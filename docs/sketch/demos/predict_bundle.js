/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./demos/predict.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./demos/predict.js":
/*!**************************!*\
  !*** ./demos/predict.js ***!
  \**************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/index */ "./src/index.ts");
/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_index__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 /**
 * Author: David Ha <hadavid@google.com>
 *
 * @fileoverview Basic p5.js sketch to show how to use sketch-rnn
 * to finish a fixed incomplete drawings, and loop through multiple
 * endings automatically.
 */



const sketch = function(p) {
  // Available SketchRNN models.
  const BASE_URL = 'https://storage.googleapis.com/quickdraw-models/sketchRNN/models/';
  const availableModels = ['bird','ant','angel','bee','bicycle','flamingo','flower','mosquito','owl','spider','yoga'];
  let model;

  // Model state.
  let modelState; // Store the hidden states of rnn's neurons.
  let temperature = 0.25; // Controls the amount of uncertainty of the model.
  let modelLoaded = false;

  let dx, dy; // Offsets of the pen strokes, in pixels.
  let x, y; // Absolute coordinates on the screen of where the pen is.
  let pen = [0,0,0]; // Current pen state, [pen_down, pen_up, pen_end].
  let previousPen = [1, 0, 0]; // Previous pen state.
  const PEN = {DOWN: 0, UP: 1, END: 2};

  /*
   * Main p5 code
   */
  p.setup = function() {
    const containerSize = document.getElementById('sketch').getBoundingClientRect();
    // Initialize the canvas.
    const screenWidth = Math.floor(containerSize.width);
    const screenHeight = p.windowHeight / 2;
    p.createCanvas(screenWidth, screenHeight);
    p.frameRate(60);

    setupNewDrawing();
    initModel(0);
    initDOMElements();
  };

  p.draw = function() {
    if (!modelLoaded) {
      return;
    }

    // If we finished the previous drawing, start a new one.
    if (previousPen[PEN.END] === 1) {
      restart();
    }

    // New state.
    const pdf = model.getPDF(modelState, temperature);
    [dx, dy, ...pen] = model.sample(pdf);

    // Only draw on the paper if the pen is still touching the paper.
    if (previousPen[PEN.DOWN] == 1) {
      p.line(x, y, x+dx, y+dy); // Draw line connecting prev point to current point.
    }

    // Update the absolute coordinates from the offsets
    x += dx;
    y += dy;

    // Update the previous pen's state to the current one we just sampled.
    previousPen = pen;
    modelState = model.update([dx, dy, ...pen], modelState);
  };
   /*
   * Helpers.
   */
  function restart() {
    // Initial strokes that we will attempt to continue.
    const strokes = [[-4,0,1,0,0],[-15,9,1,0,0],[-10,17,1,0,0],[-1,28,1,0,0],[14,13,1,0,0],[12,4,1,0,0],[22,1,1,0,0],[14,-11,1,0,0],[5,-12,1,0,0],[2,-19,1,0,0],[-12,-23,1,0,0],[-13,-7,1,0,0],[-14,-1,0,1,0]];

    // Draw strokes.
    setupNewDrawing();
    const lastPoint = drawStrokes(strokes, x, y);

    // Encode the strokes in the model.
    let newState = model.zeroState();
    newState = model.update(model.zeroInput(), newState);
    newState = model.updateStrokes(strokes, newState);

    // Reset the actual model we're using to this one that has the encoded strokes.
    modelState = model.copyState(newState);

    // Reset the pen state.
    x = lastPoint[0];
    y = lastPoint[1];
    previousPen = [0, 1, 0];

    // Reset the line colour.
    p.stroke(p.color(p.random(64, 224), p.random(64, 224), p.random(64, 224)));
  };

  function setupNewDrawing() {
    p.background(255, 255, 255, 255);
    p.strokeWeight(3.0);
    x = p.width / 2.0;
    y = p.height / 3.0;
  }

  function initModel(index) {
    modelLoaded = false;
    if (model) {
      model.dispose();
    }
    model = new _src_index__WEBPACK_IMPORTED_MODULE_0__["SketchRNN"](`${BASE_URL}${availableModels[index]}.gen.json`);

    Promise.all([model.initialize()]).then(function() {
      modelLoaded = true;
      console.log('SketchRNN model loaded.');

      // Initialize the scale factor for the model. Bigger -> large outputs
      model.setPixelFactor(5.0);
      restart();
    });
  };

  // This is very similar to the p.draw() loop, but instead of
  // sampling from the model, it uses the given set of strokes.
  function drawStrokes(strokes, startX, startY) {
    p.stroke(p.color(255,0,0));

    let x = startX;
    let y = startY;
    let dx, dy;
    let pen = [0,0,0], previousPen = [0,0,0];
    for( let i = 0; i < strokes.length; i++) {
      [dx, dy, ...pen] = strokes[i];

      if (previousPen[PEN.END] == 1) { // End of drawing.
        break;
      }

      // Only draw on the paper if the pen is still touching the paper.
      if (previousPen[PEN.DOWN] == 1) {
        p.line(x, y, x+dx, y+dy);
      }
      x += dx;
      y += dy;
      previousPen = pen;
    }
    return [x, y]; // Final coordinates.
  };

  function initDOMElements() {
    // Setup the DOM bits.
    selectModels.innerHTML = availableModels.map(m => `<option>${m}</option>`).join('');
    selectModels.addEventListener('change', () => initModel(selectModels.selectedIndex));
    inputTemperature.addEventListener('change', () => {
      temperature = parseFloat(inputTemperature.value);
      textTemperature.textContent = temperature;
    });
    textTemperature.textContent = inputTemperature.value = temperature;
  }
};

new p5(sketch, 'sketch');


/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js ***!
  \**************************************************************************/
/*! exports provided: GraphModel, loadGraphModel, version_converter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GraphModel", function() { return GraphModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadGraphModel", function() { return loadGraphModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version_converter", function() { return version; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var DataType,SaverDef,__assign=function(){return(__assign=Object.assign||function(e){for(var t,a=1,r=arguments.length;a<r;a++)for(var n in t=arguments[a])Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e}).apply(this,arguments)};function __awaiter(e,t,a,r){return new(a||(a=Promise))(function(n,s){function o(e){try{i(r.next(e))}catch(e){s(e)}}function p(e){try{i(r.throw(e))}catch(e){s(e)}}function i(e){e.done?n(e.value):new a(function(t){t(e.value)}).then(o,p)}i((r=r.apply(e,t||[])).next())})}function __generator(e,t){var a,r,n,s,o={label:0,sent:function(){if(1&n[0])throw n[1];return n[1]},trys:[],ops:[]};return s={next:p(0),throw:p(1),return:p(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function p(s){return function(p){return function(s){if(a)throw new TypeError("Generator is already executing.");for(;o;)try{if(a=1,r&&(n=2&s[0]?r.return:s[0]?r.throw||((n=r.return)&&n.call(r),0):r.next)&&!(n=n.call(r,s[1])).done)return n;switch(r=0,n&&(s=[2&s[0],n.value]),s[0]){case 0:case 1:n=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,r=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(n=(n=o.trys).length>0&&n[n.length-1])&&(6===s[0]||2===s[0])){o=0;continue}if(3===s[0]&&(!n||s[1]>n[0]&&s[1]<n[3])){o.label=s[1];break}if(6===s[0]&&o.label<n[1]){o.label=n[1],n=s;break}if(n&&o.label<n[2]){o.label=n[2],o.ops.push(s);break}n[2]&&o.ops.pop(),o.trys.pop();continue}s=t.call(e,o)}catch(e){s=[6,e],r=0}finally{a=n=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,p])}}}function getParamValue(e,t,a,r){var n=t.inputParams[e];if(n&&void 0!==n.inputIndexStart){var s=n.inputIndexStart,o=0===n.inputIndexEnd?void 0:void 0===n.inputIndexEnd?s+1:n.inputIndexEnd;if("tensor"===n.type)return getTensor(t.inputNames[n.inputIndexStart],a,r);if("tensors"===n.type)return t.inputNames.slice(s,o).map(function(e){return getTensor(e,a,r)});var p=Array.prototype.slice.call(getTensor(t.inputNames.slice(s)[0],a,r).dataSync());return"number"===n.type?p[0]:p}var i=t.attrParams[e];return i&&i.value}function getTensor(e,t,a){var r=parseNodeName(e),n=r[0],s=r[1],o=a.currentContextIds.find(function(e){return!!t[getNodeNameWithContextId(n,e)]});return void 0!==o?t[getNodeNameWithContextId(n,o)][s]:void 0}function getTensorsForCurrentContenxt(e,t,a){return t[getNodeNameWithContextId(e,a.currentContextId)]}function getNodeNameAndIndex(e,t){var a=parseNodeName(e),r=a[0],n=a[1];return[getNodeNameWithContextId(r,t&&t.currentContextId),n]}function getNodeNameWithContextId(e,t){return t?e+"-"+t:e}function parseNodeName(e){var t=e.lastIndexOf(":");return-1===t?[e,0]:[e.substring(0,t),Number(e.substring(t+1))]}function split$1(e,t){for(var a=[],r=0;r<e.length;r+=t)a.push(e.slice(r,r+t));return a}!function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(DataType||(DataType={})),function(e){!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(SaverDef||(SaverDef={}));var json=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],arithmetic=Object.freeze({json:json}),json$1=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"clip_value_min",name:"clipValueMin",type:"number"},{tfName:"clip_value_max",name:"clipValueMax",type:"number"}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"clipValueMin",name:"clipValueMin",type:"number",defaultValue:0},{tfName:"clipValueMax",name:"clipValueMax",type:"number",defaultValue:6}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],basicMath=Object.freeze({json:json$1}),json$2=[{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"}]}],control=Object.freeze({json:json$2}),json$3=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]}],convolution=Object.freeze({json:json$3}),json$4=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]}],creation=Object.freeze({json:json$4}),json$5=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],dynamic=Object.freeze({json:json$5}),json$6=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]}],evaluation=Object.freeze({json:json$6}),json$7=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],graph=Object.freeze({json:json$7}),json$8=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],image$1=Object.freeze({json:json$8}),json$9=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],logical=Object.freeze({json:json$9}),json$10=[{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],matrices=Object.freeze({json:json$10}),json$11=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],normalization=Object.freeze({json:json$11}),json$12=[{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]}],reduction=Object.freeze({json:json$12}),json$13=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool",notSupported:!0}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],sliceJoin=Object.freeze({json:json$13}),json$14=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],spectral=Object.freeze({json:json$14}),json$15=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]}],transformation=Object.freeze({json:json$15}),CONTROL_FLOW_OPS=["Switch","Merge","Enter","Exit","NextIteration"],DYNAMIC_SHAPE_OPS=["NonMaxSuppressionV2","NonMaxSuppressionV3","Where"],OperationMapper=function(){function e(){var e=[arithmetic,basicMath,control,convolution,creation,dynamic,evaluation,logical,image$1,graph,matrices,normalization,reduction,sliceJoin,spectral,transformation],t=[].concat.apply([],e.map(function(e){return e.json}));this.opMappers=t.reduce(function(e,t){return e[t.tfOpName]=t,e},{})}return Object.defineProperty(e,"Instance",{get:function(){return this._instance||(this._instance=new this)},enumerable:!0,configurable:!0}),e.prototype.isControlFlow=function(e){return CONTROL_FLOW_OPS.some(function(t){return t===e.op})},e.prototype.isDynamicShape=function(e){return DYNAMIC_SHAPE_OPS.some(function(t){return t===e.op})},e.prototype.transformGraph=function(e){var t=this,a=!1,r=!1,n=[],s=[],o=e.node.reduce(function(e,o){return e[o.name]=t.mapNode(o),t.isControlFlow(o)&&(a=!0),t.isDynamicShape(o)&&(r=!0),"Placeholder"===o.op&&n.push(e[o.name]),"Const"===o.op&&s.push(e[o.name]),e},{}),p=[],i=[];return Object.keys(o).forEach(function(e){var t=o[e];t.inputNames.forEach(function(e){var a=getNodeNameAndIndex(e)[0];t.inputs.push(o[a]),o[a].children.push(t)}),0===t.inputs.length&&p.push(t)}),Object.keys(o).forEach(function(e){var t=o[e];0===t.children.length&&i.push(t)}),{nodes:o,inputs:p,outputs:i,weights:s,placeholders:n,withControlFlow:a,withDynamicShape:r}},e.prototype.mapNode=function(e){var t=this,a=this.opMappers[e.op];if(void 0===a)throw new Error("Tensorflow Op is not supported: "+e.op);var r={name:e.name,op:e.op,category:a.category,inputNames:(e.input||[]).map(function(e){return e.startsWith("^")?e.substr(1):e}),inputs:[],children:[],inputParams:{},attrParams:{}};return null==e.attr&&(e.attr={}),null!=a.inputs&&(r.inputParams=a.inputs.reduce(function(e,t){return e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e},{})),null!=a.attrs&&(r.attrParams=a.attrs.reduce(function(a,r){var n=r.type,s=void 0;switch(r.type){case"string":void 0===(s=t.getStringParam(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(s=t.getStringParam(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number":void 0===(s=t.getNumberParam(e.attr,r.tfName,r.defaultValue||0))&&r.tfDeprecatedName&&(s=t.getNumberParam(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number[]":void 0===(s=t.getNumericArrayParam(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(s=t.getNumericArrayParam(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool":void 0===(s=t.getBoolParam(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(s=t.getBoolParam(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape":void 0===(s=t.getTensorShapeParam(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(s=t.getTensorShapeParam(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype":void 0===(s=t.getDtypeParam(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(s=t.getDtypeParam(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error("Unsupported param type: "+r.type+" for op: "+e.op)}return a[r.name]={value:s,type:n},a},{})),r},e.prototype.decodeBase64=function(e){var t=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")},e.prototype.getStringParam=function(e,t,a,r){void 0===r&&(r=!1);var n=e[t];if(void 0!==n){var s=Array.isArray(n.s)?String.fromCharCode.apply(null,n.s):this.decodeBase64(n.s);return r?s:s.toLowerCase()}return a},e.prototype.getBoolParam=function(e,t,a){var r=e[t];return r?r.b:a},e.prototype.getNumberParam=function(e,t,a){var r=e[t]||{},n=r.i?r.i:r.f?r.f:a;return"number"==typeof n?n:parseInt(n,10)},e.prototype.getDtypeParam=function(e,t,a){var r=e[t];if(r&&r.type){var n=r.type;switch("string"==typeof r.type&&(n=DataType[r.type]),n){case DataType.DT_FLOAT:return"float32";case DataType.DT_INT32:return"int32";case DataType.DT_BOOL:return"bool";default:return a}}return a},e.prototype.getTensorShapeParam=function(e,t,a){var r=e[t];if(r&&r.shape){if(r.shape.unknownRank)return;if(null!=r.shape.dim)return r.shape.dim.map(function(e){return"number"==typeof e.size?e.size:parseInt(e.size,10)})}return a},e.prototype.getNumericArrayParam=function(e,t,a){var r=e[t];return r?(r.list.f&&r.list.f.length?r.list.f:r.list.i).map(function(e){return"number"==typeof e?e:parseInt(e,10)}):a},e}(),executeOp=function(e,t,a){switch(e.op){case"BiasAdd":case"Add":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"AddN":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["addN"])(getParamValue("tensors",e,t,a))];case"FloorMod":case"Mod":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mod"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Mul":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"RealDiv":case"Div":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"FloorDiv":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["floorDiv"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Sub":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Minimum":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["minimum"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Maximum":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Pow":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pow"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"SquaredDifference":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squaredDifference"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$1=function(e,t,a){switch(e.op){case"Abs":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(getParamValue("x",e,t,a))];case"Acos":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["acos"])(getParamValue("x",e,t,a))];case"Acosh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["acosh"])(getParamValue("x",e,t,a))];case"Asin":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["asin"])(getParamValue("x",e,t,a))];case"Asinh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["asinh"])(getParamValue("x",e,t,a))];case"Atan":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atan"])(getParamValue("x",e,t,a))];case"Atan2":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atan2"])(getParamValue("x",e,t,a),getParamValue("y",e,t,a))];case"Atanh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atanh"])(getParamValue("x",e,t,a))];case"Ceil":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ceil"])(getParamValue("x",e,t,a))];case"Cos":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cos"])(getParamValue("x",e,t,a))];case"Cosh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cosh"])(getParamValue("x",e,t,a))];case"Elu":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["elu"])(getParamValue("x",e,t,a))];case"Erf":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["erf"])(getParamValue("x",e,t,a))];case"Exp":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["exp"])(getParamValue("x",e,t,a))];case"Expm1":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expm1"])(getParamValue("x",e,t,a))];case"Floor":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["floor"])(getParamValue("x",e,t,a))];case"Log":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(getParamValue("x",e,t,a))];case"Log1p":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log1p"])(getParamValue("x",e,t,a))];case"Neg":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"])(getParamValue("x",e,t,a))];case"Reciprocal":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reciprocal"])(getParamValue("x",e,t,a))];case"Relu":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"])(getParamValue("x",e,t,a))];case"Round":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["round"])(getParamValue("x",e,t,a))];case"Selu":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["selu"])(getParamValue("x",e,t,a))];case"Sigmoid":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sigmoid"])(getParamValue("x",e,t,a))];case"Sin":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sin"])(getParamValue("x",e,t,a))];case"Sign":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sign"])(getParamValue("x",e,t,a))];case"Sinh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sinh"])(getParamValue("x",e,t,a))];case"Softplus":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softplus"])(getParamValue("x",e,t,a))];case"Sqrt":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(getParamValue("x",e,t,a))];case"Square":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["square"])(getParamValue("x",e,t,a))];case"Tanh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tanh"])(getParamValue("x",e,t,a))];case"Tan":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tan"])(getParamValue("x",e,t,a))];case"Relu6":case"ClipByValue":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(getParamValue("x",e,t,a),getParamValue("clipValueMin",e,t,a),getParamValue("clipValueMax",e,t,a))];case"Rsqrt":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["rsqrt"])(getTensor(e.inputNames[0],t,a))];case"Prod":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["prod"])(getParamValue("x",e,t,a),getParamValue("axes",e,t,a))];case"LeakyRelu":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["leakyRelu"])(getParamValue("x",e,t,a),getParamValue("alpha",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},TensorArray=function(){function e(t,a,r,n,s,o,p){this.name=t,this.dtype=a,this.maxSize=r,this.elementShape=n,this.identicalElementShapes=s,this.dynamicSize=o,this.clearAfterRead=p,this.tensors=[],this.closed_=!1,this.id=e.nextId++}return Object.defineProperty(e.prototype,"closed",{get:function(){return this.closed_},enumerable:!0,configurable:!0}),e.prototype.clearAndClose=function(){this.tensors.forEach(function(e){return e.tensor.dispose()}),this.tensors=[],this.closed_=!0},e.prototype.size=function(){return this.tensors.length},e.prototype.read=function(e){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(e<0||e>=this.tensors.length)throw new Error("Tried to read from index "+e+", but array size is: "+this.tensors.length);var t=this.tensors[e];if(t.cleared)throw new Error("TensorArray "+this.name+": Could not read index "+e+" twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor},e.prototype.readMany=function(e){var t=this;return e.map(function(e){return t.read(e)})},e.prototype.write=function(e,t){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error("Tried to write to index "+e+", but array is not resizeable and size is: "+this.maxSize);var a=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+e+",\n          because the value dtype is "+t.dtype+", but TensorArray dtype is "+this.dtype+".");if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),this.assertShapesMatchAllowUndefinedSize(this.elementShape,t.shape,"TensorArray "+this.name+": Could not write to TensorArray index "+e+"."),a&&a.read)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+e+", because it has already been read.");if(a&&a.written)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+e+", because it has already been written.");a.tensor=t,a.written=!0,this.tensors[e]=a},e.prototype.writeMany=function(e,t){var a=this;if(e.length!==t.length)throw new Error("TensorArray "+this.name+": could not write multiple tensors,because the index size: "+e.length+" is not the same as tensors size: "+t.length+".");e.forEach(function(e,r){return a.write(e,t[r])})},e.prototype.gather=function(e,t){if(t&&t!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but gather requested dtype "+t);if(!e){e=[];for(var a=0;a<this.size();a++)e.push(a)}if(0===e.length)return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor"])([],[0].concat(this.elementShape));var r=this.readMany(e);return this.assertShapesMatchAllowUndefinedSize(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"])(r,0)},e.prototype.concat=function(e){if(e&&e!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but concat requested dtype "+e);if(0===this.size())return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor"])([],[0].concat(this.elementShape));for(var t=[],a=0;a<this.size();a++)t.push(a);var r=this.readMany(t);return this.assertShapesMatchAllowUndefinedSize(this.elementShape,r[0].shape,"TensorArray shape mismatch: tensor array shape ("+this.elementShape+") vs first tensor shape ("+r[0].shape+")"),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"])(r,0)},e.prototype.scatter=function(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+t.dtype);if(e.length!==t.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: "+e.length+" vs. "+t.shape[0]);var a=Math.max.apply(Math,e);if(!this.dynamicSize&&a>=this.maxSize)throw new Error("Max index must be < array size ("+a+"  vs. "+this.maxSize+")");this.writeMany(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"])(t,0))},e.prototype.split=function(e,t){var a=this;if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+t.dtype);var r=0,n=e.map(function(e){return r+=e});if(r!==t.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        "+r+", and tensor's shape is: "+t.shape);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error("TensorArray's size is not equal to the size of lengths ("+this.maxSize+" vs. "+e.length+"), and the TensorArray is not marked as dynamically resizeable");var s=0===r?0:t.size/r,o=[];Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){t=t.reshape([1,r,s]);for(var p=0;p<e.length;++p){var i=[0,0===p?0:n[p-1],0],u=[1,e[p],s];o[p]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice"])(t,i,u).reshape(a.elementShape)}return o});for(var p=[],i=0;i<e.length;i++)p[i]=i;this.writeMany(p,o)},e.prototype.assertShapesMatchAllowUndefinedSize=function(e,t,a){void 0===a&&(a=""),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(this.shapesEqualAllowUndefinedSize(e,t),function(){return a+" Shapes "+e+" and "+t+" must match"})},e.prototype.shapesEqualAllowUndefinedSize=function(e,t){if(e.length!==t.length)return!1;for(var a=0;a<e.length;a++)if(-1!==e[a]&&-1!==t[a]&&e[a]!==t[a])return!1;return!0},e.nextId=0,e}();function executeOp$2(e,t,a){return __awaiter(this,void 0,void 0,function(){var r,n,s,o,p,i,u,m,c,l,d,y,f,h,g,N,x,b,V,P,T,O,v,S,_,w,A,D,E,I,M,C,k,j,z;return __generator(this,function(F){switch(F.label){case 0:switch(e.op){case"LoopCond":return[3,1];case"Switch":return[3,2];case"Merge":return[3,4];case"Enter":return[3,5];case"Exit":return[3,6];case"NextIteration":return[3,7];case"TensorArrayV3":return[3,8];case"TensorArrayWriteV3":return[3,9];case"TensorArrayReadV3":return[3,10];case"TensorArrayGatherV3":return[3,11];case"TensorArrayScatterV3":return[3,12];case"TensorArrayConcatV3":return[3,13];case"TensorArraySplitV3":return[3,14];case"TensorArraySizeV3":return[3,15];case"TensorArrayCloseV3":return[3,16]}return[3,17];case 1:return[2,[getParamValue("pred",e,t,a).clone()]];case 2:return r=getParamValue("pred",e,t,a),n=getParamValue("data",e,t,a),[4,r.data()];case 3:return[2,F.sent()[0]?[void 0,n.clone()]:[n.clone(),void 0]];case 4:return[2,(s=e.inputNames.find(function(e){return void 0!==getTensor(e,t,a)}))?[getTensor(s,t,a).clone()]:void 0];case 5:return o=getParamValue("frameName",e,t,a),p=getParamValue("tensor",e,t,a),a.enterFrame(o),[2,[p.clone()]];case 6:return i=getParamValue("tensor",e,t,a),a.exitFrame(),[2,[i.clone()]];case 7:return u=getParamValue("tensor",e,t,a),a.nextIteration(),[2,[u.clone()]];case 8:return m=getParamValue("size",e,t,a),c=getParamValue("dtype",e,t,a),l=getParamValue("elementShape",e,t,a),d=getParamValue("dynamicSize",e,t,a),y=getParamValue("clearAfterRead",e,t,a),f=getParamValue("identicalElementShapes",e,t,a),h=getParamValue("name",e,t,a),g=new TensorArray(h,c,m,l,f,d,y),a.addTensorArray(g),[2,[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(g.id),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(1)]];case 9:return N=getParamValue("tensorArrayId",e,t,a),x=getParamValue("index",e,t,a),b=getParamValue("tensor",e,t,a),a.getTensorArray(N).write(x,b),[2,[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(1)]];case 10:return V=getParamValue("tensorArrayId",e,t,a),P=getParamValue("index",e,t,a),[2,[a.getTensorArray(V).read(P)]];case 11:return T=getParamValue("tensorArrayId",e,t,a),O=getParamValue("indices",e,t,a),v=getParamValue("dtype",e,t,a),[2,[a.getTensorArray(T).gather(O,v)]];case 12:return S=getParamValue("tensorArrayId",e,t,a),_=getParamValue("indices",e,t,a),w=getParamValue("tensor",e,t,a),a.getTensorArray(S).scatter(_,w),[2,[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(1)]];case 13:return A=getParamValue("tensorArrayId",e,t,a),D=a.getTensorArray(A),E=getParamValue("dtype",e,t,a),[2,[D.concat(E)]];case 14:return I=getParamValue("tensorArrayId",e,t,a),M=getParamValue("tensor",e,t,a),C=getParamValue("lengths",e,t,a),a.getTensorArray(I).split(C,M),[2,[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(1)]];case 15:return k=getParamValue("tensorArrayId",e,t,a),j=a.getTensorArray(k),[2,[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(j.size(),"int32")]];case 16:return z=getParamValue("tensorArrayId",e,t,a),a.getTensorArray(z).clearAndClose(),[2,[]];case 17:throw TypeError("Node type "+e.op+" is not implemented")}})})}var executeOp$3=function(e,t,a){switch(e.op){case"Conv1D":var r=getParamValue("stride",e,t,a),n=getParamValue("pad",e,t,a),s=getParamValue("dataFormat",e,t,a).toUpperCase(),o=getParamValue("dilation",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv1d"])(getParamValue("x",e,t,a),getParamValue("filter",e,t,a),r,n,s,o)];case"Conv2D":r=getParamValue("strides",e,t,a),n=getParamValue("pad",e,t,a),s=getParamValue("dataFormat",e,t,a).toUpperCase();var p=getParamValue("dilations",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"])(getParamValue("x",e,t,a),getParamValue("filter",e,t,a),[r[1],r[2]],n,s,[p[0],p[1]])];case"Conv2DBackpropInput":case"Conv2dTranspose":var i=getParamValue("outputShape",e,t,a);r=getParamValue("strides",e,t,a),n=getParamValue("pad",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2dTranspose"])(getParamValue("x",e,t,a),getParamValue("filter",e,t,a),i,[r[1],r[2]],n)];case"DepthwiseConv2dNative":case"DepthwiseConv2d":r=getParamValue("strides",e,t,a),n=getParamValue("pad",e,t,a),p=getParamValue("dilations",e,t,a),s=getParamValue("dataFormat",e,t,a).toUpperCase();return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthwiseConv2d"])(getParamValue("input",e,t,a),getParamValue("filter",e,t,a),[r[1],r[2]],n,s,[p[0],p[1]])];case"AvgPool":r=getParamValue("strides",e,t,a),n=getParamValue("pad",e,t,a);var u=getParamValue("kernelSize",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["avgPool"])(getParamValue("x",e,t,a),[u[1],u[2]],[r[1],r[2]],n)];case"MaxPool":r=getParamValue("strides",e,t,a),n=getParamValue("pad",e,t,a),u=getParamValue("kernelSize",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maxPool"])(getParamValue("x",e,t,a),[u[1],u[2]],[r[1],r[2]],n)];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$4=function(e,t,a){switch(e.op){case"Fill":var r=getParamValue("shape",e,t,a),n=getParamValue("dtype",e,t,a),s=getParamValue("value",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fill"])(r,s,n)];case"LinSpace":var o=getParamValue("start",e,t,a),p=getParamValue("stop",e,t,a),i=getParamValue("num",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["linspace"])(o,p,i)];case"OneHot":var u=getParamValue("indices",e,t,a),m=getParamValue("depth",e,t,a),c=getParamValue("onValue",e,t,a),l=getParamValue("offValue",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["oneHot"])(u,m,c,l)];case"Ones":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ones"])(getParamValue("shape",e,t,a),getParamValue("dtype",e,t,a))];case"OnesLike":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(getParamValue("x",e,t,a))];case"RandomUniform":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"])(getParamValue("shape",e,t,a),getParamValue("minval",e,t,a),getParamValue("maxval",e,t,a),getParamValue("dtype",e,t,a))];case"Range":o=getParamValue("start",e,t,a);var d=getParamValue("stop",e,t,a),y=getParamValue("step",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["range"])(o,d,y,getParamValue("dtype",e,t,a))];case"TruncatedNormal":r=getParamValue("shape",e,t,a);var f=getParamValue("mean",e,t,a),h=getParamValue("stdDev",e,t,a),g=getParamValue("seed",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["truncatedNormal"])(r,f,h,getParamValue("dtype",e,t,a),g)];case"Zeros":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])(getParamValue("shape",e,t,a),getParamValue("dtype",e,t,a))];case"ZerosLike":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zerosLike"])(getParamValue("x",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}};function executeOp$5(e,t,a){return __awaiter(this,void 0,void 0,function(){var r,n,s,o,p;return __generator(this,function(i){switch(i.label){case 0:switch(e.op){case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":return[3,1];case"Where":return[3,3];case"ListDiff":return[3,5]}return[3,7];case 1:return r=getParamValue("boxes",e,t,a),n=getParamValue("scores",e,t,a),s=getParamValue("maxOutputSize",e,t,a),o=getParamValue("iouThreshold",e,t,a),p=getParamValue("scoreThreshold",e,t,a),[4,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].nonMaxSuppressionAsync(r,n,s,o,p)];case 2:return[2,[i.sent()]];case 3:return[4,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["whereAsync"])(getParamValue("condition",e,t,a))];case 4:return[2,[i.sent()]];case 5:return[4,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["setdiff1dAsync"])(getParamValue("x",e,t,a),getParamValue("y",e,t,a))];case 6:return[2,i.sent()];case 7:throw TypeError("Node type "+e.op+" is not implemented")}})})}var executeOp$6=function(e,t,a){switch(e.op){case"TopKV2":var r=getParamValue("x",e,t,a),n=getParamValue("k",e,t,a),s=getParamValue("sorted",e,t,a),o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["topk"])(r,n,s);return[o.values,o.indices];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$7=function(e,t,a){switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":var r=getParamValue("default",e,t,a);return[getTensor(e.name,t,a)||r];case"Placeholder":return[getTensor(e.name,t,a)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[getParamValue("x",e,t,a).clone()];case"IdentityN":return getParamValue("x",e,t,a).map(function(e){return e.clone()});case"Snapshot":return[getParamValue("x",e,t,a).clone()];case"Shape":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(getParamValue("x",e,t,a).shape,"int32")];case"ShapeN":return getParamValue("x",e,t,a).map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(e.shape)});case"Size":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(getParamValue("x",e,t,a).size,"int32")];case"Rank":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(getParamValue("x",e,t,a).rank,"int32")];case"NoOp":return[];case"Print":var n=getParamValue("x",e,t,a),s=getParamValue("data",e,t,a),o=getParamValue("message",e,t,a),p=getParamValue("summarize",e,t,a);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(var i=0;i<s.length;i++)console.log(Array.prototype.slice.call(s[i].dataSync()).slice(0,p));return[n];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$8=function(e,t,a){switch(e.op){case"ResizeBilinear":var r=getParamValue("images",e,t,a),n=getParamValue("size",e,t,a),s=getParamValue("alignCorners",e,t,a);return[_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].resizeBilinear(r,[n[0],n[1]],s)];case"ResizeNearestNeighbor":r=getParamValue("images",e,t,a),n=getParamValue("size",e,t,a),s=getParamValue("alignCorners",e,t,a);return[_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].resizeNearestNeighbor(r,[n[0],n[1]],s)];case"CropAndResize":var o=getParamValue("image",e,t,a),p=getParamValue("boxes",e,t,a),i=getParamValue("boxInd",e,t,a),u=getParamValue("cropSize",e,t,a),m=getParamValue("method",e,t,a),c=getParamValue("extrapolationValue",e,t,a);return[_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].cropAndResize(o,p,i,u,m,c)];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$9=function(e,t,a){switch(e.op){case"Equal":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equal"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"NotEqual":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["notEqual"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Greater":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greater"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"GreaterEqual":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greaterEqual"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Less":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["less"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"LessEqual":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["lessEqual"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"LogicalAnd":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"LogicalNot":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalNot"])(getParamValue("a",e,t,a))];case"LogicalOr":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalOr"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Select":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["where"])(getParamValue("condition",e,t,a),getParamValue("a",e,t,a),getParamValue("b",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$10=function(e,t,a){switch(e.op){case"BatchMatMul":case"MatMul":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["matMul"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a),getParamValue("transposeA",e,t,a),getParamValue("transposeB",e,t,a))];case"Transpose":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(getParamValue("x",e,t,a),getParamValue("perm",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$11=function(e,t,a){switch(e.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm"])(getParamValue("x",e,t,a),getParamValue("mean",e,t,a),getParamValue("variance",e,t,a),getParamValue("offset",e,t,a),getParamValue("scale",e,t,a),getParamValue("epsilon",e,t,a))];case"LRN":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["localResponseNormalization"])(getParamValue("x",e,t,a),getParamValue("radius",e,t,a),getParamValue("bias",e,t,a),getParamValue("alpha",e,t,a),getParamValue("beta",e,t,a))];case"Softmax":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"])(getParamValue("x",e,t,a))];case"LogSoftmax":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logSoftmax"])(getParamValue("x",e,t,a))];case"SparseToDense":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sparseToDense"])(getParamValue("sparseIndices",e,t,a),getParamValue("outputShape",e,t,a),getParamValue("sparseValues",e,t,a),getParamValue("defaultValue",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$12=function(e,t,a){switch(e.op){case"Max":var r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(getParamValue("x",e,t,a),r,n)];case"Mean":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(getParamValue("x",e,t,a),r,n)];case"Min":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["min"])(getParamValue("x",e,t,a),r,n)];case"Sum":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(getParamValue("x",e,t,a),r,n)];case"All":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["all"])(getParamValue("x",e,t,a),r,n)];case"Any":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["any"])(getParamValue("x",e,t,a),r,n)];case"ArgMax":r=getParamValue("axis",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMax"])(getParamValue("x",e,t,a),r)];case"ArgMin":r=getParamValue("axis",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMin"])(getParamValue("x",e,t,a),r)];case"Prod":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["prod"])(getParamValue("x",e,t,a),r,n)];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$13=function(e,t,a){switch(e.op){case"ConcatV2":case"Concat":var r=getParamValue("axis",e,t,a),n=getParamValue("tensors",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"])(n,r)];case"GatherV2":case"Gather":r=getParamValue("axis",e,t,a);var s=getParamValue("x",e,t,a),o=getParamValue("indices",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["gather"])(s,o.asType("int32"),r)];case"ReverseV2":case"Reverse":r=getParamValue("axis",e,t,a),s=getParamValue("x",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse"])(s,r)];case"Slice":var p=getParamValue("begin",e,t,a),i=getParamValue("size",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice"])(getParamValue("x",e,t,a),p,i)];case"StridedSlice":p=getParamValue("begin",e,t,a);var u=getParamValue("end",e,t,a),m=getParamValue("strides",e,t,a),c=getParamValue("beginMask",e,t,a),l=getParamValue("endMask",e,t,a),d=getParamValue("ellipsisMask",e,t,a),y=getParamValue("newAxisMask",e,t,a),f=getParamValue("shrinkAxisMask",e,t,a),h=getParamValue("x",e,t,a);if(1===p.length&&h.shape.length>1)for(var g=1;g<h.shape.length;g++)p.push(0),u.push(h.shape[g]),m.push(m[0]);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stridedSlice"])(h,p,u,m,c,l,d,y,f)];case"Pack":return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=getParamValue("axis",e,t,a),n=getParamValue("tensors",e,t,a),s=n[0].shape,o=n[0].squeeze().shape,p=n.map(function(e){var t=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(e.shape,s);if(!t&&!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(e.squeeze().shape,o))throw new Error("the input tensors shape does not match");return t?e:e.reshape(s)});return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"])(p,r)]});case"Unpack":return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=getParamValue("axis",e,t,a),n=getParamValue("tensor",e,t,a);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"])(n,r)});case"Tile":var N=getParamValue("reps",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tile"])(getParamValue("x",e,t,a),N)];case"Split":case"SplitV":r=getParamValue("axis",e,t,a);var x=getParamValue("numOrSizeSplits",e,t,a);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"])(getParamValue("x",e,t,a),x,r);case"ScatterNd":o=getParamValue("indices",e,t,a);var b=getParamValue("values",e,t,a),V=getParamValue("shape",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scatterND"])(o,b,V)];case"GatherNd":var P=getParamValue("x",e,t,a);o=getParamValue("indices",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["gatherND"])(P,o)];case"SparseToDense":o=getParamValue("sparseIndices",e,t,a),V=getParamValue("outputShape",e,t,a);var T=getParamValue("sparseValues",e,t,a),O=getParamValue("defaultValue",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sparseToDense"])(o,T,V,T.dtype===O.dtype?O:O.asType(T.dtype))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$14=function(e,t,a){switch(e.op){case"FFT":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fft"])(getParamValue("x",e,t,a))];case"IFFT":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ifft"])(getParamValue("x",e,t,a))];case"RFFT":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["rfft"])(getParamValue("x",e,t,a))];case"IRFFT":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["irfft"])(getParamValue("x",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$15=function(e,t,a){switch(e.op){case"Cast":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cast"])(getParamValue("x",e,t,a),getParamValue("dtype",e,t,a))];case"ExpandDims":var r=getParamValue("axis",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"])(getParamValue("x",e,t,a),r)];case"Squeeze":r=getParamValue("axis",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squeeze"])(getParamValue("x",e,t,a),r)];case"Reshape":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"])(getParamValue("x",e,t,a),getParamValue("shape",e,t,a))];case"PadV2":case"Pad":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad"])(getParamValue("x",e,t,a),split$1(getParamValue("padding",e,t,a),2),getParamValue("constantValue",e,t,a))];case"SpaceToBatchND":var n=getParamValue("blockShape",e,t,a),s=split$1(getParamValue("paddings",e,t,a),2);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["spaceToBatchND"])(getParamValue("x",e,t,a),n,s)];case"BatchToSpaceND":n=getParamValue("blockShape",e,t,a);var o=split$1(getParamValue("crops",e,t,a),2);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchToSpaceND"])(getParamValue("x",e,t,a),n,o)];case"DepthToSpace":var p=getParamValue("blockSize",e,t,a),i=getParamValue("dataFormat",e,t,a).toUpperCase();return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthToSpace"])(getParamValue("x",e,t,a),p,i)];default:throw TypeError("Node type "+e.op+" is not implemented")}};function executeOp$16(e,t,a){var r=function(e,t,a){switch(e.category){case"arithmetic":return executeOp(e,t,a);case"basic_math":return executeOp$1(e,t,a);case"control":return executeOp$2(e,t,a);case"convolution":return executeOp$3(e,t,a);case"creation":return executeOp$4(e,t,a);case"dynamic":return executeOp$5(e,t,a);case"evaluation":return executeOp$6(e,t,a);case"image":return executeOp$8(e,t,a);case"graph":return executeOp$7(e,t,a);case"logical":return executeOp$9(e,t,a);case"matrices":return executeOp$10(e,t,a);case"normalization":return executeOp$11(e,t,a);case"reduction":return executeOp$12(e,t,a);case"slice_join":return executeOp$13(e,t,a);case"spectral":return executeOp$14(e,t,a);case"transformation":return executeOp$15(e,t,a);default:throw TypeError("Node type "+e.op+" is not implemented")}}(e,t,a);return r instanceof Promise?r.then(function(e){return[].concat(e)}):[].concat(r)}var ExecutionContext=function(){function e(e,t){this.weightMap=e,this.tensorArrayMap=t,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}return e.prototype.newFrame=function(e,t){return{id:e,frameName:t,iterationId:0}},Object.defineProperty(e.prototype,"currentContext",{get:function(){return this.contexts},set:function(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"currentContextId",{get:function(){return this._currentContextIds[0]},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"currentContextIds",{get:function(){return this._currentContextIds},enumerable:!0,configurable:!0}),e.prototype.generateCurrentContextIds=function(){for(var e=[],t=0;t<this.contexts.length-1;t++){var a=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(a))}e.push(""),this._currentContextIds=e},e.prototype.contextIdforContexts=function(e){return e?e.map(function(e){return 0===e.id&&0===e.iterationId?"":e.frameName+"-"+e.iterationId}).join("/"):""},e.prototype.enterFrame=function(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))},e.prototype.exitFrame=function(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()},e.prototype.nextIteration=function(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");this.contexts=this.contexts.slice(),this.lastId++;var e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))},e.prototype.getWeight=function(e){return this.weightMap[e]},e.prototype.addTensorArray=function(e){this.tensorArrayMap[e.id]=e},e.prototype.getTensorArray=function(e){return this.tensorArrayMap[e]},e}(),GraphExecutor=function(){function e(e){this.graph=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this.placeholders=e.placeholders,this._outputs=e.outputs,this.compile()}return Object.defineProperty(e.prototype,"weightMap",{get:function(){return this._weightMap},set:function(e){var t=Object.keys(e).map(function(t){return e[t].map(function(e){return e.id})});this.weightIds=[].concat.apply([],t),this._weightMap=e},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"inputs",{get:function(){return this.placeholders.map(function(e){return{name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}})},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"outputs",{get:function(){return this._outputs.map(function(e){return{name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}})},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"inputNodes",{get:function(){return this.placeholders.map(function(e){return e.name})},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"outputNodes",{get:function(){return this.outputs.map(function(e){return e.name})},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"isControlFlowModel",{get:function(){return this.graph.withControlFlow},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"isDynamicShapeModel",{get:function(){return this.graph.withDynamicShape},enumerable:!0,configurable:!0}),e.prototype.compile=function(e){if(!this.graph.withControlFlow&&!this.graph.withDynamicShape){var t=[],a=e||this.graph.placeholders,r=a.map(function(e){return e.name}).sort().join(this.SEPERATOR);if(!this.compiledMap.get(r)){for(var n=a.concat(this.graph.weights),s={};n.length>0;){var o=n.pop();s[o.name]=!0,t.push(o),o.children.forEach(function(e){!s[e.name]&&e.inputNames.every(function(e){var t=getNodeNameAndIndex(e)[0];return s[t]})&&n.push(e)})}this.compiledMap.set(r,t)}}},e.prototype.execute=function(e,t,a){var r=this;void 0===t&&(t=!0);var n=Object.keys(e).sort();this.checkInput(e,t),this.checkInputShapeAndType(e,t),this.compile(n.map(function(e){return r.graph.nodes[e]}));var s=this.calculateOutputs(a);this.checkOutput(this.compiledMap.get(n.join(this.SEPERATOR)),s);var o={};return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=new ExecutionContext(r._weightMap,o),a=__assign({},r.weightMap,e),p=r.getFrozenTensorIds(a),i={},u=r.compiledMap.get(n.join(r.SEPERATOR)),m=0;m<u.length;m++){var c=u[m];if(a[c.name]||(a[c.name]=executeOp$16(c,a,t),r.checkTensorForDisposal(c.name,c,a,t,p,s,i)),s.every(function(e){return!!a[e]}))break}return r.findOutputs(a,t,s)})},e.prototype.getFrozenTensorIds=function(e){var t=[].concat.apply([],Object.keys(e).map(function(t){return e[t]}).map(function(e){return e.map(function(e){return e.id})}));return new Set(t)},e.prototype.checkTensorForDisposal=function(e,t,a,r,n,s,o){"control"!==t.category&&-1===s.indexOf(e)&&(a[e].forEach(function(e){null!=e&&(o[e.id]=(o[e.id]||0)+t.children.length)}),t.inputs.forEach(function(e){if("control"!==e.category){var t=getTensorsForCurrentContenxt(e.name,a,r);null!=t&&t.forEach(function(e){if(e&&!n.has(e.id)){var t=o[e.id];1===t?(e.dispose(),delete o[e.id]):null!=t&&o[e.id]--}})}}))},e.prototype.executeAsync=function(e,t){return __awaiter(this,void 0,void 0,function(){var a,r,n,s,o,p,i,u,m=this;return __generator(this,function(c){switch(c.label){case 0:return this.checkInput(e,!1),this.checkInputShapeAndType(e,!1),a={},r=new ExecutionContext(this._weightMap,a),n=this.calculateOutputs(t),[4,this.executeWithControlFlow(e,r,n)];case 1:return s=c.sent(),o=this.findOutputs(s,r,t),p=Object.keys(o).map(function(e){return o[e].id}),i=Object.keys(e).map(function(t){return e[t].map(function(e){return e.id})}),u=[].concat.apply([],i),Object.keys(s).forEach(function(e){s[e].forEach(function(e){e&&!e.isDisposed&&-1===p.indexOf(e.id)&&-1===u.indexOf(e.id)&&-1===m.weightIds.indexOf(e.id)&&e.dispose()})}),[2,o]}})})},e.prototype.executeWithControlFlow=function(e,t,a){return __awaiter(this,void 0,void 0,function(){var r,n,s,o,p,i,u,m,c=this;return __generator(this,function(l){switch(l.label){case 0:r=Object.keys(e),n=r.map(function(e){return c.graph.nodes[e]}),s=n.concat(this.graph.weights).map(function(e){return{node:e,contexts:t.currentContext}}),o=__assign({},this.weightMap,e),p={},i=this.getFrozenTensorIds(o),u={},l.label=1;case 1:return s.length>0?(m=this.processStack(n,s,t,o,u,i,a,p),[4,Promise.all(m)]):[3,3];case 2:return l.sent(),[3,1];case 3:return[2,o]}})})},e.prototype.processStack=function(e,t,a,r,n,s,o,p){for(var i=this,u=[],m=function(){var m=t.pop();a.currentContext=m.contexts;var l="";if("Enter"===m.node.op&&getParamValue("isConstant",m.node,r,a)&&(l=getNodeNameAndIndex(m.node.name,a)[0]),-1===e.indexOf(m.node)){var d=executeOp$16(m.node,r,a);l||(l=getNodeNameAndIndex(m.node.name,a)[0]);var y=a.currentContext;d instanceof Promise?u.push(d.then(function(e){return r[l]=e,a.currentContext=y,i.checkTensorForDisposal(l,m.node,r,a,s,o,p),i.processChildNodes(m.node,t,a,r,n),e})):(r[l]=d,c.checkTensorForDisposal(l,m.node,r,a,s,o,p),c.processChildNodes(m.node,t,a,r,n))}else c.processChildNodes(m.node,t,a,r,n)},c=this;t.length>0;)m();return u},e.prototype.processChildNodes=function(e,t,a,r,n){e.children.forEach(function(e){var s=getNodeNameAndIndex(e.name,a)[0];n[s]||("Merge"===e.op?e.inputNames.some(function(e){return!!getTensor(e,r,a)})&&(n[s]=!0,t.push({contexts:a.currentContext,node:e})):e.inputNames.every(function(e){return!!getTensor(e,r,a)})&&(n[s]=!0,t.push({contexts:a.currentContext,node:e})))})},e.prototype.calculateOutputs=function(e){return!e||e instanceof Array||(e=[e]),e||this.graph.outputs.map(function(e){return e.name})},e.prototype.findOutputs=function(e,t,a){return this.calculateOutputs(a).reduce(function(a,r){return a[r]=getTensor(r,e,t),a},{})},e.prototype.dispose=function(){var e=this;Object.keys(this.weightMap).forEach(function(t){return e.weightMap[t].forEach(function(e){return e.dispose()})})},e.prototype.checkInputShapeAndType=function(e,t){void 0===t&&(t=!0),this.placeholders.forEach(function(a){var r=e[a.name];if(t||r){var n=r[0];if(a.attrParams.shape&&a.attrParams.shape.value){var s=a.attrParams.shape.value,o=s.length===n.shape.length&&n.shape.every(function(e,t){return-1===s[t]||s[t]===e});_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(o,function(){return"The shape of dict['"+a.name+"'] provided in model.execute(dict) must be ["+s+"], but was ["+n.shape+"]"})}a.attrParams.dtype&&a.attrParams.dtype.value&&_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(n.dtype===a.attrParams.dtype.value,function(){return"The dtype of dict['"+a.name+"'] provided in model.execute(dict) must be "+a.attrParams.dtype.value+", but was "+n.dtype})}})},e.prototype.checkInput=function(e,t){var a=this;void 0===t&&(t=!0);var r=Object.keys(e),n=[],s=[];this.inputNodes.forEach(function(e){-1===r.indexOf(e)&&n.push(e)}),r.forEach(function(e){-1===a.inputNodes.indexOf(e)&&s.push(e)});var o=s.filter(function(e){return!a.graph.nodes[e]});if(n.length>0&&t)throw new Error("The dict provided in model.execute(dict) has the keys ["+r+"], but is missing the required keys: ["+n+"].");if(s.length>0&&t)throw new Error("The dict provided in model.execute(dict) has unused keys: ["+s+"]. Please provide only the following keys: ["+this.inputNodes+"].");if(o.length>0)throw new Error("The dict provided in model.execute(dict) has keys: ["+o+"] not part of model graph.")},e.prototype.checkOutput=function(e,t){var a=e.map(function(e){return e.name}),r=[];if(t.forEach(function(e){var t=parseNodeName(e)[0];-1===a.indexOf(t)&&r.push(t)}),r.length>0)throw new Error("The following outputs are not generated by the execution: ["+r+"].")},e}(),TFHUB_SEARCH_PARAM="?tfjs-format=file",DEFAULT_MODEL_NAME="model.json",GraphModel=function(){function e(e,t){void 0===t&&(t={}),this.modelUrl=e,this.loadOptions=t,this.version="n/a",null==t&&(this.loadOptions={})}return Object.defineProperty(e.prototype,"modelVersion",{get:function(){return this.version},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"inputNodes",{get:function(){return this.executor.inputNodes},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"outputNodes",{get:function(){return this.executor.outputNodes},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"inputs",{get:function(){return this.executor.inputs},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"outputs",{get:function(){return this.executor.outputs},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"weights",{get:function(){return this.executor.weightMap},enumerable:!0,configurable:!0}),e.prototype.findIOHandler=function(){var e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].browserHTTPRequest(e,this.loadOptions);else{var t=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].getLoadHandlers(e,this.loadOptions.onProgress);if(0===t.length)t.push(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error("Found more than one ("+t.length+") load handlers for URL '"+[e]+"'");this.handler=t[0]}},e.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var e,t,a;return __generator(this,function(r){switch(r.label){case 0:if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");return[4,this.handler.load()];case 1:return e=r.sent(),t=e.modelTopology,this.version=t.versions.producer+"."+t.versions.minConsumer,a=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].decodeWeights(e.weightData,e.weightSpecs),this.executor=new GraphExecutor(OperationMapper.Instance.transformGraph(t)),this.executor.weightMap=this.convertTensorMapToTensorsMap(a),[2,!0]}})})},e.prototype.predict=function(e,t){return this.execute_(e,!0,this.outputNodes)},e.prototype.constructTensorMap=function(e){var t=e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]?[e]:e;if(t.length!==this.inputNodes.length)throw new Error("Input tensor count mismatch,the graph model has "+this.inputNodes.length+" placeholders, while there are "+t.length+" input tensors.");return this.inputNodes.reduce(function(e,a,r){return e[a]=t[r],e},{})},e.prototype.execute=function(e,t){return this.execute_(e,!1,t)},e.prototype.execute_=function(e,t,a){if(void 0===t&&(t=!0),a=a||this.outputNodes,(e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]||Array.isArray(e))&&(e=this.constructTensorMap(e)),this.executor.isControlFlowModel||this.executor.isDynamicShapeModel)throw new Error("The model contains control flow or dynamic shape ops, please use executeAsync method");var r=this.executor.execute(this.convertTensorMapToTensorsMap(e),t,a),n=Object.keys(r);return Array.isArray(a)&&a.length>1?a.map(function(e){return r[e]}):r[n[0]]},e.prototype.executeAsync=function(e,t){return __awaiter(this,void 0,void 0,function(){var a,r;return __generator(this,function(n){switch(n.label){case 0:if(!this.executor.isControlFlowModel&&!this.executor.isDynamicShapeModel)throw new Error("The model does not contain control flow or dynamic shape ops, please use execute method for better performance.");return t=t||this.outputNodes,(e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]||Array.isArray(e))&&(e=this.constructTensorMap(e)),[4,this.executor.executeAsync(this.convertTensorMapToTensorsMap(e),t)];case 1:return a=n.sent(),r=Object.keys(a),[2,Array.isArray(t)&&t.length>1?t.map(function(e){return a[e]}):a[r[0]]]}})})},e.prototype.convertTensorMapToTensorsMap=function(e){return Object.keys(e).reduce(function(t,a){return t[a]=[e[a]],t},{})},e.prototype.dispose=function(){this.executor.dispose()},e}();function loadGraphModel(e,t){return void 0===t&&(t={}),__awaiter(this,void 0,void 0,function(){var a;return __generator(this,function(r){switch(r.label){case 0:if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");return null==t&&(t={}),t.fromTFHub&&null==e.load&&(e.endsWith("/")||(e+="/"),e=""+e+DEFAULT_MODEL_NAME+TFHUB_SEARCH_PARAM),[4,(a=new GraphModel(e,t)).load()];case 1:return r.sent(),[2,a]}})})}var version="1.1.2";
//# sourceMappingURL=tf-converter.esm.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js ***!
  \****************************************************************/
/*! exports provided: AdadeltaOptimizer, AdagradOptimizer, AdamOptimizer, AdamaxOptimizer, DataStorage, ENV, Environment, KernelBackend, MomentumOptimizer, Optimizer, RMSPropOptimizer, Rank, Reduction, SGDOptimizer, Tensor, TensorBuffer, Variable, abs, acos, acosh, add, addN, addStrict, all, any, argMax, argMin, asin, asinh, atan, atan2, atanh, avgPool, backend, basicLSTMCell, batchNorm, batchNorm2d, batchNorm3d, batchNorm4d, batchNormalization, batchNormalization2d, batchNormalization3d, batchNormalization4d, batchToSpaceND, browser, buffer, cast, ceil, clipByValue, clone, complex, concat, concat1d, concat2d, concat3d, concat4d, conv1d, conv2d, conv2dDerFilter, conv2dTranspose, conv3d, cos, cosh, cumsum, customGrad, deprecationWarn, depthToSpace, depthwiseConv2d, disableDeprecationWarnings, dispose, disposeVariables, div, divStrict, dot, dropout, elu, enableDebugMode, enableProdMode, environment, equal, equalStrict, erf, exp, expandDims, expm1, eye, fft, fill, findBackend, findBackendFactory, floor, floorDiv, fused, gather, gatherND, getBackend, grad, grads, greater, greaterEqual, greaterEqualStrict, greaterStrict, hammingWindow, hannWindow, ifft, imag, image, io, irfft, isFinite, isInf, isNaN, keep, leakyRelu, less, lessEqual, lessEqualStrict, lessStrict, linalg, linspace, localResponseNormalization, log, log1p, logSigmoid, logSoftmax, logSumExp, logicalAnd, logicalNot, logicalOr, logicalXor, losses, matMul, math, max, maxPool, maximum, maximumStrict, mean, memory, min, minimum, minimumStrict, mod, modStrict, moments, movingAverage, mul, mulStrict, multiRNNCell, multinomial, neg, nextFrame, norm, notEqual, notEqualStrict, oneHot, ones, onesLike, op, outerProduct, pad, pad1d, pad2d, pad3d, pad4d, pool, pow, powStrict, prelu, print, prod, profile, rand, randomNormal, randomUniform, range, ready, real, reciprocal, registerBackend, relu, removeBackend, reshape, reverse, reverse1d, reverse2d, reverse3d, reverse4d, rfft, round, rsqrt, scalar, scatterND, selu, separableConv2d, serialization, setBackend, setdiff1dAsync, sigmoid, sign, sin, sinh, slice, slice1d, slice2d, slice3d, slice4d, softmax, softplus, spaceToBatchND, sparseToDense, spectral, split, sqrt, square, squaredDifference, squaredDifferenceStrict, squeeze, stack, step, stridedSlice, sub, subStrict, sum, tan, tanh, tensor, tensor1d, tensor2d, tensor3d, tensor4d, tensor5d, tensor6d, tensor_util, test_util, tidy, tile, time, topk, train, transpose, truncatedNormal, unsortedSegmentSum, unstack, util, valueAndGrad, valueAndGrads, variable, variableGrads, version_core, webgl, where, whereAsync, zeros, zerosLike */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process, global, Buffer, setImmediate) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdadeltaOptimizer", function() { return Ah; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdagradOptimizer", function() { return Th; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdamOptimizer", function() { return Dh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdamaxOptimizer", function() { return Oh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataStorage", function() { return Yn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENV", function() { return a; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Environment", function() { return i; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KernelBackend", function() { return Qn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MomentumOptimizer", function() { return Mh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Optimizer", function() { return Ih; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RMSPropOptimizer", function() { return Fh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rank", function() { return vt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Reduction", function() { return ql; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SGDOptimizer", function() { return _h; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tensor", function() { return ft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TensorBuffer", function() { return lt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Variable", function() { return dt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "abs", function() { return Vi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return Gi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acosh", function() { return qi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return qu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addN", function() { return Hu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addStrict", function() { return $u; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "all", function() { return bu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "any", function() { return Cu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "argMax", function() { return Eu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "argMin", function() { return Ru; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return Hi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asinh", function() { return $i; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return ji; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan2", function() { return ju; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atanh", function() { return Ki; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "avgPool", function() { return fu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backend", function() { return $e; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "basicLSTMCell", function() { return Al; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNorm", function() { return _s; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNorm2d", function() { return Ms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNorm3d", function() { return Fs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNorm4d", function() { return Bs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization", function() { return Os; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization2d", function() { return As; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization3d", function() { return Ts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization4d", function() { return Ds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchToSpaceND", function() { return Ir; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "browser", function() { return vh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return Nr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cast", function() { return Ar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return Xi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipByValue", function() { return Yi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return Tr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "complex", function() { return On; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return lr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat1d", function() { return cr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat2d", function() { return hr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat3d", function() { return pr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat4d", function() { return fr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv1d", function() { return Xs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv2d", function() { return Ys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv2dDerFilter", function() { return Js; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv2dTranspose", function() { return eu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv3d", function() { return Qs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return Qi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cosh", function() { return Ji; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cumsum", function() { return Dr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "customGrad", function() { return kn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deprecationWarn", function() { return De; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "depthToSpace", function() { return Or; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "depthwiseConv2d", function() { return Zs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disableDeprecationWarnings", function() { return Te; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dispose", function() { return Be; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disposeVariables", function() { return Oe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return Ku; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divStrict", function() { return Xu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return ru; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dropout", function() { return Vl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elu", function() { return gl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableDebugMode", function() { return Ae; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableProdMode", function() { return Ie; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "environment", function() { return l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equal", function() { return Ou; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equalStrict", function() { return _u; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "erf", function() { return Zi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return ts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expandDims", function() { return _r; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expm1", function() { return es; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eye", function() { return Mr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fft", function() { return Fl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fill", function() { return Hn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findBackend", function() { return Ge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findBackendFactory", function() { return qe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return ns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floorDiv", function() { return Yu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fused", function() { return vc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gather", function() { return kl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gatherND", function() { return zl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBackend", function() { return ze; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "grad", function() { return Cn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "grads", function() { return En; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greater", function() { return Mu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterEqual", function() { return Fu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterEqualStrict", function() { return Bu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterStrict", function() { return Pu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hammingWindow", function() { return $l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hannWindow", function() { return Hl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ifft", function() { return Bl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "imag", function() { return Mn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "image", function() { return fc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "io", function() { return hh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "irfft", function() { return Ll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFinite", function() { return ds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isInf", function() { return fs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNaN", function() { return ps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keep", function() { return Pe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "leakyRelu", function() { return yl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "less", function() { return Lu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessEqual", function() { return Wu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessEqualStrict", function() { return Uu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessStrict", function() { return zu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linalg", function() { return ic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linspace", function() { return $n; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "localResponseNormalization", function() { return El; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return rs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log1p", function() { return os; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logSigmoid", function() { return as; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logSoftmax", function() { return Dn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logSumExp", function() { return Su; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalAnd", function() { return hl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalNot", function() { return pl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalOr", function() { return fl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalXor", function() { return dl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "losses", function() { return nc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matMul", function() { return nu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "math", function() { return fh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return Nu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maxPool", function() { return pu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maximum", function() { return Qu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maximumStrict", function() { return Ju; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mean", function() { return ku; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "memory", function() { return _e; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return Iu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minimum", function() { return Zu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minimumStrict", function() { return tl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mod", function() { return el; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modStrict", function() { return nl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "moments", function() { return Au; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "movingAverage", function() { return Dl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return rl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mulStrict", function() { return ol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiRNNCell", function() { return Tl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multinomial", function() { return Fr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "neg", function() { return is; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nextFrame", function() { return Wh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "norm", function() { return Rl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notEqual", function() { return Vu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notEqualStrict", function() { return Gu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "oneHot", function() { return Br; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ones", function() { return Gn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onesLike", function() { return Kn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "op", function() { return An; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outerProduct", function() { return ou; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad", function() { return Pr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad1d", function() { return Lr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad2d", function() { return Wr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad3d", function() { return Ur; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad4d", function() { return zr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pool", function() { return du; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return al; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "powStrict", function() { return il; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prelu", function() { return xl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "print", function() { return kr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prod", function() { return Du; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "profile", function() { return Me; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rand", function() { return Vr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomNormal", function() { return Gr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomUniform", function() { return qr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return jn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ready", function() { return Ue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "real", function() { return _n; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reciprocal", function() { return ss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerBackend", function() { return He; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "relu", function() { return wl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeBackend", function() { return Ve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reshape", function() { return Hr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse", function() { return au; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse1d", function() { return iu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse2d", function() { return su; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse3d", function() { return uu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse4d", function() { return lu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rfft", function() { return Pl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return us; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rsqrt", function() { return ls; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scalar", function() { return Bn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scatterND", function() { return Ml; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selu", function() { return bl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "separableConv2d", function() { return tu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "serialization", function() { return xh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setBackend", function() { return We; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setdiff1dAsync", function() { return Jr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sigmoid", function() { return cs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sign", function() { return hs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return vs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinh", function() { return ms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return vu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice1d", function() { return mu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice2d", function() { return gu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice3d", function() { return yu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice4d", function() { return xu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "softmax", function() { return Tn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "softplus", function() { return gs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spaceToBatchND", function() { return $r; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sparseToDense", function() { return Ul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spectral", function() { return Wl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "split", function() { return dr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return ys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "square", function() { return xs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDifference", function() { return sl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDifferenceStrict", function() { return ul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squeeze", function() { return jr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stack", function() { return Kr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "step", function() { return ws; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stridedSlice", function() { return Ol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return ll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subStrict", function() { return cl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return Tu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return bs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tanh", function() { return Cs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor", function() { return Fn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor1d", function() { return Pn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor2d", function() { return Ln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor3d", function() { return Wn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor4d", function() { return Un; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor5d", function() { return zn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor6d", function() { return Vn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor_util", function() { return It; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "test_util", function() { return Sh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tidy", function() { return Fe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tile", function() { return Xr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "time", function() { return Le; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "topk", function() { return _l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "train", function() { return Ph; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return Cl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "truncatedNormal", function() { return Yr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unsortedSegmentSum", function() { return Il; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstack", function() { return Qr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "util", function() { return Z; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "valueAndGrad", function() { return Rn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "valueAndGrads", function() { return Sn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "variable", function() { return wt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "variableGrads", function() { return Nn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version_core", function() { return Nh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "webgl", function() { return kh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "where", function() { return vl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "whereAsync", function() { return ml; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zeros", function() { return qn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zerosLike", function() { return Xn; });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var t=function(e,n){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])})(e,n)};function e(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}var n=function(){return(n=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var o in e=arguments[n])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t}).apply(this,arguments)};function r(t,e,n,r){return new(n||(n=Promise))(function(o,a){function i(t){try{u(r.next(t))}catch(t){a(t)}}function s(t){try{u(r.throw(t))}catch(t){a(t)}}function u(t){t.done?o(t.value):new n(function(e){e(t.value)}).then(i,s)}u((r=r.apply(t,e||[])).next())})}function o(t,e){var n,r,o,a,i={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return a={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function s(a){return function(s){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,r&&(o=2&a[0]?r.return:a[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,a[1])).done)return o;switch(r=0,o&&(a=[2&a[0],o.value]),a[0]){case 0:case 1:o=a;break;case 4:return i.label++,{value:a[1],done:!1};case 5:i.label++,r=a[1],a=[0];continue;case 7:a=i.ops.pop(),i.trys.pop();continue;default:if(!(o=(o=i.trys).length>0&&o[o.length-1])&&(6===a[0]||2===a[0])){i=0;continue}if(3===a[0]&&(!o||a[1]>o[0]&&a[1]<o[3])){i.label=a[1];break}if(6===a[0]&&i.label<o[1]){i.label=o[1],o=a;break}if(o&&i.label<o[2]){i.label=o[2],i.ops.push(a);break}o[2]&&i.ops.pop(),i.trys.pop();continue}a=e.call(t,i)}catch(t){a=[6,t],r=0}finally{n=o=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,s])}}}var a,i=function(){function t(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}return t.prototype.registerFlag=function(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){var r=this.urlFlags[t];console.warn("Setting feature override from URL "+t+": "+r+"."),this.set(t,r)}},t.prototype.get=function(t){return t in this.flags?this.flags[t]:(this.flags[t]=this.evaluateFlag(t),this.flags[t])},t.prototype.getNumber=function(t){return this.get(t)},t.prototype.getBool=function(t){return this.get(t)},t.prototype.getFlags=function(){return this.flags},Object.defineProperty(t.prototype,"features",{get:function(){return this.flags},enumerable:!0,configurable:!0}),t.prototype.set=function(t,e){if(null==this.flagRegistry[t])throw new Error("Cannot set flag "+t+" as it has not been registered.");this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)},t.prototype.evaluateFlag=function(t){if(null==this.flagRegistry[t])throw new Error("Cannot evaluate flag '"+t+"': no evaluation function found.");return this.flagRegistry[t].evaluationFn()},t.prototype.setFlags=function(t){this.flags=Object.assign({},t)},t.prototype.reset=function(){this.flags={},this.urlFlags={},this.populateURLFlags()},t.prototype.populateURLFlags=function(){var t=this;if(void 0!==this.global&&void 0!==this.global.location&&void 0!==this.global.location.search){var e=s(this.global.location.search);if("tfjsflags"in e)e.tfjsflags.split(",").forEach(function(e){var n=e.split(":"),r=n[0],o=n[1];t.urlFlags[r]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error("Could not parse value flag value "+e+" for flag "+t+".")}(r,o)})}},t}();function s(t){var e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,function(t){for(var n=[],r=1;r<arguments.length;r++)n[r-1]=arguments[r];return function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("=")}),e}function u(t){a=t}var l=Object.freeze({Environment:i,getQueryParams:s,get ENV(){return a},setEnvironmentGlobal:u});function c(t){for(var e=t.length,n=0,r=0;e>0;)r=Math.random()*e|0,n=t[--e],t[e]=t[r],t[r]=n}function h(t,e,n){return Math.max(t,Math.min(e,n))}function p(t){return t%2==0?t:t+1}function f(t){for(var e=0,n=0;n<t.length;n++)e+=t[n];return e}function d(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function v(t,e,n){void 0===n&&(n=""),d(x(t,e),function(){return n+" Shapes "+t+" and "+e+" must match"})}function m(t){d(null!=t,function(){return"The input to the tensor constructor must be a non-null value."})}function g(t,e){if(void 0===e&&(e=[]),null==e&&(e=[]),Array.isArray(t)||_(t))for(var n=0;n<t.length;++n)g(t[n],e);else e.push(t);return e}function y(t){if(0===t.length)return 1;for(var e=t[0],n=1;n<t.length;n++)e*=t[n];return e}function x(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(var n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function w(t){return t%1==0}function b(t){if(null!=Math.tanh)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;var e=Math.exp(2*t);return(e-1)/(e+1)}function C(t){var e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function E(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function R(t,e,n){return void 0===e&&(e=function(t){return 0}),new Promise(function(r,o){var a=0,i=function(){if(t())r();else{var s=e(++a);null!=n&&a>=n?o():setTimeout(i,s)}};i()})}function S(t,e){for(var n=1,r=-1,o=0;o<t.length;++o)if(t[o]>=0)n*=t[o];else if(-1===t[o]){if(-1!==r)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+r+" and dim "+o);r=o}else if(t[o]<0)throw Error("Shapes can not be < 0. Found "+t[o]+" at dim "+o);if(-1===r){if(e>0&&e!==n)throw Error("Size("+e+") must match the product of shape "+t);return t}if(0===n)throw Error("Cannot infer the missing size in ["+t+"] when there are 0 elements");if(e%n!=0)throw Error("The implicit shape can't be a fractional number. Got "+e+" / "+n);var a=t.slice();return a[r]=e/n,a}function N(t,e){var n=e.length;return d((t=null==t?e.map(function(t,e){return e}):[].concat(t)).every(function(t){return t>=-n&&t<n}),function(){return"All values in axis param must be in range [-"+n+", "+n+") but got axis "+t}),d(t.every(function(t){return w(t)}),function(){return"All values in axis param must be integers but got axis "+t}),t.map(function(t){return t<0?n+t:t})}function k(t,e){for(var n=[],r=[],o=null==e?null:N(e,t).sort(),a=0,i=0;i<t.length;++i){if(null!=o){if(o[a]===i&&1!==t[i])throw new Error("Can't squeeze axis "+i+" since its dim '"+t[i]+"' is not 1");(null==o[a]||o[a]>i)&&1===t[i]&&(n.push(t[i]),r.push(i)),o[a]<=i&&a++}1!==t[i]&&(n.push(t[i]),r.push(i))}return{newShape:n,keptDims:r}}function I(t,e){var n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else{if("bool"!==t)throw new Error("Unknown data type "+t);n=new Uint8Array(e)}return n}function A(t,e){var n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error("Unknown data type "+t);n=new Array(e)}return n}function T(t,e,n){if("float32"===e)for(var r=0;r<t.length;r++){var o=t[r];if(isNaN(o)||!isFinite(o))throw Error("The result of the '"+n+"' is "+o+".")}}function D(t,e){for(var n=0;n<t.length;n++){var r=t[n];if(isNaN(r)||!isFinite(r))throw Error("A tensor of type "+e+" being uploaded contains "+r+".")}}function O(t,e){return"complex64"!==e&&(("float32"!==e||"complex64"===t)&&(("int32"!==e||"float32"===t||"complex64"===t)&&("bool"!==e||"bool"!==t)))}function _(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function M(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error("Unknown dtype "+t)}function F(t){if(null==t)return 0;var e=0;return t.forEach(function(t){return e+=2*t.length}),e}function B(t){return"string"==typeof t||t instanceof String}function P(t){return"boolean"==typeof t}function L(t){return"number"==typeof t}function W(t){return Array.isArray(t)?W(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":L(t)?"float32":B(t)?"string":P(t)?"bool":"float32"}function U(t){return!!(t&&t.constructor&&t.call&&t.apply)}function z(t,e){for(var n=e;n<t;++n)if(t%n==0)return n;return t}function V(t){var e=t.length;if(e<2)return[];var n=new Array(e-1);n[e-2]=t[e-1];for(var r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function G(t,e,n){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=g(t)),n&&D(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){for(var r=new Uint8Array(t.length),o=0;o<r.length;++o)0!==Math.round(t[o])&&(r[o]=1);return r}throw new Error("Unknown data type "+e)}function q(t,e){if(0===t.length)return e[0];var n=t.reduce(function(t,e){return t*e});if(0===n)return[];if(n!==e.length)throw new Error("["+t+"] does not match the input size.");return function t(e,n,r){var o=new Array;if(1===n.length)for(var a=n[0],i=0;i<a;i++)o[i]=r[e+i];else{a=n[0];var s=n.slice(1),u=s.reduce(function(t,e){return t*e});for(i=0;i<a;i++)o[i]=t(e+i*u,s,r)}return o}(0,t,e)}function H(t,e){for(var n=$(t,e),r=0;r<n.length;r++)n[r]=1;return n}function $(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error("Unknown data type "+e)}function j(){if("undefined"!=typeof performance)return performance.now();if("undefined"!=typeof process){var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}throw new Error("Cannot measure time in this environment. You should run tf.js in the browser or in Node.js")}function K(t){t.forEach(function(e){d(Number.isInteger(e)&&e>=0,function(){return"Tensor must have a shape comprised of positive integers but got shape ["+t+"]."})})}var X,Y=function(){if(null!=a.global.fetch)return a.global.fetch;if(a.get("IS_NODE"))return Q.fetchImport();throw new Error("Unable to find the fetch() method. Please add your own fetch() function to the global namespace.")},Q={fetchImport:function(){return __webpack_require__(/*! node-fetch */ 0)}};function J(t,e){return null==X&&(X=Y()),X(t,e)}var Z=Object.freeze({shuffle:c,clamp:h,nearestLargerEven:p,sum:f,randUniform:function(t,e){var n=Math.random();return e*n+(1-n)*t},distSquared:function(t,e){for(var n=0,r=0;r<t.length;r++){var o=Number(t[r])-Number(e[r]);n+=o*o}return n},assert:d,assertShapesMatch:v,assertNonNull:m,flatten:g,sizeFromShape:y,isScalarShape:function(t){return 0===t.length},arraysEqual:x,isInt:w,tanh:b,sizeToSquarishShape:C,createShuffledIndices:function(t){for(var e=new Uint32Array(t),n=0;n<t;++n)e[n]=n;return c(e),e},rightPad:E,repeatedTry:R,inferFromImplicitShape:S,parseAxisParam:N,squeezeShape:k,getTypedArrayFromDType:I,getArrayFromDType:A,checkComputationForErrors:T,checkConversionForErrors:D,hasEncodingLoss:O,isTypedArray:_,bytesPerElement:M,bytesFromStringArray:F,isString:B,isBoolean:P,isNumber:L,inferDtype:W,isFunction:U,nearestDivisor:z,computeStrides:V,toTypedArray:G,toNestedArray:q,makeOnesTypedArray:H,makeZerosTypedArray:$,now:j,assertNonNegativeIntegerDimensions:K,getNodeFetch:Q,get systemFetch(){return X},fetch:J}),tt=function(){function t(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new et)}return t.prototype.profileKernel=function(t,e){var n,r=this,o=this.backendTimer.time(function(){n=e()});return(Array.isArray(n)?n:[n]).forEach(function(e){var n=e.dataSync();T(n,e.dtype,t),o.then(function(o){var a="";null!=o.getExtraProfileInfo&&(a=o.getExtraProfileInfo()),r.logger.logKernelProfile(t,e,n,o.kernelMs,a)})}),n},t}(),et=function(){function t(){}return t.prototype.logKernelProfile=function(t,e,n,r,o){var a=E(r+"ms",9),i=E(t,25),s=e.rank,u=e.size,l=E(e.shape.toString(),14);console.log("%c"+i+"\t%c"+a+"\t%c"+s+"D "+l+"\t%c"+u+"\t%c"+o,"font-weight:bold","color:red","color:blue","color: orange","color: green")},t}(),nt=20,rt=3,ot=7;function at(t,e,n,r){var o=V(e),a=function(t,e,n,r){var o=y(e),a=r[r.length-1],i=new Array(a).fill(0),s=e.length,u="complex64"===n?ut(t):t;if(s>1)for(var l=0;l<o/a;l++)for(var c=l*a,h=0;h<a;h++)i[h]=Math.max(i[h],it(u[c+h],0,n).length);return i}(t,e,n,o),i=e.length,s=function t(e,n,r,o,a,i){void 0===i&&(i=!0);var s="complex64"===r?2:1;var u=n[0];var l=n.length;if(0===l){if("complex64"===r){var c=ut(e);return[it(c[0],0,r)]}return"bool"===r?[st(e[0])]:[e[0].toString()]}if(1===l){if(u>nt){var h=rt*s,p=Array.from(e.slice(0,h)),f=Array.from(e.slice(u-rt*s,u));return"complex64"===r&&(p=ut(p),f=ut(f)),["["+p.map(function(t,e){return it(t,a[e],r)}).join(", ")+", ..., "+f.map(function(t,e){return it(t,a[u-rt+e],r)}).join(", ")+"]"]}var d="complex64"===r?ut(e):Array.from(e);return["["+d.map(function(t,e){return it(t,a[e],r)}).join(", ")+"]"]}var v=n.slice(1);var m=o.slice(1);var g=o[0]*s;var y=[];if(u>nt){for(var x=0;x<rt;x++){var w=x*g,b=w+g;y.push.apply(y,t(e.slice(w,b),v,r,m,a,!1))}y.push("...");for(var x=u-rt;x<u;x++){var w=x*g,b=w+g;y.push.apply(y,t(e.slice(w,b),v,r,m,a,x===u-1))}}else for(var x=0;x<u;x++){var w=x*g,b=w+g;y.push.apply(y,t(e.slice(w,b),v,r,m,a,x===u-1))}var C=2===l?",":"";y[0]="["+y[0]+C;for(var x=1;x<y.length-1;x++)y[x]=" "+y[x]+C;var E=",\n";for(var x=2;x<l;x++)E+="\n";y[y.length-1]=" "+y[y.length-1]+"]"+(i?"":E);return y}(t,e,n,o,a),u=["Tensor"];return r&&(u.push("  dtype: "+n),u.push("  rank: "+i),u.push("  shape: ["+e+"]"),u.push("  values:")),u.push(s.map(function(t){return"    "+t}).join("\n")),u.join("\n")}function it(t,e,n){return E(Array.isArray(t)?parseFloat(t[0].toFixed(ot))+" + "+parseFloat(t[1].toFixed(ot))+"j":B(t)?"'"+t+"'":"bool"===n?st(t):parseFloat(t.toFixed(ot)).toString(),e)}function st(t){return 0===t?"false":"true"}function ut(t){for(var e=[],n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}var lt=function(){function t(t,e,n){var r=this;if(this.dtype=e,this.shape=t.slice(),this.size=y(t),null!=n){var o=n.length;d(o===this.size,function(){return"Length of values '"+o+"' does not match the size inferred by the shape '"+r.size+"'."})}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||A(e,this.size),this.strides=V(t)}return t.prototype.set=function(t){for(var e=this,n=[],r=1;r<arguments.length;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),d(n.length===this.rank,function(){return"The number of provided coordinates ("+n.length+") must match the rank ("+e.rank+")"});var o=this.locToIndex(n);this.values[o]=t},t.prototype.get=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];0===t.length&&(t=[0]);for(var n=0,r=0,o=t;r<o.length;r++){var a=o[r];if(a<0||a>=this.shape[n]){var i="Requested out of range element at "+t+".   Buffer shape="+this.shape;throw new Error(i)}n++}for(var s=t[t.length-1],u=0;u<t.length-1;++u)s+=this.strides[u]*t[u];return this.values[s]},t.prototype.locToIndex=function(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];for(var e=t[t.length-1],n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e},t.prototype.indexToLoc=function(t){if(0===this.rank)return[];if(1===this.rank)return[t];for(var e=new Array(this.shape.length),n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e},Object.defineProperty(t.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),t.prototype.toTensor=function(){return ft.make(this.shape,{values:this.values},this.dtype)},t}(),ct=null,ht=null,pt=null;var ft=function(){function t(t,e,n,r,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=y(t),this.strides=V(t),this.dataId=null!=r?r:{},this.id=ct().nextTensorId(),this.rankType=this.rank<5?this.rank.toString():"higher",ct().registerTensor(this,o),null!=n&&ct().write(this.dataId,n)}return t.make=function(e,n,r,o){return new t(e,r,n.values,n.dataId,o)},t.prototype.flatten=function(){return this.throwIfDisposed(),this.as1D()},t.prototype.asScalar=function(){return this.throwIfDisposed(),d(1===this.size,function(){return"The array must have only 1 element."}),this.reshape([])},t.prototype.as1D=function(){return this.throwIfDisposed(),this.reshape([this.size])},t.prototype.as2D=function(t,e){return this.throwIfDisposed(),this.reshape([t,e])},t.prototype.as3D=function(t,e,n){return this.throwIfDisposed(),this.reshape([t,e,n])},t.prototype.as4D=function(t,e,n,r){return this.throwIfDisposed(),this.reshape([t,e,n,r])},t.prototype.as5D=function(t,e,n,r,o){return this.throwIfDisposed(),this.reshape([t,e,n,r,o])},t.prototype.asType=function(t){return this.throwIfDisposed(),ht.cast(this,t)},Object.defineProperty(t.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),t.prototype.buffer=function(){return r(this,void 0,void 0,function(){var t;return o(this,function(e){switch(e.label){case 0:return[4,this.data()];case 1:return t=e.sent(),[2,ht.buffer(this.shape,this.dtype,t)]}})})},t.prototype.bufferSync=function(){return ht.buffer(this.shape,this.dtype,this.dataSync())},t.prototype.array=function(){return r(this,void 0,void 0,function(){var t;return o(this,function(e){switch(e.label){case 0:return[4,this.data()];case 1:return t=e.sent(),[2,q(this.shape,t)]}})})},t.prototype.arraySync=function(){return q(this.shape,this.dataSync())},t.prototype.data=function(){return r(this,void 0,void 0,function(){return o(this,function(t){return this.throwIfDisposed(),[2,ct().read(this.dataId)]})})},t.prototype.dataSync=function(){return this.throwIfDisposed(),ct().readSync(this.dataId)},t.prototype.dispose=function(){this.isDisposed||(ct().disposeTensor(this),this.isDisposedInternal=!0)},Object.defineProperty(t.prototype,"isDisposed",{get:function(){return this.isDisposedInternal},enumerable:!0,configurable:!0}),t.prototype.throwIfDisposed=function(){if(this.isDisposed)throw new Error("Tensor is disposed.")},t.prototype.toFloat=function(){return this.asType("float32")},t.prototype.toInt=function(){return this.asType("int32")},t.prototype.toBool=function(){return this.asType("bool")},t.prototype.print=function(t){return void 0===t&&(t=!1),ht.print(this,t)},t.prototype.reshape=function(t){return this.throwIfDisposed(),ht.reshape(this,t)},t.prototype.reshapeAs=function(t){return this.throwIfDisposed(),this.reshape(t.shape)},t.prototype.expandDims=function(t){return void 0===t&&(t=0),ht.expandDims(this,t)},t.prototype.cumsum=function(t,e,n){return void 0===t&&(t=0),void 0===e&&(e=!1),void 0===n&&(n=!1),ht.cumsum(this,t,e,n)},t.prototype.squeeze=function(t){return this.throwIfDisposed(),ht.squeeze(this,t)},t.prototype.clone=function(){return this.throwIfDisposed(),ht.clone(this)},t.prototype.oneHot=function(t,e,n){return this.throwIfDisposed(),ht.oneHot(this,t,e,n)},t.prototype.toString=function(t){return void 0===t&&(t=!1),at(this.dataSync(),this.shape,this.dtype,t)},t.prototype.tile=function(t){return this.throwIfDisposed(),ht.tile(this,t)},t.prototype.gather=function(t,e){return void 0===e&&(e=0),this.throwIfDisposed(),ht.gather(this,t,e)},t.prototype.matMul=function(t,e,n){return void 0===e&&(e=!1),void 0===n&&(n=!1),this.throwIfDisposed(),ht.matMul(this,t,e,n)},t.prototype.dot=function(t){return this.throwIfDisposed(),ht.dot(this,t)},t.prototype.norm=function(t,e,n){return void 0===t&&(t="euclidean"),void 0===e&&(e=null),void 0===n&&(n=!1),this.throwIfDisposed(),ht.norm(this,t,e,n)},t.prototype.slice=function(t,e){return this.throwIfDisposed(),ht.slice(this,t,e)},t.prototype.reverse=function(t){return this.throwIfDisposed(),ht.reverse(this,t)},t.prototype.concat=function(e,n){return void 0===n&&(n=0),this.throwIfDisposed(),e instanceof t&&(e=[e]),ht.concat([this].concat(e),n)},t.prototype.split=function(t,e){return void 0===e&&(e=0),this.throwIfDisposed(),ht.split(this,t,e)},t.prototype.stack=function(t,e){return void 0===e&&(e=0),ht.stack([this,t],e)},t.prototype.unstack=function(t){return void 0===t&&(t=0),ht.unstack(this,t)},t.prototype.pad=function(t,e){return void 0===e&&(e=0),ht.pad(this,t,e)},t.prototype.batchNormalization=function(t,e,n,r,o){return void 0===n&&(n=.001),pt("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"),this.batchNorm(t,e,o,r,n)},t.prototype.batchNorm=function(t,e,n,r,o){return void 0===o&&(o=.001),this.throwIfDisposed(),ht.batchNorm(this,t,e,n,r,o)},t.prototype.all=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.all(this,t,e)},t.prototype.any=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.any(this,t,e)},t.prototype.logSumExp=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.logSumExp(this,t,e)},t.prototype.sum=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.sum(this,t,e)},t.prototype.prod=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.prod(this,t,e)},t.prototype.mean=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.mean(this,t,e)},t.prototype.min=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.min(this,t,e)},t.prototype.max=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.max(this,t,e)},t.prototype.argMin=function(t){return void 0===t&&(t=null),this.throwIfDisposed(),ht.argMin(this,t)},t.prototype.argMax=function(t){return void 0===t&&(t=null),this.throwIfDisposed(),ht.argMax(this,t)},t.prototype.cast=function(t){return this.throwIfDisposed(),ht.cast(this,t)},t.prototype.add=function(t){return this.throwIfDisposed(),ht.add(this,t)},t.prototype.addStrict=function(t){return this.throwIfDisposed(),ht.addStrict(this,t)},t.prototype.atan2=function(t){return this.throwIfDisposed(),ht.atan2(this,t)},t.prototype.sub=function(t){return this.throwIfDisposed(),ht.sub(this,t)},t.prototype.subStrict=function(t){return this.throwIfDisposed(),ht.subStrict(this,t)},t.prototype.pow=function(t){return this.throwIfDisposed(),ht.pow(this,t)},t.prototype.powStrict=function(t){return this.throwIfDisposed(),ht.powStrict(this,t)},t.prototype.mul=function(t){return this.throwIfDisposed(),ht.mul(this,t)},t.prototype.mulStrict=function(t){return this.throwIfDisposed(),ht.mulStrict(this,t)},t.prototype.div=function(t){return this.throwIfDisposed(),ht.div(this,t)},t.prototype.floorDiv=function(t){return this.throwIfDisposed(),ht.floorDiv(this,t)},t.prototype.divStrict=function(t){return this.throwIfDisposed(),ht.divStrict(this,t)},t.prototype.minimum=function(t){return this.throwIfDisposed(),ht.minimum(this,t)},t.prototype.minimumStrict=function(t){return this.throwIfDisposed(),ht.minimumStrict(this,t)},t.prototype.maximum=function(t){return this.throwIfDisposed(),ht.maximum(this,t)},t.prototype.maximumStrict=function(t){return this.throwIfDisposed(),ht.maximumStrict(this,t)},t.prototype.mod=function(t){return this.throwIfDisposed(),ht.mod(this,t)},t.prototype.modStrict=function(t){return this.throwIfDisposed(),ht.modStrict(this,t)},t.prototype.squaredDifference=function(t){return this.throwIfDisposed(),ht.squaredDifference(this,t)},t.prototype.squaredDifferenceStrict=function(t){return this.throwIfDisposed(),ht.squaredDifferenceStrict(this,t)},t.prototype.transpose=function(t){return this.throwIfDisposed(),ht.transpose(this,t)},t.prototype.notEqual=function(t){return this.throwIfDisposed(),ht.notEqual(this,t)},t.prototype.notEqualStrict=function(t){return this.throwIfDisposed(),ht.notEqualStrict(this,t)},t.prototype.less=function(t){return this.throwIfDisposed(),ht.less(this,t)},t.prototype.lessStrict=function(t){return this.throwIfDisposed(),ht.lessStrict(this,t)},t.prototype.equal=function(t){return this.throwIfDisposed(),ht.equal(this,t)},t.prototype.equalStrict=function(t){return this.throwIfDisposed(),ht.equalStrict(this,t)},t.prototype.lessEqual=function(t){return this.throwIfDisposed(),ht.lessEqual(this,t)},t.prototype.lessEqualStrict=function(t){return this.throwIfDisposed(),ht.lessEqualStrict(this,t)},t.prototype.greater=function(t){return this.throwIfDisposed(),ht.greater(this,t)},t.prototype.greaterStrict=function(t){return this.throwIfDisposed(),ht.greaterStrict(this,t)},t.prototype.greaterEqual=function(t){return this.throwIfDisposed(),ht.greaterEqual(this,t)},t.prototype.greaterEqualStrict=function(t){return this.throwIfDisposed(),ht.greaterEqualStrict(this,t)},t.prototype.logicalAnd=function(t){return this.throwIfDisposed(),ht.logicalAnd(this,t)},t.prototype.logicalOr=function(t){return this.throwIfDisposed(),ht.logicalOr(this,t)},t.prototype.logicalNot=function(){return this.throwIfDisposed(),ht.logicalNot(this)},t.prototype.logicalXor=function(t){return this.throwIfDisposed(),ht.logicalXor(this,t)},t.prototype.where=function(t,e){return this.throwIfDisposed(),ht.where(t,this,e)},t.prototype.neg=function(){return this.throwIfDisposed(),ht.neg(this)},t.prototype.ceil=function(){return this.throwIfDisposed(),ht.ceil(this)},t.prototype.floor=function(){return this.throwIfDisposed(),ht.floor(this)},t.prototype.sign=function(){return this.throwIfDisposed(),ht.sign(this)},t.prototype.isNaN=function(){return this.throwIfDisposed(),ht.isNaN(this)},t.prototype.isInf=function(){return this.throwIfDisposed(),ht.isInf(this)},t.prototype.isFinite=function(){return this.throwIfDisposed(),ht.isFinite(this)},t.prototype.exp=function(){return this.throwIfDisposed(),ht.exp(this)},t.prototype.expm1=function(){return this.throwIfDisposed(),ht.expm1(this)},t.prototype.log=function(){return this.throwIfDisposed(),ht.log(this)},t.prototype.log1p=function(){return this.throwIfDisposed(),ht.log1p(this)},t.prototype.sqrt=function(){return this.throwIfDisposed(),ht.sqrt(this)},t.prototype.rsqrt=function(){return this.throwIfDisposed(),ht.rsqrt(this)},t.prototype.square=function(){return this.throwIfDisposed(),ht.square(this)},t.prototype.reciprocal=function(){return this.throwIfDisposed(),ht.reciprocal(this)},t.prototype.abs=function(){return this.throwIfDisposed(),ht.abs(this)},t.prototype.clipByValue=function(t,e){return this.throwIfDisposed(),ht.clipByValue(this,t,e)},t.prototype.relu=function(){return this.throwIfDisposed(),ht.relu(this)},t.prototype.elu=function(){return this.throwIfDisposed(),ht.elu(this)},t.prototype.selu=function(){return this.throwIfDisposed(),ht.selu(this)},t.prototype.leakyRelu=function(t){return void 0===t&&(t=.2),this.throwIfDisposed(),ht.leakyRelu(this,t)},t.prototype.prelu=function(t){return this.throwIfDisposed(),ht.prelu(this,t)},t.prototype.sigmoid=function(){return this.throwIfDisposed(),ht.sigmoid(this)},t.prototype.logSigmoid=function(){return this.throwIfDisposed(),ht.logSigmoid(this)},t.prototype.softplus=function(){return this.throwIfDisposed(),ht.softplus(this)},t.prototype.zerosLike=function(){return this.throwIfDisposed(),ht.zerosLike(this)},t.prototype.onesLike=function(){return this.throwIfDisposed(),ht.onesLike(this)},t.prototype.sin=function(){return this.throwIfDisposed(),ht.sin(this)},t.prototype.cos=function(){return this.throwIfDisposed(),ht.cos(this)},t.prototype.tan=function(){return this.throwIfDisposed(),ht.tan(this)},t.prototype.asin=function(){return this.throwIfDisposed(),ht.asin(this)},t.prototype.acos=function(){return this.throwIfDisposed(),ht.acos(this)},t.prototype.atan=function(){return this.throwIfDisposed(),ht.atan(this)},t.prototype.sinh=function(){return this.throwIfDisposed(),ht.sinh(this)},t.prototype.cosh=function(){return this.throwIfDisposed(),ht.cosh(this)},t.prototype.tanh=function(){return this.throwIfDisposed(),ht.tanh(this)},t.prototype.asinh=function(){return this.throwIfDisposed(),ht.asinh(this)},t.prototype.acosh=function(){return this.throwIfDisposed(),ht.acosh(this)},t.prototype.atanh=function(){return this.throwIfDisposed(),ht.atanh(this)},t.prototype.erf=function(){return this.throwIfDisposed(),ht.erf(this)},t.prototype.round=function(){return this.throwIfDisposed(),ht.round(this)},t.prototype.step=function(t){return void 0===t&&(t=0),this.throwIfDisposed(),ht.step(this,t)},t.prototype.softmax=function(t){return void 0===t&&(t=-1),this.throwIfDisposed(),ht.softmax(this,t)},t.prototype.logSoftmax=function(t){return void 0===t&&(t=-1),this.throwIfDisposed(),ht.logSoftmax(this,t)},t.prototype.resizeBilinear=function(t,e){return void 0===e&&(e=!1),this.throwIfDisposed(),ht.image.resizeBilinear(this,t,e)},t.prototype.resizeNearestNeighbor=function(t,e){return void 0===e&&(e=!1),this.throwIfDisposed(),ht.image.resizeNearestNeighbor(this,t,e)},t.prototype.conv1d=function(t,e,n,r,o,a){return void 0===r&&(r="NWC"),void 0===o&&(o=1),this.throwIfDisposed(),ht.conv1d(this,t,e,n,r,o,a)},t.prototype.conv2d=function(t,e,n,r,o,a){return void 0===r&&(r="NHWC"),void 0===o&&(o=[1,1]),this.throwIfDisposed(),ht.conv2d(this,t,e,n,r,o,a)},t.prototype.conv2dTranspose=function(t,e,n,r,o){return this.throwIfDisposed(),ht.conv2dTranspose(this,t,e,n,r,o)},t.prototype.depthwiseConv2D=function(t,e,n,r,o,a){return void 0===r&&(r="NHWC"),void 0===o&&(o=[1,1]),this.throwIfDisposed(),ht.depthwiseConv2d(this,t,e,n,r,o,a)},t.prototype.separableConv2d=function(t,e,n,r,o,a){return void 0===o&&(o=[1,1]),void 0===a&&(a="NHWC"),this.throwIfDisposed(),ht.separableConv2d(this,t,e,n,r,o,a)},t.prototype.avgPool=function(t,e,n,r){return this.throwIfDisposed(),ht.avgPool(this,t,e,n,r)},t.prototype.maxPool=function(t,e,n,r){return this.throwIfDisposed(),ht.maxPool(this,t,e,n,r)},t.prototype.localResponseNormalization=function(t,e,n,r){return void 0===t&&(t=5),void 0===e&&(e=1),void 0===n&&(n=1),void 0===r&&(r=.5),ht.localResponseNormalization(this,t,e,n,r)},t.prototype.pool=function(t,e,n,r,o){return this.throwIfDisposed(),ht.pool(this,t,e,n,r,o)},t.prototype.variable=function(t,e,n){return void 0===t&&(t=!0),this.throwIfDisposed(),dt.variable(this,t,e,n)},t.prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),ht.unsortedSegmentSum(this,t,e)},t.prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),ht.batchToSpaceND(this,t,e)},t.prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),ht.spaceToBatchND(this,t,e)},t.prototype.topk=function(t,e){return void 0===t&&(t=1),void 0===e&&(e=!0),this.throwIfDisposed(),ht.topk(this,t,e)},t.prototype.stridedSlice=function(t,e,n,r,o,a,i,s){return void 0===r&&(r=0),void 0===o&&(o=0),void 0===a&&(a=0),void 0===i&&(i=0),void 0===s&&(s=0),this.throwIfDisposed(),ht.stridedSlice(this,t,e,n,r,o,a,i,s)},t.prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),ht.depthToSpace(this,t,e)},t.prototype.fft=function(){return this.throwIfDisposed(),ht.spectral.fft(this)},t.prototype.ifft=function(){return this.throwIfDisposed(),ht.spectral.ifft(this)},t.prototype.rfft=function(){return this.throwIfDisposed(),ht.spectral.rfft(this)},t.prototype.irfft=function(){return this.throwIfDisposed(),ht.spectral.irfft(this)},t}();Object.defineProperty(ft,Symbol.hasInstance,{value:function(t){return!!t&&null!=t.dataId&&null!=t.shape&&null!=t.dtype}});var dt=function(t){function n(e,n,r){void 0===n&&(n=!0);var o=t.call(this,e.shape,e.dtype,null,e.dataId)||this;o.trainable=n,o.name=r,null==o.name&&(o.name=ct().nextVariableId().toString());try{ct().registerVariable(o)}catch(t){throw ct().disposeTensor(o),t}return o}return e(n,t),n.variable=function(t,e,r,o){return void 0===e&&(e=!0),null!=o&&o!==t.dtype&&(t=t.asType(o)),new n(t,e,r)},n.prototype.assign=function(t){if(t.dtype!==this.dtype)throw new Error("dtype of the new value ("+t.dtype+") and previous value ("+this.dtype+") must match");if(!x(t.shape,this.shape))throw new Error("shape of the new value ("+t.shape+") and previous value ("+this.shape+") must match");ct().disposeTensor(this),this.dataId=t.dataId,ct().registerTensor(this)},n}(ft);Object.defineProperty(dt,Symbol.hasInstance,{value:function(t){return t instanceof ft&&null!=t.assign&&t.assign instanceof Function}});var vt,mt,gt,yt,xt,wt=dt.variable;!function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(vt||(vt={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(mt||(mt={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(gt||(gt={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(yt||(yt={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(xt||(xt={}));var bt={float32:yt,int32:mt,bool:gt,complex64:xt};function Ct(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error("Can not upcast "+t+" with "+e)}return bt[t][e]}function Et(t){return Ct(t,"int32")}function Rt(t,e){if(t.dtype===e.dtype)return[t,e];var n=Ct(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function St(t,e){d(t.dtype===e.dtype,function(){return"The dtypes of the first("+t.dtype+") and second("+e.dtype+") input must match"})}function Nt(t){var e=[];return function t(e,n,r){if(null==e)return;if(e instanceof ft)return void n.push(e);if(o=e,!Array.isArray(o)&&"object"!=typeof o)return;var o;var a=e;for(var i in a){var s=a[i];r.has(s)||(r.add(s),t(s,n,r))}}(t,e,new Set),e}var kt,It=Object.freeze({makeTypesMatch:Rt,assertTypesMatch:St,isTensorInList:function(t,e){for(var n=0;n<e.length;n++)if(e[n].id===t.id)return!0;return!1},getTensorsInContainer:Nt}),At=function(){function t(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}return t.prototype.dispose=function(){for(var t in this.registeredVariables)this.registeredVariables[t].dispose()},t}(),Tt=function(){function t(t){this.ENV=t,this.registry={},this.registryFactory={},this.state=new At}return t.prototype.ready=function(){return r(this,void 0,void 0,function(){var t,e,n;return o(this,function(r){switch(r.label){case 0:if(null!=this.pendingBackendInit)return[2,this.pendingBackendInit.then(function(){})];if(null!=this.backendInstance)return[2];t=this.getSortedBackends(),e=0,r.label=1;case 1:return e<t.length?(n=t[e],[4,this.initializeBackend(n).success]):[3,4];case 2:if(r.sent())return this.setBackend(n),[2];r.label=3;case 3:return e++,[3,1];case 4:throw new Error("Could not initialize any backends, all backend initializations failed.")}})})},Object.defineProperty(t.prototype,"backend",{get:function(){if(null!=this.pendingBackendInit)throw new Error("Backend '"+this.backendName+"' has not yet been initialized. Make sure to await tf.ready() before calling other methods");if(null==this.backendInstance){var t=this.initializeBackendsAndReturnBest(),e=t.name;if(t.asyncInit)throw new Error("The highest priority backend '"+e+"' has not yet been initialized. Make sure to await tf.ready() before calling other methods");this.setBackend(e)}return this.backendInstance},enumerable:!0,configurable:!0}),t.prototype.backendNames=function(){return Object.keys(this.registryFactory)},t.prototype.findBackend=function(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;if(this.initializeBackend(t).asyncInit)return null}return this.registry[t]},t.prototype.findBackendFactory=function(t){return t in this.registryFactory?this.registryFactory[t].factory:null},t.prototype.registerBackend=function(t,e,n){return void 0===n&&(n=1),t in this.registryFactory?(console.warn(t+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[t]={factory:e,priority:n},!0)},t.prototype.setBackend=function(t){return r(this,void 0,void 0,function(){var e,n,r;return o(this,function(o){switch(o.label){case 0:if(null==this.registryFactory[t])throw new Error("Backend name '"+t+"' not found in registry");return this.backendName=t,null!=this.registry[t]?[3,4]:(this.backendInstance=null,e=this.initializeBackend(t),n=e.success,e.asyncInit?[4,n]:[3,2]);case 1:return r=o.sent(),[3,3];case 2:r=n,o.label=3;case 3:if(!r)return[2,!1];o.label=4;case 4:return this.backendInstance=this.registry[t],this.profiler=new tt(this.backendInstance),[2,!0]}})})},t.prototype.initializeBackend=function(t){var e=this,n=Dt.registryFactory[t];if(null==n)throw new Error("Cannot initialize backend "+t+", no registration found.");try{var r=n.factory();if(Promise.resolve(r)===r){var o=r.then(function(n){return e.registry[t]=n,e.pendingBackendInit=null,!0}).catch(function(n){return e.pendingBackendInit=null,console.warn("Initialization of backend "+t+" failed"),console.warn(n.stack||n.message),!1});return this.pendingBackendInit=o,{success:o,asyncInit:!0}}return this.registry[t]=r,{success:!0,asyncInit:!1}}catch(e){return console.warn("Initialization of backend "+t+" failed"),console.warn(e.stack||e.message),{success:!1,asyncInit:!1}}},t.prototype.removeBackend=function(t){if(!(t in this.registryFactory))throw new Error(t+" backend not found in registry");t in this.registry&&(this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t]},t.prototype.getSortedBackends=function(){var t=this;if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(function(e,n){return t.registryFactory[n].priority-t.registryFactory[e].priority})},t.prototype.initializeBackendsAndReturnBest=function(){for(var t=this.getSortedBackends(),e=0;e<t.length;e++){var n=t[e],r=this.initializeBackend(n),o=r.success,a=r.asyncInit;if(a||o)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")},t.prototype.moveData=function(t){this.write(t,this.readSync(t))},t.prototype.tidy=function(t,e){var n,r=this,o=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");o=t}return this.scopedRun(function(){return r.startScope(o)},function(){return r.endScope(n)},function(){return(n=e())instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n})},t.prototype.scopedRun=function(t,e,n){t();try{var r=n();return e(),r}catch(t){throw e(),t}},t.prototype.nextTensorId=function(){return t.nextTensorId++},t.prototype.nextVariableId=function(){return t.nextVariableId++},t.prototype.clone=function(t){var e=ft.make(t.shape,{dataId:t.dataId},t.dtype);return this.addTapeNode([t],e,function(t){return[t.toFloat()]}),e},t.prototype.runKernel=function(t,e,n){var r,o=this,a=[],i=this.isTapeOn(),s=null!=this.state.activeScope?this.state.activeScope.name:"",u=function(t){i&&(a=t.map(function(t){return o.keep(o.clone(t))}))},l=this.state.numBytes,c=this.state.numTensors;if(this.scopedRun(function(){return o.state.kernelDepth++},function(){return o.state.kernelDepth--},function(){r=o.ENV.getBool("DEBUG")?o.profiler.profileKernel(s,function(){return t(o.backend,u)}):t(o.backend,u)}),i){var h={id:this.state.nextTapeNodeId++,name:s,inputs:e,outputs:Array.isArray(r)?r:[r],saved:a};null!=n&&(h.gradient=function(t){return n(t,a)}),this.state.activeTape.push(h)}return this.state.profiling&&this.state.activeProfile.kernels.push({name:s,bytesAdded:this.state.numBytes-l,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-c,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(e).map(function(t){return e[t].shape}),outputShape:Array.isArray(r)?r.map(function(t){return t.shape}):r.shape}),r},t.prototype.registerTensor=function(t,e){var n=this.state.tensorInfo.has(t.dataId)?this.state.tensorInfo.get(t.dataId).refCount:0;if(this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++,0===n){this.state.numDataBuffers++;var r=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(r=t.size*M(t.dtype)),this.state.tensorInfo.set(t.dataId,{backend:null!=e?e:this.backend,dtype:t.dtype,shape:t.shape,bytes:r,refCount:0}),this.state.numBytes+=r,null!=e?e.register(t.dataId,t.shape,t.dtype):this.backend.register(t.dataId,t.shape,t.dtype)}this.state.tensorInfo.get(t.dataId).refCount++,t instanceof dt||this.track(t)},t.prototype.registerVariable=function(t){if(null!=this.state.registeredVariables[t.name])throw new Error("Variable with name "+t.name+" was already registered");this.state.registeredVariables[t.name]=t},t.prototype.disposeTensor=function(t){if(this.state.tensorInfo.has(t.dataId)){this.state.numTensors--,"string"===t.dtype&&this.state.numStringTensors--;var e=this.state.tensorInfo.get(t.dataId);e.refCount<=1?("complex64"!==t.dtype&&(this.state.numBytes-=e.bytes),this.state.numDataBuffers--,e.backend.disposeData(t.dataId),this.state.tensorInfo.delete(t.dataId)):this.state.tensorInfo.get(t.dataId).refCount--}},t.prototype.disposeVariables=function(){for(var t in this.state.registeredVariables){var e=this.state.registeredVariables[t];this.disposeTensor(e),delete this.state.registeredVariables[t]}},t.prototype.memory=function(){var t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t},t.prototype.profile=function(t){return r(this,void 0,void 0,function(){var e,n;return o(this,function(r){return this.state.profiling=!0,e=this.state.numBytes,n=this.state.numTensors,this.state.activeProfile.kernels=[],this.state.activeProfile.result=t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max.apply(Math,this.state.activeProfile.kernels.map(function(t){return t.totalBytesSnapshot})),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n,[2,this.state.activeProfile]})})},t.prototype.isTapeOn=function(){return this.state.gradientDepth>0&&0===this.state.kernelDepth},t.prototype.addTapeNode=function(t,e,n){var r={};t.forEach(function(t,e){r[e]=t});var o={id:this.state.nextTapeNodeId++,name:this.state.activeScope.name,inputs:r,outputs:[e],gradient:function(t){var e=n(t),r={};return e.forEach(function(t,e){r[e]=function(){return t}}),r}};this.state.activeTape.push(o)},t.prototype.keep=function(t){return t.kept=!0,t},t.prototype.startTape=function(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++},t.prototype.endTape=function(){this.state.gradientDepth--},t.prototype.startScope=function(t){var e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e},t.prototype.endScope=function(t){for(var e=this,n=Nt(t),r=new Set(n.map(function(t){return t.id})),o=0;o<this.state.activeScope.track.length;o++){var a=this.state.activeScope.track[o];a.kept||r.has(a.id)||a.dispose()}var i=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(function(t){t.kept||t.scopeId!==i.id||e.track(t)})},t.prototype.gradients=function(t,e,n,r){var o=this;if(void 0===r&&(r=!1),d(e.length>0,function(){return"gradients() received an empty list of xs."}),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '"+n.dtype+"'");var a=this.scopedRun(function(){return o.startTape()},function(){return o.endTape()},function(){return o.tidy("forward",t)});d(a instanceof ft,function(){return"The result y returned by f() must be a tensor."});var i=function(t,e,n){for(var r={},o={},a=0;a<e.length;a++)r[e[a].id]=!0;for(a=0;a<t.length;a++){var i=(d=t[a]).inputs;for(var s in i){for(var u=i[s],l=!1,c=0;c<e.length;c++)if(r[u.id]){d.outputs.forEach(function(t){return r[t.id]=!0}),l=!0,o[d.id]=!0;break}if(l)break}}var h={};h[n.id]=!0;var p={};for(a=t.length-1;a>=0;a--)for(i=(d=t[a]).inputs,c=0;c<d.outputs.length;c++)if(h[d.outputs[c].id]){for(var s in i)h[i[s].id]=!0,p[d.id]=!0;break}var f=[];for(a=0;a<t.length;a++){var d;if(o[(d=t[a]).id]&&p[d.id]){var v={};for(var s in d.inputs){var m=d.inputs[s];r[m.id]&&(v[s]=m)}var g=Object.assign({},d);g.inputs=v,g.outputs=d.outputs,f.push(g)}}return f}(this.state.activeTape,e,a);if(!r&&0===i.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",function(){var t,r,s={};s[a.id]=null==n?(t=a.shape,r=H(y(t),"float32"),ft.make(t,{values:r})):n,function(t,e,n){for(var r=function(r){var o=e[r],a=[];if(o.outputs.forEach(function(e){var n=t[e.id];if(null!=n)a.push(n);else{var r=ft.make(e.shape,{values:$(e.size,e.dtype)},e.dtype);a.push(r)}}),null==o.gradient)throw new Error("Cannot compute gradient: gradient function not found for "+o.name+".");var i=o.gradient(1===o.outputs.length?a[0]:a),s=function(e){if(!(e in i))throw new Error("Cannot backprop through input "+e+". Available gradients found: "+Object.keys(i)+".");var r=n(function(){return i[e]()});if("float32"!==r.dtype)throw new Error("Error in gradient for op "+o.name+". The gradient of input "+e+" must have 'float32' dtype, but has '"+r.dtype+"'");var a=o.inputs[e];if(!x(r.shape,a.shape))throw new Error("Error in gradient for op "+o.name+". The gradient of input '"+e+"' has shape '"+r.shape+"', which does not match the shape of the input '"+a.shape+"'");if(null==t[a.id])t[a.id]=r;else{var s=t[a.id];t[a.id]=s.add(r),s.dispose()}};for(var u in o.inputs)s(u)},o=e.length-1;o>=0;o--)r(o)}(s,i,function(t){return o.tidy(t)});var u=e.map(function(t){return s[t.id]});return 0===o.state.gradientDepth&&(o.state.activeTape.forEach(function(t){for(var e in t.saved)t.saved[e].dispose()}),o.state.activeTape=null),{value:a,grads:u}})},t.prototype.customGrad=function(t){var e=this;return d(U(t),function(){return"The f passed in customGrad(f) must be a function."}),function(){for(var n,r=[],o=0;o<arguments.length;o++)r[o]=arguments[o];d(r.every(function(t){return t instanceof ft}),function(){return"The args passed in customGrad(f)(x1, x2,...) must all be tensors"});var a={};return r.forEach(function(t,e){a[e]=t}),e.runKernel(function(e,o){return d((n=t.apply(void 0,r.concat([o]))).value instanceof ft,function(){return"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"}),d(U(n.gradFunc),function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."}),n.value},a,function(t,e){var o=n.gradFunc(t,e),a=Array.isArray(o)?o:[o];d(a.length===r.length,function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."}),d(a.every(function(t){return t instanceof ft}),function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."});var i={};return a.forEach(function(t,e){i[e]=function(){return t}}),i})}},t.prototype.write=function(t,e){var n=this.state.tensorInfo.get(t);if("string"===n.dtype){var r=F(e);this.state.numBytes+=r-n.bytes,n.bytes=r}this.backend!==n.backend&&(n.backend.disposeData(t),n.backend=this.backend,this.backend.register(t,n.shape,n.dtype)),this.backend.write(t,e)},t.prototype.readSync=function(t){return this.state.tensorInfo.get(t).backend.readSync(t)},t.prototype.read=function(t){return this.state.tensorInfo.get(t).backend.read(t)},t.prototype.fromPixels=function(t,e){return this.backend.fromPixels(t,e)},t.prototype.time=function(t){return r(this,void 0,void 0,function(){var e,n;return o(this,function(r){switch(r.label){case 0:return e=j(),[4,this.backend.time(t)];case 1:return(n=r.sent()).wallMs=j()-e,[2,n]}})})},t.prototype.track=function(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t},Object.defineProperty(t.prototype,"registeredVariables",{get:function(){return this.state.registeredVariables},enumerable:!0,configurable:!0}),t.prototype.reset=function(){for(var t in this.state.dispose(),this.ENV.reset(),this.state=new At,this.registry)this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null},t.nextTensorId=0,t.nextVariableId=0,t}();var Dt=function(){var t=function(){if(null==kt){var t=void 0;if("undefined"!=typeof window)t=window;else if("undefined"!=typeof global)t=global;else{if("undefined"==typeof process)throw new Error("Could not find a global object");t=process}kt=t}return kt}();if(null==t._tfengine){var e=new i(t);t._tfengine=new Tt(e)}return u(t._tfengine.ENV),ct=function(){return t._tfengine},t._tfengine}();function Ot(){return"undefined"!=typeof window}a.registerFlag("DEBUG",function(){return!1},function(t){t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),a.registerFlag("IS_BROWSER",function(){return Ot()}),a.registerFlag("IS_NODE",function(){return"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node}),a.registerFlag("IS_CHROME",function(){return"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)}),a.registerFlag("PROD",function(){return!1}),a.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",function(){return!a.getBool("PROD")}),a.registerFlag("DEPRECATION_WARNINGS_ENABLED",function(){return!0}),a.registerFlag("IS_TEST",function(){return!1});var _t={},Mt={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Ft(t){t in _t||(_t[t]=function(t){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");var e=document.createElement("canvas");if(e.addEventListener("webglcontextlost",function(e){e.preventDefault(),delete _t[t]},!1),1===t)return e.getContext("webgl",Mt)||e.getContext("experimental-webgl",Mt);return e.getContext("webgl2",Mt)}(t));var e=_t[t];return e.isContextLost()?(delete _t[t],Ft(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),_t[t])}function Bt(t,e,n){var r=n();return e&&function(t){var e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+Ut(t,e))}(t),r}var Pt=5.96e-8,Lt=65504;function Wt(t){return!!(a.getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||Pt<Math.abs(t)&&Math.abs(t)<Lt)}function Ut(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+e}}function zt(t,e,n){return he(t,e,function(){return t.getExtension(n)},'Extension "'+n+'" not supported on this browser.')}function Vt(t,e,n){var r=he(t,e,function(){return t.createShader(t.VERTEX_SHADER)},"Unable to create vertex WebGLShader.");if(Bt(t,e,function(){return t.shaderSource(r,n)}),Bt(t,e,function(){return t.compileShader(r)}),!1===t.getShaderParameter(r,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(r)),new Error("Failed to compile vertex shader.");return r}function Gt(t,e,n){var r=he(t,e,function(){return t.createShader(t.FRAGMENT_SHADER)},"Unable to create fragment WebGLShader.");if(Bt(t,e,function(){return t.shaderSource(r,n)}),Bt(t,e,function(){return t.compileShader(r)}),!1===t.getShaderParameter(r,t.COMPILE_STATUS))throw function(t,e){var n=$t.exec(e);if(null==n)return console.log("Couldn't parse line number in error: "+e),void console.log(t);for(var r=+n[1],o=t.split("\n"),a=o.length.toString().length+2,i=o.map(function(t,e){return E((e+1).toString(),a)+t}),s=0,u=0;u<i.length;u++)s=Math.max(i[u].length,s);var l=i.slice(0,r-1),c=i.slice(r-1,r),h=i.slice(r);console.log(l.join("\n")),console.log(e.split("\n")[0]),console.log("%c "+E(c[0],s),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join("\n"))}(n,t.getShaderInfoLog(r)),new Error("Failed to compile fragment shader.");return r}var qt,Ht,$t=/ERROR: [0-9]+:([0-9]+):/g;function jt(t,e){return he(t,e,function(){return t.createProgram()},"Unable to create WebGLProgram.")}function Kt(t,e,n){if(Bt(t,e,function(){return t.linkProgram(n)}),!1===t.getProgramParameter(n,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}function Xt(t,e,n){if(Bt(t,e,function(){return t.validateProgram(n)}),!1===t.getProgramParameter(n,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function Yt(t,e,n){var r=he(t,e,function(){return t.createBuffer()},"Unable to create WebGLBuffer");return Bt(t,e,function(){return t.bindBuffer(t.ARRAY_BUFFER,r)}),Bt(t,e,function(){return t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW)}),r}function Qt(t,e,n){var r=he(t,e,function(){return t.createBuffer()},"Unable to create WebGLBuffer");return Bt(t,e,function(){return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,r)}),Bt(t,e,function(){return t.bufferData(t.ELEMENT_ARRAY_BUFFER,n,t.STATIC_DRAW)}),r}function Jt(){return 2===a.getNumber("WEBGL_VERSION")?1:4}function Zt(t,e){return he(t,e,function(){return t.createTexture()},"Unable to create WebGLTexture.")}function te(t,e){var n=a.getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){var r="["+t+"x"+e+"]";throw new Error("Requested texture size "+r+" is invalid.")}if(t>n||e>n){r="["+t+"x"+e+"]";throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+("["+n+"x"+n+"]")+".")}}function ee(t,e){return he(t,e,function(){return t.createFramebuffer()},"Unable to create WebGLFramebuffer.")}function ne(t,e,n,r,o,a,i,s){var u=t.getAttribLocation(n,r);return-1!==u&&(Bt(t,e,function(){return t.bindBuffer(t.ARRAY_BUFFER,o)}),Bt(t,e,function(){return t.vertexAttribPointer(u,a,t.FLOAT,!1,i,s)}),Bt(t,e,function(){return t.enableVertexAttribArray(u)}),!0)}function re(t,e,n,r){pe(t,r),Bt(t,e,function(){return t.activeTexture(t.TEXTURE0+r)}),Bt(t,e,function(){return t.bindTexture(t.TEXTURE_2D,n)})}function oe(t,e,n,r){return he(t,e,function(){return t.getUniformLocation(n,r)},'uniform "'+r+'" not present in program.')}function ae(t,e,n){return t.getUniformLocation(e,n)}function ie(t,e,n,r,o,a){Bt(t,e,function(){return re(t,e,r,a)}),Bt(t,e,function(){return t.uniform1i(o,a)})}function se(t,e,n,r){Bt(t,e,function(){return t.bindFramebuffer(t.FRAMEBUFFER,r)}),Bt(t,e,function(){return t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0)})}function ue(t,e,n){Bt(t,e,function(){return t.bindFramebuffer(t.FRAMEBUFFER,n)}),Bt(t,e,function(){return t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0)})}function le(t){var e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+ce(t,e))}function ce(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+e}}function he(t,e,n,r){var o=Bt(t,e,function(){return n()});if(null==o)throw new Error(r);return o}function pe(t,e){var n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n)throw new Error("textureUnit must be in "+("[gl.TEXTURE0, gl.TEXTURE"+n+"]")+".")}function fe(t,e){return void 0===e&&(e=2),y(t.slice(0,t.length-e))}function de(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function ve(t,e){var n;void 0===e&&(e=!1);var r=a.getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e&&(r*=2,1===(t=t.map(function(e,n){return n>=t.length-2?p(t[n]):t[n]})).length&&(t=[2,t[0]])),2!==t.length){var o=k(t);t=o.newShape}var i=y(t);if(t.length<=1&&i<=r)return[1,i];if(2===t.length&&t[0]<=r&&t[1]<=r)return t;if(3===t.length&&t[0]*t[1]<=r&&t[2]<=r)return[t[0]*t[1],t[2]];if(3===t.length&&t[0]<=r&&t[1]*t[2]<=r)return[t[0],t[1]*t[2]];if(4===t.length&&t[0]*t[1]*t[2]<=r&&t[3]<=r)return[t[0]*t[1]*t[2],t[3]];if(4===t.length&&t[0]<=r&&t[1]*t[2]*t[3]<=r)return[t[0],t[1]*t[2]*t[3]];if(e){var s=fe(t),u=2,l=2;return t.length&&(u=(n=de(t))[0],l=n[1]),C(i=s*(u/2)*(l/2)).map(function(t){return 2*t})}return C(i)}function me(t){return t%2==0}function ge(t,e){if(x(t=t.slice(-2),e=e.slice(-2)))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){var n=t.slice(-1)[0],r=e.slice(-1)[0];if(n===r)return!0;if(me(n)&&me(r)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&me(t[0])&&me(e[0])}function ye(t){if(null==qt){var e=Ft(t);qt=e.getParameter(e.MAX_TEXTURE_SIZE)}return qt}function xe(t){if(null==Ht){var e=Ft(t);Ht=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Ht)}function we(t){if(0===t)return 0;var e=Ft(t);return be(e,"EXT_disjoint_timer_query_webgl2")&&2===t?2:be(e,"EXT_disjoint_timer_query")?1:0}function be(t,e){return null!=t.getExtension(e)}function Ce(t){try{if(null!=Ft(t))return!0}catch(t){return!1}return!1}function Ee(t){if(0===t)return!1;var e=Ft(t);if(1===t){if(!be(e,"OES_texture_float"))return!1}else if(!be(e,"EXT_color_buffer_float"))return!1;return Se(e,t)}function Re(t){if(0===t)return!1;var e=Ft(t);if(1===t){if(!be(e,"OES_texture_float"))return!1;if(!be(e,"WEBGL_color_buffer_float"))return!1}else if(!be(e,"EXT_color_buffer_float"))return!1;return Se(e,t)}function Se(t,e){var n=t.createFramebuffer(),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r);var o=2===e?t.RGBA32F:t.RGBA;t.texImage2D(t.TEXTURE_2D,0,o,1,1,0,t.RGBA,t.FLOAT,null),t.bindFramebuffer(t.FRAMEBUFFER,n),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);var a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(n),a}function Ne(t){return 2===t&&null!=Ft(t).fenceSync}var ke=Object.freeze({callAndCheck:Bt,canBeRepresented:Wt,getWebGLErrorMessage:Ut,getExtensionOrThrow:zt,createVertexShader:Vt,createFragmentShader:Gt,createProgram:jt,linkProgram:Kt,validateProgram:Xt,createStaticVertexBuffer:Yt,createStaticIndexBuffer:Qt,getNumChannels:Jt,createTexture:Zt,validateTextureSize:te,createFramebuffer:ee,bindVertexBufferToProgramAttribute:ne,bindTextureUnit:re,unbindTextureUnit:function(t,e,n){pe(t,n),Bt(t,e,function(){return t.activeTexture(t.TEXTURE0+n)}),Bt(t,e,function(){return t.bindTexture(t.TEXTURE_2D,null)})},getProgramUniformLocationOrThrow:oe,getProgramUniformLocation:ae,bindTextureToProgramUniformSampler:ie,bindCanvasToFramebuffer:function(t,e){Bt(t,e,function(){return t.bindFramebuffer(t.FRAMEBUFFER,null)}),Bt(t,e,function(){return t.viewport(0,0,t.canvas.width,t.canvas.height)}),Bt(t,e,function(){return t.scissor(0,0,t.canvas.width,t.canvas.height)})},bindColorTextureToFramebuffer:se,unbindColorTextureFromFramebuffer:ue,validateFramebuffer:le,getFramebufferErrorMessage:ce,getBatchDim:fe,getRowsCols:de,getTextureShapeFromLogicalShape:ve,isReshapeFree:ge,get MAX_TEXTURE_SIZE(){return qt},get MAX_TEXTURES_IN_SHADER(){return Ht},getWebGLMaxTextureSize:ye,getMaxTexturesInShader:xe,getWebGLDisjointQueryTimerVersion:we,isWebGLVersionEnabled:Ce,isRenderToFloatTextureEnabled:Ee,isDownloadFloatTextureEnabled:Re,isWebGLFenceEnabled:Ne});function Ie(){a.set("PROD",!0)}function Ae(){a.set("DEBUG",!0)}function Te(){a.set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function De(t){a.getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Oe(){Dt.disposeVariables()}function _e(){return Dt.memory()}function Me(t){return Dt.profile(t)}function Fe(t,e){return Dt.tidy(t,e)}function Be(t){Nt(t).forEach(function(t){return t.dispose()})}function Pe(t){return Dt.keep(t)}function Le(t){return Dt.time(t)}function We(t){return Dt.setBackend(t)}function Ue(){return Dt.ready()}function ze(){return Dt.backendName}function Ve(t){Dt.removeBackend(t)}function Ge(t){return Dt.findBackend(t)}function qe(t){return Dt.findBackendFactory(t)}function He(t,e,n){return void 0===n&&(n=1),Dt.registerBackend(t,e,n)}function $e(){return Dt.backend}function je(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];a.getBool("IS_TEST")||console.warn.apply(console,t)}function Ke(t,e,n,r){void 0===r&&(r=!0);var o=[];if(r)(o=o.concat(e.slice(0))).push(t[0]/n),o=o.concat(t.slice(1));else{o=o.concat(t[0]);for(var a=e.length,i=0;i<a;++i)o=o.concat([t[i+1]/e[i],e[i]]);o=o.concat(t.slice(a+1))}return o}function Xe(t,e,n){void 0===n&&(n=!0);var r=[];if(n){r.push(e);for(var o=e+1;o<t;++o)o<=2*e?(r.push(o),r.push(o-(e+1))):r.push(o)}else{var a=[],i=[];for(o=1;o<t;++o)o>=2*e+1||o%2==1?i.push(o):a.push(o);r.push.apply(r,a),r.push(0),r.push.apply(r,i)}return r}function Ye(t,e,n,r){void 0===r&&(r=!0);var o=[];r?o.push(t[0]/n):o.push(t[0]*n);for(var a=1;a<t.length;++a)a<=e.length?r?o.push(e[a-1]*t[a]):o.push(t[a]/e[a-1]):o.push(t[a]);return o}function Qe(t,e){for(var n=[0],r=0;r<e;++r)n.push(t[r][0]);return n}function Je(t,e,n){for(var r=t.slice(0,1),o=0;o<n;++o)r.push(t[o+1]-e[o][0]-e[o][1]);return r}function Ze(t,e){for(var n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function tn(t,e){for(var n=[],r=t.length,o=0;o<r;o++)-1===e.indexOf(o)&&n.push(t[o]);return[n,e.map(function(e){return t[e]})]}function en(t,e){return function(t,e,n){for(var r=t.length+e.length,o=[],a=0,i=0,s=0;s<r;s++)-1===n.indexOf(s)?o.push(t[a++]):o.push(e[i++]);return o}(t,e.map(function(t){return 1}),e)}function nn(t,e,n){d(Ze(e,n),function(){return t+" supports only inner-most axes for now. Got axes "+e+" and rank-"+n+" input."})}function rn(t,e){if(Ze(t,e))return null;for(var n=[],r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach(function(t){return n.push(t)}),n}function on(t){return t.map(function(t,e){return[e,t]}).sort(function(t,e){return t[1]-e[1]}).map(function(t){return t[0]})}function an(t,e){for(var n=[],r=e-t;r<e;++r)n.push(r);return n}function sn(t,e){for(var n=t[0].slice(),r=1;r<t.length;r++)n[e]+=t[r][e];return n}function un(t,e){if(t.rank<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was "+t.rank+".");if(e.rank<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was "+e.rank+".");if("int32"!==e.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was "+e.dtype+".");if(e.shape[e.rank-1]>t.rank)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+e.shape[e.rank-1]+" vs. "+t.rank);if(0===t.size)throw new Error("Requested more than 0 entries, but input is empty. Input shape: "+t.shape+".");for(var n=e.shape,r=n[n.length-1],o=1,a=0;a<n.length-1;++a)o*=n[a];var i=t.shape,s=n.slice();s.pop();var u=1;for(a=r;a<t.rank;++a)u*=i[a],s.push(i[a]);var l=V(t.shape).map(function(t){return t/u}).concat([1]).slice(0,r);return[s,o,u,l]}a.registerFlag("HAS_WEBGL",function(){return a.getNumber("WEBGL_VERSION")>0}),a.registerFlag("WEBGL_VERSION",function(){return Ce(2)?2:Ce(1)?1:0}),a.registerFlag("WEBGL_BUFFER_SUPPORTED",function(){return 2===a.get("WEBGL_VERSION")}),a.registerFlag("WEBGL_CPU_FORWARD",function(){return!1}),a.registerFlag("WEBGL_PACK",function(){return a.getBool("HAS_WEBGL")}),a.registerFlag("WEBGL_PACK_NORMALIZATION",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_PACK_CLIP",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_PACK_DEPTHWISECONV",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_PACK_REDUCE",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_LAZILY_UNPACK",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_CONV_IM2COL",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_MAX_TEXTURE_SIZE",function(){return ye(a.getNumber("WEBGL_VERSION"))}),a.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",function(){return xe(a.getNumber("WEBGL_VERSION"))}),a.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",function(){var t=a.getNumber("WEBGL_VERSION");return 0===t?0:we(t)}),a.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",function(){return a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&(t=navigator.userAgent||navigator.vendor||window.opera,!(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))));var t}),a.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",function(){return Ee(a.getNumber("WEBGL_VERSION"))}),a.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",function(){return Re(a.getNumber("WEBGL_VERSION"))}),a.registerFlag("WEBGL_FENCE_API_ENABLED",function(){return Ne(a.getNumber("WEBGL_VERSION"))}),a.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",function(){return a.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0}),pt=De;var ln=30;function cn(t){return t<=ln?t:z(t,Math.floor(Math.sqrt(t)))}function hn(t,e,n){if(e.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was "+e.rank+".");if(t.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was "+t.rank+".");if("int32"!==e.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: "+e.dtype);if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: "+n);if(0===n.length){if(0===e.size)throw new Error("Indices specified for empty output. indices shape: "+e.shape);if(0===t.size)throw new Error("Updates specified for empty output. updates shape: "+t.shape)}!function(t,e,n){var r=e.rank>1?e.shape[e.rank-1]:1,o=e.rank>1?e.rank-1:1,a="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+n.shape+", indices.shape: "+e.shape+", shape: "+t+", sliceDim: "+r+", and batchDim: "+o+".";if(n.rank<o)throw new Error(a+" update.rank < "+o+". ");if(t.length<r+(n.rank-o))throw new Error(a+" Output shape length < "+(r+(n.rank-o)));if(n.rank!==o+t.length-r)throw new Error(a+" update.rank != "+(o+t.length-r));for(var i=0;i<o;++i)if(n.shape[i]!==e.shape[i])throw new Error(a+" updates.shape["+i+"] ("+n.shape[i]+") != indices.shape["+i+"] ("+e.shape[i]+").");for(i=0;i<n.rank-o;++i)if(n.shape[i+o]!==t[i+r])throw new Error(a+" updates.shape["+(i+o)+"] ("+n.shape[i+o]+") != shape["+(i+o)+"] ("+t[i+o]+")")}(n,e,t)}function pn(t,e,n){for(var r=e.rank>1?e.shape[e.rank-1]:1,o=n.length,a=1,i=r;i<o;++i)a*=n[i];var s=r<1?1:r;return{sliceRank:r,numUpdates:e.size/s,sliceSize:a,strides:V(n.slice(0,r)).concat([1]),outputSize:y(n)}}function fn(t,e,n,r,o,a,i,s,u){if(void 0===o&&(o=0),void 0===a&&(a=0),void 0===i&&(i=0),void 0===s&&(s=0),void 0===u&&(u=0),0!==i)throw new Error("ellipsis mask is not yet supported");if(0!==s)throw new Error("new axis mask is not yet supported");for(var l=[],c=[],h=[],p=0;p<t.length;p++)l[p]=dn(o,e,r,t,p),c[p]=vn(a,n,r,t,p),u&1<<p&&(c[p]=l[p]+1,h.push(p));var f=new Array(t.length).fill(0);return f=f.map(function(t,e){for(var n=0,o=r[e]||1,a=l[e];!(o>0?a>=c[e]:a<=c[e]);a+=o)n+=1;return n}),[l,f,h]}function dn(t,e,n,r,o){var a=e[o],i=n[o]||1;(t&1<<o||null==a)&&(a=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);var s=r[o];return a<0&&(a+=s),a=h(0,a,s-1)}function vn(t,e,n,r,o){var a=e[o],i=n[o]||1;(t&1<<o||null==a)&&(a=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);var s=r[o];return a<0&&(a+=s),a=i>0?h(0,a,s):h(-1,a,s-1)}function mn(t,e,n){for(var r=n.length,o=0;o<n.length;o++)if(n[o]>1){r=o;break}for(o=r+1;o<n.length;o++)if(e[o]>0||n[o]!==t[o])return!1;return!0}function gn(t,e){for(var n=t.length>0?t[t.length-1]:1,r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function yn(t){var e=t;if(_(t))return[t.length];if(!Array.isArray(t))return[];for(var n=[];Array.isArray(e)||_(e);)n.push(e.length),e=e[0];return Array.isArray(t)&&a.getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&function t(e,n,r){r=r||[];if(!Array.isArray(e)&&!_(e))return void d(0===n.length,function(){return"Element arr["+r.join("][")+"] is a primitive, but should be an array/TypedArray of "+n[0]+" elements"});d(n.length>0,function(){return"Element arr["+r.join("][")+"] should be a primitive, but is an array of "+e.length+" elements"});d(e.length===n[0],function(){return"Element arr["+r.join("][")+"] should have "+n[0]+" elements, but has "+e.length+" elements"});var o=n.slice(1);for(var a=0;a<e.length;++a)t(e[a],o,r.concat(a))}(t,n,[]),n}function xn(t,e,n,r){if(null!=t&&("numeric"!==t&&t!==e||"numeric"===t&&"string"===e))throw new Error("Argument '"+n+"' passed to '"+r+"' must be "+t+" tensor, but got "+e+" tensor")}function wn(t,e,n,r){if(void 0===r&&(r="numeric"),t instanceof ft)return xn(r,t.dtype,e,n),t;var o=W(t);if("string"!==o&&["bool","int32","float32"].indexOf(r)>=0&&(o=r),xn(r,o,e,n),null==t||!_(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t){var i=null==t?"null":t.constructor.name;throw new Error("Argument '"+e+"' passed to '"+n+"' must be a Tensor or TensorLike, but got '"+i+"'")}var s=yn(t);_(t)||Array.isArray(t)||(t=[t]);var u="string"!==o?G(t,o,a.getBool("DEBUG")):g(t);return ft.make(s,{values:u},o)}function bn(t,e,n,r){if(void 0===r&&(r="numeric"),!Array.isArray(t))throw new Error("Argument "+e+" passed to "+n+" must be a `Tensor[]` or `TensorLike[]`");return t.map(function(t,r){return wn(t,e+"["+r+"]",n)},r)}function Cn(t){return d(U(t),function(){return"The f passed in grad(f) must be a function"}),function(e,n){var r=wn(e,"x","tf.grad",null),o=null!=n?wn(n,"dy","tf.grad"):null;return Dt.tidy(function(){var e=Dt.gradients(function(){return t(r)},[r],o),n=e.value,a=e.grads;return null!=o&&v(n.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),In(a),a[0]})}}function En(t){return d(U(t),function(){return"The f passed in grads(f) must be a function"}),function(e,n){d(Array.isArray(e),function(){return"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"});var r=bn(e,"args","tf.grads",null),o=null!=n?wn(n,"dy","tf.grads"):null;return Dt.tidy(function(){var e=Dt.gradients(function(){return t.apply(void 0,r)},r,o),n=e.value,a=e.grads;return null!=o&&v(n.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),In(a),a})}}function Rn(t){return d(U(t),function(){return"The f passed in valueAndGrad(f) must be a function"}),function(e,n){d(e instanceof ft,function(){return"The x passed in valueAndGrad(f)(x) must be a tensor"}),d(null==n||n instanceof ft,function(){return"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"});var r=Dt.gradients(function(){return t(e)},[e],n),o=r.grads,a=r.value;return In(o),{grad:o[0],value:a}}}function Sn(t){return d(U(t),function(){return"The f passed in valueAndGrads(f) must be a function"}),function(e,n){d(Array.isArray(e)&&e.every(function(t){return t instanceof ft}),function(){return"The args passed in valueAndGrads(f)(args) must be array of tensors"}),d(null==n||n instanceof ft,function(){return"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"});var r=Dt.gradients(function(){return t.apply(void 0,e)},e,n);return null!=n&&v(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),In(r.grads),r}}function Nn(t,e){if(d(U(t),function(){return"The f passed in variableGrads(f) must be a function"}),d(null==e||Array.isArray(e)&&e.every(function(t){return t instanceof dt}),function(){return"The varList passed in variableGrads(f, varList) must be an array of variables"}),null==e)for(var n in e=[],Dt.registeredVariables)e.push(Dt.registeredVariables[n]);var r=e.length;d((e=e.filter(function(t){return t.trainable})).length>0,function(){return"variableGrads() expects at least one of the input variables to be trainable, but none of the "+r+" variables is trainable."});var o=Dt.gradients(t,e,null,!0),a=o.value,i=o.grads;d(i.some(function(t){return null!=t}),function(){return"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."}),d(0===a.rank,function(){return"The f passed in variableGrads(f) must return a scalar, but it returned a rank-"+a.rank+" tensor"});var s={};return e.forEach(function(t,e){null!=i[e]&&(s[t.name]=i[e])}),{value:a,grads:s}}function kn(t){return Dt.customGrad(t)}function In(t){if(t.filter(function(t){return null==t}).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}function An(t){var e=Object.keys(t);if(1!==e.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+e.length+" keys.");var n=e[0],r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1));var o=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];Dt.startScope(n);try{var o=r.apply(void 0,t);return o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),Dt.endScope(o),o}catch(t){throw Dt.endScope(null),t}};return Object.defineProperty(o,"name",{value:n,configurable:!0}),o}var Tn=An({softmax_:function(t,e){void 0===e&&(e=-1);var n=wn(t,"logits","softmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank "+n.rank+" and dim was "+e);return kn(function(t,n){var r=t.logSumExp([e],!0),o=t.toFloat().sub(r).exp();return n([o]),{value:o,gradFunc:function(t,n){var r=n[0],o=t.mul(r);return o.sub(o.sum([e],!0).mul(r))}}})(n)}}),Dn=An({logSoftmax_:function(t,e){void 0===e&&(e=-1);var n=wn(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank "+n.rank+" and axis was "+e);return kn(function(t,n){var r=t.max(e,!0),o=t.sub(r),a=o.toFloat().sub(o.exp().sum(e,!0).log());return n([a]),{value:a,gradFunc:function(t,n){var r=n[0].exp();return t.sub(t.sum(e,!0).mul(r))}}})(n)}});var On=An({complex_:function(t,e){var n=wn(t,"real","complex"),r=wn(e,"imag","complex");return v(n.shape,r.shape,"real and imag shapes, "+n.shape+" and "+r.shape+", must match in call to tf.complex()."),Dt.runKernel(function(t){return t.complex(n,r)},{$real:n,$imag:r})}}),_n=An({real_:function(t){var e=wn(t,"input","real");return Dt.runKernel(function(t){return t.real(e)},{$input:e})}}),Mn=An({imag_:function(t){var e=wn(t,"input","imag");return Dt.runKernel(function(t){return t.imag(e)},{$input:e})}});function Fn(t,e,n){if(null==n&&(n=W(t)),"complex64"===n)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!_(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");var r=yn(t);if(null!=e){K(e);var o=y(e),i=y(r);d(o===i,function(){return"Based on the provided shape, ["+e+"], the tensor should have "+o+" values but has "+i});for(var s=0;s<r.length;++s){var u=r[s],l=s!==r.length-1||u!==y(e.slice(s));d(r[s]===e[s]||!l,function(){return"Error creating a new Tensor. Inferred shape ("+r+") does not match the provided shape ("+e+"). "})}}return _(t)||Array.isArray(t)||(t=[t]),e=e||r,t="string"!==n?G(t,n,a.getBool("DEBUG")):g(t),ft.make(e,{values:t},n)}function Bn(t,e){if((_(t)||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");return Fn(t,[],e)}function Pn(t,e){m(t);var n=yn(t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Fn(t,n,e)}function Ln(t,e,n){if(m(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");var r=yn(t);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Fn(t,e=e||r,n)}function Wn(t,e,n){if(m(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");var r=yn(t);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Fn(t,e=e||r,n)}function Un(t,e,n){if(m(t),null!=e&&4!==e.length)throw new Error("tensor4d() requires shape to have four numbers");var r=yn(t);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Fn(t,e=e||r,n)}function zn(t,e,n){if(m(t),null!=e&&5!==e.length)throw new Error("tensor5d() requires shape to have five numbers");var r=yn(t);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Fn(t,e=e||r,n)}function Vn(t,e,n){if(m(t),null!=e&&6!==e.length)throw new Error("tensor6d() requires shape to have six numbers");var r=yn(t);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return Fn(t,e=e||r,n)}function Gn(t,e){if(void 0===e&&(e="float32"),"complex64"===e){var n=Gn(t,"float32"),r=qn(t,"float32");return On(n,r)}var o=H(y(t),e);return ft.make(t,{values:o},e)}function qn(t,e){if(void 0===e&&(e="float32"),"complex64"===e){var n=qn(t,"float32"),r=qn(t,"float32");return On(n,r)}var o=$(y(t),e);return ft.make(t,{values:o},e)}function Hn(t,e,n){return Dt.runKernel(function(r){return r.fill(t,e,n)},{})}function $n(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");return Dt.runKernel(function(r){return r.linspace(t,e,n)},{})}function jn(t,e,n,r){if(void 0===n&&(n=1),void 0===r&&(r="float32"),0===n)throw new Error("Cannot have a step of zero");if(t===e||t<e&&n<0||e<t&&n>1)return qn([0],r);var o=$(Math.abs(Math.ceil((e-t)/n)),r);e<t&&1===n&&(n=-1),o[0]=t;for(var a=1;a<o.length;a++)o[a]=o[a-1]+n;return Pn(o,r)}var Kn=An({onesLike_:function(t){var e=wn(t,"x","onesLike");if("complex64"===e.dtype){var n=Kn(_n(e)),r=Xn(Mn(e));return On(n,r)}return Dt.runKernel(function(t){return t.onesLike(e)},{$x:e},null)}}),Xn=An({zerosLike_:function(t){var e=wn(t,"x","zerosLike");return Dt.runKernel(function(t){return t.zerosLike(e)},{$x:e},null)}}),Yn=function(){function t(t){this.dataMover=t,this.data=new WeakMap}return t.prototype.get=function(t){return this.data.has(t)||this.dataMover.moveData(t),this.data.get(t)},t.prototype.set=function(t,e){this.data.set(t,e)},t.prototype.has=function(t){return this.data.has(t)},t.prototype.delete=function(t){return this.data.delete(t)},t}(),Qn=function(){function t(){}return t.prototype.time=function(t){throw new Error("Not yet implemented.")},t.prototype.read=function(t){throw new Error("Not yet implemented.")},t.prototype.readSync=function(t){throw new Error("Not yet implemented.")},t.prototype.disposeData=function(t){throw new Error("Not yet implemented.")},t.prototype.write=function(t,e){throw new Error("Not yet implemented.")},t.prototype.fromPixels=function(t,e){throw new Error("Not yet implemented.")},t.prototype.register=function(t,e,n){throw new Error("Not yet implemented.")},t.prototype.memory=function(){throw new Error("Not yet implemented.")},t.prototype.floatPrecision=function(){throw new Error("Not yet implemented")},t.prototype.epsilon=function(){return 32===this.floatPrecision()?1e-7:1e-4},t.prototype.batchMatMul=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.fusedBatchMatMul=function(t,e,n,r,o,a){throw new Error("Not yet implemented")},t.prototype.slice=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.stridedSlice=function(t,e,n,r,o,a,i,s,u){throw new Error("Not yet implemented")},t.prototype.unstack=function(t,e){throw new Error("Not yet implemented")},t.prototype.reverse=function(t,e){throw new Error("Not yet implemented")},t.prototype.concat=function(t,e){throw new Error("Not yet implemented")},t.prototype.neg=function(t){throw new Error("Not yet implemented")},t.prototype.add=function(t,e){throw new Error("Not yet implemented")},t.prototype.addN=function(t){throw new Error("Not yet implemented")},t.prototype.subtract=function(t,e){throw new Error("Not yet implemented")},t.prototype.multiply=function(t,e){throw new Error("Not yet implemented")},t.prototype.realDivide=function(t,e){throw new Error("Not yet implemented")},t.prototype.floorDiv=function(t,e){throw new Error("Not yet implemented")},t.prototype.sum=function(t,e){throw new Error("Not yet implemented")},t.prototype.prod=function(t,e){throw new Error("Not yet implemented")},t.prototype.unsortedSegmentSum=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.argMin=function(t,e){throw new Error("Not yet implemented")},t.prototype.argMax=function(t,e){throw new Error("Not yet implemented")},t.prototype.equal=function(t,e){throw new Error("Not yet implemented")},t.prototype.notEqual=function(t,e){throw new Error("Not yet implemented")},t.prototype.less=function(t,e){throw new Error("Not yet implemented")},t.prototype.lessEqual=function(t,e){throw new Error("Not yet implemented")},t.prototype.greater=function(t,e){throw new Error("Not yet implemented")},t.prototype.greaterEqual=function(t,e){throw new Error("Not yet implemented")},t.prototype.logicalNot=function(t){throw new Error("Not yet implemented")},t.prototype.logicalAnd=function(t,e){throw new Error("Not yet implemented")},t.prototype.logicalOr=function(t,e){throw new Error("Not yet implemented")},t.prototype.where=function(t){throw new Error("Not yet implemented")},t.prototype.select=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.topk=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.min=function(t,e){throw new Error("Not yet implemented")},t.prototype.minimum=function(t,e){throw new Error("Not yet implemented")},t.prototype.mod=function(t,e){throw new Error("Not yet implemented")},t.prototype.max=function(t,e){throw new Error("Not yet implemented")},t.prototype.maximum=function(t,e){throw new Error("Not yet implemented")},t.prototype.all=function(t,e){throw new Error("Not yet implemented")},t.prototype.any=function(t,e){throw new Error("Not yet implemented")},t.prototype.squaredDifference=function(t,e){throw new Error("Not yet implemented")},t.prototype.ceil=function(t){throw new Error("Not yet implemented")},t.prototype.floor=function(t){throw new Error("Not yet implemented")},t.prototype.round=function(t){throw new Error("Not yet implemented")},t.prototype.sign=function(t){throw new Error("Not yet implemented")},t.prototype.isNaN=function(t){throw new Error("Not yet implemented")},t.prototype.isInf=function(t){throw new Error("Not yet implemented")},t.prototype.isFinite=function(t){throw new Error("Not yet implemented")},t.prototype.pow=function(t,e){throw new Error("Not yet implemented")},t.prototype.exp=function(t){throw new Error("Not yet implemented")},t.prototype.expm1=function(t){throw new Error("Not yet implemented")},t.prototype.log=function(t){throw new Error("Not yet implemented")},t.prototype.log1p=function(t){throw new Error("Not yet implemented")},t.prototype.sqrt=function(t){throw new Error("Not yet implemented")},t.prototype.rsqrt=function(t){throw new Error("Not yet implemented")},t.prototype.square=function(t){throw new Error("Not yet implemented")},t.prototype.reciprocal=function(t){throw new Error("Not yet implemented")},t.prototype.relu=function(t){throw new Error("Not yet implemented")},t.prototype.prelu=function(t,e){throw new Error("Not yet implemented")},t.prototype.elu=function(t){throw new Error("Not yet implemented")},t.prototype.eluDer=function(t,e){throw new Error("Not yet implemented")},t.prototype.selu=function(t){throw new Error("Not yet implemented")},t.prototype.int=function(t){throw new Error("Not yet implemented")},t.prototype.clip=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.abs=function(t){throw new Error("Not yet implemented")},t.prototype.complexAbs=function(t){throw new Error("Not yet implemented")},t.prototype.sigmoid=function(t){throw new Error("Not yet implemented")},t.prototype.softplus=function(t){throw new Error("Not yet implemented")},t.prototype.sin=function(t){throw new Error("Not yet implemented")},t.prototype.cos=function(t){throw new Error("Not yet implemented")},t.prototype.tan=function(t){throw new Error("Not yet implemented")},t.prototype.asin=function(t){throw new Error("Not yet implemented")},t.prototype.acos=function(t){throw new Error("Not yet implemented")},t.prototype.atan=function(t){throw new Error("Not yet implemented")},t.prototype.atan2=function(t,e){throw new Error("Not yet implemented")},t.prototype.sinh=function(t){throw new Error("Not yet implemented")},t.prototype.cosh=function(t){throw new Error("Not yet implemented")},t.prototype.tanh=function(t){throw new Error("Not yet implemented")},t.prototype.asinh=function(t){throw new Error("Not yet implemented")},t.prototype.acosh=function(t){throw new Error("Not yet implemented")},t.prototype.atanh=function(t){throw new Error("Not yet implemented")},t.prototype.erf=function(t){throw new Error("Not yet implemented")},t.prototype.step=function(t,e){throw new Error("Not yet implemented")},t.prototype.conv2d=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.conv2dDerInput=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.conv2dDerFilter=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.depthwiseConv2D=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.depthwiseConv2DDerInput=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.depthwiseConv2DDerFilter=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.conv3d=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.conv3dDerInput=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.conv3dDerFilter=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.maxPool=function(t,e){throw new Error("Not yet implemented")},t.prototype.maxPoolBackprop=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.avgPool=function(t,e){throw new Error("Not yet implemented")},t.prototype.avgPoolBackprop=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.reshape=function(t,e){throw new Error("Not yet implemented")},t.prototype.cast=function(t,e){throw new Error("Not yet implemented")},t.prototype.tile=function(t,e){throw new Error("Not yet implemented")},t.prototype.pad=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.transpose=function(t,e){throw new Error("Not yet implemented")},t.prototype.gather=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.gatherND=function(t,e){throw new Error("Not yet implemented")},t.prototype.scatterND=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.batchToSpaceND=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.spaceToBatchND=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.resizeBilinear=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.resizeBilinearBackprop=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.resizeNearestNeighbor=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.resizeNearestNeighborBackprop=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.batchNormalization=function(t,e,n,r,o,a){throw new Error("Not yet implemented")},t.prototype.localResponseNormalization4D=function(t,e,n,r,o){throw new Error("Not yet implemented")},t.prototype.LRNGrad=function(t,e,n,r,o,a,i){throw new Error("Not yet implemented")},t.prototype.multinomial=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.oneHot=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.cumsum=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.nonMaxSuppression=function(t,e,n,r,o){throw new Error("Not yet implemented")},t.prototype.fft=function(t){throw new Error("Not yet implemented")},t.prototype.ifft=function(t){throw new Error("Not yet implemented")},t.prototype.complex=function(t,e){throw new Error("Not yet implemented")},t.prototype.real=function(t){throw new Error("Not yet implemented")},t.prototype.imag=function(t){throw new Error("Not yet implemented")},t.prototype.cropAndResize=function(t,e,n,r,o,a){throw new Error("Not yet implemented")},t.prototype.depthToSpace=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.split=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.sparseToDense=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.fill=function(t,e,n){throw new Error("Not yet implemented.")},t.prototype.onesLike=function(t){throw new Error("Not yet implemented")},t.prototype.zerosLike=function(t){throw new Error("Not yet implemented")},t.prototype.linspace=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.dispose=function(){throw new Error("Not yet implemented")},t}();function Jn(t,e,n){if("complex64"===e){if("complex64"===t.dtype)return t.clone();var r=qn(t.shape),o=t.toFloat(),a=n.complex(o,r);return r.dispose(),o.dispose(),a}if(!O(t.dtype,e))return ft.make(t.shape,{dataId:t.dataId},e);if("complex64"===t.dtype){var i=n.real(t);a=i.cast(e);return i.dispose(),a}if("int32"===e)return n.int(t);if("bool"===e){var s=Bn(0,t.dtype);a=n.notEqual(t,s);return s.dispose(),a}throw new Error("Error in Cast: unknown dtype argument ("+e+")")}function Zn(t,e){return ft.make(e,{dataId:t.dataId},t.dtype)}function tr(t,e,n){var r=(e-t)/(n-1),o=$(n,"float32");o[0]=t;for(var a=1;a<o.length;a++)o[a]=o[a-1]+r;return Pn(o,"float32")}function er(t,e){if(t.length!==e.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+t.length+", imag: "+e.length+".");for(var n=new Float32Array(2*t.length),r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function nr(t,e){return{real:t[2*e],imag:t[2*e+1]}}function rr(t,e,n,r){t[2*r]=e,t[2*r+1]=n}function or(t,e,n){var r=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(r),imag:Math.sin(r)}}function ar(t,e,n,r,o){for(var a=Array.from(e).map(function(t,e){return{score:t,boxIndex:e}}).filter(function(t){return t.score>o}).sort(function(t,e){return e.score-t.score}),i=[],s=0;s<a.length;s++){var u=a[s],l=u.score,c=u.boxIndex;if(l<o)break;for(var h=!1,p=i.length-1;p>=0;--p){if(ir(t,c,i[p])>=r){h=!0;break}}if(!h&&(i.push(c),i.length>=n))break}return Pn(i,"int32")}function ir(t,e,n){var r=t.subarray(4*e,4*e+4),o=t.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),s=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(o[0],o[2]),c=Math.min(o[1],o[3]),h=Math.max(o[0],o[2]),p=Math.max(o[1],o[3]),f=(s-a)*(u-i),d=(h-l)*(p-c);if(f<=0||d<=0)return 0;var v=Math.max(a,l),m=Math.max(i,c),g=Math.min(s,h),y=Math.min(u,p),x=Math.max(g-v,0)*Math.max(y-m,0);return x/(f+d-x)}function sr(t,e,n){var r=new Array(t.rank).fill(0),o=t.shape.slice();return e.map(function(e){o[n]=e;var a=t.slice(r,o);return r[n]+=e,a})}function ur(t,e,n,r,o){for(var a=e[e.length-1],i=[t.length/a,a],s=i[0],u=i[1],l=I(n,s*r),c=I("int32",s*r),h=0;h<s;h++){for(var p=h*u,f=t.subarray(p,p+u),d=[],v=0;v<f.length;v++)d.push({value:f[v],index:v});d.sort(function(t,e){return e.value-t.value});var m=h*r,g=l.subarray(m,m+r),y=c.subarray(m,m+r);for(v=0;v<r;v++)g[v]=d[v].value,y[v]=d[v].index}var x=e.slice();return x[x.length-1]=r,[Fn(l,x,n),Fn(c,x,"int32")]}var lr=An({concat_:function(t,e){void 0===e&&(e=0),d(t.length>=1,function(){return"Pass at least one tensor to concat"});var n=bn(t,"tensors","concat");e=N(e,n[0].shape)[0];var r=sn(n.map(function(t){return t.shape}),e);if(0===y(r))return Fn([],r);if(1===(n=n.filter(function(t){return t.size>0})).length)return n[0];var o=n.map(function(t){return t.shape});!function(t,e){var n=t[0].length;t.forEach(function(t,e){d(t.length===n,function(){return"Error in concat"+n+"D: rank of tensors["+e+"] must be the same as the rank of the rest ("+n+")"})}),d(e>=0&&e<n,function(){return"Error in concat"+n+"D: axis must be between 0 and "+(n-1)+"."});var r=t[0];t.forEach(function(t,o){for(var a=0;a<n;a++)d(a===e||t[a]===r[a],function(){return"Error in concat"+n+"D: Shape of tensors["+o+"] ("+t+") does not match the shape of the rest ("+r+") along the non-concatenated axis "+o+"."})})}(o,e);var a=n;return Dt.runKernel(function(t){return t.concat(n,e)},a,function(t){var n=o.map(function(t){return t[e]});return dr(t,n,e).map(function(t){return function(){return t}})})}}),cr=An({concat1d_:function(t){return lr(t,0)}}),hr=An({concat2d_:function(t,e){return lr(t,e)}}),pr=An({concat3d_:function(t,e){return lr(t,e)}}),fr=An({concat4d_:function(t,e){return lr(t,e)}}),dr=An({split_:function(t,e,n){void 0===n&&(n=0);var r,o=wn(t,"x","split");return n=N(n,o.shape)[0],"number"==typeof e?(d(o.shape[n]%e==0,function(){return"Number of splits must evenly divide the axis."}),r=new Array(e).fill(o.shape[n]/e)):(d(o.shape[n]===e.reduce(function(t,e){return t+e}),function(){return"The sum of sizes must match the size of the axis dimension."}),r=e),Dt.runKernel(function(t){return t.split(o,r,n)},{$x:o},function(t){return{$x:function(){return lr(t,n)}}})}});"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;function vr(t,e){return t(e={exports:{}},e.exports),e.exports}var mr=vr(function(t){!function(t,e,n){function r(t){var e,n=this,r=(e=4022871197,function(t){t=t.toString();for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(t),n.s0<0&&(n.s0+=1),n.s1-=r(t),n.s1<0&&(n.s1+=1),n.s2-=r(t),n.s2<0&&(n.s2+=1),r=null}function o(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function a(t,e){var n=new r(t),a=e&&e.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+1.1102230246251565e-16*(2097152*i()|0)},i.quick=i,a&&("object"==typeof a&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n(function(){return a}):this.alea=a}(0,t,!1)}),gr=vr(function(t){!function(t,e,n){function r(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function a(t,e){var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&("object"==typeof a&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n(function(){return a}):this.xor128=a}(0,t,!1)}),yr=vr(function(t){!function(t,e,n){function r(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),r==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function a(t,e){var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&("object"==typeof a&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n(function(){return a}):this.xorwow=a}(0,t,!1)}),xr=vr(function(t){!function(t,e,n){function r(t){var e=this;e.next=function(){var t,n,r=e.x,o=e.i;return t=r[o],n=(t^=t>>>7)^t<<24,n^=(t=r[o+1&7])^t>>>10,n^=(t=r[o+3&7])^t>>>3,n^=(t=r[o+4&7])^t<<7,t=r[o+7&7],n^=(t^=t<<13)^t<<9,r[o]=n,e.i=o+1&7,n},function(t,e){var n,r=[];if(e===(0|e))r[0]=e;else for(e=""+e,n=0;n<e.length;++n)r[7&n]=r[7&n]<<15^e.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],t.x=r,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function o(t,e){return e.x=t.x.slice(),e.i=t.i,e}function a(t,e){null==t&&(t=+new Date);var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&(a.x&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n(function(){return a}):this.xorshift7=a}(0,t,!1)}),wr=vr(function(t){!function(t,e,n){function r(t){var e=this;e.next=function(){var t,n,r=e.w,o=e.X,a=e.i;return e.w=r=r+1640531527|0,n=o[a+34&127],t=o[a=a+1&127],n^=n<<13,t^=t<<17,n^=n>>>15,t^=t>>>12,n=o[a]=n^t,e.i=a,n+(r^r>>>16)|0},function(t,e){var n,r,o,a,i,s=[],u=128;for(e===(0|e)?(r=e,e=null):(e+="\0",r=0,u=Math.max(u,e.length)),o=0,a=-32;a<u;++a)e&&(r^=e.charCodeAt((a+32)%e.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(e&&e.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;t.w=i,t.X=s,t.i=o}(e,t)}function o(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function a(t,e){null==t&&(t=+new Date);var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&(a.X&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n(function(){return a}):this.xor4096=a}(0,t,!1)}),br=vr(function(t){!function(t,e,n){function r(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,r=e.d,o=e.a;return t=t<<25^t>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-r|0,e.d=r<<16^n>>>16^o,e.a=o-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var r=0;r<n.length+20;r++)e.b^=0|n.charCodeAt(r),e.next()}function o(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function a(t,e){var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&("object"==typeof a&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n(function(){return a}):this.tychei=a}(0,t,!1)}),Cr=vr(function(t){!function(e,n){var r,o=this,a=256,i=6,s="random",u=n.pow(a,i),l=n.pow(2,52),c=2*l,h=a-1;function p(t,h,p){var g=[],y=v(function t(e,n){var r,o=[],a=typeof e;if(n&&"object"==a)for(r in e)try{o.push(t(e[r],n-1))}catch(t){}return o.length?o:"string"==a?e:e+"\0"}((h=1==h?{entropy:!0}:h||{}).entropy?[t,m(e)]:null==t?function(){try{var t;return r&&(t=r.randomBytes)?t=t(a):(t=new Uint8Array(a),(o.crypto||o.msCrypto).getRandomValues(t)),m(t)}catch(t){var n=o.navigator,i=n&&n.plugins;return[+new Date,o,i,o.screen,m(e)]}}():t,3),g),x=new f(g),w=function(){for(var t=x.g(i),e=u,n=0;t<l;)t=(t+n)*a,e*=a,n=x.g(1);for(;t>=c;)t/=2,e/=2,n>>>=1;return(t+n)/e};return w.int32=function(){return 0|x.g(4)},w.quick=function(){return x.g(4)/4294967296},w.double=w,v(m(x.S),e),(h.pass||p||function(t,e,r,o){return o&&(o.S&&d(o,x),t.state=function(){return d(x,{})}),r?(n[s]=t,e):t})(w,y,"global"in h?h.global:this==n,h.state)}function f(t){var e,n=t.length,r=this,o=0,i=r.i=r.j=0,s=r.S=[];for(n||(t=[n++]);o<a;)s[o]=o++;for(o=0;o<a;o++)s[o]=s[i=h&i+t[o%n]+(e=s[o])],s[i]=e;(r.g=function(t){for(var e,n=0,o=r.i,i=r.j,s=r.S;t--;)e=s[o=h&o+1],n=n*a+s[h&(s[o]=s[i=h&i+e])+(s[i]=e)];return r.i=o,r.j=i,n})(a)}function d(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function v(t,e){for(var n,r=t+"",o=0;o<r.length;)e[h&o]=h&(n^=19*e[h&o])+r.charCodeAt(o++);return m(e)}function m(t){return String.fromCharCode.apply(0,t)}if(n["seed"+s]=p,v(n.random(),e),t.exports){t.exports=p;try{r=__webpack_require__(/*! crypto */ "./node_modules/crypto-browserify/index.js")}catch(t){}}}([],Math)});Cr.alea=mr,Cr.xor128=gr,Cr.xorwow=yr,Cr.xorshift7=xr,Cr.xor4096=wr,Cr.tychei=br;var Er=Cr.alea,Rr=function(){function t(t,e,n,r,o){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);var a=o||Math.random();this.random=Er(a.toString())}return t.prototype.nextValue=function(){if(!isNaN(this.nextVal)){var t=this.nextVal;return this.nextVal=NaN,t}for(var e,n,r=!1;!r;){var o=void 0,a=void 0,i=void 0;do{i=(o=2*this.random()-1)*o+(a=2*this.random()-1)*a}while(i>=1||0===i);var s=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*o*s,n=this.mean+this.stdDev*a*s,this.truncated&&!this.isValidTruncated(e)||(r=!0)}return this.truncated&&!this.isValidTruncated(n)||(this.nextVal=this.convertValue(n)),this.convertValue(e)},t.prototype.convertValue=function(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)},t.prototype.isValidTruncated=function(t){return t<=this.upper&&t>=this.lower},t}(),Sr=function(){function t(t,e,n,r){void 0===t&&(t=0),void 0===e&&(e=1),void 0===r&&(r=Math.random());var o=this;if(this.canReturnFloat=function(){return null==o.dtype||"float32"===o.dtype},this.min=t,this.range=e-t,this.dtype=n,!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between "+t+" - "+e+" <= 1 and dtype is not float");this.random=Er(r.toString())}return t.prototype.convertValue=function(t){return this.canReturnFloat()?t:Math.round(t)},t.prototype.nextValue=function(){return this.convertValue(this.min+this.range*this.random())},t}();function Nr(t,e,n){return void 0===e&&(e="float32"),e=e||"float32",K(t),new lt(t,e,n)}function kr(t,e){void 0===e&&(e=!1),console.log(t.toString(e))}var Ir=An({batchToSpaceND_:function(t,e,n){var r=wn(t,"x","batchToSpaceND"),o=e.reduce(function(t,e){return t*e});return d(r.rank>=1+e.length,function(){return"input rank is "+r.rank+" but should be > than blockShape.length "+e.length}),d(n.length===e.length,function(){return"crops.length is "+n.length+" but should be equal to blockShape.length  "+e.length}),d(r.shape[0]%o==0,function(){return"input tensor batch is "+r.shape[0]+" but is not divisible by the product of the elements of blockShape "+e.join(" * ")+" === "+o}),Dt.runKernel(function(t){return t.batchToSpaceND(r,e,n)},{$x:r},function(t){return{$x:function(){return t.spaceToBatchND(e,n)}}})}}),Ar=An({cast_:function(t,e){var n=wn(t,"x","cast");return Dt.runKernel(function(t){return t.cast(n,e)},{$x:n},function(t){return{$x:function(){return t.clone()}}})}}),Tr=An({clone_:function(t){var e=wn(t,"x","clone",null);return Dt.runKernel(function(t){return ft.make(e.shape,{dataId:e.dataId},e.dtype)},{$x:e},function(t){return{$x:function(){return t.toFloat()}}})}}),Dr=An({cumsum_:function(t,e,n,r){void 0===e&&(e=0),void 0===n&&(n=!1),void 0===r&&(r=!1);var o=wn(t,"x","cumsum"),a=rn([e|=0],o.rank),i=o;null!=a&&(i=o.transpose(a));var s=an(1,o.rank)[0],u=Dt.runKernel(function(t){return t.cumsum(i,s,n,r)},{permutedX:i},function(t){return{permutedX:function(){return t.cumsum(e,n,!r)}}});return null!=a&&(u=u.transpose(a)),u}}),Or=An({depthToSpace_:function(t,e,n){void 0===n&&(n="NHWC");var r=wn(t,"x","depthToSpace"),o="NHWC"===n?r.shape[1]:r.shape[2],a="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];return d(o*e>=0,function(){return"Negative dimension size caused by overflow when multiplying\n      "+o+" and "+e+"  for depthToSpace with input shape\n      "+r.shape}),d(a*e>=0,function(){return"Negative dimension size caused by overflow when multiplying\n      "+a+" and "+e+" for depthToSpace with input shape\n          "+r.shape}),d(i%(e*e)==0,function(){return"Dimension size must be evenly divisible by "+e*e+" but is "+i+" for depthToSpace with input shape "+r.shape}),Dt.runKernel(function(t){return t.depthToSpace(r,e,n)},{$x:r})}}),_r=An({expandDims_:function(t,e){void 0===e&&(e=0);var n=wn(t,"x","expandDims");d(e<=n.rank,function(){return"Axis must be <= rank of the tensor"});var r=n.shape.slice();return e<0&&(d(-(n.rank+1)<=e,function(){return"Axis must be in the interval ["+-(n.rank+1)+", "+n.rank+"]"}),e=n.rank+e+1),r.splice(e,0,1),Hr(n,r)}}),Mr=An({eye_:function(t,e,n,r){void 0===r&&(r="float32"),null==e&&(e=t);for(var o=Nr([t,e],r),a=t<=e?t:e,i=0;i<a;++i)o.set(1,i,i);var s=o.toTensor().as2D(t,e);if(null==n)return s;if(1===n.length)return Xr(_r(s,0),[n[0],1,1]);if(2===n.length)return Xr(_r(_r(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return Xr(_r(_r(_r(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D batchShapes, but received "+n.length+"D.")}}),Fr=An({multinomial_:function(t,e,n,r){void 0===r&&(r=!1);var o=wn(t,"logits","multinomial"),a=o.size,i=o.rank;if(a<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+a+".");if(i>2)throw new Error("Rank of probabilities must be 1 or 2, but is "+i);n=n||Math.random();var s=1===i?o.as2D(1,-1):o,u=Dt.runKernel(function(t){return t.multinomial(s,r,e,n)},{logits2D:s});return 1===i?u.as1D():u}}),Br=An({oneHot_:function(t,e,n,r){if(void 0===n&&(n=1),void 0===r&&(r=0),e<2)throw new Error("Error in oneHot: depth must be >=2, but it is "+e);var o=wn(t,"indices","oneHot","int32"),a=o.shape.concat([e]);return o=o.flatten(),Dt.runKernel(function(t){return t.oneHot(o,e,n,r)},{$indices:o},function(t){return{$indices:function(){return qn(o.shape,"float32")}}}).reshape(a)}}),Pr=An({pad_:function(t,e,n){void 0===n&&(n=0);var r=wn(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");var o=e.map(function(t){return t[0]});return Dt.runKernel(function(t){return t.pad(r,e,n)},{$x:r},function(t){return{$x:function(){return t.slice(o,r.shape)}}})}}),Lr=An({pad1d_:function(t,e,n){return void 0===n&&(n=0),d(2===e.length,function(){return"Invalid number of paddings. Must be length of 2."}),Pr(t,[e],n)}}),Wr=An({pad2d_:function(t,e,n){return void 0===n&&(n=0),d(2===e.length&&2===e[0].length&&2===e[1].length,function(){return"Invalid number of paddings. Must be length of 2 each."}),Pr(t,e,n)}}),Ur=An({pad3d_:function(t,e,n){return void 0===n&&(n=0),d(3===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length,function(){return"Invalid number of paddings. Must be length of 2 each."}),Pr(t,e,n)}}),zr=An({pad4d_:function(t,e,n){return void 0===n&&(n=0),d(4===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length&&2===e[3].length,function(){return"Invalid number of paddings. Must be length of 2 each."}),Pr(t,e,n)}}),Vr=An({rand_:function(t,e,n){var r=y(t),o=null;if(null==n||"float32"===n)o=new Float32Array(r);else if("int32"===n)o=new Int32Array(r);else{if("bool"!==n)throw new Error("Unknown data type "+n);o=new Uint8Array(r)}for(var a=0;a<r;a++)o[a]=e();return ft.make(t,{values:o},n)}}),Gr=An({randomNormal_:function(t,e,n,r,o){if(void 0===e&&(e=0),void 0===n&&(n=1),null!=r&&"bool"===r)throw new Error("Unsupported data type "+r);for(var a=new Rr(e,n,r,!1,o),i=Nr(t,r),s=0;s<i.values.length;s++)i.values[s]=a.nextValue();return i.toTensor()}}),qr=An({randomUniform_:function(t,e,n,r,o){void 0===e&&(e=0),void 0===n&&(n=1),void 0===r&&(r="float32");for(var a=Nr(t,r),i=new Sr(e,n,null,o),s=0;s<a.values.length;s++)a.values[s]=i.nextValue();return a.toTensor()}}),Hr=An({reshape_:function(t,e){var n=wn(t,"x","reshape",null);return e=S(e,n.size),d(n.size===y(e),function(){return"new shape and old shape must have the same number of elements."}),Dt.runKernel(function(t){return t.reshape(n,e)},{$x:n},function(t){return{$x:function(){return t.reshape(n.shape)}}})}}),$r=An({spaceToBatchND_:function(t,e,n){var r=wn(t,"x","spaceToBatchND");return d(r.rank>=1+e.length,function(){return"input rank "+r.rank+" should be > than [blockShape] "+e.length}),d(n.length===e.length,function(){return"paddings.shape[0] "+n.length+" must be equal to [blockShape] "+e.length}),d(r.shape.reduce(function(t,r,o){return o>0&&o<=e.length?t&&(r+n[o-1][0]+n[o-1][1])%e[o-1]==0:t},!0),function(){return"input spatial dimensions "+r.shape.slice(1)+" with paddings "+n.toString()+" must be divisible by blockShapes "+e.toString()}),Dt.runKernel(function(t){return t.spaceToBatchND(r,e,n)},{$x:r},function(t){return{$x:function(){return t.batchToSpaceND(e,n)}}})}}),jr=An({squeeze_:function(t,e){var n=wn(t,"x","squeeze");return Hr(n,k(n.shape,e).newShape)}}),Kr=An({stack_:function(t,e){void 0===e&&(e=0);var n=bn(t,"tensors","stack");if(d(n.length>=1,function(){return"Pass at least one tensor to tf.stack"}),1===n.length)return n[0].expandDims(e);var r=n[0].rank,o=n[0].shape,a=n[0].dtype;d(e<=r,function(){return"Axis must be <= rank of the tensor"}),n.forEach(function(t){v(o,t.shape,"All tensors passed to stack must have matching shapes")}),n.forEach(function(t){d(a===t.dtype,function(){return"All tensors passed to stack must have matching dtypes"})});var i=n.map(function(t){return t.expandDims(e)});return lr(i,e)}}),Xr=An({tile_:function(t,e){var n=wn(t,"x","tile");return d(n.rank===e.length,function(){return"Error in transpose: rank of input "+n.rank+" must match length of reps "+e+"."}),Dt.runKernel(function(t,r){var o=t.tile(n,e);return r([n]),o},{$x:n},function(t,n){var r=n[0];return{$x:function(){var n=Xn(r);if(1===r.rank)for(var o=0;o<e[0];++o)n=n.add(t.slice([o*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(o=0;o<e[0];++o)for(var a=0;a<e[1];++a)n=n.add(t.slice([o*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(o=0;o<e[0];++o)for(a=0;a<e[1];++a)for(var i=0;i<e[2];++i)n=n.add(t.slice([o*r.shape[0],a*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+r.rank+" tensors yet.");for(o=0;o<e[0];++o)for(a=0;a<e[1];++a)for(i=0;i<e[2];++i)for(var s=0;s<e[3];++s)n=n.add(t.slice([o*r.shape[0],a*r.shape[1],i*r.shape[2],s*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return n}}})}}),Yr=An({truncatedNormal_:function(t,e,n,r,o){if(void 0===e&&(e=0),void 0===n&&(n=1),null!=r&&"bool"===r)throw new Error("Unsupported data type "+r);for(var a=new Rr(e,n,r,!0,o),i=Nr(t,r),s=0;s<i.values.length;s++)i.values[s]=a.nextValue();return i.toTensor()}}),Qr=An({unstack_:function(t,e){void 0===e&&(e=0),e=e||0;var n=wn(t,"x","unstack");return d(e>=-n.shape.length&&e<n.shape.length,function(){return"Axis = "+e+" is not in [-"+n.shape.length+", "+n.shape.length+")"}),e<0&&(e+=n.shape.length),Dt.runKernel(function(t){return t.unstack(n,e)},{$x:n},function(t){return{$x:function(){return Kr(t,e)}}})}}),Jr=function(t,e){return r(this,void 0,void 0,function(){var n,r,a,i,s,u,l,c,h,p;return o(this,function(o){switch(o.label){case 0:return n=wn(t,"x","setdiff1d"),r=wn(e,"y","setdiff1d"),d(n.dtype===r.dtype,function(){return"x and y should have the same dtype, but got x ("+n.dtype+") and y ("+r.dtype+")."}),d(1===n.rank,function(){return"x should be 1D tensor, but got x ("+n.shape+")."}),d(1===r.rank,function(){return"y should be 1D tensor, but got y ("+r.shape+")."}),[4,n.data()];case 1:return a=o.sent(),[4,r.data()];case 2:for(i=o.sent(),s=new Set(i),u=0,h=0;h<a.length;h++)s.has(a[h])||u++;for(l=new lt([u],n.dtype),c=new lt([u],"int32"),h=0,p=0;h<a.length;h++)s.has(a[h])||(l.values[p]=a[h],c.values[p]=h,p++);return[2,[l.toTensor(),c.toTensor()]]}})})};function Zr(t,e){for(var n=[],r=0;r<e.length;r++)e[r]&&n.push(r);var o=Nr(t,"int32"),a=Nr([n.length,t.length],"int32");for(r=0;r<n.length;r++){var i=o.indexToLoc(n[r]),s=r*t.length;a.values.set(i,s)}return a.toTensor()}var to=function(){return function(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map(function(t,e){return"T"+e});var n=[];this.variableNames.forEach(function(t){n.push("float v"+t+" = get"+t+"AtOutCoords();")});var r=this.variableNames.map(function(t){return"v"+t}).join(" + ");this.userCode="\n      void main() {\n        "+n.join("\n        ")+"\n\n        float result = "+r+";\n        setOutput(result);\n      }\n    "}}(),eo=function(){return function(t,e){this.outputShape=[],this.usesPackedTextures=!0,this.outputShape=t,this.variableNames=e.map(function(t,e){return"T"+e});var n=[];this.variableNames.forEach(function(t){n.push("vec4 v"+t+" = get"+t+"AtOutCoords();")});var r=this.variableNames.map(function(t){return"v"+t}).join(" + ");this.userCode="\n      void main() {\n        "+n.join("\n        ")+"\n\n        vec4 result = "+r+";\n        setOutput(result);\n      }\n    "}}(),no=function(){return function(t,e,n){this.variableNames=["A"];var r=t.windowSize,o=t.batchSize,a=t.inSize,i=Math.ceil(a/r);n||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i];var s="max"===e?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+r+";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < "+r+"; i++) {\n          int inIdx = "+u+";\n          float candidate = getA(batch, inIdx);\n          if (candidate "+s+" bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    "}}();function ro(t,e){return["x","y","z","w","u","v"].slice(0,e).map(function(e){return t+"."+e})}function oo(t,e){return 1===e?[t]:ro(t,e)}function ao(t,e){for(var n=t.length,r=[],o=0;o<n;o++){var a=n-1-o,i=t[a]||1;(e[e.length-1-o]||1)>1&&1===i&&r.unshift(a)}return r}function io(t,e){for(var n=[],r=0;r<e.length;r++){var o=t[t.length-r-1],a=e.length-r-1,i=e[a];(null==o||1===o&&i>1)&&n.unshift(a)}return n}function so(t,e){for(var n=[],r=Math.max(t.length,e.length),o=0;o<r;o++){var a=t[t.length-o-1];null==a&&(a=1);var i=e[e.length-o-1];if(null==i&&(i=1),1===a)n.unshift(i);else if(1===i)n.unshift(a);else{if(a!==i)throw Error("Operands could not be broadcast together with shapes "+t+" and "+e+".");n.unshift(a)}}return n}function uo(){var t,e,n,r,o,i,s,u,l,c;return 2===a.getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",r="in",o="texture",i="outputColor",s="out vec4 outputColor;",u="\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 0. || val == 0.) ? false : true;\n      }\n    ",l="\n      const float INFINITY = uintBitsToFloat(uint(0x7f800000));\n    ",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",r="varying",o="texture2D",i="gl_FragColor",s="",u="\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:o,output:i,defineOutput:s,defineSpecialNaN:u,defineSpecialInf:l,defineRound:c}}function lo(t,e,n){void 0===n&&(n="index");var r=V(e);return r.map(function(e,o){return"int "+t[o]+" = "+n+" / "+e+"; "+(o===r.length-1?"int "+t[o+1]+" = "+n+" - "+t[o]+" * "+e:"index -= "+t[o]+" * "+e)+";"}).join("")}function co(t){return 1===t.length?""+t[0]:"vec"+t.length+"("+t.join(",")+")"}function ho(t,e,n,r){var o=[];t.forEach(function(t){var e=y(t.shapeInfo.logicalShape);t.shapeInfo.isUniform?o.push("uniform float "+t.name+(e>1?"["+e+"]":"")+";"):(o.push("uniform sampler2D "+t.name+";"),o.push("uniform int offset"+t.name+";"))});var a,i,s=o.join("\n"),u=t.map(function(t){return function(t,e,n){void 0===n&&(n=!1);var r="";r+=n?fo(t):po(t);var o=t.shapeInfo.logicalShape,a=e.logicalShape;o.length<=a.length&&(r+=n?function(t,e){var n,r=t.name,o=r.charAt(0).toUpperCase()+r.slice(1),a="get"+o+"AtOutCoords",i=t.shapeInfo.logicalShape.length,s=e.logicalShape.length,u=ao(t.shapeInfo.logicalShape,e.logicalShape),l=bo(s),c=s-i,h=["x","y","z","w","u","v"];n=0===i?"":s<2&&u.length>=1?"coords = 0;":u.map(function(t){return"coords."+h[t+c]+" = 0;"}).join("\n");var p="";p=s<2&&i>0?"coords":t.shapeInfo.logicalShape.map(function(t,e){return"coords."+h[e+c]}).join(", ");var f="return outputValue;",d=1===y(t.shapeInfo.logicalShape),v=1===y(e.logicalShape);if(1!==i||d||v){if(d&&!v)f=1===s?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(u.length){var m=i-2,g=i-1;u.indexOf(m)>-1&&u.indexOf(g)>-1?f="return vec4(outputValue.x);":u.indexOf(m)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":u.indexOf(g)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 "+a+"() {\n      "+l+" coords = getOutputCoords();\n      "+n+"\n      vec4 outputValue = get"+o+"("+p+");\n      "+f+"\n    }\n  "}(t,e):function(t,e){var n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),o="get"+r+"AtOutCoords",a=e.texShape,i=t.shapeInfo.texShape,s=t.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!t.shapeInfo.isUniform&&s===u&&null==t.shapeInfo.flatOffset&&x(i,a))return"\n      float "+o+"() {\n        return sampleTexture("+n+", resultUV);\n      }\n    ";var l,c=bo(u),h=ao(t.shapeInfo.logicalShape,e.logicalShape),p=u-s,f=["x","y","z","w","u","v"];l=0===s?"":u<2&&h.length>=1?"coords = 0;":h.map(function(t){return"coords."+f[t+p]+" = 0;"}).join("\n");var d="";d=u<2&&s>0?"coords":t.shapeInfo.logicalShape.map(function(t,e){return"coords."+f[e+p]}).join(", ");return"\n    float "+o+"() {\n      "+c+" coords = getOutputCoords();\n      "+l+"\n      return get"+r+"("+d+");\n    }\n  "}(t,e));return r}(t,e,r)}).join("\n"),l=e.texShape,c=uo(),h=function(t){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return "+t.texture2D+"(textureSampler, uv).r;\n    }\n  "}(c),p=function(t){return t.version+"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    "+t.varyingFs+" vec2 resultUV;\n    "+t.defineOutput+"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    #define isnan(value) isnan_custom(value)\n    "+t.defineSpecialNaN+"\n    bvec4 isnan_custom(vec4 val) {\n      return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n    }\n\n    "+t.defineSpecialInf+"\n    "+t.defineRound+"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    "+vo+"\n    "+mo+"\n    "+go+"\n  "}(c);return e.isPacked?(a=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e){var n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(1===n[0])return"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * "+n[1]+".0);\n      }\n    ";if(1===n[1])return"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * "+n[0]+".0);\n      }\n    ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      return resTexRC.x * "+n[1]+" + resTexRC.y;\n    }\n  "}(0,e);case 2:return function(t,e){var n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(x(t,e))return"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2("+n[0]+", "+n[1]+"));\n      }\n    ";var r=Math.ceil(t[1]/2);return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n      int r = 2 * (index / "+r+");\n      int c = imod(index, "+r+") * 2;\n\n      return ivec2(r, c);\n    }\n  "}(t,e);case 3:return n=t,r=e,o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],a=Math.ceil(n[2]/2),i=a*Math.ceil(n[1]/2),"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+o[0]+", "+o[1]+"));\n      int index = resTexRC.x * "+o[1]+" + resTexRC.y;\n\n      int b = index / "+i+";\n      index -= b * "+i+";\n\n      int r = 2 * (index / "+a+");\n      int c = imod(index, "+a+") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";default:return function(t,e){for(var n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[t.length-1]/2),o=r*Math.ceil(t[t.length-2]/2),a=o,i="",s="b, r, c",u=2;u<t.length-1;u++)a*=t[t.length-u-1],i="\n      int b"+u+" = index / "+a+";\n      index -= b"+u+" * "+a+";\n    "+i,s="b"+u+", "+s;return"\n    ivec"+t.length+" getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n\n      "+i+"\n\n      int b = index / "+o+";\n      index -= b * "+o+";\n\n      int r = 2 * (index / "+r+");\n      int c = imod(index, "+r+") * 2;\n\n      return ivec"+t.length+"("+s+");\n    }\n  "}(t,e)}var n,r,o,a,i}(e.logicalShape,l),i=function(t){return"\n    void setOutput(vec4 val) {\n      "+t.output+" = val;\n    }\n  "}(c)):(a=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e){if(1===e[0])return"\n      int getOutputCoords() {\n        return int(resultUV.x * "+e[1]+".0);\n      }\n    ";if(1===e[1])return"\n      int getOutputCoords() {\n        return int(resultUV.y * "+e[0]+".0);\n      }\n    ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+e[0]+", "+e[1]+"));\n      return resTexRC.x * "+e[1]+" + resTexRC.y;\n    }\n  "}(0,e);case 2:return function(t,e){if(x(t,e))return"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2("+e[0]+", "+e[1]+"));\n      }\n    ";if(1===t[1])return"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+e[0]+", "+e[1]+"));\n        int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";if(1===t[0])return"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+e[0]+", "+e[1]+"));\n        int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+e[0]+", "+e[1]+"));\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n      int r = index / "+t[1]+";\n      int c = index - r * "+t[1]+";\n      return ivec2(r, c);\n    }\n  "}(t,e);case 3:return n=e,r=lo(["r","c","d"],t),"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n      "+r+"\n      return ivec3(r, c, d);\n    }\n  ";case 4:return function(t,e){var n=lo(["r","c","d","d2"],t);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+e[0]+", "+e[1]+"));\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n      "+n+"\n      return ivec4(r, c, d, d2);\n    }\n  "}(t,e);case 5:return function(t,e){var n=lo(["r","c","d","d2","d3"],t);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2("+e[0]+",\n                             "+e[1]+"));\n\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n\n      "+n+"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  "}(t,e);case 6:return function(t,e){var n=lo(["r","c","d","d2","d3","d4"],t);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+e[0]+", "+e[1]+"));\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n\n      "+n+"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  "}(t,e);default:throw new Error(t.length+"-D output sampling is not yet supported")}var n,r}(e.logicalShape,l),i=function(t){return"\n    void setOutput(float val) {\n      "+t.output+" = vec4(val, 0, 0, 0);\n    }\n  "}(c)),r&&(p+=yo),[p,h,i,s,a,u,n].join("\n")}function po(t){var e=t.shapeInfo.logicalShape;switch(e.length){case 0:return function(t){var e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return"float "+n+"() {return "+e+";}";var r=t.shapeInfo.texShape,o=r[0],a=r[1];if(1===o&&1===a)return"\n      float "+n+"() {\n        return sampleTexture("+e+", halfCR);\n      }\n    ";var i=t.shapeInfo.texShape,s=i[0],u=i[1],l=xo(e);return"\n    float "+n+"() {\n      vec2 uv = uvFromFlat("+s+", "+u+", "+l+");\n      return sampleTexture("+e+", uv);\n    }\n  "}(t);case 1:return function(t){var e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return"\n      float "+n+"(int index) {\n        "+wo(t)+"\n      }\n    ";var r=t.shapeInfo.texShape,o=r[0],a=r[1];if(1===a&&1===o)return"\n      float "+n+"(int index) {\n        return sampleTexture("+e+", halfCR);\n      }\n    ";var i=xo(e);if(1===a)return"\n      float "+n+"(int index) {\n        vec2 uv = vec2(0.5, (float(index + "+i+") + 0.5) / "+o+".0);\n        return sampleTexture("+e+", uv);\n      }\n    ";if(1===o)return"\n      float "+n+"(int index) {\n        vec2 uv = vec2((float(index + "+i+") + 0.5) / "+a+".0, 0.5);\n        return sampleTexture("+e+", uv);\n      }\n    ";return"\n    float "+n+"(int index) {\n      vec2 uv = uvFromFlat("+o+", "+a+", index + "+i+");\n      return sampleTexture("+e+", uv);\n    }\n  "}(t);case 2:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t.shapeInfo.texShape;if(null!=o&&x(e,o)){var a=o[0],i=o[1];return"\n    float "+r+"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2("+i+".0, "+a+".0);\n      return sampleTexture("+n+", uv);\n    }\n  "}var s=k(e),u=s.newShape,l=s.keptDims,c=u;if(c.length<e.length){var h=Co(t,c);return"\n      "+po(h)+"\n      float "+r+"(int row, int col) {\n        return "+r+"("+Eo(["row","col"],l)+");\n      }\n    "}if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2("+e[1]+", 1)));\n        "+wo(t)+"\n      }\n    ";var p=o[0],f=o[1],d=xo(n);if(1===f)return"\n    float "+r+"(int row, int col) {\n      float index = dot(vec3(row, col, "+d+"), vec3("+e[1]+", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / "+p+".0);\n      return sampleTexture("+n+", uv);\n    }\n  ";if(1===p)return"\n    float "+r+"(int row, int col) {\n      float index = dot(vec3(row, col, "+d+"), vec3("+e[1]+", 1, 1));\n      vec2 uv = vec2((index + 0.5) / "+f+".0, 0.5);\n      return sampleTexture("+n+", uv);\n    }\n  ";return"\n  float "+r+"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * "+e[1]+" + col + "+d+";\n    vec2 uv = uvFromFlat("+p+", "+f+", index);\n    return sampleTexture("+n+", uv);\n  }\n"}(t);case 3:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e[1]*e[2],a=e[2],i=k(e),s=i.newShape,u=i.keptDims,l=s;if(l.length<e.length){var c=Co(t,l);return"\n        "+po(c)+"\n        float "+r+"(int row, int col, int depth) {\n          return "+r+"("+Eo(["row","col","depth"],u)+");\n        }\n      "}if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3("+o+", "+a+", 1)));\n        "+wo(t)+"\n      }\n    ";var h=t.shapeInfo.texShape,p=h[0],f=h[1],d=t.shapeInfo.flatOffset;if(f===o&&null==d)return"\n        float "+r+"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2("+a+", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2("+f+".0, "+p+".0);\n          return sampleTexture("+n+", uv);\n        }\n      ";if(f===a&&null==d)return"\n    float "+r+"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2("+e[1]+", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+f+".0, "+p+".0);\n      return sampleTexture("+n+", uv);\n    }\n  ";var v=xo(n);return"\n      float "+r+"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * "+o+" + col * "+a+" + depth + "+v+";\n        vec2 uv = uvFromFlat("+p+", "+f+", index);\n        return sampleTexture("+n+", uv);\n      }\n  "}(t);case 4:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e[3],a=e[2]*o,i=e[1]*a,s=k(e),u=s.newShape,l=s.keptDims;if(u.length<e.length){var c=Co(t,u);return"\n      "+po(c)+"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        return "+r+"("+Eo(["row","col","depth","depth2"],l)+");\n      }\n    "}if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4("+i+", "+a+", "+o+", 1)));\n        "+wo(t)+"\n      }\n    ";var h=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,f=p[0],d=p[1];if(d===i&&null==h)return"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3("+a+", "+o+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+d+".0, "+f+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";if(d===o&&null==h)return"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3("+e[1]*e[2]+", "+e[2]+", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+d+".0, "+f+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";var v=xo(n);return"\n    float "+r+"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+i+" + col * "+a+" +\n          depth * "+o+" + depth2;\n      vec2 uv = uvFromFlat("+f+", "+d+", index + "+v+");\n      return sampleTexture("+n+", uv);\n    }\n  "}(t);case 5:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e[4],a=e[3]*o,i=e[2]*a,s=e[1]*i,u=k(e),l=u.newShape,c=u.keptDims;if(l.length<e.length){var h=Co(t,l);return"\n      "+po(h)+"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        return "+r+"("+Eo(["row","col","depth","depth2","depth3"],c)+");\n      }\n    "}if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+s+", "+i+", "+a+", "+o+")) +\n          depth3;\n        "+wo(t)+"\n      }\n    ";var p=t.shapeInfo.flatOffset,f=t.shapeInfo.texShape,d=f[0],v=f[1];if(v===s&&null==p)return"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4("+i+", "+a+", "+o+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+v+".0, "+d+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";if(v===o&&null==p)return"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+e[1]*e[2]*e[3]+",\n               "+e[2]*e[3]+", "+e[3]+", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+v+".0, "+d+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";var m=xo(n);return"\n    float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+s+" + col * "+i+" + depth * "+a+" +\n          depth2 * "+o+" + depth3 + "+m+";\n      vec2 uv = uvFromFlat("+d+", "+v+", index);\n      return sampleTexture("+n+", uv);\n    }\n  "}(t);case 6:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=k(e),a=o.newShape,i=o.keptDims;if(a.length<e.length){var s=Co(t,a);return"\n      "+po(s)+"\n      float "+r+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return "+r+"("+Eo(["row","col","depth","depth2","depth3","depth4"],i)+");\n      }\n    "}var u=e[5],l=e[4]*u,c=e[3]*l,h=e[2]*c,p=e[1]*h;if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4("+p+", "+h+", "+c+", "+l+")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2("+u+", 1)));\n        "+wo(t)+"\n      }\n    ";var f=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,v=d[0],m=d[1];if(m===p&&null==f)return"\n      float "+r+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4("+h+", "+c+", "+l+", "+u+")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+m+".0, "+v+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";if(m===u&&null==f)return"\n      float "+r+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4("+e[1]*e[2]*e[3]*e[4]+",\n               "+e[2]*e[3]*e[4]+",\n               "+e[3]*e[4]+",\n               "+e[4]+")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+m+".0, "+v+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";var g=xo(n);return"\n    float "+r+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+p+" + col * "+h+" + depth * "+c+" +\n          depth2 * "+l+" + depth3 * "+u+" + depth4 + "+g+";\n      vec2 uv = uvFromFlat("+v+", "+m+", index);\n      return sampleTexture("+n+", uv);\n    }\n  "}(t);default:throw new Error(e.length+"-D input sampling is not yet supported")}}function fo(t){var e,n,r;switch(t.shapeInfo.logicalShape.length){case 0:return e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=uo(),"\n    vec4 "+n+"() {\n      return "+r.texture2D+"("+e+", halfCR);\n    }\n  ";case 1:return function(t){var e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t.shapeInfo.texShape,o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],a=uo();return"\n    vec4 "+n+"(int index) {\n      vec2 uv = packedUVfrom1D(\n        "+o[0]+", "+o[1]+", index);\n      return "+a.texture2D+"("+e+", uv);\n    }\n  "}(t);case 2:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t.shapeInfo.texShape,a=o[0],i=o[1],s=uo();if(null!=o&&x(e,o))return"\n      vec4 "+r+"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2("+i+".0, "+a+".0);\n\n        return "+s.texture2D+"("+n+", uv);\n      }\n    ";var u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],l=Math.ceil(e[1]/2);return"\n    vec4 "+r+"(int row, int col) {\n      vec2 uv = packedUVfrom2D("+l+", "+u[0]+", "+u[1]+", row, col);\n      return "+s.texture2D+"("+n+", uv);\n    }\n  "}(t);case 3:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===e[0]){var i=e.slice(1),s=Co(t,i);return"\n        "+fo(s)+"\n        vec4 "+r+"(int b, int row, int col) {\n          return "+r+"("+Eo(["b","row","col"],[1,2])+");\n        }\n      "}var u=a[0],l=a[1],c=Math.ceil(e[2]/2),h=c*Math.ceil(e[1]/2),p=uo();return"\n    vec4 "+r+"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        "+u+", "+l+", "+h+", "+c+", b, row, col);\n      return "+p.texture2D+"("+n+", uv);\n    }\n  "}(t);default:return function(t){for(var e=t.shapeInfo.logicalShape,n=e.length,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),a=t.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],s=i[0],u=i[1],l=Math.ceil(e[n-1]/2),c=l*Math.ceil(e[n-2]/2),h="int b, int row, int col",p="b * "+c+" + (row / 2) * "+l+" + (col / 2)",f=2;f<n-1;f++)h="int b"+f+", "+h,c*=e[n-f-1],p="b"+f+" * "+c+" + "+p;var d=uo();return"\n    vec4 "+o+"("+h+") {\n      int index = "+p+";\n      int texR = index / "+u+";\n      int texC = index - texR * "+u+";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+u+", "+s+");\n      return "+d.texture2D+"("+r+", uv);\n    }\n  "}(t)}}var vo="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",mo="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",go="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",yo="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function xo(t){return"offset"+t}function wo(t){var e=t.name,n=y(t.shapeInfo.logicalShape);return n<2?"return "+e+";":"\n    for (int i = 0; i < "+n+"; i++) {\n      if (i == index) {\n        return "+e+"[i];\n      }\n    }\n  "}function bo(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error("GPU for rank "+t+" is not yet supported")}function Co(t,e){var n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function Eo(t,e){return e.map(function(e){return t[e]}).join(", ")}var Ro=function(){return function(t,e,n,r){this.variableNames=["A"],this.usesPackedTextures=!0,d(t.length>2,function(){return"Packed arg"+(n.charAt(0).toUpperCase()+n.slice(1))+" supports only inputs with rank above 2."});var o=t[t.length-1],a=Math.ceil(o/e);this.outputShape=t.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");var i,s,u=this.outputShape,l=u.length,c=bo(l),h=oo("coords",l);if(1===a){var p=bo(s=l+1);i="\n        "+p+" sourceLocR = "+p+"("+h.join()+", 0);\n        ++"+h[l-1]+";\n        "+p+" sourceLocG = "+p+"("+h.join()+", 0);\n        ++"+h[l-2]+";\n        "+p+" sourceLocA = "+p+"("+h.join()+", 0);\n        --"+h[l-1]+";\n        "+p+" sourceLocB = "+p+"("+h.join()+", 0);\n        --"+h[l-2]+";"}else s=l,i="\n        "+c+" sourceLocR = coords;\n        ++"+h[l-1]+";\n        "+c+" sourceLocG = coords;\n        ++"+h[l-2]+";\n        "+c+" sourceLocA = coords;\n        --"+h[l-1]+";\n        "+c+" sourceLocB = coords;\n        --"+h[l-2]+";";var f=["x","y","z","w","u","v"].slice(0,s),v="."+f[s-1],m=f.map(function(t){return"int "+t}),g=oo("sourceLocR",s-1).concat("inIdx.r"),y=oo("sourceLocG",s-1).concat("inIdx.g"),x=oo("sourceLocB",s-1).concat("inIdx.b"),w=oo("sourceLocA",s-1).concat("inIdx.a"),b="max"===n?"greaterThan":"lessThan",C=r?"":"\n          inIdx = round(vec4(getBestIndicesAChannel("+g.join()+"),\n                             getBestIndicesAChannel("+y.join()+"),\n                             getBestIndicesAChannel("+x.join()+"),\n                             getBestIndicesAChannel("+w.join()+")));",E="vec4(\n            getAChannel("+g.join()+"),\n            hasNextCol ? getAChannel("+y.join()+") : 0.,\n            hasNextRow ? getAChannel("+x.join()+") : 0.,\n            hasNextRow && hasNextCol ? getAChannel("+w.join()+") : 0.)",R=r?"":"\n      float getBestIndicesAChannel("+m.join()+") {\n        return getChannel(getBestIndicesA("+f.join()+"),\n                                          vec2("+f.slice(-2).join()+"));\n      }";this.userCode="\n      float getAChannel("+m.join()+") {\n        return getChannel(getA("+f.join()+"),\n                               vec2("+f.slice(-2).join()+"));\n      }\n      "+R+"\n      void main() {\n        "+c+" coords = getOutputCoords();\n        bool hasNextCol = "+h[l-1]+" < "+(u[l-1]-1)+";\n        bool hasNextRow = "+h[l-2]+" < "+(u[l-2]-1)+";\n        "+i+"\n        ivec4 srcIdx = ivec4(sourceLocR"+v+", sourceLocG"+v+",\n          sourceLocB"+v+", sourceLocA"+v+") * "+e+";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = "+E+";\n\n        for (int i = 0; i < "+e+"; i++) {\n          inIdx = srcIdx;\n          "+C+"\n          vec4 candidate = "+E+";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4("+b+"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    "}}(),So=function(){return function(t){this.variableNames=["dy"],this.outputShape=t.inShape;var e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,o=t.strideWidth,a=t.dilationHeight,i=t.dilationWidth,s=t.effectiveFilterHeight,u=t.effectiveFilterWidth,l=s-1-t.padInfo.top,c=u-1-t.padInfo.left,h=1/(e*n);this.userCode="\n      const ivec2 pads = ivec2("+l+", "+c+");\n      const float avgMultiplier = float("+h+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+s+";\n            wR += "+a+") {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+t.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+u+";\n            wC+= "+i+") {\n            float dyC = float(dyCCorner + wC) / "+o+".0;\n\n            if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),No=function(){return function(t,e,n,r,o,a){this.outputShape=[],this.variableNames=["x","mean","variance"],so(t,e),so(t,n);var i="0.0";null!=r&&(so(t,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");var s="1.0";null!=o&&(so(t,o),this.variableNames.push("scale"),s="getScaleAtOutCoords()"),this.outputShape=t,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = "+i+";\n        float scale = "+s+";\n        float inv = scale * inversesqrt(variance + float("+a+"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    "}}(),ko=function(){return function(t,e,n,r,o,a){this.usesPackedTextures=!0,this.variableNames=["x","mean","variance"],so(t,e),so(t,n);var i="vec4(0.0)";null!=r&&(so(t,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");var s="vec4(1.0)";null!=o&&(so(t,o),this.variableNames.push("scale"),s="getScaleAtOutCoords()"),this.outputShape=t,this.userCode="\n      void main() {\n        vec4 offset = "+i+";\n        vec4 scale = "+s+";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4("+a+"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    "}}(),Io="return areal * breal - aimag * bimag;",Ao="return areal * bimag + aimag * breal;",To=function(){return function(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=so(e,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        "+t+"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    "}}(),Do="return a + b;",Oo="return a - b;",_o="return a * b;",Mo=function(){return function(t,e,n){this.variableNames=["A","B"],this.outputShape=so(e,n),this.userCode="\n      float binaryOperation(float a, float b) {\n        "+t+"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    "}}(),Fo=function(){return function(t,e,n,r){void 0===r&&(r=!1),this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.usesPackedTextures=!0,this.outputShape=so(e,n);var o=this.outputShape.length,a="";if(r)if(0===o||1===y(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(a="\n          "+bo(o)+" coords = getOutputCoords();\n        ",1===o)a+="\n            result.y = (coords + 1) >= "+this.outputShape[0]+" ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";else{var i=oo("coords",o);a+="\n            bool nextRowOutOfBounds =\n              ("+i[o-2]+" + 1) >= "+this.outputShape[o-2]+";\n            bool nextColOutOfBounds =\n              ("+i[o-1]+" + 1) >= "+this.outputShape[o-1]+";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        "+t+"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        "+a+"\n\n        setOutput(result);\n      }\n    "}}(),Bo=function(){function t(t){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      uniform float min;\n      uniform float max;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, min, max));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t,e){var n=this;return function(r,o){null==n.minLoc&&(n.minLoc=r.getUniformLocationNoThrow(o,"min"),n.maxLoc=r.getUniformLocationNoThrow(o,"max")),r.gl.uniform1f(n.minLoc,t),r.gl.uniform1f(n.maxLoc,e)}},t}(),Po=function(){function t(t){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=t,this.userCode="\n      uniform float min;\n      uniform float max;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(min), vec4(max)));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t,e){var n=this;return function(r,o){null==n.minLoc&&(n.minLoc=r.getUniformLocationNoThrow(o,"min"),n.maxLoc=r.getUniformLocationNoThrow(o,"max")),r.gl.uniform1f(n.minLoc,t),r.gl.uniform1f(n.maxLoc,e)}},t}(),Lo=function(){return function(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}(),Wo=function(){return function(t){this.outputShape=[],this.outputShape=sn(t,1),this.variableNames=t.map(function(t,e){return"T"+e});var e=new Array(t.length-1);e[0]=t[0][1];for(var n=1;n<e.length;n++)e[n]=e[n-1]+t[n][1];var r=["if (yC < "+e[0]+") setOutput(getT0(yR, yC));"];for(n=1;n<e.length;n++){var o=e[n-1];r.push("else if (yC < "+e[n]+") setOutput(getT"+n+"(yR, yC-"+o+"));")}var a=e.length,i=e[e.length-1];r.push("else setOutput(getT"+a+"(yR, yC-"+i+"));"),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        "+r.join("\n        ")+"\n      }\n    "}}(),Uo=function(){return function(t,e){this.usesPackedTextures=!0,this.outputShape=[],this.outputShape=sn(t,e);var n=this.outputShape,r=n.length,o=bo(r),a=oo("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map(function(t,e){return"T"+e});var s=new Array(t.length-1);s[0]=t[0][e];for(var u=1;u<s.length;u++)s[u]=s[u-1]+t[u][e];var l=i[e],c="vec2("+i.slice(-2).join()+")",h=i.join(),p="if ("+l+" < "+s[0]+")\n          return getChannel(getT0("+h+"), "+c+");";for(u=1;u<s.length;u++){var f=s[u-1];p+="\n        else if ("+l+" < "+s[u]+") {\n          "+l+" -= "+f+";\n          return getChannel(getT"+u+"("+h+"), "+c+");\n        }"}var d=s.length;p+="\n        else {\n          "+l+" -= "+s[s.length-1]+";\n          return getChannel(getT"+d+"("+h+"), "+c+");\n        }",this.userCode="\n      float getValue("+i.map(function(t){return"int "+t})+") {\n        "+p+"\n      }\n\n      void main() {\n        "+o+" coords = getOutputCoords();\n        vec4 result = vec4(getValue("+a+"), 0., 0., 0.);\n        if (++"+a[r-1]+" < "+n[r-1]+") {\n          result.g = getValue("+a+");\n        }\n        if (++"+a[r-2]+" < "+n[r-2]+") {\n          result.a = getValue("+a+");\n        }\n        if ("+a[r-2]+" < "+n[r-2]+" &&\n            --"+a[r-1]+" < "+n[r-1]+") {\n          result.b = getValue("+a+");\n        }\n        setOutput(result);\n      }\n    "}}(),zo=function(){return function(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;var e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,o=t.padInfo.left;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+t.batchSize+"; b++) {\n          for (int yR = 0; yR < "+t.outHeight+"; yR++) {\n            int xR = wR + yR * "+e+" - "+r+";\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+t.outWidth+"; yC++) {\n              int xC = wC + yC * "+n+" - "+o+";\n\n              if (xC < 0 || xC >= "+t.inWidth+") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Vo=function(){return function(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;var e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,o=t.strideWidth,a=e-1-t.padInfo.top,i=n-1-t.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2("+a+", "+i+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+e+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+t.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+e+" - 1 - wR;\n\n          for (int wC = 0; wC < "+n+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+o+".0;\n\n            if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+n+" - 1 - wC;\n\n            for (int d2 = 0; d2 < "+t.outChannels+"; d2++) {\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Go=function(){return function(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;var e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,o=t.padInfo.front,a=t.padInfo.top,i=t.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+t.batchSize+"; b++) {\n          for (int yF = 0; yF < "+t.outDepth+"; yF++) {\n            int xF = wF + yF * "+e+" - "+o+";\n\n            if (xF < 0 || xF >= "+t.inDepth+") {\n              continue;\n            }\n\n            for (int yR = 0; yR < "+t.outHeight+"; yR++) {\n              int xR = wR + yR * "+n+" - "+a+";\n\n              if (xR < 0 || xR >= "+t.inHeight+") {\n                continue;\n              }\n\n              for (int yC = 0; yC < "+t.outWidth+"; yC++) {\n                int xC = wC + yC * "+r+" - "+i+";\n\n                if (xC < 0 || xC >= "+t.inWidth+") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),qo=function(){return function(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;var e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,o=t.strideDepth,a=t.strideHeight,i=t.strideWidth,s=e-1-t.padInfo.front,u=n-1-t.padInfo.top,l=r-1-t.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3("+s+", "+u+", "+l+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < "+e+"; wF++) {\n          float dyF = float(dyFCorner + wF) / "+o+".0;\n\n          if (dyF < 0.0 || dyF >= "+t.outDepth+".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = "+e+" - 1 - wF;\n\n          for (int wR = 0; wR < "+n+"; wR++) {\n            float dyR = float(dyRCorner + wR) / "+a+".0;\n\n            if (dyR < 0.0 || dyR >= "+t.outHeight+".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = "+n+" - 1 - wR;\n\n            for (int wC = 0; wC < "+r+"; wC++) {\n              float dyC = float(dyCCorner + wC) / "+i+".0;\n\n              if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = "+r+" - 1 - wC;\n\n              for (int d2 = 0; d2 < "+t.outChannels+"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Ho=function(){return function(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;var e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,o=t.padInfo.left,a=t.outChannels/t.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * "+a+" + dm;\n\n        float dotProd = 0.0;\n\n        // TODO: Vec4 over the batch size\n        for (int b = 0; b < "+t.batchSize+"; b++) {\n          for (int yR = 0; yR < "+t.outHeight+"; yR++) {\n            int xR = wR + yR * "+e+" - "+r+";\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+t.outWidth+"; yC++) {\n              int xC = wC + yC * "+n+" - "+o+";\n\n              if (xC < 0 || xC >= "+t.inWidth+") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),$o=function(){return function(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;var e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,o=t.strideWidth,a=e-1-t.padInfo.top,i=n-1-t.padInfo.left,s=t.outChannels/t.inChannels;this.userCode="\n      const ivec2 pads = ivec2("+a+", "+i+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < "+e+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+t.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+e+" - 1 - wR;\n\n          for (int wC = 0; wC < "+n+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+o+".0;\n\n            if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+n+" - 1 - wC;\n\n            // TODO: Vec4 over the channelMul\n            for (int dm = 0; dm < "+s+"; dm++) {\n              int d2 = d1 * "+s+" + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),jo=function(){return function(t){this.variableNames=["x","W"],this.outputShape=t.outShape;var e=t.padInfo.top,n=t.padInfo.left,r=t.strideHeight,o=t.strideWidth,a=t.dilationHeight,i=t.dilationWidth,s=t.filterHeight,u=t.filterWidth,l=4*Math.floor(t.inChannels/4),c=t.inChannels%4;this.userCode="\n      const ivec2 strides = ivec2("+r+", "+o+");\n      const ivec2 pads = ivec2("+e+", "+n+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+s+"; wR++) {\n          int xR = xRCorner + wR * "+a+";\n\n          if (xR < 0 || xR >= "+t.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+u+"; wC++) {\n            int xC = xCCorner + wC * "+i+";\n\n            if (xC < 0 || xC >= "+t.inWidth+") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < "+l+"; d1 += 4) {\n              vec4 xValues = vec4(\n                getX(batch, xR, xC, d1),\n                getX(batch, xR, xC, d1 + 1),\n                getX(batch, xR, xC, d1 + 2),\n                getX(batch, xR, xC, d1 + 3)\n              );\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              dotProd += dot(xValues, wValues);\n            }\n\n            if ("+(1===c)+") {\n              dotProd +=\n                getX(batch, xR, xC, "+l+") *\n                getW(wR, wC, "+l+", d2);\n            } else if ("+(2===c)+") {\n              vec2 xValues = vec2(\n                getX(batch, xR, xC, "+l+"),\n                getX(batch, xR, xC, "+l+" + 1)\n              );\n              vec2 wValues = vec2(\n                getW(wR, wC, "+l+", d2),\n                getW(wR, wC, "+l+" + 1, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            } else if ("+(3===c)+") {\n              vec3 xValues = vec3(\n                getX(batch, xR, xC, "+l+"),\n                getX(batch, xR, xC, "+l+" + 1),\n                getX(batch, xR, xC, "+l+" + 2)\n              );\n              vec3 wValues = vec3(\n                getW(wR, wC, "+l+", d2),\n                getW(wR, wC, "+l+" + 1, d2),\n                getW(wR, wC, "+l+" + 2, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Ko=function(){return function(t){this.variableNames=["x","W"],this.outputShape=t.outShape;var e=t.padInfo.front,n=t.padInfo.top,r=t.padInfo.left,o=t.strideDepth,a=t.strideHeight,i=t.strideWidth,s=t.dilationDepth,u=t.dilationHeight,l=t.dilationWidth,c=t.filterDepth,h=t.filterHeight,p=t.filterWidth,f=4*Math.floor(t.inChannels/4),d=t.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3("+o+", "+a+", "+i+");\n      const ivec3 pads = ivec3("+e+", "+n+", "+r+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < "+c+"; wF++) {\n          int xF = xFCorner + wF * "+s+";\n\n          if (xF < 0 || xF >= "+t.inDepth+") {\n            continue;\n          }\n\n          for (int wR = 0; wR < "+h+"; wR++) {\n            int xR = xRCorner + wR * "+u+";\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+p+"; wC++) {\n              int xC = xCCorner + wC * "+l+";\n\n              if (xC < 0 || xC >= "+t.inWidth+") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < "+f+"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if ("+(1===d)+") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, "+f+") *\n                  getW(wF, wR, wC, "+f+", d2);\n              } else if ("+(2===d)+") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, "+f+"),\n                  getX(batch, xF, xR, xC, "+f+" + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, "+f+", d2),\n                  getW(wF, wR, wC, "+f+" + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if ("+(3===d)+") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, "+f+"),\n                  getX(batch, xF, xR, xC, "+f+" + 1),\n                  getX(batch, xF, xR, xC, "+f+" + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, "+f+", d2),\n                  getW(wF, wR, wC, "+f+" + 1, d2),\n                  getW(wF, wR, wC, "+f+" + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Xo=function(){return function(t){this.variableNames=["x","W"],this.outputShape=t.outShape;var e=t.inHeight,n=t.inWidth,r=t.padInfo.top,o=t.padInfo.left,a=t.strideHeight,i=t.strideWidth,s=t.dilationHeight,u=t.dilationWidth,l=t.filterHeight,c=t.filterWidth,h=t.outChannels/t.inChannels;this.userCode="\n      const ivec2 strides = ivec2("+a+", "+i+");\n      const ivec2 pads = ivec2("+r+", "+o+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / "+h+";\n        int q = d2 - d1 * "+h+";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < "+l+"; wR++) {\n          int xR = xRCorner + wR * "+s+";\n\n          if (xR < 0 || xR >= "+e+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+c+"; wC++) {\n            int xC = xCCorner + wC * "+u+";\n\n            if (xC < 0 || xC >= "+n+") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Yo=function(){return function(t){this.variableNames=["x","W"],this.usesPackedTextures=!0,this.outputShape=t.outShape;for(var e=t.inHeight,n=t.inWidth,r=t.padInfo.top,o=t.padInfo.left,a=t.strideHeight,i=t.strideWidth,s=t.dilationHeight,u=t.dilationWidth,l=t.filterHeight,c=t.filterWidth,h=c,f="int xR; int xC; int xCOffset;",d=0;d<l;d++)for(var v=0;v<c;v++)f+="\n          vec4 xTexelR"+d+"C"+2*v+" = vec4(0.);\n          vec4 wR"+d+"C"+v+" = vec4(0.);\n          vec4 xR"+d+"C"+v+" = vec4(0.);";for(d=0;d<l;d++)for(var m=0;m<h;m++){if(f+="\n          xR = xRCorner + "+d*s+";\n          xC = xCCorner + "+(v=2*m)*u+";\n        ",1===i){if(v<c&&(f+=o%2==1?"\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < "+e+" && xCOffset >= 0 && xCOffset < "+n+") {\n                  xTexelR"+d+"C"+v+" = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+d+"C"+v+" = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < "+e+" && xCOffset >= 0 && xCOffset < "+n+") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n                  xR"+d+"C"+v+" = vec4(previous.zw, xTexelR"+d+"C"+v+".xy);\n                } else {\n                  xR"+d+"C"+v+" = vec4(0, 0, xTexelR"+d+"C"+v+".xy);\n                }\n              ":"\n                if(xR >= 0 && xR < "+e+" && xC >= 0 && xC < "+n+") {\n                  xTexelR"+d+"C"+v+" = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR"+d+"C"+v+" = vec4(0.);\n                }\n\n                xR"+d+"C"+v+" = xTexelR"+d+"C"+v+";\n              ",v+1<c)){var g=o%2==0?p(u):u;u%2==0&&o%2==1||u%2!=0&&o%2!=1?(f+="\n                  xCOffset = xC + "+o%2+" + "+g+";\n\n                  if(xR >= 0 && xR < "+e+" &&\n                    xCOffset >= 0 && xCOffset < "+n+") {\n                    xTexelR"+d+"C"+(v+2)+" = getX(batch, xR, xCOffset, d1);\n                  }\n                ",u>1&&(f+="\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < "+e+" &&\n                      xCOffset >= 0 && xCOffset < "+n+") {\n                      xTexelR"+d+"C"+v+" = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR"+d+"C"+v+" = vec4(0.);\n                    }\n                  "),f+="\n                  xR"+d+"C"+(v+1)+" = vec4(\n                    xTexelR"+d+"C"+v+".zw, xTexelR"+d+"C"+(v+2)+".xy);\n                "):f+="\n                  xCOffset = xC + "+g+";\n\n                  if(xR >= 0 && xR < "+e+" &&\n                    xCOffset >= 0 && xCOffset < "+n+") {\n                    xTexelR"+d+"C"+(v+2)+" = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR"+d+"C"+(v+1)+" = xTexelR"+d+"C"+(v+2)+";\n                "}}else v<c&&(f+="\n              if(xR >= 0 && xR < "+e+") {\n            ",o%2==1?(f+="\n                xCOffset = xC + 1 - "+i+";\n                if(xCOffset >= 0 && xCOffset < "+n+") {\n                  xTexelR"+d+"C"+v+" = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+d+"C"+v+" = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < "+n+") {\n                  xTexelR"+d+"C"+(v+2)+" = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR"+d+"C"+(v+2)+" = vec4(0.);\n                }\n\n                xR"+d+"C"+v+" = vec4(\n                  xTexelR"+d+"C"+v+".zw, xTexelR"+d+"C"+(v+2)+".zw);\n              ",v+1<c&&(f+="\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + "+i+";\n                  if(xCOffset >= 0 && xCOffset < "+n+") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR"+d+"C"+(v+1)+" = vec4(xTexelR"+d+"C"+(v+2)+".xy, final.xy);\n                ")):(f+="\n                if(xC >= 0 && xC < "+n+") {\n                  xTexelR"+d+"C"+v+" = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR"+d+"C"+v+" = vec4(0.);\n                }\n\n                xCOffset = xC + "+i+";\n                if(xCOffset >= 0 && xCOffset < "+n+") {\n                  xTexelR"+d+"C"+(v+2)+" = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+d+"C"+(v+2)+" = vec4(0.);\n                }\n\n                xR"+d+"C"+v+" = vec4(\n                  xTexelR"+d+"C"+v+".xy, xTexelR"+d+"C"+(v+2)+".xy);\n              ",v+1<c&&(f+="\n                  xR"+d+"C"+(v+1)+" = vec4(\n                    xTexelR"+d+"C"+v+".zw, xTexelR"+d+"C"+(v+2)+".zw);\n                ")),f+="}");v<c&&(f+="\n            vec4 wTexelR"+d+"C"+v+" = getW("+d+", "+v+", d1, q);\n            wR"+d+"C"+v+" = vec4(wTexelR"+d+"C"+v+".xz, wTexelR"+d+"C"+v+".xz);\n          ",v+1<c&&(f+="\n              vec4 wTexelR"+d+"C"+(v+1)+" = getW("+d+", "+(v+1)+", d1, q);\n              wR"+d+"C"+(v+1)+" =\n                vec4(wTexelR"+d+"C"+(v+1)+".xz, wTexelR"+d+"C"+(v+1)+".xz);"))}for(d=0;d<l;d++)for(v=0;v<c;v++)f+="result += xR"+d+"C"+v+" * wR"+d+"C"+v+";";this.userCode="\n      const ivec2 strides = ivec2("+a+", "+i+");\n      const ivec2 pads = ivec2("+r+", "+o+");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 result = vec4(0.);\n\n        "+f+"\n\n        setOutput(result);\n      }\n    "}}(),Qo=function(){return function(t,e,n,r,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];var a=t[0],i=t[1],s=t[2],u=t[3],l=e[0],c=n[0],h=n[1];this.outputShape=[l,c,h,u];var p="bilinear"===r?1:0,f=[i-1+".0",s-1+".0"],d=f[0],v=f[1],m=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio","y1*"+d+" + float(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+d],g=m[0],y=m[1],x=m[2],w=h>1?[""+(s-1)/(h-1),"(x2-x1) * width_ratio","x1*"+v+" + float(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+v],b=w[0],C=w[1],E=w[2];this.userCode="\n      const float height_ratio = float("+g+");\n      const float width_ratio = float("+b+");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= "+a+") {\n          return;\n        }\n\n        float height_scale = "+y+";\n        float width_scale = "+C+";\n\n        float in_y = "+x+";\n        if( in_y < 0.0 || in_y > "+d+" ) {\n          setOutput(float("+o+"));\n          return;\n        }\n        float in_x = "+E+";\n        if( in_x < 0.0 || in_x > "+v+" ) {\n          setOutput(float("+o+"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if("+p+" == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    "}}(),Jo=function(){return function(t,e,n){this.variableNames=["x"],this.outputShape=t;var r=t.length,o=t[t.length-1],a=n?"<":">";this.userCode="\n      int getIndex(int i) {\n        "+(n?"return "+o+" -i - 1;":"return i;")+"\n      }\n\n      void main() {\n        "+bo(r)+" coords = getOutputCoords();\n        int end = "+Zo(r,"coords")+";\n        float val = 0.0;\n        for (int i = "+o+" - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx "+a+" end) {\n            continue;\n          }\n          if (idx == end && "+e+") {\n            continue;\n          }\n          "+Zo(r,"coords")+" = idx;\n          val += getX("+function(t,e){if(1===t)return""+e;if(2===t)return e+".x, "+e+".y";if(3===t)return e+".x, "+e+".y, "+e+".z";if(4===t)return e+".x, "+e+".y, "+e+".z, "+e+".w";throw Error("Cumulative sum for rank "+t+" is not yet supported")}(r,"coords")+");\n        }\n        setOutput(val);\n      }\n    "}}();function Zo(t,e){if(1===t)return""+e;if(2===t)return e+".y";if(3===t)return e+".z";if(4===t)return e+".w";throw Error("Cumulative sum for rank "+t+" is not yet supported")}var ta=function(){function t(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = "+this.getHeightCoordString()+";\n      int w = "+this.getWidthCoordString()+";\n      int d = "+this.getDepthCoordString()+";\n\n      int in_h = h / "+e+";\n      int offset_h = imod(h, "+e+");\n      int in_w = w / "+e+";\n      int offset_w = imod(w, "+e+");\n      int offset_d = (offset_h * "+e+" + offset_w) *\n        "+this.getOutputDepthSize()+";\n      int in_d = d + offset_d;\n\n      float result = "+this.getInputSamplingString()+";\n      setOutput(result);\n    }\n  "}return t.prototype.getHeightCoordString=function(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"},t.prototype.getWidthCoordString=function(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"},t.prototype.getDepthCoordString=function(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"},t.prototype.getOutputDepthSize=function(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]},t.prototype.getInputSamplingString=function(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"},t}(),ea=function(){return function(t){this.variableNames=["A"];var e=uo();this.outputShape=t,this.userCode="\n      const float FLOAT_MAX = 1.70141184e38;\n      const float FLOAT_MIN = 1.17549435e-38;\n\n      lowp vec4 encode_float(highp float v) {\n        if (isnan(v)) {\n          return vec4(255, 255, 255, 255);\n        }\n\n        highp float av = abs(v);\n\n        if(av < FLOAT_MIN) {\n          return vec4(0.0, 0.0, 0.0, 0.0);\n        } else if(v > FLOAT_MAX) {\n          return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n        } else if(v < -FLOAT_MAX) {\n          return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n        }\n\n        highp vec4 c = vec4(0,0,0,0);\n\n        highp float e = floor(log2(av));\n        highp float m = exp2(fract(log2(av))) - 1.0;\n\n        c[2] = floor(128.0 * m);\n        m -= c[2] / 128.0;\n        c[1] = floor(32768.0 * m);\n        m -= c[1] / 32768.0;\n        c[0] = floor(8388608.0 * m);\n\n        highp float ebias = e + 127.0;\n        c[3] = floor(ebias / 2.0);\n        ebias -= c[3] * 2.0;\n        c[2] += floor(ebias) * 128.0;\n\n        c[3] += 128.0 * step(0.0, -v);\n\n        return c / 255.0;\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        "+e.output+" = encode_float(x);\n      }\n    "}}(),na="return real * expR - imag * expI;",ra="return real * expI + imag * expR;",oa=function(){return function(t,e,n){this.variableNames=["real","imag"];var r=e[1];this.outputShape=e;var o=n?"2.0 * "+Math.PI:"-2.0 * "+Math.PI,a=n?r+".0":"1.0";this.userCode="\n      const float exponentMultiplier = "+o+";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        "+t+"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float("+r+");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < "+r+"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / "+a+";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    "}}(),aa=function(){function t(t,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t){var e=this;return function(n,r){null==e.valueLoc&&(e.valueLoc=n.getUniformLocationNoThrow(r,"value")),n.gl.uniform1f(e.valueLoc,t)}},t}(),ia=function(){return function(t){this.variableNames=["A"];var e=uo(),n=t[0],r=t[1];this.outputShape=t,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+r+".0, "+n+".0);\n\n        vec4 values = "+e.texture2D+"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    "}}(),sa=function(){return function(t,e,n){this.variableNames=["A","indices"];var r=t.slice();r[n]=e,this.outputShape=r,this.rank=r.length;var o=bo(this.rank),a=function(t,e){var n=t.length;if(n>4)throw Error("Gather for rank "+n+" is not yet supported");if(1===n)return"int(getIndices(resRC))";for(var r=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],a=0;a<t.length;a++)a===e?o.push("int(getIndices("+r[a]+"))"):o.push(""+r[a]);return o.join()}(t,n);this.userCode="\n      void main() {\n        "+o+" resRC = getOutputCoords();\n        setOutput(getA("+a+"));\n      }\n    "}}();var ua,la,ca=function(){return function(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;var r=bo(e.length),o=bo(n.length),a=this.sliceDim>1?"strides[j]":"strides";this.userCode="\n        "+r+" strides = "+r+"("+this.strides+");\n         void main() {\n          "+o+" coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < "+this.sliceDim+"; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * "+a+";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      "}}();function ha(t,e){return[e,t]}function pa(t,e){return t*e}function fa(t,e,n){var r=function(t,e){if(t%e!=0)throw new Error("unpackedSize ("+t+") must be a multiple of "+e);return t/e}(t.length,n);if(e.length<r)throw new Error("matrix length ("+e.length+") must be >= "+r);for(var o=0,a=0;a<t.length;a+=n)e[o++]=t[a]}function da(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function va(t,e){var n=da(t,e);return n[0]*n[1]*4}function ma(t,e,n,r,o){var a=n*r;if(o.length<a)throw new Error("matrix length ("+o.length+") must be >= "+a);for(var i=r%2==1,s=n%2==1,u=Math.floor(r/2),l=Math.floor(n/2),c=Math.ceil(r/2),h=c*Math.ceil(n/2),f=p(n)*p(r),d=0;d<e;d++){for(var v=d*n*r,m=d*f,g=i?4:0,y=r+(i?1:0),x=m,w=v,b=v+r,C=0;C<l;++C){for(var E=0;E<u;++E)o[w++]=t[x++],o[w++]=t[x++],o[b++]=t[x++],o[b++]=t[x++];x+=g,w+=y,b+=y}if(i){x=m+4*(c-1);var R=v+r-1;for(g=4*c,y=2*r,C=0;C<l;++C)o[R]=t[x],o[R+r]=t[x+2],x+=g,R+=y}if(s){for(x=m+4*(h-c),R=v+(n-1)*r,E=0;E<u;++E)o[R++]=t[x++],o[R++]=t[x++],x+=2;i&&(o[v+n*r-1]=t[x])}}return o}function ga(t,e){var n=uo();return Vt(t,e,n.version+"\n    precision highp float;\n    "+n.attribute+" vec3 clipSpacePos;\n    "+n.attribute+" vec2 uv;\n    "+n.varyingVs+" vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }")}function ya(t,e){return Yt(t,e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function xa(t,e){return Qt(t,e,new Uint16Array([0,1,2,2,1,3]))}function wa(t,e){var n,r,o,i,s,u,l,c,h=t;return 2===a.getNumber("WEBGL_VERSION")?(n=h.R32F,r=h.R16F,o=h.RGBA16F,i=h.RGBA32F,s=h.RED,u=4,l=1,c=h.HALF_FLOAT):(n=t.RGBA,r=t.RGBA,o=t.RGBA,i=h.RGBA,s=t.RGBA,u=4,l=4,c=null!=e?e.HALF_FLOAT_OES:null),{internalFormatFloat:n,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:s,downloadTextureFormat:t.RGBA,downloadUnpackNumChannels:u,defaultNumChannels:l,textureTypeHalfFloat:c}}function ba(t,e,n,r,o,a,i){te(n,r);var s=Zt(t,e),u=t.TEXTURE_2D;return Bt(t,e,function(){return t.bindTexture(u,s)}),Bt(t,e,function(){return t.texParameteri(u,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)}),Bt(t,e,function(){return t.texParameteri(u,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)}),Bt(t,e,function(){return t.texParameteri(u,t.TEXTURE_MIN_FILTER,t.NEAREST)}),Bt(t,e,function(){return t.texParameteri(u,t.TEXTURE_MAG_FILTER,t.NEAREST)}),Bt(t,e,function(){return t.texImage2D(u,0,o,n,r,0,a,i,null)}),Bt(t,e,function(){return t.bindTexture(t.TEXTURE_2D,null)}),s}function Ca(t,e,n,r,o){var a=ha(n,r);return ba(t,e,a[0],a[1],o.internalFormatFloat,o.textureFormatFloat,t.FLOAT)}function Ea(t,e,n,r,o){var a=ha(n,r);return ba(t,e,a[0],a[1],o.internalFormatHalfFloat,o.textureFormatFloat,o.textureTypeHalfFloat)}function Ra(t,e,n,r,o){var a=ha(n,r);return ba(t,e,a[0],a[1],t.RGBA,t.RGBA,t.UNSIGNED_BYTE)}function Sa(t,e,n,r,o){var a=da(n,r);return ba(t,e,a[0],a[1],o.internalFormatPackedFloat,t.RGBA,t.FLOAT)}function Na(t,e,n,r,o){var a=da(n,r);return ba(t,e,a[0],a[1],o.internalFormatPackedHalfFloat,t.RGBA,o.textureTypeHalfFloat)}function ka(t,e,n,r){return Bt(t,e,function(){return t.bindBuffer(t.ARRAY_BUFFER,r)}),ne(t,e,n,"clipSpacePos",r,3,20,0)&&ne(t,e,n,"uv",r,2,20,12)}function Ia(t,e,n,r){Bt(t,e,function(){return t.bindTexture(t.TEXTURE_2D,n)}),Bt(t,e,function(){return t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,r)}),Bt(t,e,function(){return t.bindTexture(t.TEXTURE_2D,null)})}function Aa(t,e,n,r,o,a,i){te(r,o),Bt(t,e,function(){return t.bindTexture(t.TEXTURE_2D,n)}),Bt(t,e,function(){return t.texSubImage2D(t.TEXTURE_2D,0,0,0,r,o,i,t.FLOAT,a)}),Bt(t,e,function(){return t.bindTexture(t.TEXTURE_2D,null)})}function Ta(t,e,n,r,o,a,i,s){var u,l=ha(r,o),c=l[0],h=l[1],p=r*o;1===s.defaultNumChannels&&p===a.length?u=a:function(t,e,n){var r=pa(t.length,n);if(e.length<r)throw new Error("unpackedArray length ("+e.length+") must be >= "+r);for(var o=0,a=0;a<t.length;++a)e[o]=t[a],o+=n}(a,u=new Float32Array(p*i),i),Aa(t,e,n,c,h,u,s.textureFormatFloat)}function Da(t,e,n,r,o,a,i,s,u,l){var c=da(i,s),h=c[0],f=c[1],d=new Float32Array(va(i,s));!function(t,e,n,r,o){for(var a=r%2==1,i=n%2==1,s=Math.floor(r/2),u=Math.floor(n/2),l=Math.ceil(r/2),c=l*Math.ceil(n/2),h=p(n)*p(r),f=0;f<e;f++){for(var d=f*n*r,v=f*h,m=a?4:0,g=r,y=v,x=0;x<u;++x){for(var w=2*x*r,b=0;b<s;++b){var C=d+w+2*b;o[y]=t[C],o[y+1]=t[C+1],o[y+2]=t[C+g],o[y+3]=t[C+g+1],y+=4}y+=m}if(a){C=d+r-1,y=v+4*(l-1);var E=2*r;for(m=4*l,x=0;x<u;++x)o[y]=t[C],o[y+2]=t[C+r],C+=E,y+=m}if(i){for(C=d+(n-1)*r,y=v+4*(c-l),b=0;b<s;++b)o[y++]=t[C++],o[y++]=t[C++],y+=2;a&&i&&(o[v+h-4]=t[C])}}}(u,r,o,a,d),Aa(t,e,n,h,f,d,t.RGBA)}function Oa(t,e,n,r,o){var a=t.createBuffer();Bt(t,e,function(){return t.bindBuffer(t.PIXEL_PACK_BUFFER,a)});var i=4*pa(n*r,o.downloadUnpackNumChannels);return Bt(t,e,function(){return t.bufferData(t.PIXEL_PACK_BUFFER,i,t.STREAM_READ)}),Bt(t,e,function(){return t.readPixels(0,0,r,n,t.RGBA,t.FLOAT,0)}),Bt(t,e,function(){return t.bindBuffer(t.PIXEL_PACK_BUFFER,null)}),a}function _a(t,e,n,r,o){var a=t,i=new Float32Array(pa(n*r,o.downloadUnpackNumChannels));a.bindBuffer(a.PIXEL_PACK_BUFFER,e),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,i),a.bindBuffer(a.PIXEL_PACK_BUFFER,null);var s=new Float32Array(n*r);return fa(i,s,o.downloadUnpackNumChannels),s}function Ma(t,e,n,r,o){var a=ha(n,r),i=a[0],s=a[1],u=new Float32Array(pa(n*r,o.downloadUnpackNumChannels));Bt(t,e,function(){return t.readPixels(0,0,i,s,o.downloadTextureFormat,t.FLOAT,u)});var l=new Float32Array(n*r);return fa(u,l,o.downloadUnpackNumChannels),l}function Fa(t,e,n,r,o){var a=ha(n,r),i=a[0],s=a[1],u=new Uint8Array(pa(n*r,4));return Bt(t,e,function(){return t.readPixels(0,0,i,s,o.downloadTextureFormat,t.UNSIGNED_BYTE,u)}),new Float32Array(u.buffer)}function Ba(t,e,n,r,o,a,i,s){var u=t,l=new Float32Array(va(a,i));u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null);var c=new Float32Array(y([n,r,o]));return ma(l,n,r,o,c),c}function Pa(t,e,n,r,o,a,i,s){var u=da(a,i),l=u[0],c=u[1],h=new Float32Array(va(a,i));Bt(t,e,function(){return t.readPixels(0,0,l,c,t.RGBA,t.FLOAT,h)});var p=new Float32Array(y([n,r,o]));return ma(h,n,r,o,p)}!function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(ua||(ua={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(la||(la={}));var La=Object.freeze({createVertexShader:ga,createVertexBuffer:ya,createIndexBuffer:xa,getTextureConfig:wa,createFloat32MatrixTexture:Ca,createFloat16MatrixTexture:Ea,createUnsignedBytesMatrixTexture:Ra,createPackedMatrixTexture:Sa,createFloat16PackedMatrixTexture:Na,bindVertexProgramAttributeStreams:ka,uploadPixelDataToTexture:Ia,uploadMatrixToTexture:Ta,uploadMatrixToPackedTexture:Da,createBufferFromOutputTexture:Oa,downloadFloat32MatrixFromBuffer:_a,downloadFloat32MatrixFromOutputTexture:Ma,downloadByteEncodedFloatMatrixFromOutputTexture:Fa,downloadPackedMatrixFromBuffer:Ba,downloadMatrixFromPackedOutputTexture:Pa}),Wa=function(){function t(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];var e=a.getNumber("WEBGL_VERSION");null!=t?(this.gl=t,function(t,e){_t[t]=e}(e,t)):this.gl=Ft(e),1===a.getNumber("WEBGL_VERSION")?(this.textureFloatExtension=zt(this.gl,this.debug,"OES_texture_float"),this.colorBufferFloatExtension=this.gl.getExtension("WEBGL_color_buffer_float"),a.getBool("WEBGL_RENDER_FLOAT32_ENABLED")||(this.textureHalfFloatExtension=zt(this.gl,this.debug,"OES_texture_half_float"),this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float"))):this.colorBufferFloatExtension=zt(this.gl,this.debug,"EXT_color_buffer_float"),this.vertexBuffer=ya(this.gl,this.debug),this.indexBuffer=xa(this.gl,this.debug),this.framebuffer=ee(this.gl,this.debug),this.textureConfig=wa(this.gl,this.textureHalfFloatExtension)}return Object.defineProperty(t.prototype,"debug",{get:function(){return a.getBool("DEBUG")},enumerable:!0,configurable:!0}),t.prototype.dispose=function(){var t=this;if(!this.disposed){null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");var e=this.gl;Bt(e,this.debug,function(){return e.finish()}),Bt(e,this.debug,function(){return e.bindFramebuffer(e.FRAMEBUFFER,null)}),Bt(e,this.debug,function(){return e.deleteFramebuffer(t.framebuffer)}),Bt(e,this.debug,function(){return e.bindBuffer(e.ARRAY_BUFFER,null)}),Bt(e,this.debug,function(){return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)}),Bt(e,this.debug,function(){return e.deleteBuffer(t.indexBuffer)}),this.disposed=!0}},t.prototype.createFloat32MatrixTexture=function(t,e){return this.throwIfDisposed(),Ca(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.createFloat16MatrixTexture=function(t,e){return this.throwIfDisposed(),Ea(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.createUnsignedBytesMatrixTexture=function(t,e){return this.throwIfDisposed(),Ra(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.uploadPixelDataToTexture=function(t,e){this.throwIfDisposed(),Ia(this.gl,this.debug,t,e)},t.prototype.createFloat16PackedMatrixTexture=function(t,e){return this.throwIfDisposed(),Na(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.createPackedMatrixTexture=function(t,e){return this.throwIfDisposed(),Sa(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.deleteMatrixTexture=function(t){var e=this;this.throwIfDisposed(),this.outputTexture===t&&(ue(this.gl,this.debug,this.framebuffer),this.outputTexture=null),Bt(this.gl,this.debug,function(){return e.gl.deleteTexture(t)})},t.prototype.uploadMatrixToTexture=function(t,e,n,r){this.throwIfDisposed();var o=Jt();return Ta(this.gl,this.debug,t,e,n,r,o,this.textureConfig)},t.prototype.uploadMatrixToPackedTexture=function(t,e,n,r,o,a,i){return this.throwIfDisposed(),Da(this.gl,this.debug,t,e,n,r,o,a,i,this.textureConfig)},t.prototype.downloadFloat32MatrixFromOutputTexture=function(t,e,n){var r=this;return this.downloadMatrixDriver(t,function(){return Ma(r.gl,r.debug,e,n,r.textureConfig)})},t.prototype.downloadByteEncodedFloatMatrixFromOutputTexture=function(t,e,n){var r=this;return this.downloadMatrixDriver(t,function(){return Fa(r.gl,r.debug,e,n,r.textureConfig)})},t.prototype.downloadPackedMatrixFromBuffer=function(t,e,n,r,o,a){return Ba(this.gl,t,e,n,r,o,a,this.textureConfig)},t.prototype.downloadFloat32MatrixFromBuffer=function(t,e,n){return _a(this.gl,t,e,n,this.textureConfig)},t.prototype.createBufferFromTexture=function(t,e,n){this.bindTextureToFrameBuffer(t);var r=Oa(this.gl,this.debug,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r},t.prototype.createAndWaitForFence=function(){var t=this.createFence(this.gl);return this.pollFence(t)},t.prototype.createFence=function(t){var e,n,r=this;if(a.getBool("WEBGL_FENCE_API_ENABLED")){var o=t,i=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=function(){var t=o.clientWaitSync(i,0,0);return t===o.ALREADY_SIGNALED||t===o.CONDITION_SATISFIED},e=i}else a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=function(){return r.isQueryAvailable(e,a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}):n=function(){return!0};return{query:e,isFencePassed:n}},t.prototype.downloadMatrixFromPackedTexture=function(t,e,n,r,o,a){var i=this;return this.downloadMatrixDriver(t,function(){return Pa(i.gl,i.debug,e,n,r,o,a,i.textureConfig)})},t.prototype.createProgram=function(t){this.throwIfDisposed();var e=this.gl,n=Gt(e,this.debug,t),r=ga(e,this.debug),o=jt(e,this.debug);return Bt(e,this.debug,function(){return e.attachShader(o,r)}),Bt(e,this.debug,function(){return e.attachShader(o,n)}),Kt(e,this.debug,o),this.debug&&Xt(e,this.debug,o),this.vertexAttrsAreBound||(this.setProgram(o),this.vertexAttrsAreBound=ka(e,this.debug,this.program,this.vertexBuffer)),o},t.prototype.deleteProgram=function(t){var e=this;this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&Bt(this.gl,this.debug,function(){return e.gl.deleteProgram(t)})},t.prototype.setProgram=function(t){var e=this;this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&Xt(this.gl,this.debug,this.program),Bt(this.gl,this.debug,function(){return e.gl.useProgram(t)})},t.prototype.getUniformLocation=function(t,e,n){return void 0===n&&(n=!0),this.throwIfDisposed(),n?oe(this.gl,this.debug,t,e):ae(this.gl,t,e)},t.prototype.getAttributeLocation=function(t,e){var n=this;return this.throwIfDisposed(),Bt(this.gl,this.debug,function(){return n.gl.getAttribLocation(t,e)})},t.prototype.getUniformLocationNoThrow=function(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)},t.prototype.setInputMatrixTexture=function(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),ie(this.gl,this.debug,this.program,t,e,n)},t.prototype.setOutputMatrixTexture=function(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)},t.prototype.setOutputPackedMatrixTexture=function(t,e,n){this.throwIfDisposed();var r=da(e,n),o=r[0],a=r[1];this.setOutputMatrixTextureDriver(t,o,a)},t.prototype.setOutputMatrixWriteRegion=function(t,e,n,r){this.setOutputMatrixWriteRegionDriver(n,t,r,e)},t.prototype.setOutputPackedMatrixWriteRegion=function(t,e,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")},t.prototype.debugValidate=function(){null!=this.program&&Xt(this.gl,this.debug,this.program),le(this.gl)},t.prototype.executeProgram=function(){this.throwIfDisposed(),this.throwIfNoProgram();var t=this.gl;this.debug&&this.debugValidate(),Bt(t,this.debug,function(){return t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)})},t.prototype.blockUntilAllProgramsCompleted=function(){var t=this;this.throwIfDisposed(),Bt(this.gl,this.debug,function(){return t.gl.finish()})},t.prototype.getQueryTimerExtension=function(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=zt(this.gl,this.debug,2===a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension},t.prototype.getQueryTimerExtensionWebGL2=function(){return this.getQueryTimerExtension()},t.prototype.getQueryTimerExtensionWebGL1=function(){return this.getQueryTimerExtension()},t.prototype.beginQuery=function(){if(2===a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}var r=this.getQueryTimerExtensionWebGL1(),o=r.createQueryEXT();return r.beginQueryEXT(r.TIME_ELAPSED_EXT,o),o},t.prototype.endQuery=function(){if(2!==a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}else{var e=this.gl,n=this.getQueryTimerExtensionWebGL2();e.endQuery(n.TIME_ELAPSED_EXT)}},t.prototype.waitForQueryAndGetTime=function(t){return r(this,void 0,void 0,function(){var e=this;return o(this,function(n){switch(n.label){case 0:return[4,R(function(){return e.disposed||e.isQueryAvailable(t,a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})];case 1:return n.sent(),[2,this.getQueryTime(t,a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))]}})})},t.prototype.getQueryTime=function(t,e){if(0===e)return null;if(2===e){var n=this.gl;return n.getQueryParameter(t,n.QUERY_RESULT)/1e6}var r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6},t.prototype.isQueryAvailable=function(t,e){if(0===e)return!0;if(2===e){var n=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=n.getQueryParameter(t,n.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}o=(r=this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint},t.prototype.pollFence=function(t){var e=this;return new Promise(function(n){e.addItemToPoll(function(){return t.isFencePassed()},function(){return n()})})},t.prototype.pollItems=function(){for(var t=function(t){for(var e=0;e<t.length;++e){var n=t[e]();if(!n)break}return e-1}(this.itemsToPoll.map(function(t){return t.isDoneFn})),e=0;e<=t;++e){(0,this.itemsToPoll[e].resolveFn)()}this.itemsToPoll=this.itemsToPoll.slice(t+1)},t.prototype.addItemToPoll=function(t,e){var n=this;this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||R(function(){return n.pollItems(),0===n.itemsToPoll.length})},t.prototype.bindTextureToFrameBuffer=function(t){this.throwIfDisposed(),se(this.gl,this.debug,t,this.framebuffer),this.debug&&le(this.gl)},t.prototype.unbindTextureToFrameBuffer=function(){null!=this.outputTexture?(se(this.gl,this.debug,this.outputTexture,this.framebuffer),this.debug&&le(this.gl)):ue(this.gl,this.debug,this.framebuffer)},t.prototype.downloadMatrixDriver=function(t,e){this.bindTextureToFrameBuffer(t);var n=e();return this.unbindTextureToFrameBuffer(),n},t.prototype.setOutputMatrixTextureDriver=function(t,e,n){this.throwIfDisposed();var r=this.gl;se(r,this.debug,t,this.framebuffer),this.debug&&le(r),this.outputTexture=t,Bt(r,this.debug,function(){return r.viewport(0,0,e,n)}),Bt(r,this.debug,function(){return r.scissor(0,0,e,n)})},t.prototype.setOutputMatrixWriteRegionDriver=function(t,e,n,r){var o=this;this.throwIfDisposed(),Bt(this.gl,this.debug,function(){return o.gl.scissor(t,e,n,r)})},t.prototype.throwIfDisposed=function(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")},t.prototype.throwIfNoProgram=function(){if(null==this.program)throw new Error("No GPU program is currently set.")},t}();function Ua(t,e){if(t.length!==e.length)throw Error("Binary was compiled with "+t.length+" inputs, but was executed with "+e.length+" inputs");t.forEach(function(t,n){var r=t.logicalShape,o=e[n],a=o.shape;if(!x(r,a))throw Error("Binary was compiled with different shapes than the current args. Shapes "+r+" and "+a+" must match");if(!t.isUniform||!o.isUniform){var i=t.texShape,s=o.isUniform?null:o.texData.texShape;if(!x(i,s))throw Error("Binary was compiled with different texture shapes than the current args. Shape "+i+" and "+s+" must match")}})}var za=function(){return function(t,e,n){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=t;var r=n.filterWidth,o=n.inChannels,a=n.strideWidth,i=n.strideHeight,s=n.padInfo,u=n.outWidth,l=n.dilationWidth,c=n.dilationHeight,h=s.left,p=s.top,f=o*r,d=uo();this.userCode="\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            int blockIndex = rc.y + col;\n            int pos = rc.x + row;\n\n            if(blockIndex >= "+t[1]+" || pos >= "+t[0]+") continue;\n\n            int offsetY = int(blockIndex / ("+u+")) * "+i+" - "+p+";\n            int d0 = offsetY + "+c+" * (pos / "+f+");\n\n            if(d0 >= "+e[0]+" || d0 < 0) continue;\n\n            int offsetX = int(mod(float(blockIndex), "+u+".) * "+a+". - "+h+".);\n            int d1 = offsetX + "+l+" * (int(mod(float(pos), "+f+".) / "+o+".));\n\n            if(d1 >= "+e[1]+" || d1 < 0) continue;\n\n            vec2 innerDims = vec2(d1, int(mod(float(pos), "+o+".)));\n            result[row * 2 + col] = getChannel(getA(d0, int(innerDims.x),\n                                              int(innerDims.y)), innerDims);\n          }\n        }\n\n        "+d.output+" = result;\n      }\n    "}}(),Va=function(){return function(t,e,n,r,o){this.variableNames=["x"],this.outputShape=[];var a,i=e,s=t[3]-1;this.outputShape=t;var u="float("+n+") + float("+r+") * sum";a=.5===o?"inversesqrt("+u+")":1===o?"1.0/("+u+")":"exp(log("+u+") * float(-"+o+"));",this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -"+i+"; j <= "+i+"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  "+s+") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * "+a+";\n        setOutput(val);\n      }\n    "}}(),Ga=function(){return function(t,e,n,r,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=r,this.beta=o,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < "+this.depth+"; ++d) {\n          int depthBegin = int(max(0.0, float(d - "+e+")));\n          int depthEnd = int(min(float("+this.depth+"),\n              float(d + "+e+" + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = "+this.depth+";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float("+r+") * norm + float("+n+");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float("+r+")\n                * float("+o+")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * "+o+");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    "}}(),qa=function(){return function(t,e,n,r,o){this.variableNames=["x"],this.outputShape=[],this.usesPackedTextures=!0;var a,i=e,s=t[3]-1;this.outputShape=t;var u="float("+n+") + float("+r+") * sum";a=.5===o?"inversesqrt("+u+")":1===o?"1.0/("+u+")":"exp(log("+u+") * float(-"+o+"));",this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < "+this.outputShape[3]+";\n        bool hasNextRow = c < "+this.outputShape[2]+";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - "+i+";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - "+i+"; j <= "+i+"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2("+s+"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * "+a+";\n        setOutput(result);\n      }\n    "}}(),Ha=function(){return function(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;var e=t.strideHeight,n=t.strideWidth,r=t.dilationHeight,o=t.effectiveFilterHeight,a=t.effectiveFilterWidth,i=o-1-t.padInfo.top,s=a-1-t.padInfo.left,u=o*a-1;this.userCode="\n      const ivec2 pads = ivec2("+i+", "+s+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+o+";\n          wR += "+r+") {\n          float dyR = float(dyRCorner + wR) / "+e+".0;\n\n          if (dyR < 0.0 || dyR >= "+t.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+a+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+n+".0;\n\n            if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = "+u+" - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * "+a+" + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),$a=function(){return function(t,e,n,r,o,a){void 0===n&&(n=!1),void 0===r&&(r=!1),void 0===o&&(o=!1),void 0===a&&(a=null),this.variableNames=["matrixA","matrixB"],this.usesPackedTextures=!0,this.outputShape=e;var i=n?t[1]:t[2],s=Math.ceil(i/2),u=n?"i * 2, rc.y":"rc.y, i * 2",l=r?"rc.z, i * 2":"i * 2, rc.z",c=n?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],p="",f="";a&&(p="vec4 activation(vec4 x) {\n        "+a+"\n      }",f="result = activation(result);");var d=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),this.userCode="\n      "+p+"\n\n      const float sharedDimension = "+s+".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < "+s+"; i++) {\n          vec4 a = getMatrixA(rc.x, "+u+");\n          vec4 b = getMatrixB(rc.x, "+l+");\n\n          result += ("+c[0]+" * "+h[0]+") + ("+c[1]+" * "+h[1]+");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        "+d+"\n\n        "+f+"\n\n        setOutput(result);\n      }\n    "}}(),ja=function(){function t(t,e,n){this.variableNames=["probs"],this.outputShape=[t,n],this.userCode="\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < "+(e-1)+"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float("+(e-1)+"));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t){var e=this;return function(n,r){null==e.seedLoc&&(e.seedLoc=n.getUniformLocation(r,"seed")),n.gl.uniform1f(e.seedLoc,t)}},t}(),Ka=function(){return function(t,e,n,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float("+r+"), float("+n+"),\n                      float(index == coords.y)));\n      }\n    "}}(),Xa=function(){return function(t){this.variableNames=["A"],this.isPackShader=!0,this.outputShape=t;var e=t.length;if(0===e)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{var n=oo("rc",e),r=bo(e),o=function(t,e,n){if(1===t)return"rc > "+e[0];for(var r="",o=t-2;o<t;o++)r+=n[o]+" >= "+e[o],o<t-1&&(r+="||");return r}(e,t,n),a=function(t,e,n,r){if(1===t)return"";var o=r.slice(-2);return"\n    int r = "+o[0]+";\n    int c = "+o[1]+";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= "+e+";\n    bool rEdge = rp1 >= "+n+";\n  "}(e,t[t.length-1],t[t.length-2],n),i=function(t,e){var n=t.length,r=function(t,e){for(var n=[],r=0;r<=1;r++)for(var o=0;o<=1;o++){for(var a=(0===r?"r":"rp1")+", "+(0===o?"c":"cp1"),i=2;i<t;i++)a=e[e.length-1-i]+","+a;n.push(a)}return n}(n,e);return 1===n?"getA(rc),\n            rc + 1 >= "+t[0]+" ? 0. : getA(rc + 1),\n            0, 0":"getA("+r[0]+"),\n          cEdge ? 0. : getA("+r[1]+"),\n          rEdge ? 0. : getA("+r[2]+"),\n          rEdge || cEdge ? 0. : getA("+r[3]+")"}(t,n);this.userCode="\n        void main() {\n          "+r+" rc = getOutputCoords();\n\n          if("+o+") {\n            setOutput(vec4(0));\n          } else {\n            "+a+"\n\n            setOutput(vec4("+i+"));\n          }\n        }\n      "}}}();var Ya=function(){return function(t,e,n){this.variableNames=["x"],this.outputShape=e.map(function(e,n){return e[0]+t[n]+e[1]});var r=t.length,o=bo(r),a=e.map(function(t){return t[0]}).join(","),i=e.map(function(e,n){return e[0]+t[n]}).join(","),s=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?"\n      "+o+" start = "+o+"("+a+");\n      "+o+" end = "+o+"("+i+");\n\n      void main() {\n        "+o+" outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float("+n+"));\n        } else {\n          "+o+" coords = outC - start;\n          setOutput(getX("+s+"));\n        }\n      }\n    ":"\n        int start = "+a+";\n        int end = "+i+";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float("+n+"));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      "}}(),Qa=function(){return function(t,e,n){this.variableNames=["x"],this.usesPackedTextures=!0,this.outputShape=e.map(function(e,n){return e[0]+t[n]+e[1]});for(var r=t.length,o=bo(r),a=e.map(function(t){return t[0]}).join(","),i=e.map(function(e,n){return e[0]+t[n]}).join(","),s=oo("rc",r),u=oo("source",r),l=s[r-1]+" < "+this.outputShape[r-1],c=1===r?"source":"vec2("+u.slice(-2).join()+")",h=[o+" rc = outputLoc;",s[r-1]+" += 1;\n       if("+l+") {\n      ",1===r?"":"}\n       rc = outputLoc;\n       "+s[r-2]+" += 1;\n       if("+s[r-2]+" < "+this.outputShape[r-2]+") {",1===r?"":"  "+s[r-1]+" += 1;\n         if("+l+") {"],p=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",f="",d=0,v=1===r?2:4;d<v;d++)f+="\n        "+h[d]+"\n        if ("+p+") {\n          result["+d+"] = float("+n+");\n        } else {\n          "+o+" source = rc - start;\n          result["+d+"] = getChannel(getX("+u.join()+"), "+c+");\n        }\n      ";f+=1===r?"} ":"}}",this.userCode="\n      const "+o+" start = "+o+"("+a+");\n      const "+o+" end = "+o+"("+i+");\n\n      void main() {\n        "+o+" outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        "+f+"\n        setOutput(result);\n      }\n    "}}(),Ja=function(){return function(t,e,n){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");var r=t.filterWidth,o=t.strideHeight,a=t.strideWidth,i=t.dilationHeight,s=t.dilationWidth,u=t.effectiveFilterHeight,l=t.effectiveFilterWidth,c=t.padInfo.top,h=t.padInfo.left;this.outputShape=t.outShape;var p="avg"===e,f="0.0";if(p||(f="-1.0 / 1e-20"),n)this.userCode="\n        const ivec2 strides = ivec2("+o+", "+a+");\n        const ivec2 pads = ivec2("+c+", "+h+");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < "+u+";\n              wR += "+i+") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+l+";\n                wC += "+s+") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= "+t.inWidth+") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * "+l+" + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";else{var d=e+"("+e+"("+e+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===e&&(d="avgValue / count");var v=4*Math.floor(r/4),m=r%4,g="\n      if ("+p+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";this.userCode="\n      const ivec2 strides = ivec2("+o+", "+a+");\n      const ivec2 pads = ivec2("+c+", "+h+");\n      const float initializationValue = "+f+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= "+t.inWidth+") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+f+");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < "+u+";\n            wR += "+i+") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= "+t.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+v+"; wC += 4) {\n            int xC = xCCorner + wC * "+s+";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+s+", d),\n              getValue(batch, xR, xC + 2 * "+s+", d),\n              getValue(batch, xR, xC + 3 * "+s+", d)\n            );\n\n            "+g+"\n          }\n\n          int xC = xCCorner + "+v+";\n          if ("+(1===m)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            "+g+"\n          } else if ("+(2===m)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+s+", d),\n              initializationValue,\n              initializationValue\n            );\n\n            "+g+"\n          } else if ("+(3===m)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+s+", d),\n              getValue(batch, xR, xC + 2 * "+s+", d),\n              initializationValue\n            );\n\n            "+g+"\n          }\n        }\n        setOutput("+d+");\n      }\n    "}}}(),Za=function(){return function(t,e){this.variableNames=["x"];var n=t.windowSize,r=t.batchSize,o=t.inSize,a=Math.ceil(o/n);this.outputShape=[r,a];var i="0.0",s="";"prod"===e?i="1.0":"min"===e?(i="1.0 / 1e-20",s="min"):"max"===e&&(i="-1.0 / 1e-20",s="max");var u=e+"("+e+"("+e+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===e?u="sumValue":"prod"===e?u="prodValue":"all"===e?u="allValue":"any"===e&&(u="anyValue");var l=4*Math.floor(n/4),c=n%4,h="\n      if ("+("sum"===e)+") {\n        sumValue += dot(values, ones);\n      } else if ("+("prod"===e)+") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = "+s+"(values, minMaxValue);\n      }\n    ",p="vec4";"all"===e?(i="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===e&&(i="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");var f="";o%n>0&&(f="\n        if (inIdx < 0 || inIdx >= "+o+") {\n          return initializationValue;\n        }\n      "),this.userCode="\n      const float initializationValue = "+i+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        "+f+"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+n+";\n\n        vec4 minMaxValue = vec4("+i+");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < "+l+"; i += 4) {\n          int inIdx = inOffset + i;\n          "+p+" values = "+p+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          "+h+"\n        }\n\n        int inIdx = inOffset + "+l+";\n        if ("+(1===c)+") {\n          "+p+" values = "+p+"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          "+h+"\n        } else if ("+(2===c)+") {\n          "+p+" values = "+p+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          "+h+"\n        } else if ("+(3===c)+") {\n          "+p+" values = "+p+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          "+h+"\n        }\n        setOutput("+u+");\n      }\n    "}}(),ti=function(){return function(t,e){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=t;for(var n="",r=0;r<4;r++){var o="thisRC = rc;";r%2==1&&(o+="thisRC.z += 1;"),r>1&&(o+="thisRC.y += 1;"),n+="\n        "+o+"\n        "+(r>0?"if(thisRC.y < rows && thisRC.z < cols){":"")+"\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result["+r+"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        "+(r>0?"}":"")+"\n      "}this.userCode="\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      "+lo(["r","c","d"],e)+"\n      return ivec3(r, c, d);\n    }\n  \n      "+function(t){return"\n    int getFlatIndex(ivec3 coords) {\n      return round("+function(t,e){if(t.length!==e.length)throw new Error("Vectors to be dotted must be of the same length -got "+t.length+" and "+e.length);for(var n=[],r=Math.floor(t.length/4),o=t.length%4,a=0;a<r;a++){var i=t.slice(4*a,4*a+4),s=e.slice(4*a,4*a+4);n.push(co(i)+", "+co(s))}return 0!==o&&(i=t.slice(4*r),s=e.slice(4*r),1===i.length&&(i=i.map(function(t){return"float("+t+")"}),s=s.map(function(t){return"float("+t+")"})),n.push(co(i)+", "+co(s))),n.map(function(t,e){return"dot("+t+")"}).join("+")}(["coords.x","coords.y","coords.z"],V(t).map(function(t){return t.toString()}).concat(["1."]))+");\n    }\n  "}(t)+"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = "+t[1]+";\n        int cols = "+t[2]+";\n\n        "+n+"\n\n        setOutput(result);\n      }\n    "}}();var ei=function(){return function(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;var r=e.shape,o=r[1],a=r[2],i=t.shape,s=i[1],u=i[2],l=[n&&s>1?o-1:o,n&&u>1?a-1:a],c=[n&&s>1?s-1:s,n&&u>1?u-1:u],h=l[0]/c[0],p=l[1]/c[1],f=1/h,d=1/p,v=2*Math.ceil(f)+2,m=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+h+");\n        const float widthScale = float("+p+");\n\n        const float invHeightScale = float("+f+");\n        const float invWidthScale = float("+d+");\n\n        const int winHeight = int("+v+");\n        const int winWidth = int("+m+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+s+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+u+") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), "+(o-1)+".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), "+(a-1)+".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "}}(),ni=function(){return function(t,e,n,r){this.variableNames=["A"],this.outputShape=[];var o=t[0],a=t[1],i=t[2],s=t[3];this.outputShape=[o,e,n,s];var u=[r&&e>1?a-1:a,r&&n>1?i-1:i],l=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+u[0]/l[0]+",\n          "+u[1]/l[1]+");\n      const vec2 inputShapeRC = vec2("+a+".0, "+i+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    "}}(),ri=function(){return function(t,e,n,r){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=[];var o=t[0],a=t[1],i=t[2],s=t[3];this.outputShape=[o,e,n,s];var u=[r&&e>1?a-1:a,r&&n>1?i-1:i],l=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          "+u[0]/l[0]+",\n          "+u[1]/l[1]+",\n          "+u[1]/l[1]+");\n      const vec3 inputShapeRC = vec3("+a+".0, "+i+".0,\n                                     "+i+".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n        \n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < "+(s-1)+"; \n        bool hasNextRow = coords.z < "+(n-1)+";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    "}}(),oi=function(){return function(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;var r=e.shape,o=r[1],a=r[2],i=t.shape,s=i[1],u=i[2],l=[n&&s>1?o-1:o,n&&u>1?a-1:a],c=[n&&s>1?s-1:s,n&&u>1?u-1:u],h=l[0]/c[0],p=l[1]/c[1],f=1/h,d=1/p,v=2*Math.ceil(f)+2,m=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+h+");\n        const float widthScale = float("+p+");\n\n        const float invHeightScale = float("+f+");\n        const float invWidthScale = float("+d+");\n\n        const int winHeight = int("+v+");\n        const int winWidth = int("+m+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+s+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+u+") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float("+l[0]+") *\n                (float(dyR) / float("+c[0]+"));\n\n            float sourceFracCol =\n                float("+l[1]+") *\n                  (float(dyC) / float("+c[1]+"));\n\n            int sourceNearestRow = int(min(\n                float(int("+o+") - 1),\n                "+n+" ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int("+a+") - 1),\n                "+n+" ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "}}(),ai=function(){return function(t,e,n,r){this.variableNames=["A"],this.outputShape=[];var o=t[0],a=t[1],i=t[2],s=t[3];this.outputShape=[o,e,n,s];var u=[r&&e>1?a-1:a,r&&n>1?i-1:i],l=[r&&e>1?e-1:e,r&&n>1?n-1:n],c=r?"0.5":"0.0";this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+u[0]/l[0]+",\n          "+u[1]/l[1]+");\n      const vec2 inputShapeRC = vec2("+a+".0, "+i+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + "+c+")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    "}}(),ii=function(){return function(t,e){this.variableNames=["x"];var n=t.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-"+n+" tensor is not yet supported");if(this.outputShape=t,1!==n){var r=t.map(function(n,r){return function(n){return-1!==e.indexOf(n)&&1!==t[n]?t[n]+" - coords["+n+"] - 1":"coords["+n+"]"}(r)}).join(","),o=bo(n);this.userCode="\n      void main() {\n        "+o+" coords = getOutputCoords();\n        setOutput(getX("+r+"));\n      }\n    "}else this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX("+t[0]+" - coord - 1));\n        }\n      "}}(),si=function(){return function(t,e){this.variableNames=["x"],this.usesPackedTextures=!0;var n=t.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-"+n+" tensor is not yet supported");this.outputShape=t;var r=oo("rc",n),o=r[n-1]+" + 1 < "+this.outputShape[n-1],a=r[n-2]+" + 1 < "+this.outputShape[n-2],i=bo(n);function s(n){var r=t.map(function(r,o){return function(n,r){return-1!==e.indexOf(n)&&1!==t[n]?t[n]+" - "+r[n]+" - 1":""+r[n]}(o,n)});return"getChannel(getX("+r.join(",")+"), vec2("+r.slice(-2).join(",")+"))"}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX("+t[0]+" - rc - 1),\n            "+t[0]+" - rc - 1);\n          if("+o+"){\n              result.g = getChannel(getX("+t[0]+" - (rc  + 1) - 1),\n                "+t[0]+" - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      ":"\n        void main() {\n          "+i+" rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = "+function(t){return s(t)}(r.slice())+";\n          if("+o+"){\n            result.g = "+function(t){return t[n-1]="("+t[n-1]+" + 1)",s(t)}(r.slice())+";\n          }\n          if("+a+") {\n            result.b = "+function(t){return t[n-2]="("+t[n-2]+" + 1)",s(t)}(r.slice())+";\n            if("+o+") {\n              result.a = "+function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",s(t)}(r.slice())+";\n            }\n          }\n          setOutput(result);\n        }\n    "}}(),ui=function(){return function(t,e,n,r,o,a,i){void 0===i&&(i=!0),this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;var s=bo(o.length),u=bo(a.length),l="";1===n?l="i":2===n&&(l="i, j");var c="getIndices("+l+")",h="";1===r?h="i":2===r&&(h="i, coords[1]");var p="getUpdates("+h+")",f=e>1?"strides[j]":"strides";this.userCode="\n        "+s+" strides = "+s+"("+o+");\n\n        void main() {\n          "+u+" coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < "+t+"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < "+e+"; j++) {\n              int index = round("+c+");\n              flattenedIndex += index * "+f+";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += "+p+";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      "}}(),li=function(){return function(t,e){this.variableNames=["x","segmentIds"];var n=t.windowSize,r=t.batchSize,o=t.inSize,a=t.numSegments,i=a*Math.ceil(o/n);this.outputShape=[r,i];var s=4*Math.floor(n/4),u=n%4,l="\n        sumValue += dot(values, segFilter);\n    ",c="";o%n>0&&(c="\n        if (inIdx < 0 || inIdx >= "+o+") {\n          return initializationValue;\n        }\n      ");var h="";o%n>0&&(h="\n        if (inIdx < 0 || inIdx >= "+o+") {\n          return -1.0;\n        }\n      "),this.userCode="\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        "+c+"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        "+h+"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          "+a+")) * float("+n+"));\n        int currentSeg = int(mod(float(outIdx), float("+a+")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < "+s+"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          "+l+"\n        }\n\n        int inIdx = inOffset + "+s+";\n        if ("+(1===u)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          "+l+"\n        } else if ("+(2===u)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          "+l+"\n        } else if ("+(3===u)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          "+l+"\n        }\n        setOutput(sumValue);\n      }\n    "}}(),ci=function(){return function(t,e,n){var r,o;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error("Where for rank "+n+" is not yet supported");if(1===n)o="resRC",r="resRC";else{for(var a=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],s=[],u=0;u<e.length;u++)s.push(""+a[u]),u<t&&i.push(""+a[u]);r=i.join(),o=s.join()}var l=bo(n);this.userCode="\n      void main() {\n        "+l+" resRC = getOutputCoords();\n        float cVal = getC("+r+");\n        if (cVal >= 1.0) {\n          setOutput(getA("+o+"));\n        } else {\n          setOutput(getB("+o+"));\n        }\n      }\n    "}}(),hi=function(){function t(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;var e,n=bo(this.rank),r="uniform int start["+this.rank+"];",o=function(t){if(1===t)return"sourceLoc";if(t<=6)return pi.slice(0,t).map(function(t){return"sourceLoc."+t}).join(",");throw Error("Slicing for rank "+t+" is not yet supported")}(this.rank);e="\n        "+n+" sourceLoc;\n        "+n+" coords = getOutputCoords();\n        "+t.map(function(t,e){return"sourceLoc."+pi[e]+" = start["+e+"] + coords."+pi[e]+";"}).join("\n")+"\n      ",this.userCode="\n      "+r+"\n      void main() {\n        "+e+"\n        setOutput(getSource("+o+"));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t){var e=this;if(t.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+t.length+")");return function(n,r){null==e.startLoc&&(e.startLoc=n.getUniformLocationNoThrow(r,"start"),null==e.startLoc)||n.gl.uniform1iv(e.startLoc,t)}},t}(),pi=["x","y","z","w","u","v"];var fi=function(){function t(t){this.variableNames=["source"],this.usesPackedTextures=!0,this.outputShape=t,this.rank=t.length;var e=bo(this.rank),n=oo("coords",this.rank),r=oo("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":"vec2("+r.slice(-2).join()+")",a="getChannel(getSource("+r.join()+"), "+o+")",i="\n      result.x = "+a+";\n      if (++"+n[this.rank-1]+" < "+t[this.rank-1]+") {\n        ++"+r[this.rank-1]+";\n        result.y = "+a+";\n        --"+r[this.rank-1]+";\n      }\n    ",s=1===this.rank?"":"\n      --"+n[this.rank-1]+";\n      if (++"+n[this.rank-2]+" < "+t[this.rank-2]+") {\n        ++"+r[this.rank-2]+";\n        result.z = "+a+";\n        if (++"+n[this.rank-1]+" < "+t[this.rank-1]+") {\n          ++"+r[this.rank-1]+";\n          result.w = "+a+";\n        }\n      }\n    ",u=this.rank<=4?"sourceLoc = coords +\n            "+e+"("+t.map(function(t,e){return"start["+e+"]"}).join()+");":t.map(function(t,e){return r[e]+" = "+n[e]+" + start["+e+"];"}).join("\n");this.userCode="\n      uniform int start["+this.rank+"];\n      void main() {\n        "+e+" coords = getOutputCoords();\n        "+e+" sourceLoc;\n        "+u+" \n        vec4 result = vec4(0.);\n        "+i+"\n        "+s+"\n        setOutput(result);\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t){var e=this;if(t.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+t.length+")");return function(n,r){null==e.startLoc&&(e.startLoc=n.getUniformLocationNoThrow(r,"start"),null==e.startLoc)||n.gl.uniform1iv(e.startLoc,t)}},t}(),di=function(){return function(t,e,n,r){this.variableNames=["x"];var o=n.filter(function(t,e){return-1===r.indexOf(e)});this.outputShape=o;var a=n.length,i=bo(n.length),s=bo(o.length),u="";if(1===a)u="coords * strides + begin";else{var l=0;u=n.map(function(t,e){return-1===r.indexOf(e)?(l++,1===o.length?"coords * strides["+e+"] + begin["+e+"]":"coords["+(l-1)+"] * strides["+e+"] + begin["+e+"]"):"begin["+e+"]"}).join(",")}this.userCode="\n      "+i+" begin = "+i+"("+t+");\n      "+i+" strides = "+i+"("+e+");\n\n      void main() {\n        "+s+" coords = getOutputCoords();\n        setOutput(getX("+u+"));\n      }\n    "}}(),vi=function(){function t(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}return t.prototype.acquireTexture=function(t,e,n){var r,o=mi(e,n),a=gi(t,o,n);if(a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]),this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this.log();var i=this.freeTextures[a].shift();return this.usedTextures[a].push(i),i}return this.numUsedTextures++,this.log(),o===la.PACKED_2X2_FLOAT32?r=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):o===la.PACKED_2X2_FLOAT16?r=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):o===la.UNPACKED_FLOAT32?r=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):o===la.UNPACKED_FLOAT16?r=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):o===la.PACKED_4X1_UNSIGNED_BYTE&&(r=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[a].push(r),r},t.prototype.releaseTexture=function(t,e,n,r){if(null!=this.freeTextures){var o=gi(e,mi(n,r),r);o in this.freeTextures||(this.freeTextures[o]=[]),this.freeTextures[o].push(t),this.numFreeTextures++,this.numUsedTextures--;var a=this.usedTextures[o],i=a.indexOf(t);if(i<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(i,1),this.log()}},t.prototype.log=function(){if(this.logEnabled){var t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",this.numFreeTextures+" / "+this.numUsedTextures,"("+t+")")}},t.prototype.getNumUsedTextures=function(){return this.numUsedTextures},t.prototype.getNumFreeTextures=function(){return this.numFreeTextures},t.prototype.dispose=function(){var t=this;if(null!=this.freeTextures){for(var e in this.freeTextures)this.freeTextures[e].forEach(function(e){t.gpgpu.deleteMatrixTexture(e)});for(var e in this.usedTextures)this.usedTextures[e].forEach(function(e){t.gpgpu.deleteMatrixTexture(e)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0}},t}();function mi(t,e){if(t===ua.UPLOAD)return e?la.PACKED_2X2_FLOAT32:la.UNPACKED_FLOAT32;if(t===ua.RENDER||null==t)return e?a.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?la.PACKED_2X2_FLOAT32:la.PACKED_2X2_FLOAT16:a.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?la.UNPACKED_FLOAT32:la.UNPACKED_FLOAT16;if(t===ua.DOWNLOAD||t===ua.PIXELS)return la.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+t)}function gi(t,e,n){return t[0]+"_"+t[1]+"_"+e+"_"+n}var yi=function(){return function(t,e){this.variableNames=["A"];for(var n=new Array(t.length),r=0;r<n.length;r++)n[r]=t[r]*e[r];this.outputShape=n,this.rank=n.length;var o=bo(this.rank),a=function(t){var e=t.length;if(e>5)throw Error("Tile for rank "+e+" is not yet supported");if(1===e)return"imod(resRC, "+t[0]+")";for(var n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[],o=0;o<t.length;o++)r.push("imod("+n[o]+", "+t[o]+")");return r.join()}(t);this.userCode="\n      void main() {\n        "+o+" resRC = getOutputCoords();\n        setOutput(getA("+a+"));\n      }\n    "}}();var xi=function(){return function(t,e){this.variableNames=["A"];for(var n=new Array(t.length),r=0;r<n.length;r++)n[r]=t[e[r]];this.outputShape=n,this.rank=n.length;var o=bo(this.rank),a=function(t){var e=t.length;if(e>6)throw Error("Transpose for rank "+e+" is not yet supported");for(var n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e),o=0;o<t.length;o++)r[t[o]]=n[o];return r.join()}(e);this.userCode="\n    void main() {\n      "+o+" resRC = getOutputCoords();\n      setOutput(getA("+a+"));\n    }\n    "}}();var wi=function(){return function(t,e){this.variableNames=["A"],this.usesPackedTextures=!0;for(var n=new Array(t.length),r=0;r<n.length;r++)n[r]=t[e[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank "+this.rank+" is not yet supported.");var o=bo(this.rank),a=ro("rc",this.rank),i=new Array(this.rank);for(r=0;r<e.length;r++)i[e[r]]=a[r];var s="vec2("+i.slice(-2).join()+")",u="++"+a[this.rank-1]+" < "+n[this.rank-1],l="getChannel(getA("+i.join()+"), "+s+")";this.userCode="\n    void main() {\n      "+o+" rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = "+l+";\n      if("+u+") {\n        result[1] = "+l+";\n      }\n      --"+a[this.rank-1]+";\n      if(++"+a[this.rank-2]+" < "+n[this.rank-2]+") {\n        result[2] = "+l+";\n        if("+u+") {\n          result[3] = "+l+";\n        }\n      }  \n      setOutput(result);\n    }\n    "}}(),bi=1.7580993408473768,Ci=1.0507009873554805,Ei=function(){return function(t,e){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      float unaryOperation(float x) {\n        "+e+"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "}}(),Ri="if (isnan(x)) return x;",Si="return x;",Ni=Ri+"\n  return (x < 0.0) ? 0.0 : x;\n",ki="\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = "+bi+";\n  float scale = "+Ci+";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";var Ii="return exp(x);",Ai=Ri+"\n  return sin(x);\n",Ti=Ri+"\n  return cos(x);\n",Di=Ri+"\n  return atan(x);\n",Oi=Ri+"\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));",_i=Ri+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;",Mi="return x;",Fi="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Bi=function(){return function(t,e){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=t,this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        "+e+"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "}}(),Pi=function(){return function(t){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=t;var e=t.length,n=oo("rc",e),r=bo(e),o=function(t,e){if(1===t)return"rc";for(var n="",r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}(e,n),a=n.slice(-2),i=e<=1?"rc":"vec2("+a.join(",")+")";this.userCode="\n      void main() {\n        "+r+" rc = getOutputCoords();\n        vec4 packedInput = getA("+o+");\n\n        setOutput(getChannel(packedInput, "+i+"));\n      }\n    "}}(),Li={};var Wi=600;var Ui=function(){function t(t){if(this.gpgpu=t,this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.warnedAboutMemory=!1,this.disposed=!1,!a.getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==t){var e=Ft(a.getNumber("WEBGL_VERSION"));this.binaryCache=(n=a.getNumber("WEBGL_VERSION"))in Li?Li[n]:(Li[n]={},Li[n]),this.gpgpu=new Wa(e),this.canvas=e.canvas,this.gpgpuCreatedLocally=!0}else this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=t.gl.canvas;var n;this.textureManager=new vi(this.gpgpu),this.numMBBeforeWarning=null==a.global.screen?1024:a.global.screen.height*a.global.screen.width*window.devicePixelRatio*Wi/1024/1024,this.texData=new Yn(Dt)}return t.prototype.register=function(t,e,n){if(this.texData.has(t))throw new Error("Data buffer is already registered");this.texData.set(t,{shape:e,dtype:n})},t.prototype.fromPixels=function(t,e){if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");var n=[t.height,t.width],r=[t.height,t.width,e];if(a.getBool("IS_BROWSER")){if(!(t instanceof HTMLVideoElement||t instanceof HTMLImageElement||t instanceof HTMLCanvasElement||t instanceof ImageData))throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or ImageData, but was "+t.constructor.name);if(t instanceof HTMLVideoElement){if(null==this.fromPixels2DContext){if("complete"!==document.readyState)throw new Error("The DOM is not ready yet. Please call tf.browser.fromPixels() once the DOM is ready. One way to do that is to add an event listener for `DOMContentLoaded` on the document object");this.fromPixels2DContext=document.createElement("canvas").getContext("2d")}this.fromPixels2DContext.canvas.width=t.width,this.fromPixels2DContext.canvas.height=t.height,this.fromPixels2DContext.drawImage(t,0,0,t.width,t.height),t=this.fromPixels2DContext.canvas}}var o=this.makeTensorHandle(n,"int32");this.texData.get(o.dataId).usage=ua.PIXELS,this.gpgpu.uploadPixelDataToTexture(this.getTexture(o.dataId),t);var i=new ia(r),s=this.compileAndRun(i,[o]);return this.disposeData(o.dataId),s},t.prototype.makeTensorHandle=function(t,e){var n={};return this.register(n,t,e),{dataId:n,shape:t,dtype:e}},t.prototype.write=function(t,e){if(null==e)throw new Error("MathBackendWebGL.write(): values can not be null");if(a.getBool("DEBUG"))for(var n=0;n<e.length;n++){var r=e[n];if(!Wt(r))throw Error("The value "+r+" cannot be represented on this device.")}var o=this.texData.get(t);if("complex64"===o.dtype)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.releaseGPUData(t),o.usage=ua.UPLOAD,o.values=e},t.prototype.readSync=function(t){var e=this.texData.get(t),n=e.values,r=e.dtype,o=e.complexTensors,a=e.slice,i=e.shape;if(null!=a){var s=new Ei(i,"return x;"),u=this.compileAndRun(s,[{dataId:t,shape:i,dtype:r}]),l=this.readSync(u.dataId);return u.dispose(),l}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===r)return n;var c,h,p=null!=this.activeTimers;(p&&(c=performance.now()),"complex64"===r)?h=er(o.real.dataSync(),o.imag.dataSync()):h=this.getValuesFromTexture(t);return p&&(this.downloadWaitMs+=performance.now()-c),this.convertAndCacheOnCPU(t,h)},t.prototype.read=function(t){return r(this,void 0,void 0,function(){var e,n,r,i,s,u,l,c,h,p,f,d,v,m,g,x,w,b,C,E,R,S,N,k,I,A,T,D;return o(this,function(o){switch(o.label){case 0:if(this.pendingRead.has(t))return r=this.pendingRead.get(t),[2,new Promise(function(t){return r.push(t)})];if(i=this.texData.get(t),s=i.texture,u=i.values,l=i.texShape,c=i.isPacked,h=i.shape,p=i.slice,f=i.dtype,d=i.complexTensors,null!=p)return v=new Ei(h,"return x;"),m=this.compileAndRun(v,[{dataId:t,shape:h,dtype:f}]),g=this.read(m.dataId),m.dispose(),[2,g];if(null!=u)return[2,this.convertAndCacheOnCPU(t)];if(this.pendingRead.set(t,[]),!a.getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===a.getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");return x=null,"complex64"===f?[3,2]:(w=l[1],b=l[0],c&&(e=da(l[0],l[1]),w=e[0],b=e[1]),a.get("WEBGL_BUFFER_SUPPORTED")&&(x=this.gpgpu.createBufferFromTexture(s,b,w)),[4,this.gpgpu.createAndWaitForFence()]);case 1:o.sent(),o.label=2;case 2:return"complex64"!==f?[3,4]:[4,Promise.all([d.real.data(),d.imag.data()])];case 3:return E=o.sent(),R=E[0],S=E[1],C=er(R,S),[3,5];case 4:null==x?C=this.getValuesFromTexture(t):(N=y(h),c?(k=fe(h),I=1,A=1,h.length&&(n=de(h),I=n[0],A=n[1]),C=this.gpgpu.downloadPackedMatrixFromBuffer(x,k,I,A,l[0],l[1]).subarray(0,N)):C=this.gpgpu.downloadFloat32MatrixFromBuffer(x,l[0],l[1]).subarray(0,N)),o.label=5;case 5:return T=this.convertAndCacheOnCPU(t,C),D=this.pendingRead.get(t),this.pendingRead.delete(t),D.forEach(function(t){return t(T)}),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)),[2,T]}})})},t.prototype.getValuesFromTexture=function(t){var e,n=this,r=this.texData.get(t),o=r.shape,i=r.dtype,s=r.texture,u=r.texShape,l=y(o);if(a.getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){if(this.texData.get(t).isPacked){var c=fe(o),h=1,p=1;return o.length&&(h=(e=de(o))[0],p=e[1]),this.gpgpu.downloadMatrixFromPackedTexture(s,c,h,p,u[0],u[1]).subarray(0,l)}return this.gpgpu.downloadFloat32MatrixFromOutputTexture(s,u[0],u[1]).subarray(0,l)}var f=this.makeTensorHandle(o,"float32");f.size=y(o),this.texData.get(f.dataId).usage=ua.DOWNLOAD;var d=Fe(function(){var e=new ea(o);return n.compileAndRun(e,[{shape:o,dtype:i,dataId:t}],f,null)}),v=this.texData.get(d.dataId),m=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(v.texture,v.texShape[0],v.texShape[1]).subarray(0,l);return this.disposeData(f.dataId),m},t.prototype.time=function(t){return r(this,void 0,void 0,function(){var e,n,r,a,i,s,u;return o(this,function(o){switch(o.label){case 0:return e=this.activeTimers,n=[],r=!1,null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,t(),a=g(this.activeTimers.map(function(t){return t.query})).filter(function(t){return null!=t}),i=g(this.activeTimers.map(function(t){return t.name})).filter(function(t){return null!=t}),this.activeTimers=e,r&&(this.programTimersStack=null),[4,Promise.all(a)];case 1:return s=o.sent(),u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:f(s),getExtraProfileInfo:function(){return s.map(function(t,e){return{name:i[e],ms:t}}).map(function(t){return t.name+": "+t.ms}).join(", ")},wallMs:null},this.uploadWaitMs=0,this.downloadWaitMs=0,[2,u]}})})},t.prototype.memory=function(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU}},t.prototype.startTimer=function(){return a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?this.gpgpu.beginQuery():{startMs:performance.now(),endMs:null}},t.prototype.endTimer=function(t){return a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(this.gpgpu.endQuery(),t):(t.endMs=performance.now(),t)},t.prototype.getQueryTime=function(t){return r(this,void 0,void 0,function(){var e;return o(this,function(n){return a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?[2,this.gpgpu.waitForQueryAndGetTime(t)]:[2,(e=t).endMs-e.startMs]})})},t.prototype.disposeData=function(t){if(!this.pendingDisposal.has(t))if(this.pendingRead.has(t))this.pendingDisposal.add(t);else if(this.texData.has(t)){this.releaseGPUData(t);var e=this.texData.get(t).complexTensors;null!=e&&(e.real.dispose(),e.imag.dispose()),this.texData.delete(t)}},t.prototype.releaseGPUData=function(t){var e=this.texData.get(t),n=e.texture,r=e.dtype,o=e.texShape,a=e.usage,i=e.isPacked,s=e.slice,u=s&&s.origDataId||t,l=this.dataRefCount.get(u);l>1?this.dataRefCount.set(u,l-1):(this.dataRefCount.delete(u),null!=n&&(this.numBytesInGPU-=this.computeBytes(o,r),this.textureManager.releaseTexture(n,o,a,i)));var c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null},t.prototype.getTexture=function(t){return this.uploadToGPU(t),this.texData.get(t).texture},t.prototype.getCPUBackend=function(){return a.getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=Dt.findBackend("cpu")),this.cpuBackend):null},t.prototype.shouldExecuteOnCPU=function(t,e){var n=this;return void 0===e&&(e=128),null!=this.getCPUBackend()&&t.every(function(t){return null==n.texData.get(t.dataId).texture&&t.size<e})},t.prototype.getGPGPUContext=function(){return this.gpgpu},t.prototype.getCanvas=function(){return this.canvas},t.prototype.complex=function(t,e){var n=this.makeOutputArray(t.shape,"complex64");return this.texData.get(n.dataId).complexTensors={real:Dt.keep(t.clone()),imag:Dt.keep(e.clone())},n},t.prototype.real=function(t){return this.texData.get(t.dataId).complexTensors.real.clone()},t.prototype.imag=function(t){return this.texData.get(t.dataId).complexTensors.imag.clone()},t.prototype.slice=function(t,e,n){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.slice(t,e,n);var r=this.texData.get(t.dataId).isPacked,o=mn(t.shape,e,n);if(r||!o){var i=a.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fi(n):new hi(n),s=i.getCustomSetupFunc(e);return this.compileAndRun(i,[t],null,s)}return this.uploadToGPU(t.dataId),this.shallowSlice(t,e,n)},t.prototype.shallowSlice=function(t,e,n){var r=this.texData.get(t.dataId),o=ft.make(n,{},t.dtype,this),a=this.texData.get(o.dataId);Object.assign(a,r),a.shape=n,a.dtype=t.dtype;var i=gn(e,t.strides);r.slice&&(i+=r.slice.flatOffset),a.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||t.dataId};var s=this.dataRefCount.get(a.slice.origDataId)||1;return this.dataRefCount.set(a.slice.origDataId,s+1),o},t.prototype.stridedSlice=function(t,e,n,r,o,a,i,s,u){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.stridedSlice(t,e,n,r,o,a,i,s,u);var l=fn(t.shape,e,n,r,o,a,i,s,u),c=l[0],h=l[1],p=l[2],f=h.filter(function(t,e){return-1===p.indexOf(e)});if(f.some(function(t){return 0===t}))return Fn([],f);var d=new di(c,r,h,p);return this.compileAndRun(d,[t])},t.prototype.reverse=function(t,e){var n=a.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new si(t.shape,e):new ii(t.shape,e);return this.compileAndRun(n,[t])},t.prototype.concat=function(t,e){if(this.shouldExecuteOnCPU(t))return this.cpuBackend.concat(t,e);if(1===t.length)return t[0];if(t.length>a.getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){var n=Math.floor(t.length/2),r=this.concat(t.slice(0,n),e),o=this.concat(t.slice(n),e);return this.concat([r,o],e)}if(a.getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].rank>1){var i=new Uo(t.map(function(t){return t.shape}),e);return this.compileAndRun(i,t)}var s=sn(t.map(function(t){return t.shape}),e),u=t.map(function(t){return t.as2D(-1,y(t.shape.slice(e)))}),l=new Wo(u.map(function(t){return t.shape}));return this.compileAndRun(l,u).reshape(s)},t.prototype.neg=function(t){var e=new Ei(t.shape,"return -x;");return this.compileAndRun(e,[t])},t.prototype.batchMatMul=function(t,e,n,r){var o=n?t.shape[2]:t.shape[1],a=r?e.shape[1]:e.shape[2],i=n?t.shape[1]:t.shape[2],s=t.shape[0];if((1===o||1===a)&&i>1e3){n&&(t=t.transpose([0,2,1])),r&&(e=e.transpose([0,2,1]));var u=1===a?t:t.as3D(s,i,1),l=1===a?2:1,c=1===a?e.as3D(s,1,i):e;return this.multiply(u,c).sum(l,!0)}var h=Ct(t.dtype,e.dtype),p=new $a(t.shape,[s,o,a],n,r),f=this.makePackedTensor(p.outputShape,h);return this.compileAndRun(p,[t,e],f)},t.prototype.fusedBatchMatMul=function(t,e,n,r,o,a){var i=n?t.shape[2]:t.shape[1],s=r?e.shape[1]:e.shape[2],u=t.shape[0],l=Ct(t.dtype,e.dtype),c=new $a(t.shape,[u,i,s],n,r,!!o,a?function(t,e){if(void 0===e&&(e=!1),"linear"===t)return e?Mi:Si;if("relu"===t)return e?Fi:Ni;throw new Error("Activation "+t+" has not been implemented for the WebGL backend.")}(a,!0):null),h=this.makePackedTensor(c.outputShape,l),p=[t,e];return o&&p.push(o),this.compileAndRun(c,p,h)},t.prototype.multiply=function(t,e){if("complex64"===t.dtype){var n=this.texData.get(t.dataId),r=this.texData.get(e.dataId),o=new To(Io,t.shape,e.shape),i=new To(Ao,t.shape,e.shape),s=[this.makeComplexComponentTensorHandle(t,n.complexTensors.real),this.makeComplexComponentTensorHandle(t,n.complexTensors.imag),this.makeComplexComponentTensorHandle(e,r.complexTensors.real),this.makeComplexComponentTensorHandle(e,r.complexTensors.imag)],u=this.compileAndRun(o,s),l=this.compileAndRun(i,s),c=this.complex(u,l);return u.dispose(),l.dispose(),c}if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.multiply(t,e);if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,_o,t.dtype);var h=new Mo(_o,t.shape,e.shape),p=this.makeOutputArray(h.outputShape,t.dtype);return this.compileAndRun(h,[t,e],p)},t.prototype.batchNormalization=function(t,e,n,r,o,i){var s=[t,e,n],u=null;null!=i&&(u=i.shape,s.push(i));var l=null;if(null!=o&&(l=o.shape,s.push(o)),a.getBool("WEBGL_PACK_NORMALIZATION")){var c=new ko(t.shape,e.shape,n.shape,u,l,r);return this.compileAndRun(c,s)}var h=new No(t.shape,e.shape,n.shape,u,l,r);return this.compileAndRun(h,s)},t.prototype.localResponseNormalization4D=function(t,e,n,r,o){var i=a.getBool("WEBGL_PACK_NORMALIZATION")?new qa(t.shape,e,n,r,o):new Va(t.shape,e,n,r,o);return this.compileAndRun(i,[t])},t.prototype.LRNGrad=function(t,e,n,r,o,a,i){var s=new Ga(e.shape,r,o,a,i);return this.compileAndRun(s,[e,n,t])},t.prototype.tile=function(t,e){var n=new yi(t.shape,e);return this.compileAndRun(n,[t])},t.prototype.pad=function(t,e,n){var r=a.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Qa(t.shape,e,n):new Ya(t.shape,e,n);return this.compileAndRun(r,[t])},t.prototype.transpose=function(t,e){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.transpose(t,e);var n=a.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new wi(t.shape,e):new xi(t.shape,e);return this.compileAndRun(n,[t])},t.prototype.gather=function(t,e,n){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.gather(t,e,n);var r=new sa(t.shape,e.size,n);return this.compileAndRun(r,[t,e])},t.prototype.batchToSpaceND=function(t,e,n){d(t.rank<=4,function(){return"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"});var r=e.reduce(function(t,e){return t*e}),o=Ke(t.shape,e,r),a=Xe(o.length,e.length),i=Ye(t.shape,e,r),s=Qe(n,e.length),u=Je(i,n,e.length);return t.reshape(o).transpose(a).reshape(i).slice(s,u)},t.prototype.spaceToBatchND=function(t,e,n){d(t.rank<=4,function(){return"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"});var r=e.reduce(function(t,e){return t*e}),o=[[0,0]];o.push.apply(o,n);for(var a=1+e.length;a<t.shape.length;++a)o.push([0,0]);var i=t.pad(o),s=Ke(i.shape,e,r,!1),u=Xe(s.length,e.length,!1),l=Ye(i.shape,e,r,!1);return i.reshape(s).transpose(u).reshape(l)},t.prototype.reduce=function(t,e,n){var r=t.shape[0],o=t.shape[1],a=cn(o),i=new Za({windowSize:a,inSize:o,batchSize:r},e),s=i.outputShape,u=s[0],l=s[1],c=this.makeOutputArray([u,l],n);return this.compileAndRun(i,[t],c),1===c.shape[1]?c:this.reduce(c,e,n)},t.prototype.argReduce=function(t,e,n){void 0===n&&(n=null);var r=t.shape[0],o=t.shape[1];null!=n&&(r=n.shape[0],o=n.shape[1]);var a=cn(o),i=new no({windowSize:a,inSize:o,batchSize:r},e,null==n),s=i.outputShape,u=s[0],l=s[1],c=this.makeOutputArray([u,l],"int32"),h=[t];return null!=n&&h.push(n),this.compileAndRun(i,h,c),1===c.shape[1]?c:this.argReduce(t,e,c)},t.prototype.argReducePacked=function(t,e,n){void 0===n&&(n=null);var r=null!=n?n.shape:t.shape,o=cn(r[r.length-1]),a=new Ro(r,o,e,null==n),i=this.makePackedTensor(a.outputShape,"int32"),s=null==n?[t]:[t,n];return this.compileAndRun(a,s,i),i.rank===t.rank?this.argReducePacked(t,e,i):i},t.prototype.sum=function(t,e){nn("sum",e,t.rank);var n=tn(t.shape,e),r=n[0],o=y(n[1]),a=t.as2D(-1,o),i=Et(t.dtype);return this.reduce(a,"sum",i).reshape(r)},t.prototype.prod=function(t,e){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.prod(t,e);var n=tn(t.shape,e),r=n[0],o=y(n[1]),a=t.as2D(-1,o),i=Et(t.dtype);return this.reduce(a,"prod",i).reshape(r)},t.prototype.unsortedSegmentSum=function(t,e,n){var r=0,o=rn([r],t.rank),a=t;null!=o&&(a=t.transpose(o),r=an(1,t.rank)[0]);var i=function(t,e,n){for(var r=[],o=t.length,a=0;a<o;a++)a!==e?r.push(t[a]):r.push(n);return r}(a.shape,r,n),s=y([a.shape[r]]),u=a.as2D(-1,s),l=Et(t.dtype),c=this.segOpCompute(u,"unsortedSegmentSum",e,l,n).reshape(i);return null!=o&&(c=c.transpose(on(o))),c},t.prototype.segOpCompute=function(t,e,n,r,o){var a=t.shape[0],i=t.shape[1],s=function(t,e){var n,r=!1;for(t<=ln?(n=t,r=!0):n=z(t,Math.floor(Math.sqrt(t)));!r;)n>e||n===t?r=!0:n=z(t,n+1);return n}(i,o),u=new li({windowSize:s,inSize:i,batchSize:a,numSegments:o},e),l=u.outputShape,c=l[0],h=l[1],p=this.makeOutputArray([c,h],r);return this.compileAndRun(u,[t,n],p),p.shape[1]===o?p:(n=jn(0,o).tile([i/s]),this.segOpCompute(p,e,n,r,o))},t.prototype.argMinMaxReduce=function(t,e,n){var r=[e];if(nn("arg"+n.charAt(0).toUpperCase()+n.slice(1),r,t.rank),!a.getBool("WEBGL_PACK_REDUCE")||t.rank<=2){var o=tn(t.shape,r),i=o[0],s=y(o[1]),u=t.as2D(-1,s);return this.argReduce(u,n).reshape(i)}return this.argReducePacked(t,n)},t.prototype.argMin=function(t,e){return this.argMinMaxReduce(t,e,"min")},t.prototype.argMax=function(t,e){return this.argMinMaxReduce(t,e,"max")},t.prototype.cumsum=function(t,e,n,r){if(e!==t.rank-1)throw new Error("WebGL cumsum shader expects an inner-most axis="+(t.rank-1)+" but got axis="+e);var o=new Jo(t.shape,n,r);return this.compileAndRun(o,[t])},t.prototype.equal=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(equal(a, b));\n","bool");var n=new Mo("return float(a == b);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.notEqual=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(notEqual(a, b));\n","bool");var n=new Mo("return float(a != b);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.less=function(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.less(t,e);if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(lessThan(a, b));\n","bool");var n=new Mo("return float(a < b);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.lessEqual=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(lessThanEqual(a, b));\n","bool");var n=new Mo("return float(a <= b);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.greater=function(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.greater(t,e);if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(greaterThan(a, b));\n","bool");var n=new Mo("return float(a > b);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.greaterEqual=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(greaterThanEqual(a, b));\n","bool");var n=new Mo("return float(a >= b);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.logicalNot=function(t){var e=new Ei(t.shape,"return float(!(x >= 1.0));");return this.compileAndRun(e,[t])},t.prototype.logicalAnd=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n","bool");var n=new Mo("return float(a >= 1.0 && b >= 1.0);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.logicalOr=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n","bool");var n=new Mo("return float(a >= 1.0 || b >= 1.0);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.select=function(t,e,n){var r=new ci(t.rank,e.shape,e.rank),o=this.makeOutputArray(r.outputShape,Ct(e.dtype,n.dtype));return this.compileAndRun(r,[t,e,n],o)},t.prototype.where=function(t){je("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");var e=t.dataSync();return Zr(t.shape,e)},t.prototype.topk=function(t,e,n){return ur(t.dataSync(),t.shape,t.dtype,e)},t.prototype.min=function(t,e){nn("min",e,t.rank);var n=tn(t.shape,e),r=n[0],o=y(n[1]),a=t.as2D(-1,o);return this.reduce(a,"min",a.dtype).reshape(r)},t.prototype.minimum=function(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.minimum(t,e);var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Mo("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])},t.prototype.mod=function(t,e){var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Mo("if (b == 0.0) return NAN;\n  return mod(a, b);",t.shape,e.shape);return this.compileAndRun(n,[t,e])},t.prototype.max=function(t,e){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.max(t,e);nn("max",e,t.rank);var n=tn(t.shape,e),r=n[0],o=y(n[1]),a=t.as2D(-1,o);return this.reduce(a,"max",a.dtype).reshape(r)},t.prototype.maximum=function(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.maximum(t,e);var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Mo("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])},t.prototype.all=function(t,e){nn("all",e,t.rank);var n=tn(t.shape,e),r=n[0],o=y(n[1]),a=t.as2D(-1,o);return this.reduce(a,"all",a.dtype).reshape(r)},t.prototype.any=function(t,e){nn("any",e,t.rank);var n=tn(t.shape,e),r=n[0],o=y(n[1]),a=t.as2D(-1,o);return this.reduce(a,"any",a.dtype).reshape(r)},t.prototype.squaredDifference=function(t,e){var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo("return (a - b) * (a - b);",t.shape,e.shape):new Mo("return (a - b) * (a - b);",t.shape,e.shape);return this.compileAndRun(n,[t,e])},t.prototype.realDivide=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS")){return this.packedBinaryOp(t,e,"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(b.x == 0.0) {\n    result.x = NAN;\n  } else if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(b.y == 0.0) {\n    result.y = NAN;\n  } else if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(b.z == 0.0) {\n    result.z = NAN;\n  } else if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(b.w == 0.0) {\n    result.w = NAN;\n  } else if(a.w == b.w) {\n    result.w = 1.;\n  }\n  \n  return result;\n","float32",!0)}var n=new Mo("\nif (b == 0.0) {\n  return NAN;\n} \nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"float32");return this.compileAndRun(n,[t,e],r)},t.prototype.floorDiv=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n","int32");var n=new Mo("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"int32");return this.compileAndRun(n,[t,e],r)},t.prototype.add=function(t,e){if("complex64"===t.dtype&&"complex64"===e.dtype)return this.complexSeparableBinaryOp(t,e,Do);if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.add(t,e);var n=Ct(t.dtype,e.dtype);if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,Do,n);var r=new Mo(Do,t.shape,e.shape),o=this.makeOutputArray(r.outputShape,n);return this.compileAndRun(r,[t,e],o)},t.prototype.packedBinaryOp=function(t,e,n,r,o){void 0===o&&(o=!1);var a=new Fo(n,t.shape,e.shape,o),i=this.makePackedTensor(a.outputShape,r);return this.compileAndRun(a,[t,e],i)},t.prototype.complexSeparableBinaryOp=function(t,e,n){var r=this,o=this.texData.get(t.dataId),a=this.texData.get(e.dataId),i=[[o.complexTensors.real,a.complexTensors.real],[o.complexTensors.imag,a.complexTensors.imag]].map(function(o){var a=o[0],i=o[1],s=r.makeComplexComponentTensorHandle(t,a),u=r.makeComplexComponentTensorHandle(e,i),l=new Mo(n,t.shape,e.shape),c=r.makeOutputArray(l.outputShape,Ct(a.dtype,i.dtype));return r.compileAndRun(l,[s,u],c)}),s=i[0],u=i[1],l=this.complex(s,u);return s.dispose(),u.dispose(),l},t.prototype.makeComplexComponentTensorHandle=function(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}},t.prototype.addN=function(t){if(1===t.length)return t[0];if(t.length>a.get("WEBGL_MAX_TEXTURES_IN_SHADER")){var e=Math.floor(t.length/2),n=this.addN(t.slice(0,e)),r=this.addN(t.slice(e));return this.addN([n,r])}var o=t.map(function(t){return t.dtype}).reduce(function(t,e){return Ct(t,e)}),i=t.map(function(t){return t.shape}),s=a.getBool("WEBGL_PACK"),u=s?new eo(t[0].shape,i):new to(t[0].shape,i),l=s?this.makePackedTensor(u.outputShape,o):this.makeOutputArray(u.outputShape,o);return this.compileAndRun(u,t,l)},t.prototype.subtract=function(t,e){if("complex64"===t.dtype&&"complex64"===e.dtype)return this.complexSeparableBinaryOp(t,e,Oo);if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.subtract(t,e);var n=Ct(t.dtype,e.dtype);if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,Oo,t.dtype);var r=new Mo(Oo,t.shape,e.shape),o=this.makeOutputArray(r.outputShape,n);return this.compileAndRun(r,[t,e],o)},t.prototype.pow=function(t,e){var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS"),r=n?new Fo("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Mo("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",t.shape,e.shape),o=Ct(t.dtype,e.dtype),i=n?this.makePackedTensor(r.outputShape,o):this.makeOutputArray(r.outputShape,o);return this.compileAndRun(r,[t,e],i)},t.prototype.ceil=function(t){var e=new Ei(t.shape,"return ceil(x);");return this.compileAndRun(e,[t])},t.prototype.floor=function(t){var e=new Ei(t.shape,"return floor(x);");return this.compileAndRun(e,[t])},t.prototype.sign=function(t){var e=new Ei(t.shape,"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");return this.compileAndRun(e,[t])},t.prototype.isNaN=function(t){var e=new Ei(t.shape,"return float(isnan(x));"),n=this.makeOutputArray(e.outputShape,"bool");return this.compileAndRun(e,[t],n)},t.prototype.isInf=function(t){var e=new Ei(t.shape,"return float(isinf(x));"),n=this.makeOutputArray(e.outputShape,"bool");return this.compileAndRun(e,[t],n)},t.prototype.isFinite=function(t){var e=new Ei(t.shape,"return float(!isnan(x) && !isinf(x));"),n=this.makeOutputArray(e.outputShape,"bool");return this.compileAndRun(e,[t],n)},t.prototype.round=function(t){var e=new Ei(t.shape,"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");return this.compileAndRun(e,[t])},t.prototype.exp=function(t){var e;return e=a.getBool("WEBGL_PACK")?new Bi(t.shape,Ii):new Ei(t.shape,Ii),this.compileAndRun(e,[t])},t.prototype.expm1=function(t){var e=new Ei(t.shape,"return exp(x) - 1.0;");return this.compileAndRun(e,[t])},t.prototype.log=function(t){var e;return e=a.getBool("WEBGL_PACK")?new Bi(t.shape,"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n"):new Ei(t.shape,"if (x < 0.0) return NAN;\n  return log(x);"),this.compileAndRun(e,[t])},t.prototype.log1p=function(t){var e=new Ei(t.shape,"return log(1.0 + x);");return this.compileAndRun(e,[t])},t.prototype.sqrt=function(t){var e=new Ei(t.shape,"return sqrt(x);");return this.compileAndRun(e,[t])},t.prototype.rsqrt=function(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.rsqrt(t);var e=new Ei(t.shape,"return inversesqrt(x);");return this.compileAndRun(e,[t])},t.prototype.square=function(t){var e=new Ei(t.shape,"return x * x;");return this.compileAndRun(e,[t])},t.prototype.reciprocal=function(t){var e=new Ei(t.shape,"return 1.0 / x;");return this.compileAndRun(e,[t])},t.prototype.relu=function(t){var e;return e=a.getBool("WEBGL_PACK")?new Bi(t.shape,Fi):new Ei(t.shape,Ni),this.compileAndRun(e,[t])},t.prototype.prelu=function(t,e){var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo("\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",t.shape,e.shape):new Mo("return (a < 0.) ? b * a : a;",t.shape,e.shape);return this.compileAndRun(n,[t,e])},t.prototype.elu=function(t){var e=new Ei(t.shape,"return (x >= 0.0) ? x : (exp(x) - 1.0);");return this.compileAndRun(e,[t])},t.prototype.eluDer=function(t,e){var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",t.shape,e.shape):new Mo("return (b >= 1.0) ? a : a * (b + 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e])},t.prototype.selu=function(t){var e=new Ei(t.shape,ki);return this.compileAndRun(e,[t])},t.prototype.int=function(t){var e=new Ei(t.shape,"return float(int(x));"),n=this.makeOutputArray(e.outputShape,"int32");return this.compileAndRun(e,[t],n)},t.prototype.clip=function(t,e,n){var r,o=(r=a.getBool("WEBGL_PACK_CLIP")?new Po(t.shape):new Bo(t.shape)).getCustomSetupFunc(e,n);return this.compileAndRun(r,[t],null,o)},t.prototype.abs=function(t){var e=new Ei(t.shape,"return abs(x);");return this.compileAndRun(e,[t])},t.prototype.complexAbs=function(t){var e=this.texData.get(t.dataId),n=new Lo(t.shape),r=[this.makeComplexComponentTensorHandle(t,e.complexTensors.real),this.makeComplexComponentTensorHandle(t,e.complexTensors.imag)];return this.compileAndRun(n,r)},t.prototype.sigmoid=function(t){var e=new Ei(t.shape,"return 1.0 / (1.0 + exp(-1.0 * x));");return this.compileAndRun(e,[t])},t.prototype.softplus=function(t){var e=new Ei(t.shape,"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");return this.compileAndRun(e,[t])},t.prototype.sin=function(t){var e=new Ei(t.shape,Ai);return this.compileAndRun(e,[t])},t.prototype.cos=function(t){var e=new Ei(t.shape,Ti);return this.compileAndRun(e,[t])},t.prototype.tan=function(t){var e=new Ei(t.shape,"return tan(x);");return this.compileAndRun(e,[t])},t.prototype.asin=function(t){var e=new Ei(t.shape,"return asin(x);");return this.compileAndRun(e,[t])},t.prototype.acos=function(t){var e=new Ei(t.shape,"return acos(x);");return this.compileAndRun(e,[t])},t.prototype.atan=function(t){var e=new Ei(t.shape,Di);return this.compileAndRun(e,[t])},t.prototype.atan2=function(t,e){var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Mo("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])},t.prototype.sinh=function(t){var e=new Ei(t.shape,"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])},t.prototype.cosh=function(t){var e=new Ei(t.shape,"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])},t.prototype.tanh=function(t){var e=new Ei(t.shape,"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");return this.compileAndRun(e,[t])},t.prototype.asinh=function(t){var e=new Ei(t.shape,"return log(x + sqrt(x * x + 1.0));");return this.compileAndRun(e,[t])},t.prototype.acosh=function(t){var e=new Ei(t.shape,Oi);return this.compileAndRun(e,[t])},t.prototype.atanh=function(t){var e=new Ei(t.shape,_i);return this.compileAndRun(e,[t])},t.prototype.erf=function(t){var e=new Ei(t.shape,'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float t = 1.0 / (1.0 + p * x);\n  return 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x);\n');return this.compileAndRun(e,[t])},t.prototype.step=function(t,e){var n=new Ei(t.shape,function(t){return void 0===t&&(t=0),Ri+"\n    return x > 0.0 ? 1.0 : float("+t+");\n  "}(e));return this.compileAndRun(n,[t])},t.prototype.conv2dByMatMul=function(t,e,n){var r=t.shape,o=this.texData.get(t.dataId),i=n.inChannels,s=r[0]*r[1]*r[2],u=n.outChannels,l=(1===s||1===u)&&i>1e3,c=r[2]%2!=0&&!!o.isPacked;if(l||!a.getBool("WEBGL_LAZILY_UNPACK")||!a.getBool("WEBGL_PACK_BINARY_OPERATIONS")||!c){var h=this.reshape(t,[1,r[0]*r[1]*r[2],n.inChannels]),p=this.reshape(e,[1,n.inChannels,n.outChannels]);return this.reshape(this.batchMatMul(h,p,!1,!1),n.outShape)}var f=ft.make([1,r[0]*r[1]*(r[2]+1),n.inChannels],{dataId:t.dataId},t.dtype,this),v=o.shape;o.shape=o.shape.slice(),o.shape[o.shape.length-2]++,d(ge(o.shape,f.shape),function(){return"packed reshape "+o.shape+" to "+f.shape+" isn't free"});var m=this.reshape(e,[1,n.inChannels,n.outChannels]),g=this.batchMatMul(f,m,!1,!1),y=this.texData.get(g.dataId);return d(y.isPacked,function(){return"batchMatMul result is expected to be packed"}),o.shape=v,y.shape=n.outShape,ft.make(n.outShape,{dataId:g.dataId},g.dtype,this)},t.prototype.conv2dWithIm2Row=function(t,e,n){var r=n.filterWidth,o=n.filterHeight,a=n.inChannels,i=n.outWidth,s=n.outHeight,u=r*o*a,l=s*i,c=[u,l],h=t.squeeze([0]),p=e.reshape([1,u,-1]),f=new za(c,h.shape,n),d=this.compileAndRun(f,[h]).reshape([1,c[0],c[1]]),v=new $a(d.shape,[1,l,n.outChannels],!0,!1);return this.compileAndRun(v,[d,p]).reshape([1,s,i,n.outChannels])},t.prototype.conv2d=function(t,e,n){if(1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type))return this.conv2dByMatMul(t,e,n);if(a.getBool("WEBGL_CONV_IM2COL")&&1===t.shape[0])return this.conv2dWithIm2Row(t,e,n);var r=new jo(n);return this.compileAndRun(r,[t,e])},t.prototype.conv2dDerInput=function(t,e,n){var r=new Vo(n);return this.compileAndRun(r,[t,e])},t.prototype.conv2dDerFilter=function(t,e,n){var r=new zo(n);return this.compileAndRun(r,[t,e])},t.prototype.depthwiseConv2D=function(t,e,n){var r;return a.getBool("WEBGL_PACK_DEPTHWISECONV")&&n.strideWidth<=2&&n.outChannels/n.inChannels==1?(r=new Yo(n),this.compileAndRun(r,[t,e],this.makePackedTensor(n.outShape,t.dtype))):(r=new Xo(n),this.compileAndRun(r,[t,e]))},t.prototype.depthwiseConv2DDerInput=function(t,e,n){var r=new $o(n);return this.compileAndRun(r,[t,e])},t.prototype.depthwiseConv2DDerFilter=function(t,e,n){var r=new Ho(n);return this.compileAndRun(r,[t,e])},t.prototype.conv3d=function(t,e,n){var r=new Ko(n);return this.compileAndRun(r,[t,e])},t.prototype.conv3dDerInput=function(t,e,n){var r=new qo(n);return this.compileAndRun(r,[t,e])},t.prototype.conv3dDerFilter=function(t,e,n){var r=new Go(n);return this.compileAndRun(r,[t,e])},t.prototype.maxPool=function(t,e){var n=new Ja(e,"max",!1),r=this.makeOutputArray(n.outputShape,t.dtype);return this.compileAndRun(n,[t],r)},t.prototype.avgPool=function(t,e){var n=new Ja(e,"avg",!1),r=this.makeOutputArray(n.outputShape,"float32");return this.compileAndRun(n,[t],r)},t.prototype.maxPoolBackprop=function(t,e,n,r){var o=new Ja(r,"max",!0),a=this.compileAndRun(o,[e]),i=new Ha(r),s=this.makeOutputArray(i.outputShape,e.dtype),u=this.compileAndRun(i,[t,a],s);return a.dispose(),u},t.prototype.avgPoolBackprop=function(t,e,n){var r=new So(n),o=this.makeOutputArray(r.outputShape,e.dtype);return this.compileAndRun(r,[t],o)},t.prototype.cast=function(t,e){return Jn(t,e,this)},t.prototype.unstack=function(t,e){for(var n=t.shape[e],r=new Array(t.rank-1),o=0,a=0;a<t.rank;a++)a!==e&&(r[o++]=t.shape[a]);var i=new Array(t.rank).fill(0),s=t.shape.slice();s[e]=1;var u=new Array(n);for(a=0;a<u.length;a++)i[e]=a,u[a]=this.slice(t,i,s).reshape(r);return u},t.prototype.reshape=function(t,e){var n=this.texData.get(t.dataId);return!n.isPacked||ge(t.shape,e)||null!==n.texture&&ge(n.shape,e)?Zn(t,e):this.packedReshape(t,e)},t.prototype.resizeBilinear=function(t,e,n,r){var o=a.getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ri(t.shape,e,n,r):new ni(t.shape,e,n,r);return this.compileAndRun(o,[t])},t.prototype.resizeBilinearBackprop=function(t,e,n){var r=new ei(t,e,n);return this.compileAndRun(r,[t])},t.prototype.resizeNearestNeighbor=function(t,e,n,r){var o=new ai(t.shape,e,n,r);return this.compileAndRun(o,[t])},t.prototype.resizeNearestNeighborBackprop=function(t,e,n){var r=new oi(t,e,n);return this.compileAndRun(r,[t])},t.prototype.multinomial=function(t,e,n,r){var o=e?t:Tn(t),a=o.shape[0],i=o.shape[1],s=new ja(a,i,n),u=this.makeOutputArray(s.outputShape,"int32"),l=s.getCustomSetupFunc(r);return this.compileAndRun(s,[o],u,l)},t.prototype.oneHot=function(t,e,n,r){var o=new Ka(t.size,e,n,r);return this.compileAndRun(o,[t])},t.prototype.nonMaxSuppression=function(t,e,n,r,o){return je("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"),ar(t.dataSync(),e.dataSync(),n,r,o)},t.prototype.cropAndResize=function(t,e,n,r,o,a){var i=new Qo(t.shape,e.shape,r,o,a);return this.compileAndRun(i,[t,e,n])},t.prototype.depthToSpace=function(t,e,n){d(e>1,function(){return"blockSize should be > 1 for depthToSpace, but was: "+e});var r=t.shape[0],o="NHWC"===n?t.shape[1]:t.shape[2],a="NHWC"===n?t.shape[2]:t.shape[3],i="NHWC"===n?t.shape[3]:t.shape[1],s=o*e,u=a*e,l=i/(e*e),c=new ta("NHWC"===n?[r,s,u,l]:[r,l,s,u],e,n);return this.compileAndRun(c,[t])},t.prototype.split=function(t,e,n){return sr(t,e,n)},t.prototype.scatterND=function(t,e,n){var r=pn(0,t,n),o=r.sliceRank,a=r.numUpdates,i=r.sliceSize,s=r.strides,u=r.outputSize,l=[u/i,i],c=t.reshape([a,o]),h=e.reshape([a,i]);if(0===u)return Zn(Fn([]),n);var p=Bn(0),f=new ui(a,o,c.rank,h.rank,s,l);return this.compileAndRun(f,[h,c,p]).reshape(n)},t.prototype.sparseToDense=function(t,e,n,r){var o=pn(0,t,n),a=o.sliceRank,i=o.numUpdates,s=o.strides,u=o.outputSize,l=new ui(i,a,t.rank,e.rank,s,[u,1],!1);return this.compileAndRun(l,[e,t,r]).reshape(n)},t.prototype.fft=function(t){return this.fftImpl(t,!1)},t.prototype.ifft=function(t){return this.fftImpl(t,!0)},t.prototype.fftImpl=function(t,e){var n=this.texData.get(t.dataId),r=new oa(na,t.shape,e),o=new oa(ra,t.shape,e),a=[this.makeComplexComponentTensorHandle(t,n.complexTensors.real),this.makeComplexComponentTensorHandle(t,n.complexTensors.imag)],i=this.compileAndRun(r,a),s=this.compileAndRun(o,a),u=this.complex(i,s).as2D(t.shape[0],t.shape[1]);return i.dispose(),s.dispose(),u},t.prototype.gatherND=function(t,e){var n=e.shape,r=n[n.length-1],o=un(t,e),a=o[0],i=o[1],s=o[2],u=o[3],l=e.reshape([i,r]),c=t.reshape([t.size/s,s]),h=new ca(r,u,[i,s]);return this.compileAndRun(h,[c,l]).reshape(a)},t.prototype.fill=function(t,e,n){if("string"===(n=n||W(e))){var r=A(n,y(t));return r.fill(e),ft.make(t,{values:r},n)}var o=new aa(t,e),a=o.getCustomSetupFunc(e),i=this.makeOutputArray(t,n);return this.compileAndRun(o,[],i,a)},t.prototype.onesLike=function(t){if("string"===t.dtype)throw new Error("onesLike is not supported under string dtype");return this.fill(t.shape,1,t.dtype)},t.prototype.zerosLike=function(t){return this.fill(t.shape,"string"===t.dtype?"":0,t.dtype)},t.prototype.linspace=function(t,e,n){return tr(t,e,n)},t.prototype.makeOutputArray=function(t,e){return ft.make(t,{},e,this)},t.prototype.makePackedTensor=function(t,e){var n=ft.make(t,{},e,this);return this.texData.get(n.dataId).isPacked=!0,n},t.prototype.unpackTensor=function(t){var e=new Pi(t.shape);return this.compileAndRun(e,[t],ft.make(e.outputShape,{},t.dtype,this))},t.prototype.packTensor=function(t){var e=new Xa(t.shape);return this.compileAndRun(e,[t],this.makePackedTensor(t.shape,t.dtype))},t.prototype.packedReshape=function(t,e){var n=t.reshape([fe(t.shape)].concat(de(t.shape))),r=[fe(e)].concat(de(e)),o=new ti(r,n.shape);return this.compileAndRun(o,[n]).reshape(e)},t.prototype.compileAndRun=function(t,e,n,r){var o=this;if(null==n&&(n=t.usesPackedTextures?this.makePackedTensor(t.outputShape,e[0].dtype):this.makeOutputArray(t.outputShape,e[0].dtype)),0===n.size)return this.texData.get(n.dataId).values=I(n.dtype,0),n;var i=e.map(function(e){if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");var n=o.texData.get(e.dataId);if(null==n.texture){if(!t.usesPackedTextures&&y(e.shape)<=a.getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.usesPackedTextures&&(n.isPacked=!0,n.shape=e.shape)}else if(!!n.isPacked!=!!t.usesPackedTextures)e=n.isPacked?o.unpackTensor(e):o.packTensor(e),n=o.texData.get(e.dataId);else if(n.isPacked&&!ge(n.shape,e.shape)){var r=e,i=e.shape;e.shape=n.shape,e=o.packedReshape(e,i),n=o.texData.get(e.dataId),r.shape=i}return o.uploadToGPU(e.dataId),{shape:e.shape,texData:n,isUniform:!1}});this.uploadToGPU(n.dataId);var s,u={shape:n.shape,texData:this.texData.get(n.dataId),isUniform:!1},l=function(t,e,n){var r="";e.concat(n).forEach(function(t){var e=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0,n=t.isUniform?"uniform":t.texData.texShape;r+=t.shape+"_"+n+"_"+e});var o=t.userCode,a=t.constructor.name;return a+="_"+r+"_"+o}(t,i,u),c=this.getAndSaveBinary(l,function(){return function(t,e,n,r){var o=e.userCode,i=n.map(function(t,n){var r={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(r.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:r}}),s=i.map(function(t){return t.shapeInfo}),u={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},l=ho(i,u,o,e.usesPackedTextures),c=t.createProgram(l),h=null,p=t.getUniformLocation(c,"NAN",!1);1===a.getNumber("WEBGL_VERSION")&&(h=t.getUniformLocation(c,"INFINITY",!1));for(var f={},d=0;d<e.variableNames.length;d++){var v=e.variableNames[d];f[v]=t.getUniformLocation(c,v,!1),f["offset"+v]=t.getUniformLocation(c,"offset"+v,!1)}return{program:e,source:l,webGLProgram:c,uniformLocations:f,inShapeInfos:s,outShapeInfo:u,infLoc:h,nanLoc:p}}(o.gpgpu,t,i,u)}),h=null!=this.activeTimers;return h&&(s=this.startTimer()),function(t,e,n,r,o){Ua(e.inShapeInfos,n),Ua([e.outShapeInfo],[r]);var i=r.texData.texture,s=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(i,s[0],s[1]):t.setOutputMatrixTexture(i,s[0],s[1]),t.setProgram(e.webGLProgram),1===a.getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach(function(n,r){var o=e.program.variableNames[r],a=e.uniformLocations[o],i=e.uniformLocations["offset"+o];if(null!=a)if(n.isUniform)if(y(n.shape)<2)t.gl.uniform1f(a,n.uniformValues[0]);else{var s=n.uniformValues;s instanceof Float32Array||(s=new Float32Array(s)),t.gl.uniform1fv(a,s)}else null!=n.texData.slice&&null!=i&&t.gl.uniform1i(i,n.texData.slice.flatOffset),t.setInputMatrixTexture(n.texData.texture,a,r)}),null!=o&&o(t,e.webGLProgram),t.executeProgram()}(this.gpgpu,c,i,u,r),h&&(s=this.endTimer(s),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(s)})),a.getBool("WEBGL_LAZILY_UNPACK")||!this.texData.get(n.dataId).isPacked||t.isPackShader?n:this.unpackTensor(n)},t.prototype.getAndSaveBinary=function(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]},t.prototype.getTextureManager=function(){return this.textureManager},t.prototype.dispose=function(){this.disposed||(this.textureManager.dispose(),this.canvas.remove(),null!=this.fromPixels2DContext&&this.fromPixels2DContext.canvas.remove(),this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)},t.prototype.floatPrecision=function(){var t=this;return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Fe(function(){var e=a.getBool("DEBUG");a.set("DEBUG",!1);var n=t.abs(Bn(1e-8)).dataSync()[0];return a.set("DEBUG",e),n>0?32:16})),this.floatPrecisionValue},t.prototype.epsilon=function(){return 32===this.floatPrecision()?1e-7:1e-4},t.prototype.uploadToGPU=function(t){var e,n=this.texData.get(t),r=n.shape,o=n.dtype,a=n.values,i=n.texture,s=n.usage,u=n.isPacked;if(null==i){var l,c=null!=this.activeTimers;c&&(l=performance.now());var h=ve(r,u);n.texShape=h;var p=this.acquireTexture(h,s,o,u);if(n.texture=p,null!=a){if(u){var f=fe(r),d=1,v=1;r.length&&(d=(e=de(r))[0],v=e[1]),this.gpgpu.uploadMatrixToPackedTexture(p,f,d,v,h[0],h[1],zi(a))}else this.gpgpu.uploadMatrixToTexture(p,h[0],h[1],zi(a));n.values=null,c&&(this.uploadWaitMs+=performance.now()-l)}}},t.prototype.convertAndCacheOnCPU=function(t,e){var n=this.texData.get(t),r=n.dtype;return this.releaseGPUData(t),n.usage=ua.UPLOAD,null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){for(var n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length),r=0;r<n.length;++r)n[r]=Math.round(t[r]);return n}throw new Error("Unknown dtype "+e)}(e,r)),n.values},t.prototype.acquireTexture=function(t,e,n,r){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){var o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: "+o+" MB, most likely due to a memory leak")}return this.textureManager.acquireTexture(t,e,r)},t.prototype.computeBytes=function(t,e){return t[0]*t[1]*M(e)},t}();function zi(t){return t instanceof Float32Array?t:new Float32Array(t)}Ot()&&Dt.registerBackend("webgl",function(){return new Ui},2);var Vi=An({abs_:function(t){var e=wn(t,"x","abs");return"complex64"===e.dtype?Dt.runKernel(function(t){return t.complexAbs(e)},{$x:e}):Dt.runKernel(function(t,n){var r=t.abs(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mul(n.toFloat().step(-1))}}})}}),Gi=An({acos_:function(t){var e=wn(t,"x","acos");return Dt.runKernel(function(t,n){var r=t.acos(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.divStrict(Bn(1).sub(n.toFloat().square()).sqrt()).neg()}}})}}),qi=An({acosh_:function(t){var e=wn(t,"x","acosh");return Dt.runKernel(function(t,n){var r=t.acosh(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.divStrict(n.toFloat().square().sub(1).sqrt())}}})}}),Hi=An({asin_:function(t){var e=wn(t,"x","asin");return Dt.runKernel(function(t,n){var r=t.asin(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.divStrict(Bn(1).sub(n.toFloat().square()).sqrt())}}})}}),$i=An({asinh_:function(t){var e=wn(t,"x","asinh");return Dt.runKernel(function(t,n){var r=t.asinh(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.divStrict(Bn(1).add(n.toFloat().square()).sqrt())}}})}}),ji=An({atan_:function(t){var e=wn(t,"x","atan");return Dt.runKernel(function(t,n){var r=t.atan(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(n.toFloat().square().add(1))}}})}}),Ki=An({atanh_:function(t){var e=wn(t,"x","atanh");return Dt.runKernel(function(t,n){var r=t.atanh(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(Bn(1).sub(n.toFloat().square()))}}})}}),Xi=An({ceil_:function(t){var e=wn(t,"x","ceil");return Dt.runKernel(function(t){return t.ceil(e)},{$x:e},function(t){return{$x:function(){return Xn(t)}}})}}),Yi=An({clipByValue_:function(t,e,n){var r=wn(t,"x","clipByValue");return d(e<=n,function(){return"Error in clip: min ("+e+") must be less than or equal to max ("+n+")."}),Dt.runKernel(function(t,o){var a=t.clip(r,e,n);return o([r]),a},{$x:r},function(t,r){var o=r[0];return{$x:function(){return t.where(o.greaterEqual(e).logicalAnd(o.lessEqual(n)),Xn(t))}}})}}),Qi=An({cos_:function(t){var e=wn(t,"x","cos");return Dt.runKernel(function(t,n){var r=t.cos(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return n.toFloat().sin().neg().mul(t)}}})}}),Ji=An({cosh_:function(t){var e=wn(t,"x","cosh");return Dt.runKernel(function(t,n){var r=t.cosh(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return n.toFloat().sinh().mulStrict(t)}}})}}),Zi=An({erf_:function(t){var e=wn(t,"x","erf");return d("int32"===e.dtype||"float32"===e.dtype,function(){return"Input dtype must be `int32` or `float32`."}),"int32"===e.dtype&&(e=e.toFloat()),Dt.runKernel(function(t,n){var r=t.erf(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mul(n.square().neg().exp().mul(2/Math.sqrt(Math.PI)))}}})}}),ts=An({exp_:function(t){var e=wn(t,"x","exp");return Dt.runKernel(function(t,n){var r=t.exp(e);return n([r]),r},{$x:e},function(t,e){return{$x:function(){return t.mulStrict(e[0])}}})}}),es=An({expm1_:function(t){var e=wn(t,"x","expm1");return Dt.runKernel(function(t,n){var r=t.expm1(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mul(n.exp())}}})}}),ns=An({floor_:function(t){var e=wn(t,"x","floor");return Dt.runKernel(function(t){return t.floor(e)},{$x:e},function(t){return{$x:function(){return Xn(t)}}})}}),rs=An({log_:function(t){var e=wn(t,"x","log");return Dt.runKernel(function(t,n){var r=t.log(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(n.toFloat())}}})}}),os=An({log1p_:function(t){var e=wn(t,"x","log1p");return Dt.runKernel(function(t,n){var r=t.log1p(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(n.add(1))}}})}}),as=An({logSigmoid_:function(t){var e=wn(t,"x","logSigmoid");return Dt.runKernel(function(t,n){var r=t.softplus(e.neg()).neg();return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mul(n.neg().sigmoid())}}})}}),is=An({neg_:function(t){var e=wn(t,"x","neg");return Dt.runKernel(function(t){return t.neg(e)},{$x:e},function(t){return{$x:function(){return t.neg()}}})}}),ss=An({reciprocal_:function(t){var e=wn(t,"x","reciprocal");return Dt.runKernel(function(t,n){var r=t.reciprocal(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(n.square().neg())}}})}}),us=An({round_:function(t){var e=wn(t,"x","round");return Dt.runKernel(function(t){return t.round(e)},{$x:e},function(t){return{$x:function(){return Xn(t)}}})}}),ls=An({rsqrt_:function(t){var e=wn(t,"x","rsqrt");return Dt.runKernel(function(t,n){var r=t.rsqrt(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(n.pow(1.5).mul(2)).neg()}}})}}),cs=An({sigmoid_:function(t){var e=wn(t,"x","sigmoid");return Dt.runKernel(function(t,n){var r=t.sigmoid(e);return n([r]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mul(n.mul(Bn(1).sub(n)))}}})}}),hs=An({sign_:function(t){var e=wn(t,"x","sign");return Dt.runKernel(function(t){return t.sign(e)},{$x:e},function(t){return{$x:function(){return Xn(t)}}})}}),ps=An({isNaN_:function(t){var e=wn(t,"x","isNaN");return Dt.runKernel(function(t){return t.isNaN(e)},{$x:e},function(t){return{$x:function(){return Xn(t)}}})}}),fs=An({isInf_:function(t){var e=wn(t,"x","isInf");return Dt.runKernel(function(t){return t.isInf(e)},{$x:e},function(t){return{$x:function(){return Xn(t)}}})}}),ds=An({isFinite_:function(t){var e=wn(t,"x","isFinite");return Dt.runKernel(function(t){return t.isFinite(e)},{$x:e},function(t){return{$x:function(){return Xn(t)}}})}}),vs=An({sin_:function(t){var e=wn(t,"x","sin");return Dt.runKernel(function(t,n){var r=t.sin(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return n.toFloat().cos().mul(t)}}})}}),ms=An({sinh_:function(t){var e=wn(t,"x","sinh");return Dt.runKernel(function(t,n){var r=t.sinh(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return n.toFloat().cosh().mulStrict(t)}}})}}),gs=An({softplus_:function(t){var e=wn(t,"x","softplus");return Dt.runKernel(function(t,n){var r=t.softplus(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mul(n.sigmoid())}}})}}),ys=An({sqrt_:function(t){var e=wn(t,"x","sqrt");return Dt.runKernel(function(t,n){var r=t.sqrt(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(n.toFloat().sqrt().mul(2))}}})}}),xs=An({square_:function(t){var e=wn(t,"x","square");return Dt.runKernel(function(t,n){return n([e]),t.square(e)},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mul(n.toFloat().mul(2))}}})}}),ws=An({step_:function(t,e){void 0===e&&(e=0);var n=wn(t,"x","step");return Dt.runKernel(function(t){return t.step(n,e)},{$x:n},function(t){return{$x:function(){return Xn(t)}}})}}),bs=An({tan_:function(t){var e=wn(t,"x","tan");return Dt.runKernel(function(t,n){var r=t.tan(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(n.cos().square())}}})}}),Cs=An({tanh_:function(t){var e=wn(t,"x","tanh");return Dt.runKernel(function(t,n){var r=t.tanh(e);return n([r]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return Bn(1).sub(n.square()).mulStrict(t)}}})}});function Es(t,e,n,r,o,a){var i,s,u=wn(t,"x","batchNorm"),l=wn(e,"mean","batchNorm"),c=wn(n,"variance","batchNorm");return null!=o&&(i=wn(o,"scale","batchNorm")),null!=r&&(s=wn(r,"offset","batchNorm")),d(2===u.rank,function(){return"Error in batchNorm3D: x must be rank 3 but got rank "+u.rank+"."}),d(2===l.rank||1===l.rank,function(){return"Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank "+l.rank+"."}),d(2===c.rank||1===c.rank,function(){return"Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank "+c.rank+"."}),null!=i&&d(2===i.rank||1===i.rank,function(){return"Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank "+i.rank+"."}),null!=s&&d(2===s.rank||1===s.rank,function(){return"Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank "+s.rank+"."}),Ns(u,l,c,s,i,a)}function Rs(t,e,n,r,o,a){var i,s,u=wn(t,"x","batchNorm"),l=wn(e,"mean","batchNorm"),c=wn(n,"variance","batchNorm");return null!=o&&(i=wn(o,"scale","batchNorm")),null!=r&&(s=wn(r,"offset","batchNorm")),d(3===u.rank,function(){return"Error in batchNorm3D: x must be rank 3 but got rank "+u.rank+"."}),d(3===l.rank||1===l.rank,function(){return"Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank "+l.rank+"."}),d(3===c.rank||1===c.rank,function(){return"Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank "+c.rank+"."}),null!=i&&d(3===i.rank||1===i.rank,function(){return"Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank "+i.rank+"."}),null!=s&&d(3===s.rank||1===s.rank,function(){return"Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank "+s.rank+"."}),Ns(u,l,c,s,i,a)}function Ss(t,e,n,r,o,a){var i,s,u=wn(t,"x","batchNorm"),l=wn(e,"mean","batchNorm"),c=wn(n,"variance","batchNorm");return null!=o&&(i=wn(o,"scale","batchNorm")),null!=r&&(s=wn(r,"offset","batchNorm")),d(4===u.rank,function(){return"Error in batchNorm4D: x must be rank 4 but got rank "+u.rank+"."}),d(4===l.rank||1===l.rank,function(){return"Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank "+l.rank+"."}),d(4===c.rank||1===c.rank,function(){return"Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank "+c.rank+"."}),null!=i&&d(4===i.rank||1===i.rank,function(){return"Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank "+i.rank+"."}),null!=s&&d(4===s.rank||1===s.rank,function(){return"Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank "+s.rank+"."}),Ns(u,l,c,s,i,a)}function Ns(t,e,n,r,o,a){null==a&&(a=.001);var i,s,u,l=wn(t,"x","batchNorm"),c=wn(e,"mean","batchNorm"),h=wn(n,"variance","batchNorm");null!=o&&(i=wn(o,"scale","batchNorm")),null!=r&&(s=wn(r,"offset","batchNorm")),d(c.rank===h.rank,function(){return"Batch normalization gradient requires mean and variance to have equal ranks."}),d(null==s||c.rank===s.rank,function(){return"Batch normalization gradient requires mean and offset to have equal ranks."}),d(null==i||c.rank===i.rank,function(){return"Batch normalization gradient requires mean and scale to have equal ranks."}),u=0===l.rank||1===l.rank?l.as4D(1,1,1,l.size):2===l.rank?l.as4D(1,1,l.shape[0],l.shape[1]):3===l.rank?l.as4D(1,l.shape[0],l.shape[1],l.shape[2]):l;return Dt.runKernel(function(t,e){var n=t.batchNormalization(u,ks(c),ks(h),a,ks(i),ks(s));return e([l,c,h,i]),n},{$x:l,$mean:c,$variance:h,$scale:i,$offset:s},function(t,e){var n=e[0],r=e[1],o=e[2],i=e[3],s=null==i?Bn(1):i,l=io(r.shape,u.shape),c=[];if(1===r.rank){for(var h=0;h<u.shape.length-1;++h)c.push(u.shape[h]);c.push(1)}var p=n.sub(r),f=t.mul(s),d=ls(o.add(Bn(a))),v=d.mul(d).mul(d).mul(Bn(-.5));return{$x:function(){return 1===r.rank?t.mul(Xr(d.as4D(1,1,1,r.shape[0]),c)).mul(s).reshape(n.shape):t.mul(d).mul(s).reshape(n.shape)},$mean:function(){var t=d.mul(Bn(-1)).mul(f);return 1===r.rank&&(t=t.sum(l)),t.reshape(r.shape)},$variance:function(){var t=v.mul(p).mul(f);return 1===r.rank&&(t=t.sum(l)),t.reshape(r.shape)},$scale:function(){var e=p.mul(d),n=t.mul(e);return 1===r.rank&&(n=n.sum(l)),n.reshape(r.shape)},$offset:function(){var e=t;return 1===r.rank&&(e=e.sum(l)),e.reshape(r.shape)}}}).reshape(l.shape)}function ks(t){return null==t?null:0===t.rank?t.as1D():1===t.rank?t:2===t.rank?t.as4D(1,1,t.shape[0],t.shape[1]):3===t.rank?t.as4D(1,t.shape[0],t.shape[1],t.shape[2]):t}function Is(){De("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon")}var As=An({batchNormalization2d_:function(t,e,n,r,o,a){return void 0===r&&(r=.001),Is(),Es(t,e,n,a,o,r)}}),Ts=An({batchNormalization3d_:function(t,e,n,r,o,a){return void 0===r&&(r=.001),Is(),Rs(t,e,n,a,o,r)}}),Ds=An({batchNormalization4d_:function(t,e,n,r,o,a){return void 0===r&&(r=.001),Is(),Ss(t,e,n,a,o,r)}}),Os=An({batchNormalization_:function(t,e,n,r,o,a){return void 0===r&&(r=.001),Is(),Ns(t,e,n,a,o,r)}}),_s=An({batchNorm_:Ns}),Ms=An({batchNorm2d_:Es}),Fs=An({batchNorm3d_:Rs}),Bs=An({batchNorm4d_:Ss});function Ps(t,e,n,r,o,a,i){void 0===i&&(i="channelsLast");var s,u=Us(e),l=u[0],c=u[1];if("channelsLast"===i)s=[l,c,t[3],t[3]];else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat "+i);s=[l,c,t[1],t[1]]}return Ls(t,s,n,r,o,a,!1,i)}function Ls(t,e,n,r,o,a,i,s){void 0===i&&(i=!1),void 0===s&&(s="channelsLast");var u=[-1,-1,-1,-1],l=u[0],c=u[1],h=u[2],p=u[3];if("channelsLast"===s)l=t[0],c=t[1],h=t[2],p=t[3];else{if("channelsFirst"!==s)throw new Error("Unknown dataFormat "+s);l=t[0],p=t[1],c=t[2],h=t[3]}var f,v=e[0],m=e[1],g=e[3],y=Us(n),x=y[0],b=y[1],C=Us(r),E=C[0],R=C[1],S=Vs(v,E),N=Vs(m,R),k=function(t,e,n,r,o,a,i,s){var u,l,c;if("number"==typeof t){var h=0===t?"VALID":"NUMBER";u={top:t,bottom:t,left:t,right:t,type:h};var p=function(t,e,n,r,o,a){null==o&&(o=function(t,e,n,r){void 0===r&&(r=1);var o=Vs(e,r);return Math.floor((t[0]*(n-1)-n+o)/2)}(t,e,r));var i=t[0],s=t[1],u=Gs((i-e+2*o)/r+1,a);d(w(u),function(){return"The output # of rows ("+u+") must be an integer. Change the stride and/or zero pad parameters"});var l=Gs((s-e+2*o)/r+1,a);return d(w(l),function(){return"The output # of columns ("+l+") must be an integer. Change the stride and/or zero pad parameters"}),[u,l,n]}([e,n,1],a,1,r,t,s);l=p[0],c=p[1]}else if("same"===t){l=Math.ceil(e/r),c=Math.ceil(n/o);var f=Math.max(0,(l-1)*r+a-e),v=Math.max(0,(c-1)*o+i-n),m=Math.floor(f/2),g=f-m,y=Math.floor(v/2),x=v-y;u={top:m,bottom:g,left:y,right:x,type:"SAME"}}else{if("valid"!==t)throw Error("Unknown padding parameter: "+t);u={top:0,bottom:0,left:0,right:0,type:"VALID"},l=Math.ceil((e-a+1)/r),c=Math.ceil((n-i+1)/o)}return{padInfo:u,outHeight:l,outWidth:c}}(o,c,h,x,b,S,N,a),I=k.padInfo,A=k.outHeight,T=k.outWidth,D=i?g*p:g;return"channelsFirst"===s?f=[l,D,A,T]:"channelsLast"===s&&(f=[l,A,T,D]),{batchSize:l,dataFormat:s,inHeight:c,inWidth:h,inChannels:p,outHeight:A,outWidth:T,outChannels:D,padInfo:I,strideHeight:x,strideWidth:b,filterHeight:v,filterWidth:m,effectiveFilterHeight:S,effectiveFilterWidth:N,dilationHeight:E,dilationWidth:R,inShape:t,outShape:f,filterShape:e}}function Ws(t,e,n,r,o,a,i){void 0===a&&(a=!1),void 0===i&&(i="channelsLast");var s=[-1,-1,-1,-1,-1],u=s[0],l=s[1],c=s[2],h=s[3],p=s[4];if("channelsLast"===i)u=t[0],l=t[1],c=t[2],h=t[3],p=t[4];else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat "+i);u=t[0],p=t[1],l=t[2],c=t[3],h=t[4]}var f,d=e[0],v=e[1],m=e[2],g=e[4],y=zs(n),x=y[0],w=y[1],b=y[2],C=zs(r),E=C[0],R=C[1],S=C[2],N=function(t,e,n,r,o,a,i,s,u,l){var c,h,p,f;if("same"===t){h=Math.ceil(e/o),p=Math.ceil(n/a),f=Math.ceil(r/i);var d=(h-1)*o+s-e,v=(p-1)*a+u-n,m=(f-1)*i+l-r,g=Math.floor(d/2),y=d-g,x=Math.floor(v/2),w=v-x,b=Math.floor(m/2),C=m-b;c={top:x,bottom:w,left:b,right:C,front:g,back:y,type:"SAME"}}else{if("valid"!==t)throw Error("Unknown padding parameter: "+t);c={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},h=Math.ceil((e-s+1)/o),p=Math.ceil((n-u+1)/a),f=Math.ceil((r-l+1)/i)}return{padInfo:c,outDepth:h,outHeight:p,outWidth:f}}(o,l,c,h,x,w,b,Vs(d,E),Vs(v,R),Vs(m,S)),k=N.padInfo,I=N.outDepth,A=N.outHeight,T=N.outWidth,D=a?g*p:g;return"channelsFirst"===i?f=[u,D,I,A,T]:"channelsLast"===i&&(f=[u,I,A,T,D]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:c,inWidth:h,inChannels:p,outDepth:I,outHeight:A,outWidth:T,outChannels:D,padInfo:k,strideDepth:x,strideHeight:w,strideWidth:b,filterDepth:d,filterHeight:v,filterWidth:m,dilationDepth:E,dilationHeight:R,dilationWidth:S,inShape:t,outShape:f,filterShape:e}}function Us(t){return"number"==typeof t?[t,t]:t}function zs(t){return"number"==typeof t?[t,t,t]:t}function Vs(t,e){return e<=1?t:t+(t-1)*(e-1)}function Gs(t,e){if(!e)return t;switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error("Unknown roundingMode "+e)}}function qs(t){var e=Us(t),n=e[0],r=e[1];return 1===n&&1===r}function Hs(t,e){return qs(t)||qs(e)}function $s(t,e,n,r,o,a){d(t.length===e.rank,function(){return"Length of inShape ("+t.length+") and rank of dy ("+e.rank+") must match"});var i=t,s=e,u=!1;3===e.rank&&(u=!0,s=e.as4D(1,e.shape[0],e.shape[1],e.shape[2]),i=[1,t[0],t[1],t[2]]);var l=i[3],c=s.shape[3];d(4===i.length,function(){return"Error in conv2dDerInput: inShape must be length 4, but got length "+i.length+"."}),d(4===s.rank,function(){return"Error in conv2dDerInput: dy must be rank 4, but got rank "+s.rank}),d(4===n.rank,function(){return"Error in conv2dDerInput: filter must be rank 4, but got rank "+n.rank}),d(l===n.shape[2],function(){return"Error in conv2dDerInput: depth of input ("+l+") must match input depth for filter "+n.shape[2]+"."}),d(c===n.shape[3],function(){return"Error in conv2dDerInput: depth of output ("+c+") must match output depth for filter "+n.shape[3]+"."}),null!=a&&d(w(o),function(){return"Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+o+"."});var h=Ls(i,n.shape,r,1,o,a),p=Dt.runKernel(function(t,e){var r=t.conv2dDerInput(s,n,h);return e([n,s]),r},{dy4D:s,filter:n},function(t,e){var n=e[0],i=e[1];return{dy4D:function(){return Ys(t,n,r,o,"NHWC",1,a)},filter:function(){return Js(t,i,n.shape,r,o,a)}}});return u?p.as3D(p.shape[1],p.shape[2],p.shape[3]):p}function js(t,e,n,r,o,a){var i=t;3===t.rank&&(i=t.as4D(1,t.shape[0],t.shape[1],t.shape[2]));var s=e;3===s.rank&&(s=e.as4D(1,e.shape[0],e.shape[1],e.shape[2])),d(4===i.rank,function(){return"Error in conv2dDerFilter: input must be rank 4, but got shape "+i.shape+"."}),d(4===s.rank,function(){return"Error in conv2dDerFilter: dy must be rank 4, but got shape "+s.shape+"."}),d(4===n.length,function(){return"Error in conv2dDerFilter: filterShape must be length 4, but got "+n+"."}),d(i.shape[3]===n[2],function(){return"Error in conv2dDerFilter: depth of input "+i.shape[3]+") must match input depth in filter ("+n[2]+"."}),d(s.shape[3]===n[3],function(){return"Error in conv2dDerFilter: depth of dy ("+s.shape[3]+") must match output depth for filter ("+n[3]+")."}),null!=a&&d(w(o),function(){return"Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+o+"."});var u=Ls(i.shape,n,r,1,o,a);return Dt.runKernel(function(t){return t.conv2dDerFilter(i,s,u)},{x4D:i,dy4D:s})}function Ks(t){var e=function(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}(t),n=e[0],r=e[1],o=e[2];return 1===n&&1===r&&1===o}var Xs=An({conv1d_:function(t,e,n,r,o,a,i){void 0===o&&(o="NWC"),void 0===a&&(a=1);var s=wn(t,"x","conv1d"),u=wn(e,"filter","conv1d"),l=s,c=!1;2===s.rank&&(c=!0,l=s.as3D(1,s.shape[0],s.shape[1])),d(3===l.rank,function(){return"Error in conv1d: input must be rank 3, but got rank "+l.rank+"."}),d(3===u.rank,function(){return"Error in conv1d: filter must be rank 3, but got rank "+u.rank+"."}),null!=i&&d(w(r),function(){return"Error in conv1d: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+r+"."}),d(l.shape[2]===u.shape[1],function(){return"Error in conv1d: depth of input ("+l.shape[2]+") must match input depth for filter "+u.shape[1]+"."}),d(Hs(n,a),function(){return"Error in conv1D: Either stride or dilation must be 1. Got stride "+n+" and dilation '"+a+"'"}),d("NWC"===o,function(){return"Error in conv1d: got dataFormat of "+o+" but only NWC is currently supported."});var h=u.as4D(1,u.shape[0],u.shape[1],u.shape[2]),p=l.as4D(l.shape[0],1,l.shape[1],l.shape[2]),f=Ys(p,h,[1,n],r,"NHWC",[1,a],i);return c?f.as2D(f.shape[2],f.shape[3]):f.as3D(f.shape[0],f.shape[2],f.shape[3])}}),Ys=An({conv2d_:function(t,e,n,r,o,a,i){void 0===o&&(o="NHWC"),void 0===a&&(a=[1,1]);var s=wn(t,"x","conv2d"),u=wn(e,"filter","conv2d"),l=s,c=!1;3===s.rank&&(c=!0,l=s.as4D(1,s.shape[0],s.shape[1],s.shape[2])),d(4===l.rank,function(){return"Error in conv2d: input must be rank 4, but got rank "+l.rank+"."}),d(4===u.rank,function(){return"Error in conv2d: filter must be rank 4, but got rank "+u.rank+"."}),null!=i&&d(w(r),function(){return"Error in conv2d: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+r+"."}),d(l.shape[3]===u.shape[2],function(){return"Error in conv2d: depth of input ("+l.shape[3]+") must match input depth for filter "+u.shape[2]+"."}),d(Hs(n,a),function(){return"Error in conv2D: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+a+"'"}),d("NHWC"===o,function(){return"Error in conv2d: got dataFormat of "+o+" but only NHWC is currently supported."});var h=Ls(l.shape,u.shape,n,a,r,i),p=Dt.runKernel(function(t,e){var n=t.conv2d(l,u,h);return e([u,l]),n},{x:l,$filter:u},function(t,e){var o=e,i=o[0],s=o[1];return d(qs(a),function(){return"Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+a+"'"}),{x:function(){return $s(s.shape,t,i,n,r)},$filter:function(){return js(s,t,i.shape,n,r)}}});return c?p.as3D(p.shape[1],p.shape[2],p.shape[3]):p}}),Qs=An({conv3d_:function(t,e,n,r,o,a){void 0===o&&(o="NDHWC"),void 0===a&&(a=[1,1,1]);var i=wn(t,"x","conv3d"),s=wn(e,"filter","conv3d"),u=i,l=!1;4===i.rank&&(l=!0,u=i.as5D(1,i.shape[0],i.shape[1],i.shape[2],i.shape[3])),d(5===u.rank,function(){return"Error in conv3d: input must be rank 5, but got rank "+u.rank+"."}),d(5===s.rank,function(){return"Error in conv3d: filter must be rank 5, but got rank "+s.rank+"."}),d(u.shape[4]===s.shape[3],function(){return"Error in conv3d: depth of input ("+u.shape[4]+") must match input depth for filter "+s.shape[3]+"."}),d(function(t,e){return Ks(t)||Ks(e)}(n,a),function(){return"Error in conv3D: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+a+"'"}),d("NDHWC"===o,function(){return"Error in conv3d: got dataFormat of "+o+" but only NDHWC is currently supported."});var c=Ws(u.shape,s.shape,n,a,r),h=Dt.runKernel(function(t,e){var n=t.conv3d(u,s,c);return e([u,s]),n},{x:u,$filter:s},function(t,e){d(Ks(a),function(){return"Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+a+"'"});var o=e[0],i=e[1];return{x:function(){return function(t,e,n,r,o){d(t.length===e.rank,function(){return"Length of inShape ("+t.length+") and rank of dy ("+e.rank+") must match"});var a=t,i=e,s=!1;4===e.rank&&(s=!0,i=e.as5D(1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]),a=[1,t[0],t[1],t[2],t[3]]);var u=a[4],l=i.shape[4];d(5===a.length,function(){return"Error in conv3dDerInput: inShape must be length 5, but got length "+a.length+"."}),d(5===i.rank,function(){return"Error in conv3dDerInput: dy must be rank 5, but got rank "+i.rank}),d(5===n.rank,function(){return"Error in conv3dDerInput: filter must be rank 5, but got rank "+n.rank}),d(u===n.shape[3],function(){return"Error in conv3dDerInput: depth of input ("+u+") must match input depth for filter "+n.shape[3]+"."}),d(l===n.shape[4],function(){return"Error in conv3dDerInput: depth of output ("+l+") must match output depth for filter "+n.shape[4]+"."});var c=Ws(a,n.shape,r,1,o),h=Dt.runKernel(function(t){return t.conv3dDerInput(i,n,c)},{dy5D:i});return s?h.as4D(h.shape[1],h.shape[2],h.shape[3],h.shape[4]):h}(o.shape,t,i,n,r)},$filter:function(){return function(t,e,n,r,o){var a=t;4===t.rank&&(a=t.as5D(1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]));var i=e;4===i.rank&&(i=e.as5D(1,e.shape[0],e.shape[1],e.shape[2],e.shape[3])),d(5===a.rank,function(){return"Error in conv3dDerFilter: input must be rank 5, but got shape "+a.shape+"."}),d(5===i.rank,function(){return"Error in conv3dDerFilter: dy must be rank 5, but got shape "+i.shape+"."}),d(5===n.length,function(){return"Error in conv3dDerFilter: filterShape must be length 5, but got "+n+"."}),d(a.shape[4]===n[3],function(){return"Error in conv3dDerFilter: depth of input "+a.shape[4]+") must match input depth in filter ("+n[3]+"."}),d(i.shape[4]===n[4],function(){return"Error in conv3dDerFilter: depth of dy ("+i.shape[4]+") must match output depth for filter ("+n[4]+")."});var s=Ws(a.shape,n,r,1,o);return Dt.runKernel(function(t){return t.conv3dDerFilter(a,i,s)},{x5D:a,dy5D:i})}(o,t,i.shape,n,r)}}});return l?h.as4D(h.shape[1],h.shape[2],h.shape[3],h.shape[4]):h}}),Js=An({conv2dDerFilter_:js}),Zs=An({depthwiseConv2d_:function(t,e,n,r,o,a,i){void 0===o&&(o="NHWC"),void 0===a&&(a=[1,1]);var s=wn(t,"x","depthwiseConv2d"),u=wn(e,"filter","depthwiseConv2d"),l=s,c=!1;3===s.rank&&(c=!0,l=s.as4D(1,s.shape[0],s.shape[1],s.shape[2])),d(4===l.rank,function(){return"Error in depthwiseConv2d: input must be rank 4, but got rank "+l.rank+"."}),d(4===u.rank,function(){return"Error in depthwiseConv2d: filter must be rank 4, but got rank "+u.rank+"."}),d(l.shape[3]===u.shape[2],function(){return"Error in depthwiseConv2d: number of input channels ("+l.shape[3]+") must match the inChannels dimension in filter "+u.shape[2]+"."}),null==a&&(a=[1,1]),d(Hs(n,a),function(){return"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+a+"'"}),null!=i&&d(w(r),function(){return"Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+r+"."});var h=Ls(l.shape,u.shape,n,a,r,i,!0),p=Dt.runKernel(function(t,e){var n=t.depthwiseConv2D(l,u,h);return e([l,u]),n},{x:l,$filter:u},function(t,e){d(qs(a),function(){return"Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+a+"'"});var n=e[0],r=e[1];return{x:function(){return function(t,e,n,r){var o=e,a=!1;3===e.rank&&(a=!0,o=e.as4D(1,e.shape[0],e.shape[1],e.shape[2]));var i=Dt.runKernel(function(t){return t.depthwiseConv2DDerInput(o,n,r)},{dy4D:o});return a?i.as3D(i.shape[1],i.shape[2],i.shape[3]):i}(n.shape,t,r,h)},$filter:function(){return function(t,e,n,r){var o=t;3===t.rank&&(o=t.as4D(1,t.shape[0],t.shape[1],t.shape[2]));var a=e;return 3===a.rank&&(a=e.as4D(1,e.shape[0],e.shape[1],e.shape[2])),Dt.runKernel(function(t){return t.depthwiseConv2DDerFilter(o,a,r)},{x4D:o,dy4D:a})}(n,t,r.shape,h)}}});return c?p.as3D(p.shape[1],p.shape[2],p.shape[3]):p}}),tu=An({separableConv2d_:function(t,e,n,r,o,a,i){void 0===a&&(a=[1,1]),void 0===i&&(i="NHWC");var s=wn(t,"x","separableConv2d"),u=wn(e,"depthwiseFilter","separableConv2d"),l=wn(n,"pointwiseFilter","separableConv2d"),c=s,h=!1;if(3===s.rank&&(h=!0,c=s.as4D(1,s.shape[0],s.shape[1],s.shape[2])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");d(4===c.rank,function(){return"Error in separableConv2d: input must be rank 4, but got rank "+c.rank+"."}),d(4===u.rank,function(){return"Error in separableConv2d: depthwise filter must be rank 4, but got rank "+u.rank+"."}),d(4===l.rank,function(){return"Error in separableConv2d: pointwise filter must be rank 4, but got rank "+u.rank+"."}),d(1===l.shape[0],function(){return"Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got "+l.shape[0]+"."}),d(1===l.shape[1],function(){return"Error in separableConv2d: the second dimension of pointwise filter must be 1, but got "+l.shape[1]+"."});var p=u.shape[2],f=u.shape[3];d(l.shape[2]===p*f,function(){return"Error in separableConv2d: the third dimension of pointwise filter must be "+p*f+", but got "+l.shape[2]+"."});var v=Zs(c,u,r,o,i,a),m=Ys(v,l,1,"valid",i);return h?m.as3D(m.shape[1],m.shape[2],m.shape[3]):m}}),eu=An({conv2dTranspose_:function(t,e,n,r,o,a){return $s(n,wn(t,"x","conv2dTranspose"),wn(e,"filter","conv2dTranspose"),r,o,a)}});var nu=An({matMul_:function(t,e,n,r){var o;void 0===n&&(n=!1),void 0===r&&(r=!1);var a=wn(t,"a","matMul"),i=wn(e,"b","matMul");o=Rt(a,i),a=o[0],i=o[1];var s=n?a.shape[a.rank-2]:a.shape[a.rank-1],u=r?i.shape[i.rank-1]:i.shape[i.rank-2],l=n?a.shape[a.rank-1]:a.shape[a.rank-2],c=r?i.shape[i.rank-2]:i.shape[i.rank-1],h=a.shape.slice(0,-2),p=i.shape.slice(0,-2),f=y(h),v=y(p);d(a.rank>=2&&i.rank>=2&&a.rank===i.rank,function(){return"Error in matMul: inputs must have the same rank of at least 2, got ranks "+a.rank+" and "+i.rank+"."}),d(x(h,p),function(){return"Error in matMul: outer dimensions ("+h+") and ("+p+") of Tensors with shapes "+a.shape+" and "+i.shape+" must match."}),d(s===u,function(){return"Error in matMul: inner shapes ("+s+") and ("+u+") of Tensors with shapes "+a.shape+" and "+i.shape+" and transposeA="+n+" and transposeB="+r+" must match."});var m=a.shape.slice(0,-2).concat([l,c]),g=n?a.as3D(f,s,l):a.as3D(f,l,s),w=r?i.as3D(v,c,u):i.as3D(v,u,c);return Dt.runKernel(function(t,e){var o=t.batchMatMul(g,w,n,r);return e([g,w]),o},{$a:g,$b:w},function(t,e){var o=e,a=o[0],i=o[1];return n||r?!n&&r?{$a:function(){return t.matMul(i,!1,!1)},$b:function(){return t.matMul(a,!0,!1)}}:n&&!r?{$a:function(){return i.matMul(t,!1,!0)},$b:function(){return a.matMul(t,!1,!1)}}:{$a:function(){return i.matMul(t,!0,!0)},$b:function(){return t.matMul(a,!0,!0)}}:{$a:function(){return t.matMul(i,!1,!0)},$b:function(){return a.matMul(t,!0,!1)}}}).reshape(m)}}),ru=An({dot_:function(t,e){var n=wn(t,"t1","dot"),r=wn(e,"t2","dot");d(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),function(){return"Error in dot: inputs must all be rank 1 or 2, but got ranks "+n.rank+" and "+r.rank+"."});var o=1===n.rank?n.size:n.shape[1],a=1===r.rank?r.size:r.shape[0];return d(o===a,function(){return"Error in dot: inner dimensions of inputs must match, but got "+o+" and "+a+"."}),1===n.rank&&1===r.rank?n.as2D(1,-1).matMul(r.as2D(-1,1)).asScalar():1===n.rank&&2===r.rank?n.as2D(1,-1).matMul(r.as2D(r.shape[0],r.shape[1])).as1D():2===n.rank&&1===r.rank?n.matMul(r.as2D(-1,1)).as1D():n.matMul(r.as2D(r.shape[0],r.shape[1]))}}),ou=An({outerProduct_:function(t,e){var n=wn(t,"v1","outerProduct"),r=wn(e,"v2","outerProduct");return d(1===n.rank&&1===r.rank,function(){return"Error in outerProduct: inputs must be rank 1, but got ranks "+n.rank+" and "+r.rank+"."}),n.as2D(-1,1).matMul(r.as2D(1,-1))}});var au=An({reverse_:function(t,e){var n=wn(t,"x","reverse");if(0===n.rank)return n.clone();var r=N(e,n.shape);return Dt.runKernel(function(t){return t.reverse(n,r)},{$x:n},function(t){return{$x:function(){return t.reverse(r)}}}).reshapeAs(n)}}),iu=An({reverse1d_:function(t){var e=wn(t,"x","reverse");return d(1===e.rank,function(){return"Error in reverse1D: x must be rank 1 but got rank "+e.rank+"."}),au(e,0)}}),su=An({reverse2d_:function(t,e){var n=wn(t,"x","reverse");return d(2===n.rank,function(){return"Error in reverse2D: x must be rank 2 but got rank "+n.rank+"."}),au(n,e)}}),uu=An({reverse3d_:function(t,e){var n=wn(t,"x","reverse");return d(3===n.rank,function(){return"Error in reverse3D: x must be rank 3 but got rank "+n.rank+"."}),au(n,e)}}),lu=An({reverse4d_:function(t,e){var n=wn(t,"x","reverse");return d(4===n.rank,function(){return"Error in reverse4D: x must be rank 4 but got rank "+n.rank+"."}),au(n,e)}});function cu(t,e,n,r,o,a){var i=wn(t,"x","maxPool"),s=i,u=!1;3===i.rank&&(u=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),null==r&&(r=[1,1]),d(4===s.rank,function(){return"Error in maxPool: input must be rank 4 but got rank "+s.rank+"."}),d(Hs(n,r),function(){return"Error in maxPool: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+r+"'"}),null!=a&&d(w(o),function(){return"Error in maxPool: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+o+"."});var l=Ps(s.shape,e,n,r,o,a),c=Dt.runKernel(function(t,e){var n=t.maxPool(s,l);return e([s,n]),n},{x:s},function(t,a){var i=a[0],s=a[1];return{x:function(){return function(t,e,n,r,o,a,i,s){var u=wn(t,"dy","maxPoolBackprop"),l=wn(e,"input","maxPoolBackprop"),c=wn(n,"output","maxPoolBackprop");d(l.rank===u.rank,function(){return"Rank of input ("+l.rank+") does not match rank of dy ("+u.rank+")"}),null==a&&(a=[1,1]),d(Hs(o,a),function(){return"Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides "+o+" and dilations '"+a+"'"}),d(4===u.rank,function(){return"Error in maxPoolBackprop: dy must be rank 4 but got rank "+u.rank+"."}),d(4===l.rank,function(){return"Error in maxPoolBackprop: input must be rank 4 but got rank "+l.rank+"."}),null!=s&&d(w(i),function(){return"Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode "+s+" but got pad "+i+"."});var h=Ps(l.shape,r,o,a,i,s);return Dt.runKernel(function(t){return t.maxPoolBackprop(u,l,c,h)},{$dy:u,$input:l})}(t,i,s,e,n,r,o)}}});return u?c.as3D(c.shape[1],c.shape[2],c.shape[3]):c}function hu(t,e,n,r,o,a){var i=wn(t,"x","avgPool","float32");null==r&&(r=[1,1]),d(Hs(n,r),function(){return"Error in avgPool: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+r+"'"});var s=i,u=!1;3===i.rank&&(u=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),d(4===s.rank,function(){return"Error in avgPool: x must be rank 4 but got rank "+s.rank+"."}),null!=a&&d(w(o),function(){return"Error in avgPool: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+o+"."});var l=Ps(s.shape,e,n,r,o,a),c=Dt.runKernel(function(t){return t.avgPool(s,l)},{x:s},function(t){return{x:function(){return function(t,e,n,r,o,a){var i=wn(t,"dy","avgPoolBackprop"),s=wn(e,"input","avgPoolBackprop");d(s.rank===i.rank,function(){return"Rank of input ("+s.rank+") does not match rank of dy ("+i.rank+")"}),null==o&&(o=[1,1]),d(Hs(r,o),function(){return"Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides "+r+" and dilations '"+o+"'"});var u=s,l=i,c=!1;3===s.rank&&(c=!0,u=s.as4D(1,s.shape[0],s.shape[1],s.shape[2]),l=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),d(4===l.rank,function(){return"Error in avgPoolBackprop: dy must be rank 4 but got rank "+l.rank+"."}),d(4===u.rank,function(){return"Error in avgPoolBackprop: input must be rank 4 but got rank "+u.rank+"."});var h=Ps(u.shape,n,r,o,a),p=Dt.runKernel(function(t){return t.avgPoolBackprop(l,u,h)},{dy4D:l,input4D:u});return c?p.as3D(p.shape[1],p.shape[2],p.shape[3]):p}(t,s,e,n,r,o)}}});return c=c.cast(i.dtype),u?c.as3D(c.shape[1],c.shape[2],c.shape[3]):c}var pu=An({maxPool_:function(t,e,n,r,o){return cu(t,e,n,1,r,o)}}),fu=An({avgPool_:function(t,e,n,r,o){return hu(t,e,n,1,r,o)}}),du=An({pool_:function(t,e,n,r,o,a){null==o&&(o=[1,1]),null==a&&(a=1),0===r&&(r="valid");var i=wn(t,"x","maxPool"),s=i,u=!1;3===i.rank&&(u=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),d(Hs(a,o),function(){return"Error in pool: Either strides or dilations must be 1. Got strides "+a+" and dilations '"+o+"'"});var l,c=Ps(s.shape,e,a,o,r),h=[c.dilationHeight,c.dilationWidth];l="same"===r?function(t,e){var n=t.map(function(t,n){return t+(t-1)*(e[n]-1)}).map(function(t){return t-1}),r=n.map(function(t){return Math.floor(t/2)}),o=n.map(function(t,e){return t-r[e]});return n.map(function(t,e){return[r[e],o[e]]})}([c.filterHeight,c.filterWidth],h):[[0,0],[0,0]];var p=1===h[0]&&1===h[1],f=function(t,e,n){var r=n.map(function(t){return t[0]}),o=n.map(function(t){return t[1]}),a=t.concat(r,o),i=e.map(function(t,e){return(t-a[e]%t)%t}),s=o.map(function(t,e){return t+i[e]}),u=e.map(function(t,e){return[r[e],s[e]]}),l=e.map(function(t,e){return[0,i[e]]});return[u,l]}([c.inHeight,c.inWidth],h,l),v=f[0],m=f[1],g=p?r:"valid",y=p?s:$r(s,h,v),x=("avg"===n?function(){return hu(y,e,a,1,g)}:function(){return cu(y,e,a,1,g)})(),w=p?x:Ir(x,h,m);return u?w.as3D(w.shape[1],w.shape[2],w.shape[3]):w}});var vu=An({slice_:function(t,e,n){var r,o,a=wn(t,"x","slice");if(0===a.rank)throw new Error("Slicing scalar is not possible");r="number"==typeof e?[e].concat(new Array(a.rank-1).fill(0)):e.length<a.rank?e.concat(new Array(a.rank-e.length).fill(0)):e.slice(),o=(o=null==n?new Array(a.rank).fill(-1):"number"==typeof n?[n].concat(new Array(a.rank-1).fill(-1)):n.length<a.rank?n.concat(new Array(a.rank-n.length).fill(-1)):n).map(function(t,e){return t>=0?t:(d(-1===t,function(){return"Bad value in size"}),a.shape[e]-r[e])}),function(t,e,n){d(t.rank===e.length,function(){return"Error in slice"+t.rank+"D: Length of begin "+e+" must match the rank of the array ("+t.rank+")."}),d(t.rank===n.length,function(){return"Error in slice"+t.rank+"D: Length of size "+n+" must match the rank of the array ("+t.rank+")."});for(var r=function(r){d(e[r]+n[r]<=t.shape[r],function(){return"Error in slice"+t.rank+"D: begin["+r+"] + size["+r+"] ("+(e[r]+n[r])+") would overflow input.shape["+r+"] ("+t.shape[r]+")"})},o=0;o<t.rank;++o)r(o)}(a,r,o);var i=a.shape;return Dt.runKernel(function(t){return t.slice(a,r,o)},{$x:a},function(t){for(var e=[],n=0;n<t.rank;n++)e.push([r[n],i[n]-r[n]-o[n]]);return{$x:function(){return t.pad(e)}}})}}),mu=An({slice1d_:function(t,e,n){var r=wn(t,"x","slice1d");return d(1===r.rank,function(){return"slice1d expects a rank-1 tensor, but got a rank-"+r.rank+" tensor"}),vu(r,[e],[n])}}),gu=An({slice2d_:function(t,e,n){var r=wn(t,"x","slice2d");return d(2===r.rank,function(){return"slice2d expects a rank-2 tensor, but got a rank-"+r.rank+" tensor"}),vu(r,e,n)}}),yu=An({slice3d_:function(t,e,n){var r=wn(t,"x","slice3d");return d(3===r.rank,function(){return"slice3d expects a rank-3 tensor, but got a rank-"+r.rank+" tensor"}),vu(r,e,n)}}),xu=An({slice4d_:function(t,e,n){var r=wn(t,"x","slice4d");return d(4===r.rank,function(){return"slice4d expects a rank-4 tensor, but got a rank-"+r.rank+" tensor"}),vu(r,e,n)}});function wu(t,e,n,r,o){return e.rank<n.rank&&(e=e.reshape(en(e.shape,r))),t.rank<n.rank&&(t=t.reshape(en(t.shape,r))),{$x:function(){var r=t.mul(n.equal(e).cast(t.dtype));return null==o?r:r.transpose(o)}}}var bu=An({all_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","all","bool"),o=N(e,r.shape),a=o,i=rn(a,r.rank);null!=i&&(r=r.transpose(i),a=an(a.length,r.rank));var s=Dt.runKernel(function(t){return t.all(r,a)},{$x:r});if(n){var u=en(s.shape,o);return s.reshape(u)}return s}}),Cu=An({any_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","any","bool"),o=N(e,r.shape),a=o,i=rn(a,r.rank);null!=i&&(r=r.transpose(i),a=an(a.length,r.rank));var s=Dt.runKernel(function(t){return t.any(r,a)},{$x:r});if(n){var u=en(s.shape,o);return s.reshape(u)}return s}}),Eu=An({argMax_:function(t,e){void 0===e&&(e=0);var n=wn(t,"x","argMax");null==e&&(e=0);var r=N(e,n.shape),o=rn(r,n.rank);return null!=o&&(n=n.transpose(o),r=an(r.length,n.rank)),Dt.runKernel(function(t,e){var o=t.argMax(n,r[0]);return e([n]),o},{$x:n},function(t,e){var n=e[0];return{$x:function(){return Xn(n)}}})}}),Ru=An({argMin_:function(t,e){void 0===e&&(e=0);var n=wn(t,"x","argMin");null==e&&(e=0);var r=N(e,n.shape),o=rn(r,n.rank);return null!=o&&(n=n.transpose(o),r=an(r.length,n.rank)),Dt.runKernel(function(t,e){var o=t.argMin(n,r[0]);return e([n]),o},{$x:n},function(t,e){var n=e[0];return{$x:function(){return Xn(n)}}})}}),Su=An({logSumExp_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","logSumExp"),o=N(e,r.shape),a=r.max(o,!0),i=r.sub(a).exp().sum(o).log(),s=a.reshape(i.shape).add(i);if(n){var u=en(s.shape,o);return s.reshape(u)}return s}}),Nu=An({max_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","max"),o=r,a=N(e,r.shape),i=a,s=rn(i,r.rank);null!=s&&(r=r.transpose(s),i=an(i.length,r.rank));var u=Dt.runKernel(function(t,e){var n=t.max(r,i);return e([o,n]),n},{$x:r},function(t,e){return wu(t,e[1],e[0],a,s)});if(n){var l=en(u.shape,a);u=u.reshape(l)}return u}}),ku=An({mean_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","mean"),o=N(e,r.shape),a=y(tn(r.shape,o)[1]);return kn(function(t){var r=Bn(a);return{value:(r.dtype===t.dtype?t:t.cast(r.dtype)).div(r).sum(e,n),gradFunc:function(e){var n=t.shape.slice();return o.forEach(function(t){n[t]=1}),e.reshape(n).mul(Gn(t.shape,"float32")).div(a)}}})(r)}}),Iu=An({min_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","min"),o=r,a=N(e,r.shape),i=a,s=rn(i,r.rank);null!=s&&(r=r.transpose(s),i=an(i.length,r.rank));var u=Dt.runKernel(function(t,e){var n=t.min(r,i);return e([o,n]),n},{$x:r},function(t,e){return wu(t,e[1],e[0],a,s)});if(n){var l=en(u.shape,a);u=u.reshape(l)}return u}}),Au=An({moments_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=N(e,(t=wn(t,"x","moments")).shape),o=t.mean(r,n),a=o.shape;n||(a=en(o.shape,r));var i=t.toFloat().sub(o.reshape(a)).square();return{mean:o,variance:i.mean(r,n)}}}),Tu=An({sum_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","sum");"bool"===r.dtype&&(r=r.toInt());var o=N(e,r.shape);return kn(function(t){var e=rn(o,t.rank),r=o,a=t;null!=e&&(a=t.transpose(e),r=an(r.length,t.rank));var i=Dt.runKernel(function(t){return t.sum(a,r)},{permutedX:a});if(n){var s=en(i.shape,o);i=i.reshape(s)}return{value:i,gradFunc:function(e){var n=t.shape.slice();return o.forEach(function(t){n[t]=1}),e.reshape(n).mul(Gn(t.shape,"float32"))}}})(r)}}),Du=An({prod_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","prod");"bool"===r.dtype&&(r=r.toInt());var o=N(e,r.shape),a=rn(o,r.rank),i=o,s=r;null!=a&&(s=r.transpose(a),i=an(i.length,r.rank));var u=Dt.runKernel(function(t){return t.prod(s,i)},{permutedX:s});if(n){var l=en(u.shape,o);u=u.reshape(l)}return u}});var Ou=An({equal_:function(t,e){var n,r=wn(t,"a","equal"),o=wn(e,"b","equal");return n=Rt(r,o),r=n[0],o=n[1],so(r.shape,o.shape),Dt.runKernel(function(t){return t.equal(r,o)},{$a:r,$b:o})}}),_u=An({equalStrict_:function(t,e){var n=wn(t,"a","equalStrict"),r=wn(e,"b","equalStrict");return v(n.shape,r.shape,"Error in equalStrict: "),n.equal(r)}}),Mu=An({greater_:function(t,e){var n,r=wn(t,"a","greater"),o=wn(e,"b","greater");return n=Rt(r,o),r=n[0],o=n[1],so(r.shape,o.shape),Dt.runKernel(function(t){return t.greater(r,o)},{$a:r,$b:o})}}),Fu=An({greaterEqual_:function(t,e){var n,r=wn(t,"a","greaterEqual"),o=wn(e,"b","greaterEqual");return n=Rt(r,o),r=n[0],o=n[1],so(r.shape,o.shape),Dt.runKernel(function(t,e){var n=t.greaterEqual(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){return Xn(n)},$b:function(){return Xn(r)}}})}}),Bu=An({greaterEqualStrict_:function(t,e){var n=wn(t,"a","greaterEqualStrict"),r=wn(e,"b","greaterEqualStrict");return v(n.shape,r.shape,"Error in greaterEqualStrict: "),n.greaterEqual(r)}}),Pu=An({greaterStrict_:function(t,e){var n=wn(t,"a","greaterStrict"),r=wn(e,"b","greaterStrict");return v(n.shape,r.shape,"Error in greaterStrict: "),n.greater(r)}}),Lu=An({less_:function(t,e){var n,r=wn(t,"a","less"),o=wn(e,"b","less");return n=Rt(r,o),r=n[0],o=n[1],so(r.shape,o.shape),Dt.runKernel(function(t){return t.less(r,o)},{$a:r,$b:o})}}),Wu=An({lessEqual_:function(t,e){var n,r=wn(t,"a","lessEqual"),o=wn(e,"b","lessEqual");return n=Rt(r,o),r=n[0],o=n[1],so(r.shape,o.shape),Dt.runKernel(function(t){return t.lessEqual(r,o)},{$a:r,$b:o})}}),Uu=An({lessEqualStrict_:function(t,e){var n=wn(t,"a","lessEqualStrict"),r=wn(e,"b","lessEqualStrict");return v(n.shape,r.shape,"Error in lessEqualStrict: "),n.lessEqual(r)}}),zu=An({lessStrict_:function(t,e){var n=wn(t,"a","lessStrict"),r=wn(e,"b","lessStrict");return v(n.shape,r.shape,"Error in lessStrict: "),n.less(r)}}),Vu=An({notEqual_:function(t,e){var n,r=wn(t,"a","notEqual"),o=wn(e,"b","notEqual");return n=Rt(r,o),r=n[0],o=n[1],so(r.shape,o.shape),Dt.runKernel(function(t){return t.notEqual(r,o)},{$a:r,$b:o})}}),Gu=An({notEqualStrict_:function(t,e){var n=wn(t,"a","notEqualStrict"),r=wn(e,"b","notEqualStrict");return v(n.shape,r.shape,"Error in notEqualStrict: "),n.notEqual(r)}});var qu=An({add_:function(t,e){var n,r=wn(t,"a","add"),o=wn(e,"b","add");n=Rt(r,o),r=n[0],o=n[1];var a=so(r.shape,o.shape);return Dt.runKernel(function(t){return t.add(r,o)},{$a:r,$b:o},function(t){return{$a:function(){var e=t,n=io(r.shape,a);return n.length>0&&(e=e.sum(n)),e.reshape(r.shape)},$b:function(){var e=t,n=io(o.shape,a);return n.length>0&&(e=e.sum(n)),e.reshape(o.shape)}}})}}),Hu=An({addN_:function(t){d(Array.isArray(t),function(){return"The argument passed to tf.addN() must be a list of tensors"}),d(t.length>=1,function(){return"Must pass at least one tensor to tf.addN(), but got "+t.length});var e=t.map(function(t,e){return wn(t,"tensors"+e,"addN")}),n=e[0];e.forEach(function(t){if(t.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(function(t){if(!x(t.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});var r=e;return Dt.runKernel(function(t){return t.addN(e)},r,function(t){var n={};return e.forEach(function(e,r){n[r]=function(){return t.clone()}}),n})}}),$u=An({addStrict_:function(t,e){var n=wn(t,"a","addStrict"),r=wn(e,"b","addStrict");return v(n.shape,r.shape,"Error in addStrict: "),n.add(r)}}),ju=An({atan2_:function(t,e){var n,r=wn(t,"a","atan2"),o=wn(e,"b","atan2");n=Rt(r,o),r=n[0],o=n[1];var a=so(r.shape,o.shape);return Dt.runKernel(function(t,e){var n=t.atan2(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){var e=qu(n.square(),r.square()),o=t.mul(r.div(e)),i=io(n.shape,a);return i.length>0&&(o=o.sum(i)),o.reshape(n.shape)},$b:function(){var e=qu(n.square(),r.square()),o=is(t.mul(n.div(e))),i=io(r.shape,a);return i.length>0&&(o=o.sum(i)),o.reshape(r.shape)}}})}}),Ku=An({div_:function(t,e){var n,r=wn(t,"a","div"),o=wn(e,"b","div");if(n=Rt(r,o),r=n[0],o=n[1],"int32"===r.dtype&&"int32"===o.dtype)return Yu(r,o);var a=so(r.shape,o.shape);return Dt.runKernel(function(t,e){var n=t.realDivide(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){var e=t.div(r.toFloat()),o=io(n.shape,a);return o.length>0?e.sum(o).reshape(n.shape):e},$b:function(){var e=t.mul(n.toFloat()),o=io(r.shape,a);o.length>0&&(e=e.sum(o).reshape(r.shape));var i=r.square();return e.div(i.toFloat()).neg()}}})}}),Xu=An({divStrict_:function(t,e){var n=wn(t,"a","div"),r=wn(e,"b","div");return v(n.shape,r.shape,"Error in divideStrict: "),n.div(r)}}),Yu=An({floorDiv_:function(t,e){var n,r=wn(t,"a","floorDiv"),o=wn(e,"b","floorDiv");n=Rt(r,o),r=n[0],o=n[1];var a=so(r.shape,o.shape);return Dt.runKernel(function(t,e){var n=t.floorDiv(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){var e=t.div(r.toFloat()),o=io(n.shape,a);return o.length>0?e.sum(o).reshape(n.shape):e},$b:function(){var e=t.mul(n.toFloat()),o=io(r.shape,a);o.length>0&&(e=e.sum(o).reshape(r.shape));var i=r.square();return e.div(i.toFloat()).neg()}}})}}),Qu=An({maximum_:function(t,e){var n,r=wn(t,"a","maximum"),o=wn(e,"b","maximum");return n=Rt(r,o),r=n[0],o=n[1],"bool"===r.dtype&&(r=r.toInt(),o=o.toInt()),so(r.shape,o.shape),Dt.runKernel(function(t,e){var n=t.maximum(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){return t.mul(n.greaterEqual(r).toFloat())},$b:function(){return t.mul(n.less(r).toFloat())}}})}}),Ju=An({maximumStrict_:function(t,e){var n=wn(t,"a","maximumStrict"),r=wn(e,"b","maximumStrict");return v(n.shape,r.shape,"Error in maximumStrict: "),n.maximum(r)}}),Zu=An({minimum_:function(t,e){var n,r=wn(t,"a","minimum"),o=wn(e,"b","minimum");return n=Rt(r,o),r=n[0],o=n[1],"bool"===r.dtype&&(r=r.toInt(),o=o.toInt()),so(r.shape,o.shape),Dt.runKernel(function(t,e){var n=t.minimum(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){return t.mul(n.lessEqual(r).toFloat())},$b:function(){return t.mul(n.greater(r).toFloat())}}})}}),tl=An({minimumStrict_:function(t,e){var n=wn(t,"a","minimumStrict"),r=wn(e,"b","minimumStrict");return v(n.shape,r.shape,"Error in minimumStrict: "),n.minimum(r)}}),el=An({mod_:function(t,e){var n,r=wn(t,"a","mod"),o=wn(e,"b","mod");n=Rt(r,o),r=n[0],o=n[1];var a=so(r.shape,o.shape);return Dt.runKernel(function(t,e){var n=t.mod(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){var e=io(n.shape,a);return e.length>0?t.sum(e).reshape(n.shape):t},$b:function(){var e=t.mul(n.div(r).floor().neg()),o=io(r.shape,a);return o.length>0?e.sum(o).reshape(r.shape):e}}})}}),nl=An({modStrict_:function(t,e){var n=wn(t,"a","modStrict"),r=wn(e,"b","modStrict");return v(n.shape,r.shape,"Error in modStrict: "),n.mod(r)}}),rl=An({mul_:function(t,e){var n,r=wn(t,"a","mul"),o=wn(e,"b","mul");n=Rt(r,o),r=n[0],o=n[1];var a=so(r.shape,o.shape);return Dt.runKernel(function(t,e){var n=t.multiply(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){var e=t.mul(r.toFloat()),o=io(n.shape,a);return o.length>0?e.sum(o).reshape(n.shape):e},$b:function(){var e=t.mul(n.toFloat()),o=io(r.shape,a);return o.length>0?e.sum(o).reshape(r.shape):e}}})}}),ol=An({mulStrict_:function(t,e){var n=wn(t,"a","mul"),r=wn(e,"b","mul");return v(n.shape,r.shape,"Error in multiplyStrict: "),n.mul(r)}}),al=An({pow_:function(t,e){var n=wn(t,"base","pow"),r=wn(e,"exp","pow"),o=so(n.shape,r.shape);return t=n.cast(Ct(n.dtype,r.dtype)),e=r.cast(Ct(n.dtype,r.dtype)),Dt.runKernel(function(t,e){var o=t.pow(n,r);return e([n,r,o]),o},{$base:n,$exp:r},function(t,e){var n=e[0],r=e[1],a=e[2];return{$base:function(){var e=r.toFloat(),a=t.mul(e.mul(n.pow(e.sub(Bn(1))))),i=io(n.shape,o);return i.length>0&&(a=a.sum(i)),a.reshape(n.shape)},$exp:function(){var e=n.greater(0),i=n.log().where(e,Xn(n)),s=t.mul(a.mul(i)),u=io(r.shape,o);return u.length>0&&(s=s.sum(u)),s.reshape(r.shape)}}})}}),il=An({powStrict_:function(t,e){return v(t.shape,e.shape,"Error in powStrict: "),t.pow(e)}}),sl=An({squaredDifference_:function(t,e){var n,r=wn(t,"a","squaredDifference"),o=wn(e,"b","squaredDifference");return n=Rt(r,o),r=n[0],o=n[1],so(r.shape,o.shape),Dt.runKernel(function(t,e){var n=t.squaredDifference(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1],o=Bn(2);return{$a:function(){return t.mul(n.sub(r).mul(o))},$b:function(){return t.mul(r.sub(n).mul(o))}}})}}),ul=An({squaredDifferenceStrict_:function(t,e){var n=wn(t,"a","squaredDifferenceStrict"),r=wn(e,"b","squaredDifferenceStrict");return v(n.shape,r.shape,"Error in squaredDifferenceStrict: "),n.squaredDifference(r)}}),ll=An({sub_:function(t,e){var n,r=wn(t,"a","sub"),o=wn(e,"b","sub");n=Rt(r,o),r=n[0],o=n[1];var a=so(r.shape,o.shape);return Dt.runKernel(function(t){return t.subtract(r,o)},{$a:r,$b:o},function(t){return{$a:function(){var e=t,n=io(r.shape,a);return n.length>0&&(e=e.sum(n)),e.reshape(r.shape)},$b:function(){var e=t,n=io(o.shape,a);return n.length>0&&(e=e.sum(n)),e.neg().reshape(o.shape)}}})}}),cl=An({subStrict_:function(t,e){var n=wn(t,"a","subStrict"),r=wn(e,"b","subStrict");return v(n.shape,r.shape,"Error in subStrict: "),n.sub(r)}});var hl=An({logicalAnd_:function(t,e){var n=wn(t,"a","logicalAnd","bool"),r=wn(e,"b","logicalAnd","bool");return so(n.shape,r.shape),Dt.runKernel(function(t){return t.logicalAnd(n,r)},{$a:n,$b:r})}}),pl=An({logicalNot_:function(t){var e=wn(t,"x","logicalNot","bool");return Dt.runKernel(function(t){return t.logicalNot(e)},{$x:e})}}),fl=An({logicalOr_:function(t,e){var n=wn(t,"a","logicalOr","bool"),r=wn(e,"b","logicalOr","bool");return so(n.shape,r.shape),Dt.runKernel(function(t){return t.logicalOr(n,r)},{$a:n,$b:r})}}),dl=An({logicalXor_:function(t,e){var n=wn(t,"a","logicalXor","bool"),r=wn(e,"b","logicalXor","bool");return so(n.shape,r.shape),fl(t,e).logicalAnd(hl(t,e).logicalNot())}}),vl=An({where_:function(t,e,n){var r=wn(e,"a","where"),o=wn(n,"b","where"),a=wn(t,"condition","where","bool");return v(r.shape,o.shape,"Error in where: "),1===a.rank?d(a.shape[0]===r.shape[0],function(){return"The first dimension of `a` must match the size of `condition`."}):v(a.shape,o.shape,"Error in where: "),Dt.runKernel(function(t,e){var n=t.select(a,r,o);return e([a]),n},{$condition:a,$a:r,$b:o},function(t,e){var n=e[0];return{$condition:function(){return Xn(n).toFloat()},$a:function(){return t.mul(n.cast(t.dtype))},$b:function(){return t.mul(n.logicalNot().cast(t.dtype))}}})}}),ml=function(t){return r(this,void 0,void 0,function(){var e,n,r;return o(this,function(o){switch(o.label){case 0:return[4,(e=wn(t,"condition","whereAsync","bool")).data()];case 1:return n=o.sent(),r=Zr(e.shape,n),t!==e&&e.dispose(),[2,r]}})})};var gl=An({elu_:function(t){var e=wn(t,"x","elu");return Dt.runKernel(function(t,n){var r=t.elu(e);return n([r]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return Dt.runKernel(function(e){return e.eluDer(t,n)},{dy:t,y:n})}}})}}),yl=An({leakyRelu_:function(t,e){void 0===e&&(e=.2);var n=wn(t,"x","leakyRelu");return Qu(Bn(e).mul(n),n)}}),xl=An({prelu_:function(t,e){var n=wn(t,"x","prelu"),r=wn(e,"alpha","prelu");return Dt.runKernel(function(t,e){var o=t.prelu(n,r);return e([n,r]),o},{$x:n,$alpha:r},function(t,e){var n=e[0],r=e[1],o=n.greater(0);return{$x:function(){return vl(o,t,t.mul(r))},$alpha:function(){var e=vl(o,Xn(t),t.mul(n)),a=io(r.shape,t.shape);return a.length>0&&(e=e.sum(a)),e.reshape(r.shape)}}})}}),wl=An({relu_:function(t){var e=wn(t,"x","relu");return"bool"===e.dtype?e.toInt():Dt.runKernel(function(t,n){var r=t.relu(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mulStrict(n.step().toFloat())}}})}}),bl=An({selu_:function(t){var e=wn(t,"x","selu");return Dt.runKernel(function(t,n){var r=t.selu(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){var e=n.greater(Bn(0)),r=Bn(bi),o=Bn(Ci),a=t.mul(o),i=t.mul(r).mul(n.toFloat().exp());return vl(e,a,i)}}})}});var Cl=An({transpose_:function(t,e){var n=wn(t,"x","transpose");return null==e&&(e=n.shape.map(function(t,e){return e}).reverse()),d(n.rank===e.length,function(){return"Error in transpose: rank of input "+n.rank+" must match length of perm "+e+"."}),e.forEach(function(t){d(t>=0&&t<n.rank,function(){return"All entries in 'perm' must be between 0 and "+(n.rank-1)+" but got "+e})}),n.rank<=1?n.clone():Dt.runKernel(function(t){return t.transpose(n,e)},{$x:n},function(t){var n=on(e);return{$x:function(){return t.transpose(n)}}})}});var El=An({localResponseNormalization_:function(t,e,n,r,o){void 0===e&&(e=5),void 0===n&&(n=1),void 0===r&&(r=1),void 0===o&&(o=.5);var a=wn(t,"x","localResponseNormalization");d(4===a.rank||3===a.rank,function(){return"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank "+a.rank+"."}),d(w(e),function(){return"Error in localResponseNormalization: depthRadius must be an integer but got depthRadius "+e+"."});var i=a,s=!1;3===a.rank&&(s=!0,i=a.as4D(1,a.shape[0],a.shape[1],a.shape[2]));var u=Dt.runKernel(function(t,a){var s=t.localResponseNormalization4D(i,e,n,r,o);return a([i,s]),s},{x4D:i},function(t,a){var i=a[0],s=a[1];return{x4D:function(){return Dt.runKernel(function(a){return a.LRNGrad(t,i,s,e,n,r,o)},{})}}});return s?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}});var Rl=An({norm_:function(t,e,n,r){void 0===e&&(e="euclidean"),void 0===n&&(n=null),void 0===r&&(r=!1);var o=function t(e,n,r){if(void 0===r&&(r=null),0===e.rank)return e.abs();if(1!==e.rank&&null===r)return t(e.reshape([-1]),n,r);if(1===e.rank||"number"==typeof r||Array.isArray(r)&&1===r.length){if(1===n)return e.abs().sum(r);if(n===1/0)return e.abs().max(r);if(n===-1/0)return e.abs().min(r);if("euclidean"===n||2===n)return e.abs().pow(Bn(2,"int32")).sum(r).sqrt();throw new Error("Error in norm: invalid ord value: "+n)}if(Array.isArray(r)&&2===r.length){if(1===n)return e.abs().sum(r[0]).max(r[1]-1);if(n===1/0)return e.abs().sum(r[1]).max(r[0]);if(n===-1/0)return e.abs().sum(r[1]).min(r[0]);if("fro"===n||"euclidean"===n)return e.square().sum(r).sqrt();throw new Error("Error in norm: invalid ord value: "+n)}throw new Error("Error in norm: invalid axis: "+r)}(t=wn(t,"x","norm"),e,n),a=o.shape;if(r){var i=N(n,t.shape);a=en(o.shape,i)}return o.reshape(a)}});function Sl(t,e){for(var n=[],r=t;r<e;++r)n.push(r);return n}function Nl(t){for(var e=[],n=0;n<t.length;++n)for(var r=0;r<t[n].length;++r)e.push(t[n][r]);return e}var kl=An({gather_:function(t,e,n){void 0===n&&(n=0);var r=wn(t,"x","gather"),o=wn(e,"indices","gather","int32");n=N(n,r.shape)[0];var a=function(t,e,n){for(var r=t.shape[n],o=[],a=1,i=1,s=0;s<n;s++)o.push(t.shape[s]),a*=t.shape[s];for(s=0;s<e.rank;s++)o.push(e.shape[s]);for(s=n+1;s<t.rank;s++)o.push(t.shape[s]),i*=t.shape[s];return{batchSize:a,sliceSize:i,dimSize:r,outputShape:o}}(r,o,n);return Dt.runKernel(function(t,e){var a=t.gather(r,o.flatten(),n);return e([o]),a},{$x:r},function(t,e){var o=e[0];return{$x:function(){var e=r.shape,a=o.size,i=e.slice(0,n),s=i.length,u=e.slice(n,e.length).slice(1),l=u.length,c=Sl(0,s),h=Sl(s+1,s+1+l),p=Nl([i,[a],u]),f=t.reshape(p),d=o.reshape([a]),v=Nl([[s],c,h]),m=f.transpose(v),g=Il(m,d,r.shape[n]),y=on(v);return g=g.transpose(y)}}}).reshape(a.outputShape)}}),Il=An({unsortedSegmentSum_:function(t,e,n){var r=wn(t,"x","unsortedSegmentSum"),o=wn(e,"segmentIds","unsortedSegmentSum","int32");return d(w(n),function(){return"numSegments must be of dtype int"}),Dt.runKernel(function(t,e){var a=t.unsortedSegmentSum(r,o,n);return e([o]),a},{$x:r},function(t,e){var n=e[0];return{$x:function(){return function(t,e){for(var n=Qu(e,Xn(e)),r=kl(t,n),o=Fu(e,Bn(0,"int32")),a=r.rank-o.rank,i=0;i<a;++i)o=_r(o,i+1);o=hl(o,Gn(r.shape,"bool"));var s=Xn(r);return vl(o,r,s)}(t,n)}}})}});var Al=An({basicLSTMCell_:function(t,e,n,r,o,a){var i=wn(t,"forgetBias","basicLSTMCell"),s=wn(e,"lstmKernel","basicLSTMCell"),u=wn(n,"lstmBias","basicLSTMCell"),l=wn(r,"data","basicLSTMCell"),c=wn(o,"c","basicLSTMCell"),h=wn(a,"h","basicLSTMCell"),p=l.concat(h,1).matMul(s).add(u),f=p.shape[0],d=p.shape[1]/4,v=[f,d],m=p.slice([0,0],v),g=p.slice([0,d],v),y=p.slice([0,2*d],v),x=p.slice([0,3*d],v),w=m.sigmoid().mulStrict(g.tanh()).addStrict(c.mulStrict(i.add(y).sigmoid())),b=w.tanh().mulStrict(x.sigmoid());return[w,b]}}),Tl=An({multiRNNCell_:function(t,e,n,r){for(var o=wn(e,"data","multiRNNCell"),a=bn(n,"c","multiRNNCell"),i=bn(r,"h","multiRNNCell"),s=o,u=[],l=0;l<t.length;l++){var c=t[l](s,a[l],i[l]);u.push(c[0]),u.push(c[1]),s=c[1]}var h=[],p=[];for(l=0;l<u.length;l+=2)h.push(u[l]),p.push(u[l+1]);return[h,p]}});var Dl=An({movingAverage_:function(t,e,n,r,o){void 0===o&&(o=!0);var a=wn(t,"v","movingAverage"),i=wn(e,"x","movingAverage"),s=wn(n,"decay","movingAverage");St(a,i),d(x(a.shape,i.shape),function(){return"Shape mismatch in v and x"});var u=Bn(1),l=u.sub(s),c=i.sub(a).mul(l);if(o){d(null!=r,function(){return"When using zeroDebias: true, step is required."});var h=wn(r,"step","movingAverage");c=c.div(u.sub(al(s,h)))}return a.add(c)}});var Ol=An({stridedSlice_:function(t,e,n,r,o,a,i,s,u){if(void 0===o&&(o=0),void 0===a&&(a=0),void 0===i&&(i=0),void 0===s&&(s=0),void 0===u&&(u=0),0!==i)throw new Error("ellipsis mask is not yet supported");if(0!==s)throw new Error("new axis mask is not yet supported");var l=wn(t,"x","stridedSlice");if(r.every(function(t){return 1===t})){var c=fn(l.shape,e,n,r,o,a,i,s,u),h=c[0],p=c[1],f=c[2],d=p.filter(function(t,e){return-1===f.indexOf(e)});return vu(l,h,p).reshape(d)}return Dt.runKernel(function(t){return t.stridedSlice(l,e,n,r,o,a,i,s,u)},{$x:l})}});var _l=An({topk_:function(t,e,n){void 0===e&&(e=1),void 0===n&&(n=!0);var r=wn(t,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");var o=r.shape[r.shape.length-1];if(e>o)throw new Error("'k' passed to topk() must be <= the last dimension ("+o+") but got "+e);var a=Dt.runKernel(function(t){return t.topk(r,e,n)},{$x:r});return{values:a[0],indices:a[1]}}});var Ml=An({scatterND_:function(t,e,n){var r=wn(t,"indices","scatterND","int32"),o=wn(e,"updates","scatterND");return hn(o,r,n),Dt.runKernel(function(t){return t.scatterND(r,o,n)},{$indices:r,$updates:o})}});var Fl=An({fft_:function(t){d("complex64"===t.dtype,function(){return"The dtype for tf.spectral.fft() must be complex64 but got "+t.dtype+"."});var e=t.shape[t.shape.length-1],n=t.size/e,r=t.as2D(n,e);return Dt.runKernel(function(t){return t.fft(r)},{input:t}).reshape(t.shape)}}),Bl=An({ifft_:function(t){d("complex64"===t.dtype,function(){return"The dtype for tf.spectral.ifft() must be complex64 but got "+t.dtype+"."});var e=t.shape[t.shape.length-1],n=t.size/e,r=t.as2D(n,e);return Dt.runKernel(function(t){return t.ifft(r)},{input:t}).reshape(t.shape)}}),Pl=An({rfft_:function(t){d("float32"===t.dtype,function(){return"The dtype for rfft() must be real value but got "+t.dtype});var e=t.shape[t.shape.length-1],n=t.size/e,r=t.zerosLike(),o=On(t,r).as2D(n,e),a=Fl(o),i=Math.floor(e/2)+1,s=_n(a),u=Mn(a),l=s.split([i,e-i],s.shape.length-1),c=u.split([i,e-i],u.shape.length-1),h=t.shape.slice();return h[t.shape.length-1]=i,On(l[0],c[0]).reshape(h)}}),Ll=An({irfft_:function(t){var e=t.shape[t.shape.length-1],n=t.size/e;if(e<=2){var r=t.as2D(n,e),o=Bl(r);return _n(o)}var a=[n,2*(e-1)],i=_n(t).as2D(n,e),s=Mn(t).as2D(n,e),u=i.slice([0,1],[n,e-2]).reverse(1),l=s.slice([0,1],[n,e-2]).reverse(1).mul(Bn(-1)),c=i.concat(u,1),h=s.concat(l,1);return r=On(c,h).as2D(a[0],a[1]),o=Bl(r),_n(o)}}),Wl=Object.freeze({fft:Fl,ifft:Bl,rfft:Pl,irfft:Ll});var Ul=An({sparseToDense_:function(t,e,n,r){void 0===r&&(r=0);var o=wn(t,"sparseIndices","sparseToDense","int32"),a=wn(e,"sparseValues","sparseToDense"),i=wn(r,"defaultValue","sparseToDense",a.dtype);return function(t,e,n,r){if("int32"!==t.dtype)throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was "+t.dtype+".");if(t.rank>2)throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape "+t.shape+".");var o=t.rank>0?t.shape[0]:1,a=t.rank>1?t.shape[1]:1;if(n.length!==a)throw new Error("outputShape has incorrect number of elements:, "+n.length+", should be: "+a+".");var i=e.size;if(0!==e.rank&&(1!==e.rank||i!==o))throw new Error("sparseValues has incorrect shape "+e.shape+", should be [] or ["+o+"]");if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(o,a,n,i),Dt.runKernel(function(t){return t.sparseToDense(o,a,n,i)},{$sparseIndices:o,$sparseValues:a,$defaultValue:i})}});var zl=An({gatherND_:function(t,e){var n=wn(e,"indices","gatherND","int32"),r=wn(t,"x","gatherND");return Dt.runKernel(function(t){return t.gatherND(r,n)},{$x:r,$indices:n})}});var Vl=An({dropout_:function(t,e,n,r){if(null!=n&&!x(t.shape,n))throw new Error("Non-default noise shape is not implemented yet: "+JSON.stringify(n));var o=qr(t.shape,0,1,"float32",r).greater(e);return o=o.div(ll(1,e)),t.mul(o)}});function Gl(t,e,n){for(var r=1-t%2,o=new Float32Array(t),a=0;a<t;++a){var i=2*Math.PI*a/(t+r-1);o[a]=e-n*Math.cos(i)}return Pn(o,"float32")}var ql,Hl=An({hannWindow_:function(t){return Gl(t,.5,.5)}}),$l=An({hammingWindow_:function(t){return Gl(t,.54,.46)}});!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(ql||(ql={}));var jl=An({absoluteDifference_:function(t,e,n,r){void 0===r&&(r=ql.SUM_BY_NONZERO_WEIGHTS);var o=wn(t,"labels","absoluteDifference"),a=wn(e,"predictions","absoluteDifference"),i=null;null!=n&&(i=wn(n,"weights","absoluteDifference")),v(o.shape,a.shape,"Error in absoluteDifference: ");var s=o.sub(a).abs();return Kl(s,i,r)}}),Kl=An({computeWeightedLoss_:function(t,e,n){void 0===n&&(n=ql.SUM_BY_NONZERO_WEIGHTS);var r=wn(t,"losses","computeWeightedLoss"),o=null;null!=e&&(o=wn(e,"weights","computeWeightedLoss"));var a=null==o?r:r.mul(o);if(n===ql.NONE)return a;if(n===ql.SUM)return a.sum();if(n===ql.MEAN){if(null==o)return a.mean();var i=r.size/o.size,s=a.sum().div(o.sum());return i>1?s.div(Bn(i)):s}if(n===ql.SUM_BY_NONZERO_WEIGHTS){if(null==o)return a.sum().div(Bn(r.size));var u=o.mul(Gn(r.shape)).notEqual(Bn(0)).sum().toFloat();return a.sum().div(u)}throw Error("Unknown reduction: "+n)}}),Xl=An({cosineDistance_:function(t,e,n,r,o){void 0===o&&(o=ql.SUM_BY_NONZERO_WEIGHTS);var a=wn(t,"labels","cosineDistance"),i=wn(e,"predictions","cosineDistance"),s=null;null!=r&&(s=wn(r,"weights","cosineDistance")),v(a.shape,i.shape,"Error in cosineDistance: ");var u=Bn(1).sub(a.mul(i).sum(n,!0));return Kl(u,s,o)}}),Yl=An({hingeLoss_:function(t,e,n,r){void 0===r&&(r=ql.SUM_BY_NONZERO_WEIGHTS);var o=wn(t,"labels","hingeLoss"),a=wn(e,"predictions","hingeLoss"),i=null;null!=n&&(i=wn(n,"weights","hingeLoss")),v(o.shape,a.shape,"Error in hingeLoss: ");var s=Bn(1);o=Bn(2).mul(o).sub(s);var u=s.sub(o.mul(a)).relu();return Kl(u,i,r)}}),Ql=An({huberLoss_:function(t,e,n,r,o){void 0===r&&(r=1),void 0===o&&(o=ql.SUM_BY_NONZERO_WEIGHTS);var a=wn(t,"labels","huberLoss"),i=wn(e,"predictions","huberLoss"),s=null;null!=n&&(s=wn(n,"weights","huberLoss")),v(a.shape,i.shape,"Error in huberLoss: ");var u=Bn(r),l=i.sub(a).abs(),c=Zu(l,u),h=l.sub(c),p=Bn(.5).mul(c.square()).add(u.mul(h));return Kl(p,s,o)}}),Jl=An({logLoss_:function(t,e,n,r,o){void 0===r&&(r=1e-7),void 0===o&&(o=ql.SUM_BY_NONZERO_WEIGHTS);var a=wn(t,"labels","logLoss"),i=wn(e,"predictions","logLoss"),s=null;null!=n&&(s=wn(n,"weights","logLoss")),v(a.shape,i.shape,"Error in logLoss: ");var u=Bn(1),l=Bn(r),c=a.mul(i.add(l).log()).neg().sub(u.sub(a).mul(u.sub(i).add(l).log()));return Kl(c,s,o)}}),Zl=An({meanSquaredError_:function(t,e,n,r){void 0===r&&(r=ql.SUM_BY_NONZERO_WEIGHTS);var o=wn(t,"labels","meanSquaredError"),a=wn(e,"predictions","meanSquaredError"),i=null;null!=n&&(i=wn(n,"weights","meanSquaredError")),v(o.shape,a.shape,"Error in meanSquaredError: ");var s=o.squaredDifference(a);return Kl(s,i,r)}}),tc=An({sigmoidCrossEntropy_:function(t,e,n,r,o){void 0===r&&(r=0),void 0===o&&(o=ql.SUM_BY_NONZERO_WEIGHTS);var a=wn(t,"multiClassLabels","sigmoidCrossEntropy"),i=wn(e,"logits","sigmoidCrossEntropy"),s=null;if(null!=n&&(s=wn(n,"weights","sigmoidCrossEntropy")),v(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){var u=Bn(r),l=Bn(1),c=Bn(.5);a=a.mul(l.sub(u)).add(c.mul(u))}var h=function(t,e){var n=wn(t,"labels","sigmoidCrossEntropyWithLogits"),r=wn(e,"logits","sigmoidCrossEntropyWithLogits");v(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");var o=r.relu(),a=r.mul(n),i=r.abs().neg().exp().log1p();return o.sub(a).add(i)}(a,i);return Kl(h,s,o)}}),ec=An({softmaxCrossEntropy_:function(t,e,n,r,o){void 0===r&&(r=0),void 0===o&&(o=ql.SUM_BY_NONZERO_WEIGHTS);var a=wn(t,"onehotLabels","softmaxCrossEntropy"),i=wn(e,"logits","softmaxCrossEntropy"),s=null;if(null!=n&&(s=wn(n,"weights","softmaxCrossEntropy")),v(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){var u=Bn(r),l=Bn(1),c=Bn(a.shape[1]);a=a.mul(l.sub(u)).add(u.div(c))}var h=function(t,e,n){if(void 0===n&&(n=-1),-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank "+e.rank+" and dim was "+n);return kn(function(t,e,r){var o=e.logSumExp([n],!0),a=e.toFloat().sub(o);return r([t,a]),{value:a.mul(t).neg().sum([n]),gradFunc:function(t,e){var r=e[0],o=e[1],a=en(t.shape,[n]);return[t.reshape(a).mul(r.toFloat().sub(o.exp())),t.reshape(a).mul(o.exp().sub(r.toFloat()))]}}})(t,e)}(a,i);return Kl(h,s,o)}}),nc=Object.freeze({get Reduction(){return ql},absoluteDifference:jl,computeWeightedLoss:Kl,cosineDistance:Xl,hingeLoss:Yl,huberLoss:Ql,logLoss:Jl,meanSquaredError:Zl,sigmoidCrossEntropy:tc,softmaxCrossEntropy:ec});function rc(t,e){return void 0===e&&(e=!1),Dt.tidy(function(){if(2!==t.shape.length)throw new Error("qr2d() requires a 2D Tensor, but got a "+t.shape.length+"D Tensor.");for(var n=t.shape[0],r=t.shape[1],o=Mr(n),a=t.clone(),i=Ln([[1]],[1,1]),s=i.clone(),u=n>=r?r:n,l=function(t){var e,u=a,l=s,c=o;e=Dt.tidy(function(){var e=a.slice([t,t],[n-t,1]),u=e.norm(),l=a.slice([t,t],[1,1]),c=l.sign().neg(),h=l.sub(c.mul(u)),p=e.div(h);s=1===p.shape[0]?i.clone():i.concat(p.slice([1,0],[p.shape[0]-1,p.shape[1]]),0);var f=c.matMul(h).div(u).neg(),d=a.slice([t,0],[n-t,r]),v=f.mul(s);a=0===t?d.sub(v.matMul(s.transpose().matMul(d))):a.slice([0,0],[t,r]).concat(d.sub(v.matMul(s.transpose().matMul(d))),0);var m=o.slice([0,t],[n,o.shape[1]-t]);return o=0===t?m.sub(m.matMul(s).matMul(v.transpose())):o.slice([0,0],[n,t]).concat(m.sub(m.matMul(s).matMul(v.transpose())),1),[s,a,o]}),s=e[0],a=e[1],o=e[2],Be([u,l,c])},c=0;c<u;++c)l(c);return!e&&n>r&&(o=o.slice([0,0],[n,r]),a=a.slice([0,0],[r,r])),[o,a]})}var oc=An({gramSchmidt_:function(t){var e;if(Array.isArray(t)){e=!1,d(null!=t&&t.length>0,function(){return"Gram-Schmidt process: input must not be null, undefined, or empty"});for(var n=t[0].shape[0],r=function(e){d(t[e].shape[0]===n,function(){return"Gram-Schmidt: Non-unique lengths found in the input vectors: ("+t[e].shape[0]+" vs. "+n+")"})},o=1;o<t.length;++o)r(o)}else e=!0,t=dr(t,t.shape[0],0).map(function(t){return jr(t,[0])});d(t.length<=t[0].shape[0],function(){return"Gram-Schmidt: Number of vectors ("+t.length+") exceeds number of dimensions ("+t[0].shape[0]+")."});var a=[],i=t,s=function(t){a.push(Dt.tidy(function(){var e=i[t];if(t>0)for(var n=0;n<t;++n){var r=Tu(a[n].mulStrict(e)).mul(a[n]);e=e.sub(r)}return e.div(Rl(e,"euclidean"))}))};for(o=0;o<t.length;++o)s(o);return e?Kr(a,0):a}}),ac=An({qr_:function(t,e){if(void 0===e&&(e=!1),t.rank<2)throw new Error("qr() requires input tensor to have a rank >= 2, but got rank "+t.rank);if(2===t.rank)return rc(t,e);var n=t.shape.slice(0,t.shape.length-2).reduce(function(t,e){return t*e}),r=Qr(t.reshape([n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),o=[],a=[];return r.forEach(function(t){var n=rc(t,e),r=n[0],i=n[1];o.push(r),a.push(i)}),[Kr(o,0).reshape(t.shape),Kr(a,0).reshape(t.shape)]}}),ic=Object.freeze({gramSchmidt:oc,qr:ac});function sc(t,e,n,r,o){null==r&&(r=.5),null==o&&(o=Number.NEGATIVE_INFINITY);var a=t.shape[0];return n=Math.min(n,a),d(0<=r&&r<=1,function(){return"iouThreshold must be in [0, 1], but was '"+r+"'"}),d(2===t.rank,function(){return"boxes must be a 2D tensor, but was of rank '"+t.rank+"'"}),d(4===t.shape[1],function(){return"boxes must have 4 columns, but 2nd dimension was "+t.shape[1]}),d(1===e.rank,function(){return"scores must be a 1D tensor"}),d(e.shape[0]===a,function(){return"scores has incompatible shape with boxes. Expected "+a+", but was "+e.shape[0]}),{maxOutputSize:n,iouThreshold:r,scoreThreshold:o}}var uc=An({resizeBilinear_:function(t,e,n){void 0===n&&(n=!1);var r=wn(t,"images","resizeBilinear");d(3===r.rank||4===r.rank,function(){return"Error in resizeBilinear: x must be rank 3 or 4, but got rank "+r.rank+"."}),d(2===e.length,function(){return"Error in resizeBilinear: new shape must 2D, but got shape "+e+"."});var o=r,a=!1;3===r.rank&&(a=!0,o=r.as4D(1,r.shape[0],r.shape[1],r.shape[2]));var i=e[0],s=e[1],u=Dt.runKernel(function(t,e){return e([o]),t.resizeBilinear(o,i,s,n)},{batchImages:o},function(t,e){return{batchImages:function(){return Dt.runKernel(function(r){return r.resizeBilinearBackprop(t,e[0],n)},{})}}});return a?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}}),lc=An({resizeNearestNeighbor_:function(t,e,n){void 0===n&&(n=!1);var r=wn(t,"images","resizeNearestNeighbor");d(3===r.rank||4===r.rank,function(){return"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank "+r.rank+"."}),d(2===e.length,function(){return"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+e+"."}),d("float32"===r.dtype||"int32"===r.dtype,function(){return"`images` must have `int32` or `float32` as dtype"});var o=r,a=!1;3===r.rank&&(a=!0,o=r.as4D(1,r.shape[0],r.shape[1],r.shape[2]));var i=e[0],s=e[1],u=Dt.runKernel(function(t,e){return e([o]),t.resizeNearestNeighbor(o,i,s,n)},{batchImages:o},function(t,e){return{batchImages:function(){return Dt.runKernel(function(r){return r.resizeNearestNeighborBackprop(t,e[0],n)},{})}}});return a?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}}),cc=An({nonMaxSuppression_:function(t,e,n,r,o){void 0===r&&(r=.5),void 0===o&&(o=Number.NEGATIVE_INFINITY);var a=wn(t,"boxes","nonMaxSuppression"),i=wn(e,"scores","nonMaxSuppression"),s=sc(a,i,n,r,o);return n=s.maxOutputSize,r=s.iouThreshold,o=s.scoreThreshold,Dt.runKernel(function(t){return t.nonMaxSuppression(a,i,n,r,o)},{$boxes:a})}}),hc=function(t,e,n,a,i){return void 0===a&&(a=.5),void 0===i&&(i=Number.NEGATIVE_INFINITY),r(this,void 0,void 0,function(){var r,s,u,l,c,h;return o(this,function(o){switch(o.label){case 0:return r=wn(t,"boxes","nonMaxSuppressionAsync"),s=wn(e,"scores","nonMaxSuppressionAsync"),u=sc(r,s,n,a,i),n=u.maxOutputSize,a=u.iouThreshold,i=u.scoreThreshold,[4,r.data()];case 1:return l=o.sent(),[4,s.data()];case 2:return c=o.sent(),h=ar(l,c,n,a,i),r!==t&&r.dispose(),s!==e&&s.dispose(),[2,h]}})})},pc=An({cropAndResize_:function(t,e,n,r,o,a){var i=wn(t,"image","cropAndResize","float32"),s=wn(e,"boxes","cropAndResize","float32"),u=wn(n,"boxInd","cropAndResize","int32");o=o||"bilinear",a=a||0;var l=s.shape[0];return d(4===i.rank,function(){return"Error in cropAndResize: image must be rank 4,but got rank "+i.rank+"."}),d(2===s.rank&&4===s.shape[1],function(){return"Error in cropAndResize: boxes must be have size ["+l+",4] but had shape "+s.shape+"."}),d(1===u.rank&&u.shape[0]===l,function(){return"Error in cropAndResize: boxInd must be have size ["+l+"] but had shape "+s.shape+"."}),d(2===r.length,function(){return"Error in cropAndResize: cropSize must be of length 2, but got length "+r.length+"."}),d(r[0]>=1&&r[1]>=1,function(){return"cropSize must be atleast [1,1], but was "+r}),d("bilinear"===o||"nearest"===o,function(){return"method must be bilinear or nearest, but was "+o}),Dt.runKernel(function(t,e){return t.cropAndResize(i,s,u,r,o,a)},{$image:i,$boxes:s})}}),fc=Object.freeze({resizeBilinear:uc,resizeNearestNeighbor:lc,nonMaxSuppression:cc,nonMaxSuppressionAsync:hc,cropAndResize:pc});var dc=An({matMul_:function(t,e,n,r,o,a){var i;void 0===n&&(n=!1),void 0===r&&(r=!1),void 0===a&&(a="linear");var s=wn(t,"a","fused matMul"),u=wn(e,"b","fused matMul");i=Rt(s,u),s=i[0],u=i[1];var l=n?s.shape[s.rank-2]:s.shape[s.rank-1],c=r?u.shape[u.rank-1]:u.shape[u.rank-2],h=n?s.shape[s.rank-1]:s.shape[s.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=s.shape.slice(0,-2),v=u.shape.slice(0,-2),m=y(f),g=y(v);d(s.rank>=2&&u.rank>=2&&s.rank===u.rank,function(){return"Error in fused matMul: inputs must have the same rank of at least 2, got ranks "+s.rank+" and "+u.rank+"."}),d(x(f,v),function(){return"Error in fused matMul: outer dimensions ("+f+") and ("+v+") of Tensors with shapes "+s.shape+" and "+u.shape+" must match."}),d(l===c,function(){return"Error in fused matMul: inner shapes ("+l+") and ("+c+") of Tensors with shapes "+s.shape+" and "+u.shape+" and transposeA="+n+" and transposeB="+r+" must match."});var w,b=s.shape.slice(0,-2).concat([h,p]),C=n?s.as3D(m,l,h):s.as3D(m,h,l),E=r?u.as3D(g,p,c):u.as3D(g,c,p);null!=o&&so(b,(w=Rt(w=wn(o,"bias","fused matMul"),s)[0]).shape);var R={$a:C,$b:E};return null!=o&&(R.$bias=w),Dt.runKernel(function(t,e){var o=t.fusedBatchMatMul(C,E,n,r,w,a);return e([C,E,o]),o},R,function(t,e){var i,s=e[0],u=e[1],l=e[2];if(null==a||"linear"===a)i=t;else{if("relu"!==a)throw new Error("Gradient for activation "+a+" has not been implemented yet.");i=t.mul(l.step())}var c={};return null!=o&&(c={$bias:function(){var t=i,e=io(w.shape,i.shape);return e.length>0&&(t=t.sum(e)),t.reshape(w.shape)}}),n||r?!n&&r?Object.assign({$a:function(){return i.matMul(u,!1,!1)},$b:function(){return i.matMul(s,!0,!1)}},c):n&&!r?Object.assign({$a:function(){return u.matMul(i,!1,!0)},$b:function(){return s.matMul(i,!1,!1)}},c):Object.assign({$a:function(){return u.matMul(i,!0,!0)},$b:function(){return i.matMul(s,!0,!0)}},c):Object.assign({$a:function(){return i.matMul(u,!1,!0)},$b:function(){return s.matMul(i,!0,!1)}},c)}).reshape(b)}}),vc=Object.freeze({matMul:dc}),mc=Object.freeze({image:fc,linalg:ic,losses:nc,spectral:Wl,fused:vc,op:An,batchNormalization2d:As,batchNormalization3d:Ts,batchNormalization4d:Ds,batchNormalization:Os,batchNorm:_s,batchNorm2d:Ms,batchNorm3d:Fs,batchNorm4d:Bs,complex:On,real:_n,imag:Mn,concat:lr,concat1d:cr,concat2d:hr,concat3d:pr,concat4d:fr,split:dr,conv1d:Xs,conv2d:Ys,conv3d:Qs,conv2dDerFilter:Js,depthwiseConv2d:Zs,separableConv2d:tu,conv2dTranspose:eu,matMul:nu,dot:ru,outerProduct:ou,reverse:au,reverse1d:iu,reverse2d:su,reverse3d:uu,reverse4d:lu,maxPool:pu,avgPool:fu,pool:du,slice:vu,slice1d:mu,slice2d:gu,slice3d:yu,slice4d:xu,abs:Vi,acos:Gi,acosh:qi,asin:Hi,asinh:$i,atan:ji,atanh:Ki,ceil:Xi,clipByValue:Yi,cos:Qi,cosh:Ji,erf:Zi,exp:ts,expm1:es,floor:ns,log:rs,log1p:os,logSigmoid:as,neg:is,reciprocal:ss,round:us,rsqrt:ls,sigmoid:cs,sign:hs,isNaN:ps,isInf:fs,isFinite:ds,sin:vs,sinh:ms,softplus:gs,sqrt:ys,square:xs,step:ws,tan:bs,tanh:Cs,all:bu,any:Cu,argMax:Eu,argMin:Ru,logSumExp:Su,max:Nu,mean:ku,min:Iu,moments:Au,sum:Tu,prod:Du,equal:Ou,equalStrict:_u,greater:Mu,greaterEqual:Fu,greaterEqualStrict:Bu,greaterStrict:Pu,less:Lu,lessEqual:Wu,lessEqualStrict:Uu,lessStrict:zu,notEqual:Vu,notEqualStrict:Gu,add:qu,addN:Hu,addStrict:$u,atan2:ju,div:Ku,divStrict:Xu,floorDiv:Yu,maximum:Qu,maximumStrict:Ju,minimum:Zu,minimumStrict:tl,mod:el,modStrict:nl,mul:rl,mulStrict:ol,pow:al,powStrict:il,squaredDifference:sl,squaredDifferenceStrict:ul,sub:ll,subStrict:cl,elu:gl,leakyRelu:yl,prelu:xl,relu:wl,selu:bl,logicalAnd:hl,logicalNot:pl,logicalOr:fl,logicalXor:dl,where:vl,whereAsync:ml,buffer:Nr,print:kr,batchToSpaceND:Ir,cast:Ar,clone:Tr,cumsum:Dr,depthToSpace:Or,expandDims:_r,eye:Mr,multinomial:Fr,oneHot:Br,pad:Pr,pad1d:Lr,pad2d:Wr,pad3d:Ur,pad4d:zr,rand:Vr,randomNormal:Gr,randomUniform:qr,reshape:Hr,spaceToBatchND:$r,squeeze:jr,stack:Kr,tile:Xr,truncatedNormal:Yr,unstack:Qr,setdiff1dAsync:Jr,fill:Hn,linspace:$n,ones:Gn,range:jn,scalar:Bn,tensor:Fn,tensor1d:Pn,tensor2d:Ln,tensor3d:Wn,tensor4d:Un,tensor5d:zn,tensor6d:Vn,zeros:qn,onesLike:Kn,zerosLike:Xn,transpose:Cl,softmax:Tn,logSoftmax:Dn,localResponseNormalization:El,norm:Rl,gather:kl,unsortedSegmentSum:Il,basicLSTMCell:Al,multiRNNCell:Tl,movingAverage:Dl,stridedSlice:Ol,topk:_l,scatterND:Ml,fft:Fl,ifft:Bl,rfft:Pl,irfft:Ll,sparseToDense:Ul,gatherND:zl,dropout:Vl,hannWindow:Hl,hammingWindow:$l});var gc=function(){function t(){this.blockSize=48,this.firstUse=!0,a.get("IS_BROWSER")&&(this.fromPixels2DContext=document.createElement("canvas").getContext("2d")),this.data=new Yn(Dt)}return t.prototype.register=function(t,e,n){if(this.firstUse&&(this.firstUse=!1,a.get("IS_NODE")&&je("\n============================\nHi there 👋. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================\n")),this.data.has(t))throw new Error("Data buffer is already registered");this.data.set(t,{dtype:n})},t.prototype.write=function(t,e){if(null==e)throw new Error("MathBackendCPU.write(): values can not be null");this.data.get(t).values=e},t.prototype.fromPixels=function(t,e){if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");var n,r;if(a.get("IS_NODE")&&null==t.getContext)throw new Error("When running in node, pixels must be an HTMLCanvasElement like the one returned by the `canvas` npm package");if(null!=t.getContext)n=t.getContext("2d").getImageData(0,0,t.width,t.height).data;else if(t instanceof ImageData)n=t.data;else{if(!(t instanceof HTMLImageElement||t instanceof HTMLVideoElement))throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or ImageData, but was "+t.constructor.name);if(null==this.fromPixels2DContext)throw new Error("Can't read pixels from HTMLImageElement outside the browser.");this.fromPixels2DContext.canvas.width=t.width,this.fromPixels2DContext.canvas.height=t.height,this.fromPixels2DContext.drawImage(t,0,0,t.width,t.height),n=this.fromPixels2DContext.getImageData(0,0,t.width,t.height).data}if(4===e)r=new Int32Array(n);else{var o=t.width*t.height;r=new Int32Array(o*e);for(var i=0;i<o;i++)for(var s=0;s<e;++s)r[i*e+s]=n[4*i+s]}return Wn(r,[t.height,t.width,e],"int32")},t.prototype.read=function(t){return r(this,void 0,void 0,function(){return o(this,function(e){return[2,this.readSync(t)]})})},t.prototype.readSync=function(t){var e=this.data.get(t),n=e.dtype,r=e.complexTensors;return"complex64"===n?er(r.real.dataSync(),r.imag.dataSync()):this.data.get(t).values},t.prototype.disposeData=function(t){if(this.data.has(t)){var e=this.data.get(t).complexTensors;null!=e&&(e.real.dispose(),e.imag.dispose()),this.data.delete(t)}},t.prototype.time=function(t){return r(this,void 0,void 0,function(){var e;return o(this,function(n){return e=j(),t(),[2,{kernelMs:j()-e}]})})},t.prototype.memory=function(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}},t.prototype.complex=function(t,e){var n=ft.make(t.shape,{},"complex64");return this.data.get(n.dataId).complexTensors={real:Dt.keep(t.clone()),imag:Dt.keep(e.clone())},n},t.prototype.real=function(t){return this.data.get(t.dataId).complexTensors.real.clone()},t.prototype.imag=function(t){return this.data.get(t.dataId).complexTensors.imag.clone()},t.prototype.assertNotComplex=function(t,e){Array.isArray(t)||(t=[t]),t.forEach(function(t){null!=t&&d("complex64"!==t.dtype,function(){return e+" does not support complex64 tensors."})})},t.prototype.slice=function(t,e,n){if(this.assertNotComplex(t,"slice"),mn(t.shape,e,n)){var r=gn(e,t.strides),o=y(n);return Fn(t.dataSync().subarray(r,r+o),n,t.dtype)}for(var a=Nr(n,t.dtype),i=t.bufferSync(),s=0;s<a.size;++s){var u=a.indexToLoc(s).map(function(t,n){return t+e[n]});a.values[s]=i.get.apply(i,u)}return a.toTensor()},t.prototype.stridedSlice=function(t,e,n,r,o,a,i,s,u){this.assertNotComplex(t,"stridedSlice");var l=fn(t.shape,e,n,r,o,a,i,s,u),c=l[0],h=l[1],p=l[2],f=h.filter(function(t,e){return-1===p.indexOf(e)});if(f.some(function(t){return 0===t}))return Fn([],f);for(var d=Nr(h,t.dtype),v=t.bufferSync(),m=0;m<d.size;m++){for(var g=d.indexToLoc(m),y=new Array(g.length),x=0;x<y.length;x++)y[x]=g[x]*r[x]+c[x];d.set.apply(d,[v.get.apply(v,y)].concat(g))}return d.toTensor().reshape(f)},t.prototype.unstack=function(t,e){for(var n=t.shape[e],r=new Array(t.rank-1),o=0,a=0;a<t.rank;a++)a!==e&&(r[o++]=t.shape[a]);var i=new Array(t.rank).fill(0),s=t.shape.slice();s[e]=1;var u=new Array(n);for(a=0;a<u.length;a++)i[e]=a,u[a]=this.slice(t,i,s).reshape(r);return u},t.prototype.reverse=function(t,e){this.assertNotComplex(t,"reverse");for(var n=Nr(t.shape,t.dtype),r=t.bufferSync(),o=function(o){var a=n.indexToLoc(o),i=a.slice();e.forEach(function(e){return i[e]=t.shape[e]-1-i[e]}),n.set.apply(n,[r.get.apply(r,i)].concat(a))},a=0;a<n.size;a++)o(a);return n.toTensor()},t.prototype.concat=function(t,e){this.assertNotComplex(t,"concat");var n=t.map(function(t){var n=y(t.shape.slice(e));return t.as2D(-1,n)}),r=sn(n.map(function(t){return t.shape}),1),o=Nr(r,t[0].dtype).values;if(1===n[0].shape[0]){var a=0;n.forEach(function(t){o.set(t.dataSync(),a),a+=t.size})}else{var i=0;n.forEach(function(t){for(var e=t.dataSync(),n=0,a=0;a<t.shape[0];++a)for(var s=a*r[1]+i,u=0;u<t.shape[1];++u)o[s+u]=e[n++];i+=t.shape[1]})}var s=sn(t.map(function(t){return t.shape}),e);return Fn(o,s,t[0].dtype)},t.prototype.neg=function(t){return this.assertNotComplex(t,"neg"),this.multiply(Bn(-1),t)},t.prototype.add=function(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),function(t,e,n,r){return{real:t+n,imag:e+r}}):this.broadcastedBinaryOp(t,e,Ct(t.dtype,e.dtype),function(t,e){return t+e})},t.prototype.addN=function(t){this.assertNotComplex(t,"addN");for(var e=t.map(function(t){return t.dataSync()}),n=Nr(t[0].shape,t[0].dtype),r=n.values,o=0;o<t.length;o++)for(var a=e[o],i=0;i<r.length;i++)r[i]+=a[i];return n.toTensor()},t.prototype.subtract=function(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),function(t,e,n,r){return{real:t-n,imag:e-r}}):this.broadcastedBinaryOp(t,e,Ct(t.dtype,e.dtype),function(t,e){return t-e})},t.prototype.pow=function(t,e){return this.assertNotComplex([t,e],"pow"),this.broadcastedBinaryOp(t,e,t.dtype,function(t,e){return Math.pow(t,e)})},t.prototype.batchMatMul=function(t,e,n,r){this.assertNotComplex([t,e],"matMul");for(var o=n?t.shape[1]:t.shape[2],a=n?t.shape[2]:t.shape[1],i=r?e.shape[1]:e.shape[2],s=t.shape[0],u=t.dataSync(),l=e.dataSync(),c=n?[t.strides[0],1,t.strides[1]]:[t.strides[0],t.strides[1],1],h=c[0],p=c[1],f=c[2],d=r?[1,e.strides[1],e.strides[0]]:[e.strides[1],1,e.strides[0]],v=d[0],m=d[1],g=d[2],y=a*i,x=Nr([s,a,i],t.dtype),w=x.values,b=this.blockSize,C=0;C<s;C++)for(var E=0;E<a;E+=b)for(var R=0;R<i;R+=b)for(var S=0;S<o;S+=b)for(var N=Math.min(E+b,a),k=Math.min(R+b,i),I=Math.min(S+b,o),A=E;A<N;A++)for(var T=R;T<k;T++){for(var D=0,O=S;O<I;O++)D+=u[C*h+A*p+O*f]*l[O*v+T*m+C*g];w[C*y+(A*i+T)]+=D}return x.toTensor()},t.prototype.fusedBatchMatMul=function(t,e,n,r,o,a){var i=this.batchMatMul(t,e,n,r);return o&&(i=this.add(i,o)),a&&(i=function(t,e,n){if("linear"===e)return t.linear(n);if("relu"===e)return t.relu(n);throw new Error("Activation "+e+" has not been implemented for the CPU backend.")}(this,a,i)),i},t.prototype.multiply=function(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),function(t,e,n,r){return{real:t*n-e*r,imag:t*r+e*n}}):this.broadcastedBinaryOp(t,e,Ct(t.dtype,e.dtype),function(t,e){return t*e})},t.prototype.realDivide=function(t,e){this.assertNotComplex([t,e],"realDivide");return this.broadcastedBinaryOp(t,e,"float32",function(t,e){return t/e})},t.prototype.floorDiv=function(t,e){this.assertNotComplex([t,e],"floorDiv");return this.broadcastedBinaryOp(t,e,"int32",function(t,e){return Math.floor(t/e)})},t.prototype.sum=function(t,e){this.assertNotComplex(t,"sum"),nn("sum",e,t.rank);for(var n=tn(t.shape,e),r=n[0],o=n[1],a=qn(r,Ct(t.dtype,"int32")),i=y(o),s=a.dataSync(),u=t.dataSync(),l=0;l<s.length;++l){for(var c=l*i,h=0,p=0;p<i;++p)h+=u[c+p];s[l]=h}return a},t.prototype.prod=function(t,e){this.assertNotComplex(t,"sum");for(var n=tn(t.shape,e),r=n[0],o=n[1],a=qn(r,Ct(t.dtype,"int32")),i=y(o),s=a.dataSync(),u=t.dataSync(),l=0;l<s.length;++l){for(var c=l*i,h=1,p=0;p<i;++p)h*=u[c+p];s[l]=h}return a},t.prototype.unsortedSegmentSum=function(t,e,n){this.assertNotComplex(t,"unsortedSegmentSum");for(var r=[],o=t.rank-e.rank,a=0;a<o;++a)e=e.expandDims(a+1);for(a=0;a<n;++a){var i=Bn(a,"int32"),s=Ou(i,e).asType("float32").mul(t).sum(0);r.push(s)}return Kr(r)},t.prototype.argMin=function(t,e){this.assertNotComplex(t,"argMin");var n=[e];nn("argMin",n,t.rank);for(var r=tn(t.shape,n),o=r[0],a=r[1],i=qn(o,"int32"),s=y(a),u=i.dataSync(),l=t.dataSync(),c=0;c<u.length;++c){for(var h=c*s,p=l[h],f=0,d=0;d<s;++d){var v=l[h+d];v<p&&(p=v,f=d)}u[c]=f}return i},t.prototype.argMax=function(t,e){this.assertNotComplex(t,"argMax");var n=[e];nn("argMax",n,t.rank);for(var r=tn(t.shape,n),o=r[0],a=r[1],i=qn(o,"int32"),s=y(a),u=i.dataSync(),l=t.dataSync(),c=0;c<u.length;++c){for(var h=c*s,p=l[h],f=0,d=0;d<s;++d){var v=l[h+d];v>p&&(p=v,f=d)}u[c]=f}return i},t.prototype.cumsum=function(t,e,n,r){if(this.assertNotComplex(t,"cumsum"),e!==t.rank-1)throw new Error("backend.cumsum in CPU expects an inner-most axis="+(t.rank-1)+" but got axis="+e);for(var o=Ct(t.dtype,"int32"),a=qn(t.shape,o),i=a.dataSync(),s=t.dataSync(),u=t.shape[t.rank-1],l=r?function(t,e){return t+u-e-1}:function(t,e){return t+e},c=0;c<s.length;c+=u)for(var h=0;h<u;h++){var p=l(c,h);if(0===h)i[p]=n?0:s[p];else{var f=l(c,h-1);i[p]=n?s[f]+i[f]:s[p]+i[f]}}return a},t.prototype.equal=function(t,e){return this.assertNotComplex([t,e],"equal"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t===e?1:0})},t.prototype.notEqual=function(t,e){return this.assertNotComplex([t,e],"notEqual"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t!==e?1:0})},t.prototype.less=function(t,e){return this.assertNotComplex([t,e],"less"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t<e?1:0})},t.prototype.lessEqual=function(t,e){return this.assertNotComplex([t,e],"lessEqual"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t<=e?1:0})},t.prototype.greater=function(t,e){return this.assertNotComplex([t,e],"greater"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t>e?1:0})},t.prototype.greaterEqual=function(t,e){return this.assertNotComplex([t,e],"greaterEqual"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t>=e?1:0})},t.prototype.logicalNot=function(t){this.assertNotComplex(t,"logicalNot");for(var e=t.dataSync(),n=new Uint8Array(e.length),r=0;r<e.length;++r)n[r]=e[r]?0:1;return ft.make(t.shape,{values:n},"bool")},t.prototype.logicalAnd=function(t,e){return this.assertNotComplex([t,e],"logicalAnd"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t&&e})},t.prototype.logicalOr=function(t,e){return this.assertNotComplex([t,e],"logicalOr"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t||e})},t.prototype.select=function(t,e,n){this.assertNotComplex([t,e,n],"select");for(var r=t.dataSync(),o=e.dataSync(),a=n.dataSync(),i=qn(e.shape,Ct(e.dtype,n.dtype)),s=i.dataSync(),u=0,l=0===t.rank||t.rank>1||1===e.rank?1:e.shape[1],c=0;c<r.length;c++)for(var h=0;h<l;h++)1===r[c]?s[u++]=o[c]:s[u++]=a[c];return i},t.prototype.where=function(t){this.assertNotComplex([t],"where");var e=t.dataSync();return Zr(t.shape,e)},t.prototype.topk=function(t,e,n){return this.assertNotComplex(t,"topk"),ur(t.dataSync(),t.shape,t.dtype,e)},t.prototype.min=function(t,e){this.assertNotComplex(t,"min"),nn("min",e,t.rank);for(var n=tn(t.shape,e),r=n[0],o=n[1],a=qn(r,t.dtype),i=y(o),s=a.dataSync(),u=t.dataSync(),l=0;l<s.length;++l){for(var c=l*i,h=u[c],p=0;p<i;++p){var f=u[c+p];f<h&&(h=f)}s[l]=h}return a},t.prototype.minimum=function(t,e){return this.assertNotComplex([t,e],"minimum"),this.broadcastedBinaryOp(t,e,t.dtype,function(t,e){return Math.min(t,e)})},t.prototype.mod=function(t,e){return this.assertNotComplex([t,e],"mod"),this.broadcastedBinaryOp(t,e,t.dtype,function(t,e){var n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e})},t.prototype.max=function(t,e){this.assertNotComplex(t,"max"),nn("max",e,t.rank);for(var n=tn(t.shape,e),r=n[0],o=n[1],a=qn(r,t.dtype),i=y(o),s=a.dataSync(),u=t.dataSync(),l=0;l<s.length;++l){for(var c=l*i,h=u[c],p=0;p<i;++p){var f=u[c+p];f>h&&(h=f)}s[l]=h}return a},t.prototype.maximum=function(t,e){return this.assertNotComplex([t,e],"maximum"),this.broadcastedBinaryOp(t,e,t.dtype,function(t,e){return Math.max(t,e)})},t.prototype.all=function(t,e){this.assertNotComplex(t,"all"),nn("all",e,t.rank);for(var n=tn(t.shape,e),r=n[0],o=n[1],a=qn(r,t.dtype),i=y(o),s=a.dataSync(),u=t.dataSync(),l=0;l<s.length;++l){for(var c=l*i,h=u[c],p=0;p<i;++p){var f=u[c+p];h=h&&f}s[l]=h}return a},t.prototype.any=function(t,e){this.assertNotComplex(t,"any"),nn("any",e,t.rank);for(var n=tn(t.shape,e),r=n[0],o=n[1],a=qn(r,t.dtype),i=y(o),s=a.dataSync(),u=t.dataSync(),l=0;l<s.length;++l){for(var c=l*i,h=u[c],p=0;p<i;++p){var f=u[c+p];h=h||f}s[l]=h}return a},t.prototype.squaredDifference=function(t,e){return this.assertNotComplex([t,e],"squaredDifference"),this.broadcastedBinaryOp(t,e,t.dtype,function(t,e){var n=t-e;return n*n})},t.prototype.ceil=function(t){this.assertNotComplex(t,"ceil");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=Math.ceil(e[r]);return ft.make(t.shape,{values:n})},t.prototype.floor=function(t){this.assertNotComplex(t,"floor");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=Math.floor(e[r]);return ft.make(t.shape,{values:n})},t.prototype.sign=function(t){this.assertNotComplex(t,"x");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r)e[r]<0?n[r]=-1:e[r]>0?n[r]=1:n[r]=0;return ft.make(t.shape,{values:n})},t.prototype.isNaN=function(t){this.assertNotComplex(t,"x");for(var e=t.dataSync(),n=new Uint8Array(e.length),r=0;r<e.length;++r)Number.isNaN(e[r])&&(n[r]=1);return ft.make(t.shape,{values:n},"bool")},t.prototype.isInf=function(t){this.assertNotComplex(t,"x");for(var e=t.dataSync(),n=new Uint8Array(e.length),r=0;r<e.length;++r)Math.abs(e[r])===1/0&&(n[r]=1);return ft.make(t.shape,{values:n},"bool")},t.prototype.isFinite=function(t){this.assertNotComplex(t,"x");for(var e=t.dataSync(),n=new Uint8Array(e.length),r=0;r<e.length;++r)Number.isFinite(e[r])&&(n[r]=1);return ft.make(t.shape,{values:n},"bool")},t.prototype.round=function(t){this.assertNotComplex(t,"round");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=Math.floor(e[r]);e[r]-o<.5?n[r]=Math.floor(e[r]):e[r]-o>.5?n[r]=Math.ceil(e[r]):n[r]=o%2==0?o:o+1}return ft.make(t.shape,{values:n})},t.prototype.exp=function(t){this.assertNotComplex(t,"exp");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=Math.exp(e[r]);return ft.make(t.shape,{values:n})},t.prototype.expm1=function(t){this.assertNotComplex(t,"expm1");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=Math.expm1(e[r]);return ft.make(t.shape,{values:n})},t.prototype.log=function(t){this.assertNotComplex(t,"log");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=Math.log(o)}return ft.make(t.shape,{values:n})},t.prototype.log1p=function(t){this.assertNotComplex(t,"log1p");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=Math.log1p(o)}return ft.make(t.shape,{values:n})},t.prototype.sqrt=function(t){this.assertNotComplex(t,"sqrt");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=Math.sqrt(o)}return ft.make(t.shape,{values:n})},t.prototype.rsqrt=function(t){this.assertNotComplex(t,"rsqrt");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=1/Math.sqrt(o)}return ft.make(t.shape,{values:n})},t.prototype.square=function(t){this.assertNotComplex(t,"square");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=o*o}return ft.make(t.shape,{values:n})},t.prototype.reciprocal=function(t){this.assertNotComplex(t,"reciprocal");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=1/e[r];return ft.make(t.shape,{values:n})},t.prototype.linear=function(t){return t},t.prototype.relu=function(t){this.assertNotComplex(t,"relu");for(var e=qn(t.shape,t.dtype),n=e.dataSync(),r=t.dataSync(),o=0;o<r.length;++o)n[o]=Math.max(0,r[o]);return e},t.prototype.prelu=function(t,e){return this.assertNotComplex([t,e],"prelu"),this.broadcastedBinaryOp(t,e,t.dtype,function(t,e){return t<0?e*t:t})},t.prototype.elu=function(t){this.assertNotComplex(t,"elu");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r){var o=n[r];e[r]=o>=0?o:Math.exp(o)-1}return ft.make(t.shape,{values:e})},t.prototype.eluDer=function(t,e){this.assertNotComplex([t,e],"eluDer");for(var n=new Float32Array(e.size),r=e.dataSync(),o=t.dataSync(),a=0;a<r.length;++a){var i=r[a];n[a]=i>=1?o[a]:o[a]*(i+1)}return ft.make(e.shape,{values:n})},t.prototype.selu=function(t){this.assertNotComplex(t,"selu");for(var e=bi,n=Ci,r=new Float32Array(t.size),o=t.dataSync(),a=0;a<o.length;++a){var i=o[a];r[a]=i>=0?n*i:e*(Math.exp(i)-1)}return ft.make(t.shape,{values:r})},t.prototype.clip=function(t,e,n){this.assertNotComplex(t,"clip");for(var r=new Float32Array(t.size),o=t.dataSync(),a=0;a<o.length;++a){var i=o[a];r[a]=i>n?n:i<e?e:i}return ft.make(t.shape,{values:r})},t.prototype.abs=function(t){for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.abs(n[r]);return ft.make(t.shape,{values:e})},t.prototype.complexAbs=function(t){for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<t.size;++r){var o=n[2*r],a=n[2*r+1];e[r]=Math.hypot(o,a)}return ft.make(t.shape,{values:e})},t.prototype.int=function(t){this.assertNotComplex(t,"int");for(var e=new Int32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=n[r];return ft.make(t.shape,{values:e},"int32")},t.prototype.sigmoid=function(t){this.assertNotComplex(t,"sigmoid");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=1/(1+Math.exp(-n[r]));return ft.make(t.shape,{values:e})},t.prototype.softplus=function(t){this.assertNotComplex(t,"softplus");for(var e=Math.log(1.1920928955078125e-7)+2,n=new Float32Array(t.size),r=t.dataSync(),o=0;o<r.length;++o){var a=r[o]>-e,i=r[o]<e,s=Math.exp(r[o]),u=void 0;u=i?s:a?r[o]:Math.log(1+s),n[o]=u}return ft.make(t.shape,{values:n})},t.prototype.sin=function(t){this.assertNotComplex(t,"sin");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.sin(n[r]);return ft.make(t.shape,{values:e})},t.prototype.cos=function(t){this.assertNotComplex(t,"cos");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.cos(n[r]);return ft.make(t.shape,{values:e})},t.prototype.tan=function(t){this.assertNotComplex(t,"tan");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.tan(n[r]);return ft.make(t.shape,{values:e})},t.prototype.asin=function(t){this.assertNotComplex(t,"asin");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.asin(n[r]);return ft.make(t.shape,{values:e})},t.prototype.acos=function(t){this.assertNotComplex(t,"acos");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.acos(n[r]);return ft.make(t.shape,{values:e})},t.prototype.atan=function(t){this.assertNotComplex(t,"atan");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.atan(n[r]);return ft.make(t.shape,{values:e})},t.prototype.atan2=function(t,e){return this.assertNotComplex([t,e],"atan2"),this.broadcastedBinaryOp(t,e,t.dtype,function(t,e){return Math.atan2(t,e)})},t.prototype.sinh=function(t){this.assertNotComplex(t,"sinh");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.sinh(n[r]);return ft.make(t.shape,{values:e})},t.prototype.cosh=function(t){this.assertNotComplex(t,"cosh");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.cosh(n[r]);return ft.make(t.shape,{values:e})},t.prototype.tanh=function(t){this.assertNotComplex(t,"tanh");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=b(n[r]);return ft.make(t.shape,{values:e})},t.prototype.asinh=function(t){this.assertNotComplex(t,"asinh");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.asinh(n[r]);return ft.make(t.shape,{values:e})},t.prototype.acosh=function(t){this.assertNotComplex(t,"acosh");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.acosh(n[r]);return ft.make(t.shape,{values:e})},t.prototype.atanh=function(t){this.assertNotComplex(t,"atanh");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.atanh(n[r]);return ft.make(t.shape,{values:e})},t.prototype.erf=function(t){this.assertNotComplex(t,"erf");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r){var o=n[r],a=1/(1+.3275911*o);e[r]=1-((((1.061405429*a-1.453152027)*a+1.421413741)*a-.284496736)*a+.254829592)*a*Math.exp(-o*o)}return ft.make(t.shape,{values:e})},t.prototype.step=function(t,e){void 0===e&&(e=0),this.assertNotComplex(t,"step");for(var n=new Float32Array(t.size),r=t.dataSync(),o=0;o<r.length;++o){var a=r[o];isNaN(a)?n[o]=NaN:n[o]=a>0?1:e}return ft.make(t.shape,{values:n})},t.prototype.conv2d=function(t,e,n){this.assertNotComplex([t,e],"conv2d");for(var r=n.filterHeight,o=n.filterWidth,a=n.dilationHeight,i=n.dilationWidth,s=n.padInfo.left,u=n.padInfo.top,l=Nr(n.outShape,t.dtype),c=t.dataSync(),h=e.dataSync(),p=l.values,f=0;f<n.batchSize;++f)for(var d=f*t.strides[0],v=f*l.strides[0],m=0;m<n.outHeight;++m)for(var g=v+m*l.strides[1],y=m*n.strideHeight-s,x=0;x<r;x++){var w=y+x*a;if(!(w<0||w>=n.inHeight))for(var b=x*e.strides[0],C=d+w*t.strides[1],E=0;E<n.outWidth;++E)for(var R=g+E*n.outChannels,S=E*n.strideWidth-u,N=0;N<o;N++){var k=S+N*i;if(!(k<0||k>=n.inWidth))for(var I=b+N*e.strides[1],A=C+k*n.inChannels,T=I,D=0;D<n.inChannels;++D){for(var O=c[A+D],_=0;_<n.outChannels;++_)p[R+_]+=O*h[T+_];T+=n.outChannels}}}return l.toTensor()},t.prototype.conv3d=function(t,e,n){for(var r=n.filterDepth,o=n.filterHeight,a=n.filterWidth,i=n.dilationDepth,s=n.dilationHeight,u=n.dilationWidth,l=n.padInfo.front,c=n.padInfo.left,h=n.padInfo.top,p=Nr(n.outShape,t.dtype),f=t.dataSync(),d=e.dataSync(),v=p.values,m=0;m<n.batchSize;++m)for(var g=m*t.strides[0],y=m*p.strides[0],x=0;x<n.outDepth;++x)for(var w=y+x*p.strides[1],b=x*n.strideDepth-l,C=0;C<r;C++){var E=b+C*i;if(!(E<0||E>=n.inDepth))for(var R=C*e.strides[0],S=g+E*t.strides[1],N=0;N<n.outHeight;++N)for(var k=w+N*p.strides[2],I=N*n.strideHeight-h,A=0;A<o;A++){var T=I+A*s;if(!(T<0||T>=n.inHeight))for(var D=R+A*e.strides[1],O=S+T*t.strides[2],_=0;_<n.outWidth;++_)for(var M=k+_*n.outChannels,F=_*n.strideWidth-c,B=0;B<a;B++){var P=F+B*u;if(!(P<0||P>=n.inWidth))for(var L=D+B*e.strides[2],W=O+P*n.inChannels,U=L,z=0;z<n.inChannels;++z){for(var V=f[W+z],G=0;G<n.outChannels;++G)v[M+G]+=V*d[U+G];U+=n.outChannels}}}}return p.toTensor()},t.prototype.conv2dDerInput=function(t,e,n){this.assertNotComplex([t,e],"conv2dDerInput");for(var r=Nr(n.inShape,"float32"),o=r.values,a=r.strides,i=a[0],s=a[1],u=a[2],l=t.dataSync(),c=t.strides,h=c[0],p=c[1],f=c[2],d=e.dataSync(),v=e.strides,m=v[0],g=v[1],y=v[2],x=n.batchSize,w=n.filterHeight,b=n.filterWidth,C=n.inChannels,E=n.inHeight,R=n.inWidth,S=n.outChannels,N=n.outHeight,k=n.outWidth,I=n.strideHeight,A=n.strideWidth,T=w-1-n.padInfo.top,D=b-1-n.padInfo.left,O=0;O<x;++O)for(var _=0;_<C;++_)for(var M=0;M<E;++M)for(var F=M-T,B=Math.max(0,Math.ceil(F/I)),P=Math.min(N,(w+F)/I),L=0;L<R;++L){for(var W=L-D,U=Math.max(0,Math.ceil(W/A)),z=Math.min(k,(b+W)/A),V=0,G=B;G<P;++G)for(var q=G*I-F,H=U;H<z;++H)for(var $=h*O+p*G+f*H,j=m*(w-1-q)+g*(b-1-(H*A-W))+y*_,K=0;K<S;++K){V+=l[$+K]*d[j+K]}o[i*O+s*M+u*L+_]=V}return r.toTensor()},t.prototype.conv3dDerInput=function(t,e,n){for(var r=Nr(n.inShape,"float32"),o=r.values,a=r.strides,i=a[0],s=a[1],u=a[2],l=a[3],c=t.dataSync(),h=t.strides,p=h[0],f=h[1],d=h[2],v=h[3],m=e.dataSync(),g=e.strides,y=g[0],x=g[1],w=g[2],b=g[3],C=n.batchSize,E=n.filterDepth,R=n.filterHeight,S=n.filterWidth,N=n.inChannels,k=n.inDepth,I=n.inHeight,A=n.inWidth,T=n.outChannels,D=n.outDepth,O=n.outHeight,_=n.outWidth,M=n.strideDepth,F=n.strideHeight,B=n.strideWidth,P=E-1-n.padInfo.front,L=R-1-n.padInfo.top,W=S-1-n.padInfo.left,U=0;U<C;++U)for(var z=0;z<N;++z)for(var V=0;V<k;++V)for(var G=V-P,q=Math.max(0,Math.ceil(G/M)),H=Math.min(D,(E+G)/M),$=0;$<I;++$)for(var j=$-L,K=Math.max(0,Math.ceil(j/F)),X=Math.min(O,(R+j)/F),Y=0;Y<A;++Y){for(var Q=Y-W,J=Math.max(0,Math.ceil(Q/B)),Z=Math.min(_,(S+Q)/B),tt=0,et=q;et<H;++et)for(var nt=et*M-G,rt=K;rt<X;++rt)for(var ot=rt*F-j,at=J;at<Z;++at)for(var it=p*U+f*et+d*rt+v*at,st=y*(E-1-nt)+x*(R-1-ot)+w*(S-1-(at*B-Q))+b*z,ut=0;ut<T;++ut){tt+=c[it+ut]*m[st+ut]}o[i*U+s*V+u*$+l*Y+z]=tt}return r.toTensor()},t.prototype.conv2dDerFilter=function(t,e,n){this.assertNotComplex([t,e],"conv2dDerFilter");for(var r=n.strideHeight,o=n.strideWidth,a=n.filterHeight,i=n.filterWidth,s=Nr(n.filterShape,"float32"),u=n.padInfo.left,l=n.padInfo.top,c=t.bufferSync(),h=e.bufferSync(),p=0;p<a;++p)for(var f=Math.max(0,Math.ceil((l-p)/r)),d=Math.min(n.outHeight,(n.inHeight+l-p)/r),v=0;v<i;++v)for(var m=Math.max(0,Math.ceil((u-v)/o)),g=Math.min(n.outWidth,(n.inWidth+u-v)/o),y=0;y<n.inChannels;++y)for(var x=0;x<n.outChannels;++x){for(var w=0,b=0;b<n.batchSize;++b)for(var C=f;C<d;++C)for(var E=p+C*r-l,R=m;R<g;++R){var S=v+R*o-u;w+=c.get(b,E,S,y)*h.get(b,C,R,x)}s.set(w,p,v,y,x)}return s.toTensor()},t.prototype.conv3dDerFilter=function(t,e,n){for(var r=n.strideDepth,o=n.strideHeight,a=n.strideWidth,i=n.filterDepth,s=n.filterHeight,u=n.filterWidth,l=Nr(n.filterShape,"float32"),c=l.values,h=l.strides,p=h[0],f=h[1],d=h[2],v=h[3],m=e.dataSync(),g=e.strides,y=g[0],x=g[1],w=g[2],b=g[3],C=t.dataSync(),E=t.strides,R=E[0],S=E[1],N=E[2],k=E[3],I=n.padInfo.front,A=n.padInfo.left,T=n.padInfo.top,D=0;D<i;++D)for(var O=Math.max(0,Math.ceil((I-D)/r)),_=Math.min(n.outDepth,(n.inDepth+I-D)/r),M=D*p,F=0;F<s;++F)for(var B=Math.max(0,Math.ceil((T-F)/o)),P=Math.min(n.outHeight,(n.inHeight+T-F)/o),L=F*f+M,W=0;W<u;++W)for(var U=Math.max(0,Math.ceil((A-W)/a)),z=Math.min(n.outWidth,(n.inWidth+A-W)/a),V=W*d+L,G=0;G<n.inChannels;++G)for(var q=G*v+V,H=0;H<n.outChannels;++H){for(var $=0,j=0;j<n.batchSize;++j)for(var K=j*R,X=j*y,Y=O;Y<_;++Y)for(var Q=(D+Y*r-I)*S+K,J=Y*x+X,Z=B;Z<P;++Z)for(var tt=(F+Z*o-T)*N+Q,et=Z*w+J,nt=U;nt<z;++nt){var rt=nt*b+et;$+=C[(W+nt*a-A)*k+tt+G]*m[rt+H]}c[q+H]=$}return l.toTensor()},t.prototype.depthwiseConv2D=function(t,e,n){this.assertNotComplex([t,e],"depthwiseConv2D");for(var r=n.filterHeight,o=n.filterWidth,a=n.dilationHeight,i=n.dilationWidth,s=n.padInfo.left,u=n.padInfo.top,l=n.outChannels/n.inChannels,c=Nr(n.outShape,t.dtype),h=t.dataSync(),p=e.dataSync(),f=c.values,d=0;d<n.batchSize;++d)for(var v=d*t.strides[0],m=d*c.strides[0],g=0;g<n.outHeight;++g)for(var y=m+g*c.strides[1],x=g*n.strideHeight-s,w=0;w<r;++w){var b=x+w*a;if(!(b<0||b>=n.inHeight))for(var C=w*e.strides[0],E=v+b*t.strides[1],R=0;R<n.outWidth;++R)for(var S=y+R*c.strides[2],N=R*n.strideWidth-u,k=0;k<o;++k){var I=N+k*i;if(!(I<0||I>=n.inWidth))for(var A=C+k*e.strides[1],T=E+I*n.inChannels,D=S,O=A,_=0;_<n.inChannels;++_){for(var M=h[T+_],F=0;F<l;++F)f[D+F]+=M*p[O+F];D+=l,O+=l}}}return c.toTensor()},t.prototype.depthwiseConv2DDerInput=function(t,e,n){this.assertNotComplex([t,e],"depthwiseConv2DDerInput");for(var r=Nr(n.inShape,"float32"),o=r.values,a=r.strides,i=a[0],s=a[1],u=a[2],l=t.dataSync(),c=t.strides,h=c[0],p=c[1],f=c[2],d=e.dataSync(),v=e.strides,m=v[0],g=v[1],y=v[2],x=n.batchSize,w=n.filterHeight,b=n.filterWidth,C=n.inChannels,E=n.inHeight,R=n.inWidth,S=n.outChannels,N=n.outHeight,k=n.outWidth,I=n.strideHeight,A=n.strideWidth,T=w-1-n.padInfo.top,D=b-1-n.padInfo.left,O=S/C,_=0;_<x;++_)for(var M=0;M<C;++M)for(var F=0;F<E;++F)for(var B=F-T,P=Math.max(0,Math.ceil(B/I)),L=Math.min(N,(w+B)/I),W=0;W<R;++W){for(var U=W-D,z=Math.max(0,Math.ceil(U/A)),V=Math.min(k,(b+U)/A),G=0,q=P;q<L;++q)for(var H=q*I-B,$=z;$<V;++$)for(var j=h*_+p*q+f*$,K=m*(w-1-H)+g*(b-1-($*A-U))+y*M,X=0;X<O;++X){G+=l[j+(M*O+X)]*d[K+X]}o[i*_+s*F+u*W+M]=G}return r.toTensor()},t.prototype.depthwiseConv2DDerFilter=function(t,e,n){this.assertNotComplex([t,e],"depthwiseConv2DDerFilter");for(var r=n.strideHeight,o=n.strideWidth,a=n.filterHeight,i=n.filterWidth,s=Nr(n.filterShape,"float32"),u=n.padInfo.left,l=n.padInfo.top,c=n.outChannels/n.inChannels,h=t.bufferSync(),p=e.bufferSync(),f=0;f<a;++f)for(var d=Math.max(0,Math.ceil((l-f)/r)),v=Math.min(n.outHeight,(n.inHeight+l-f)/r),m=0;m<i;++m)for(var g=Math.max(0,Math.ceil((u-m)/o)),y=Math.min(n.outWidth,(n.inWidth+u-m)/o),x=0;x<n.outChannels;++x){for(var w=Math.trunc(x/c),b=x%c,C=0,E=0;E<n.batchSize;++E)for(var R=d;R<v;++R)for(var S=f+R*r-l,N=g;N<y;++N){var k=m+N*o-u;C+=h.get(E,S,k,w)*p.get(E,R,N,x)}s.set(C,f,m,w,b)}return s.toTensor()},t.prototype.tile=function(t,e){this.assertNotComplex(t,"tile");for(var n=new Array(t.rank),r=0;r<n.length;r++)n[r]=t.shape[r]*e[r];var o=Nr(n,t.dtype),a=t.bufferSync();for(r=0;r<o.values.length;++r){for(var i=o.indexToLoc(r),s=new Array(t.rank),u=0;u<s.length;u++)s[u]=i[u]%t.shape[u];var l=a.locToIndex(s);o.values[r]=a.values[l]}return o.toTensor()},t.prototype.pad=function(t,e,n){this.assertNotComplex(t,"pad");var r=e.map(function(e,n){return e[0]+t.shape[n]+e[1]}),o=e.map(function(t){return t[0]}),a=t.bufferSync(),i=Nr(r,t.dtype);0!==n&&i.values.fill(n);for(var s=0;s<t.size;s++){var u=a.indexToLoc(s),l=u.map(function(t,e){return t+o[e]});i.set.apply(i,[a.get.apply(a,u)].concat(l))}return i.toTensor()},t.prototype.transpose=function(t,e){this.assertNotComplex(t,"transpose");for(var n=new Array(t.rank),r=0;r<n.length;r++)n[r]=t.shape[e[r]];var o=t.dataSync(),a=Nr(n,t.dtype),i=t.bufferSync();for(r=0;r<t.size;++r){for(var s=i.indexToLoc(r),u=new Array(s.length),l=0;l<u.length;l++)u[l]=s[e[l]];var c=a.locToIndex(u);a.values[c]=o[r]}return a.toTensor()},t.prototype.gather=function(t,e,n){this.assertNotComplex([t,e],"gather");var r=t.shape.slice(),o=e.dataSync();r[n]=o.length;for(var a=Nr(r,t.dtype),i=t.bufferSync(),s=0;s<a.size;++s){var u=a.indexToLoc(s),l=u.slice();l[n]=o[u[n]];var c=i.locToIndex(l);a.values[s]=i.values[c]}return a.toTensor()},t.prototype.batchToSpaceND=function(t,e,n){this.assertNotComplex([t],"batchToSpaceND");var r=e.reduce(function(t,e){return t*e}),o=Ke(t.shape,e,r),a=Xe(o.length,e.length),i=Ye(t.shape,e,r),s=Qe(n,e.length),u=Je(i,n,e.length);return t.reshape(o).transpose(a).reshape(i).slice(s,u)},t.prototype.spaceToBatchND=function(t,e,n){this.assertNotComplex([t],"spaceToBatchND");var r=e.reduce(function(t,e){return t*e}),o=[[0,0]];o.push.apply(o,n);for(var a=1+e.length;a<t.shape.length;++a)o.push([0,0]);var i=t.pad(o),s=Ke(i.shape,e,r,!1),u=Xe(s.length,e.length,!1),l=Ye(i.shape,e,r,!1);return i.reshape(s).transpose(u).reshape(l)},t.prototype.pool=function(t,e,n){this.assertNotComplex(t,"pool");for(var r=e.strideHeight,o=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,s=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=e.padInfo.top,c=e.padInfo.left,h="max"===n?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,p=t.dataSync(),f=Nr(e.outShape,t.dtype),d=f.values,v=e.outShape[1]*e.outShape[2]*e.outShape[3],m=e.outShape[2]*e.outShape[3],g=e.outShape[3],y=0;y<e.batchSize;++y)for(var x=y*v,w=y*t.strides[0],b=0;b<e.inChannels;++b)for(var C=0;C<e.outHeight;++C)for(var E=C*r-l,R=Math.max(0,E),S=Math.min(e.inHeight,s+E),N=x+C*m,k=0;k<e.outWidth;++k){for(var I=k*o-c,A=Math.max(0,I),T=Math.min(e.inWidth,u+I),D=h,O=0,_=0,M=R;M<S;M+=a){for(var F=w+M*t.strides[1],B=A;B<T;B+=i){var P=p[F+B*t.strides[2]+b];"max"===n&&P>D?D=P:"avg"===n&&(O+=P,_++)}if(isNaN(D))break}d[N+k*g+b]="avg"===n?O/_:D}return f.toTensor()},t.prototype.maxPool=function(t,e){return this.pool(t,e,"max")},t.prototype.maxPoolPositions=function(t,e){for(var n=Nr(e.outShape,"int32"),r=e.strideHeight,o=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,s=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=e.padInfo.top,c=e.padInfo.left,h=t.bufferSync(),p=0;p<e.batchSize;++p)for(var f=0;f<e.inChannels;++f)for(var d=0;d<e.outHeight;++d){for(var v=d*r-l,m=v;m<0;)m+=a;for(var g=Math.min(e.inHeight,s+v),y=0;y<e.outWidth;++y){for(var x=y*o-c,w=x;w<0;)w+=i;for(var b=Math.min(e.inWidth,u+x),C=Number.NEGATIVE_INFINITY,E=-1,R=m;R<g;R+=a)for(var S=R-v,N=w;N<b;N+=i){var k=N-x,I=h.get(p,R,N,f);I>C&&(C=I,E=S*u+k)}n.set(E,p,d,y,f)}}return n.toTensor()},t.prototype.maxPoolBackprop=function(t,e,n,r){this.assertNotComplex([e,n],"maxPoolBackprop");for(var o=this.maxPoolPositions(e,r),a=r.strideHeight,i=r.strideWidth,s=r.dilationHeight,u=r.dilationWidth,l=r.effectiveFilterHeight,c=r.effectiveFilterWidth,h=c-1-r.padInfo.left,p=l-1-r.padInfo.top,f=Nr(e.shape,"float32"),d=o.bufferSync(),v=t.bufferSync(),m=0;m<r.batchSize;++m)for(var g=0;g<r.inChannels;++g)for(var y=0;y<r.inHeight;++y)for(var x=0;x<r.inWidth;++x){for(var w=y-p,b=x-h,C=0,E=0;E<l;E+=s){var R=(w+E)/a;if(!(R<0||R>=r.outHeight||Math.floor(R)!==R))for(var S=0;S<c;S+=u){var N=(b+S)/i;if(!(N<0||N>=r.outWidth||Math.floor(N)!==N)){var k=l*c-1-d.get(m,R,N,g)===E*c+S?1:0;if(0!==k)C+=v.get(m,R,N,g)*k}}}f.set(C,m,y,x,g)}return f.toTensor()},t.prototype.avgPoolBackprop=function(t,e,n){this.assertNotComplex([t,e],"avgPoolBackprop");for(var r=n.strideHeight,o=n.strideWidth,a=n.filterHeight,i=n.filterWidth,s=n.dilationHeight,u=n.dilationWidth,l=n.effectiveFilterHeight,c=n.effectiveFilterWidth,h=c-1-n.padInfo.left,p=l-1-n.padInfo.top,f=Nr(e.shape,"float32"),d=1/(a*i),v=t.bufferSync(),m=0;m<n.batchSize;++m)for(var g=0;g<n.inChannels;++g)for(var y=0;y<n.inHeight;++y)for(var x=0;x<n.inWidth;++x){for(var w=y-p,b=x-h,C=0,E=0;E<l;E+=s){var R=(w+E)/r;if(!(R<0||R>=n.outHeight||Math.floor(R)!==R))for(var S=0;S<c;S+=u){var N=(b+S)/o;if(!(N<0||N>=n.outWidth||Math.floor(N)!==N))C+=v.get(m,R,N,g)}}f.set(C*d,m,y,x,g)}return f.toTensor()},t.prototype.cast=function(t,e){return Jn(t,e,this)},t.prototype.reshape=function(t,e){return Zn(t,e)},t.prototype.avgPool=function(t,e){return this.assertNotComplex(t,"avgPool"),this.pool(t,e,"avg").toFloat()},t.prototype.resizeBilinear=function(t,e,n,r){this.assertNotComplex(t,"resizeBilinear");for(var o=t.shape,a=o[0],i=o[1],s=o[2],u=o[3],l=t.dataSync(),c=new Float32Array(y([a,e,n,u])),h=[r&&e>1?i-1:i,r&&n>1?s-1:s],p=[r&&e>1?e-1:e,r&&n>1?n-1:n],f=0,d=h[0]/p[0],v=h[1]/p[1],m=0;m<a;m++)for(var g=0;g<e;g++)for(var x=d*g,w=Math.floor(x),b=x-w,C=Math.min(i-1,Math.ceil(x)),E=m*t.strides[0]+w*t.strides[1],R=m*t.strides[0]+C*t.strides[1],S=0;S<n;S++)for(var N=v*S,k=Math.floor(N),I=N-k,A=Math.min(s-1,Math.ceil(N)),T=E+k*t.strides[2],D=R+k*t.strides[2],O=E+ +A*t.strides[2],_=R+A*t.strides[2],M=0;M<u;M++){var F=l[T+M],B=l[D+M],P=F+(l[O+M]-F)*I,L=P+(B+(l[_+M]-B)*I-P)*b;c[f++]=L}return Fn(c,[a,e,n,u])},t.prototype.resizeBilinearBackprop=function(t,e,n){this.assertNotComplex([t,e],"resizeBilinearBackprop");for(var r=e.shape,o=r[0],a=r[1],i=r[2],s=r[3],u=t.shape,l=u[1],c=u[2],h=new Float32Array(o*a*i*s),p=[n&&l>1?a-1:a,n&&c>1?i-1:i],f=[n&&l>1?l-1:l,n&&c>1?c-1:c],d=p[0]/f[0],v=p[1]/f[1],m=t.dataSync(),g=0,y=0;y<o;y++)for(var x=y*e.strides[0],w=0;w<l;w++)for(var b=w*d,C=Math.floor(b),E=Math.min(Math.ceil(b),a-1),R=x+C*e.strides[1],S=x+E*e.strides[1],N=b-C,k=1-N,I=0;I<c;I++)for(var A=I*v,T=Math.floor(A),D=Math.min(Math.ceil(A),i-1),O=A-T,_=1-O,M=R+T*e.strides[2],F=R+D*e.strides[2],B=S+T*e.strides[2],P=S+D*e.strides[2],L=k*_,W=k*O,U=N*_,z=N*O,V=0;V<s;V++){var G=m[g++];h[M+V]+=G*L,h[F+V]+=G*W,h[B+V]+=G*U,h[P+V]+=G*z}return Un(h,[o,i,a,s],e.dtype)},t.prototype.resizeNearestNeighbor=function(t,e,n,r){this.assertNotComplex(t,"resizeNearestNeighbor");for(var o=t.shape,a=o[0],i=o[1],s=o[2],u=o[3],l=t.dataSync(),c=new Float32Array(a*e*n*u),h=[r&&e>1?i-1:i,r&&n>1?s-1:s],p=[r&&e>1?e-1:e,r&&n>1?n-1:n],f=h[0]/p[0],d=h[1]/p[1],v=0,m=0;m<a;m++)for(var g=m*t.strides[0],y=0;y<e;y++)for(var x=f*y,w=g+Math.min(i-1,r?Math.round(x):Math.floor(x))*t.strides[1],b=0;b<n;b++)for(var C=d*b,E=w+Math.min(s-1,r?Math.round(C):Math.floor(C))*t.strides[2],R=0;R<u;R++){var S=l[E+R];c[v++]=S}return Fn(c,[a,e,n,u],t.dtype)},t.prototype.resizeNearestNeighborBackprop=function(t,e,n){this.assertNotComplex([t,e],"resizeNearestNeighborBackprop");for(var r=e.shape,o=r[0],a=r[1],i=r[2],s=r[3],u=t.shape,l=u[1],c=u[2],h=new Float32Array(o*a*i*s),p=t.dataSync(),f=[n&&l>1?a-1:a,n&&c>1?i-1:i],d=[n&&l>1?l-1:l,n&&c>1?c-1:c],v=f[0]/d[0],m=f[1]/d[1],g=1/v,y=1/m,x=2*Math.ceil(g)+2,w=2*Math.ceil(y)+2,b=0;b<o;b++)for(var C=b*e.strides[0],E=0;E<a;E++)for(var R=C+E*e.strides[1],S=Math.floor(E*g),N=Math.floor(S-x/2),k=0;k<i;k++)for(var I=R+k*e.strides[2],A=Math.floor(k*y),T=Math.floor(A-w/2),D=0;D<s;D++){for(var O=0,_=0;_<x;_++){var M=_+N;if(!(M<0||M>=l)){var F=C+M*t.strides[1],B=M*v;if(E===Math.min(a-1,n?Math.round(B):Math.floor(B)))for(var P=0;P<w;P++){var L=P+T;if(!(L<0||L>=c)){var W=F+L*t.strides[2],U=L*m;k===Math.min(i-1,n?Math.round(U):Math.floor(U))&&(O+=p[W+D])}}}}h[I+D]=O}return Un(h,e.shape,e.dtype)},t.prototype.batchNormalization=function(t,e,n,r,o,a){this.assertNotComplex([t,e,n,o,a],"batchNorm");for(var i=t.dataSync(),s=e.dataSync(),u=n.dataSync(),l=o?o.dataSync():new Float32Array([1]),c=a?a.dataSync():new Float32Array([0]),h=new Float32Array(i.length),p=c.length,f=l.length,d=u.length,v=s.length,m=0,g=0,y=0,x=0,w=0;w<i.length;++w)h[w]=c[m++]+(i[w]-s[g++])*l[y++]/Math.sqrt(u[x++]+r),m>=p&&(m=0),g>=v&&(g=0),y>=f&&(y=0),x>=d&&(x=0);return Un(h,t.shape)},t.prototype.localResponseNormalization4D=function(t,e,n,r,o){this.assertNotComplex(t,"localResponseNormalization4D");var a=t.shape[3],i=a-1,s=t.dataSync(),u=t.size,l=new Float32Array(u);function c(t){for(var n=t%a,r=t-n+Math.max(0,n-e),o=t-n+Math.min(n+e,i),u=0;r<=o;r++){var l=s[r];u+=l*l}return u}for(var h=0;h<u;h++){var p=c(h),f=s[h]*Math.pow(n+r*p,-o);l[h]=f}return Un(l,t.shape)},t.prototype.LRNGrad=function(t,e,n,r,o,a,i){this.assertNotComplex(t,"LRNGrad");for(var s=t.shape[3],u=t.dataSync(),l=e.dataSync(),c=n.dataSync(),h=new Float32Array(t.size),p=t.size,f=0;f<p;f++){for(var d=f%s,v=f-d+Math.max(0,d-r),m=f-d+Math.min(s,d+r+1),g=0,y=v;y<m;y++)g+=Math.pow(l[y],2);g=a*g+o;for(y=v;y<m;y++){var x=-2*a*i*l[y]*c[f]/g;f===y&&(x+=Math.pow(g,-i)),x*=u[f],h[y]+=x}}return Un(h,t.shape)},t.prototype.multinomial=function(t,e,n,r){this.assertNotComplex(t,"multinomial");for(var o=e?t:Tn(t),a=o.shape[0],i=o.shape[1],s=qn([a,n],"int32"),u=s.dataSync(),l=o.dataSync(),c=0;c<a;++c){var h=c*i,p=new Float32Array(i-1);p[0]=l[h];for(var f=1;f<p.length;++f)p[f]=p[f-1]+l[h+f];for(var d=Er(r.toString()),v=c*n,m=0;m<n;++m){var g=d();u[v+m]=p.length;for(var y=0;y<p.length;y++)if(g<p[y]){u[v+m]=y;break}}}return s},t.prototype.oneHot=function(t,e,n,r){this.assertNotComplex(t,"oneHot");var o=new Float32Array(t.size*e);o.fill(r);for(var a=t.dataSync(),i=0;i<t.size;++i)a[i]>=0&&a[i]<e&&(o[i*e+a[i]]=n);return Ln(o,[t.size,e],"int32")},t.prototype.nonMaxSuppression=function(t,e,n,r,o){return this.assertNotComplex(t,"nonMaxSuppression"),ar(t.dataSync(),e.dataSync(),n,r,o)},t.prototype.fft=function(t){return this.fftBatch(t,!1)},t.prototype.ifft=function(t){return this.fftBatch(t,!0)},t.prototype.fftBatch=function(t,e){for(var n=t.shape[0],r=t.shape[1],o=Nr(t.shape,"float32"),a=Nr(t.shape,"float32"),i=_n(t).as2D(n,r),s=Mn(t).as2D(n,r),u=0;u<n;u++)for(var l=i.slice([u,0],[1,r]),c=s.slice([u,0],[1,r]),h=On(l,c),p=this.fftImpl(h,e).dataSync(),f=0;f<r;f++){var d=nr(p,f);o.values[u*r+f]=d.real,a.values[u*r+f]=d.imag}return On(o.toTensor(),a.toTensor()).as2D(n,r)},t.prototype.fftImpl=function(t,e){var n=t.as1D(),r=n.size;if(this.isExponentOf2(r)){var o=this.fftRadix2(n,r,e).as2D(t.shape[0],t.shape[1]);return e&&(o=On(_n(o).div(Bn(r)),Mn(o).div(Bn(r)))),o}var a=t.dataSync(),i=function(t){for(var e=new Float32Array(t.length/2),n=new Float32Array(t.length/2),r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}(this.fourierTransformByMatmul(a,r,e));return On(i.real,i.imag).as2D(t.shape[0],t.shape[1])},t.prototype.isExponentOf2=function(t){return 0==(t&t-1)},t.prototype.fftRadix2=function(t,e,n){if(1===e)return t;var r=t.dataSync(),o=e/2,a=function(t){for(var e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e),o=0;o<t.length;o+=4)n[Math.floor(o/4)]=t[o],r[Math.floor(o/4)]=t[o+1];return{real:n,imag:r}}(r),i=On(a.real,a.imag).as1D(),s=function(t){for(var e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e),o=2;o<t.length;o+=4)n[Math.floor(o/4)]=t[o],r[Math.floor(o/4)]=t[o+1];return{real:n,imag:r}}(r),u=On(s.real,s.imag).as1D();i=this.fftRadix2(i,o,n),u=this.fftRadix2(u,o,n);var l=function(t,e){for(var n=new Float32Array(t/2),r=new Float32Array(t/2),o=0;o<Math.ceil(t/2);o++){var a=(e?2:-2)*Math.PI*(o/t);n[o]=Math.cos(a),r[o]=Math.sin(a)}return{real:n,imag:r}}(e,n),c=On(l.real,l.imag).mul(u),h=i.add(c),p=i.sub(c),f=_n(h).concat(_n(p)),d=Mn(h).concat(Mn(p));return On(f,d).as1D()},t.prototype.fourierTransformByMatmul=function(t,e,n){for(var r=new Float32Array(2*e),o=0;o<e;o++){for(var a=0,i=0,s=0;s<e;s++){var u=or(o*s,e,n),l=nr(t,s);a+=l.real*u.real-l.imag*u.imag,i+=l.real*u.imag+l.imag*u.real}n&&(a/=e,i/=e),rr(r,a,i,o)}return r},t.prototype.depthToSpace=function(t,e,n){d("NHWC"===n,function(){return"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+n}),d(e>1,function(){return"blockSize should be > 1 for depthToSpace, but was: "+e});for(var r=t.shape[0],o=t.shape[1],a=t.shape[2],i=t.shape[3],s=o*e,u=a*e,l=i/(e*e),c=t.dataSync(),h=new Float32Array(r*s*u*l),p=0,f=0;f<r;++f)for(var v=0;v<s;++v)for(var m=Math.floor(v/e),g=v%e,y=0;y<u;++y)for(var x=Math.floor(y/e),w=(g*e+y%e)*l,b=0;b<l;++b){var C=b+w+i*(x+a*(m+o*f));h[p++]=c[C]}return Un(h,[r,s,u,l])},t.prototype.broadcastedBinaryOp=function(t,e,n,r){var o=so(t.shape,e.shape),a=Nr(o,n),i=t.dataSync(),s=e.dataSync(),u=ao(t.shape,o),l=ao(e.shape,o),c=a.values;if(u.length+l.length===0)for(var h=0;h<c.length;++h)c[h]=r(i[h%i.length],s[h%s.length]);else{var p=t.bufferSync(),f=e.bufferSync(),d=function(n){var o=a.indexToLoc(n),h=o.slice(-t.rank);u.forEach(function(t){return h[t]=0});var d=p.locToIndex(h),v=o.slice(-e.rank);l.forEach(function(t){return v[t]=0});var m=f.locToIndex(v);c[n]=r(i[d],s[m])};for(h=0;h<c.length;++h)d(h)}return a.toTensor()},t.prototype.broadcastedBinaryComplexOp=function(t,e,n){var r=so(t.shape,e.shape),o=Nr(r,"float32"),a=Nr(r,"float32"),i=t.dataSync(),s=e.dataSync(),u=ao(t.shape,r),l=ao(e.shape,r),c=o.values,h=a.values;if(u.length+l.length===0)for(var p=0;p<c.length;p++){var f=p%i.length,d=p%s.length,v=n(i[2*f],i[2*f+1],s[2*d],s[2*d+1]);c[p]=v.real,h[p]=v.imag}else{var m=this.data.get(t.dataId).complexTensors.real.bufferSync(),g=this.data.get(e.dataId).complexTensors.real.bufferSync(),y=function(r){var a=o.indexToLoc(r),p=a.slice(-t.rank);u.forEach(function(t){return p[t]=0});var f=m.locToIndex(p),d=a.slice(-e.rank);l.forEach(function(t){return d[t]=0});var v=g.locToIndex(d),y=n(i[2*f],i[2*f+1],s[2*v],s[2*v+1]);c[r]=y.real,h[r]=y.imag};for(p=0;p<c.length;p++)y(p)}return this.complex(o.toTensor(),a.toTensor())},t.prototype.split=function(t,e,n){return sr(t,e,n)},t.prototype.dispose=function(){},t.prototype.floatPrecision=function(){return 32},t.prototype.epsilon=function(){return 1e-7},t.prototype.cropAndResize=function(t,e,n,r,o,a){for(var i=t.shape,s=i[0],u=i[1],l=i[2],c=i[3],h=e.shape[0],p=r[0],f=r[1],d=Nr([h,p,f,c],t.dtype),v=e.dataSync(),m=n.dataSync(),g=t.dataSync(),y=t.strides,x=d.strides,w=0;w<h;w++){var b=4*w,C=v[b],E=v[b+1],R=v[b+2],S=v[b+3],N=m[w];if(!(N>=s))for(var k=p>1?(R-C)*(u-1)/(p-1):0,I=f>1?(S-E)*(l-1)/(f-1):0,A=0;A<p;A++){var T=p>1?C*(u-1)+A*k:.5*(C+R)*(u-1);if(T<0||T>u-1)for(var D=0;D<f;D++)for(var O=0;O<c;O++){var _=O+D*x[2]+A*x[1]+w*x[0];d.values[_]=a}else if("bilinear"===o){var M=Math.floor(T),F=Math.ceil(T),B=T-M;for(D=0;D<f;D++){if((H=f>1?E*(l-1)+D*I:.5*(E+S)*(l-1))<0||H>l-1)for(O=0;O<c;O++){_=O+D*x[2]+A*x[1]+w*x[0];d.values[_]=a}else{var P=Math.floor(H),L=Math.ceil(H),W=H-P;for(O=0;O<c;O++){var U=g[_=O+P*y[2]+M*y[1]+N*y[0]],z=g[_=O+L*y[2]+M*y[1]+N*y[0]],V=g[_=O+P*y[2]+F*y[1]+N*y[0]],G=U+(z-U)*W,q=V+(g[_=O+L*y[2]+F*y[1]+N*y[0]]-V)*W;_=O+D*x[2]+A*x[1]+w*x[0],d.values[_]=G+(q-G)*B}}}}else for(D=0;D<f;++D){var H;if((H=f>1?E*(l-1)+D*I:.5*(E+S)*(l-1))<0||H>l-1)for(O=0;O<c;O++){_=O+D*x[2]+A*x[1]+w*x[0];d.values[_]=a}else{var $=Math.round(H),j=Math.round(T);for(O=0;O<c;O++){var K=O+$*y[2]+j*y[1]+N*y[0],X=O+D*x[2]+A*x[1]+w*x[0];d.values[X]=g[K]}}}}}return d.toTensor()},t.prototype.sparseToDense=function(t,e,n,r){var o=pn(0,t,n),a=o.sliceRank,i=o.numUpdates,s=o.sliceSize,u=o.strides,l=o.outputSize;return this.scatter(t,e,n,l,s,i,a,u,r,!1)},t.prototype.gatherND=function(t,e){var n=e.shape,r=n[n.length-1],o=un(t,e),a=o[0],i=o[1],s=o[2],u=o[3];if(0===i)return Fn([],a,t.dtype);for(var l=new lt([i,s],t.dtype),c=e.dataSync(),h=t.dataSync(),p=0;p<i;p++){for(var f=[],d=0,v=0;v<r;v++){var m=c[p*r+v];d+=m*u[v],f.push(m)}if(d<0||d>=t.size/s)throw new Error("Invalid indices: "+f+" does not index into "+t.shape);for(var g=0;g<s;g++)l.values[p*s+g]=h[d*s+g]}return l.toTensor().reshape(a)},t.prototype.scatterND=function(t,e,n){var r=pn(0,t,n),o=r.sliceRank,a=r.numUpdates,i=r.sliceSize,s=r.strides,u=r.outputSize,l=Bn(0);return this.scatter(t,e,n,u,i,a,o,s,l,!0)},t.prototype.fill=function(t,e,n){var r=A(n=n||W(e),y(t));return r.fill(e),ft.make(t,{values:r},n)},t.prototype.onesLike=function(t){if("string"===t.dtype)throw new Error("onesLike is not supported for string tensors");return this.fill(t.shape,1,t.dtype)},t.prototype.zerosLike=function(t){var e=A(t.dtype,y(t.shape));return ft.make(t.shape,{values:e},t.dtype)},t.prototype.linspace=function(t,e,n){return tr(t,e,n)},t.prototype.scatter=function(t,e,n,r,o,a,i,s,u,l){var c=[r/o,o],h=t.dataSync(),p=e.dataSync();if(0===r)return Fn([],n,e.dtype);var f=new lt(c,e.dtype);f.values.fill(u.dataSync()[0]);for(var d=0;d<a;d++){for(var v=[],m=0,g=0;g<i;g++){var y=h[d*i+g];v.push(y),m+=y*s[g]}if(m<0||m>=r/o)throw new Error("Invalid indices: "+v+" does not index into "+n);for(var x=0;x<o;x++)l?f.values[m*o+x]+=p[d*o+x]:f.values[m*o+x]=0===e.rank?p[0]:p[d*o+x]}return f.toTensor().reshape(n)},t}();Dt.registerBackend("cpu",function(){return new gc},1);var yc={float32:4,int32:4,uint16:2,uint8:1,bool:1};function xc(t,e){for(var n={},r=0,o=function(e){var o=e.name,a=e.dtype,i=e.shape,s=y(i),u=void 0;if("quantization"in e){var l=e.quantization;if("uint8"!==l.dtype&&"uint16"!==l.dtype)throw new Error("Weight "+e.name+" has unknown quantization dtype "+l.dtype+". Supported quantization dtypes are: 'uint8' and 'uint16'.");var c=yc[l.dtype],h=t.slice(r,r+s*c),p="uint8"===l.dtype?new Uint8Array(h):new Uint16Array(h);if("float32"===a)u=Float32Array.from(p,function(t){return t*l.scale+l.min});else{if("int32"!==a)throw new Error("Unsupported dtype in weight '"+o+"': "+a);u=Int32Array.from(p,function(t){return Math.round(t*l.scale+l.min)})}r+=s*c}else{var f=yc[a];h=t.slice(r,r+s*f);if("float32"===a)u=new Float32Array(h);else if("int32"===a)u=new Int32Array(h);else{if("bool"!==a)throw new Error("Unsupported dtype in weight '"+o+"': "+a);u=new Uint8Array(h)}r+=s*f}var d=void 0;if("float32"===a)d=Fn(u,i,"float32");else if("int32"===a)d=Fn(u,i,"int32");else{if("bool"!==a)throw new Error("Unsupported dtype in weight '"+o+"': "+a);d=Fn(u,i,"bool")}n[o]=d},a=0,i=e;a<i.length;a++){o(i[a])}return n}function wc(t){if(null===t)throw new Error("Invalid input value: "+JSON.stringify(t));var e=0,n=[];t.forEach(function(t){if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: "+t.constructor.name)});var r=new Uint8Array(e),o=0;return n.forEach(function(t){r.set(new Uint8Array(t.buffer),o),o+=t.byteLength}),r.buffer}var bc="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function Cc(t){return bc?Buffer.byteLength(t):new Blob([t]).size}function Ec(t){var e=0;t.forEach(function(t){e+=t.byteLength});var n=new Uint8Array(e),r=0;return t.forEach(function(t){n.set(new Uint8Array(t),r),r+=t.byteLength}),n.buffer}function Rc(t){for(t=t.trim();t.endsWith("/");)t=t.slice(0,t.length-1);var e=t.split("/");return e[e.length-1]}function Sc(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:Cc(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:Cc(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}var Nc=function(){function t(){this.saveRouters=[],this.loadRouters=[]}return t.getInstance=function(){return null==t.instance&&(t.instance=new t),t.instance},t.registerSaveRouter=function(e){t.getInstance().saveRouters.push(e)},t.registerLoadRouter=function(e){t.getInstance().loadRouters.push(e)},t.getSaveHandlers=function(e){return t.getHandlers(e,"save")},t.getLoadHandlers=function(e,n){return t.getHandlers(e,"load",n)},t.getHandlers=function(e,n,r){var o=[];return("load"===n?t.getInstance().loadRouters:t.getInstance().saveRouters).forEach(function(t){var n=t(e,r);null!==n&&o.push(n)}),o},t}(),kc="://",Ic=function(){function t(){this.managers={}}return t.getInstance=function(){return null==t.instance&&(t.instance=new t),t.instance},t.registerManager=function(e,n){d(null!=e,function(){return"scheme must not be undefined or null."}),e.endsWith(kc)&&(e=e.slice(0,e.indexOf(kc))),d(e.length>0,function(){return"scheme must not be an empty string."});var r=t.getInstance();d(null==r.managers[e],function(){return"A model store manager is already registered for scheme '"+e+"'."}),r.managers[e]=n},t.getManager=function(t){var e=this.getInstance().managers[t];if(null==e)throw new Error("Cannot find model manager for scheme '"+t+"'");return e},t.getSchemes=function(){return Object.keys(this.getInstance().managers)},t}();function Ac(t){if(-1===t.indexOf(kc))throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+Ic.getSchemes().join(","));return{scheme:t.split(kc)[0],path:t.split(kc)[1]}}function Tc(t,e,n){return void 0===n&&(n=!1),r(this,void 0,void 0,function(){var r,a,i,s,u,l,c,h,p;return o(this,function(o){switch(o.label){case 0:return d(t!==e,function(){return"Old path and new path are the same: '"+t+"'"}),d((r=Nc.getLoadHandlers(t)).length>0,function(){return"Copying failed because no load handler is found for source URL "+t+"."}),d(r.length<2,function(){return"Copying failed because more than one ("+r.length+") load handlers for source URL "+t+"."}),a=r[0],d((i=Nc.getSaveHandlers(e)).length>0,function(){return"Copying failed because no save handler is found for destination URL "+e+"."}),d(i.length<2,function(){return"Copying failed because more than one ("+r.length+") save handlers for destination URL "+e+"."}),s=i[0],u=Ac(t).scheme,l=Ac(t).path,c=u===Ac(t).scheme,[4,a.load()];case 1:return h=o.sent(),n&&c?[4,Ic.getManager(u).removeModel(l)]:[3,3];case 2:o.sent(),o.label=3;case 3:return[4,s.save(h)];case 4:return p=o.sent(),!n||c?[3,6]:[4,Ic.getManager(u).removeModel(l)];case 5:o.sent(),o.label=6;case 6:return[2,p.modelArtifactsInfo]}})})}var Dc="models_store",Oc="model_info_store";function _c(){if(!a.getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");var t=window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Mc(t){var e=t.result;e.createObjectStore(Dc,{keyPath:"modelPath"}),e.createObjectStore(Oc,{keyPath:"modelPath"})}var Fc=function(){function t(t){if(this.indexedDB=_c(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}return t.prototype.save=function(t){return r(this,void 0,void 0,function(){return o(this,function(e){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return[2,this.databaseAction(this.modelPath,t)]})})},t.prototype.load=function(){return r(this,void 0,void 0,function(){return o(this,function(t){return[2,this.databaseAction(this.modelPath)]})})},t.prototype.databaseAction=function(t,e){var n=this;return new Promise(function(t,r){var o=n.indexedDB.open("tensorflowjs",1);o.onupgradeneeded=function(){return Mc(o)},o.onsuccess=function(){var a=o.result;if(null==e){var i=a.transaction(Dc,"readonly"),s=i.objectStore(Dc).get(n.modelPath);s.onsuccess=function(){if(null==s.result)return a.close(),r(new Error("Cannot find model with path '"+n.modelPath+"' in IndexedDB."));t(s.result.modelArtifacts)},s.onerror=function(t){return a.close(),r(s.error)},i.oncomplete=function(){return a.close()}}else{var u,l=Sc(e),c=a.transaction(Oc,"readwrite"),h=c.objectStore(Oc),p=h.put({modelPath:n.modelPath,modelArtifactsInfo:l});p.onsuccess=function(){var o=(u=a.transaction(Dc,"readwrite")).objectStore(Dc).put({modelPath:n.modelPath,modelArtifacts:e,modelArtifactsInfo:l});o.onsuccess=function(){return t({modelArtifactsInfo:l})},o.onerror=function(t){var e=(h=c.objectStore(Oc)).delete(n.modelPath);e.onsuccess=function(){return a.close(),r(o.error)},e.onerror=function(t){return a.close(),r(o.error)}}},p.onerror=function(t){return a.close(),r(p.error)},c.oncomplete=function(){null==u?a.close():u.oncomplete=function(){return a.close()}}}},o.onerror=function(t){return r(o.error)}})},t.URL_SCHEME="indexeddb://",t}(),Bc=function(t){return a.getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Fc.URL_SCHEME)?(e=t.slice(Fc.URL_SCHEME.length),new Fc(e)):null;var e};Nc.registerSaveRouter(Bc),Nc.registerLoadRouter(Bc);var Pc=function(){function t(){this.indexedDB=_c()}return t.prototype.listModels=function(){return r(this,void 0,void 0,function(){var t=this;return o(this,function(e){return[2,new Promise(function(e,n){var r=t.indexedDB.open("tensorflowjs",1);r.onupgradeneeded=function(){return Mc(r)},r.onsuccess=function(){var t=r.result,o=t.transaction(Oc,"readonly"),a=o.objectStore(Oc).getAll();a.onsuccess=function(){for(var t={},n=0,r=a.result;n<r.length;n++){var o=r[n];t[o.modelPath]=o.modelArtifactsInfo}e(t)},a.onerror=function(e){return t.close(),n(a.error)},o.oncomplete=function(){return t.close()}},r.onerror=function(t){return n(r.error)}})]})})},t.prototype.removeModel=function(t){return r(this,void 0,void 0,function(){var e=this;return o(this,function(n){var r;return t=(r=t).startsWith(Fc.URL_SCHEME)?r.slice(Fc.URL_SCHEME.length):r,[2,new Promise(function(n,r){var o=e.indexedDB.open("tensorflowjs",1);o.onupgradeneeded=function(){return Mc(o)},o.onsuccess=function(){var e,a=o.result,i=a.transaction(Oc,"readwrite"),s=i.objectStore(Oc),u=s.get(t);u.onsuccess=function(){if(null==u.result)return a.close(),r(new Error("Cannot find model with path '"+t+"' in IndexedDB."));var o=s.delete(t),i=function(){var o=(e=a.transaction(Dc,"readwrite")).objectStore(Dc).delete(t);o.onsuccess=function(){return n(u.result.modelArtifactsInfo)},o.onerror=function(t){return r(u.error)}};o.onsuccess=i,o.onerror=function(t){return i(),a.close(),r(u.error)}},u.onerror=function(t){return a.close(),r(u.error)},i.oncomplete=function(){null==e?a.close():e.oncomplete=function(){return a.close()}}},o.onerror=function(t){return r(o.error)}})]})})},t}();if(a.getBool("IS_BROWSER"))try{Ic.registerManager(Fc.URL_SCHEME,new Pc)}catch(t){}var Lc="/",Wc="tensorflowjs_models",Uc="info",zc="model_topology",Vc="weight_specs",Gc="weight_data",qc="model_metadata";function Hc(t){return{info:[Wc,t,Uc].join(Lc),topology:[Wc,t,zc].join(Lc),weightSpecs:[Wc,t,Vc].join(Lc),weightData:[Wc,t,Gc].join(Lc),modelMetadata:[Wc,t,qc].join(Lc)}}function $c(t){var e=t.split(Lc);if(e.length<3)throw new Error("Invalid key format: "+t);return e.slice(1,e.length-1).join(Lc)}var jc=function(){function t(t){if(!a.getBool("IS_BROWSER")||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=Hc(this.modelPath)}return t.prototype.save=function(t){return r(this,void 0,void 0,function(){var e,n,r;return o(this,function(o){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),r=Sc(t);try{return this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,(a=t.weightData,bc?Buffer.from(a).toString("base64"):btoa(String.fromCharCode.apply(null,new Uint8Array(a))))),this.LS.setItem(this.keys.modelMetadata,JSON.stringify({format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy})),[2,{modelArtifactsInfo:r}]}catch(t){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error("Failed to save model '"+this.modelPath+"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes="+r.modelTopologyBytes+", weightSpecsBytes="+r.weightSpecsBytes+", weightDataBytes="+r.weightDataBytes+".")}var a;return[2]})})},t.prototype.load=function(){return r(this,void 0,void 0,function(){var t,e,n,r,a,i,s;return o(this,function(o){if(null==(t=JSON.parse(this.LS.getItem(this.keys.info))))throw new Error("In local storage, there is no model with name '"+this.modelPath+"'");if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");if(e={},null==(n=JSON.parse(this.LS.getItem(this.keys.topology))))throw new Error("In local storage, the topology of model '"+this.modelPath+"' is missing.");if(e.modelTopology=n,null==(r=JSON.parse(this.LS.getItem(this.keys.weightSpecs))))throw new Error("In local storage, the weight specs of model '"+this.modelPath+"' are missing.");if(e.weightSpecs=r,null!=(a=this.LS.getItem(this.keys.modelMetadata))&&(i=JSON.parse(a),e.format=i.format,e.generatedBy=i.generatedBy,e.convertedBy=i.convertedBy),null==(s=this.LS.getItem(this.keys.weightData)))throw new Error("In local storage, the binary weight values of model '"+this.modelPath+"' are missing.");return e.weightData=function(t){if(bc){var e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}for(var n=atob(t),r=new Uint8Array(n.length),o=0;o<n.length;++o)r.set([n.charCodeAt(o)],o);return r.buffer}(s),[2,e]})})},t.URL_SCHEME="localstorage://",t}(),Kc=function(t){return a.getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(jc.URL_SCHEME)?(e=t.slice(jc.URL_SCHEME.length),new jc(e)):null;var e};Nc.registerSaveRouter(Kc),Nc.registerLoadRouter(Kc);var Xc=function(){function t(){d(a.getBool("IS_BROWSER"),function(){return"Current environment is not a web browser"}),d(void 0!==window.localStorage,function(){return"Current browser does not appear to support localStorage"}),this.LS=window.localStorage}return t.prototype.listModels=function(){return r(this,void 0,void 0,function(){var t,e,n,r,a,i;return o(this,function(o){for(t={},e=Wc+Lc,n=Lc+Uc,r=0;r<this.LS.length;++r)(a=this.LS.key(r)).startsWith(e)&&a.endsWith(n)&&(i=$c(a),t[i]=JSON.parse(this.LS.getItem(a)));return[2,t]})})},t.prototype.removeModel=function(t){return r(this,void 0,void 0,function(){var e,n;return o(this,function(r){var o;if(t=(o=t).startsWith(jc.URL_SCHEME)?o.slice(jc.URL_SCHEME.length):o,e=Hc(t),null==this.LS.getItem(e.info))throw new Error("Cannot find model at path '"+t+"'");return n=JSON.parse(this.LS.getItem(e.info)),this.LS.removeItem(e.info),this.LS.removeItem(e.topology),this.LS.removeItem(e.weightSpecs),this.LS.removeItem(e.weightData),[2,n]})})},t}();if(a.getBool("IS_BROWSER"))try{Ic.registerManager(jc.URL_SCHEME,new Xc)}catch(t){}var Yc="model",Qc=".json",Jc=".weights.bin";function Zc(t){return new Promise(function(t){return setTimeout(t)}).then(t)}var th=function(){function t(e){if(!a.getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(t.URL_SCHEME)&&(e=e.slice(t.URL_SCHEME.length)),null!=e&&0!==e.length||(e=Yc),this.modelTopologyFileName=e+Qc,this.weightDataFileName=e+Jc}return t.prototype.save=function(t){return r(this,void 0,void 0,function(){var e,n,r,a,i,s;return o(this,function(o){switch(o.label){case 0:if(e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"})),!(t.modelTopology instanceof ArrayBuffer))return[3,1];throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");case 1:return n=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:n},a=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),(i=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor).download=this.modelTopologyFileName,i.href=a,[4,Zc(function(){return i.dispatchEvent(new MouseEvent("click"))})];case 2:return o.sent(),null==t.weightData?[3,4]:((s=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor).download=this.weightDataFileName,s.href=e,[4,Zc(function(){return s.dispatchEvent(new MouseEvent("click"))})]);case 3:o.sent(),o.label=4;case 4:return[2,{modelArtifactsInfo:Sc(t)}]}})})},t.URL_SCHEME="downloads://",t}(),eh=function(){function t(t){if(null==t||t.length<1)throw new Error("When calling browserFiles, at least 1 file is required, but received "+t);this.files=t}return t.prototype.load=function(){return r(this,void 0,void 0,function(){var t,e,n=this;return o(this,function(r){return t=this.files[0],e=this.files.slice(1),[2,new Promise(function(r,o){var a=new FileReader;a.onload=function(a){var i=JSON.parse(a.target.result),s=i.modelTopology;if(null!=s){0===e.length&&r({modelTopology:s});var u=i.weightsManifest;if(null!=u){var l;try{l=n.checkManifestAndWeightFiles(u,e)}catch(t){return void o(t)}var c=[],h=[],p=[];u.forEach(function(t){t.paths.forEach(function(t){h.push(t),p.push(null)}),c.push.apply(c,t.weights)}),u.forEach(function(t){t.paths.forEach(function(t){var e=new FileReader;e.onload=function(e){var n=e.target.result,o=h.indexOf(t);p[o]=n,-1===p.indexOf(null)&&r({modelTopology:s,weightSpecs:c,weightData:Ec(p)})},e.onerror=function(e){return o("Failed to weights data from file of path '"+t+"'.")},e.readAsArrayBuffer(l[t])})})}else o(new Error("weightManifest field is missing from file "+t.name))}else o(new Error("modelTopology field is missing from file "+t.name))},a.onerror=function(e){return o("Failed to read model topology and weights manifest JSON from file '"+t.name+"'. BrowserFiles supports loading Keras-style tf.Model artifacts only.")},a.readAsText(t)})]})})},t.prototype.checkManifestAndWeightFiles=function(t,e){for(var n=[],r=e.map(function(t){return Rc(t.name)}),o={},a=0,i=t;a<i.length;a++){i[a].paths.forEach(function(t){var a=Rc(t);if(-1!==n.indexOf(a))throw new Error("Duplicate file basename found in weights manifest: '"+a+"'");if(n.push(a),-1===r.indexOf(a))throw new Error("Weight file with basename '"+a+"' is not provided.");o[t]=e[r.indexOf(a)]})}if(n.length!==e.length)throw new Error("Mismatch in the number of files in weights manifest ("+n.length+") and the number of weight files provided ("+e.length+").");return o},t}();function nh(t,e,n,r){!function(t){d(null!=t&&Array.isArray(t)&&t.length>0,function(){return"promises must be a none empty array"})}(t),function(t,e){d(t>=0&&t<=1,function(){return"Progress fraction must be in range [0, 1], but got startFraction "+t}),d(e>=0&&e<=1,function(){return"Progress fraction must be in range [0, 1], but got endFraction "+e}),d(e>=t,function(){return"startFraction must be no more than endFraction, but got startFraction "+t+" and endFraction "+e})}(n=null==n?0:n,r=null==r?1:r);var o=0;return Promise.all(t.map(function(a){return a.then(function(a){var i=n+ ++o/t.length*(r-n);return e(i),a}),a}))}function rh(t,e){return r(this,void 0,void 0,function(){var n,r,a,i,s,u,l,c,h;return o(this,function(o){switch(o.label){case 0:return null==e&&(e={}),n=null==e.fetchFunc?J:e.fetchFunc,r=t.map(function(t){return n(t,e.requestInit)}),a=0,i=.5,null!=e.onProgress?[3,2]:[4,Promise.all(r)];case 1:return s=o.sent(),[3,4];case 2:return[4,nh(r,e.onProgress,a,i)];case 3:s=o.sent(),o.label=4;case 4:return u=s.map(function(t){return t.arrayBuffer()}),l=.5,c=1,null!=e.onProgress?[3,6]:[4,Promise.all(u)];case 5:return h=o.sent(),[3,8];case 6:return[4,nh(u,e.onProgress,l,c)];case 7:h=o.sent(),o.label=8;case 8:return[2,h]}})})}function oh(t){var e=this;return function(n,a,i){return void 0===a&&(a=""),r(e,void 0,void 0,function(){var e,r,s,u,l,c,h,p,f,d;return o(this,function(o){switch(o.label){case 0:if(e=n.map(function(){return!1}),r={},s=null!=i?i.map(function(){return!1}):[],u=[],n.forEach(function(t,n){var o=0;t.weights.forEach(function(t){var a="quantization"in t?t.quantization.dtype:t.dtype,l=yc[a]*y(t.shape),c=function(){e[n]=!0,null==r[n]&&(r[n]=[]),r[n].push({manifestEntry:t,groupOffset:o,sizeBytes:l})};null!=i?i.forEach(function(e,n){e===t.name&&(c(),s[n]=!0)}):c(),u.push(t.name),o+=l})}),!s.every(function(t){return t}))throw l=i.filter(function(t,e){return!s[e]}),new Error("Could not find weights in manifest with names: "+l.join(", ")+". \nManifest JSON has weights with names: "+u.join(", ")+".");return c=e.reduce(function(t,e,n){return e&&t.push(n),t},[]),h=[],c.forEach(function(t){n[t].paths.forEach(function(t){var e=a+(a.endsWith("/")?"":"/")+t;h.push(e)})}),[4,t(h)];case 1:return p=o.sent(),f={},d=0,c.forEach(function(t){for(var e=n[t].paths.length,o=0,a=0;a<e;a++)o+=p[d+a].byteLength;for(var i=new ArrayBuffer(o),s=new Uint8Array(i),u=0,l=0;l<e;l++){var c=new Uint8Array(p[d+l]);s.set(c,u),u+=c.byteLength}r[t].forEach(function(t){var e=xc(i.slice(t.groupOffset,t.groupOffset+t.sizeBytes),[t.manifestEntry]);for(var n in e)f[n]=e[n]}),d+=e}),[2,f]}})})}}Nc.registerSaveRouter(function(t){return a.getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(th.URL_SCHEME)?(e=t.slice(th.URL_SCHEME.length),void 0===e&&(e="model"),new th(e)):null;var e});var ah=function(){function t(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,null!=e.fetchFunc?(d("function"==typeof e.fetchFunc,function(){return"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"}),this.fetch=e.fetchFunc):this.fetch=J,d(null!=t&&t.length>0,function(){return"URL path for http must not be null, undefined or empty."}),Array.isArray(t)&&d(2===t.length,function(){return"URL paths for http must have a length of 2, (actual length is "+t.length+")."}),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}return t.prototype.save=function(t){return r(this,void 0,void 0,function(){var e,n,r,a;return o(this,function(o){switch(o.label){case 0:if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");return(e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit)).body=new FormData,n=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:n},e.body.append("model.json",new Blob([JSON.stringify(r)],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin"),[4,this.fetch(this.path,e)];case 1:if((a=o.sent()).ok)return[2,{modelArtifactsInfo:Sc(t),responses:[a]}];throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+a.status+".")}})})},t.prototype.load=function(){return r(this,void 0,void 0,function(){var t,e,n,r,a,i,s,u;return o(this,function(o){switch(o.label){case 0:return[4,this.fetch(this.path,this.requestInit)];case 1:if(!(t=o.sent()).ok)throw new Error("Request to "+this.path+" failed with status code "+t.status+". Please verify this URL points to the model JSON of the model to load.");o.label=2;case 2:return o.trys.push([2,4,,5]),[4,t.json()];case 3:return e=o.sent(),[3,5];case 4:throw o.sent(),n="Failed to parse model JSON of response from "+this.path+".",this.path.endsWith(".pb")?n+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":n+=" Please make sure the server is serving valid JSON for this request.",new Error(n);case 5:if(r=e.modelTopology,a=e.weightsManifest,null==r&&null==a)throw new Error("The JSON from HTTP path "+this.path+" contains neither model topology or manifest for weights.");return null==a?[3,7]:[4,this.loadWeights(a)];case 6:u=o.sent(),i=u[0],s=u[1],o.label=7;case 7:return[2,{modelTopology:r,weightSpecs:i,weightData:s}]}})})},t.prototype.loadWeights=function(t){return r(this,void 0,void 0,function(){var e,n,r,a,i,s,u,l,c,h,p;return o(this,function(o){switch(o.label){case 0:for(e=Array.isArray(this.path)?this.path[1]:this.path,n=function(t){var e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),o=n>e?t.substring(n):"";return[r+"/",o]}(e),r=n[0],a=n[1],i=this.weightPathPrefix||r,s=[],u=0,l=t;u<l.length;u++)c=l[u],s.push.apply(s,c.weights);return h=[],t.forEach(function(t){t.paths.forEach(function(t){h.push(i+t+a)})}),[4,rh(h,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress})];case 1:return p=o.sent(),[2,[s,Ec(p)]]}})})},t.URL_SCHEME_REGEX=/^https?:\/\//,t}();function ih(t){return null!=t.match(ah.URL_SCHEME_REGEX)}var sh=function(t,e){return(Array.isArray(t)?t.every(function(t){return ih(t)}):ih(t))?uh(t,{onProgress:e}):null};function uh(t,e){return new ah(t,e)}Nc.registerSaveRouter(sh),Nc.registerLoadRouter(sh);var lh=function(){function t(t,e,n){this.modelTopology=t,this.weightSpecs=e,this.weightData=n}return t.prototype.load=function(){return r(this,void 0,void 0,function(){var t;return o(this,function(e){return t={},null!=this.modelTopology&&(t=n({modelTopology:this.modelTopology},t)),null!=this.weightSpecs&&this.weightSpecs.length>0&&(t=n({weightSpecs:this.weightSpecs},t)),null!=this.weightData&&this.weightData.byteLength>0&&(t=n({weightData:this.weightData},t)),[2,t]})})},t}(),ch=function(){function t(t){this.saveHandler=t}return t.prototype.save=function(t){return r(this,void 0,void 0,function(){return o(this,function(e){return[2,this.saveHandler(t)]})})},t}();var hh=Object.freeze({browserFiles:function(t){return new eh(t)},browserHTTPRequest:function(t,e){return uh(t,e)},concatenateArrayBuffers:Ec,decodeWeights:xc,encodeWeights:function(t){return r(this,void 0,void 0,function(){var e,n,r,a;return o(this,function(o){switch(o.label){case 0:for(r in e=[],n=[],t){if("float32"!==(a=t[r]).dtype&&"int32"!==a.dtype&&"bool"!==a.dtype)throw new Error("Unsupported dtype in weight '"+r+"': "+a.dtype);e.push({name:r,shape:a.shape,dtype:a.dtype}),n.push(a.data())}return[4,Promise.all(n)];case 1:return[2,{data:wc(o.sent()),specs:e}]}})})},fromMemory:function(t,e,n){return new lh(t,e,n)},getLoadHandlers:function(t,e){return Nc.getLoadHandlers(t)},getModelArtifactsInfoForJSON:Sc,getSaveHandlers:function(t){return Nc.getSaveHandlers(t)},http:uh,isHTTPScheme:ih,loadWeights:function(t,e,n,a){return void 0===e&&(e=""),r(this,void 0,void 0,function(){return o(this,function(r){return[2,oh(function(t){return rh(t,{requestInit:a})})(t,e,n)]})})},registerLoadRouter:function(t){return Nc.registerLoadRouter(t)},registerSaveRouter:function(t){return Nc.registerSaveRouter(t)},weightsLoaderFactory:oh,withSaveHandler:function(t){return new ch(t)},copyModel:function(t,e){return r(this,void 0,void 0,function(){return o(this,function(n){return[2,Tc(t,e,!1)]})})},listModels:function(){return r(this,void 0,void 0,function(){var t,e,n,r,a,i,s;return o(this,function(o){switch(o.label){case 0:t=Ic.getSchemes(),e={},n=0,r=t,o.label=1;case 1:return n<r.length?(a=r[n],[4,Ic.getManager(a).listModels()]):[3,4];case 2:for(s in i=o.sent())e[a+kc+s]=i[s];o.label=3;case 3:return n++,[3,1];case 4:return[2,e]}})})},moveModel:function(t,e){return r(this,void 0,void 0,function(){return o(this,function(n){return[2,Tc(t,e,!0)]})})},removeModel:function(t){return r(this,void 0,void 0,function(){var e;return o(this,function(n){return e=Ac(t),[2,Ic.getManager(e.scheme).removeModel(e.path)]})})}});var ph=An({confusionMatrix_:function(t,e,n){var r=wn(t,"labels","confusionMatrix"),o=wn(e,"predictions","confusionMatrix");d(null==n||n>0&&Number.isInteger(n),function(){return"If provided, numClasses must be a positive integer, but got "+n}),d(1===r.rank,function(){return"Expected the rank of labels to be 1, but got "+r.rank}),d(1===o.rank,function(){return"Expected the rank of predictions to be 1, but got "+o.rank}),d(r.shape[0]===o.shape[0],function(){return"Mismatch in the number of examples: "+r.shape[0]+" vs. "+o.shape[0]+". Labels and predictions should have the same number of elements."}),d(n>0&&Number.isInteger(n),function(){return"numClasses is required to be a positive integer, but got "+n});var a=Br(r.asType("int32"),n),i=Br(o.asType("int32"),n);return a.transpose().matMul(i).asType("int32")}}),fh=Object.freeze({confusionMatrix:ph});var dh=An({fromPixels_:function(t,e){if(void 0===e&&(e=3),e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");return Dt.fromPixels(t,e)}}),vh=Object.freeze({toPixels:function(t,e){return r(this,void 0,void 0,function(){var n,r,a,i,s,u,l,c,h,p,f,d,v,m,g,y,x,w,b,C,E,R,S;return o(this,function(o){switch(o.label){case 0:if(n=wn(t,"img","toPixels"),t instanceof ft||(n=n.toInt()),2!==n.rank&&3!==n.rank)throw new Error("toPixels only supports rank 2 or 3 tensors, got rank "+n.rank+".");if(r=n.shape.slice(0,2),a=r[0],i=r[1],(s=2===n.rank?1:n.shape[2])>4||2===s)throw new Error("toPixels only supports depth of size 1, 3 or 4 but got "+s);return[4,n.data()];case 1:return u=o.sent(),l=n.min(),c=n.max(),[4,Promise.all([l.data(),c.data()])];case 2:if(h=o.sent(),p=h[0],f=h[1],d=p[0],v=f[0],l.dispose(),c.dispose(),"float32"===n.dtype){if(d<0||v>1)throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range ["+d+" - "+v+"].")}else{if("int32"!==n.dtype)throw new Error("Unsupported type for toPixels: "+n.dtype+". Please use float32 or int32 tensors.");if(d<0||v>255)throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range ["+d+" - "+v+"].")}for(m="float32"===n.dtype?255:1,g=new Uint8ClampedArray(i*a*4),y=0;y<a*i;++y)x=void 0,w=void 0,b=void 0,C=void 0,1===s?(x=u[y]*m,w=u[y]*m,b=u[y]*m,C=255):3===s?(x=u[3*y]*m,w=u[3*y+1]*m,b=u[3*y+2]*m,C=255):4===s&&(x=u[4*y]*m,w=u[4*y+1]*m,b=u[4*y+2]*m,C=u[4*y+3]*m),g[0+(E=4*y)]=Math.round(x),g[E+1]=Math.round(w),g[E+2]=Math.round(b),g[E+3]=Math.round(C);return null!=e&&(e.width=i,e.height=a,R=e.getContext("2d"),S=new ImageData(g,i,a),R.putImageData(S,0,0)),n!==t&&n.dispose(),[2,g]}})})},fromPixels:dh}),mh=function(){function t(){}return t.prototype.getClassName=function(){return this.constructor.className},t.fromConfig=function(t,e){return new t(e)},t}(),gh=function(){function t(){this.classNameMap={}}return t.getMap=function(){return null==t.instance&&(t.instance=new t),t.instance},t.register=function(e){t.getMap().classNameMap[e.className]=[e,e.fromConfig]},t}();function yh(t){d(null!=t.className,function(){return"Class being registered does not have the static className property defined."}),d("string"==typeof t.className,function(){return"className is required to be a string, but got type "+typeof t.className}),d(t.className.length>0,function(){return"Class being registered has an empty-string as its className, which is disallowed."}),gh.register(t)}var xh=Object.freeze({Serializable:mh,SerializationMap:gh,registerClass:yh}),wh=.001,bh=.1;function Ch(){return 32===Dt.backend.floatPrecision()?wh:bh}function Eh(t,e,n){var r=!0;if((_(t)||_(e))&&(r=!1),_(t)&&_(e)&&(r=!0),r){var o=t.constructor.name,a=e.constructor.name;if(o!==a)throw new Error("Arrays are of different type. Actual: "+o+". Expected: "+a)}if(Array.isArray(t)&&Array.isArray(e)){var i=yn(t),s=yn(e);if(!x(i,s))throw new Error("Arrays have different shapes. Actual: ["+i+"]. Expected: ["+s+"]")}var u=_(t)?t:g(t),l=_(e)?e:g(e);if(u.length!==l.length)throw new Error("Arrays have different lengths actual: "+u.length+" vs expected: "+l.length+".\nActual:   "+u+".\nExpected: "+l+".");for(var c=0;c<l.length;++c){var h=u[c],p=l[c];if(!n(h,p))throw new Error("Arrays differ: actual["+c+"] = "+h+", expected["+c+"] = "+p+".\nActual:   "+u+".\nExpected: "+l+".")}}function Rh(t,e,n){return!isFinite(t)&&!isFinite(e)||!(isNaN(t)||isNaN(e)||Math.abs(t-e)>n)}var Sh=Object.freeze({TEST_EPSILON_FLOAT16:bh,expectArraysClose:function(t,e,n){return null==n&&(n=Ch()),Eh(t,e,function(t,e){return Rh(t,e,n)})},testEpsilon:Ch,expectPromiseToFail:function(t,e){t().then(function(){return e.fail()},function(){return e()})},expectArraysEqual:function(t,e){var n="string"==typeof e||"number"==typeof e||"boolean"==typeof e?[e]:e;return B(t)||B(t[0])||B(e)||B(e[0])?Eh(t,n,function(t,e){return t==e}):Eh(t,e,function(t,e){return Rh(t,e,0)})},expectNumbersClose:function(t,e,n){if(null==n&&(n=Ch()),!Rh(t,e,n))throw new Error("Numbers differ: actual === "+t+", expected === "+e)},expectValuesInRange:function(t,e,n){for(var r=0;r<t.length;r++)if(t[r]<e||t[r]>n)throw new Error("Value out of range:"+t[r]+" low: "+e+", high: "+n)},expectArrayBuffersEqual:function(t,e){expect(new Float32Array(t)).toEqual(new Float32Array(e))}}),Nh="1.1.2",kh=Object.freeze({gpgpu_util:La,webgl_util:ke,MathBackendWebGL:Ui,GPGPUContext:Wa}),Ih=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return e(n,t),n.prototype.minimize=function(t,e,n){void 0===e&&(e=!1);var r=this.computeGradients(t,n),o=r.value,a=r.grads;return this.applyGradients(a),Object.keys(a).forEach(function(t){return a[t].dispose()}),e?o:(o.dispose(),null)},n.prototype.computeGradients=function(t,e){return Nn(t,e)},n.prototype.dispose=function(){},n}(mh);Object.defineProperty(Ih,Symbol.hasInstance,{value:function(t){return null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients}});var Ah=function(t){function n(e,n,r){void 0===r&&(r=null);var o=t.call(this)||this;return o.learningRate=e,o.rho=n,o.epsilon=r,o.accumulatedGrads={},o.accumulatedUpdates={},null==r&&(o.epsilon=Dt.backend.epsilon()),o}return e(n,t),n.prototype.applyGradients=function(t){var e=this,n=function(n){var o=Dt.registeredVariables[n];if(null==r.accumulatedGrads[n]){Fe(function(){e.accumulatedGrads[n]=Xn(o).variable(!1)})}if(null==r.accumulatedUpdates[n]){Fe(function(){e.accumulatedUpdates[n]=Xn(o).variable(!1)})}var a=t[n],i=r.accumulatedGrads[n],s=r.accumulatedUpdates[n];Fe(function(){var t=i.mul(e.rho).add(a.square().mul(1-e.rho)),r=s.add(e.epsilon).sqrt().div(i.add(e.epsilon).sqrt()).mul(a),u=s.mul(e.rho).add(r.square().mul(1-e.rho));e.accumulatedGrads[n].assign(t),e.accumulatedUpdates[n].assign(u);var l=r.mul(-e.learningRate).add(o);o.assign(l)})},r=this;for(var o in t)n(o)},n.prototype.dispose=function(){var t=this;null!=this.accumulatedUpdates&&(Object.keys(this.accumulatedUpdates).forEach(function(e){return t.accumulatedUpdates[e].dispose()}),Object.keys(this.accumulatedGrads).forEach(function(e){return t.accumulatedGrads[e].dispose()}))},n.prototype.getConfig=function(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}},n.fromConfig=function(t,e){return new t(e.learningRate,e.rho,e.epsilon)},n.className="AdadeltaOptimizer",n}(Ih);yh(Ah);var Th=function(t){function n(e,n){void 0===n&&(n=.1);var r=t.call(this)||this;return r.learningRate=e,r.initialAccumulatorValue=n,r.accumulatedGrads={},r}return e(n,t),n.prototype.applyGradients=function(t){var e=this,n=function(n){var o=Dt.registeredVariables[n];if(null==r.accumulatedGrads[n]){Fe(function(){e.accumulatedGrads[n]=Hn(o.shape,e.initialAccumulatorValue).variable(!1)})}var a=t[n],i=r.accumulatedGrads[n];Fe(function(){var t=i.add(a.square());e.accumulatedGrads[n].assign(t);var r=a.div(t.add(Dt.backend.epsilon()).sqrt()).mul(-e.learningRate).add(o);o.assign(r)})},r=this;for(var o in t)n(o)},n.prototype.dispose=function(){var t=this;null!=this.accumulatedGrads&&Object.keys(this.accumulatedGrads).forEach(function(e){return t.accumulatedGrads[e].dispose()})},n.prototype.getConfig=function(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}},n.fromConfig=function(t,e){return new t(e.learningRate,e.initialAccumulatorValue)},n.className="AdagradOptimizer",n}(Ih);yh(Th);var Dh=function(t){function n(e,n,r,o){void 0===o&&(o=null);var a=t.call(this)||this;return a.learningRate=e,a.beta1=n,a.beta2=r,a.epsilon=o,a.accumulatedFirstMoment={},a.accumulatedSecondMoment={},Fe(function(){a.accBeta1=Bn(n).variable(),a.accBeta2=Bn(r).variable()}),null==o&&(a.epsilon=Dt.backend.epsilon()),a}return e(n,t),n.prototype.applyGradients=function(t){var e=this;Fe(function(){var n=ll(1,e.accBeta1),r=ll(1,e.accBeta2);for(var o in t){var a=Dt.registeredVariables[o];if(null==e.accumulatedFirstMoment[o]){var i=!1;e.accumulatedFirstMoment[o]=Xn(a).variable(i)}if(null==e.accumulatedSecondMoment[o]){i=!1;e.accumulatedSecondMoment[o]=Xn(a).variable(i)}var s=t[o],u=e.accumulatedFirstMoment[o],l=e.accumulatedSecondMoment[o],c=u.mul(e.beta1).add(s.mul(1-e.beta1)),h=l.mul(e.beta2).add(s.square().mul(1-e.beta2)),p=c.div(n),f=h.div(r);e.accumulatedFirstMoment[o].assign(c),e.accumulatedSecondMoment[o].assign(h);var d=p.div(f.sqrt().add(e.epsilon)).mul(-e.learningRate).add(a);a.assign(d)}e.accBeta1.assign(e.accBeta1.mul(e.beta1)),e.accBeta2.assign(e.accBeta2.mul(e.beta2))})},n.prototype.dispose=function(){var t=this;this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Object.keys(this.accumulatedFirstMoment).forEach(function(e){return t.accumulatedFirstMoment[e].dispose()}),null!=this.accumulatedSecondMoment&&Object.keys(this.accumulatedSecondMoment).forEach(function(e){return t.accumulatedSecondMoment[e].dispose()})},n.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}},n.fromConfig=function(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)},n.className="AdamOptimizer",n}(Ih);yh(Dh);var Oh=function(t){function n(e,n,r,o,a){void 0===o&&(o=null),void 0===a&&(a=0);var i=t.call(this)||this;return i.learningRate=e,i.beta1=n,i.beta2=r,i.epsilon=o,i.decay=a,i.accumulatedFirstMoment={},i.accumulatedWeightedInfNorm={},Fe(function(){i.iteration=Bn(0).variable(),i.accBeta1=Bn(n).variable()}),null==o&&(i.epsilon=Dt.backend.epsilon()),i}return e(n,t),n.prototype.applyGradients=function(t){var e=this;Fe(function(){var n=ll(1,e.accBeta1),r=Ku(-e.learningRate,e.iteration.mul(e.decay).add(1));for(var o in t){var a=Dt.registeredVariables[o];if(null==e.accumulatedFirstMoment[o]){var i=!1;e.accumulatedFirstMoment[o]=Xn(a).variable(i)}if(null==e.accumulatedWeightedInfNorm[o]){i=!1;e.accumulatedWeightedInfNorm[o]=Xn(a).variable(i)}var s=t[o],u=e.accumulatedFirstMoment[o],l=e.accumulatedWeightedInfNorm[o],c=u.mul(e.beta1).add(s.mul(1-e.beta1)),h=l.mul(e.beta2),p=s.abs(),f=h.maximum(p);e.accumulatedFirstMoment[o].assign(c),e.accumulatedWeightedInfNorm[o].assign(f);var d=r.div(n).mul(c.div(f.add(e.epsilon))).add(a);a.assign(d)}e.iteration.assign(e.iteration.add(1)),e.accBeta1.assign(e.accBeta1.mul(e.beta1))})},n.prototype.dispose=function(){var t=this;this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Object.keys(this.accumulatedFirstMoment).forEach(function(e){return t.accumulatedFirstMoment[e].dispose()}),null!=this.accumulatedWeightedInfNorm&&Object.keys(this.accumulatedWeightedInfNorm).forEach(function(e){return t.accumulatedWeightedInfNorm[e].dispose()})},n.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}},n.fromConfig=function(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)},n.className="AdamaxOptimizer",n}(Ih);yh(Oh);var _h=function(t){function n(e){var n=t.call(this)||this;return n.learningRate=e,n.setLearningRate(e),n}return e(n,t),n.prototype.applyGradients=function(t){var e=this;Object.keys(t).forEach(function(n){var r=t[n],o=Dt.registeredVariables[n];Fe(function(){var t=e.c.mul(r).add(o);o.assign(t)})})},n.prototype.setLearningRate=function(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=Pe(Bn(-t))},n.prototype.dispose=function(){this.c.dispose()},n.prototype.getConfig=function(){return{learningRate:this.learningRate}},n.fromConfig=function(t,e){return new t(e.learningRate)},n.className="SGDOptimizer",n}(Ih);yh(_h);var Mh=function(t){function n(e,n,r){void 0===r&&(r=!1);var o=t.call(this,e)||this;return o.learningRate=e,o.momentum=n,o.useNesterov=r,o.m=Bn(o.momentum),o.accumulations={},o}return e(n,t),n.prototype.applyGradients=function(t){var e=this,n=function(n){var o=Dt.registeredVariables[n];if(null==r.accumulations[n]){Fe(function(){e.accumulations[n]=Xn(o).variable(!1)})}var a=r.accumulations[n],i=t[n];Fe(function(){var t,r=e.m.mul(a).add(i);t=e.useNesterov?e.c.mul(i.add(r.mul(e.m))).add(o):e.c.mul(r).add(o),e.accumulations[n].assign(r),o.assign(t)})},r=this;for(var o in t)n(o)},n.prototype.dispose=function(){if(t.prototype.dispose.call(this),this.m.dispose(),null!=this.accumulations)for(var e in this.accumulations)this.accumulations[e].dispose()},n.prototype.setMomentum=function(t){this.momentum=t},n.prototype.getConfig=function(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}},n.fromConfig=function(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)},n.className="MomentumOptimizer",n}(_h);yh(Mh);var Fh=function(t){function n(e,n,r,o,a){void 0===n&&(n=.9),void 0===r&&(r=0),void 0===o&&(o=null),void 0===a&&(a=!1);var i=t.call(this)||this;return i.learningRate=e,i.decay=n,i.momentum=r,i.epsilon=o,i.accumulatedMeanSquares={},i.accumulatedMeanGrads={},i.accumulatedMoments={},i.centered=a,null==o&&(i.epsilon=Dt.backend.epsilon()),i}return e(n,t),n.prototype.applyGradients=function(t){var e=this,n=function(n){var o=Dt.registeredVariables[n];if(null==r.accumulatedMeanSquares[n]){Fe(function(){e.accumulatedMeanSquares[n]=Xn(o).variable(!1)})}if(null==r.accumulatedMeanGrads[n]&&r.centered){Fe(function(){e.accumulatedMeanGrads[n]=Xn(o).variable(!1)})}if(null==r.accumulatedMoments[n]){Fe(function(){e.accumulatedMoments[n]=Xn(o).variable(!1)})}var a=r.accumulatedMeanSquares[n],i=r.accumulatedMeanGrads[n],s=r.accumulatedMoments[n],u=t[n];Fe(function(){var t=a.mul(e.decay).add(u.square().mul(1-e.decay));if(e.centered){var r=i.mul(e.decay).add(u.mul(1-e.decay)),l=s.mul(e.momentum).add(u.mul(e.learningRate).div(t.sub(r.square().add(e.epsilon)).sqrt()));e.accumulatedMeanSquares[n].assign(t),e.accumulatedMeanGrads[n].assign(r),e.accumulatedMoments[n].assign(l);var c=o.sub(l);o.assign(c)}else{var h=a.mul(e.decay).add(u.square().mul(1-e.decay));l=s.mul(e.momentum).add(u.mul(e.learningRate).div(h.add(e.epsilon).sqrt()));e.accumulatedMeanSquares[n].assign(h),e.accumulatedMoments[n].assign(l);c=o.sub(l);o.assign(c)}})},r=this;for(var o in t)n(o)},n.prototype.dispose=function(){var t=this;null!=this.accumulatedMeanSquares&&Object.keys(this.accumulatedMeanSquares).forEach(function(e){return t.accumulatedMeanSquares[e].dispose()}),null!=this.accumulatedMeanGrads&&this.centered&&Object.keys(this.accumulatedMeanGrads).forEach(function(e){return t.accumulatedMeanGrads[e].dispose()}),null!=this.accumulatedMoments&&Object.keys(this.accumulatedMoments).forEach(function(e){return t.accumulatedMoments[e].dispose()})},n.prototype.getConfig=function(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}},n.fromConfig=function(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)},n.className="RMSPropOptimizer",n}(Ih);yh(Fh);var Bh=function(){function t(){}return t.sgd=function(t){return new _h(t)},t.momentum=function(t,e,n){return void 0===n&&(n=!1),new Mh(t,e,n)},t.rmsprop=function(t,e,n,r,o){return void 0===e&&(e=.9),void 0===n&&(n=0),void 0===r&&(r=null),void 0===o&&(o=!1),new Fh(t,e,n,r,o)},t.adam=function(t,e,n,r){return void 0===t&&(t=.001),void 0===e&&(e=.9),void 0===n&&(n=.999),void 0===r&&(r=null),new Dh(t,e,n,r)},t.adadelta=function(t,e,n){return void 0===t&&(t=.001),void 0===e&&(e=.95),void 0===n&&(n=null),new Ah(t,e,n)},t.adamax=function(t,e,n,r,o){return void 0===t&&(t=.002),void 0===e&&(e=.9),void 0===n&&(n=.999),void 0===r&&(r=null),void 0===o&&(o=0),new Oh(t,e,n,r,o)},t.adagrad=function(t,e){return void 0===e&&(e=.1),new Th(t,e)},t}(),Ph={sgd:Bh.sgd,momentum:Bh.momentum,adadelta:Bh.adadelta,adagrad:Bh.adagrad,rmsprop:Bh.rmsprop,adamax:Bh.adamax,adam:Bh.adam},Lh="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:function(t){return t()};function Wh(){return new Promise(function(t){return Lh(function(){return t()})})}ht=mc;
//# sourceMappingURL=tf-core.esm.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/timers-browserify/main.js */ "./node_modules/node-libs-browser/node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-data/dist/tf-data.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-data/dist/tf-data.esm.js ***!
  \****************************************************************/
/*! exports provided: array, Dataset, zip, CSVDataset, TextLineDataset, csv, func, generator, webcam, FileDataSource, URLDataSource, version_data */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, process, Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "array", function() { return array; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Dataset", function() { return Dataset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return zip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSVDataset", function() { return CSVDataset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextLineDataset", function() { return TextLineDataset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csv", function() { return csv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "func", function() { return func; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generator", function() { return generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "webcam", function() { return webcam; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileDataSource", function() { return FileDataSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "URLDataSource", function() { return URLDataSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version_data", function() { return version; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var extendStatics=function(t,e){return(extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var r in e)e.hasOwnProperty(r)&&(t[r]=e[r])})(t,e)};function __extends(t,e){function r(){this.constructor=t}extendStatics(t,e),t.prototype=null===e?Object.create(e):(r.prototype=e.prototype,new r)}function __awaiter(t,e,r,n){return new(r||(r=Promise))(function(i,o){function a(t){try{s(n.next(t))}catch(t){o(t)}}function u(t){try{s(n.throw(t))}catch(t){o(t)}}function s(t){t.done?i(t.value):new r(function(e){e(t.value)}).then(a,u)}s((n=n.apply(t,e||[])).next())})}function __generator(t,e){var r,n,i,o,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:u(0),throw:u(1),return:u(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function u(o){return function(u){return function(o){if(r)throw new TypeError("Generator is already executing.");for(;a;)try{if(r=1,n&&(i=2&o[0]?n.return:o[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,o[1])).done)return i;switch(n=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return a.label++,{value:o[1],done:!1};case 5:a.label++,n=o[1],o=[0];continue;case 7:o=a.ops.pop(),a.trys.pop();continue;default:if(!(i=(i=a.trys).length>0&&i[i.length-1])&&(6===o[0]||2===o[0])){a=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){a.label=o[1];break}if(6===o[0]&&a.label<i[1]){a.label=i[1],i=o;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(o);break}i[2]&&a.ops.pop(),a.trys.pop();continue}o=e.call(t,a)}catch(t){o=[6,t],n=0}finally{r=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,u])}}}var commonjsGlobal="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function unwrapExports(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}function createCommonjsModule(t,e){return t(e={exports:{}},e.exports),e.exports}var alea=createCommonjsModule(function(t){!function(t,e,r){function n(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function i(t,e){var r=new function(t){var e,r=this,n=(e=4022871197,function(t){t=t.toString();for(var r=0;r<t.length;r++){var n=.02519603282416938*(e+=t.charCodeAt(r));n-=e=n>>>0,e=(n*=e)>>>0,e+=4294967296*(n-=e)}return 2.3283064365386963e-10*(e>>>0)});r.next=function(){var t=2091639*r.s0+2.3283064365386963e-10*r.c;return r.s0=r.s1,r.s1=r.s2,r.s2=t-(r.c=0|t)},r.c=1,r.s0=n(" "),r.s1=n(" "),r.s2=n(" "),r.s0-=n(t),r.s0<0&&(r.s0+=1),r.s1-=n(t),r.s1<0&&(r.s1+=1),r.s2-=n(t),r.s2<0&&(r.s2+=1),n=null}(t),i=e&&e.state,o=r.next;return o.int32=function(){return 4294967296*r.next()|0},o.double=function(){return o()+1.1102230246251565e-16*(2097152*o()|0)},o.quick=o,i&&("object"==typeof i&&n(i,r),o.state=function(){return n(r,{})}),o}e&&e.exports?e.exports=i:r&&r.amd?r(function(){return i}):this.alea=i}(0,t,!1)}),xor128=createCommonjsModule(function(t){!function(t,e,r){function n(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function i(t,e){var r=new function(t){var e=this,r="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:r+=t;for(var n=0;n<r.length+64;n++)e.x^=0|r.charCodeAt(n),e.next()}(t),i=e&&e.state,o=function(){return(r.next()>>>0)/4294967296};return o.double=function(){do{var t=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=r.next,o.quick=o,i&&("object"==typeof i&&n(i,r),o.state=function(){return n(r,{})}),o}e&&e.exports?e.exports=i:r&&r.amd?r(function(){return i}):this.xor128=i}(0,t,!1)}),xorwow=createCommonjsModule(function(t){!function(t,e,r){function n(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function i(t,e){var r=new function(t){var e=this,r="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:r+=t;for(var n=0;n<r.length+64;n++)e.x^=0|r.charCodeAt(n),n==r.length&&(e.d=e.x<<10^e.x>>>4),e.next()}(t),i=e&&e.state,o=function(){return(r.next()>>>0)/4294967296};return o.double=function(){do{var t=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=r.next,o.quick=o,i&&("object"==typeof i&&n(i,r),o.state=function(){return n(r,{})}),o}e&&e.exports?e.exports=i:r&&r.amd?r(function(){return i}):this.xorwow=i}(0,t,!1)}),xorshift7=createCommonjsModule(function(t){!function(t,e,r){function n(t,e){return e.x=t.x.slice(),e.i=t.i,e}function i(t,e){null==t&&(t=+new Date);var r=new function(t){var e=this;e.next=function(){var t,r,n=e.x,i=e.i;return t=n[i],r=(t^=t>>>7)^t<<24,r^=(t=n[i+1&7])^t>>>10,r^=(t=n[i+3&7])^t>>>3,r^=(t=n[i+4&7])^t<<7,t=n[i+7&7],r^=(t^=t<<13)^t<<9,n[i]=r,e.i=i+1&7,r},function(t,e){var r,n=[];if(e===(0|e))n[0]=e;else for(e=""+e,r=0;r<e.length;++r)n[7&r]=n[7&r]<<15^e.charCodeAt(r)+n[r+1&7]<<13;for(;n.length<8;)n.push(0);for(r=0;r<8&&0===n[r];++r);for(8==r?n[7]=-1:n[r],t.x=n,t.i=0,r=256;r>0;--r)t.next()}(e,t)}(t),i=e&&e.state,o=function(){return(r.next()>>>0)/4294967296};return o.double=function(){do{var t=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=r.next,o.quick=o,i&&(i.x&&n(i,r),o.state=function(){return n(r,{})}),o}e&&e.exports?e.exports=i:r&&r.amd?r(function(){return i}):this.xorshift7=i}(0,t,!1)}),xor4096=createCommonjsModule(function(t){!function(t,e,r){function n(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function i(t,e){null==t&&(t=+new Date);var r=new function(t){var e=this;e.next=function(){var t,r,n=e.w,i=e.X,o=e.i;return e.w=n=n+1640531527|0,r=i[o+34&127],t=i[o=o+1&127],r^=r<<13,t^=t<<17,r^=r>>>15,t^=t>>>12,r=i[o]=r^t,e.i=o,r+(n^n>>>16)|0},function(t,e){var r,n,i,o,a,u=[],s=128;for(e===(0|e)?(n=e,e=null):(e+="\0",n=0,s=Math.max(s,e.length)),i=0,o=-32;o<s;++o)e&&(n^=e.charCodeAt((o+32)%e.length)),0===o&&(a=n),n^=n<<10,n^=n>>>15,n^=n<<4,n^=n>>>13,o>=0&&(a=a+1640531527|0,i=0==(r=u[127&o]^=n+a)?i+1:0);for(i>=128&&(u[127&(e&&e.length||0)]=-1),i=127,o=512;o>0;--o)n=u[i+34&127],r=u[i=i+1&127],n^=n<<13,r^=r<<17,n^=n>>>15,r^=r>>>12,u[i]=n^r;t.w=a,t.X=u,t.i=i}(e,t)}(t),i=e&&e.state,o=function(){return(r.next()>>>0)/4294967296};return o.double=function(){do{var t=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=r.next,o.quick=o,i&&(i.X&&n(i,r),o.state=function(){return n(r,{})}),o}e&&e.exports?e.exports=i:r&&r.amd?r(function(){return i}):this.xor4096=i}(0,t,!1)}),tychei=createCommonjsModule(function(t){!function(t,e,r){function n(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function i(t,e){var r=new function(t){var e=this,r="";e.next=function(){var t=e.b,r=e.c,n=e.d,i=e.a;return t=t<<25^t>>>7^r,r=r-n|0,n=n<<24^n>>>8^i,i=i-t|0,e.b=t=t<<20^t>>>12^r,e.c=r=r-n|0,e.d=n<<16^r>>>16^i,e.a=i-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):r+=t;for(var n=0;n<r.length+20;n++)e.b^=0|r.charCodeAt(n),e.next()}(t),i=e&&e.state,o=function(){return(r.next()>>>0)/4294967296};return o.double=function(){do{var t=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=r.next,o.quick=o,i&&("object"==typeof i&&n(i,r),o.state=function(){return n(r,{})}),o}e&&e.exports?e.exports=i:r&&r.amd?r(function(){return i}):this.tychei=i}(0,t,!1)}),seedrandom=createCommonjsModule(function(t){!function(e,r){var n,i=this,o=256,a=6,u="random",s=r.pow(o,a),c=r.pow(2,52),l=2*c,f=o-1;function h(t,h,v){var y=[],_=d(function t(e,r){var n,i=[],o=typeof e;if(r&&"object"==o)for(n in e)try{i.push(t(e[n],r-1))}catch(t){}return i.length?i:"string"==o?e:e+"\0"}((h=1==h?{entropy:!0}:h||{}).entropy?[t,m(e)]:null==t?function(){try{var t;return n&&(t=n.randomBytes)?t=t(o):(t=new Uint8Array(o),(i.crypto||i.msCrypto).getRandomValues(t)),m(t)}catch(t){var r=i.navigator,a=r&&r.plugins;return[+new Date,i,a,i.screen,m(e)]}}():t,3),y),w=new function(t){var e,r=t.length,n=this,i=0,a=n.i=n.j=0,u=n.S=[];r||(t=[r++]);for(;i<o;)u[i]=i++;for(i=0;i<o;i++)u[i]=u[a=f&a+t[i%r]+(e=u[i])],u[a]=e;(n.g=function(t){for(var e,r=0,i=n.i,a=n.j,u=n.S;t--;)e=u[i=f&i+1],r=r*o+u[f&(u[i]=u[a=f&a+e])+(u[a]=e)];return n.i=i,n.j=a,r})(o)}(y),g=function(){for(var t=w.g(a),e=s,r=0;t<c;)t=(t+r)*o,e*=o,r=w.g(1);for(;t>=l;)t/=2,e/=2,r>>>=1;return(t+r)/e};return g.int32=function(){return 0|w.g(4)},g.quick=function(){return w.g(4)/4294967296},g.double=g,d(m(w.S),e),(h.pass||v||function(t,e,n,i){return i&&(i.S&&p(i,w),t.state=function(){return p(w,{})}),n?(r[u]=t,e):t})(g,_,"global"in h?h.global:this==r,h.state)}function p(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function d(t,e){for(var r,n=t+"",i=0;i<n.length;)e[f&i]=f&(r^=19*e[f&i])+n.charCodeAt(i++);return m(e)}function m(t){return String.fromCharCode.apply(0,t)}if(r["seed"+u]=h,d(r.random(),e),t.exports){t.exports=h;try{n=__webpack_require__(/*! crypto */ "./node_modules/crypto-browserify/index.js")}catch(t){}}else 0}([],Math)});seedrandom.alea=alea,seedrandom.xor128=xor128,seedrandom.xorwow=xorwow,seedrandom.xorshift7=xorshift7,seedrandom.xor4096=xor4096,seedrandom.tychei=tychei;var seedrandom$1=seedrandom,seedrandom_1=seedrandom$1.alea;function deepMapInternal(t,e,r,n){if(void 0===r&&(r=new Map),void 0===n&&(n=new Set),null==t)return null;if(n.has(t))throw new Error("Circular references are not supported.");if(r.has(t))return r.get(t);var i=e(t);if(i.recurse&&null!==i.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(i.recurse){if(isIterable(t)){var o=Array.isArray(t)?[]:{};for(var a in n.add(t),t){var u=deepMapInternal(t[a],e,r,n);o[a]=u}return n.delete(t),o}throw new Error("Can't recurse into non-iterable type: "+t)}return r.set(t,i.value),i.value}function deepZip(t,e){return void 0===e&&(e=zipToList),deepZipInternal(t,e)}function deepZipInternal(t,e,r){void 0===r&&(r=new Set);var n=t[0];if(r.has(n))throw new Error("Circular references are not supported.");var i=e(t);if(i.recurse&&null!==i.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(i.recurse){if(isIterable(n)){var o=Array.isArray(n)?[]:{};r.add(n);var a=function(n){var i=deepZipInternal(t.map(function(t){return t[n]}),e,r);o[n]=i};for(var u in n)a(u);return r.delete(n),o}throw new Error("Can't recurse into non-iterable type: "+n)}return i.value}function zipToList(t){return null===t?null:isIterable(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}function deepMapAndAwaitAll(t,e){return __awaiter(this,void 0,void 0,function(){var r,n,i,o,a,u;return __generator(this,function(s){switch(s.label){case 0:r=new Map,deepMapInternal(t,e,r),n=0,i=Array.from(r.keys()),s.label=1;case 1:return n<i.length?(o=i[n],(a=r.get(o))instanceof Promise?[4,a]:[3,3]):[3,4];case 2:u=s.sent(),r.set(o,u),s.label=3;case 3:return n++,[3,1];case 4:return[2,deepMapInternal(t,e,r)]}})})}function isIterable(t){return null!=t&&(Array.isArray(t)||"object"==typeof t&&!(t instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]))}function canTensorify(t){return null==t||isPrimitive(t)||Array.isArray(t)||"object"==typeof t&&t instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]||_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].isTypedArray(t)}function isPrimitive(t){return null===t||"object"!=typeof t&&"function"!=typeof t}var RingBuffer=function(){function t(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}return t.prototype.wrap=function(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity},t.prototype.get=function(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]},t.prototype.set=function(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e},t.prototype.length=function(){var t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t},t.prototype.isFull=function(){return this.length()===this.capacity},t.prototype.isEmpty=function(){return 0===this.length()},t.prototype.push=function(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)},t.prototype.pushAll=function(t){for(var e=0,r=t;e<r.length;e++){var n=r[e];this.push(n)}},t.prototype.pop=function(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);var t=this.get(this.end);return this.set(this.end,void 0),t},t.prototype.unshift=function(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)},t.prototype.shift=function(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");var t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t},t.prototype.shuffleExcise=function(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");var e=this.wrap(this.begin+t),r=this.get(e);return this.set(e,this.pop()),r},t}(),GrowingRingBuffer=function(t){function e(){return t.call(this,e.INITIAL_CAPACITY)||this}return __extends(e,t),e.prototype.isFull=function(){return!1},e.prototype.push=function(e){t.prototype.isFull.call(this)&&this.expand(),t.prototype.push.call(this,e)},e.prototype.unshift=function(e){t.prototype.isFull.call(this)&&this.expand(),t.prototype.unshift.call(this,e)},e.prototype.expand=function(){for(var t=2*this.capacity,e=new Array(t),r=this.length(),n=0;n<r;n++)e[n]=this.get(this.wrap(this.begin+n));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r},e.INITIAL_CAPACITY=32,e}(RingBuffer);function iteratorFromItems(t){return new ArrayIterator(t)}function iteratorFromFunction(t){return new FunctionCallIterator(t)}function iteratorFromConcatenated(t,e){return new ChainedIterator(t,e)}function iteratorFromZipped(t,e){return void 0===e&&(e=ZipMismatchMode.FAIL),new ZipIterator(t,e)}var ZipMismatchMode,LazyIterator=function(){function t(){}return t.prototype.toArray=function(){return __awaiter(this,void 0,void 0,function(){var t,e;return __generator(this,function(r){switch(r.label){case 0:return t=[],[4,this.next()];case 1:e=r.sent(),r.label=2;case 2:return e.done?[3,4]:(t.push(e.value),[4,this.next()]);case 3:return e=r.sent(),[3,2];case 4:return[2,t]}})})},t.prototype.toArrayForTest=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r;return __generator(this,function(n){switch(n.label){case 0:return t=this.prefetch(100),e=[],[4,t.next()];case 1:r=n.sent(),n.label=2;case 2:return r.done?[3,4]:(e.push(r.value),[4,t.next()]);case 3:return r=n.sent(),[3,2];case 4:return[2,e]}})})},t.prototype.resolveFully=function(){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(e){switch(e.label){case 0:return[4,this.next()];case 1:t=e.sent(),e.label=2;case 2:return t.done?[3,4]:[4,this.next()];case 3:return t=e.sent(),[3,2];case 4:return[2]}})})},t.prototype.resolveWhile=function(t){return __awaiter(this,void 0,void 0,function(){var e,r;return __generator(this,function(n){switch(n.label){case 0:return[4,this.next()];case 1:e=n.sent(),r=t(e.value),n.label=2;case 2:return e.done||!r?[3,4]:[4,this.next()];case 3:return e=n.sent(),r=t(e.value),[3,2];case 4:return[2]}})})},t.prototype.handleErrors=function(t){return new ErrorHandlingLazyIterator(this,t)},t.prototype.filter=function(t){return new FilterIterator(this,t)},t.prototype.map=function(t){return new MapIterator(this,t)},t.prototype.mapAsync=function(t){return new AsyncMapIterator(this,t)},t.prototype.serialMapAsync=function(t){return new AsyncMapIterator(this,t).serial()},t.prototype.flatmap=function(t){return new FlatmapIterator(this,t)},t.prototype.forEachAsync=function(t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2,this.map(t).resolveFully()]})})},t.prototype.serialForEach=function(t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2,this.serialMapAsync(t).resolveWhile(function(t){return!0===t})]})})},t.prototype.rowMajorBatch=function(t,e){return void 0===e&&(e=!0),new RowMajorBatchIterator(this,t,e)},t.prototype.columnMajorBatch=function(t,e,r){return void 0===e&&(e=!0),void 0===r&&(r=zipToList),this.rowMajorBatch(t,e).map(function(t){return deepZip(t,r)})},t.prototype.concatenate=function(t,e){return new ChainedIterator(iteratorFromItems([this,t]),e)},t.prototype.take=function(t){return t<0||null==t?this:new TakeIterator(this,t)},t.prototype.skip=function(t){return t<0||null==t?this:new SkipIterator(this,t)},t.prototype.prefetch=function(t){return new PrefetchIterator(this,t)},t.prototype.shuffle=function(t,e){return new ShuffleIterator(this,t,e)},t.prototype.serial=function(){return new SerialIterator(this)},t}(),ArrayIterator=function(t){function e(e){var r=t.call(this)||this;return r.items=e,r.trav=0,r}return __extends(e,t),e.prototype.summary=function(){return"Array of "+this.items.length+" items"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t,e;return __generator(this,function(r){return this.trav>=this.items.length?[2,{value:null,done:!0}]:(t=this.items[this.trav],e=t instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clone"])(t):t,this.trav++,[2,{value:e,done:!1}])})})},e}(LazyIterator),FunctionCallIterator=function(t){function e(e){var r=t.call(this)||this;return r.nextFn=e,r}return __extends(e,t),e.prototype.summary=function(){return"Function call"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){try{return[2,this.nextFn()]}catch(t){throw t.message="Error thrown while iterating through a dataset: "+t.message,t}return[2]})})},e}(LazyIterator),SerialIterator=function(t){function e(e){var r=t.call(this)||this;return r.upstream=e,r.lastRead=Promise.resolve({value:null,done:!1}),r}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Serial"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(e){return this.lastRead=this.lastRead.then(function(){return t.serialNext()}),[2,this.lastRead]})})},e.prototype.serialNext=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return[2,this.upstream.next()]})})},e}(LazyIterator),SkipIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.maxCount=r,n.count=0,n.lastRead=Promise.resolve({value:null,done:!1}),n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Skip"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(e){return this.lastRead=this.lastRead.then(function(){return t.serialNext()}),[2,this.lastRead]})})},e.prototype.serialNext=function(){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(e){switch(e.label){case 0:return this.count++<this.maxCount?[4,this.upstream.next()]:[3,2];case 1:return(t=e.sent()).done?[2,t]:(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(t.value),[3,0]);case 2:return[2,this.upstream.next()]}})})},e}(LazyIterator),TakeIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.maxCount=r,n.count=0,n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Take"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return this.count++>=this.maxCount?[2,{value:null,done:!0}]:[2,this.upstream.next()]})})},e}(LazyIterator),RowMajorBatchIterator=function(t){function e(e,r,n){void 0===n&&(n=!0);var i=t.call(this)||this;return i.upstream=e,i.batchSize=r,i.enableSmallLastBatch=n,i.lastRead=Promise.resolve({value:null,done:!1}),i}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> RowMajorBatch"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(e){return this.lastRead=this.lastRead.then(function(){return t.serialNext()}),[2,this.lastRead]})})},e.prototype.serialNext=function(){return __awaiter(this,void 0,void 0,function(){var t,e;return __generator(this,function(r){switch(r.label){case 0:t=[],r.label=1;case 1:return t.length<this.batchSize?[4,this.upstream.next()]:[3,3];case 2:return(e=r.sent()).done?this.enableSmallLastBatch&&t.length>0?[2,{value:t,done:!1}]:[2,{value:null,done:!0}]:(t.push(e.value),[3,1]);case 3:return[2,{value:t,done:!1}]}})})},e}(LazyIterator),FilterIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.predicate=r,n.lastRead=Promise.resolve({value:null,done:!1}),n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Filter"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(e){return this.lastRead=this.lastRead.then(function(){return t.serialNext()}),[2,this.lastRead]})})},e.prototype.serialNext=function(){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(e){switch(e.label){case 0:return[4,this.upstream.next()];case 1:return(t=e.sent()).done||this.predicate(t.value)?[2,t]:(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(t.value),[3,0]);case 2:return[2]}})})},e}(LazyIterator),MapIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.transform=r,n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Map"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r,n,i,o,a;return __generator(this,function(u){switch(u.label){case 0:return[4,this.upstream.next()];case 1:if((t=u.sent()).done)return[2,{value:null,done:!0}];for(e=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].getTensorsInContainer(t.value),r=this.transform(t.value),n=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].getTensorsInContainer(r),i=0,o=e;i<o.length;i++)a=o[i],_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].isTensorInList(a,n)||a.dispose();return[2,{value:r,done:!1}]}})})},e}(LazyIterator),ErrorHandlingLazyIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.handler=r,n.count=0,n.lastRead=Promise.resolve({value:null,done:!1}),n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> handleErrors"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(e){return this.lastRead=this.lastRead.then(function(){return t.serialNext()}),[2,this.lastRead]})})},e.prototype.serialNext=function(){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(e){switch(e.label){case 0:e.label=1;case 1:return e.trys.push([1,3,,4]),[4,this.upstream.next()];case 2:return[2,e.sent()];case 3:return t=e.sent(),this.handler(t)?[3,4]:[2,{value:null,done:!0}];case 4:return[3,0];case 5:return[2]}})})},e}(LazyIterator),AsyncMapIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.transform=r,n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> AsyncMap"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r,n,i,o,a;return __generator(this,function(u){switch(u.label){case 0:return[4,this.upstream.next()];case 1:return(t=u.sent()).done?[2,{value:null,done:!0}]:(e=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].getTensorsInContainer(t.value),[4,this.transform(t.value)]);case 2:for(r=u.sent(),n=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].getTensorsInContainer(r),i=0,o=e;i<o.length;i++)a=o[i],_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].isTensorInList(a,n)||a.dispose();return[2,{value:r,done:!1}]}})})},e}(LazyIterator),OneToManyIterator=function(t){function e(){var e=t.call(this)||this;return e.outputQueue=new GrowingRingBuffer,e.lastRead=Promise.resolve({value:null,done:!1}),e}return __extends(e,t),e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(e){return this.lastRead=this.lastRead.then(function(){return t.serialNext()}),[2,this.lastRead]})})},e.prototype.serialNext=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return 0!==this.outputQueue.length()?[3,2]:[4,this.pump()];case 1:return t.sent()?[3,0]:[2,{value:null,done:!0}];case 2:return[2,{value:this.outputQueue.shift(),done:!1}]}})})},e}(LazyIterator),FlatmapIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.transform=r,n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Flatmap"},e.prototype.pump=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r,n,i,o,a;return __generator(this,function(u){switch(u.label){case 0:return[4,this.upstream.next()];case 1:if((t=u.sent()).done)return[2,!1];for(e=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].getTensorsInContainer(t.value),r=this.transform(t.value),n=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].getTensorsInContainer(r),this.outputQueue.pushAll(r),i=0,o=e;i<o.length;i++)a=o[i],_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].isTensorInList(a,n)||a.dispose();return[2,!0]}})})},e}(OneToManyIterator),ChainedIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.baseErrorHandler=r,n.lastRead=null,n.iterator=null,n.moreIterators=e,n}return __extends(e,t),e.prototype.summary=function(){return"TODO: fill in upstream of chained summaries -> Chained"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return this.lastRead=this.readFromChain(this.lastRead),[2,this.lastRead]})})},e.prototype.readFromChain=function(t){return __awaiter(this,void 0,void 0,function(){var e,r;return __generator(this,function(n){switch(n.label){case 0:return[4,t];case 1:return n.sent(),null!=this.iterator?[3,3]:[4,this.moreIterators.next()];case 2:if((e=n.sent()).done)return[2,{value:null,done:!0}];this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler)),n.label=3;case 3:return[4,this.iterator.next()];case 4:return(r=n.sent()).done?(this.iterator=null,[2,this.readFromChain(t)]):[2,r]}})})},e}(LazyIterator);!function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"}(ZipMismatchMode||(ZipMismatchMode={}));var ZipIterator=function(t){function e(e,r){void 0===r&&(r=ZipMismatchMode.FAIL);var n=t.call(this)||this;return n.iterators=e,n.mismatchMode=r,n.count=0,n.currentPromise=null,n}return __extends(e,t),e.prototype.summary=function(){return"{TODO: fill in upstream of zip summaries} -> Zip"},e.prototype.nextState=function(t){return __awaiter(this,void 0,void 0,function(){function e(t){return t instanceof LazyIterator?{value:t.next().then(function(t){return r++,t.done&&n++,t.value}),recurse:!1}:{value:null,recurse:!0}}var r,n,i;return __generator(this,function(o){switch(o.label){case 0:return[4,t];case 1:return o.sent(),r=0,n=0,[4,deepMapAndAwaitAll(this.iterators,e)];case 2:if(i=o.sent(),r===n)return[2,{value:null,done:!0}];if(n>0)switch(this.mismatchMode){case ZipMismatchMode.FAIL:throw new Error("Zipped streams should have the same length. Mismatched at element "+this.count+".");case ZipMismatchMode.SHORTEST:return[2,{value:null,done:!0}];case ZipMismatchMode.LONGEST:}return this.count++,[2,{value:i,done:!1}]}})})},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return this.currentPromise=this.nextState(this.currentPromise),[4,this.currentPromise];case 1:return[2,t.sent()]}})})},e}(LazyIterator),PrefetchIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.bufferSize=r,n.buffer=new RingBuffer(r),n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Prefetch"},e.prototype.refill=function(){for(;!this.buffer.isFull();){var t=this.upstream.next();this.buffer.push(t)}},e.prototype.next=function(){return this.refill(),this.buffer.shift()},e}(LazyIterator),ShuffleIterator=function(t){function e(e,r,n){var i=t.call(this,e,r)||this;return i.upstream=e,i.windowSize=r,i.upstreamExhausted=!1,i.random=seedrandom_1(n||_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].now().toString()),i.lastRead=Promise.resolve({value:null,done:!1}),i}return __extends(e,t),e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(e){return this.lastRead=this.lastRead.then(function(){return t.serialNext()}),[2,this.lastRead]})})},e.prototype.randomInt=function(t){return Math.floor(this.random()*t)},e.prototype.chooseIndex=function(){return this.randomInt(this.buffer.length())},e.prototype.serialNext=function(){return __awaiter(this,void 0,void 0,function(){var t,e;return __generator(this,function(r){switch(r.label){case 0:this.upstreamExhausted||this.refill(),r.label=1;case 1:return this.buffer.isEmpty()?[3,3]:(t=this.chooseIndex(),[4,this.buffer.shuffleExcise(t)]);case 2:return(e=r.sent()).done?(this.upstreamExhausted=!0,[3,1]):(this.refill(),[2,e]);case 3:return[2,{value:null,done:!0}]}})})},e}(PrefetchIterator),Dataset=function(){function t(){this.size=null}return t.prototype.batch=function(t,e){var r=this;void 0===e&&(e=!0);var n=this;return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(t>0,function(){return"batchSize needs to be positive, but it is\n      "+t}),datasetFromIteratorFn(function(){return __awaiter(r,void 0,void 0,function(){return __generator(this,function(r){switch(r.label){case 0:return[4,n.iterator()];case 1:return[2,r.sent().columnMajorBatch(t,e,deepBatchConcat)]}})})},this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t))},t.prototype.concatenate=function(t){var e=this,r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){var e,n;return __generator(this,function(i){switch(i.label){case 0:return[4,r.iterator()];case 1:return n=(e=i.sent()).concatenate,[4,t.iterator()];case 2:return[2,n.apply(e,[i.sent()])]}})})},this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null)},t.prototype.filter=function(t){var e=this,r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,r.iterator()];case 1:return[2,e.sent().filter(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return t(e)})})]}})})},this.size===1/0?1/0:null)},t.prototype.forEachAsync=function(t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,this.iterator()];case 1:return[2,e.sent().forEachAsync(t)]}})})},t.prototype.forEach=function(t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["deprecationWarn"])("dataset.forEach() is deprecated and will be removed. Please use dataset.forEachAsync() instead"),[2,this.forEachAsync(t)]})})},t.prototype.map=function(t){var e=this,r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,r.iterator()];case 1:return[2,e.sent().map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return t(e)})})]}})})},this.size)},t.prototype.mapAsync=function(t){var e=this,r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,r.iterator()];case 1:return[2,e.sent().mapAsync(t)]}})})},this.size)},t.prototype.prefetch=function(t){var e=this;if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");var r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,r.iterator()];case 1:return[2,e.sent().prefetch(t)]}})})},this.size)},t.prototype.repeat=function(t){var e=this,r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){var e=this;return __generator(this,function(n){return[2,iteratorFromConcatenated(iteratorFromFunction(function(){return __awaiter(e,void 0,void 0,function(){var t;return __generator(this,function(e){switch(e.label){case 0:return t={},[4,r.iterator()];case 1:return[2,(t.value=e.sent(),t.done=!1,t)]}})})}).take(t))]})})},null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null)},t.prototype.skip=function(t){var e=this,r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,r.iterator()];case 1:return[2,e.sent().skip(t)]}})})},null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null)},t.prototype.shuffle=function(t,e,r){var n=this;if(void 0===r&&(r=!0),null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting bufferSize to the dataset size ("+this.size+" elements)");var i=this,o=seedrandom_1(e||_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].now().toString());return datasetFromIteratorFn(function(){return __awaiter(n,void 0,void 0,function(){var e;return __generator(this,function(n){switch(n.label){case 0:return e=o.int32(),r&&(e+=o.int32()),[4,i.iterator()];case 1:return[2,n.sent().shuffle(t,e.toString())]}})})},this.size)},t.prototype.take=function(t){var e=this,r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,r.iterator()];case 1:return[2,e.sent().take(t)]}})})},null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null)},t.prototype.toArray=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return[4,this.iterator()];case 1:return[2,t.sent().toArray()]}})})},t.prototype.toArrayForTest=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return[4,this.iterator()];case 1:return[2,t.sent().toArrayForTest()]}})})},t.MAX_BUFFER_SIZE=1e4,t}();function datasetFromIteratorFn(t,e){return void 0===e&&(e=null),new(function(r){function n(){var t=null!==r&&r.apply(this,arguments)||this;return t.size=e,t}return __extends(n,r),n.prototype.iterator=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2,t()]})})},n}(Dataset))}function array(t){var e=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(e){return[2,iteratorFromItems(t)]})})},t.length)}function zip(t){var e,r=this;if(!isIterable(t))throw new Error("The argument to zip() must be an object or array.");if(Array.isArray(t))for(var n=0;n<t.length;n++)e=null==e?t[n].size:Math.min(e,t[n].size);else if(t instanceof Object)for(var i in t)e=null==e?t[i].size:Math.min(e,t[i].size);return datasetFromIteratorFn(function(){return __awaiter(r,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,deepMapAndAwaitAll(t,function(t){if(t instanceof Dataset)return{value:t.iterator(),recurse:!1};if(isIterable(t))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")})];case 1:return[2,iteratorFromZipped(e.sent(),ZipMismatchMode.SHORTEST)]}})})},e)}function deepBatchConcat(t){return null===t?null:canTensorify(t[0])?{value:batchConcat(t),recurse:!1}:{value:null,recurse:!0}}function batchConcat(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"])(t):Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor"])(t)}var TextLineDataset=function(t){function e(e){var r=t.call(this)||this;return r.input=e,r}return __extends(e,t),e.prototype.iterator=function(){return __awaiter(this,void 0,void 0,function(){var t,e;return __generator(this,function(r){switch(r.label){case 0:return[4,this.input.iterator()];case 1:return t=r.sent(),e=t.decodeUTF8(),[2,e.split("\n")]}})})},e}(Dataset),CODE_QUOTE='"',STATE_OUT=Symbol("out"),STATE_FIELD=Symbol("field"),STATE_QUOTE=Symbol("quote"),STATE_QUOTE_AFTER_QUOTE=Symbol("quoteafterquote"),STATE_WITHIN_QUOTE_IN_QUOTE=Symbol("quoteinquote"),CSVDataset=function(t){function e(e,r){var n=t.call(this)||this;return n.input=e,n.hasHeader=!0,n.fullColumnNames=null,n.columnNamesValidated=!1,n.columnConfigs=null,n.configuredColumnsOnly=!1,n.delimiter=",",n.delimWhitespace=!1,n.base=new TextLineDataset(e),r||(r={}),n.hasHeader=!1!==r.hasHeader,n.fullColumnNames=r.columnNames,n.columnConfigs=r.columnConfigs,n.configuredColumnsOnly=r.configuredColumnsOnly,r.delimWhitespace?(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null==r.delimiter,function(){return"Delimiter should not be provided when delimWhitespace is true."}),n.delimWhitespace=!0,n.delimiter=" "):n.delimiter=r.delimiter?r.delimiter:",",n}return __extends(e,t),e.prototype.columnNames=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return this.columnNamesValidated?[3,2]:[4,this.setColumnNames()];case 1:t.sent(),t.label=2;case 2:return[2,this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames]}})})},e.prototype.setColumnNames=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r,n,i,o,a=this;return __generator(this,function(u){switch(u.label){case 0:return[4,this.maybeReadHeaderLine()];case 1:if(t=u.sent(),!this.fullColumnNames&&!t)throw new Error("Column names must be provided if there is no header line.");if(this.fullColumnNames&&t&&_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(t.length===this.fullColumnNames.length,function(){return"The length of provided columnNames ("+a.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+t.length.toString()+")."}),this.fullColumnNames||(this.fullColumnNames=t),e=this.fullColumnNames.reduce(function(t,e){return t[e]=t[e]+1||1,t},{}),r=Object.keys(e).filter(function(t){return e[t]>1}),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(0===r.length,function(){return"Duplicate column names found: "+r.toString()}),this.columnConfigs)for(n=0,i=Object.keys(this.columnConfigs);n<i.length;n++)if(o=i[n],-1===this.fullColumnNames.indexOf(o))throw new Error('The key "'+o+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").");return this.columnNamesValidated=!0,[2]}})})},e.prototype.maybeReadHeaderLine=function(){return __awaiter(this,void 0,void 0,function(){var t,e;return __generator(this,function(r){switch(r.label){case 0:return this.hasHeader?[4,this.base.iterator()]:[3,3];case 1:return[4,r.sent().next()];case 2:if((t=r.sent()).done)throw new Error("No data was found for CSV parsing.");return e=t.value,[2,this.parseRow(e,!1)];case 3:return[2,null]}})})},e.prototype.iterator=function(){return __awaiter(this,void 0,void 0,function(){var t,e=this;return __generator(this,function(r){switch(r.label){case 0:return this.columnNamesValidated?[3,2]:[4,this.setColumnNames()];case 1:r.sent(),r.label=2;case 2:return[4,this.base.iterator()];case 3:return t=r.sent(),this.hasHeader&&(t=t.skip(1)),[2,t.map(function(t){return e.makeDataElement(t)})]}})})},e.prototype.makeDataElement=function(t){for(var e=this.parseRow(t),r={},n={},i=0;i<this.fullColumnNames.length;i++){var o=this.fullColumnNames[i],a=this.columnConfigs?this.columnConfigs[o]:null;if(!this.configuredColumnsOnly||a){var u=e[i],s=null;if(""===u)if(a&&void 0!==a.default)s=a.default;else{if(a&&(a.required||a.isLabel))throw new Error("Required column "+o+" is empty in this line: "+t);s=void 0}else{var c=Number(u);if(isNaN(c))s=a&&"bool"===a.dtype?this.getBoolean(u):u;else if(a&&a.dtype)switch(a.dtype){case"float32":s=c;break;case"int32":s=Math.floor(c);break;case"bool":s=this.getBoolean(u);break;default:s=c}else s=c}a&&a.isLabel?n[o]=s:r[o]=s}}return 0===Object.keys(n).length?r:{xs:r,ys:n}},e.prototype.getBoolean=function(t){return"1"===t||"true"===t.toLowerCase()?1:0},e.prototype.parseRow=function(t,e){void 0===e&&(e=!0);for(var r=[],n=0,i=t.length,o=STATE_OUT,a=0;a<i;a++)switch(o){case STATE_OUT:switch(t.charAt(a)){case CODE_QUOTE:n=a+1,o=STATE_QUOTE;break;case this.delimiter:if(n=a+1," "===this.delimiter&&this.delimWhitespace)break;r.push(""),o=STATE_OUT;break;default:o=STATE_FIELD,n=a}break;case STATE_FIELD:switch(t.charAt(a)){case this.delimiter:r.push(t.substring(n,a)),o=STATE_OUT,n=a+1}break;case STATE_QUOTE:switch(t.charAt(a)){case CODE_QUOTE:o=STATE_QUOTE_AFTER_QUOTE}break;case STATE_QUOTE_AFTER_QUOTE:switch(t.charAt(a)){case this.delimiter:r.push(t.substring(n,a-1)),o=STATE_OUT,n=a+1;break;case CODE_QUOTE:o=STATE_QUOTE;break;default:o=STATE_WITHIN_QUOTE_IN_QUOTE}break;case STATE_WITHIN_QUOTE_IN_QUOTE:switch(t.charAt(a)){case CODE_QUOTE:o=STATE_QUOTE}}if(o===STATE_QUOTE_AFTER_QUOTE?r.push(t.substring(n,i-1)):r.push(t.substring(n)),e&&r.length!==this.fullColumnNames.length)throw new Error("Invalid row in csv file. Should have "+this.fullColumnNames.length+" elements in a row, but got "+r);return r},e}(Dataset),environment=createCommonjsModule(function(t,e){Object.defineProperty(e,"__esModule",{value:!0});var r=function(){function t(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}return t.prototype.registerFlag=function(t,e,r){if(this.flagRegistry[t]={evaluationFn:e,setHook:r},null!=this.urlFlags[t]){var n=this.urlFlags[t];console.warn("Setting feature override from URL "+t+": "+n+"."),this.set(t,n)}},t.prototype.get=function(t){return t in this.flags?this.flags[t]:(this.flags[t]=this.evaluateFlag(t),this.flags[t])},t.prototype.getNumber=function(t){return this.get(t)},t.prototype.getBool=function(t){return this.get(t)},t.prototype.getFlags=function(){return this.flags},Object.defineProperty(t.prototype,"features",{get:function(){return this.flags},enumerable:!0,configurable:!0}),t.prototype.set=function(t,e){if(null==this.flagRegistry[t])throw new Error("Cannot set flag "+t+" as it has not been registered.");this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)},t.prototype.evaluateFlag=function(t){if(null==this.flagRegistry[t])throw new Error("Cannot evaluate flag '"+t+"': no evaluation function found.");return this.flagRegistry[t].evaluationFn()},t.prototype.setFlags=function(t){this.flags=Object.assign({},t)},t.prototype.reset=function(){this.flags={},this.urlFlags={},this.populateURLFlags()},t.prototype.populateURLFlags=function(){var t=this;if(void 0!==this.global&&void 0!==this.global.location&&void 0!==this.global.location.search){var e=n(this.global.location.search);if("tfjsflags"in e)e.tfjsflags.split(",").forEach(function(e){var r=e.split(":"),n=r[0],i=r[1];t.urlFlags[n]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error("Could not parse value flag value "+e+" for flag "+t+".")}(n,i)})}},t}();function n(t){var e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,function(t){for(var r=[],n=1;n<arguments.length;n++)r[n-1]=arguments[n];return function(t,e,r){t[decodeURIComponent(e)]=decodeURIComponent(r||"")}(e,r[0],r[1]),r.join("=")}),e}e.Environment=r,e.getQueryParams=n,e.setEnvironmentGlobal=function(t){e.ENV=t}});unwrapExports(environment);var environment_1=environment.Environment,environment_2=environment.getQueryParams,environment_3=environment.ENV,environment_4=environment.setEnvironmentGlobal,util$1=createCommonjsModule(function(t,e){function r(t){for(var e=t.length,r=0,n=0;e>0;)n=Math.random()*e|0,r=t[--e],t[e]=t[n],t[n]=r}function n(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function i(t,e){if(void 0===e&&(e=[]),null==e&&(e=[]),Array.isArray(t)||c(t))for(var r=0;r<t.length;++r)i(t[r],e);else e.push(t);return e}function o(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(var r=0;r<t.length;r++)if(t[r]!==e[r])return!1;return!0}function a(t){return t%1==0}function u(t,e){var r=e.length;return n((t=null==t?e.map(function(t,e){return e}):[].concat(t)).every(function(t){return t>=-r&&t<r}),function(){return"All values in axis param must be in range [-"+r+", "+r+") but got axis "+t}),n(t.every(function(t){return a(t)}),function(){return"All values in axis param must be integers but got axis "+t}),t.map(function(t){return t<0?r+t:t})}function s(t,e){for(var r=0;r<t.length;r++){var n=t[r];if(isNaN(n)||!isFinite(n))throw Error("A tensor of type "+e+" being uploaded contains "+n+".")}}function c(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function l(t){return"string"==typeof t||t instanceof String}function f(t){return"boolean"==typeof t}function h(t){return"number"==typeof t}function p(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error("Unknown data type "+e)}Object.defineProperty(e,"__esModule",{value:!0}),e.shuffle=r,e.clamp=function(t,e,r){return Math.max(t,Math.min(e,r))},e.nearestLargerEven=function(t){return t%2==0?t:t+1},e.sum=function(t){for(var e=0,r=0;r<t.length;r++)e+=t[r];return e},e.randUniform=function(t,e){var r=Math.random();return e*r+(1-r)*t},e.distSquared=function(t,e){for(var r=0,n=0;n<t.length;n++){var i=Number(t[n])-Number(e[n]);r+=i*i}return r},e.assert=n,e.assertShapesMatch=function(t,e,r){void 0===r&&(r=""),n(o(t,e),function(){return r+" Shapes "+t+" and "+e+" must match"})},e.assertNonNull=function(t){n(null!=t,function(){return"The input to the tensor constructor must be a non-null value."})},e.flatten=i,e.sizeFromShape=function(t){if(0===t.length)return 1;for(var e=t[0],r=1;r<t.length;r++)e*=t[r];return e},e.isScalarShape=function(t){return 0===t.length},e.arraysEqual=o,e.isInt=a,e.tanh=function(t){if(null!=Math.tanh)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;var e=Math.exp(2*t);return(e-1)/(e+1)},e.sizeToSquarishShape=function(t){var e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]},e.createShuffledIndices=function(t){for(var e=new Uint32Array(t),n=0;n<t;++n)e[n]=n;return r(e),e},e.rightPad=function(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)},e.repeatedTry=function(t,e,r){return void 0===e&&(e=function(t){return 0}),new Promise(function(n,i){var o=0,a=function(){if(t())n();else{var u=e(++o);null!=r&&o>=r?i():setTimeout(a,u)}};a()})},e.inferFromImplicitShape=function(t,e){for(var r=1,n=-1,i=0;i<t.length;++i)if(t[i]>=0)r*=t[i];else if(-1===t[i]){if(-1!==n)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+n+" and dim "+i);n=i}else if(t[i]<0)throw Error("Shapes can not be < 0. Found "+t[i]+" at dim "+i);if(-1===n){if(e>0&&e!==r)throw Error("Size("+e+") must match the product of shape "+t);return t}if(0===r)throw Error("Cannot infer the missing size in ["+t+"] when there are 0 elements");if(e%r!=0)throw Error("The implicit shape can't be a fractional number. Got "+e+" / "+r);var o=t.slice();return o[n]=e/r,o},e.parseAxisParam=u,e.squeezeShape=function(t,e){for(var r=[],n=[],i=null==e?null:u(e,t).sort(),o=0,a=0;a<t.length;++a){if(null!=i){if(i[o]===a&&1!==t[a])throw new Error("Can't squeeze axis "+a+" since its dim '"+t[a]+"' is not 1");(null==i[o]||i[o]>a)&&1===t[a]&&(r.push(t[a]),n.push(a)),i[o]<=a&&o++}1!==t[a]&&(r.push(t[a]),n.push(a))}return{newShape:r,keptDims:n}},e.getTypedArrayFromDType=function(t,e){var r=null;if(null==t||"float32"===t)r=new Float32Array(e);else if("int32"===t)r=new Int32Array(e);else{if("bool"!==t)throw new Error("Unknown data type "+t);r=new Uint8Array(e)}return r},e.getArrayFromDType=function(t,e){var r=null;if(null==t||"float32"===t)r=new Float32Array(e);else if("int32"===t)r=new Int32Array(e);else if("bool"===t)r=new Uint8Array(e);else{if("string"!==t)throw new Error("Unknown data type "+t);r=new Array(e)}return r},e.checkComputationForErrors=function(t,e,r){if("float32"===e)for(var n=0;n<t.length;n++){var i=t[n];if(isNaN(i)||!isFinite(i))throw Error("The result of the '"+r+"' is "+i+".")}},e.checkConversionForErrors=s,e.hasEncodingLoss=function(t,e){return!("complex64"===e||"float32"===e&&"complex64"!==t||"int32"===e&&"float32"!==t&&"complex64"!==t||"bool"===e&&"bool"===t)},e.isTypedArray=c,e.bytesPerElement=function(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error("Unknown dtype "+t)},e.bytesFromStringArray=function(t){if(null==t)return 0;var e=0;return t.forEach(function(t){return e+=2*t.length}),e},e.isString=l,e.isBoolean=f,e.isNumber=h,e.inferDtype=function t(e){return Array.isArray(e)?t(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array?"int32":h(e)?"float32":l(e)?"string":f(e)?"bool":"float32"},e.isFunction=function(t){return!!(t&&t.constructor&&t.call&&t.apply)},e.nearestDivisor=function(t,e){for(var r=e;r<t;++r)if(t%r==0)return r;return t},e.computeStrides=function(t){var e=t.length;if(e<2)return[];var r=new Array(e-1);r[e-2]=t[e-1];for(var n=e-3;n>=0;--n)r[n]=r[n+1]*t[n+1];return r},e.toTypedArray=function(t,e,r){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=i(t)),r&&s(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){for(var n=new Uint8Array(t.length),o=0;o<n.length;++o)0!==Math.round(t[o])&&(n[o]=1);return n}throw new Error("Unknown data type "+e)},e.toNestedArray=function(t,e){if(0===t.length)return e[0];var r=t.reduce(function(t,e){return t*e});if(0===r)return[];if(r!==e.length)throw new Error("["+t+"] does not match the input size.");return function t(e,r,n){var i=new Array;if(1===r.length)for(var o=r[0],a=0;a<o;a++)i[a]=n[e+a];else{o=r[0];var u=r.slice(1),s=u.reduce(function(t,e){return t*e});for(a=0;a<o;a++)i[a]=t(e+a*s,u,n)}return i}(0,t,e)},e.makeOnesTypedArray=function(t,e){for(var r=p(t,e),n=0;n<r.length;n++)r[n]=1;return r},e.makeZerosTypedArray=p,e.now=function(){if("undefined"!=typeof performance)return performance.now();if("undefined"!=typeof process){var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}throw new Error("Cannot measure time in this environment. You should run tf.js in the browser or in Node.js")},e.assertNonNegativeIntegerDimensions=function(t){t.forEach(function(e){n(Number.isInteger(e)&&e>=0,function(){return"Tensor must have a shape comprised of positive integers but got shape ["+t+"]."})})};var d=function(){if(null!=environment.ENV.global.fetch)return environment.ENV.global.fetch;if(environment.ENV.get("IS_NODE"))return e.getNodeFetch.fetchImport();throw new Error("Unable to find the fetch() method. Please add your own fetch() function to the global namespace.")};e.getNodeFetch={fetchImport:function(){return __webpack_require__(/*! node-fetch */ 5)}},e.fetch=function(t,r){return null==e.systemFetch&&(e.systemFetch=d()),e.systemFetch(t,r)}});unwrapExports(util$1);var util_1=util$1.shuffle,util_2=util$1.clamp,util_3=util$1.nearestLargerEven,util_4=util$1.sum,util_5=util$1.randUniform,util_6=util$1.distSquared,util_7=util$1.assert,util_8=util$1.assertShapesMatch,util_9=util$1.assertNonNull,util_10=util$1.flatten,util_11=util$1.sizeFromShape,util_12=util$1.isScalarShape,util_13=util$1.arraysEqual,util_14=util$1.isInt,util_15=util$1.tanh,util_16=util$1.sizeToSquarishShape,util_17=util$1.createShuffledIndices,util_18=util$1.rightPad,util_19=util$1.repeatedTry,util_20=util$1.inferFromImplicitShape,util_21=util$1.parseAxisParam,util_22=util$1.squeezeShape,util_23=util$1.getTypedArrayFromDType,util_24=util$1.getArrayFromDType,util_25=util$1.checkComputationForErrors,util_26=util$1.checkConversionForErrors,util_27=util$1.hasEncodingLoss,util_28=util$1.isTypedArray,util_29=util$1.bytesPerElement,util_30=util$1.bytesFromStringArray,util_31=util$1.isString,util_32=util$1.isBoolean,util_33=util$1.isNumber,util_34=util$1.inferDtype,util_35=util$1.isFunction,util_36=util$1.nearestDivisor,util_37=util$1.computeStrides,util_38=util$1.toTypedArray,util_39=util$1.toNestedArray,util_40=util$1.makeOnesTypedArray,util_41=util$1.makeZerosTypedArray,util_42=util$1.now,util_43=util$1.assertNonNegativeIntegerDimensions,util_44=util$1.getNodeFetch,util_45=util$1.systemFetch,util_46=util$1.fetch,WebcamIterator=function(t){function e(e,r){var n=t.call(this)||this;if(n.webcamVideoElement=e,n.webcamConfig=r,n.isClosed=!0,n.resize=!1,n.needToResize())if(n.resize=!0,n.cropSize=[n.webcamConfig.resizeHeight,n.webcamConfig.resizeWidth],n.cropBoxInd=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])([0],"int32"),n.webcamConfig.centerCrop){var i=1*n.webcamConfig.resizeWidth/n.webcamVideoElement.width,o=1*n.webcamConfig.resizeHeight/n.webcamVideoElement.height,a=(1-i)/2,u=(1-o)/2,s=a+i,c=o+u;n.cropBox=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor2d"])([u,a,c,s],[1,4])}else n.cropBox=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor2d"])([0,0,1,1],[1,4]);return n}return __extends(e,t),e.prototype.summary=function(){return"webcam"},e.create=function(t,r){return void 0===r&&(r={}),__awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(i){switch(i.label){case 0:if(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].get("IS_NODE"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!r.resizeWidth||!r.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=r.resizeWidth,t.height=r.resizeHeight}return[4,(n=new e(t,r)).start()];case 1:return i.sent(),[2,n]}})})},e.prototype.start=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r=this;return __generator(this,function(n){switch(n.label){case 0:this.webcamConfig.facingMode&&util_7("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,function(){return"Invalid webcam facing mode: "+r.webcamConfig.facingMode+". Please provide 'user' or 'environment'"}),n.label=1;case 1:return n.trys.push([1,3,,4]),t=this,[4,navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})];case 2:return t.stream=n.sent(),[3,4];case 3:throw(e=n.sent()).message="Error thrown while initializing video stream: "+e.message,e;case 4:if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,[2,new Promise(function(t){r.webcamVideoElement.onloadedmetadata=function(){t()}})]}})})},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(e){if(this.isClosed)return[2,{value:null,done:!0}];try{t=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["browser"].fromPixels(this.webcamVideoElement)}catch(t){throw new Error("Error thrown converting video to pixels: "+JSON.stringify(t))}if(!this.resize)return[2,{value:t,done:!1}];try{return[2,{value:this.cropAndResizeFrame(t),done:!1}]}catch(t){throw new Error("Error thrown cropping the video: "+t.message)}return[2]})})},e.prototype.needToResize=function(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)},e.prototype.cropAndResizeFrame=function(t){var e,r=t.toFloat().expandDims(0),n=(e=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].cropAndResize(r,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear")).shape;return e.reshape(n.slice(1))},e.prototype.capture=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return[4,this.next()];case 1:return[2,t.sent().value]}})})},e.prototype.stop=function(){this.stream.getTracks().forEach(function(t){return t.stop()});try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0},e.prototype.toArray=function(){throw new Error("Can not convert infinite video stream to array.")},e}(LazyIterator),DataSource=function(){return function(){}}(),StringIterator=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return __extends(e,t),e.prototype.split=function(t){return new SplitIterator(this,t)},e}(LazyIterator),SplitIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.impl=new SplitIteratorImpl(e,r),n}return __extends(e,t),e.prototype.summary=function(){return this.impl.summary()},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return[2,this.impl.next()]})})},e}(StringIterator),SplitIteratorImpl=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.separator=r,n.carryover="",n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Split('"+this.separator+"')"},e.prototype.pump=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r,n,i;return __generator(this,function(o){switch(o.label){case 0:return[4,this.upstream.next()];case 1:if((t=o.sent()).done)return""===this.carryover?[2,!1]:(this.outputQueue.push(this.carryover),this.carryover="",[2,!0]);for((e=t.value.split(this.separator))[0]=this.carryover+e[0],r=0,n=e.slice(0,-1);r<n.length;r++)i=n[r],this.outputQueue.push(i);return this.carryover=e[e.length-1],[2,!0]}})})},e}(OneToManyIterator),ByteChunkIterator=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return __extends(e,t),e.prototype.decodeUTF8=function(){return new Utf8Iterator(this)},e}(LazyIterator),Utf8Iterator=function(t){function e(e){var r=t.call(this)||this;return r.upstream=e,r.impl=new Utf8IteratorImpl(e),r}return __extends(e,t),e.prototype.summary=function(){return this.impl.summary()},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return[2,this.impl.next()]})})},e}(StringIterator),Utf8IteratorImpl=function(t){function e(e){var r=t.call(this)||this;if(r.upstream=e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].get("IS_BROWSER"))r.decoder=new TextDecoder("utf-8");else{var n=__webpack_require__(/*! string_decoder */ 6).StringDecoder;r.decoder=new n("utf8")}return r}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Utf8"},e.prototype.pump=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r;return __generator(this,function(n){switch(n.label){case 0:return[4,this.upstream.next()];case 1:return(t=n.sent()).done?[2,!1]:(e=t.value,r=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].get("IS_BROWSER")?this.decoder.decode(e,{stream:!0}):this.decoder.write(Buffer.from(e.buffer)),this.outputQueue.push(r),[2,!0])}})})},e}(OneToManyIterator),FileChunkIterator=function(t){function e(e,r){void 0===r&&(r={});var n=t.call(this)||this;return n.file=e,n.options=r,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(e instanceof Uint8Array||!!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),function(){return"FileChunkIterator only supports File, Blob and Uint8Array right now."}),n.offset=r.offset||0,n.chunkSize=r.chunkSize||1048576,n}return __extends(e,t),e.prototype.summary=function(){return"FileChunks "+this.file},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r=this;return __generator(this,function(n){switch(n.label){case 0:return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?[2,{value:null,done:!0}]:(t=new Promise(function(t,e){var n=r.offset+r.chunkSize;if(r.file instanceof Uint8Array)t(new Uint8Array(r.file.slice(r.offset,n)));else{var i=new FileReader;i.onload=function(r){var n=i.result;if(n instanceof ArrayBuffer&&(n=new Uint8Array(n)),!(n instanceof Uint8Array))return e(new TypeError("FileReader returned unknown type."));t(n)},i.onabort=function(t){return e(new Error("Aborted"))},i.onerror=function(t){return e(new Error(t.type))};var o=r.file.slice(r.offset,n);i.readAsArrayBuffer(o)}r.offset=n}),e={},[4,t]);case 1:return[2,(e.value=n.sent(),e.done=!1,e)]}})})},e}(ByteChunkIterator);function urlChunkIterator(t,e){return void 0===e&&(e={}),__awaiter(this,void 0,void 0,function(){var r,n,i,o;return __generator(this,function(a){switch(a.label){case 0:return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].get("IS_BROWSER")?[4,fetch(t)]:[3,5];case 1:return(r=a.sent()).ok?[4,r.blob()]:[3,3];case 2:return n=a.sent(),[2,new FileChunkIterator(n,e)];case 3:throw new Error(r.statusText);case 4:return[3,9];case 5:if(i=__webpack_require__(/*! node-fetch */ 5),"string"!=typeof t)throw new Error("URL must be a string. Request objects are not supported in the node.js environment yet.");return[4,i(t)];case 6:return(r=a.sent()).ok?[4,r.buffer()]:[3,8];case 7:return o=a.sent(),[2,new FileChunkIterator(o,e)];case 8:throw new Error(r.statusText);case 9:return[2]}})})}function isLocalPath(t){return"string"==typeof t&&"file://"===t.substr(0,7)}var FileDataSource=function(t){function e(e,r){void 0===r&&(r={});var n=t.call(this)||this;return n.input=e,n.options=r,n}return __extends(e,t),e.prototype.iterator=function(){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(e){return isLocalPath(this.input)&&_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].get("IS_NODE")&&(t=__webpack_require__(/*! fs */ 7),this.input=t.readFileSync(this.input.substr(7))),[2,new FileChunkIterator(this.input,this.options)]})})},e}(DataSource),URLDataSource=function(t){function e(e,r){void 0===r&&(r={});var n=t.call(this)||this;return n.url=e,n.fileOptions=r,n}return __extends(e,t),e.prototype.iterator=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return isLocalPath(this.url)?[2,new FileDataSource(this.url,this.fileOptions).iterator()]:[2,urlChunkIterator(this.url,this.fileOptions)]})})},e}(DataSource);function csv(t,e){return void 0===e&&(e={}),new CSVDataset(new URLDataSource(t),e)}function func(t){var e=this,r=iteratorFromFunction(t);return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(t){return[2,r]})})})}function generator(t){var e=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){var e;return __generator(this,function(r){switch(r.label){case 0:return[4,t()];case 1:return e=r.sent(),[2,iteratorFromFunction(function(){return e.next()})]}})})})}function webcam(t,e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(r){return[2,WebcamIterator.create(t,e)]})})}var version="1.1.2";
//# sourceMappingURL=tf-data.esm.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-layers/dist/tf-layers.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-layers/dist/tf-layers.esm.js ***!
  \********************************************************************/
/*! exports provided: constraints, initializers, layers, metrics, models, regularizers, CallbackList, CustomCallback, History, Callback, callbacks, EarlyStopping, InputSpec, SymbolicTensor, LayersModel, input, loadLayersModel, model, registerCallbackConstructor, sequential, RNN, Sequential, LayerVariable, version_layers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "constraints", function() { return exports_constraints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initializers", function() { return exports_initializers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "layers", function() { return exports_layers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "metrics", function() { return exports_metrics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "models", function() { return exports_models; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "regularizers", function() { return exports_regularizers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CallbackList", function() { return CallbackList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomCallback", function() { return CustomCallback; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "History", function() { return History; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Callback", function() { return Callback; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "callbacks", function() { return callbacks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EarlyStopping", function() { return EarlyStopping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InputSpec", function() { return InputSpec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SymbolicTensor", function() { return SymbolicTensor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayersModel", function() { return LayersModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "input", function() { return input; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadLayersModel", function() { return loadLayersModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "model", function() { return model; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerCallbackConstructor", function() { return registerCallbackConstructor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sequential", function() { return sequential; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RNN", function() { return RNN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sequential", function() { return Sequential; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayerVariable", function() { return LayerVariable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version_layers", function() { return version; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var extendStatics=function(e,t){return(extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(e,t)};function __extends(e,t){function n(){this.constructor=e}extendStatics(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}var _epsilon,__assign=function(){return(__assign=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var i in t=arguments[n])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)};function __awaiter(e,t,n,r){return new(n||(n=Promise))(function(i,a){function o(e){try{l(r.next(e))}catch(e){a(e)}}function s(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){e.done?i(e.value):new n(function(t){t(e.value)}).then(o,s)}l((r=r.apply(e,t||[])).next())})}function __generator(e,t){var n,r,i,a,o={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return a={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function s(a){return function(s){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,r&&(i=2&a[0]?r.return:a[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,a[1])).done)return i;switch(r=0,i&&(a=[2&a[0],i.value]),a[0]){case 0:case 1:i=a;break;case 4:return o.label++,{value:a[1],done:!1};case 5:o.label++,r=a[1],a=[0];continue;case 7:a=o.ops.pop(),o.trys.pop();continue;default:if(!(i=(i=o.trys).length>0&&i[i.length-1])&&(6===a[0]||2===a[0])){o=0;continue}if(3===a[0]&&(!i||a[1]>i[0]&&a[1]<i[3])){o.label=a[1];break}if(6===a[0]&&o.label<i[1]){o.label=i[1],i=a;break}if(i&&o.label<i[2]){o.label=i[2],o.ops.push(a);break}i[2]&&o.ops.pop(),o.trys.pop();continue}a=t.call(e,o)}catch(e){a=[6,e],r=0}finally{n=i=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,s])}}}function epsilon(){return null==_epsilon&&(_epsilon=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["backend"])().epsilon()),_epsilon}function imageDataFormat(){return"channelsLast"}var AttributeError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error),RuntimeError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error),ValueError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error),NotImplementedError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error),AssertionError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error),IndexError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error);function pyListRepeat(e,t){if(Array.isArray(e)){for(var n=[],r=0;r<t;r++)n=n.concat(e);return n}return(n=new Array(t)).fill(e),n}function assert(e,t){if(!e)throw new AssertionError(t)}function count(e,t){for(var n=0,r=0,i=e;r<i.length;r++){i[r]===t&&n++}return n}function singletonOrArray(e){return 1===e.length?e[0]:e}function toList(e){return Array.isArray(e)?e:[e]}function toSnakeCase(e){var t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function toCamelCase(e){return e.length<=1?e:-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,function(e,t){return t.toUpperCase()})}var _GLOBAL_CUSTOM_OBJECTS={};function serializeKerasObject(e){if(null===e||void 0===e)return null;var t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function convertNDArrayScalarsInConfig(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach(function(e){return convertNDArrayScalarsInConfig(e)});else for(var t=0,n=Object.keys(e);t<n.length;t++){var r=n[t],i=e[r];null!=i&&"object"==typeof i&&(Array.isArray(i)||"ndarray"!==i.type||"number"!=typeof i.value?convertNDArrayScalarsInConfig(i):e[r]=i.value)}}function deserializeKerasObject(e,t,n,r,i){var a,o,s;if(void 0===t&&(t={}),void 0===n&&(n={}),void 0===r&&(r="object"),void 0===i&&(i=!1),"string"==typeof e){var l=e,u=void 0;if(l in n)u=n[l];else if(l in _GLOBAL_CUSTOM_OBJECTS)u=_GLOBAL_CUSTOM_OBJECTS[l];else if(null==(u=t[l]))throw new ValueError("Unknown "+r+": "+e+". This may be due to one of the following reasons:\n1. The "+r+" is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom "+r+" is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");return u}var c=e;if(null==c.className||null==c.config)throw new ValueError(r+": Improper config format: "+JSON.stringify(c)+".\n'className' and 'config' must set.");var p=c.className,h=void 0,d=void 0;if(p in n?(h=(a=n[p])[0],d=a[1]):p in _GLOBAL_CUSTOM_OBJECTS?(h=(o=_GLOBAL_CUSTOM_OBJECTS.className)[0],d=o[1]):p in t&&(h=(s=t[p])[0],d=s[1]),null==h)throw new ValueError("Unknown "+r+": "+p+". This may be due to one of the following reasons:\n1. The "+r+" is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom "+r+" is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");if(null!=d){for(var f={},g=0,m=Object.keys(_GLOBAL_CUSTOM_OBJECTS);g<m.length;g++){f[S=m[g]]=_GLOBAL_CUSTOM_OBJECTS[S]}for(var y=0,v=Object.keys(n);y<v.length;y++){f[S=v[y]]=n[S]}c.config.customObjects=f;for(var b=__assign({},_GLOBAL_CUSTOM_OBJECTS),w=0,z=Object.keys(n);w<z.length;w++){var S=z[w];_GLOBAL_CUSTOM_OBJECTS[S]=n[S]}convertNDArrayScalarsInConfig(c.config);var I=d(h,c.config,n,i);return _GLOBAL_CUSTOM_OBJECTS=__assign({},b),I}b=__assign({},_GLOBAL_CUSTOM_OBJECTS);for(var A=0,_=Object.keys(n);A<_.length;A++){S=_[A];_GLOBAL_CUSTOM_OBJECTS[S]=n[S]}I=new h(c.config);return _GLOBAL_CUSTOM_OBJECTS=__assign({},b),I}function numberCompare(e,t){return e<t?-1:e>t?1:0}function reverseNumberCompare(e,t){return-1*numberCompare(e,t)}function unique(e){if(null==e)return e;for(var t=[],n=0,r=e;n<r.length;n++){var i=r[n];-1===t.indexOf(i)&&t.push(i)}return t}function isObjectEmpty(e){if(null==e)throw new ValueError("Invalid value in obj: "+JSON.stringify(e));for(var t in e)if(e.hasOwnProperty(t))return!1;return!0}function checkStringTypeUnionValue(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new ValueError(n+" is not a valid "+t+".  Valid values are "+e+" or null/undefined.")}function checkArrayTypeAndLength(e,t,n,r){return void 0===n&&(n=0),void 0===r&&(r=1/0),assert(n>=0),assert(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(function(e){return typeof e===t})}function assertPositiveInteger(e,t){Array.isArray(e)?(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(e.length>0,function(){return t+" is unexpectedly an empty array."}),e.forEach(function(e,n){return assertPositiveInteger(e,"element "+(n+1)+" of "+t)})):_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(Number.isInteger(e)&&e>0,function(){return"Expected "+t+" to be a positive integer, but got "+formatAsFriendlyString(e)+"."})}function formatAsFriendlyString(e){return null===e?"null":Array.isArray(e)?"["+e.map(function(e){return formatAsFriendlyString(e)}).join(",")+"]":"string"==typeof e?'"'+e+'"':""+e}function debounce(e,t){var n,r=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].now();return function(){for(var i=[],a=0;a<arguments.length;a++)i[a]=arguments[a];var o=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].now();return o-r<t?n:(r=o,n=e.apply(void 0,i))}}function calcL2Norms(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mulStrict"])(e,e),t,!0))})}var Constraint=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.getConfig=function(){return{}},t}(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].Serializable),MaxNorm=function(e){function t(t){var n=e.call(this)||this;return n.defaultMaxValue=2,n.defaultAxis=0,n.maxValue=null!=t.maxValue?t.maxValue:n.defaultMaxValue,n.axis=null!=t.axis?t.axis:n.defaultAxis,n}return __extends(t,e),t.prototype.apply=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=calcL2Norms(e,t.axis),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(n,0,t.maxValue);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(r,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(epsilon(),n)))})},t.prototype.getConfig=function(){return{maxValue:this.maxValue,axis:this.axis}},t.className="MaxNorm",t}(Constraint);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(MaxNorm);var UnitNorm=function(e){function t(t){var n=e.call(this)||this;return n.defaultAxis=0,n.axis=null!=t.axis?t.axis:n.defaultAxis,n}return __extends(t,e),t.prototype.apply=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(epsilon(),calcL2Norms(e,t.axis)))})},t.prototype.getConfig=function(){return{axis:this.axis}},t.className="UnitNorm",t}(Constraint);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(UnitNorm);var NonNeg=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"])(e)},t.className="NonNeg",t}(Constraint);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(NonNeg);var MinMaxNorm=function(e){function t(t){var n=e.call(this)||this;return n.defaultMinValue=0,n.defaultMaxValue=1,n.defaultRate=1,n.defaultAxis=0,n.minValue=null!=t.minValue?t.minValue:n.defaultMinValue,n.maxValue=null!=t.maxValue?t.maxValue:n.defaultMaxValue,n.rate=null!=t.rate?t.rate:n.defaultRate,n.axis=null!=t.axis?t.axis:n.defaultAxis,n}return __extends(t,e),t.prototype.apply=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=calcL2Norms(e,t.axis),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(t.rate,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(n,t.minValue,t.maxValue)),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(1-t.rate,n));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(r,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(epsilon(),n)))})},t.prototype.getConfig=function(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}},t.className="MinMaxNorm",t}(Constraint);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(MinMaxNorm);var CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function serializeConstraint(e){return serializeKerasObject(e)}function deserializeConstraint(e,t){return void 0===t&&(t={}),deserializeKerasObject(e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].SerializationMap.getMap().classNameMap,t,"constraint")}function getConstraint(e){return null==e?null:"string"==typeof e?deserializeConstraint({className:e in CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP?CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[e]:e,config:{}}):e instanceof Constraint?e:deserializeConstraint(e)}function maxNorm(e){return new MaxNorm(e)}function unitNorm(e){return new UnitNorm(e)}function nonNeg(){return new NonNeg}function minMaxNorm(e){return new MinMaxNorm(e)}var exports_constraints=Object.freeze({maxNorm:maxNorm,unitNorm:unitNorm,nonNeg:nonNeg,minMaxNorm:minMaxNorm}),VALID_DATA_FORMAT_VALUES=["channelsFirst","channelsLast"],VALID_PADDING_MODE_VALUES=["valid","same","causal"],VALID_POOL_MODE_VALUES=["max","avg"],VALID_BIDIRECTIONAL_MERGE_MODES=["sum","mul","concat","ave"],nameMap=new Map;function checkDataFormat(e){checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES,"DataFormat",e)}function checkPaddingMode(e){checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES,"PaddingMode",e)}function checkPoolMode(e){checkStringTypeUnionValue(VALID_POOL_MODE_VALUES,"PoolMode",e)}var _nameScopeStack=[],_nameScopeDivider="/";function nameScope(e,t){_nameScopeStack.push(e);try{var n=t();return _nameScopeStack.pop(),n}catch(e){throw _nameScopeStack.pop(),e}}function currentNameScopePrefix(){return 0===_nameScopeStack.length?"":_nameScopeStack.join(_nameScopeDivider)+_nameScopeDivider}function getScopedTensorName(e){if(!isValidTensorName(e))throw new Error("Not a valid tensor name: '"+e+"'");return currentNameScopePrefix()+e}function getUniqueTensorName(e){if(!isValidTensorName(e))throw new Error("Not a valid tensor name: '"+e+"'");nameMap.has(e)||nameMap.set(e,0);var t=nameMap.get(e);if(nameMap.set(e,nameMap.get(e)+1),t>0){var n=e+"_"+t;return nameMap.set(n,1),n}return e}var tensorNameRegex=new RegExp(/^[A-Za-z][-A-Za-z0-9\._\/]*$/);function isValidTensorName(e){return!!e.match(tensorNameRegex)}function isInteger(e){return e===parseInt(e.toString(),10)}function arrayProd(e,t,n){null==t&&(t=0),null==n&&(n=e.length);for(var r=1,i=t;i<n;++i)r*=e[i];return r}function toArray1D(e){return e=Array.isArray(e)?new Float32Array(e):e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(e)}function min$1(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["min"])(toArray1D(e)).dataSync()[0]}function max$1(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(toArray1D(e)).dataSync()[0]}function range(e,t){if(t<e)throw new ValueError("end ("+t+") < begin ("+e+") is forbidden.");for(var n=[],r=e;r<t;++r)n.push(r);return n}function cast$1(e,t){return e.asType(t)}function expandDims$1(e,t){void 0===t&&(t=-1);var n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),e.reshape(n)}function repeat(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(2!==e.shape.length)throw new ValueError("repeat() expects a rank-2 tensor, but received a rank-"+e.shape.length+" tensor.");return tile$1(expandDims$1(e,1),[1,t,1])})}function flatten(e){var t=[arrayProd(e.shape)];return e.reshape(t)}function batchFlatten(e){if(e.rank<=1)throw new ValueError("batchFlatten requires a minimum rank of 2. Got rank: "+e.rank+".");var t=[e.shape[0],arrayProd(e.shape,1)];return e.reshape(t)}function sliceAlongFirstAxis(e,t,n){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){switch(e.rank){case 1:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice1d"])(e,t,n);case 2:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice2d"])(e,[t,0],[n,e.shape[1]]);case 3:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice3d"])(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice4d"])(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);default:throw new ValueError("sliceAlongFirstAxis() received an unsupported tensor rank: "+e.rank)}})}function sliceAlongLastAxis(e,t,n){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){switch(e.rank){case 1:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice1d"])(e,t,n);case 2:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice2d"])(e,[0,t],[e.shape[0],n]);case 3:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice3d"])(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice4d"])(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new ValueError("sliceAlongLastAxis() received an unsupported tensor rank: "+e.rank)}})}function sliceAlongAxis(e,t,n,r){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){switch(e.rank){case 1:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice1d"])(e,t,n);case 2:switch(r){case 1:return sliceAlongFirstAxis(e,t,n);case 2:return sliceAlongLastAxis(e,t,n);default:throw new ValueError("The axis is not within the rank of the tensor "+r)}case 3:switch(r){case 1:return sliceAlongFirstAxis(e,t,n);case 2:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice3d"])(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return sliceAlongLastAxis(e,t,n);default:throw new ValueError("The axis is not within the rank of the tensor "+r)}case 4:switch(r){case 1:return sliceAlongFirstAxis(e,t,n);case 2:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice4d"])(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice4d"])(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return sliceAlongLastAxis(e,t,n);default:throw new ValueError("The axis is not within the rank of the tensor "+r)}default:throw new ValueError("sliceAlongLastAxis() received an unsupported tensor rank: "+e.rank)}})}function concatenate(e,t){var n;return void 0===t&&(t=-1),t<0&&(t=0!==(n=e[0].rank)?n:0),t===e[0].rank&&(t=-1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"])(e,t)}function concatAlongFirstAxis(e,t){switch(e.rank){case 1:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat1d"])([e,t]);case 2:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat2d"])([e,t],0);case 3:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat3d"])([e,t],0);case 4:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat4d"])([e,t],0);default:throw new ValueError("concatAlongFirstAxis() received an unsupported tensor rank: "+e.rank)}}function tile$1(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new ValueError("The length of input n ("+t.length+") does not match the number of dimensions in input x ("+e.rank+")");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tile"])(e,t)}function randomNormal$1(e,t,n,r,i){return void 0===t&&(t=0),void 0===n&&(n=1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomNormal"])(e,t,n,r,i)}function dot(e,t,n,r){if(e.rank<2||t.rank<2)throw new NotImplementedError("dot requires both inputs to be rank >= 2 but got x shape = "+e.shape+" and y shape = "+t.shape);if(t.rank>=3&&(s=e.shape.slice(-1)[0])!==(c=t.shape.slice(-2)[0]))throw new NotImplementedError("If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = "+e.shape+" and  y shape = "+t.shape);if(2===e.rank&&2===t.rank){var i=!1,a=!1;return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fused"].matMul(e,t,i,a,r?reshapeBias(e.rank,r,imageDataFormat()):null,n)}var o=e.shape.slice(),s=o.pop();e=e.reshape([-1,s]);var l=t.shape.slice(),u=l.pop(),c=l.pop(),p=l.concat([u]),h=Array.from({length:t.rank},function(e,n){return 0===n?t.rank-2:n<=t.rank-2?n-1:n});t=t.transpose(h).reshape([c,-1]);var d=o.concat(p);i=!1,a=!1;return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fused"].matMul(e,t,i,a,r?reshapeBias(e.rank,r,imageDataFormat()):null,n).reshape(d)}function gather$1(e,t,n){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return t=Array.isArray(t)?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(t,"int32"):t.toInt(),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["gather"])(e,t,n)})}function square(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mulStrict"])(e,e)}function reshapeBias(e,t,n){var r=t.shape;if(1!==t.rank&&t.rank!==e)throw new ValueError("Unexpected bias dimensions: "+t.rank+"; expected it to be 1 or "+e);if(5===e){if("channelsFirst"===n)return 1===r.length?t.reshape([1,r[0],1,1,1]):t.reshape([1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?t.reshape([1,1,1,1,r[0]]):t.reshape([1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?t.reshape([1,r[0],1,1]):t.reshape([1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?t.reshape([1,1,1,r[0]]):t.reshape([1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?t.reshape([1,r[0],1]):t.reshape([1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?t.reshape([1,1,r[0]]):t.reshape([1].concat(r))}else if(e<3)return t;throw new ValueError("Unsupported input rank by biasAdd: "+t.rank)}function biasAdd(e,t,n){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return null==n&&(n=imageDataFormat()),checkDataFormat(n),e.add(reshapeBias(e.rank,t,n))})}function elu$1(e,t){if(void 0===t&&(t=1),1!==t)throw new NotImplementedError("Support for alpha values other than 1 ("+t+") is not implemented yet.");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["elu"])(e)}function softsign(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(e).add(1))})}function dropout(e,t,n,r){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null!=n&&!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(e.shape,n))throw new NotImplementedError("Non-default noise shape is not implemented yet: "+JSON.stringify(n));if(null!=r)throw new NotImplementedError("seed is not implemented for dropout yet.");var i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["step"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(-t,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"])(e.shape,0,1,"float32")));return i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(1/(1-t),i),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,i)})}function hardSigmoid(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(.5,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(.2,e));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,0,1)})}function inTrainPhase(e,t,n){return void 0===n&&(n=!1),n?e():t()}var VALID_FAN_MODE_VALUES=["fanIn","fanOut","fanAvg"],VALID_DISTRIBUTION_VALUES=["normal","uniform","truncatedNormal"];function checkFanMode(e){checkStringTypeUnionValue(VALID_FAN_MODE_VALUES,"FanMode",e)}function checkDistribution(e){checkStringTypeUnionValue(VALID_DISTRIBUTION_VALUES,"Distribution",e)}var Initializer=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.fromConfigUsesCustomObjects=function(){return!1},t.prototype.getConfig=function(){return{}},t}(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].Serializable),Zeros=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])(e,t)},t.className="Zeros",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Zeros);var Ones=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ones"])(e,t)},t.className="Ones",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Ones);var Constant=function(e){function t(t){var n=e.call(this)||this;if("object"!=typeof t)throw new ValueError("Expected argument of type ConstantConfig but got "+t);if(void 0===t.value)throw new ValueError("config must have value set but got "+t);return n.value=t.value,n}return __extends(t,e),t.prototype.apply=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(n.value),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ones"])(e,t))})},t.prototype.getConfig=function(){return{value:this.value}},t.className="Constant",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Constant);var RandomUniform=function(e){function t(t){var n=e.call(this)||this;return n.DEFAULT_MINVAL=-.05,n.DEFAULT_MAXVAL=.05,n.minval=t.minval||n.DEFAULT_MINVAL,n.maxval=t.maxval||n.DEFAULT_MAXVAL,n.seed=t.seed,n}return __extends(t,e),t.prototype.apply=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"])(e,this.minval,this.maxval,t)},t.prototype.getConfig=function(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}},t.className="RandomUniform",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(RandomUniform);var RandomNormal=function(e){function t(t){var n=e.call(this)||this;return n.DEFAULT_MEAN=0,n.DEFAULT_STDDEV=.05,n.mean=t.mean||n.DEFAULT_MEAN,n.stddev=t.stddev||n.DEFAULT_STDDEV,n.seed=t.seed,n}return __extends(t,e),t.prototype.apply=function(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new NotImplementedError("randomNormal does not support dType "+t+".");return randomNormal$1(e,this.mean,this.stddev,t,this.seed)},t.prototype.getConfig=function(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}},t.className="RandomNormal",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(RandomNormal);var TruncatedNormal=function(e){function t(t){var n=e.call(this)||this;return n.DEFAULT_MEAN=0,n.DEFAULT_STDDEV=.05,n.mean=t.mean||n.DEFAULT_MEAN,n.stddev=t.stddev||n.DEFAULT_STDDEV,n.seed=t.seed,n}return __extends(t,e),t.prototype.apply=function(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new NotImplementedError("truncatedNormal does not support dType "+t+".");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["truncatedNormal"])(e,this.mean,this.stddev,t,this.seed)},t.prototype.getConfig=function(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}},t.className="TruncatedNormal",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(TruncatedNormal);var Identity=function(e){function t(t){var n=e.call(this)||this;return n.gain=null!=t.gain?t.gain:1,n}return __extends(t,e),t.prototype.apply=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(2!==e.length||e[0]!==e[1])throw new ValueError("Identity matrix initializer can only be used for 2D square matrices.");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(n.gain,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["eye"])(e[0]))})},t.prototype.getConfig=function(){return{gain:this.gain}},t.className="Identity",t}(Initializer);function computeFans(e,t){var n,r;if(void 0===t&&(t="channelsLast"),checkDataFormat(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){var i=arrayProd(e,2);n=e[1]*i,r=e[0]*i}else if("channelsLast"===t){i=arrayProd(e,0,e.length-2);n=e[e.length-2]*i,r=e[e.length-1]*i}}else{var a=arrayProd(e);n=Math.sqrt(a),r=Math.sqrt(a)}return[n,r]}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Identity);var VarianceScaling=function(e){function t(t){var n=e.call(this)||this;if(t.scale<0)throw new ValueError("scale must be a positive float. Got: "+t.scale);return n.scale=null==t.scale?1:t.scale,n.mode=null==t.mode?"fanIn":t.mode,checkFanMode(n.mode),n.distribution=null==t.distribution?"normal":t.distribution,checkDistribution(n.distribution),n.seed=t.seed,n}return __extends(t,e),t.prototype.apply=function(e,t){var n=computeFans(e),r=n[0],i=n[1],a=this.scale;if("fanIn"===this.mode?a/=Math.max(1,r):"fanOut"===this.mode?a/=Math.max(1,i):a/=Math.max(1,(r+i)/2),"normal"===this.distribution){var o=Math.sqrt(a);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new NotImplementedError(this.getClassName()+" does not support dType "+t+".");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["truncatedNormal"])(e,0,o,t,this.seed)}var s=Math.sqrt(3*a);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"])(e,-s,s,t)},t.prototype.getConfig=function(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}},t.className="VarianceScaling",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(VarianceScaling);var GlorotUniform=function(e){function t(t){return e.call(this,{scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="GlorotUniform",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlorotUniform);var GlorotNormal=function(e){function t(t){return e.call(this,{scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="GlorotNormal",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlorotNormal);var HeNormal=function(e){function t(t){return e.call(this,{scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="HeNormal",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(HeNormal);var HeUniform=function(e){function t(t){return e.call(this,{scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="HeUniform",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(HeUniform);var LeCunNormal=function(e){function t(t){return e.call(this,{scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="LeCunNormal",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LeCunNormal);var LeCunUniform=function(e){function t(t){return e.call(this,{scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="LeCunNormal",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LeCunUniform);var Orthogonal=function(e){function t(t){var n=e.call(this)||this;if(n.DEFAULT_GAIN=1,n.gain=null==t.gain?n.DEFAULT_GAIN:t.gain,n.seed=t.seed,null!=n.seed)throw new NotImplementedError("Random seed is not implemented for Orthogonal Initializer yet.");return n}return __extends(t,e),t.prototype.apply=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(2!==e.length)throw new NotImplementedError("The Orthogonal Initializer does not support non-2D shapes yet.");e[0]*e[1]>2e3&&console.warn("Orthogonal initializer is being called on a matrix with more than 2000 ("+e[0]*e[1]+") elements: Slowness may result.");var t=randomNormal$1(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32"),r=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["linalg"].gramSchmidt(t);return e[0]>e[1]&&(r=r.transpose()),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(n.gain,r)})},t.prototype.getConfig=function(){return{gain:this.gain,seed:this.seed}},t.className="Orthogonal",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Orthogonal);var INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function deserializeInitializer(e,t){return void 0===t&&(t={}),deserializeKerasObject(e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].SerializationMap.getMap().classNameMap,t,"initializer")}function serializeInitializer(e){return serializeKerasObject(e)}function getInitializer(e){if("string"==typeof e){var t=e in INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP?INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[e]:e;if("GlorotNormal"===t)return new GlorotNormal;if("GlorotUniform"===t)return new GlorotUniform;if("HeNormal"===t)return new HeNormal;if("HeUniform"===t)return new HeUniform;if("LeCunNormal"===t)return new LeCunNormal;if("LeCunUniform"===t)return new LeCunUniform;var n={};return n.className=t,n.config={},deserializeInitializer(n)}return e instanceof Initializer?e:deserializeInitializer(e)}function zeros$1(){return new Zeros}function ones$1(){return new Ones}function constant(e){return new Constant(e)}function randomUniform$1(e){return new RandomUniform(e)}function randomNormal$2(e){return new RandomNormal(e)}function truncatedNormal$1(e){return new TruncatedNormal(e)}function identity(e){return new Identity(e)}function varianceScaling(e){return new VarianceScaling(e)}function glorotUniform(e){return new GlorotUniform(e)}function glorotNormal(e){return new GlorotNormal(e)}function heNormal(e){return new HeNormal(e)}function heUniform(e){return new HeUniform(e)}function leCunNormal(e){return new LeCunNormal(e)}function leCunUniform(e){return new LeCunUniform(e)}function orthogonal(e){return new Orthogonal(e)}var exports_initializers=Object.freeze({zeros:zeros$1,ones:ones$1,constant:constant,randomUniform:randomUniform$1,randomNormal:randomNormal$2,truncatedNormal:truncatedNormal$1,identity:identity,varianceScaling:varianceScaling,glorotUniform:glorotUniform,glorotNormal:glorotNormal,heNormal:heNormal,heUniform:heUniform,leCunNormal:leCunNormal,leCunUniform:leCunUniform,orthogonal:orthogonal}),_nextUniqueTensorId=0;function getNextUniqueTensorId(){return _nextUniqueTensorId++}var _uidPrefixes={};function getUid(e){return void 0===e&&(e=""),e in _uidPrefixes||(_uidPrefixes[e]=0),_uidPrefixes[e]+=1,e+_uidPrefixes[e].toString()}function isArrayOfShapes(e){return Array.isArray(e)&&Array.isArray(e[0])}function normalizeShapeList(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function getExactlyOneTensor(e){var t;if(Array.isArray(e)){if(1!==e.length)throw new ValueError("Expected Tensor length to be 1; got "+e.length);t=e[0]}else t=e;return t}function getExactlyOneShape(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return(e=e)[0];throw new ValueError("Expected exactly 1 Shape; got "+e.length)}return e}function countParamsInWeights(e){for(var t=0,n=0,r=e;n<r.length;n++){var i=r[n];0===i.shape.length?t+=1:t+=i.shape.reduce(function(e,t){return e*t})}return t}var DEFAULT_VARIABLE_NAME_PREFIX="Variable",LayerVariable=function(){function e(e,t,n,r,i){void 0===t&&(t="float32"),void 0===n&&(n=DEFAULT_VARIABLE_NAME_PREFIX),void 0===r&&(r=!0),void 0===i&&(i=null),this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=getNextUniqueTensorId(),n=null==n?DEFAULT_VARIABLE_NAME_PREFIX:n,this.originalName=getScopedTensorName(n),this.name=getUniqueTensorName(this.originalName),this.trainable_=r,this.constraint=i,this.val=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["variable"])(e,this.trainable_,this.name,this.dtype)}return e.prototype.read=function(){return this.assertNotDisposed(),this.val},e.prototype.write=function(e){return this.assertNotDisposed(),checkShapesMatch(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this},e.prototype.dispose=function(){this.assertNotDisposed(),this.val.dispose()},e.prototype.assertNotDisposed=function(){if(this.val.isDisposed)throw new Error("LayersVariable "+this.name+" is already disposed.")},Object.defineProperty(e.prototype,"trainable",{get:function(){return this.trainable_},set:function(e){this.trainable_=e,this.val.trainable=e},enumerable:!0,configurable:!0}),e}();function checkShapesMatch(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function batchGetValue(e){return e.map(function(e){return e.read()})}function batchSetValue(e){e.forEach(function(e){e[0].write(e[1])})}var InputSpec=function(){return function(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}(),SymbolicTensor=function(){return function(e,t,n,r,i,a,o){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=i,this.outputTensorIndex=o,this.id=getNextUniqueTensorId(),null!=a&&(this.originalName=getScopedTensorName(a),this.name=getUniqueTensorName(this.originalName)),this.rank=t.length}}(),_nextNodeID=0,Node=function(){function e(e,t){this.callArgs=t,this.id=_nextNodeID++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(var n=0,r=e.inboundLayers;n<r.length;n++){var i=r[n];null!=i&&i.outboundNodes.push(this)}e.outboundLayer.inboundNodes.push(this)}return e.prototype.getConfig=function(){for(var e=[],t=0,n=this.inboundLayers;t<n.length;t++){var r=n[t];null!=r?e.push(r.name):e.push(null)}return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}},e}(),_nextLayerID=0,Layer=function(e){function t(t){var n=e.call(this)||this;n._callHook=null,n._addedWeightNames=[],n._stateful=!1,n.id=_nextLayerID++,n.activityRegularizer=null,n.inputSpec=null,n.supportsMasking=!1,n._trainableWeights=[],n._nonTrainableWeights=[],n._losses=[],n._updates=[],n._built=!1,n.inboundNodes=[],n.outboundNodes=[];var r=t.name;if(!r){var i=n.getClassName();r=toSnakeCase(i)+"_"+getUid(i)}if(n.name=r,n.trainable_=null==t.trainable||t.trainable,n.updatable=null==t.updatable||t.updatable,null!=t.inputShape||null!=t.batchInputShape){var a=void 0;if(null!=t.batchInputShape)a=t.batchInputShape;else if(null!=t.inputShape){var o=null;null!=t.batchSize&&(o=t.batchSize),a=[o].concat(t.inputShape)}n.batchInputShape=a;var s=t.dtype;null==s&&(s=t.inputDType),null==s&&(s="float32"),n.dtype=s}return null!=t.weights?n.initialWeights=t.weights:n.initialWeights=null,n._refCount=null,n.fastWeightInitDuringBuild=!1,n}return __extends(t,e),t.nodeKey=function(e,t){return e.name+"_ib-"+t.toString()},t.prototype.getNodeAtIndex=function(e,t){if(0===this.inboundNodes.length)throw new RuntimeError("The layer has never been called and thus has no defined "+t+".");if(this.inboundNodes.length<=e)throw new ValueError("Asked to get "+t+" at node "+e+", but the layer has only "+this.inboundNodes.length+" inbound nodes.");return this.inboundNodes[e]},t.prototype.getInputAt=function(e){return singletonOrArray(this.getNodeAtIndex(e,"input").inputTensors)},t.prototype.getOutputAt=function(e){return singletonOrArray(this.getNodeAtIndex(e,"output").outputTensors)},Object.defineProperty(t.prototype,"input",{get:function(){if(this.inboundNodes.length>1)throw new AttributeError("Layer "+this.name+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new AttributeError("Layer "+this.name+" is not connected, no input to return.");return singletonOrArray(this.getNodeAtIndex(0,"input").inputTensors)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"output",{get:function(){if(0===this.inboundNodes.length)throw new AttributeError("Layer "+this.name+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new AttributeError("Layer "+this.name+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return singletonOrArray(this.getNodeAtIndex(0,"output").outputTensors)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"losses",{get:function(){return this._losses},enumerable:!0,configurable:!0}),t.prototype.calculateLosses=function(){return this.losses.map(function(e){return e()})},Object.defineProperty(t.prototype,"updates",{get:function(){return this._updates},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"built",{get:function(){return this._built},set:function(e){this._built=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"trainable",{get:function(){return this.trainable_},set:function(e){this._trainableWeights.forEach(function(t){return t.trainable=e}),this.trainable_=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"trainableWeights",{get:function(){return this.trainable_?this._trainableWeights.filter(function(e){return e.trainable}):[]},set:function(e){this._trainableWeights=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){return this.trainable?this._trainableWeights.filter(function(e){return!e.trainable}).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)},set:function(e){this._nonTrainableWeights=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"weights",{get:function(){return this.trainableWeights.concat(this.nonTrainableWeights)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"stateful",{get:function(){return this._stateful},enumerable:!0,configurable:!0}),t.prototype.resetStates=function(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")},t.prototype.assertInputCompatibility=function(e){if(e=toList(e),null!=this.inputSpec&&0!==this.inputSpec.length){var t=toList(this.inputSpec);if(e.length!==t.length)throw new ValueError("Layer "+this.name+" expects "+t.length+" inputs, but it received "+e.length+" input tensors. Input received: "+e);for(var n=0;n<e.length;n++){var r=e[n],i=t[n];if(null!=i){var a=r.rank;if(null!=i.ndim&&a!==i.ndim)throw new ValueError("Input "+n+" is incompatible with layer "+this.name+": expected ndim="+i.ndim+", found ndim="+a);if(null!=i.maxNDim&&a>i.maxNDim)throw new ValueError("Input "+n+" is incompatible with layer "+this.name+": expected max_ndim="+i.maxNDim+", found ndim="+a);if(null!=i.minNDim&&a<i.minNDim)throw new ValueError("Input "+n+" is incompatible with layer "+this.name+": expected min_ndim="+i.minNDim+", found ndim="+a+".");if(null!=i.dtype&&r.dtype!==i.dtype)throw new ValueError("Input "+n+" is incompatible with layer "+this.name+" : expected dtype="+i.dtype+", found dtype="+r.dtype+".");if(i.axes){var o=r.shape;for(var s in i.axes){var l=Number(s),u=i.axes[s],c=l>=0?o[l]:o[o.length+l];if(null!=u&&-1===[u,null].indexOf(c))throw new ValueError("Input "+n+" is incompatible with layer "+this.name+": expected axis "+l+" of input shape to have value "+u+" but got shape "+o+".")}}if(null!=i.shape)for(var p=0;p<i.shape.length;++p){var h=i.shape[p],d=r.shape[p];if(null!=h&&null!=d&&h!==d)throw new ValueError("Input "+n+" is incompatible with layer "+this.name+": expected shape="+i.shape+", found shape="+r.shape+".")}}}}},t.prototype.call=function(e,t){return e},t.prototype.invokeCallHook=function(e,t){null!=this._callHook&&this._callHook(e,t)},t.prototype.setCallHook=function(e){this._callHook=e},t.prototype.clearCallHook=function(){this._callHook=null},t.prototype.apply=function(e,t){var n=this;t=t||{},this.assertNotDisposed();for(var r=toList(e),i=!0,a=0,o=r;a<o.length;a++){if(!(o[a]instanceof SymbolicTensor)){i=!1;break}}for(var s=!0,l=0,u=r;l<u.length;l++){if(u[l]instanceof SymbolicTensor){s=!1;break}}if(i===s)throw new ValueError("Arguments to apply() must be all SymbolicTensors or all Tensors");return nameScope(this.name,function(){if(!n.built){n.assertInputCompatibility(e);for(var i=[],a=0,o=toList(e);a<o.length;a++){var l=o[a];i.push(l.shape)}n.build(singletonOrArray(i)),n.built=!0,n.initialWeights&&n.setWeights(n.initialWeights),null===n._refCount&&s&&(n._refCount=1)}if(n.assertInputCompatibility(e),s){for(var u=[],c=0,p=toList(g=n.call(e,t));c<p.length;c++){var h=p[c];-1!==r.indexOf(h)&&(h=h.clone()),u.push(h)}if(g=singletonOrArray(u),null!=n.activityRegularizer)throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return g}var d=collectInputShape(e),f=n.computeOutputShape(d),g=void 0,m=guessOutputDType(e);if(n.warnOnIncompatibleInputShape(Array.isArray(e)?d[0]:d),g=null!=f&&f.length>0&&Array.isArray(f[0])?f.map(function(r,i){return new SymbolicTensor(m,r,n,toList(e),t,n.name,i)}):new SymbolicTensor(m,f,n,toList(e),t,n.name),n.addInboundNode(e,g,null,null,d,f,t),n._refCount++,null!=n.activityRegularizer)throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return g})},t.prototype.warnOnIncompatibleInputShape=function(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+JSON.stringify(e)+") does not match that of the batchInputShape ("+JSON.stringify(this.batchInputShape)+") of the layer "+this.name);else{var t=!1;this.batchInputShape.forEach(function(n,r){null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)}),t&&console.warn("The shape of the input tensor ("+JSON.stringify(e)+") does not match the expectation of layer "+this.name+": "+JSON.stringify(this.batchInputShape))}},Object.defineProperty(t.prototype,"outputShape",{get:function(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new AttributeError("The layer "+this.name+" has never been called and thus has no defined output shape.");for(var e=[],t=0,n=this.inboundNodes;t<n.length;t++){var r=n[t],i=JSON.stringify(r.outputShapes);-1===e.indexOf(i)&&e.push(i)}if(1===e.length){var a=this.inboundNodes[0].outputShapes;return Array.isArray(a)&&Array.isArray(a[0])&&1===a.length?a[0]:a}throw new AttributeError("The layer "+this.name+' has multiple inbound nodes with different output shapes. Hence the notion of "outut shape" is ill-defined for the layer.')},enumerable:!0,configurable:!0}),t.prototype.countParams=function(){if(!this.built)throw new RuntimeError("You tried to call countParams() on "+this.name+", but the layer is not built yet. Build it first by calling build(batchInputShape).");return countParamsInWeights(this.weights)},t.prototype.build=function(e){this.built=!0},t.prototype.getWeights=function(e){return void 0===e&&(e=!1),batchGetValue(e?this.trainableWeights:this.weights)},t.prototype.setWeights=function(e){var t=this;Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=t.weights;if(n.length!==e.length)throw new ValueError('You called setWeights(weights) on layer "'+t.name+'" with a weight list of length '+e.length+", but the layer was expecting "+n.length+" weights. Provided weights: "+e+"...");if(0!==n.length){for(var r=[],i=batchGetValue(n),a=0;a<i.length;++a){var o=i[a],s=n[a],l=e[a];if(!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(o.shape,l.shape))throw new ValueError("Layer weight shape "+o.shape+" not compatible with provided weight shape "+l.shape);r.push([s,l])}batchSetValue(r)}})},t.prototype.addWeight=function(e,t,n,r,i,a,o){if(-1!==this._addedWeightNames.indexOf(e))throw new ValueError("Duplicate weight name "+e+" for layer "+this.name);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=getInitializer("zeros"));var s=r.apply(t,n),l=new LayerVariable(s,n,e,a,o);return s.dispose(),null!=i&&this.addLoss(function(){return i.apply(l.read())}),null==a&&(a=!0),a?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l},t.prototype.setFastWeightInitDuringBuild=function(e){this.fastWeightInitDuringBuild=e},t.prototype.addLoss=function(e){var t;null==e||Array.isArray(e)&&0===e.length||(e=toList(e),void 0!==this._losses&&null!==this._losses&&(t=this.losses).push.apply(t,e))},t.prototype.computeOutputShape=function(e){return e},t.prototype.computeMask=function(e,t){var n=this;if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError("Layer "+this.name+" does not support masking, but was passed an inputMask.");t.forEach(function(e){if(null!=e)throw new TypeError("Layer "+n.name+" does not support masking, but was passed an inputMask.")})}return null}return t},t.prototype.addInboundNode=function(e,t,n,r,i,a,o){void 0===o&&(o=null);var s=toList(e);t=toList(t),n=toList(n),r=toList(r),i=normalizeShapeList(i),a=normalizeShapeList(a);for(var l=[],u=[],c=[],p=0,h=s;p<h.length;p++){var d=h[p];l.push(d.sourceLayer),u.push(d.nodeIndex),c.push(d.tensorIndex)}new Node({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:s,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:i,outputShapes:a},o);for(var f=0;f<t.length;f++)t[f].sourceLayer=this,t[f].nodeIndex=this.inboundNodes.length-1,t[f].tensorIndex=f},t.prototype.getConfig=function(){var e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e},t.prototype.disposeWeights=function(){return this.weights.forEach(function(e){return e.dispose()}),this.weights.length},t.prototype.assertNotDisposed=function(){if(0===this._refCount)throw new Error("Layer '"+this.name+"' is already disposed.")},t.prototype.dispose=function(){if(!this.built)throw new Error("Cannot dispose Layer "+this.name+" because it has not been built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer "+this.name+" because it has not been used yet.");this.assertNotDisposed();var e=0;return 0==--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}},t}(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].Serializable);function collectInputShape(e){for(var t=[],n=0,r=e=toList(e);n<r.length;n++){var i=r[n];t.push(i.shape)}return singletonOrArray(t)}function guessOutputDType(e){return"float32"}function getSourceInputs(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];var r=t.inboundNodes[n];if(0===r.inboundLayers.length)return r.inputTensors;for(var i=[],a=0;a<r.inboundLayers.length;a++)for(var o=0,s=getSourceInputs(r.inputTensors[a],r.inboundLayers[a],r.nodeIndices[a]);o<s.length;o++){var l=s[o];-1===i.indexOf(l)&&i.push(l)}return i}var ModelLoggingVerbosity,InputLayer=function(e){function t(t){var n=e.call(this,{dtype:t.dtype,name:null!=t.name?t.name:getUid("input").toString()})||this;if(null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),n.trainable=!1,n.built=!0,n.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new ValueError("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");var r=t.batchInputShape;if(null==r){if(null==t.inputShape)throw new ValueError("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new ValueError("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");var i=t.dtype||"float32";n.batchInputShape=r,n.dtype=i,n.inputSpec=[{shape:r}];var a=new SymbolicTensor(n.dtype,n.batchInputShape,n,[],{},n.name);return a.nodeIndex=0,a.tensorIndex=0,new Node({outboundLayer:n,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]}),n}return __extends(t,e),t.prototype.apply=function(e,t){throw new ValueError("Cannot pass any input to an InputLayer's apply() method. InputLayer name: "+this.name)},t.prototype.dispose=function(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}},t.prototype.getConfig=function(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}},t.className="InputLayer",t}(Layer);function Input(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new ValueError("Please provide either a `shape` or `batchShape` argument to Input, but not both.");var t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));var n=e.dtype;return null==n&&(n="float32"),new InputLayer({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function resolveScalarsInLogs(e){return __awaiter(this,void 0,void 0,function(){var t,n,r,i,a,o,s,l;return __generator(this,function(u){switch(u.label){case 0:if(null==e)return[2];for(i in t=[],n=[],r=[],e)"number"!=typeof(a=e[i])&&(o=a,t.push(o.data()),n.push(i),r.push(o));return t.length>0?[4,Promise.all(t)]:[3,2];case 1:for(s=u.sent(),l=0;l<s.length;++l)e[n[l]]=s[l][0];Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r),u.label=2;case 2:return[2]}})})}function disposeTensorsInLogs(e){if(null!=e)for(var t in e){var n=e[t];"number"!=typeof n&&n.dispose()}}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(InputLayer),function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(ModelLoggingVerbosity||(ModelLoggingVerbosity={}));var DEFAULT_YIELD_EVERY_MS=125,BaseCallback=function(){function e(){this.validationData=null}return e.prototype.setParams=function(e){this.params=e},e.prototype.onEpochBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.onBatchBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.onBatchEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.onTrainBegin=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.onTrainEnd=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.setModel=function(e){},e}(),CallbackList=function(){function e(e,t){void 0===t&&(t=10),null==e&&(e=[]),this.callbacks=e,this.queueLength=t}return e.prototype.append=function(e){this.callbacks.push(e)},e.prototype.setParams=function(e){for(var t=0,n=this.callbacks;t<n.length;t++){n[t].setParams(e)}},e.prototype.setModel=function(e){for(var t=0,n=this.callbacks;t<n.length;t++){n[t].setModel(e)}},e.prototype.onEpochBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r;return __generator(this,function(i){switch(i.label){case 0:null==t&&(t={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onEpochBegin(e,t)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}})})},e.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r;return __generator(this,function(i){switch(i.label){case 0:null==t&&(t={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onEpochEnd(e,t)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}})})},e.prototype.onBatchBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r;return __generator(this,function(i){switch(i.label){case 0:null==t&&(t={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onBatchBegin(e,t)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}})})},e.prototype.onBatchEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r;return __generator(this,function(i){switch(i.label){case 0:null==t&&(t={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onBatchEnd(e,t)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}})})},e.prototype.onTrainBegin=function(e){return __awaiter(this,void 0,void 0,function(){var t,n;return __generator(this,function(r){switch(r.label){case 0:null==e&&(e={}),t=0,n=this.callbacks,r.label=1;case 1:return t<n.length?[4,n[t].onTrainBegin(e)]:[3,4];case 2:r.sent(),r.label=3;case 3:return t++,[3,1];case 4:return[2]}})})},e.prototype.onTrainEnd=function(e){return __awaiter(this,void 0,void 0,function(){var t,n;return __generator(this,function(r){switch(r.label){case 0:null==e&&(e={}),t=0,n=this.callbacks,r.label=1;case 1:return t<n.length?[4,n[t].onTrainEnd(e)]:[3,4];case 2:r.sent(),r.label=3;case 3:return t++,[3,1];case 4:return[2]}})})},e}(),BaseLogger=function(e){function t(){return e.call(this)||this}return __extends(t,e),t.prototype.onEpochBegin=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return this.seen=0,this.totals={},[2]})})},t.prototype.onBatchEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var e,n,r,i,a=this;return __generator(this,function(o){for(i in null==t&&(t={}),e=null==t.size?0:t.size,this.seen+=e,n=function(n){var i=t[n];if("number"==typeof i)r.totals.hasOwnProperty(n)||(r.totals[n]=0),r.totals[n]=r.totals[n]+i*e;else{var o=void 0;n in r.totals?o=r.totals[n]:r.totals[n]=0,r.totals[n]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(a.totals[n],Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(i,e))}),null!=o&&o.dispose()}},r=this,t)n(i);return[2]})})},t.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var e,n,r,i,a,o=this;return __generator(this,function(s){if(null!=t)for(e=function(e){if(null==n.totals[e])return"continue";"number"==typeof n.totals[e]?t[e]=n.totals[e]/n.seen:Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){t[e]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(1,o.seen),o.totals[e]),o.totals[e].dispose(),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(t[e])})},n=this,r=0,i=this.params.metrics;r<i.length;r++)a=i[r],e(a);return[2]})})},t}(BaseCallback),History=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.onTrainBegin=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return this.epoch=[],this.history={},[2]})})},t.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(r){for(n in null==t&&(t={}),this.epoch.push(e),t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n]);return[2]})})},t.prototype.syncData=function(){return __awaiter(this,void 0,void 0,function(){var e,t,n,r,i,a,o,s,l;return __generator(this,function(u){switch(u.label){case 0:for(r in e=[],t=[],n=[],this.history)for(i=this.history[r],a=0;a<i.length;++a)"number"!=typeof i[a]&&(o=i[a],e.push(o.data()),t.push(r),n.push(a));return[4,Promise.all(e)];case 1:for(s=u.sent(),l=0;l<s.length;++l)this.history[t[l]][n[l]].dispose(),this.history[t[l]][n[l]]=s[l][0];return[2]}})})},t}(BaseCallback),CustomCallback=function(e){function t(t,n){var r=e.call(this)||this;if(r.currentEpoch=0,r.yieldEvery=n||"auto","auto"===r.yieldEvery&&(r.yieldEvery=DEFAULT_YIELD_EVERY_MS),"never"===r.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].isNumber(r.yieldEvery)&&(r.maybeWait=debounce(r.maybeWait.bind(r),r.yieldEvery)),r.trainBegin=t.onTrainBegin,r.trainEnd=t.onTrainEnd,r.epochBegin=t.onEpochBegin,r.epochEnd=t.onEpochEnd,r.batchBegin=t.onBatchBegin,r.batchEnd=t.onBatchEnd,r.yield=t.onYield,r}return __extends(t,e),t.prototype.maybeWait=function(e,t,n){return __awaiter(this,void 0,void 0,function(){var r;return __generator(this,function(i){switch(i.label){case 0:return r=[],null==this.yield?[3,2]:[4,resolveScalarsInLogs(n)];case 1:i.sent(),r.push(this.yield(e,t,n)),i.label=2;case 2:return r.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["nextFrame"])()),[4,Promise.all(r)];case 3:return i.sent(),[2]}})})},t.prototype.onEpochBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){switch(n.label){case 0:return this.currentEpoch=e,null==this.epochBegin?[3,3]:[4,resolveScalarsInLogs(t)];case 1:return n.sent(),[4,this.epochBegin(e,t)];case 2:n.sent(),n.label=3;case 3:return[2]}})})},t.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(r){switch(r.label){case 0:return n=[],null==this.epochEnd?[3,2]:[4,resolveScalarsInLogs(t)];case 1:r.sent(),n.push(this.epochEnd(e,t)),r.label=2;case 2:return"epoch"===this.yieldEvery&&n.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["nextFrame"])()),[4,Promise.all(n)];case 3:return r.sent(),[2]}})})},t.prototype.onBatchBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){switch(n.label){case 0:return null==this.batchBegin?[3,3]:[4,resolveScalarsInLogs(t)];case 1:return n.sent(),[4,this.batchBegin(e,t)];case 2:n.sent(),n.label=3;case 3:return[2]}})})},t.prototype.onBatchEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(r){switch(r.label){case 0:return n=[],null==this.batchEnd?[3,2]:[4,resolveScalarsInLogs(t)];case 1:r.sent(),n.push(this.batchEnd(e,t)),r.label=2;case 2:return"batch"===this.yieldEvery?n.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["nextFrame"])()):_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),[4,Promise.all(n)];case 3:return r.sent(),[2]}})})},t.prototype.onTrainBegin=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return null==this.trainBegin?[3,3]:[4,resolveScalarsInLogs(e)];case 1:return t.sent(),[4,this.trainBegin(e)];case 2:t.sent(),t.label=3;case 3:return[2]}})})},t.prototype.onTrainEnd=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return null==this.trainEnd?[3,3]:[4,resolveScalarsInLogs(e)];case 1:return t.sent(),[4,this.trainEnd(e)];case 2:t.sent(),t.label=3;case 3:return[2]}})})},t}(BaseCallback);function standardizeCallbacks(e,t){return null==e&&(e={}),e instanceof BaseCallback?[e]:Array.isArray(e)&&e[0]instanceof BaseCallback?e:toList(e).map(function(e){return new CustomCallback(e,t)})}var CallbackConstructorRegistry=function(){function e(){}return e.registerCallbackConstructor=function(t,n){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(t>=0&&Number.isInteger(t),function(){return"Verbosity level is expected to be an integer >= 0, but got "+t}),e.checkForDuplicate(n),null==e.constructors[t]&&(e.constructors[t]=[]),e.constructors[t].push(n)},e.checkForDuplicate=function(t){for(var n in e.constructors){e.constructors[+n].forEach(function(e){if(e===t)throw new ValueError("Duplicate callback constructor.")})}},e.clear=function(){e.constructors={}},e.createCallbacks=function(t){var n=[];for(var r in e.constructors){var i=+r;t>=i&&n.push.apply(n,e.constructors[i])}return n.map(function(e){return new e})},e.constructors={},e}();function configureCallbacks(e,t,n,r,i,a,o,s,l){var u=new History,c=[new BaseLogger].concat(CallbackConstructorRegistry.createCallbacks(t));null!=e&&c.push.apply(c,e),c.push(u);var p=new CallbackList(c);return p.setParams({epochs:n,initialEpoch:r,samples:i,steps:a,batchSize:o,verbose:t,doValidation:s,metrics:l}),{callbackList:p,history:u}}function l2Normalize(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){"float32"!==e.dtype&&(e=e.asType("float32"));var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(square(e),t,!0),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fill"])(n.shape,epsilon()),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(n,r));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(e,i)})}function meanSquaredError(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(square(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(t,e)),-1)})}function meanAbsoluteError(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(t,e)),-1)})}function meanAbsolutePercentageError(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(e,t),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(e),epsilon(),Number.MAX_VALUE),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(n,r));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(100,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(i,-1))})}function meanSquaredLogarithmicError(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,epsilon(),Number.MAX_VALUE),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(1,n)),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(e,epsilon(),Number.MAX_VALUE),a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(1,i));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(square(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(r,a)),-1)})}function squaredHinge(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(0,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(1,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,t)));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(square(n),-1)})}function hinge(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(0,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(1,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,t)));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(n,-1)})}function categoricalHinge(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,t),-1),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(1,e),t),-1);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(0,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(1,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(r,n)))})}function logcosh(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Math.log(2),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(t,e),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(r,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softplus"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(-2,r))),n);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(i,-1)})}function categoricalCrossentropy(e,t,n){return void 0===n&&(n=!1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"])(t);else{var r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(t,t.shape.length-1,!0);t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(t,r)}return t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,epsilon(),1-epsilon()),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e.toFloat(),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(t)),t.shape.length-1))})}function sparseCategoricalCrossentropy(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["floor"])(flatten(e)).toInt(),r=(t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,epsilon(),1-epsilon())).shape;return categoricalCrossentropy(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["oneHot"])(n,r[r.length-1]).reshape(r),t,!1)})}function sigmoidCrossEntropyWithLogits(e,t){if(!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(e.shape,t.shape))throw new ValueError("logits and labels must have the same shape, but got shapes "+JSON.stringify(e.shape)+" and "+JSON.stringify(t.shape));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=t.relu(),r=t.abs().neg();return n.sub(t.mul(e)).add(r.exp().log1p())})}function binaryCrossentropy(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n;return n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,epsilon(),1-epsilon()),n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(n,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(1,n))),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(sigmoidCrossEntropyWithLogits(e,n),-1)})}function kullbackLeiblerDivergence(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(e,epsilon(),1),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,epsilon(),1);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(n,r))),-1)})}function poisson(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(epsilon(),t));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(t,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,n)),-1)})}function cosineProximity(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=l2Normalize(e,-1),r=l2Normalize(t,-1),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(n,r);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(i,-1))})}function get(e){var t={meanSquaredError:meanSquaredError,meanAbsoluteError:meanAbsoluteError,meanAbsolutePercentageError:meanAbsolutePercentageError,meanSquaredLogarithmicError:meanSquaredLogarithmicError,squaredHinge:squaredHinge,hinge:hinge,categoricalHinge:categoricalHinge,logcosh:logcosh,categoricalCrossentropy:categoricalCrossentropy,sparseCategoricalCrossentropy:sparseCategoricalCrossentropy,binaryCrossentropy:binaryCrossentropy,kullbackLeiblerDivergence:kullbackLeiblerDivergence,poisson:poisson,cosineProximity:cosineProximity};if("string"==typeof e){if(e in t)return t[e];var n="Unknown loss "+e;throw e.toLowerCase().includes("softmaxcrossentropy")&&(n="Unknown loss "+e+'. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new ValueError(n)}return e}function binaryAccuracy(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(.5,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(t)),r=cast$1(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greater"])(t,n),e.dtype);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equal"])(e,r),-1)})}function categoricalAccuracy(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return cast$1(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equal"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMax"])(e,-1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMax"])(t,-1)),"float32")})}function truePositives(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"])(e.equal(1),t.equal(1)).sum().cast("float32")})}function falseNegatives(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"])(e.equal(1),t.equal(0)).sum().cast("float32")})}function falsePositives(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"])(e.equal(0),t.equal(1)).sum().cast("float32")})}function precision(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=truePositives(e,t),r=falsePositives(e,t),i=n.add(r);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["where"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greater"])(i,0),n.div(i),0).cast("float32")})}function recall(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=truePositives(e,t),r=falseNegatives(e,t),i=n.add(r);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["where"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greater"])(i,0),n.div(i),0).cast("float32")})}function binaryCrossentropy$1(e,t){return binaryCrossentropy(e,t)}function sparseCategoricalAccuracy(e,t){return e.rank===t.rank&&(e=e.squeeze([e.rank-1])),(t=t.argMax(-1)).dtype!==e.dtype&&(t=t.asType(e.dtype)),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equal"])(e,t).asType("float32")}var mse$1=meanSquaredError,MSE$1=meanSquaredError,mae$1=meanAbsoluteError,MAE$1=meanAbsoluteError,mape$1=meanAbsolutePercentageError,MAPE$1=meanAbsolutePercentageError,categoricalCrossentropy$1=categoricalCrossentropy,cosine$1=cosineProximity,sparseCategoricalCrossentropy$1=sparseCategoricalCrossentropy;function get$1(e){var t={binaryAccuracy:binaryAccuracy,categoricalAccuracy:categoricalAccuracy,precision:precision,categoricalCrossentropy:categoricalCrossentropy$1,sparseCategoricalCrossentropy:sparseCategoricalCrossentropy$1,mse:mse$1,MSE:MSE$1,mae:mae$1,MAE:MAE$1,mape:mape$1,MAPE:MAPE$1,cosine:cosine$1};if("string"==typeof e&&e in t)return t[e];if("string"!=typeof e&&null!=e)return e;throw new ValueError("Unknown metric "+e)}function getOptimizer(e){var t={Adagrad:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].adagrad(.01)},Adadelta:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].adadelta(1,.95,epsilon())},Adam:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].adam(.001,.9,.999,epsilon())},Adamax:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].adamax(.002,.9,.999,epsilon(),0)},RMSProp:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].rmsprop(.001,.9,0,epsilon())},SGD:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].sgd(.01)}};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new ValueError("Unknown Optimizer "+e)}function printSummary(e,t,n,r){void 0===r&&(r=console.log);var i,a=isModelSequentialLike(e),o=["Layer (type)","Output shape","Param #"];if(a?(t=t||65,n=n||[.45,.85,1]):(t=t||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map(function(e){return Math.floor(t*e)})),!a)for(var s in o.push("Receives inputs"),i=[],e.nodesByDepth)i.push.apply(i,e.nodesByDepth[s]);r("_".repeat(t)),printRow(o,n,r),r("=".repeat(t));for(var l=e.layers,u=0;u<l.length;++u)a?printLayerSummary(l[u],n,r):printLayerSummaryWithConnections(l[u],n,i,r),r((u===l.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();var c=countTrainableParams(e),p=countParamsInWeights(e.nonTrainableWeights);r("Total params: "+(c+p)),r("Trainable params: "+c),r("Non-trainable params: "+p),r("_".repeat(t))}function countTrainableParams(e){return null!=e.collectedTrainableWeights?countParamsInWeights(e.collectedTrainableWeights):countParamsInWeights(e.trainableWeights)}function isModelSequentialLike(e){var t=!0,n=[],r=[];for(var i in e.nodesByDepth)n.push(e.nodesByDepth[i]);for(var a=0,o=n;a<o.length;a++){var s=o[a];if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){t=!1;break}r.push.apply(r,s)}if(t)for(var l=0,u=e.layers;l<u.length;l++){for(var c=!1,p=0,h=u[l].inboundNodes;p<h.length;p++){var d=h[p];if(-1!==r.indexOf(d)){if(c){t=!1;break}c=!0}}if(!t)break}return t}function printRow(e,t,n){void 0===n&&(n=console.log);for(var r="",i=0;i<e.length;++i)i>0&&(r=r.slice(0,r.length-1)+" "),r=(r+=e[i]).slice(0,t[i]),r+=" ".repeat(t[i]-r.length);n(r)}function printLayerSummary(e,t,n){var r;try{r=JSON.stringify(e.outputShape)}catch(e){r="multiple"}printRow([e.name+" ("+e.getClassName()+")",r,e.countParams().toString()],t,n)}function printLayerSummaryWithConnections(e,t,n,r){var i;try{i=JSON.stringify(e.outputShape)}catch(e){i="multiple"}for(var a=[],o=0,s=e.inboundNodes;o<s.length;o++){var l=s[o];if(!(null!=n&&n.length>0&&-1===n.indexOf(l)))for(var u=0;u<l.inboundLayers.length;++u){var c=l.inboundLayers[u].name,p=l.nodeIndices[u],h=l.tensorIndices[u];a.push(c+"["+p+"]["+h+"]")}}var d=e.name,f=e.getClassName(),g=0===a.length?"":a[0];printRow([d+" ("+f+")",i,e.countParams().toString(),g],t,r);for(u=1;u<a.length;++u)printRow(["","","",a[u]],t,r)}var version="1.1.2";function deserialize(e,t,n){return void 0===t&&(t={}),void 0===n&&(n=!1),deserializeKerasObject(e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].SerializationMap.getMap().classNameMap,t,"layer",n)}function isArrayItemInputOrOutputName(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function convertPythonicToTs(e,t){if(null===e)return null;if("string"==typeof e)return toCamelCase(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){for(var n=[],r=e.length,i=0;i<r;++i){var a=e[i];isArrayItemInputOrOutputName(t,i,a)?n.push(a):n.push(convertPythonicToTs(a,t))}return n}for(var o={},s=0,l=Object.keys(e);s<l.length;s++){var u=l[s],c=e[u];if("name"===u&&"string"==typeof c)o[u]=c;else{var p=toCamelCase(u);o[p]=convertPythonicToTs(c,p)}}return o}function convertTsToPythonic(e,t){if(null===e||void 0===e)return null;if("string"==typeof e)return toSnakeCase(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){for(var n=[],r=e.length,i=0;i<r;++i){var a=e[i];isArrayItemInputOrOutputName(t,i,a)?n.push(a):n.push(convertTsToPythonic(a,t))}return n}for(var o={},s=0,l=Object.keys(e);s<l.length;s++){var u=l[s],c=e[u],p=toSnakeCase(u);o[p]="name"!==u&&"className"!==u||"string"!=typeof c?convertTsToPythonic(c,u):c}return o}function assertFeedCompatibility(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cast"])(t,e.dtype)}catch(n){throw new ValueError("The dtype of the feed ("+t.dtype+") can not be cast to the dtype of the key '"+e.name+"' ("+e.dtype+").")}}var FeedDict=function(){function e(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof e)for(var n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(null==t)return;for(var r=0,i=t;r<i.length;r++){var a=i[r];this.add(a.key,a.value)}}}return e.prototype.add=function(e,t,n){if(null!=this.id2Value[e.id])throw new ValueError("Duplicate key: name="+e.name+", id="+e.id);return this.id2Value[e.id]=assertFeedCompatibility(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this},e.prototype.addFeed=function(e){this.add(e.key,e.value)},e.prototype.hasKey=function(e){return null!=this.id2Value[e.id]},e.prototype.names=function(){return Object.keys(this.name2Id)},e.prototype.getValue=function(e){if(e instanceof SymbolicTensor){if(null==this.id2Value[e.id])throw new ValueError("Nonexistent key: "+e.name);return this.id2Value[e.id]}var t=this.name2Id[e];if(null==t)throw new ValueError("Feed dict has no SymbolicTensor name: "+e);return this.id2Value[t]},e.prototype.getMask=function(e){if(e instanceof SymbolicTensor){if(null==this.id2Value[e.id])throw new ValueError("Nonexistent key: "+e.name);return this.id2Mask[e.id]}var t=this.name2Id[e];if(null==t)throw new ValueError("Feed dict has no SymbolicTensor name: "+e);return this.id2Mask[t]},e.prototype.disposeMasks=function(){null!=this.id2Mask&&Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(this.id2Mask)},e}(),cachedSorted={},cachedRecipientCounts={};function execute(e,t,n,r){for(var i=null!=n&&n.training,a=Array.isArray(e),o=a?e:[e],s=o.map(function(e){return e.name}),l=[],u=t.names(),c=0,p=s;c<p.length;c++){var h=p[c];-1!==u.indexOf(h)?l.push(t.getValue(h)):l.push(null)}null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);var d,f,g=s.join(",")+"|"+t.names().join(",");if(null==cachedSorted[g]){var m=getTopologicalSortAndRecipientCounts(o,t);d=m.sorted,f=m.recipientCounts,cachedSorted[g]=d,cachedRecipientCounts[g]=f}d=cachedSorted[g],f={},i||Object.assign(f,cachedRecipientCounts[g]);for(var y=new FeedDict(t),v=0;v<d.length;++v){if(null!=r){var b=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["memory"])().numTensors;b>r.maxNumTensors&&(r.maxNumTensors=b),b<r.minNumTensors&&(r.minNumTensors=b)}var w=d[v],z=w.sourceLayer;if(!(z instanceof InputLayer)){for(var S=[],I=[],A=[],_=!1,C=0,N=w.inputs;C<N.length;C++){var E=N[C],k=y.getValue(E),L=y.getMask(E);S.push(k),I.push(L),null!=L&&(_=!0),i||(f[E.name]--,0!==f[E.name]||t.hasKey(E)||-1!==s.indexOf(E.name)||k.isDisposed||!0===E.sourceLayer.stateful||A.push(k))}_&&((n=n||{}).mask=I[0]);var x=toList(z.apply(S,n)),T=null;z.supportsMasking&&(T=z.computeMask(S,I));for(var D=getNodeOutputs(w),O=Array.isArray(D)?D:[D],R=0;R<O.length;++R){y.hasKey(O[R])||y.add(O[R],x[R],Array.isArray(T)?T[0]:T);var M=s.indexOf(O[R].name);-1!==M&&(l[M]=x[R])}i||Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(A)}}return y.disposeMasks(),a?l:l[0]}function getTopologicalSortAndRecipientCounts(e,t){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=e&&e.length>0,function(){return"Expected at least one fetch, got none"});var n=[],r={};if(1===e.length){var i=getTopologicalSortAndRecipientCountsForOneFetch(e[0],t);n=i.sorted,r=i.recipientMap}else for(var a=new Set,o=0,s=e;o<s.length;o++){for(var l=getTopologicalSortAndRecipientCountsForOneFetch(s[o],t),u=l.sorted,c=l.recipientMap,p=0,h=u;p<h.length;p++){var d=h[p];a.has(d.name)||(n.push(d),a.add(d.name))}var f=function(e){null==r[e]&&(r[e]=new Set),c[e].forEach(function(t){return r[e].add(t)})};for(var g in c)f(g)}return{sorted:n,recipientCounts:recipientMap2Counts(r)}}function recipientMap2Counts(e){var t={};for(var n in e)t[n]=e[n].size;return t}function getTopologicalSortAndRecipientCountsForOneFetch(e,t){for(var n=new Set,r=[],i={},a=0,o=t.names();a<o.length;a++){var s=o[a];n.add(s)}var l=[],u=[];for(l.push(e);l.length>0;){var c=l[l.length-1];if(n.has(c.name))l.pop();else{var p=u[u.length-1]===l.length-1;if(0===c.inputs.length||p)l.pop(),r.push(c),n.add(c.name),p&&u.pop();else{u.push(l.length-1);for(var h=0,d=c.inputs;h<d.length;h++){var f=d[h];null==i[f.name]&&(i[f.name]=new Set),i[f.name].add(c.name),n.has(f.name)||l.push(f)}}}}return{sorted:r,recipientMap:i}}function getNodeOutputs(e){var t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{for(var n=null,r=0;r<e.sourceLayer.inboundNodes.length;++r)for(var i=0,a=e.sourceLayer.inboundNodes[r].outputTensors;i<a.length;i++){if(a[i].id===e.id){n=r;break}}t=e.sourceLayer.getOutputAt(n)}return t}var Container=function(e){function t(n){var r=e.call(this,{})||this;if(r.containerNodes=new Set,r.name=n.name,null==r.name){var i=r.getClassName().toLowerCase();r.name=getUid(i)}if(r.supportsMasking=!1,r.trainable_=!0,r.updatable=!0,Array.isArray(n.inputs)?r.inputs=n.inputs.slice():r.inputs=[n.inputs],Array.isArray(n.outputs)?r.outputs=n.outputs.slice():r.outputs=[n.outputs],unique(r.inputs).length!==r.inputs.length)throw new ValueError("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+r.inputs.map(function(e){return e.name}));unique(r.outputs).length!==r.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+r.outputs.map(function(e){return e.name})),r.inputLayers=[],r.inputLayersNodeIndices=[],r.inputLayersTensorIndices=[],r.outputLayers=[],r.outputLayersNodeIndices=[],r.outputLayersTensorIndices=[],r.layers=[];for(var a=0,o=r.outputs;a<o.length;a++){var s=(C=o[a]).sourceLayer,l=C.nodeIndex,u=C.tensorIndex;r.outputLayers.push(s),r.outputLayersNodeIndices.push(l),r.outputLayersTensorIndices.push(u)}for(var c=0,p=r.inputs;c<p.length;c++){s=(C=p[c]).sourceLayer,l=C.nodeIndex,u=C.tensorIndex;assert(0===l,"input layer has >1 nodes"),assert(0===u,"input layer has >1 tensors"),r.inputLayers.push(s),r.inputLayersNodeIndices.push(l),r.inputLayersTensorIndices.push(u)}r.inputNames=[],r.outputNames=[],r.feedInputShapes=[],r.feedInputNames=[],r.feedOutputNames=[];for(var h=0;h<r.inputLayers.length;h++){if(!((s=r.inputLayers[h])instanceof InputLayer))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. Received inputs: "+n.inputs+". Input "+h+" (0-based) originates from layer type "+s.getClassName()+".");r.inputNames.push(s.name),r.feedInputShapes.push(s.batchInputShape),r.feedInputNames.push(s.name)}for(var d=0,f=r.outputLayers;d<f.length;d++){s=f[d];r.outputNames.push(s.name)}r.internalInputShapes=r.inputs.map(function(e){return e.shape}),r.internalOutputShapes=r.outputs.map(function(e){return e.shape});for(var g={},m={},y={},v={},b={},w=[],z=function(e,n,i,a,o,s){null!=a&&null!=o&&null!=s||(a=e.sourceLayer,o=e.nodeIndex,s=e.tensorIndex);var l=a.inboundNodes[o];if(-1!==i.indexOf(l))throw new RuntimeError("The tensor "+e.name+' at layer "'+a.name+'" is part of a cycle.');if(-1===n.indexOf(l)){r.containerNodes.add(t.nodeKey(a,o)),a.id in b||(b[a.id]=Object.keys(b).length),-1===i.indexOf(l)&&i.push(l);for(var u=l.inboundLayers.length,c=0;c<u;c++){var p=l.inputTensors[c],h=l.inboundLayers[c],d=l.nodeIndices[c],f=l.tensorIndices[c];z(p,n,i,h,d,f)}for(n.push(l);i.indexOf(l)>=0;)i.splice(i.indexOf(l),1);w.push(l)}},S=[],I=[],A=0,_=r.outputs;A<_.length;A++){var C=_[A];z(C,S,I)}for(var N=0,E=w.slice().reverse();N<E.length;N++){m[(K=E[N]).id]=K,K.id in g||(g[K.id]=0);var k=g[K.id],L=null==y[K.outboundLayer.id]?0:y[K.outboundLayer.id];k=Math.max(k,L),y[K.outboundLayer.id]=k,v[K.outboundLayer.id]=K.outboundLayer,g[K.id]=k;for(h=0;h<K.inboundLayers.length;h++){var x=K.inboundLayers[h],T=(l=K.nodeIndices[h],x.inboundNodes[l]),D=null==g[T.id]?0:g[T.id];g[T.id]=Math.max(k+1,D),m[T.id]=T}}var O={};for(var R in g){(k=g[R])in O||(O[k]=[]),O[k].push(m[R])}var M={};for(var P in y){(k=y[P])in M||(M[k]=[]),M[k].push(v[P])}var F=Object.keys(M).map(function(e){return parseInt(e,10)}).sort(reverseNumberCompare);r.layers=[];for(var V=0,B=F;V<B.length;V++){var U=M[k=B[V]];U.sort(function(e,t){var n=b[e.id],r=b[t.id];return n<r?-1:n>r?1:0});for(var j=0,W=U;j<W.length;j++){s=W[j];r.layers.push(s)}}r.layersByDepth=M,F=Object.keys(O).map(function(e){return parseInt(e,10)}).sort(reverseNumberCompare);for(var $=r.inputs.slice(),q=[],G=0,H=F;G<H.length;G++)for(var J=0,Z=O[k=H[G]];J<Z.length;J++){var K;if(null!=(s=(K=Z[J]).outboundLayer)){for(var Y=0,X=K.inputTensors;Y<X.length;Y++){C=X[Y];if(-1===$.indexOf(C))throw new RuntimeError("Graph disconnected: cannot obtain value for tensor "+C+' at layer "'+s.name+'". The following previous layers were accessed without issue: '+q)}for(var Q=0,ee=K.outputTensors;Q<ee.length;Q++){C=ee[Q];$.push(C)}q.push(s.name)}}r.nodesByDepth=O;for(var te=r.layers.map(function(e){return e.name}),ne=function(e){var t=te.filter(function(t){return t===e}).length;if(1!==t)throw new RuntimeError('The name "'+e+'" is used '+t+" times in the model. All layer names should be unique. Layer names: "+JSON.stringify(te))},re=0,ie=te;re<ie.length;re++){ne(ie[re])}return r.outboundNodes=[],r.inboundNodes=[],new Node({outboundLayer:r,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:r.inputs,outputTensors:r.outputs,inputMasks:r.inputs.map(function(e){return null}),outputMasks:r.outputs.map(function(e){return null}),inputShapes:r.inputs.map(function(e){return e.shape}),outputShapes:r.outputs.map(function(e){return e.shape})}),r.built=!0,r._refCount=1,r}return __extends(t,e),t.prototype.assertNotDisposed=function(){if(0===this._refCount)throw new Error("Container '"+this.name+"' is already disposed.")},t.prototype.dispose=function(){this.assertNotDisposed();var e={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount)for(var t=0,n=this.layers;t<n.length;t++){var r=n[t];e.numDisposedVariables+=r.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e},Object.defineProperty(t.prototype,"trainable",{get:function(){return this.trainable_},set:function(e){this.layers.forEach(function(t){t._trainableWeights.forEach(function(t){return t.trainable=e})}),this.trainable_=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"trainableWeights",{get:function(){if(this._trainableWeights.length>0)throw new ValueError("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];for(var e=[],t=0,n=this.layers;t<n.length;t++){var r=n[t];e=e.concat(r.trainableWeights)}return e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){for(var e=[],t=0,n=this.layers;t<n.length;t++){var r=n[t];e.push.apply(e,r.nonTrainableWeights)}if(!this.trainable){for(var i=[],a=0,o=this.layers;a<o.length;a++){r=o[a];i.push.apply(i,r.trainableWeights)}return i.concat(e)}return e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"weights",{get:function(){return this.trainableWeights.concat(this.nonTrainableWeights)},enumerable:!0,configurable:!0}),t.prototype.loadWeights=function(e,t){void 0===t&&(t=!0);for(var n={},r=0,i=0,a=this.layers;i<a.length;i++)for(var o=0,s=a[i].weights;o<s.length;o++){var l=s[o];if(null!=n[l.originalName])throw new ValueError("Duplicate weight name: "+l.originalName);n[l.originalName]=l,r++}var u=[];for(var c in e){if(null!=n[c])u.push([n[c],e[c]]);else if(t)throw new ValueError("Provided weight data has no target variable: "+c);delete n[c]}if(t){var p=[];for(var h in n)p.push(h);if(p.length>0)throw new ValueError(p.length+" of "+r+" weights are not set: "+p)}batchSetValue(u)},t.prototype.updatedConfig=function(){var e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion="tfjs-layers "+version,t.backend="TensorFlow.js",t},t.prototype.toJSON=function(e,t){void 0===t&&(t=!0);var n=convertTsToPythonic(this.updatedConfig());return t?JSON.stringify(n):n},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){e=toList(e);for(var r=new FeedDict,i=0;i<n.inputs.length;++i)r.add(n.inputs[i],e[i]);return execute(n.outputs,r,t)})},t.prototype.computeMask=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r;return e=toList(e),r=null==t?pyListRepeat(null,e.length):toList(t),n.runInternalGraph(e,r)[1]})},t.prototype.computeOutputShape=function(e){var t=normalizeShapeList(e);if(t.length!==this.inputLayers.length)throw new ValueError("Invalid inputShape argument "+e+": model has "+this.inputLayers.length+" tensor inputs.");for(var n={},r=0;r<t.length;r++){var i=this.inputLayers[r],a=t[r];n[I=i.name+"_0_0"]=a}var o=Object.keys(this.nodesByDepth).map(function(e){return parseInt(e,10)}).sort(reverseNumberCompare);if(o.length>1)for(var s=0,l=o;s<l.length;s++)for(var u=l[s],c=0,p=this.nodesByDepth[u];c<p.length;c++){var h=p[c];i=h.outboundLayer;if(-1===this.inputLayers.map(function(e){return e.id}).indexOf(i.id)){for(var d=[],f=0;f<h.inboundLayers.length;f++){var g=h.inboundLayers[f],m=h.nodeIndices[f],y=h.tensorIndices[f],v=n[I=g.name+"_"+m+"_"+y];d.push(v)}var b=normalizeShapeList(i.computeOutputShape(singletonOrArray(d))),w=i.inboundNodes.indexOf(h);for(f=0;f<b.length;f++){n[I=i.name+"_"+w+"_"+f]=b[f]}}}var z=[],S=[];for(r=0;r<this.outputLayers.length;r++){i=this.outputLayers[r],w=this.outputLayersNodeIndices[r],y=this.outputLayersTensorIndices[r];var I=i.name+"_"+w+"_"+y;S.push(I)}for(r=0;r<S.length;r++){var A=S[r];assert(A in n),z.push(n[A])}return singletonOrArray(z)},t.prototype.runInternalGraph=function(e,t){null==t&&(t=pyListRepeat(null,e.length));for(var n={},r=0;r<this.inputs.length;++r){var i=this.inputs[r],a=e[r],o=t[r];n[i.id]=[a,o]}for(var s=0,l=Object.keys(this.nodesByDepth).map(function(e){return parseInt(e,10)}).sort(reverseNumberCompare);s<l.length;s++)for(var u=l[s],c=0,p=this.nodesByDepth[u];c<p.length;c++){for(var h=p[c],d=h.outboundLayer,f=h.inputTensors,g=h.outputTensors,m=new Array,y=0,v=f;y<v.length;y++){(i=v[y]).id in n&&m.push(n[i.id])}if(m.length===f.length){var b={},w=void 0,z=void 0,S=void 0,I=void 0;if(null!=h.callArgs&&(b=h.callArgs),1===m.length){var A=m[0],_=A[0],C=A[1];null==b.mask&&(b.mask=C),S=toList(d.call(_,b)),I=toList(d.computeMask(_,C)),w=[_],z=[C]}else w=m.map(function(e){return e[0]}),z=m.map(function(e){return e[1]}),null==b.mask&&(b.mask=z),S=toList(d.call(w,b)),I=toList(d.computeMask(w,z));if(d.activityRegularizer)throw new NotImplementedError("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(r=0;r<g.length;++r){i=g[r],a=S[r],o=I[r];n[i.id]=[a,o]}}}for(var N=[],E=[],k=[],L=0,x=this.outputs;L<x.length;L++){assert((i=x[L]).id in n,"Could not compute output "+i.name+" : "+i.id);var T=n[i.id],D=T[0];o=T[1];k.push(D.shape),N.push(D),E.push(o)}return[N,E,k]},t.prototype.buildNodeConversionMap=function(e){for(var n,r={},i=0,a=this.layers;i<a.length;i++){var o=a[i];n=o instanceof t?1:0;for(var s=0;s<o.inboundNodes.length;s++){var l=t.nodeKey(o,s);this.containerNodes.has(l)&&(r[l]=n,n+=1)}}return r},t.prototype.getLayer=function(e,t){if(null!=t){if(this.layers.length<=t)throw new ValueError("Was asked to retrieve layer at index "+t+", but model only has "+this.layers.length+" layer(s).");return this.layers[t]}if(null==e)throw new ValueError("Provide either a layer name or layer index");for(var n=0,r=this.layers;n<r.length;n++){var i=r[n];if(i.name===e)return i}throw new ValueError("No such layer: "+e)},t.prototype.calculateLosses=function(){var e=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var n=[],r=0,i=e.layers;r<i.length;r++)for(var a=i[r],o=0;o<a.inboundNodes.length;++o){var s=t.nodeKey(a,o);e.containerNodes.has(s)&&n.push.apply(n,a.calculateLosses())}return n})},t.prototype.getConfig=function(){for(var e={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[],i=0,a=this.layers;i<a.length;i++){for(var o=(w=a[i]).getClassName(),s=w.getConfig(),l=[],u=0;u<w.inboundNodes.length;u++){var c=w.inboundNodes[u],p=t.nodeKey(w,u),h={};if(this.containerNodes.has(p)){if(c.callArgs)try{JSON.stringify(c.callArgs),h=c.callArgs}catch(e){console.warn("Layer "+w.name+" was passed non-serializable keyword arguments: "+c.callArgs+". They will not be included in the serialized model (and thus will be missing at deserialization time)."),h={}}if(c.inboundLayers.length>0){for(var d=[],f=0;f<c.inboundLayers.length;f++){var g=c.inboundLayers[f],m=c.nodeIndices[f],y=c.tensorIndices[f];null==(S=n[t.nodeKey(g,m)])&&(S=0),d.push([g.name,S,y,h])}l.push(d)}}}var v={};v.name=w.name,v.className=o,v.config=s,v.inboundNodes=l,r.push(v)}e.layers=r;var b=[];for(f=0;f<this.inputLayers.length;f++){var w=this.inputLayers[f];m=this.inputLayersNodeIndices[f],p=t.nodeKey(w,m);if(this.containerNodes.has(p)){null!==(S=n[p])&&void 0!==S||(S=0);y=this.inputLayersTensorIndices[f];b.push([w.name,S,y])}}e.inputLayers=b;var z=[];for(f=0;f<this.outputLayers.length;f++){w=this.outputLayers[f],m=this.outputLayersNodeIndices[f],p=t.nodeKey(w,m);if(this.containerNodes.has(p)){var S;null!==(S=n[p])&&void 0!==S||(S=0);y=this.outputLayersTensorIndices[f];z.push([w.name,S,y])}}return e.outputLayers=z,e},t.fromConfig=function(e,t,n,r){void 0===n&&(n={}),void 0===r&&(r=!1);var i={},a={};function o(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function s(e,t){for(var n,r=[],a=0,s=t;a<s.length;a++){var l=s[a],u=l[0],c=l[1],p=l[2];if(n=null==l[3]?{}:l[3],!(u in i))return void o(e,t);var h=i[u];if(h.inboundNodes.length<=c)return void o(e,t);var d=h.inboundNodes[c];r.push(d.outputTensors[p])}r.length>0&&e.apply(singletonOrArray(r),n)}function l(e){var n=e.name,a=deserialize(e,null!=t.customObjects?t.customObjects:{});a.setFastWeightInitDuringBuild(r),i[n]=a,e.inboundNodes.forEach(function(e){if(!(e instanceof Array))throw new ValueError("Corrupted configuration, expected array for nodeData: "+e);o(a,e)})}for(var u=t.name,c=t.layers,p=0,h=c;p<h.length;p++){l(g=h[p])}for(;!isObjectEmpty(a);)for(var d=0,f=c;d<f.length;d++){var g=f[d];if((k=i[g.name]).name in a){var m=a[k.name];delete a[k.name];for(var y=0,v=m;y<v.length;y++){s(k,v[y])}}}for(var b=[],w=[],z=0,S=t.inputLayers;z<S.length;z++){var I=(g=S[z])[0],A=g[1],_=g[2];assert(I in i);var C=(k=i[I]).inboundNodes[A].outputTensors;b.push(C[_])}for(var N=0,E=t.outputLayers;N<E.length;N++){I=(g=E[N])[0],A=g[1],_=g[2];assert(I in i);var k;C=(k=i[I]).inboundNodes[A].outputTensors;w.push(C[_])}return new e({inputs:b,outputs:w,name:u})},Object.defineProperty(t.prototype,"stateful",{get:function(){if(this._stateful)throw new ValueError("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(var e=0,t=this.layers;e<t.length;e++){if(t[e].stateful)return!0}return!1},enumerable:!0,configurable:!0}),t.prototype.resetStates=function(){var e=this;Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){e.layers.forEach(function(e){e.stateful&&e.resetStates()})})},t}(Layer),DEFAULT_VALIDATION_BATCH_SIZE=32;function standardizeDataIteratorOutput(e,t){var n,r,i=t;n=i.xs,r=i.ys,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=n&&null!=r,function(){return"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+t});var a=flattenTensorOrArrayOrMap("input",e.inputNames,n),o=flattenTensorOrArrayOrMap("output",e.outputNames,r),s=a[0].shape[0];_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(a.length===e.inputs.length,function(){return"LayersModel has "+e.inputs.length+" inputs, but the dataset provides "+a.length+" inputs.  (Expected input keys: "+JSON.stringify(e.inputNames)+")"}),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(o.length===e.outputs.length,function(){return"LayersModel has "+e.outputs.length+" outputs, but the dataset provides "+o.length+" outputs.  (Expected output keys: "+JSON.stringify(e.outputNames)+")"});var l=function(t){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(a[t].shape[0]===s,function(){return"Batch size mismatch: input "+e.inputNames[t]+" has "+a[t].shape[0]+"; expected  "+s+" based on input "+e.inputNames[0]+"."})};for(var u in a)l(u);var c=function(t){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(o[t].shape[0]===s,function(){return"Batch size mismatch: output "+e.outputNames[t]+" has "+o[t].shape[0]+"; expected  "+s+" based on input "+e.inputNames[0]+"."})};for(var p in o)c(p);return a.concat(o)}function flattenTensorOrArrayOrMap(e,t,n){if(n instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"])return[n];if(Array.isArray(n))return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(n.length===t.length,function(){return"Received an array of "+n.length+" Tensors, but expected "+t.length+" to match the "+e+" keys "+t+"."}),n;for(var r=[],i=0,a=t;i<a.length;i++){var o=a[i];if(null==n[o])throw new ValueError("The feature data generated by the dataset lacks the required "+e+" key '"+o+"'.");r.push(n[o])}return r}function standardizeTensorValidationData(e){if(3===e.length)throw new NotImplementedError("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}function fitDataset(e,t,n){return __awaiter(this,void 0,void 0,function(){var r,i,a,o,s,l,u,c,p,h,d,f,g,m,y,v,b,w,z,S,I,A,_,C,N,E,k;return __generator(this,function(L){switch(L.label){case 0:if(r=null!=n.batchesPerEpoch,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=e.optimizer,function(){return"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."}),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=n,function(){return"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."}),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),function(){return"For fitDataset(), config.epochs is expected to be a positive integer, but got "+n.epochs}),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),function(){return"For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got "+n.batchesPerEpoch}),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null==n.validationSplit,function(){return"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."}),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0,L.label=1;case 1:return L.trys.push([1,,22,23]),i=null!=n.validationData,a=void 0,o=void 0,i&&(isDatasetObject(n.validationData)?_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),function(){return"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got "+n.validationBatches}):(s=standardizeTensorValidationData(n.validationData),a=s.xs,o=s.ys)),l=e.makeTrainFunction(),u=e.getDedupedMetricsNames(),c=void 0,c=i?u.slice().concat(u.map(function(e){return"val_"+e})):u.slice(),p=standardizeCallbacks(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,d=configureCallbacks(p,h,n.epochs,null,null,getStepsPerEpoch(t,n),null,i,c),f=d.callbackList,g=d.history,f.setModel(e),e.history=g,[4,f.onTrainBegin()];case 2:return L.sent(),e.stopTraining_=!1,m=null==n.initialEpoch?0:n.initialEpoch,[4,t.iterator()];case 3:y=L.sent(),L.label=4;case 4:return m<n.epochs?(v={},[4,f.onEpochBegin(m)]):[3,19];case 5:return L.sent(),b=0,w=0,r?[3,7]:[4,t.iterator()];case 6:y=L.sent(),L.label=7;case 7:return!r||b<n.batchesPerEpoch?[4,y.next()]:[3,17];case 8:return z=L.sent(),r&&z.done?(console.warn("You provided `batchesPerEpoch` as "+n.batchesPerEpoch+", but your dataset iterator ran out of data after "+b+" batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset."),[3,17]):null==z.value?[3,11]:(S=standardizeDataIteratorOutput(e,z.value),(I={}).batch=w,I.size=S[0].shape[0],[4,f.onBatchBegin(w,I)]);case 9:for(L.sent(),A=l(S),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(S),k=0;k<u.length;++k)_=u[k],C=A[k],I[_]=C,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(C);return[4,f.onBatchEnd(w,I)];case 10:L.sent(),disposeTensorsInLogs(I),w++,b++,L.label=11;case 11:return(r?b>=n.batchesPerEpoch:z.done)?i?(N=void 0,isDatasetObject(n.validationData)?(E=toList,[4,e.evaluateDataset(n.validationData,{batches:n.validationBatches})]):[3,13]):[3,15]:[3,16];case 12:return N=E.apply(void 0,[L.sent()]),[3,14];case 13:N=toList(e.evaluate(a,o,{batchSize:null==n.validationBatchSize?DEFAULT_VALIDATION_BATCH_SIZE:n.validationBatchSize,verbose:0})),L.label=14;case 14:for(k=0;k<e.metricsNames.length;++k)v["val_"+e.metricsNames[k]]=N[k];L.label=15;case 15:return[3,17];case 16:return e.stopTraining_?[3,17]:[3,7];case 17:return[4,f.onEpochEnd(m,v)];case 18:return L.sent(),m++,e.stopTraining_?[3,19]:[3,4];case 19:return[4,f.onTrainEnd()];case 20:return L.sent(),[4,e.history.syncData()];case 21:return L.sent(),[2,e.history];case 22:return e.isTraining=!1,[7];case 23:return[2]}})})}function getStepsPerEpoch(e,t){var n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function isDatasetObject(e){return"function"==typeof e.iterator}function isLazyIteratorObject(e){return"function"==typeof e.next}function evaluateDataset(e,t,n){return __awaiter(this,void 0,void 0,function(){var r,i,a,o,s,l,u,c,p,h;return __generator(this,function(d){switch(d.label){case 0:if(r=null!=(n=n||{}).batches,i=e.testFunction,a=[],n.verbose>0)throw new NotImplementedError("Verbose mode is not implemented yet.");return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(!r||n.batches>0&&Number.isInteger(n.batches),function(){return"Test loop expects `batches` to be a positive integer, but received "+JSON.stringify(n.batches)}),isLazyIteratorObject(t)?(s=t,[3,3]):[3,1];case 1:return[4,t.iterator()];case 2:s=d.sent(),d.label=3;case 3:o=s,l=0,u=0,c=function(){var t;return __generator(this,function(s){switch(s.label){case 0:return[4,o.next()];case 1:return t=s.sent(),a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(t.value){var n=standardizeDataIteratorOutput(e,t.value),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return i(n)});if(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(n),0===u)for(var o=0;o<r.length;++o)a.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(0));var s=n[0].shape[0],c=function(e){var t=r[e],n=a[e];a[e]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(a[e],Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(s,t))}),u>0&&Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(n)};for(o=0;o<r.length;++o)c(o);Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r),l+=s,++u}return a}),t.done?(r&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` batches (in this case, "+n.batches+" batches). You may need to use the repeat() function when building your dataset."),[2,"break"]):[2]}})},d.label=4;case 4:return!r||u<n.batches?[5,c()]:[3,6];case 5:return"break"===d.sent()?[3,6]:[3,4];case 6:for(p=0;p<a.length;++p)h=a[p],a[p]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(a[p],l),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(h);return[2,singletonOrArray(a)]}})})}function checkBatchSize(e){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(e>0&&Number.isInteger(e),function(){return"batchSize is required to be a positive integer, but got "+e})}function sliceArrays(e,t,n){return null==e?[null]:Array.isArray(e)?e.map(function(e){return sliceAlongFirstAxis(e,t,n-t)}):sliceAlongFirstAxis(e,t,n-t)}function sliceArraysByIndices(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return null==e?null:Array.isArray(e)?e.map(function(e){return sliceArraysByIndices(e,t)}):gather$1(e,"int32"===t.dtype?t:t.toInt())})}function makeBatches(e,t){for(var n=[],r=0,i=null;r<e;)(i=r+t)>=e&&(i=e),n.push([r,i]),r=i;return n}function fitLoop(e,t,n,r,i,a,o,s,l,u,c,p,h,d,f){return __awaiter(this,void 0,void 0,function(){var g,m,y,v,b,w,z,S;return __generator(this,function(I){switch(I.label){case 0:if(null==i&&(i=32),null==a&&(a=1),null==c&&(c=!0),null==h&&(h=0),g=!1,null!=l&&null!=u&&(g=!0),null!=f&&(g=!0,null==d))throw new ValueError("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");return null!=(m=e.checkNumSamples(n,i,d,"steps_per_epoch"))&&(y=range(0,m)),null==o&&(o=1),v=configureCallbacks(s,o,a,h,m,d,i,g,p),b=v.callbackList,w=v.history,b.setModel(e),e.history=w,[4,b.onTrainBegin()];case 1:I.sent(),e.stopTraining_=!1,z=function(a){var o,s,p,h,f;return __generator(this,function(v){switch(v.label){case 0:return[4,b.onEpochBegin(a)];case 1:if(v.sent(),o={},null==d)return[3,2];throw new NotImplementedError("stepsPerEpoch mode is not implemented yet.");case 2:if("batch"===c)throw new NotImplementedError("batch shuffling is not implemneted yet");c&&_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].shuffle(y),s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(y),p=makeBatches(m,i),h=function(a){var c;return __generator(this,function(h){switch(h.label){case 0:return c={},[4,b.onBatchBegin(a,c)];case 1:return h.sent(),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var h=p[a][0],d=p[a][1],f=sliceAlongFirstAxis(s,h,d-h);c.batch=a,c.size=d-h;for(var m=sliceArraysByIndices(n,f),y=t(m),v=0;v<r.length;++v){var b=r[v],w=y[v];c[b]=w,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(w)}if(a===p.length-1&&g){var z=e.testLoop(l,u,i);for(v=0;v<r.length;++v){b=r[v],w=z[v];Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(w),o["val_"+b]=w}}}),[4,b.onBatchEnd(a,c)];case 2:return h.sent(),disposeTensorsInLogs(c),e.stopTraining_?[2,"break"]:[2]}})},f=0,v.label=3;case 3:return f<p.length?[5,h(f)]:[3,6];case 4:if("break"===v.sent())return[3,6];v.label=5;case 5:return++f,[3,3];case 6:s.dispose(),v.label=7;case 7:return[4,b.onEpochEnd(a,o)];case 8:return v.sent(),e.stopTraining_?[2,"break"]:[2]}})},S=h,I.label=2;case 2:return S<a?[5,z(S)]:[3,5];case 3:if("break"===I.sent())return[3,5];I.label=4;case 4:return++S,[3,2];case 5:return[4,b.onTrainEnd()];case 6:return I.sent(),[4,e.history.syncData()];case 7:return I.sent(),[2,e.history]}})})}function fitTensors(e,t,n,r){return void 0===r&&(r={}),__awaiter(this,void 0,void 0,function(){var i,a,o,s,l,u,c,p,h,d,f,g,m,y,v,b,w,z,S;return __generator(this,function(I){switch(I.label){case 0:if(e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0,I.label=1;case 1:if(I.trys.push([1,,3,4]),checkBatchSize(c=null==r.batchSize?32:r.batchSize),p=e.standardizeUserData(t,n,!1,c),i=p[0],a=p[1],h=!1,d=void 0,null!=r.validationData&&r.validationData.length>0){if(h=!0,2!==r.validationData.length)throw 3===r.validationData.length?new NotImplementedError("validationData including sample weights is not supported yet."):new ValueError("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+r.validationData+" is invalid.");o=r.validationData[0],s=r.validationData[1],f=e.standardizeUserData(o,s,!0,c),l=f[0],u=f[1],d=l.concat(u)}else null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1?(h=!0,g=Math.floor(i[0].shape[0]*(1-r.validationSplit)),m=i[0].shape[0],l=sliceArrays(i,g,m),i=sliceArrays(i,0,g),u=sliceArrays(a,g,m),a=sliceArrays(a,0,g),d=l.concat(u)):null!=r.validationSteps&&(h=!0);return y=i.concat(a),e.checkTrainableWeightsConsistency(),v=e.makeTrainFunction(),b=e.getDedupedMetricsNames(),w=void 0,z=void 0,h?(e.makeTestFunction(),w=e.testFunction,z=b.slice().concat(b.map(function(e){return"val_"+e}))):(w=null,d=[],z=b.slice()),S=standardizeCallbacks(r.callbacks,r.yieldEvery),[4,fitLoop(e,v,y,b,c,r.epochs,r.verbose,S,w,d,r.shuffle,z,r.initialEpoch,null,null)];case 2:return[2,I.sent()];case 3:return e.isTraining=!1,disposeNewTensors(i,t),disposeNewTensors(a,n),disposeNewTensors(l,o),disposeNewTensors(u,s),[7];case 4:return[2]}})})}function ensureTensorsRank2OrHigher(e){var t=[];e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]&&(e=[e]);for(var n=0;n<e.length;++n){var r=e[n];if(1===r.rank)t.push(expandDims$1(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function disposeNewTensors(e,t){if(null!=e){var n=[];if(t instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"])n.push(t.id);else if(Array.isArray(t))t.forEach(function(e){return n.push(e.id)});else if(null!=t)for(var r in t){var i=t[r];n.push(i.id)}var a=[];if(e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"])-1===n.indexOf(e.id)&&a.push(e);else if(Array.isArray(e))e.forEach(function(e){-1===n.indexOf(e.id)&&a.push(e)});else if(null!=e)for(var o in e){var s=e[o];-1===n.indexOf(s.id)&&a.push(s)}a.forEach(function(e){e.isDisposed||e.dispose()})}}function isDataTensor(e){return e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]}function isDataArray(e){return Array.isArray(e)}function isDataDict(e){return!isDataTensor(e)&&!isDataArray(e)}function standardizeInputData(e,t,n,r,i){if(void 0===r&&(r=!0),void 0===i&&(i=""),null==t||0===t.length){if(null!=e){var a=!1;if(isDataArray(e)&&e.length>0)a=!0;else if(isDataDict(e)){for(var o in e)if(e.hasOwnProperty(o)){a=!0;break}}else a=!0;if(a)throw new ValueError("Error when checking model "+i+" expected no data, but got "+e)}return[]}if(null==e)return t.map(function(e){return null});var s;if(isDataDict(e)){e=e,s=[];for(var l=0,u=t;l<u.length;l++){var c=u[l];if(null==e[c])throw new ValueError('No data provided for "'+c+'". Need data for each key in: '+t);s.push(e[c])}}else if(isDataArray(e)){if((e=e).length!==t.length)throw new ValueError("Error when checking model "+i+": the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see "+t.length+" Tensor(s), but instead got the following list of Tensor(s): "+e);s=e}else{if(e=e,t.length>1)throw new ValueError("The model "+i+" expects "+t.length+" Tensor(s), but only received one Tensor. Found: Tensor with shape "+e.shape);s=[e]}if(s=ensureTensorsRank2OrHigher(s),null!=n)for(var p=0;p<t.length;++p)if(null!=n[p]){var h=s[p];if(h.shape.length!==n[p].length)throw new ValueError("Error when checking "+i+": expected "+t[p]+" to have "+n[p].length+" dimension(s). but got array with shape "+h.shape);for(var d=0;d<n[p].length;++d)if(0!==d||r){var f=h.shape[d],g=n[p][d];if(null!=g&&g>=0&&f!==g)throw new ValueError("Error when checking "+i+": expected "+t[p]+" to have shape ["+n[p]+"], but got array with shape ["+h.shape+"].")}}return s}function checkArrayLengths(e,t,n){var r=unique(e.map(function(e){return e.shape[0]}));r.sort();var i=unique(t.map(function(e){return e.shape[0]}));if(i.sort(),r.length>1)throw new ValueError("All input Tensors (x) should have the same number of samples. Got array shapes: "+JSON.stringify(e.map(function(e){return e.shape})));if(i.length>1)throw new ValueError("All target Tensors (y) should have the same number of samples. Got array shapes: "+JSON.stringify(t.map(function(e){return e.shape})));if(r.length>0&&i.length>0&&!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(r,i))throw new ValueError("Input Tensors should have the same number of samples as target Tensors. Found "+r[0]+" input sample(s) and "+i[0]+" target sample(s).")}function checkLossAndTargetCompatibility(e,t,n){for(var r=[meanSquaredError,binaryCrossentropy,categoricalCrossentropy],i=0;i<e.length;++i){var a=e[i],o=t[i],s=n[i];if(null!=o){if(o===categoricalCrossentropy&&1===a.shape[a.shape.length-1])throw new ValueError("You are passing a target array of shape "+a.shape+" while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==r.indexOf(o))for(var l=a.shape.slice(1),u=s.slice(1),c=0;c<l.length;++c){var p=l[c],h=u[c];if(null!=h&&p!==h)throw new ValueError("A target Tensor with shape "+a.shape+" was passed for an output of shape "+s+", while using a loss function that expects targets to have the same shape as the output.")}}}}function checkInputData(e,t,n,r,i){var a;if(void 0===r&&(r=!0),void 0===i&&(i=""),Array.isArray(e)){if(e.length!==t.length)throw new ValueError("Error when checking model "+i+": the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see "+t.length+" Tensor(s), but instead got "+e.length+" Tensors(s).");a=e}else{if(t.length>1)throw new ValueError("The model expects "+t.length+" "+i+" Tensors, but only received one Tensor. Found: array with shape "+JSON.stringify(e.shape)+".");a=[e]}if(null!=n)for(var o=0;o<t.length;++o)if(null!=n[o]){var s=a[o];if(s.shape.length!==n[o].length)throw new ValueError("Error when checking "+i+": expected "+t[o]+" to have "+n[o].length+" dimension(s), but got array with shape "+JSON.stringify(s.shape));for(var l=0;l<n[o].length;++l)if(0!==l||r){var u=s.shape[l],c=n[o][l];if(null!=c&&c!==u)throw new ValueError("Error when checking "+i+": expected "+t[o]+" to have shape "+JSON.stringify(n[o])+" but got array with shape "+JSON.stringify(s.shape)+".")}}}function collectMetrics(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map(function(e){return[]});if(Array.isArray(e))return t.map(function(t){return e});if(null!=e){for(var n=[],r=0,i=t;r<i.length;r++){var a=i[r],o=e.hasOwnProperty(a)?e[a]:[];Array.isArray(o)||(o=[o]),n.push(o)}return n}throw new TypeError("Type of metrics argument not understood. Expected an Array or Object, found: "+e)}var LAYERS_MODEL_FORMAT_NAME="layers-model",LayersModel=function(e){function t(t){var n=e.call(this,t)||this;return n.isTraining=!1,n}return __extends(t,e),t.prototype.summary=function(e,t,n){if(void 0===n&&(n=console.log),!this.built)throw new ValueError("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");printSummary(this,e,t,n)},t.prototype.compile=function(e){var t=this;if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=getOptimizer(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Optimizer"]))throw new ValueError("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}var n=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new ValueError("When passing an Array as loss, it should have one entry per model output. The model has "+this.outputs.length+" output(s), but you passed loss="+e.loss+".");var r=e.loss;n=r.map(function(e){return get(e)})}else{var i=get(e.loss);this.outputs.forEach(function(e){n.push(i)})}else{for(var a in e.loss=e.loss,e.loss)if(-1===this.outputNames.indexOf(a))throw new ValueError('Unknown entry in loss dictionary: "'+a+'". Only expected the following keys: '+this.outputNames);for(var o=0,s=this.outputNames;o<s.length;o++){var l=s[o];null==e.loss[l]&&console.warn('Output "'+l+'" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to '+l+" during training"),n.push(get(e.loss[l]))}}this.lossFunctions=n,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(var u=0;u<this.outputs.length;++u){var c=this.internalOutputShapes[u],p=this.outputNames[u];this.feedOutputNames.push(p),this.feedOutputShapes.push(c),this.feedLossFns.push(this.lossFunctions[u])}var h=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],nameScope("loss",function(){for(var e=0;e<t.outputs.length;++e)if(-1===h.indexOf(e)){var n=t.lossFunctions[e];t.outputs.length>1&&(t.metricsTensors.push([n,e]),t.metricsNames.push(t.outputNames[e]+"_loss"))}});var d=collectMetrics(e.metrics,this.outputNames);nameScope("metric",function(){for(var e=function(e){if(-1!==h.indexOf(e))return"continue";!function(n){for(var r,i,a,o=function(n){if(-1!==["accuracy","acc","crossentropy","ce"].indexOf(n)){var o=t.internalOutputShapes[e];1===o[o.length-1]||t.lossFunctions[e]===binaryCrossentropy?-1!==["accuracy","acc"].indexOf(n)?i=binaryAccuracy:-1!==["crossentropy","ce"].indexOf(n)&&(i=binaryCrossentropy$1):t.lossFunctions[e]===sparseCategoricalCrossentropy?-1!==["accuracy","acc"].indexOf(n)?i=sparseCategoricalAccuracy:-1!==["crossentropy","ce"].indexOf(n)&&(i=sparseCategoricalCrossentropy$1):-1!==["accuracy","acc"].indexOf(n)?i=categoricalAccuracy:-1!==["crossentropy","ce"].indexOf(n)&&(i=categoricalCrossentropy$1);var s=void 0;-1!==["accuracy","acc"].indexOf(n)?s="acc":-1!==["crossentropy","ce"].indexOf(n)&&(s="ce"),a=i,r=""+s}else{var l=get$1(n);a=l,r=""+n}var u;nameScope(r,function(){u=a}),function(e,n,r){t.outputNames.length>1&&(n=t.outputNames[e]+"_"+n),t.metricsNames.push(n),t.metricsTensors.push([r,e])}(e,r,u)},s=0,l=n;s<l.length;s++)o(l[s])}(d[e])},n=0;n<t.outputs.length;++n)e(n)}),this.collectedTrainableWeights=this.trainableWeights},t.prototype.checkTrainableWeightsConsistency=function(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")},t.prototype.evaluate=function(e,t,n){void 0===n&&(n={});var r=null==n.batchSize?32:n.batchSize;checkBatchSize(r);var i=this.standardizeUserData(e,t,!0,r);try{var a=i[0].concat(i[1]);this.makeTestFunction();var o=this.testFunction;return singletonOrArray(this.testLoop(o,a,r,n.verbose,n.steps))}finally{disposeNewTensors(i[0],e),disposeNewTensors(i[1],t)}},t.prototype.evaluateDataset=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){return this.makeTestFunction(),[2,evaluateDataset(this,e,t)]})})},t.prototype.checkNumSamples=function(e,t,n,r){var i;if(void 0===r&&(r="steps"),null!=n){if(i=null,null!=t)throw new ValueError("If "+r+" is set, batchSize must be null or undefined.Got batchSize = "+t)}else{if(null==e)throw new ValueError("Either the input data should have a defined shape, or "+r+" shoud be specified.");i=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return i},t.prototype.execute=function(e,t){if(Array.isArray(t)&&0===t.length)throw new ValueError("`outputs` is an empty Array, which is not allowed.");var n=Array.isArray(t),r=n?t:[t],i=this.retrieveSymbolicTensors(r),a=new FeedDict;if(e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new ValueError("The number of inputs provided ("+e.length+") does not match the number of inputs of this model ("+this.inputs.length+").");for(var o=0;o<this.inputs.length;++o)a.add(this.inputs[o],e[o])}else for(var s=0,l=this.inputs;s<l.length;s++){var u=l[s],c=e[u.name];if(null==c)throw new ValueError("No value is provided for the model's input "+u.name);a.add(u,c)}var p=execute(i,a);return n?p:p[0]},t.prototype.retrieveSymbolicTensors=function(e){for(var t=pyListRepeat(null,e.length),n=e.length,r=0,i=this.layers;r<i.length;r++){for(var a=i[r],o=Array.isArray(a.output)?a.output:[a.output],s=o.map(function(e){return e.name}),l=0;l<e.length;++l){var u=s.indexOf(e[l]);if(-1!==u&&(t[l]=o[u],n--),0===n)break}if(0===n)break}if(n>0){var c=[];throw t.forEach(function(t,n){null==t&&c.push(e[n])}),new ValueError("Cannot find SymbolicTensors for output name(s): "+JSON.stringify(c))}return t},t.prototype.predictLoop=function(e,t,n){var r=this;return void 0===t&&(t=32),void 0===n&&(n=!1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var i=r.checkNumSamples(e);if(n)throw new NotImplementedError("Verbose predictLoop() is not implemented yet.");for(var a=makeBatches(i,t),o=r.outputs.map(function(e){return[]}),s=function(t){Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=a[t][0],i=a[t][1],o=sliceArrays(e,n,i),s=[];if(Array.isArray(o))for(var l=0;l<o.length;++l)s.push({key:r.inputs[l],value:o[l]});else s.push({key:r.inputs[0],value:o});var u=new FeedDict(s);return execute(r.outputs,u)}).forEach(function(e,t){return o[t].push(e)})},l=0;l<a.length;++l)s(l);return singletonOrArray(o.map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"])(e,0)}))})},t.prototype.predict=function(e,t){void 0===t&&(t={});var n=ensureTensorsRank2OrHigher(e);checkInputData(n,this.inputNames,this.feedInputShapes,!1);try{var r=null==t.batchSize?32:t.batchSize;return checkBatchSize(r),this.predictLoop(n,r)}finally{disposeNewTensors(n,e)}},t.prototype.predictOnBatch=function(e){return checkInputData(e,this.inputNames,this.feedInputShapes,!0),this.predictLoop(e,e.shape[0])},t.prototype.standardizeUserData=function(e,t,n,r){if(void 0===n&&(n=!0),null==this.optimizer_)throw new RuntimeError("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");for(var i=[],a=0;a<this.feedOutputShapes.length;++a){var o=this.feedOutputShapes[a];this.feedLossFns[a]===sparseCategoricalCrossentropy?i.push(o.slice(0,o.length-1).concat([1])):i.push(o)}if(checkArrayLengths(e=standardizeInputData(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=standardizeInputData(t,this.feedOutputNames,i,!1,"target"),null),checkLossAndTargetCompatibility(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!=0)throw new ValueError("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+r+". Found: "+e[0].shape[0]+" sample(s).");return[e,t,null]},t.prototype.testLoop=function(e,t,n,r,i){var a=this;return void 0===r&&(r=0),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var o=a.checkNumSamples(t,n,i,"steps"),s=[];if(r>0)throw new NotImplementedError("Verbose mode is not implemented yet.");if(null!=i)throw new NotImplementedError("steps mode in testLoop() is not implemented yet");for(var l=makeBatches(o,n),u=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(range(0,o)),c=0;c<l.length;++c){var p=l[c][0],h=l[c][1],d=sliceAlongFirstAxis(u,p,h-p),f=sliceArraysByIndices(t,d),g=e(f);if(0===c)for(var m=0;m<g.length;++m)s.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(0));for(m=0;m<g.length;++m){var y=g[m];s[m]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(s[m],Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(h-p,y))}}for(m=0;m<s.length;++m)s[m]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(s[m],o);return s})},t.prototype.getDedupedMetricsNames=function(){for(var e=this.metricsNames,t=[],n=0;n<e.length;++n){var r=e[n],i=r;if(count(e,r)>1)i+="_"+count(e.slice(0,n),r);t.push(i)}return t},t.prototype.makeTrainFunction=function(){var e=this;return function(t){var n=t.slice(0,e.inputs.length),r=t.slice(e.inputs.length,e.inputs.length+e.outputs.length),i=[],a=e.collectedTrainableWeights.map(function(e){return e.read()});return[e.optimizer_.minimize(function(){for(var t=[],a=0;a<e.inputs.length;++a)t.push({key:e.inputs[a],value:n[a]});var o,s=new FeedDict(t),l=execute(e.outputs,s,{training:!0});for(a=0;a<e.lossFunctions.length;++a){var u=(0,e.lossFunctions[a])(r[a],l[a]);Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(u),o=0===a?u:Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(o,u)}for(a=0;a<e.metricsTensors.length;++a){var c=e.metricsTensors[a][0],p=e.metricsTensors[a][1],h=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(c(r[p],l[p]));Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(h),i.push(h)}return o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(o),e.calculateLosses().forEach(function(e){o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(o,e)}),o},!0,a)].concat(i)}},t.prototype.makeTestFunction=function(){var e=this;this.testFunction=function(t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var n,r=[],i=t.slice(0,e.inputs.length),a=t.slice(e.inputs.length,e.inputs.length+e.outputs.length),o=[],s=0;s<e.inputs.length;++s)o.push({key:e.inputs[s],value:i[s]});var l=new FeedDict(o),u=execute(e.outputs,l);for(s=0;s<e.lossFunctions.length;++s){var c=e.lossFunctions[s],p=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(c(a[s],u[s]));n=0===s?p:Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(n,p),r.push(n)}for(s=0;s<e.metricsTensors.length;++s){var h=e.metricsTensors[s][0],d=e.metricsTensors[s][1],f=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(h(a[d],u[d]));r.push(f)}return r})}},t.prototype.fit=function(e,t,n){return void 0===n&&(n={}),__awaiter(this,void 0,void 0,function(){return __generator(this,function(r){return[2,fitTensors(this,e,t,n)]})})},t.prototype.fitDataset=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){return[2,fitDataset(this,e,t)]})})},t.prototype.trainOnBatch=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r,i,a,o,s,l,u,c;return __generator(this,function(p){switch(p.label){case 0:n=this.standardizeUserData(e,t),r=n[0],i=n[1],a=this.makeTrainFunction(),o=a(r.concat(i)),s=[],l=0,u=o,p.label=1;case 1:return l<u.length?[4,u[l].data()]:[3,4];case 2:c=p.sent(),s.push(c[0]),p.label=3;case 3:return l++,[3,1];case 4:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(o),[2,singletonOrArray(s)]}})})},t.prototype.getNamedWeights=function(e){for(var t={},n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,i=this.getWeights(n),a=0;a<r.length;++a)n&&!r[a].trainable||(t[r[a].originalName]=i[a]);return t},Object.defineProperty(t.prototype,"stopTraining",{get:function(){return this.stopTraining_},set:function(e){this.stopTraining_=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"optimizer",{get:function(){return this.optimizer_},set:function(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)},enumerable:!0,configurable:!0}),t.prototype.dispose=function(){var t=e.prototype.dispose.call(this);if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["memory"])().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=n-Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["memory"])().numTensors}return t},t.prototype.save=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r,i,a,o;return __generator(this,function(s){switch(s.label){case 0:if("string"==typeof e){if(0===(n=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].getSaveHandlers(e)).length)throw new ValueError("Cannot find any save handlers for URL '"+e+"'");if(n.length>1)throw new ValueError("Found more than one ("+n.length+") save handlers for URL '"+e+"'");e=n[0]}if(null==e.save)throw new ValueError("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return[4,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].encodeWeights(this.getNamedWeights(t))];case 1:return r=s.sent(),i=!1,a=null,o=this.toJSON(a,i),[2,e.save({modelTopology:o,weightData:r.data,weightSpecs:r.specs,format:LAYERS_MODEL_FORMAT_NAME,generatedBy:"TensorFlow.js tfjs-layers v"+version,convertedBy:null})]}})})},t.className="Model",t}(Container);function modelFromJSON(e,t){return __awaiter(this,void 0,void 0,function(){var n,r,i,a,o,s,l,u;return __generator(this,function(c){switch(c.label){case 0:return"modelTopology"in e||(e={modelTopology:e}),null!=(n=(e=e).modelTopology).model_config&&(n=n.model_config),r=convertPythonicToTs(n),i=deserialize(r,t),null==e.weightsManifest?[3,2]:[4,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].loadWeights(e.weightsManifest,e.pathPrefix,i.weights.map(function(e){return e.originalName}))];case 1:for(a=c.sent(),o={},s=0,l=i.weights;s<l.length;s++)u=l[s],o[u.originalName]=a[u.originalName];i.loadWeights(o),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(a),c.label=2;case 2:return[2,i]}})})}function loadLayersModelInternal(e,t){return __awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(r){if(null==t&&(t={}),"string"==typeof e){if(0===(n=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].getLoadHandlers(e)).length)n.push(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].browserHTTPRequest(e,t));else if(n.length>1)throw new ValueError("Found more than one ("+n.length+") load handlers for URL '"+e+"'");e=n[0]}return[2,loadLayersModelFromIOHandler(e,void 0,t)]})})}function loadLayersModelFromIOHandler(e,t,n){return __awaiter(this,void 0,void 0,function(){var r,i,a,o,s,l;return __generator(this,function(u){switch(u.label){case 0:if(null==n&&(n={}),null==e.load)throw new ValueError("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");return[4,e.load()];case 1:if(r=u.sent(),null!=(i=r.modelTopology).model_config&&(i=i.model_config),a=null==n.strict||n.strict,o=null!=r.weightData&&null!=r.weightSpecs&&a,s=deserialize(convertPythonicToTs(i),t,o),null!=r.weightData){if(null==r.weightSpecs)throw new ValueError("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");l=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].decodeWeights(r.weightData,r.weightSpecs),s.loadWeights(l,a),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(l)}return[2,s]}})})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LayersModel);var Sequential=function(e){function t(t){var n=e.call(this,{inputs:[],outputs:[]})||this;if(t=t||{},n.trainable=!0,n._updatable=!0,n.built=!1,n.name=null!=t.name?t.name:getUid("sequential_"),null!=t.layers)for(var r=0,i=t.layers;r<i.length;r++){var a=i[r];n.add(a)}return n}return __extends(t,e),t.prototype.checkShape=function(e){if(e.inboundNodes[0].outputTensors[0].shape.some(function(e){return e<0}))throw new ValueError("Negative dimension size caused by adding layer "+e.name+" with input shape ["+e.inboundNodes[0].inputTensors[0].shape+"]")},t.prototype.add=function(e){var n,r=e instanceof t||e instanceof LayersModel;if(r){if(1!==(n=e).outputs.length)throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new ValueError("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new ValueError("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");var i=Input({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(i)}if(r)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new ValueError("A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer "+e.name+" which has "+e.inboundNodes.length+" pre-existing inbound connections.");if(1!==e.inboundNodes[0].outputTensors.length)throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=getSourceInputs(this.outputs[0])}this.inboundNodes=[],new Node({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:pyListRepeat(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(function(e){return e.shape}),outputShapes:this.outputs[0].shape})}else{var a=e.apply(this.outputs[0]);if(Array.isArray(a))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[a],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1},t.prototype.pop=function(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{var e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}},t.prototype.call=function(e,t){return null==this.model&&this.build(),this.model.call(e,t)},t.prototype.build=function(e){if(getExactlyOneShape(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new LayersModel({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.model.updatable=this.updatable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0},t.prototype.countParams=function(){return this.built||this.build(),e.prototype.countParams.call(this)},t.prototype.summary=function(t,n,r){void 0===r&&(r=console.log),this.built||this.build(),e.prototype.summary.call(this,t,n,r)},t.prototype.setWeights=function(e){null==this.model&&this.build(),this.model.setWeights(e)},Object.defineProperty(t.prototype,"updatable",{get:function(){return this._updatable},set:function(e){this.built&&(this.model.updatable=e),this._updatable=e},enumerable:!0,configurable:!0}),t.prototype.evaluate=function(e,t,n){if(void 0===n&&(n={}),!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)},t.prototype.evaluateDataset=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return[2,this.model.evaluateDataset(e,t)]})})},t.prototype.predict=function(e,t){return void 0===t&&(t={}),null==this.model&&this.build(),this.model.predict(e,t)},t.prototype.predictOnBatch=function(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)},t.prototype.compile=function(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames},Object.defineProperty(t.prototype,"optimizer",{get:function(){return this.model.optimizer},set:function(e){this.model.optimizer=e},enumerable:!0,configurable:!0}),t.prototype.fit=function(e,t,n){return void 0===n&&(n={}),__awaiter(this,void 0,void 0,function(){return __generator(this,function(r){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return[2,this.model.fit(e,t,n)]})})},t.prototype.fitDataset=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return[2,this.model.fitDataset(e,t)]})})},t.prototype.trainOnBatch=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){return[2,this.model.trainOnBatch(e,t)]})})},t.fromConfig=function(e,n,r,i){var a;void 0===r&&(r={}),void 0===i&&(i=!1);var o={};if(n instanceof Array){if(null==n[0].className||"Merge"===n[0].className)throw new ValueError("Legacy serialization format not supported yet.");a=n}else _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=n.layers,function(){return"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."}),a=n.layers,delete n.layers,o=n;var s=new e(o);if(!(s instanceof t))throw new NotImplementedError("Sequential.fromConfig called on non-Sequential input: "+s);for(var l=0,u=a;l<u.length;l++){var c=deserialize(u[l],void 0,i);i&&c.setFastWeightInitDuringBuild(!0),s.add(c)}return s},Object.defineProperty(t.prototype,"stopTraining",{get:function(){if(null==this.model)throw new ValueError("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining},set:function(e){if(null==this.model)throw new ValueError("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e},enumerable:!0,configurable:!0}),t.prototype.getConfig=function(){for(var e=[],t=0,n=this.layers;t<n.length;t++){var r=n[t],i={};i.className=r.getClassName(),i.config=r.getConfig(),e.push(i)}return e},t.className="Sequential",t}(LayersModel);function model(e){return new LayersModel(e)}function sequential(e){return new Sequential(e)}function loadLayersModel(e,t){return null==t&&(t={}),loadLayersModelInternal(e,t)}function input(e){return Input(e)}function registerCallbackConstructor(e,t){CallbackConstructorRegistry.registerCallbackConstructor(e,t)}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Sequential);var Activation=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.getConfig=function(){return{}},t}(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].Serializable),Elu=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e,t){return void 0===t&&(t=1),elu$1(e,t)},t.className="elu",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Elu);var Selu=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["selu"])(e)},t.className="selu",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Selu);var Relu=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"])(e)},t.className="relu",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Relu);var Relu6=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["minimum"])(6,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"])(e))})},t.className="relu6",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Relu6);var Linear=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return e},t.className="linear",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Linear);var Sigmoid=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sigmoid"])(e)},t.className="sigmoid",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Sigmoid);var HardSigmoid=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return hardSigmoid(e)},t.className="hardSigmoid",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(HardSigmoid);var Softplus=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softplus"])(e)},t.className="softplus",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Softplus);var Softsign=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return softsign(e)},t.className="softsign",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Softsign);var Tanh=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tanh"])(e)},t.className="tanh",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Tanh);var Softmax=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e,t){return void 0===t&&(t=-1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"])(e,t)},t.className="softmax",t}(Activation);function serializeActivation(e){return e.getClassName()}function deserializeActivation(e,t){return void 0===t&&(t={}),deserializeKerasObject(e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].SerializationMap.getMap().classNameMap,t,"activation")}function getActivation(e){var t;return null==e?deserializeActivation(t={className:"linear",config:{}}):"string"==typeof e?((t={}).className=e,t.config={},deserializeActivation(t)):e instanceof Activation?e:deserializeActivation(e)}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Softmax);var Regularizer=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t}(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].Serializable),L1L2=function(e){function t(t){var n=e.call(this)||this;return n.l1=null==t||null==t.l1?.01:t.l1,n.l2=null==t||null==t.l2?.01:t.l2,n.hasL1=0!==n.l1,n.hasL2=0!==n.l2,n}return __extends(t,e),t.prototype.apply=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])([1]);return t.hasL1&&(n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(n,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(t.l1,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(e))))),t.hasL2&&(n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(n,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(t.l2,square(e))))),n.asScalar()})},t.prototype.getConfig=function(){return{l1:this.l1,l2:this.l2}},t.fromConfig=function(e,t){return new e({l1:t.l1,l2:t.l2})},t.className="L1L2",t}(Regularizer);function l1(e){return new L1L2({l1:null!=e?e.l1:null,l2:0})}function l2(e){return new L1L2({l2:null!=e?e.l2:null,l1:0})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(L1L2);var REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP={l1l2:"L1L2"};function serializeRegularizer(e){return serializeKerasObject(e)}function deserializeRegularizer(e,t){return void 0===t&&(t={}),deserializeKerasObject(e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].SerializationMap.getMap().classNameMap,t,"regularizer")}function getRegularizer(e){return null==e?null:"string"==typeof e?deserializeRegularizer({className:e in REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP?REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[e]:e,config:{}}):e instanceof Regularizer?e:deserializeRegularizer(e)}var ReLU=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;return n.supportsMasking=!0,null!=t&&(n.maxValue=t.maxValue),n}return __extends(t,e),t.prototype.call=function(e,t){e=getExactlyOneTensor(e);var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"])(e);return null!=this.maxValue&&(n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(n,0,this.maxValue)),n},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t={maxValue:this.maxValue},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="ReLU",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(ReLU);var LeakyReLU=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;return n.DEFAULT_ALPHA=.3,null==t&&(t={}),n.alpha=null==t.alpha?n.DEFAULT_ALPHA:t.alpha,n}return __extends(t,e),t.prototype.call=function(e,t){var n=getExactlyOneTensor(e);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["leakyRelu"])(n,this.alpha)},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t={alpha:this.alpha},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="LeakyReLU",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LeakyReLU);var PReLU=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;if(n.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),n.supportsMasking=!0,n.alphaInitializer=getInitializer(t.alphaInitializer||n.DEFAULT_ALPHA_INITIALIZER),n.alphaRegularizer=getRegularizer(t.alphaRegularizer),n.alphaConstraint=getConstraint(t.alphaConstraint),null==t.sharedAxes)n.sharedAxes=null;else if(Array.isArray(t.sharedAxes))n.sharedAxes=t.sharedAxes;else{if("number"!=typeof t.sharedAxes)throw new ValueError("Expected sharedAxes to be a number or an array of numbers, but got "+t.sharedAxes);n.sharedAxes=[t.sharedAxes]}return n}return __extends(t,e),t.prototype.build=function(e){var t=(e=getExactlyOneShape(e)).slice(1);if(null!=this.sharedAxes)for(var n=0,r=this.sharedAxes;n<r.length;n++){t[(a=r[n])-1]=1}this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);var i={};if(null!=this.sharedAxes)for(var a=1;a<e.length;++a)i[a]=e[a];this.inputSpec=[new InputSpec({ndim:e.length,axes:i})],this.built=!0},t.prototype.call=function(e,t){return e=getExactlyOneTensor(e),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["prelu"])(e,this.alpha.read())},t.prototype.getConfig=function(){var t={alphaInitializer:serializeInitializer(this.alphaInitializer),alphaRegularizer:serializeRegularizer(this.alphaRegularizer),alphaConstraint:serializeConstraint(this.alphaConstraint),sharedAxes:this.sharedAxes},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="PReLU",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(PReLU);var ELU=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;if(n.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==n.DEFAULT_ALPHA)throw new NotImplementedError("Non-default alpha value ("+t.alpha+") is not supported by the ELU layer yet.");return n.alpha=null==t.alpha?n.DEFAULT_ALPHA:t.alpha,n}return __extends(t,e),t.prototype.call=function(e,t){var n=getExactlyOneTensor(e);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["elu"])(n)},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t={alpha:this.alpha},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="ELU",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(ELU);var ThresholdedReLU=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;return n.DEFAULT_THETA=1,null==t&&(t={}),n.theta=null==t.theta?n.DEFAULT_THETA:t.theta,n}return __extends(t,e),t.prototype.call=function(e,t){var n=getExactlyOneTensor(e);return n.mul(cast$1(n.greater(this.theta),"float32"))},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t={theta:this.theta},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="ThresholdedReLU",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(ThresholdedReLU);var Softmax$1=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;return n.DEFAULT_AXIS=1,null==t&&(t={}),n.softmax=(new Softmax).apply,n.axis=null==t.axis?n.DEFAULT_AXIS:t.axis,n}return __extends(t,e),t.prototype.call=function(e,t){var n=getExactlyOneTensor(e);return this.softmax(n,this.axis)},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t={axis:this.axis},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Softmax",t}(Layer);function normalizeArray(e,t,n){if("number"==typeof e)return pyListRepeat(e,t);if(e.length!==t)throw new ValueError("The "+n+" argument must be an integer or tuple of "+t+" integers. Received: "+e.length+" elements.");for(var r=0;r<t;++r){var i=e[r];if(!isInteger(i))throw new ValueError("The "+n+" argument must be an integer or tuple of "+t+" integers. Received: "+JSON.stringify(e)+" including a non-integer number "+i)}return e}function convOutputLength(e,t,n,r,i){return void 0===i&&(i=1),null==e?e:(a="same"===n?e:e-(t+(t-1)*(i-1))+1,Math.floor((a+r-1)/r));var a}function deconvLength(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+max$1([n-t,0]);else{if("same"!==r)throw new ValueError("Unsupport padding mode: "+r+".");e*=t}return e}function preprocessConv2DInput(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return checkDataFormat(t),"channelsFirst"===t?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(e,[0,2,3,1]):e})}function preprocessConv3DInput(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return checkDataFormat(t),"channelsFirst"===t?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(e,[0,2,3,4,1]):e})}function conv1dWithBias(e,t,n,r,i,a,o){return void 0===r&&(r=1),void 0===i&&(i="valid"),void 0===o&&(o=1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null==a&&(a=imageDataFormat()),checkDataFormat(a),3!==e.shape.length)throw new ValueError("The input of a conv1dWithBias operation should be 3, but is "+e.shape.length+" instead.");if(3!==t.shape.length)throw new ValueError("The kernel for a conv1dWithBias operation should be 3, but is "+t.shape.length+" instead");if(null!=n&&1!==n.shape.length)throw new ValueError("The bias for a conv1dWithBias operation should be 1, but is "+t.shape.length+" instead");if("channelsFirst"===a&&(e=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(e,[0,2,1])),"causal"===i)throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");var s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv1d"])(e,t,r,"same"===i?"same":"valid","NWC",o);return null!=n&&(s=biasAdd(s,n)),s})}function conv2dWithBias(e,t,n,r,i,a,o){return void 0===r&&(r=[1,1]),void 0===i&&(i="valid"),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null==a&&(a=imageDataFormat()),checkDataFormat(a),3!==e.rank&&4!==e.rank)throw new ValueError("conv2dWithBias expects input to be of rank 3 or 4, but received "+e.rank+".");if(3!==t.rank&&4!==t.rank)throw new ValueError("conv2dWithBias expects kernel to be of rank 3 or 4, but received "+e.rank+".");var s=preprocessConv2DInput(e,a);if("causal"===i)throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"])(s,t,r,"same"===i?"same":"valid","NHWC",o),null!=n&&(s=biasAdd(s,n)),"channelsFirst"===a&&(s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(s,[0,3,1,2])),s})}function conv3dWithBias(e,t,n,r,i,a,o){return void 0===r&&(r=[1,1,1]),void 0===i&&(i="valid"),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null==a&&(a=imageDataFormat()),checkDataFormat(a),4!==e.rank&&5!==e.rank)throw new ValueError("conv3dWithBias expects input to be of rank 4 or 5, but received "+e.rank+".");if(4!==t.rank&&5!==t.rank)throw new ValueError("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+e.rank+".");var s=preprocessConv3DInput(e,a);if("causal"===i)throw new NotImplementedError("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv3d"])(s,t,r,"same"===i?"same":"valid","NDHWC",o),null!=n&&(s=biasAdd(s,n)),"channelsFirst"===a&&(s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(s,[0,4,1,2,3])),s})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Softmax$1);var BaseConv=function(e){function t(n,r){var i=e.call(this,r)||this;if(i.bias=null,i.DEFAULT_KERNEL_INITIALIZER="glorotNormal",i.DEFAULT_BIAS_INITIALIZER="zeros",t.verifyArgs(r),i.rank=n,assertPositiveInteger(i.rank,"rank"),1!==i.rank&&2!==i.rank&&3!==i.rank)throw new NotImplementedError("Convolution layer for rank other than 1, 2, or 3 ("+i.rank+") is not implemented yet.");if(i.kernelSize=normalizeArray(r.kernelSize,n,"kernelSize"),i.strides=normalizeArray(null==r.strides?1:r.strides,n,"strides"),i.padding=null==r.padding?"valid":r.padding,checkPaddingMode(i.padding),i.dataFormat=null==r.dataFormat?"channelsLast":r.dataFormat,checkDataFormat(i.dataFormat),i.activation=getActivation(r.activation),i.useBias=null==r.useBias||r.useBias,i.biasInitializer=getInitializer(r.biasInitializer||i.DEFAULT_BIAS_INITIALIZER),i.biasConstraint=getConstraint(r.biasConstraint),i.biasRegularizer=getRegularizer(r.biasRegularizer),i.activityRegularizer=getRegularizer(r.activityRegularizer),i.dilationRate=normalizeArray(null==r.dilationRate?1:r.dilationRate,n,"dilationRate"),1===i.rank&&Array.isArray(i.dilationRate)&&1!==i.dilationRate.length)throw new ValueError("dilationRate must be a number or an array of a single number for 1D convolution, but received "+JSON.stringify(i.dilationRate));if(2===i.rank){if("number"==typeof i.dilationRate)i.dilationRate=[i.dilationRate,i.dilationRate];else if(2!==i.dilationRate.length)throw new ValueError("dilationRate must be a number or array of two numbers for 2D convolution, but received "+JSON.stringify(i.dilationRate))}else if(3===i.rank)if("number"==typeof i.dilationRate)i.dilationRate=[i.dilationRate,i.dilationRate,i.dilationRate];else if(3!==i.dilationRate.length)throw new ValueError("dilationRate must be a number or array of three numbers for 3D convolution, but received "+JSON.stringify(i.dilationRate));return i}return __extends(t,e),t.verifyArgs=function(e){if(assert("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!checkArrayTypeAndLength(e.kernelSize,"number",1,3))throw new ValueError("BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received "+JSON.stringify(e.kernelSize)+".")},t.prototype.getConfig=function(){var t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:serializeActivation(this.activation),useBias:this.useBias,biasInitializer:serializeInitializer(this.biasInitializer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),biasConstraint:serializeConstraint(this.biasConstraint)},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t}(Layer),Conv=function(e){function t(n,r){var i=e.call(this,n,r)||this;return i.kernel=null,t.verifyArgs(r),i.filters=r.filters,assertPositiveInteger(i.filters,"filters"),i.kernelInitializer=getInitializer(r.kernelInitializer||i.DEFAULT_KERNEL_INITIALIZER),i.kernelConstraint=getConstraint(r.kernelConstraint),i.kernelRegularizer=getRegularizer(r.kernelRegularizer),i}return __extends(t,e),t.prototype.build=function(e){var t;e=getExactlyOneShape(e);var n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new ValueError("The channel dimension of the input should be defined. Found "+e[n]);var r=e[n],i=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:(t={},t[n]=r,t)}],this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t;e=getExactlyOneTensor(e);var r=null==n.bias?null:n.bias.read();if(1===n.rank)t=conv1dWithBias(e,n.kernel.read(),r,n.strides[0],n.padding,n.dataFormat,n.dilationRate[0]);else if(2===n.rank)t=conv2dWithBias(e,n.kernel.read(),r,n.strides,n.padding,n.dataFormat,n.dilationRate);else{if(3!==n.rank)throw new NotImplementedError("convolutions greater than 3D are not implemented yet.");t=conv3dWithBias(e,n.kernel.read(),r,n.strides,n.padding,n.dataFormat,n.dilationRate)}return null!=n.activation&&(t=n.activation.apply(t)),t})},t.prototype.computeOutputShape=function(e){e=getExactlyOneShape(e);for(var t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2),r=0;r<n.length;++r){var i=convOutputLength(n[r],this.kernelSize[r],this.padding,this.strides[r],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[r]);t.push(i)}var a=[e[0]];return"channelsLast"===this.dataFormat?(a=a.concat(t)).push(this.filters):(a.push(this.filters),a=a.concat(t)),a},t.prototype.getConfig=function(){var t={filters:this.filters,kernelInitializer:serializeInitializer(this.kernelInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint)},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.verifyArgs=function(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new ValueError("Convolution layer expected config.filters to be a 'number' > 0 but got "+JSON.stringify(e.filters))},t}(BaseConv),Conv2D=function(e){function t(n){var r=e.call(this,2,n)||this;return t.verifyArgs(n),r}return __extends(t,e),t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return delete t.rank,t},t.verifyArgs=function(e){if("number"!=typeof e.kernelSize&&!checkArrayTypeAndLength(e.kernelSize,"number",1,2))throw new ValueError("Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received "+JSON.stringify(e.kernelSize)+".")},t.className="Conv2D",t}(Conv);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Conv2D);var Conv3D=function(e){function t(n){var r=e.call(this,3,n)||this;return t.verifyArgs(n),r}return __extends(t,e),t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return delete t.rank,t},t.verifyArgs=function(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new ValueError("Conv3D expects config.kernelSize to be number or [number, number, number], but received "+JSON.stringify(e.kernelSize)+".")},t.className="Conv3D",t}(Conv);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Conv3D);var Conv2DTranspose=function(e){function t(t){var n=e.call(this,t)||this;if(n.inputSpec=[new InputSpec({ndim:4})],"same"!==n.padding&&"valid"!==n.padding)throw new ValueError("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode "+n.padding);return n}return __extends(t,e),t.prototype.build=function(e){var t;if(4!==(e=getExactlyOneShape(e)).length)throw new ValueError("Input should have rank 4; Received input shape: "+JSON.stringify(e));var n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new ValueError("The channel dimension of the inputs should be defined. Found `None`.");var r=e[n],i=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new InputSpec({ndim:4,axes:(t={},t[n]=r,t)})],this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e);if(4!==t.shape.length)throw new ValueError("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-"+t.shape.length);var r,i,a=t.shape,o=a[0];"channelsFirst"===n.dataFormat?(r=2,i=3):(r=1,i=2);var s=a[r],l=a[i],u=n.kernelSize[0],c=n.kernelSize[1],p=n.strides[0],h=n.strides[1],d=[o,deconvLength(s,p,u,n.padding),deconvLength(l,h,c,n.padding),n.filters];"channelsLast"!==n.dataFormat&&(t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(t,[0,2,3,1]));var f=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2dTranspose"])(t,n.kernel.read(),d,n.strides,n.padding);return"channelsLast"!==n.dataFormat&&(f=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(f,[0,3,1,2])),null!=n.bias&&(f=biasAdd(f,n.bias.read(),n.dataFormat)),null!=n.activation&&(f=n.activation.apply(f)),f})},t.prototype.computeOutputShape=function(e){var t,n,r,i=(e=getExactlyOneShape(e)).slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3):(t=3,n=1,r=2);var a=this.kernelSize[0],o=this.kernelSize[1],s=this.strides[0],l=this.strides[1];return i[t]=this.filters,i[n]=deconvLength(i[n],s,a,this.padding),i[r]=deconvLength(i[r],l,o,this.padding),i},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return delete t.dilationRate,t},t.className="Conv2DTranspose",t}(Conv2D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Conv2DTranspose);var SeparableConv=function(e){function t(t,n){var r=e.call(this,t,n)||this;if(r.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",r.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",r.depthwiseKernel=null,r.pointwiseKernel=null,null==n.filters)throw new ValueError("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=n.kernelInitializer||null!=n.kernelRegularizer||null!=n.kernelConstraint)throw new ValueError("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=n.padding&&"same"!==n.padding&&"valid"!==n.padding)throw new ValueError("SeparableConv"+r.rank+"D supports only padding modes: 'same' and 'valid', but received "+JSON.stringify(n.padding));return r.depthMultiplier=null==n.depthMultiplier?1:n.depthMultiplier,r.depthwiseInitializer=getInitializer(n.depthwiseInitializer||r.DEFAULT_DEPTHWISE_INITIALIZER),r.depthwiseRegularizer=getRegularizer(n.depthwiseRegularizer),r.depthwiseConstraint=getConstraint(n.depthwiseConstraint),r.pointwiseInitializer=getInitializer(n.depthwiseInitializer||r.DEFAULT_POINTWISE_INITIALIZER),r.pointwiseRegularizer=getRegularizer(n.pointwiseRegularizer),r.pointwiseConstraint=getConstraint(n.pointwiseConstraint),r}return __extends(t,e),t.prototype.build=function(e){var t;if((e=getExactlyOneShape(e)).length<this.rank+2)throw new ValueError("Inputs to SeparableConv"+this.rank+"D should have rank "+(this.rank+2)+", but received input shape: "+JSON.stringify(e));var n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n]||e[n]<0)throw new ValueError("The channel dimension of the inputs should be defined, but found "+JSON.stringify(e[n]));for(var r=e[n],i=this.kernelSize.concat([r,this.depthMultiplier]),a=[],o=0;o<this.rank;++o)a.push(1);a.push(r*this.depthMultiplier,this.filters);this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,!0,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.inputSpec=[new InputSpec({ndim:this.rank+2,axes:(t={},t[n]=r,t)})],this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t;if(e=getExactlyOneTensor(e),1===n.rank)throw new NotImplementedError("1D separable convolution is not implemented yet.");return 2===n.rank&&("channelsFirst"===n.dataFormat&&(e=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(e,[0,2,3,1])),t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["separableConv2d"])(e,n.depthwiseKernel.read(),n.pointwiseKernel.read(),n.strides,n.padding,n.dilationRate,"NHWC")),n.useBias&&(t=biasAdd(t,n.bias.read(),n.dataFormat)),null!=n.activation&&(t=n.activation.apply(t)),"channelsFirst"===n.dataFormat&&(t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(t,[0,3,1,2])),t})},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=serializeInitializer(this.depthwiseInitializer),t.pointwiseInitializer=serializeInitializer(this.pointwiseInitializer),t.depthwiseRegularizer=serializeRegularizer(this.depthwiseRegularizer),t.pointwiseRegularizer=serializeRegularizer(this.pointwiseRegularizer),t.depthwiseConstraint=serializeConstraint(this.depthwiseConstraint),t.pointwiseConstraint=serializeConstraint(this.pointwiseConstraint),t},t.className="SeparableConv",t}(Conv),SeparableConv2D=function(e){function t(t){return e.call(this,2,t)||this}return __extends(t,e),t.className="SeparableConv2D",t}(SeparableConv);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(SeparableConv2D);var Conv1D=function(e){function t(n){var r=e.call(this,1,n)||this;return t.verifyArgs(n),r.inputSpec=[{ndim:3}],r}return __extends(t,e),t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return delete t.rank,delete t.dataFormat,t},t.verifyArgs=function(e){if("number"!=typeof e.kernelSize&&!checkArrayTypeAndLength(e.kernelSize,"number",1,1))throw new ValueError("Conv1D expects config.kernelSize to be number or number[] with length 1, but received "+JSON.stringify(e.kernelSize)+".")},t.className="Conv1D",t}(Conv);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Conv1D);var Cropping2D=function(e){function t(t){var n=e.call(this,t)||this;return"number"==typeof t.cropping?n.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"==typeof t.cropping[0]?n.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:n.cropping=t.cropping,n.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,n.inputSpec=[{ndim:4}],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return e=getExactlyOneTensor(e),"channelsLast"===n.dataFormat?sliceAlongAxis(sliceAlongAxis(e,n.cropping[0][0],e.shape[1]-n.cropping[0][0]-n.cropping[0][1],2),n.cropping[1][0],e.shape[2]-n.cropping[1][1]-n.cropping[1][0],3):sliceAlongAxis(sliceAlongAxis(e,n.cropping[0][0],e.shape[2]-n.cropping[0][0]-n.cropping[0][1],3),n.cropping[1][0],e.shape[3]-n.cropping[1][1]-n.cropping[1][0],4)})},t.prototype.getConfig=function(){var t={cropping:this.cropping,dataFormat:this.dataFormat},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Cropping2D",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Cropping2D);var UpSampling2D=function(e){function t(t){var n=e.call(this,t)||this;return n.DEFAULT_SIZE=[2,2],n.inputSpec=[{ndim:4}],n.size=null==t.size?n.DEFAULT_SIZE:t.size,n.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,n}return __extends(t,e),t.prototype.computeOutputShape=function(e){if("channelsFirst"===this.dataFormat){var t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e),r=t.shape;if("channelsFirst"===n.dataFormat){t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(t,[0,2,3,1]);var i=n.size[0]*r[2],a=n.size[1]*r[3],o=t.resizeNearestNeighbor([i,a]);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(o,[0,3,1,2])}i=n.size[0]*r[1],a=n.size[1]*r[2];return t.resizeNearestNeighbor([i,a])})},t.prototype.getConfig=function(){var t={size:this.size,dataFormat:this.dataFormat},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="UpSampling2D",t}(Layer);function depthwiseConv2d$1(e,t,n,r,i,a){return void 0===n&&(n=[1,1]),void 0===r&&(r="valid"),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){null==i&&(i=imageDataFormat()),checkDataFormat(i);var o=preprocessConv2DInput(e,i);if(4!==e.rank)throw new ValueError("Input for depthwiseConv2d is required to be 4-D, but is instead "+e.rank+"-D");if(4!==t.rank)throw new ValueError("depthwiseKernel is required to be 4-D, but is instead "+t.rank+"-D");return o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthwiseConv2d"])(o,t,n,"same"===r?"same":"valid","NHWC",a),"channelsFirst"===i&&(o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(o,[0,3,1,2])),o})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(UpSampling2D);var DepthwiseConv2D=function(e){function t(t){var n=e.call(this,2,t)||this;return n.depthwiseKernel=null,n.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,n.depthwiseInitializer=getInitializer(t.depthwiseInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.depthwiseConstraint=getConstraint(t.depthwiseConstraint),n.depthwiseRegularizer=getRegularizer(t.depthwiseRegularizer),n}return __extends(t,e),t.prototype.build=function(e){if((e=getExactlyOneShape(e)).length<4)throw new ValueError("Inputs to DepthwiseConv2D should have rank 4. Received input shape: "+JSON.stringify(e)+".");var t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new ValueError("The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not ("+e[t]+").");var n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=depthwiseConv2d$1(e=getExactlyOneTensor(e),n.depthwiseKernel.read(),n.strides,n.padding,n.dataFormat,null);return n.useBias&&(t=biasAdd(t,n.bias.read(),n.dataFormat)),null!=n.activation&&(t=n.activation.apply(t)),t})},t.prototype.computeOutputShape=function(e){e=getExactlyOneShape(e);var t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=convOutputLength(t,this.kernelSize[0],this.padding,this.strides[0]),a=convOutputLength(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,i,a]:[e[0],i,a,r]},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=serializeInitializer(this.depthwiseInitializer),t.depthwiseRegularizer=serializeRegularizer(this.depthwiseRegularizer),t.depthwiseConstraint=serializeConstraint(this.depthwiseRegularizer),t},t.className="DepthwiseConv2D",t}(BaseConv);function mapActivationToFusedKernel(e){return"relu"===e?"relu":"linear"===e?"linear":null}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(DepthwiseConv2D);var Dropout=function(e){function t(t){var n=e.call(this,t)||this;if(n.rate=Math.max(Math.min(t.rate,1),0),n.noiseShape=t.noiseShape,n.seed=t.seed,null!=n.seed)throw new NotImplementedError("Non-default seed is not implemented in Dropout layer yet: "+n.seed);return n.supportsMasking=!0,n}return __extends(t,e),t.prototype.getNoiseShape=function(e){if(null==this.noiseShape)return this.noiseShape;for(var t=e.shape,n=[],r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e);if(null!=n.noiseShape&&!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(r.shape,n.noiseShape))throw new NotImplementedError("Non-default noise shape is not implemented in Dropout layer yet: "+JSON.stringify(n.noiseShape));if(0<n.rate&&n.rate<1){var i=null!=t.training&&t.training,a=n.getNoiseShape(r);return inTrainPhase(function(){return dropout(r,n.rate,a,n.seed)},function(){return r},i)}return e})},t.prototype.getConfig=function(){var t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.prototype.dispose=function(){return e.prototype.dispose.call(this)},t.className="Dropout",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Dropout);var Dense=function(e){function t(t){var n=e.call(this,t)||this;if(n.activation=null,n.useBias=!0,n.kernel=null,n.bias=null,n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){var r=null;null!=t.batchSize&&(r=t.batchSize),n.batchInputShape=[r,t.inputDim]}return n.units=t.units,assertPositiveInteger(n.units,"units"),n.activation=getActivation(t.activation),null!=t.useBias&&(n.useBias=t.useBias),n.kernelInitializer=getInitializer(t.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.biasInitializer=getInitializer(t.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.kernelConstraint=getConstraint(t.kernelConstraint),n.biasConstraint=getConstraint(t.biasConstraint),n.kernelRegularizer=getRegularizer(t.kernelRegularizer),n.biasRegularizer=getRegularizer(t.biasRegularizer),n.activityRegularizer=getRegularizer(t.activityRegularizer),n.supportsMasking=!0,n.inputSpec=[{minNDim:2}],n}return __extends(t,e),t.prototype.build=function(e){var t,n=(e=getExactlyOneShape(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:(t={},t[-1]=n,t)}],this.built=!0},t.prototype.computeOutputShape=function(e){var t=(e=getExactlyOneShape(e)).slice();return t[t.length-1]=this.units,t},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r,i=getExactlyOneTensor(e),a=mapActivationToFusedKernel(n.activation.getClassName());return null!=a?r=dot(i,n.kernel.read(),a,n.bias?n.bias.read():null):(r=dot(i,n.kernel.read()),null!=n.bias&&(r=biasAdd(r,n.bias.read())),null!=n.activation&&(r=n.activation.apply(r))),r})},t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),biasConstraint:serializeConstraint(this.biasConstraint)},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Dense",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Dense);var Flatten=function(e){function t(t){var n=e.call(this,t||{})||this;return n.inputSpec=[{minNDim:3}],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){for(var t=0,n=(e=getExactlyOneShape(e)).slice(1);t<n.length;t++){if(null==n[t])throw new ValueError('The shape of the input to "Flatten" is not fully defined (got '+e.slice(1)+'). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.')}return[e[0],arrayProd(e,1)]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return n.invokeCallHook(e,t),batchFlatten(getExactlyOneTensor(e))})},t.className="Flatten",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Flatten);var Activation$1=function(e){function t(t){var n=e.call(this,t)||this;return n.supportsMasking=!0,n.activation=getActivation(t.activation),n}return __extends(t,e),t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e);return n.activation.apply(r)})},t.prototype.getConfig=function(){var t={activation:serializeActivation(this.activation)},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Activation",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Activation$1);var RepeatVector=function(e){function t(t){var n=e.call(this,t)||this;return n.n=t.n,n.inputSpec=[{ndim:2}],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return[e[0],this.n,e[1]]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return repeat(e=getExactlyOneTensor(e),n.n)})},t.prototype.getConfig=function(){var t={n:this.n},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="RepeatVector",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(RepeatVector);var Reshape=function(e){function t(t){var n=e.call(this,t)||this;n.targetShape=t.targetShape;for(var r=0;r<n.targetShape.length;++r)n.isUnknown(n.targetShape[r])&&(n.targetShape[r]=null);return n}return __extends(t,e),t.prototype.isUnknown=function(e){return e<0||null==e},t.prototype.fixUnknownDimension=function(e,t){for(var n="Total size of new array must be unchanged.",r=t.slice(),i=1,a=null,o=0;o<r.length;++o){var s=r[o];if(this.isUnknown(s)){if(null!==a)throw new ValueError("Can only specifiy one unknown dimension.");a=o}else i*=s}var l=arrayProd(e);if(null!==a){if(0===i||l%i!=0)throw new ValueError(n);r[a]=l/i}else if(l!==i)throw new ValueError(n);return r},t.prototype.computeOutputShape=function(e){for(var t=!1,n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e),i=r.shape,a=i.slice(0,1).concat(n.fixUnknownDimension(i.slice(1),n.targetShape));return r.reshape(a)})},t.prototype.getConfig=function(){var t={targetShape:this.targetShape},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Reshape",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Reshape);var Permute=function(e){function t(t){var n=e.call(this,t)||this;if(null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+t.dims+" instead.");var r=range(1,t.dims.length+1);if(!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(t.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");return n.dims=t.dims,n.dimsIncludingBatch=[0].concat(n.dims),n.inputSpec=[new InputSpec({ndim:n.dims.length+1})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){var t=(e=getExactlyOneShape(e)).slice();return this.dims.forEach(function(n,r){t[r+1]=e[n]}),t},t.prototype.call=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(getExactlyOneTensor(e),this.dimsIncludingBatch)},t.prototype.getConfig=function(){var t={dims:this.dims},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Permute",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Permute);var Masking=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;return n.supportsMasking=!0,n.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0,n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this),n={maskValue:this.maskValue};return Object.assign(n,t),n},t.prototype.computeMask=function(e,t){var n=getExactlyOneTensor(e);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["any"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["notEqual"])(n,this.maskValue),-1)},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["any"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["notEqual"])(r,n.maskValue),-1,!0);return r.mul(i.asType(r.dtype))})},t.className="Masking",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Masking);var Embedding=function(e){function t(t){var n=e.call(this,t)||this;if(n.embeddings=null,n.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){var r=null;null!=t.batchSize&&(r=t.batchSize),null==t.inputLength?n.batchInputShape=[r,null]:n.batchInputShape=[r].concat(toList(t.inputLength))}return n.inputDim=t.inputDim,assertPositiveInteger(n.inputDim,"inputDim"),n.outputDim=t.outputDim,assertPositiveInteger(n.outputDim,"outputDim"),n.embeddingsInitializer=getInitializer(t.embeddingsInitializer||n.DEFAULT_EMBEDDINGS_INITIALIZER),n.embeddingsRegularizer=getRegularizer(t.embeddingsRegularizer),n.activityRegularizer=getRegularizer(t.activityRegularizer),n.embeddingsConstraint=getConstraint(t.embeddingsConstraint),n.maskZero=t.maskZero,n.supportsMasking=t.maskZero,n.inputLength=t.inputLength,n}return __extends(t,e),t.prototype.build=function(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0},t.prototype.warnOnIncompatibleInputShape=function(e){},t.prototype.computeMask=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return n.maskZero?(e=getExactlyOneTensor(e),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["notEqual"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zerosLike"])(e))):null})},t.prototype.computeOutputShape=function(e){if(e=getExactlyOneShape(e),null==this.inputLength)return e.concat([this.outputDim]);var t=toList(this.inputLength);if(t.length!==e.length-1)throw new ValueError('"inputLength" is '+this.inputLength+", but received input shape has shape "+e);for(var n=0,r=0;r<t.length;++r){var i=t[r],a=e[r+1];if(null!=i&&null!=a&&i!==a)throw new ValueError('"inputLength" is '+this.inputLength+", but received input shape has shape "+e);null==i&&(t[n]=a),n++}return[e[0]].concat(t,[this.outputDim])},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e);return"int32"!==r.dtype&&(r=cast$1(r,"int32")),gather$1(n.embeddings.read(),r.as1D()).reshape(getExactlyOneShape(n.computeOutputShape(r.shape)))})},t.prototype.getConfig=function(){var t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:serializeInitializer(this.embeddingsInitializer),embeddingsRegularizer:serializeRegularizer(this.embeddingsRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),embeddingsConstraint:serializeConstraint(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Embedding",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Embedding);var Merge=function(e){function t(t){var n=e.call(this,t||{})||this;return n.supportsMasking=!0,n}return __extends(t,e),t.prototype.mergeFunction=function(e){throw new NotImplementedError},t.prototype.computeElementwiseOpOutputShape=function(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;for(var n=e.slice(0,e.length-t.length),r=0;r<t.length;++r){var i=e[e.length-t.length+r],a=t[r];if(null==i||null==a||i<0||a<0)n.push(null);else if(1===i)n.push(a);else if(1===a)n.push(i);else{if(i!==a)throw new ValueError("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(i)}}return n},t.prototype.build=function(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[getExactlyOneShape(e)]),(e=e).length<2)throw new ValueError("A merge layer should be called on an Array of at least 2 inputs. Got "+e.length+" input(s).");for(var t=[],n=0,r=e;n<r.length;n++){null!=(o=r[n])&&null!==o[0]&&t.push(o[0])}if((t=unique(t)).length>1)throw new ValueError("Can not merge tensors with different batch sizes. Got tensors with shapes: "+JSON.stringify(e)+".");for(var i=null==e[0]?null:e[0].slice(1),a=1;a<e.length;++a){var o=null==e[a]?null:e[a].slice(1);i=this.computeElementwiseOpOutputShape(i,o)}var s=e.map(function(e){return e.length});-1===e.indexOf(null)&&1===unique(s).length?this.reshapeRequired=!1:this.reshapeRequired=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(e=e,n.reshapeRequired){var t=[],r=e.map(function(e){return e.rank});if(-1===r.indexOf(null)){for(var i=max$1(r),a=0,o=e;a<o.length;a++){for(var s=(h=o[a]).rank,l=0;l<i-s;++l)h=expandDims$1(h,1);t.push(h)}return n.mergeFunction(t)}for(var u=!1,c=0,p=e;c<p.length;c++){var h;if(null==(s=(h=p[c]).rank)){var d=h.shape,f=d[0],g=d.slice(1).concat([f]),m=h.reshape([f].concat(arrayProd(d.slice(1))));m=(m=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(m,[1,0])).reshape(g),t.push(m),u=!0}else if(s>1){var y=range(1,s).concat([0]);t.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(h,y)),u=!0}else t.push(h)}var v=n.mergeFunction(t),b=v.rank;if(u)if(null==b){var w=v.shape;g=[f=w[w.length-1]].concat(w.slice(0,w.length-1));v=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(v.reshape([-1,f]),[1,0]).reshape(g)}else if(b>1){y=[b-1].concat(range(0,b-1));v=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(v,y)}return v}return n.mergeFunction(e)})},t.prototype.computeOutputShape=function(e){var t;t=null==(e=e)[0]?null:e[0].slice(1);for(var n=1;n<e.length;++n){var r=null==e[n]?null:e[n].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}for(var i=[],a=0,o=e;a<o.length;a++){null!=(r=o[a])&&null!==r[0]&&i.push(r[0])}return t=1===(i=unique(i)).length?i.concat(t):[null].concat(t)},t.prototype.computeMask=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null==t)return null;if(!Array.isArray(t))throw new ValueError("`mask` should be an Array");if(!Array.isArray(e))throw new ValueError("`inputs` should be an Array");if(t.length!==e.length)throw new ValueError("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths ("+e.length+" vs "+t.length+")");if(t.every(function(e){return null==e}))return null;for(var n=(t=t.map(function(e){return null==e?e:Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"])(e,0)}))[0],r=1;r<t.length-1;++r)n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"])(n,t[r]);return n})},t}(Layer),Add=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.mergeFunction=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=e[0].clone(),n=1;n<e.length;++n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(t,e[n]);return t})},t.className="Add",t}(Merge);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Add);var Multiply=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.mergeFunction=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=e[0].clone(),n=1;n<e.length;++n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(t,e[n]);return t})},t.className="Multiply",t}(Merge);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Multiply);var Average=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.mergeFunction=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=e[0].clone(),n=1;n<e.length;++n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(t,e[n]);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(1/e.length,t)})},t.className="Average",t}(Merge);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Average);var Maximum=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.mergeFunction=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=e[0],n=1;n<e.length;++n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(t,e[n]);return t})},t.className="Maximum",t}(Merge);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Maximum);var Minimum=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.mergeFunction=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=e[0],n=1;n<e.length;++n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["minimum"])(t,e[n]);return t})},t.className="Minimum",t}(Merge);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Minimum);var Concatenate=function(e){function t(t){var n=e.call(this,t)||this;return n.DEFAULT_AXIS=-1,null==t&&(t={}),n.axis=null==t.axis?n.DEFAULT_AXIS:t.axis,n.supportsMasking=!0,n.reshapeRequired=!1,n}return __extends(t,e),t.prototype.build=function(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new ValueError("A `Concatenate` layer should be called on a list of at least 2 inputs");for(var t=!0,n=0,r=e=e;n<r.length;n++){if(null!=(c=r[n])){t=!1;break}}if(!t){for(var i=[],a=0;a<e.length;++a){var o=e[a].slice();o.splice(this.axis,1);for(var s=!1,l=0,u=i;l<u.length;l++){var c=u[l];if(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(c,o)){s=!0;break}}s||i.push(o)}if(i.length>1)throw new ValueError("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}},t.prototype.mergeFunction=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return concatenate(e,t.axis)})},t.prototype.computeOutputShape=function(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new ValueError("A `Concatenate` layer should be called on a list of inputs.");for(var t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis,i=0,a=t.slice(1);i<a.length;i++){var o=a[i];if(null==n[r]||null==o[r]){n[r]=null;break}n[r]+=o[r]}return n},t.prototype.computeMask=function(e,t){var n=this;if(null==t)return null;if(!Array.isArray(t))throw new ValueError("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new ValueError("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new ValueError("Mismatch in the length of mask ("+t.length+") and the legnth of inputs ("+e.length+")");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=!0;if(t.forEach(function(e){null==e||(r=!1)}),r)return null;for(var i=[],a=0;a<e.length;++a)null==t[a]?i.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(e[a]).asType("bool")):t[a].rank<e[a].rank?i.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"])(t[a],-1)):i.push(t[a]);var o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"])(i,n.axis);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["all"])(o,-1,!1)})},t.prototype.getConfig=function(){var t={axis:this.axis},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Concatenate",t}(Merge);function interpretAxis(e,t){for(;e<0;)e+=t;return e}function batchDot(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new NotImplementedError("batchDot is not implemented for tensors of 4D or higher rank yet");if(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(e.shape.length>=2,function(){return"batchDot requires the rank of x to be >= 2, but got "+e.shape.length}),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(e.shape.length>=2,function(){return"batchDot requires the rank of y to be >= 2, but got "+t.shape.length}),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new NotImplementedError("batchDot is not implemented for complex64-type Tensors yet.");var r=e.shape.length,i=t.shape.length;null==n&&(n=[r-1,i-2]);var a=n;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n,o;if(r>i){n=r-i;for(var s=[],l=0;l<n;++l)s.push(1);t=t.reshape(t.shape.concat(s))}else if(i>r){n=i-r;for(s=[],l=0;l<n;++l)s.push(1);e=e.reshape(e.shape.concat(s))}else n=0;if(2===e.shape.length&&2===t.shape.length)o=a[0]===a[1]?e.mulStrict(t).sum(a[0]):e.transpose([1,0]).mulStrict(t).sum(a[1]);else{var u=a[0]!==e.shape.length-1,c=a[1]===t.shape.length-1;o=e.matMul(t,u,c)}if(n>0){var p=void 0,h=[];for(l=p=r>i?r+i-3:r-1;l<p+n;++l)h.push(l);o=o.squeeze(h)}return 1===o.shape.length&&(o=o.expandDims(1)),o})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Concatenate);var Dot=function(e){function t(t){var n=e.call(this,t)||this;return n.axes=t.axes,n.normalize=null!=t.normalize&&t.normalize,n.supportsMasking=!0,n.reshapeRequired=!1,n}return __extends(t,e),t.prototype.build=function(e){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),function(){return"A `Dot` layer should be called on a list of exactly 2 inputs."});var t=e[0],n=e[1];if(t.length>3||n.length>3)throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");var r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new ValueError("Dimension incompatibility: "+t[r[0]]+" !== "+n[r[1]])},t.prototype.mergeFunction=function(e){if(2!==e.length)throw new ValueError("A `Dot` layer must be called on exactly 2 inputs, but received "+e.length+" input(s).");var t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(function(t,n){return interpretAxis(t,e[n].shape.length)}):[interpretAxis(this.axes,n.shape.length),interpretAxis(this.axes,r.shape.length)],this.normalize&&(n=l2Normalize(n,t[0]),r=l2Normalize(r,t[1])),batchDot(n,r,t)},t.prototype.interpretAxes=function(e,t){return Array.isArray(this.axes)?this.axes:[interpretAxis(this.axes,e.length),interpretAxis(this.axes,t.length)]},t.prototype.computeOutputShape=function(e){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),function(){return"A `Dot` layer should be called on a list of exactly 2 inputs."});var t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");var r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);var i=t.concat(n);return 1===i.length&&i.push(1),i},t.prototype.computeMask=function(e,t){return null},t.prototype.getConfig=function(){var t={axes:this.axes,normalize:this.normalize},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Dot",t}(Merge);function batchNormalization(e,t,n,r,i,a){var o;if(void 0===a&&(a=.001),2===e.rank)o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm2d"])(e,t,n,r,i,a);else if(3===e.rank)o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm3d"])(e,t,n,r,i,a);else{if(4!==e.rank)throw new NotImplementedError("batchNormalization is not implemented for array of rank "+e.rank+" yet");o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm4d"])(e,t,n,r,i,a)}return o}function regularNormalizeBatchInTraining(e,t,n,r,i){return void 0===i&&(i=.001),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["moments"])(e,r),o=a.mean,s=a.variance;return[batchNormalization(e,o,s,n,t,i),o,s]})}function broadcastNormalizeBatchInTraining(e,t,n,r,i){return void 0===i&&(i=.001),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["moments"])(e,r),o=a.mean,s=a.variance,l=[],u=0,c=range(0,e.rank);u<c.length;u++){var p=c[u];-1!==r.indexOf(p)?l.push(1):l.push(e.shape[p])}var h=o.reshape(l),d=s.reshape(l),f=null==t?null:t.reshape(l),g=null==n?null:n.reshape(l);return[batchNormalization(e,h,d,g,f,i),o,s]})}function normalizeBatchInTraining(e,t,n,r,i){return void 0===i&&(i=.001),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(r.slice().sort(),range(0,e.rank-1))?regularNormalizeBatchInTraining(e,t,n,r,i):broadcastNormalizeBatchInTraining(e,t,n,r,i)}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Dot);var BatchNormalization=function(e){function t(t){var n=this;return null==t&&(t={}),(n=e.call(this,t)||this).supportsMasking=!0,n.axis=null==t.axis?-1:t.axis,n.momentum=null==t.momentum?.99:t.momentum,n.epsilon=null==t.epsilon?.001:t.epsilon,n.center=null==t.center||t.center,n.scale=null==t.scale||t.scale,n.betaInitializer=getInitializer(t.betaInitializer||"zeros"),n.gammaInitializer=getInitializer(t.gammaInitializer||"ones"),n.movingMeanInitializer=getInitializer(t.movingMeanInitializer||"zeros"),n.movingVarianceInitializer=getInitializer(t.movingVarianceInitializer||"ones"),n.betaConstraint=getConstraint(t.betaConstraint),n.gammaConstraint=getConstraint(t.gammaConstraint),n.betaRegularizer=getRegularizer(t.betaRegularizer),n.gammaRegularizer=getRegularizer(t.gammaRegularizer),n}return __extends(t,e),t.prototype.build=function(e){var t;e=getExactlyOneShape(e);var n=this.axis>=0?this.axis:this.axis+e.length,r=e[n];if(null==r)throw new ValueError("Axis "+n+" of input tensor should have a defined dimension but the layer received an input with shape "+JSON.stringify(e)+".");this.inputSpec=[new InputSpec({ndim:e.length,axes:(t={},t[n]=r,t)})];var i=[r];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=null!=t.training&&t.training,i=getExactlyOneTensor(e),a=i.shape,o=a.length,s=range(0,o),l=n.axis>=0?n.axis:n.axis+o;s.splice(l,1);var u=pyListRepeat(1,o);u[l]=a[l];var c=s.slice();c.sort();var p=!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(c,range(0,o).slice(0,o-1));if(!r)return function(){if(p){var e=n.movingMean.read().reshape(u),t=n.movingVariance.read().reshape(u),r=n.center?n.beta.read().reshape(u):null,a=n.scale?n.gamma.read().reshape(u):null;return batchNormalization(i,e,t,r,a,n.epsilon)}return batchNormalization(i,n.movingMean.read(),n.movingVariance.read(),null==n.beta?null:n.beta.read(),null==n.gamma?null:n.gamma.read(),n.epsilon)}();var h=normalizeBatchInTraining(i,n.gamma.read(),n.beta.read(),s,n.epsilon),d=h[0],f=h[1],g=h[2],m=function(e,t,n){Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=1-n,i=e.read(),a=i.sub(t).mul(r);e.write(i.sub(a))})};return m(n.movingMean,f,n.momentum),m(n.movingVariance,g,n.momentum),d})},t.prototype.getConfig=function(){var t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:serializeInitializer(this.betaInitializer),gammaInitializer:serializeInitializer(this.gammaInitializer),movingMeanInitializer:serializeInitializer(this.movingMeanInitializer),movingVarianceInitializer:serializeInitializer(this.movingVarianceInitializer),betaRegularizer:serializeRegularizer(this.betaRegularizer),gammaRegularizer:serializeRegularizer(this.gammaRegularizer),betaConstraint:serializeConstraint(this.betaConstraint),gammaConstraint:serializeConstraint(this.gammaConstraint)},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="BatchNormalization",t}(Layer);function spatial2dPadding(e,t,n){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(4!==e.rank)throw new ValueError("temporalPadding expects input tensor to be 4-D, but received a "+e.rank+"-D tensor.");if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new ValueError("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n=imageDataFormat()),"channelsLast"!==n&&"channelsFirst"!==n)throw new ValueError("Unknown data format: "+n+". Supported data formats are 'channelsLast' and 'channelsFirst.");var r;return r="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad"])(e,r)})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(BatchNormalization);var ZeroPadding2D=function(e){function t(t){var n=this;if(null==t&&(t={}),(n=e.call(this,t)||this).dataFormat=null==t.dataFormat?imageDataFormat():t.dataFormat,null==t.padding)n.padding=[[1,1],[1,1]];else if("number"==typeof t.padding)n.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new ValueError("ZeroPadding2D expects padding to be a length-2 array, but received a length-"+t.padding.length+" array.");var r=void 0,i=void 0;if("number"==typeof t.padding[0])r=[t.padding[0],t.padding[0]],i=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new ValueError("ZeroPadding2D expects height padding to be a length-2 array, but received a length-"+t.padding[0].length+" array.");if(r=t.padding[0],2!==t.padding[1].length)throw new ValueError("ZeroPadding2D expects width padding to be a length-2 array, but received a length-"+t.padding[1].length+" array.");i=t.padding[1]}n.padding=[r,i]}return n.inputSpec=[new InputSpec({ndim:4})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){var t,n;return e=getExactlyOneShape(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return spatial2dPadding(getExactlyOneTensor(e),n.padding,n.dataFormat)})},t.prototype.getConfig=function(){var t={padding:this.padding,dataFormat:this.dataFormat},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="ZeroPadding2D",t}(Layer);function pool2d(e,t,n,r,i,a){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var o;checkDataFormat(i),checkPoolMode(a),checkPaddingMode(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==i&&(i=imageDataFormat()),null==a&&(a="max"),e=preprocessConv2DInput(e,i);var s="same"===r?"same":"valid";return o="max"===a?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maxPool"])(e,t,n,s):Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["avgPool"])(e,t,n,s),"channelsFirst"===i&&(o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(o,[0,3,1,2])),o})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(ZeroPadding2D);var Pooling1D=function(e){function t(t){var n=this;if(null==t.poolSize&&(t.poolSize=2),n=e.call(this,t)||this,"number"==typeof t.poolSize)n.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new ValueError("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+JSON.stringify(t.poolSize));n.poolSize=t.poolSize}if(assertPositiveInteger(n.poolSize,"poolSize"),null==t.strides)n.strides=n.poolSize;else if("number"==typeof t.strides)n.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new ValueError("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+JSON.stringify(t.strides));n.strides=t.strides}return assertPositiveInteger(n.strides,"strides"),n.padding=null==t.padding?"valid":t.padding,checkPaddingMode(n.padding),n.inputSpec=[new InputSpec({ndim:3})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){var t=convOutputLength((e=getExactlyOneShape(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t),e=expandDims$1(getExactlyOneTensor(e),2);var r=n.poolingFunction(getExactlyOneTensor(e),[n.poolSize[0],1],[n.strides[0],1],n.padding,"channelsLast");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squeeze"])(r,[2])})},t.prototype.getConfig=function(){var t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t}(Layer),MaxPooling1D=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.poolingFunction=function(e,t,n,r,i){return checkDataFormat(i),checkPaddingMode(r),pool2d(e,t,n,r,i,"max")},t.className="MaxPooling1D",t}(Pooling1D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(MaxPooling1D);var AveragePooling1D=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.poolingFunction=function(e,t,n,r,i){return checkDataFormat(i),checkPaddingMode(r),pool2d(e,t,n,r,i,"avg")},t.className="AveragePooling1D",t}(Pooling1D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(AveragePooling1D);var Pooling2D=function(e){function t(t){var n=this;if(null==t.poolSize&&(t.poolSize=[2,2]),(n=e.call(this,t)||this).poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)n.strides=n.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new ValueError("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+t.strides.length+".");n.strides=t.strides}else n.strides=[t.strides,t.strides];return assertPositiveInteger(n.poolSize,"poolSize"),assertPositiveInteger(n.strides,"strides"),n.padding=null==t.padding?"valid":t.padding,n.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,checkDataFormat(n.dataFormat),checkPaddingMode(n.padding),n.inputSpec=[new InputSpec({ndim:4})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){e=getExactlyOneShape(e);var t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=convOutputLength(t,this.poolSize[0],this.padding,this.strides[0]),n=convOutputLength(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return n.invokeCallHook(e,t),n.poolingFunction(getExactlyOneTensor(e),n.poolSize,n.strides,n.padding,n.dataFormat)})},t.prototype.getConfig=function(){var t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t}(Layer),MaxPooling2D=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.poolingFunction=function(e,t,n,r,i){return checkDataFormat(i),checkPaddingMode(r),pool2d(e,t,n,r,i,"max")},t.className="MaxPooling2D",t}(Pooling2D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(MaxPooling2D);var AveragePooling2D=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.poolingFunction=function(e,t,n,r,i){return checkDataFormat(i),checkPaddingMode(r),pool2d(e,t,n,r,i,"avg")},t.className="AveragePooling2D",t}(Pooling2D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(AveragePooling2D);var GlobalPooling1D=function(e){function t(t){var n=e.call(this,t)||this;return n.inputSpec=[new InputSpec({ndim:3})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return[e[0],e[2]]},t.prototype.call=function(e,t){throw new NotImplementedError},t}(Layer),GlobalAveragePooling1D=function(e){function t(t){return e.call(this,t||{})||this}return __extends(t,e),t.prototype.call=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(t,1)})},t.className="GlobalAveragePooling1D",t}(GlobalPooling1D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlobalAveragePooling1D);var GlobalMaxPooling1D=function(e){function t(t){return e.call(this,t||{})||this}return __extends(t,e),t.prototype.call=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(t,1)})},t.className="GlobalMaxPooling1D",t}(GlobalPooling1D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlobalMaxPooling1D);var GlobalPooling2D=function(e){function t(t){var n=e.call(this,t)||this;return n.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,checkDataFormat(n.dataFormat),n.inputSpec=[new InputSpec({ndim:4})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return e=e,"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]},t.prototype.call=function(e,t){throw new NotImplementedError},t.prototype.getConfig=function(){var t={dataFormat:this.dataFormat},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t}(Layer),GlobalAveragePooling2D=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e);return"channelsLast"===n.dataFormat?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(t,[1,2]):Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(t,[2,3])})},t.className="GlobalAveragePooling2D",t}(GlobalPooling2D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlobalAveragePooling2D);var GlobalMaxPooling2D=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e);return"channelsLast"===n.dataFormat?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(t,[1,2]):Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(t,[2,3])})},t.className="GlobalMaxPooling2D",t}(GlobalPooling2D);function standardizeArgs(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new ValueError("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function i(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=i(t),constants:n=i(n)}}function rnn(e,t,n,r,i,a,o,s){return void 0===r&&(r=!1),void 0===o&&(o=!1),void 0===s&&(s=!1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var l=t.shape.length;if(l<3)throw new ValueError("Input should be at least 3D, but is "+l+"D.");var u=[1,0].concat(range(2,l));if(t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(t,u),null!=a)throw new NotImplementedError("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=i&&((i=i.asType("bool").asType("float32")).rank===l-1&&(i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"])(i,-1)),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(i,u)),r&&(t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse"])(t,0),null!=i&&(i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse"])(i,0)));var c,p,h=[],d=n,f=t.shape[0],g=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"])(t);null!=i&&(p=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"])(i));for(var m,y=function(t){var n=g[t],r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return e(n,d)});if(null==i)c=r[0],d=r[1];else{var a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var e=p[t],n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(e).sub(e);return{output:r[0].mul(e).addStrict(d[0].mul(n)),newStates:d.map(function(t,i){return r[1][i].mul(e).addStrict(t.mul(n))})}});c=a.output,d=a.newStates}s&&h.push(c)},v=0;v<f;++v)y(v);if(s){m=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"])(h,1)}return[c,m,d]})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlobalMaxPooling2D);var RNN=function(e){function t(t){var n,r=e.call(this,t)||this;if(null==t.cell)throw new ValueError("cell property is missing for the constructor of RNN.");if(null==(n=Array.isArray(t.cell)?new StackedRNNCells({cells:t.cell}):t.cell).stateSize)throw new ValueError("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");return r.cell=n,r.returnSequences=null!=t.returnSequences&&t.returnSequences,r.returnState=null!=t.returnState&&t.returnState,r.goBackwards=null!=t.goBackwards&&t.goBackwards,r._stateful=null!=t.stateful&&t.stateful,r.unroll=null!=t.unroll&&t.unroll,r.supportsMasking=!0,r.inputSpec=[new InputSpec({ndim:3})],r.stateSpec=null,r.states_=null,r.numConstants=null,r.keptStates=[],r}return __extends(t,e),t.prototype.getStates=function(){return null==this.states_?range(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(function(e){return null}):this.states_},t.prototype.setStates=function(e){this.states_=e},t.prototype.computeOutputShape=function(e){isArrayOfShapes(e)&&(e=e[0]),e=e;var t=this.cell.stateSize;Array.isArray(t)||(t=[t]);var n,r=t[0];if(n=this.returnSequences?[e[0],e[1],r]:[e[0],r],this.returnState){for(var i=[],a=0,o=t;a<o.length;a++){var s=o[a];i.push([e[0],s])}return[n].concat(i)}return n},t.prototype.computeMask=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){Array.isArray(t)&&(t=t[0]);var e=n.returnSequences?t:null;if(n.returnState){var r=n.states.map(function(e){return null});return[e].concat(r)}return e})},Object.defineProperty(t.prototype,"states",{get:function(){if(null==this.states_){for(var e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[],n=0;n<e;++n)t.push(null);return t}return this.states_},set:function(e){this.states_=e},enumerable:!0,configurable:!0}),t.prototype.build=function(e){if(null!=this.numConstants)throw new NotImplementedError("Constants support is not implemented in RNN yet.");isArrayOfShapes(e)&&(e=e[0]),e=e;var t=this.stateful?e[0]:null,n=e[e.length-1];this.inputSpec[0]=new InputSpec({shape:[t,null,n]});var r,i=[e[0]].concat(e.slice(2));if(this.cell.build(i),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(this.stateSpec.map(function(e){return e.shape[e.shape.length-1]}),r))throw new ValueError("An initialState was passed that is not compatible with cell.stateSize. Received stateSpec="+this.stateSpec+"; However cell.stateSize is "+this.cell.stateSize)}else this.stateSpec=r.map(function(e){return new InputSpec({shape:[null,e]})});this.stateful&&this.resetStates()},t.prototype.resetStates=function(e,t){var n=this;void 0===t&&(t=!1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(!n.stateful)throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");var r=n.inputSpec[0].shape[0];if(null==r)throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==n.states_)Array.isArray(n.cell.stateSize)?n.states_=n.cell.stateSize.map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])([r,e])}):n.states_=[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])([r,n.cell.stateSize])];else if(null==e)Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(n.states_),null!=n.keptStates&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(n.keptStates),n.keptStates=[]),Array.isArray(n.cell.stateSize)?n.states_=n.cell.stateSize.map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])([r,e])}):n.states_[0]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])([r,n.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==n.states_.length)throw new ValueError("Layer "+n.name+" expects "+n.states_.length+" state(s), but it received "+e.length+" state value(s). Input received: "+e);!0===t?n.keptStates.push(n.states_.slice()):Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(n.states_);for(var i=0;i<n.states_.length;++i){var a=e[i],o=Array.isArray(n.cell.stateSize)?n.cell.stateSize[i]:n.cell.stateSize,s=[r,o];if(!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(a.shape,s))throw new ValueError("State "+i+" is incompatible with layer "+n.name+": expected shape="+s+", received shape="+a.shape);n.states_[i]=a}}n.states_=n.states_.map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(e.clone())})})},t.prototype.apply=function(t,n){var r=null==n?null:n.initialState,i=null==n?null:n.constants;null==n&&(n={});var a=standardizeArgs(t,r,i,this.numConstants);t=a.inputs,r=a.initialState,i=a.constants;var o=[],s=[];if(null!=r){n.initialState=r,o=o.concat(r),this.stateSpec=[];for(var l=0,u=r;l<u.length;l++){var c=u[l];this.stateSpec.push(new InputSpec({shape:c.shape}))}s=s.concat(this.stateSpec)}if(null!=i&&(n.constants=i,o=o.concat(i),this.numConstants=i.length),o[0]instanceof SymbolicTensor){var p=[t].concat(o),h=this.inputSpec.concat(s),d=this.inputSpec;this.inputSpec=h;var f=e.prototype.apply.call(this,p,n);return this.inputSpec=d,f}return e.prototype.apply.call(this,t,n)},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=null==t?null:t.mask,i=null==t?null:t.training,a=null==t?null:t.initialState;e=getExactlyOneTensor(e),null==a&&(a=n.stateful?n.states_:n.getInitialState(e));var o=Array.isArray(n.cell.stateSize)?n.cell.stateSize.length:1;if(a.length!==o)throw new ValueError("RNN Layer has "+o+" state(s) but was passed "+a.length+" initial state(s).");n.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");var s={training:i},l=rnn(function(e,t){var r=n.cell.call([e].concat(t),s);return[r[0],r.slice(1)]},e,a,n.goBackwards,r,null,n.unroll,n.returnSequences),u=l[0],c=l[1],p=l[2];n.stateful&&n.resetStates(p,i);var h=n.returnSequences?c:u;return n.returnState?[h].concat(p):h})},t.prototype.getInitialState=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])(e.shape);return n=expandDims$1(n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(n,[1,2])),Array.isArray(t.cell.stateSize)?t.cell.stateSize.map(function(e){return e>1?tile$1(n,[1,e]):n}):t.cell.stateSize>1?[tile$1(n,[1,t.cell.stateSize])]:[n]})},Object.defineProperty(t.prototype,"trainableWeights",{get:function(){return this.trainable?this.cell.trainableWeights:[]},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights},enumerable:!0,configurable:!0}),t.prototype.setFastWeightInitDuringBuild=function(t){e.prototype.setFastWeightInitDuringBuild.call(this,t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)},t.prototype.getConfig=function(){var t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);var n=this.cell.getConfig();t.cell={className:this.cell.getClassName(),config:n};var r=e.prototype.getConfig.call(this);return Object.assign(t,r),t},t.className="RNN",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(RNN);var RNNCell=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t}(Layer),SimpleRNNCell=function(e){function t(t){var n=e.call(this,t)||this;return n.DEFAULT_ACTIVATION="tanh",n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_RECURRENT_INITIALIZER="orthogonal",n.DEFAULT_BIAS_INITIALIZER="zeros",n.units=t.units,assertPositiveInteger(n.units,"units"),n.activation=getActivation(null==t.activation?n.DEFAULT_ACTIVATION:t.activation),n.useBias=null==t.useBias||t.useBias,n.kernelInitializer=getInitializer(t.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.recurrentInitializer=getInitializer(t.recurrentInitializer||n.DEFAULT_RECURRENT_INITIALIZER),n.biasInitializer=getInitializer(t.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.kernelRegularizer=getRegularizer(t.kernelRegularizer),n.recurrentRegularizer=getRegularizer(t.recurrentRegularizer),n.biasRegularizer=getRegularizer(t.biasRegularizer),n.kernelConstraint=getConstraint(t.kernelConstraint),n.recurrentConstraint=getConstraint(t.recurrentConstraint),n.biasConstraint=getConstraint(t.biasConstraint),n.dropout=min$1([1,max$1([0,null==t.dropout?0:t.dropout])]),n.recurrentDropout=min$1([1,max$1([0,null==t.recurrentDropout?0:t.recurrentDropout])]),n.stateSize=n.units,n.dropoutMask=null,n.recurrentDropoutMask=null,n}return __extends(t,e),t.prototype.build=function(e){e=getExactlyOneShape(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(2!==(e=e).length)throw new ValueError("SimpleRNNCell expects 2 input Tensors, got "+e.length+".");var r=e[1];e=e[0];var i,a=null!=t.training&&t.training;0<n.dropout&&n.dropout<1&&null==n.dropoutMask&&(n.dropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(e)},n.dropout,a)),0<n.recurrentDropout&&n.recurrentDropout<1&&null==n.recurrentDropoutMask&&(n.recurrentDropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(r)},n.recurrentDropout,a));var o=n.dropoutMask,s=n.recurrentDropoutMask;i=dot(null!=o?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,o):e,n.kernel.read()),null!=n.bias&&(i=biasAdd(i,n.bias.read())),null!=s&&(r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(r,s));var l=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(i,dot(r,n.recurrentKernel.read()));return null!=n.activation&&(l=n.activation.apply(l)),[l,l]})},t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="SimpleRNNCell",t}(RNNCell);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(SimpleRNNCell);var SimpleRNN=function(e){function t(t){return t.cell=new SimpleRNNCell(t),e.call(this,t)||this}return __extends(t,e),t.prototype.call=function(t,n){var r=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){null!=r.cell.dropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.dropoutMask),r.cell.dropoutMask=null),null!=r.cell.recurrentDropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.recurrentDropoutMask),r.cell.recurrentDropoutMask=null);var i=null==n?null:n.mask,a=null==n?null:n.training,o=null==n?null:n.initialState;return e.prototype.call.call(r,t,{mask:i,training:a,initialState:o})})},Object.defineProperty(t.prototype,"units",{get:function(){return this.cell.units},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"activation",{get:function(){return this.cell.activation},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"useBias",{get:function(){return this.cell.useBias},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelInitializer",{get:function(){return this.cell.kernelInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentInitializer",{get:function(){return this.cell.recurrentInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasInitializer",{get:function(){return this.cell.biasInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelRegularizer",{get:function(){return this.cell.kernelRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentRegularizer",{get:function(){return this.cell.recurrentRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasRegularizer",{get:function(){return this.cell.biasRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelConstraint",{get:function(){return this.cell.kernelConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentConstraint",{get:function(){return this.cell.recurrentConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasConstraint",{get:function(){return this.cell.biasConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"dropout",{get:function(){return this.cell.dropout},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentDropout",{get:function(){return this.cell.recurrentDropout},enumerable:!0,configurable:!0}),t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout},n=e.prototype.getConfig.call(this);return delete n.cell,Object.assign(t,n),t},t.className="SimpleRNN",t}(RNN);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(SimpleRNN);var GRUCell=function(e){function t(t){var n=e.call(this,t)||this;return n.DEFAULT_ACTIVATION="tanh",n.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_RECURRENT_INITIALIZER="orthogonal",n.DEFAULT_BIAS_INITIALIZER="zeros",n.units=t.units,assertPositiveInteger(n.units,"units"),n.activation=getActivation(void 0===t.activation?n.DEFAULT_ACTIVATION:t.activation),n.recurrentActivation=getActivation(void 0===t.recurrentActivation?n.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),n.useBias=null==t.useBias||t.useBias,n.kernelInitializer=getInitializer(t.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.recurrentInitializer=getInitializer(t.recurrentInitializer||n.DEFAULT_RECURRENT_INITIALIZER),n.biasInitializer=getInitializer(t.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.kernelRegularizer=getRegularizer(t.kernelRegularizer),n.recurrentRegularizer=getRegularizer(t.recurrentRegularizer),n.biasRegularizer=getRegularizer(t.biasRegularizer),n.kernelConstraint=getConstraint(t.kernelConstraint),n.recurrentConstraint=getConstraint(t.recurrentConstraint),n.biasConstraint=getConstraint(t.biasConstraint),n.dropout=min$1([1,max$1([0,null==t.dropout?0:t.dropout])]),n.recurrentDropout=min$1([1,max$1([0,null==t.recurrentDropout?0:t.recurrentDropout])]),n.implementation=t.implementation,n.stateSize=n.units,n.dropoutMask=null,n.recurrentDropoutMask=null,n}return __extends(t,e),t.prototype.build=function(e){var t=(e=getExactlyOneShape(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(2!==(e=e).length)throw new ValueError("GRUCell expects 2 input Tensors (inputs, h, c), got "+e.length+".");var r=null!=t.training&&t.training,i=e[1];e=e[0],0<n.dropout&&n.dropout<1&&null==n.dropoutMask&&(n.dropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(e)},n.dropout,r,3)),0<n.recurrentDropout&&n.recurrentDropout<1&&null==n.recurrentDropoutMask&&(n.recurrentDropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(i)},n.recurrentDropout,r,3));var a,o,s,l=n.dropoutMask,u=n.recurrentDropoutMask;0<n.dropout&&n.dropout<1&&(e=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,l[0]));var c=dot(e,n.kernel.read());n.useBias&&(c=biasAdd(c,n.bias.read())),0<n.recurrentDropout&&n.recurrentDropout<1&&(i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(i,u[0]));var p=n.recurrentKernel.read(),h=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"])(p,[2*n.units,n.units],p.rank-1),d=h[0],f=h[1],g=dot(i,d),m=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"])(c,3,c.rank-1),y=m[0],v=m[1],b=m[2],w=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"])(g,2,g.rank-1),z=w[0],S=w[1];a=n.recurrentActivation.apply(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(y,z)),o=n.recurrentActivation.apply(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(v,S));var I=dot(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(o,i),f);s=n.activation.apply(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(b,I));var A=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(a,i),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(1,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"])(a)),s));return[A,A]})},t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="GRUCell",t}(RNNCell);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GRUCell);var GRU=function(e){function t(t){return 0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new GRUCell(t),e.call(this,t)||this}return __extends(t,e),t.prototype.call=function(t,n){var r=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){null!=r.cell.dropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.dropoutMask),r.cell.dropoutMask=null),null!=r.cell.recurrentDropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.recurrentDropoutMask),r.cell.recurrentDropoutMask=null);var i=null==n?null:n.mask,a=null==n?null:n.training,o=null==n?null:n.initialState;return e.prototype.call.call(r,t,{mask:i,training:a,initialState:o})})},Object.defineProperty(t.prototype,"units",{get:function(){return this.cell.units},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"activation",{get:function(){return this.cell.activation},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentActivation",{get:function(){return this.cell.recurrentActivation},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"useBias",{get:function(){return this.cell.useBias},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelInitializer",{get:function(){return this.cell.kernelInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentInitializer",{get:function(){return this.cell.recurrentInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasInitializer",{get:function(){return this.cell.biasInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelRegularizer",{get:function(){return this.cell.kernelRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentRegularizer",{get:function(){return this.cell.recurrentRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasRegularizer",{get:function(){return this.cell.biasRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelConstraint",{get:function(){return this.cell.kernelConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentConstraint",{get:function(){return this.cell.recurrentConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasConstraint",{get:function(){return this.cell.biasConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"dropout",{get:function(){return this.cell.dropout},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentDropout",{get:function(){return this.cell.recurrentDropout},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"implementation",{get:function(){return this.cell.implementation},enumerable:!0,configurable:!0}),t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},n=e.prototype.getConfig.call(this);return delete n.cell,Object.assign(t,n),t},t.fromConfig=function(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)},t.className="GRU",t}(RNN);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GRU);var LSTMCell=function(e){function t(t){var n=e.call(this,t)||this;return n.DEFAULT_ACTIVATION="tanh",n.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_RECURRENT_INITIALIZER="orthogonal",n.DEFAULT_BIAS_INITIALIZER="zeros",n.units=t.units,assertPositiveInteger(n.units,"units"),n.activation=getActivation(void 0===t.activation?n.DEFAULT_ACTIVATION:t.activation),n.recurrentActivation=getActivation(void 0===t.recurrentActivation?n.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),n.useBias=null==t.useBias||t.useBias,n.kernelInitializer=getInitializer(t.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.recurrentInitializer=getInitializer(t.recurrentInitializer||n.DEFAULT_RECURRENT_INITIALIZER),n.biasInitializer=getInitializer(t.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.unitForgetBias=t.unitForgetBias,n.kernelRegularizer=getRegularizer(t.kernelRegularizer),n.recurrentRegularizer=getRegularizer(t.recurrentRegularizer),n.biasRegularizer=getRegularizer(t.biasRegularizer),n.kernelConstraint=getConstraint(t.kernelConstraint),n.recurrentConstraint=getConstraint(t.recurrentConstraint),n.biasConstraint=getConstraint(t.biasConstraint),n.dropout=min$1([1,max$1([0,null==t.dropout?0:t.dropout])]),n.recurrentDropout=min$1([1,max$1([0,null==t.recurrentDropout?0:t.recurrentDropout])]),n.implementation=t.implementation,n.stateSize=[n.units,n.units],n.dropoutMask=null,n.recurrentDropoutMask=null,n}return __extends(t,e),t.prototype.build=function(e){var t,n,r=(e=getExactlyOneShape(e))[e.length-1];if(this.kernel=this.addWeight("kernel",[r,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){var i=this.biasInitializer,a=this.units;n=new((t=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e,t){var n=i.apply([a]),r=(new Ones).apply([a]),o=i.apply([2*a]);return concatAlongFirstAxis(concatAlongFirstAxis(n,r),o)},t}(Initializer)).className="CustomInit",t)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=null!=t.training&&t.training;if(3!==(e=e).length)throw new ValueError("LSTMCell expects 3 input Tensors (inputs, h, c), got "+e.length+".");var i=e[1],a=e[2];e=e[0],0<n.dropout&&n.dropout<1&&null==n.dropoutMask&&(n.dropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(e)},n.dropout,r,4)),0<n.recurrentDropout&&n.recurrentDropout<1&&null==n.recurrentDropoutMask&&(n.recurrentDropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(i)},n.recurrentDropout,r,4));var o,s,l,u,c=n.dropoutMask,p=n.recurrentDropoutMask;0<n.dropout&&n.dropout<1&&(e=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,c[0]));var h=dot(e,n.kernel.read());0<n.recurrentDropout&&n.recurrentDropout<1&&(i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(i,p[0])),h=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(h,dot(i,n.recurrentKernel.read())),n.useBias&&(h=biasAdd(h,n.bias.read()));var d=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"])(h,4,h.rank-1),f=d[0],g=d[1],m=d[2],y=d[3];o=n.recurrentActivation.apply(f),s=n.recurrentActivation.apply(g),l=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(s,a),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(o,n.activation.apply(m))),u=n.recurrentActivation.apply(y);var v=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(u,n.activation.apply(l));return[v,v,l]})},t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="LSTMCell",t}(RNNCell);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LSTMCell);var LSTM=function(e){function t(t){return 0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new LSTMCell(t),e.call(this,t)||this}return __extends(t,e),t.prototype.call=function(t,n){var r=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){null!=r.cell.dropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.dropoutMask),r.cell.dropoutMask=null),null!=r.cell.recurrentDropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.recurrentDropoutMask),r.cell.recurrentDropoutMask=null);var i=null==n?null:n.mask,a=null==n?null:n.training,o=null==n?null:n.initialState;return e.prototype.call.call(r,t,{mask:i,training:a,initialState:o})})},Object.defineProperty(t.prototype,"units",{get:function(){return this.cell.units},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"activation",{get:function(){return this.cell.activation},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentActivation",{get:function(){return this.cell.recurrentActivation},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"useBias",{get:function(){return this.cell.useBias},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelInitializer",{get:function(){return this.cell.kernelInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentInitializer",{get:function(){return this.cell.recurrentInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasInitializer",{get:function(){return this.cell.biasInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"unitForgetBias",{get:function(){return this.cell.unitForgetBias},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelRegularizer",{get:function(){return this.cell.kernelRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentRegularizer",{get:function(){return this.cell.recurrentRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasRegularizer",{get:function(){return this.cell.biasRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelConstraint",{get:function(){return this.cell.kernelConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentConstraint",{get:function(){return this.cell.recurrentConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasConstraint",{get:function(){return this.cell.biasConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"dropout",{get:function(){return this.cell.dropout},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentDropout",{get:function(){return this.cell.recurrentDropout},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"implementation",{get:function(){return this.cell.implementation},enumerable:!0,configurable:!0}),t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},n=e.prototype.getConfig.call(this);return delete n.cell,Object.assign(t,n),t},t.fromConfig=function(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)},t.className="LSTM",t}(RNN);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LSTM);var StackedRNNCells=function(e){function t(t){var n=e.call(this,t)||this;return n.cells=t.cells,n}return __extends(t,e),Object.defineProperty(t.prototype,"stateSize",{get:function(){for(var e=[],t=0,n=this.cells.slice().reverse();t<n.length;t++){var r=n[t];Array.isArray(r.stateSize)?e.push.apply(e,r.stateSize):e.push(r.stateSize)}return e},enumerable:!0,configurable:!0}),t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var r=(e=e).slice(1),i=[],a=0,o=n.cells.slice().reverse();a<o.length;a++){var s=o[a];Array.isArray(s.stateSize)?i.push(r.splice(0,s.stateSize.length)):i.push(r.splice(0,1))}i.reverse();for(var l,u=[],c=0;c<n.cells.length;++c){s=n.cells[c];r=i[c],l=0===c?[e[0]].concat(r):[l[0]].concat(r),l=s.call(l,t),u.push(l.slice(1))}r=[];for(var p=0,h=u.slice().reverse();p<h.length;p++){var d=h[p];r.push.apply(r,d)}return[l[0]].concat(r)})},t.prototype.build=function(e){var t;isArrayOfShapes(e)&&(e=e[0]),e=e;for(var n=0,r=this.cells;n<r.length;n++){var i=r[n];i.build(e),t=Array.isArray(i.stateSize)?i.stateSize[0]:i.stateSize,e=[e[0],t]}this.built=!0},t.prototype.getConfig=function(){for(var t=[],n=0,r=this.cells;n<r.length;n++){var i=r[n];t.push({className:this.getClassName(),config:i.getConfig()})}var a={cells:t},o=e.prototype.getConfig.call(this);return Object.assign(a,o),a},t.fromConfig=function(e,t,n){void 0===n&&(n={});for(var r=[],i=0,a=t.cells;i<a.length;i++){var o=a[i];r.push(deserialize(o,n))}return new e({cells:r})},Object.defineProperty(t.prototype,"trainableWeights",{get:function(){if(!this.trainable)return[];for(var e=[],t=0,n=this.cells;t<n.length;t++){var r=n[t];e.push.apply(e,r.trainableWeights)}return e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){for(var e=[],t=0,n=this.cells;t<n.length;t++){var r=n[t];e.push.apply(e,r.nonTrainableWeights)}if(!this.trainable){for(var i=[],a=0,o=this.cells;a<o.length;a++){r=o[a];i.push.apply(i,r.trainableWeights)}return i.concat(e)}return e},enumerable:!0,configurable:!0}),t.prototype.getWeights=function(){for(var e=[],t=0,n=this.cells;t<n.length;t++){var r=n[t];e.push.apply(e,r.weights)}return batchGetValue(e)},t.prototype.setWeights=function(e){for(var t=[],n=0,r=this.cells;n<r.length;n++)for(var i=r[n],a=i.weights.length,o=e.splice(a),s=0;s<i.weights.length;++s)t.push([i.weights[s],o[s]]);batchSetValue(t)},t.className="StackedRNNCells",t}(RNNCell);function generateDropoutMask(e,t,n,r){function i(){return dropout(e(),t)}if(void 0===n&&(n=null),void 0===r&&(r=1),r>1){for(var a=[],o=0;o<r;o++)a.push(inTrainPhase(i,e,n));return a.map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(e.clone())})}return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(inTrainPhase(i,e,n).clone())}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(StackedRNNCells);var Wrapper=function(e){function t(t){var n=e.call(this,t)||this;return n.layer=t.layer,n}return __extends(t,e),t.prototype.build=function(e){this.built=!0},Object.defineProperty(t.prototype,"trainable",{get:function(){return null!=this.layer&&this.layer.trainable},set:function(e){null!=this.layer&&(this.layer.trainable=e)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"trainableWeights",{get:function(){return this.layer.trainableWeights},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){return this.layer.nonTrainableWeights},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"updates",{get:function(){return this.layer._updates},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"losses",{get:function(){return this.layer.losses},enumerable:!0,configurable:!0}),t.prototype.getWeights=function(){return this.layer.getWeights()},t.prototype.setWeights=function(e){this.layer.setWeights(e)},t.prototype.getConfig=function(){var t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.prototype.setFastWeightInitDuringBuild=function(t){e.prototype.setFastWeightInitDuringBuild.call(this,t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)},t.fromConfig=function(e,t,n){void 0===n&&(n={});var r=deserialize(t.layer,n);delete t.layer;var i={layer:r};return Object.assign(i,t),new e(i)},t}(Layer),TimeDistributed=function(e){function t(t){var n=e.call(this,t)||this;return n.supportsMasking=!0,n}return __extends(t,e),t.prototype.build=function(t){if((t=getExactlyOneShape(t)).length<3)throw new ValueError("TimeDistributed layer expects an input shape >= 3D, but received input shape "+JSON.stringify(t));this.inputSpec=[{shape:t}];var n=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),e.prototype.build.call(this,t)},t.prototype.computeOutputShape=function(e){var t=[(e=getExactlyOneShape(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return rnn(function(e,r){return[getExactlyOneTensor(n.layer.call(e,t)),[]]},e=getExactlyOneTensor(e),[],!1,null,null,!1,!0)[1]})},t.className="TimeDistributed",t}(Wrapper);function checkBidirectionalMergeMode(e){checkStringTypeUnionValue(VALID_BIDIRECTIONAL_MERGE_MODES,"BidirectionalMergeMode",e)}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(TimeDistributed);var DEFAULT_BIDIRECTIONAL_MERGE_MODE="concat",Bidirectional=function(e){function t(t){var n=e.call(this,t)||this,r=t.layer.getConfig(),i={};i.className=t.layer.getClassName(),i.config=r,n.forwardLayer=deserialize(i),r.goBackwards=!0!==r.goBackwards;var a={};if(a.className=t.layer.getClassName(),a.config=r,n.backwardLayer=deserialize(a),n.forwardLayer.name="forward_"+n.forwardLayer.name,n.backwardLayer.name="backward_"+n.backwardLayer.name,n.mergeMode=void 0===t.mergeMode?DEFAULT_BIDIRECTIONAL_MERGE_MODE:t.mergeMode,checkBidirectionalMergeMode(n.mergeMode),t.weights)throw new NotImplementedError("weights support is not implemented for Bidirectional layer yet.");return n._stateful=t.layer.stateful,n.returnSequences=t.layer.returnSequences,n.returnState=t.layer.returnState,n.supportsMasking=!0,n._trainable=!0,n.inputSpec=t.layer.inputSpec,n.numConstants=null,n}return __extends(t,e),Object.defineProperty(t.prototype,"trainable",{get:function(){return this._trainable},set:function(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)},enumerable:!0,configurable:!0}),t.prototype.getWeights=function(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())},t.prototype.setWeights=function(e){var t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))},t.prototype.computeOutputShape=function(e){var t,n,r,i=this.forwardLayer.computeOutputShape(e);return Array.isArray(i)&&Array.isArray(i[0])||(i=[i]),i=i,this.returnState?(r=i.slice(1),t=i[0]):t=i[0],t=t,"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):singletonOrArray(n)},t.prototype.apply=function(t,n){var r=null==n?null:n.initialState,i=null==n?null:n.constants;null==n&&(n={});var a=standardizeArgs(t,r,i,this.numConstants);if(t=a.inputs,r=a.initialState,i=a.constants,Array.isArray(t)&&(r=t.slice(1),t=t[0]),(null==r||0===r.length)&&null==i)return e.prototype.apply.call(this,t,n);var o=[],s=[];if(null!=r){var l=r.length;if(l%2>0)throw new ValueError("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=r,o.push.apply(o,r);var u=r.map(function(e){return new InputSpec({shape:e.shape})});this.forwardLayer.stateSpec=u.slice(0,l/2),this.backwardLayer.stateSpec=u.slice(l/2),s.push.apply(s,u)}if(null!=i)throw new NotImplementedError("Support for constants in Bidirectional layers is not implemented yet.");for(var c=o[0]instanceof SymbolicTensor,p=0,h=o;p<h.length;p++){if(h[p]instanceof SymbolicTensor!==c)throw new ValueError("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors")}if(c){var d=[t].concat(o),f=this.inputSpec.concat(s),g=this.inputSpec;this.inputSpec=f;var m=e.prototype.apply.call(this,d,n);return this.inputSpec=g,m}return e.prototype.apply.call(this,t,n)},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null!=t.mask)throw new NotImplementedError("The support for masking is not implemented for Bidirectional layers yet.");var r,i,a,o,s=t.initialState;if(null==s)r=n.forwardLayer.call(e,t),i=n.backwardLayer.call(e,t);else{var l=s.slice(0,s.length/2),u=s.slice(s.length/2);r=n.forwardLayer.call(e,Object.assign(t,{initialState:l})),i=n.backwardLayer.call(e,Object.assign(t,{initialState:u}))}return n.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),n.returnSequences&&(i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse"])(i,1)),"concat"===n.mergeMode?o=concatenate([r,i]):"sum"===n.mergeMode?o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(r,i):"ave"===n.mergeMode?o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(.5,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(r,i)):"mul"===n.mergeMode?o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(r,i):null==n.mergeMode&&(o=[r,i]),n.returnState?null==n.mergeMode?o.concat(a):[o].concat(a):o})},t.prototype.resetStates=function(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()},t.prototype.build=function(e){var t=this;nameScope(this.forwardLayer.name,function(){t.forwardLayer.build(e)}),nameScope(this.backwardLayer.name,function(){t.backwardLayer.build(e)}),this.built=!0},Object.defineProperty(t.prototype,"trainableWeights",{get:function(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)},enumerable:!0,configurable:!0}),t.prototype.setFastWeightInitDuringBuild=function(t){e.prototype.setFastWeightInitDuringBuild.call(this,t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)},t.prototype.getConfig=function(){var t={mergeMode:this.mergeMode},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.fromConfig=function(e,t){var n=deserialize(t.layer);if(delete t.layer,null!=t.numConstants)throw new NotImplementedError("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");var r=t;return r.layer=n,new e(r)},t.className="Bidirectional",t}(Wrapper);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Bidirectional);var GaussianNoise=function(e){function t(t){var n=e.call(this,t)||this;return n.supportsMasking=!0,n.stddev=t.stddev,n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this),n={stddev:this.stddev};return Object.assign(n,t),n},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e);return inTrainPhase(function(){return randomNormal$1(r.shape,0,n.stddev).add(r)},function(){return r},t.training||!1)})},t.className="GaussianNoise",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GaussianNoise);var GaussianDropout=function(e){function t(t){var n=e.call(this,t)||this;return n.supportsMasking=!0,n.rate=t.rate,n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this),n={rate:this.rate};return Object.assign(n,t),n},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e);if(n.rate>0&&n.rate<1){return inTrainPhase(function(){var e=Math.sqrt(n.rate/(1-n.rate));return dot(r,randomNormal$1(r.shape,1,e))},function(){return r},t.training||!1)}return r})},t.className="GaussianDropout",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GaussianDropout);var AlphaDropout=function(e){function t(t){var n=e.call(this,t)||this;return n.supportsMasking=!0,n.rate=t.rate,n.noiseShape=t.noiseShape,n}return __extends(t,e),t.prototype._getNoiseShape=function(e){return this.noiseShape||getExactlyOneTensor(e).shape},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this),n={rate:this.rate};return Object.assign(n,t),n},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(n.rate<1&&n.rate>0){var r=n._getNoiseShape(e);return inTrainPhase(function(){var t=getExactlyOneTensor(e),i=-1.7580993408473766,a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greaterEqual"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"])(r),n.rate);a=cast$1(a,"float32");var o=Math.pow((1-n.rate)*(1+n.rate*Math.pow(i,2)),-.5),s=-o*i*n.rate;return dot(t,a).add(a.add(-1).mul(i)).mul(o).add(s)},function(){return getExactlyOneTensor(e)},t.training||!1)}return e})},t.className="AlphaDropout",t}(Layer);function inputLayer(e){return new InputLayer(e)}function elu$2(e){return new ELU(e)}function reLU(e){return new ReLU(e)}function leakyReLU(e){return new LeakyReLU(e)}function prelu$1(e){return new PReLU(e)}function softmax$1(e){return new Softmax$1(e)}function thresholdedReLU(e){return new ThresholdedReLU(e)}function conv1d$2(e){return new Conv1D(e)}function conv2d$2(e){return new Conv2D(e)}function conv2dTranspose$1(e){return new Conv2DTranspose(e)}function conv3d$2(e){return new Conv3D(e)}function separableConv2d$1(e){return new SeparableConv2D(e)}function cropping2D(e){return new Cropping2D(e)}function upSampling2d(e){return new UpSampling2D(e)}function depthwiseConv2d$2(e){return new DepthwiseConv2D(e)}function activation(e){return new Activation$1(e)}function dense(e){return new Dense(e)}function dropout$1(e){return new Dropout(e)}function flatten$1(e){return new Flatten(e)}function repeatVector(e){return new RepeatVector(e)}function reshape(e){return new Reshape(e)}function permute(e){return new Permute(e)}function embedding(e){return new Embedding(e)}function add$2(e){return new Add(e)}function average$1(e){return new Average(e)}function concatenate$2(e){return new Concatenate(e)}function maximum$2(e){return new Maximum(e)}function minimum$2(e){return new Minimum(e)}function multiply$1(e){return new Multiply(e)}function dot$1(e){return new Dot(e)}function batchNormalization$1(e){return new BatchNormalization(e)}function zeroPadding2d(e){return new ZeroPadding2D(e)}function averagePooling1d(e){return new AveragePooling1D(e)}function avgPool1d(e){return averagePooling1d(e)}function avgPooling1d(e){return averagePooling1d(e)}function averagePooling2d(e){return new AveragePooling2D(e)}function avgPool2d(e){return averagePooling2d(e)}function avgPooling2d(e){return averagePooling2d(e)}function globalAveragePooling1d(e){return new GlobalAveragePooling1D(e)}function globalAveragePooling2d(e){return new GlobalAveragePooling2D(e)}function globalMaxPooling1d(e){return new GlobalMaxPooling1D(e)}function globalMaxPooling2d(e){return new GlobalMaxPooling2D(e)}function maxPooling1d(e){return new MaxPooling1D(e)}function maxPooling2d(e){return new MaxPooling2D(e)}function gru(e){return new GRU(e)}function gruCell(e){return new GRUCell(e)}function lstm(e){return new LSTM(e)}function lstmCell(e){return new LSTMCell(e)}function simpleRNN(e){return new SimpleRNN(e)}function simpleRNNCell(e){return new SimpleRNNCell(e)}function rnn$1(e){return new RNN(e)}function stackedRNNCells(e){return new StackedRNNCells(e)}function bidirectional(e){return new Bidirectional(e)}function timeDistributed(e){return new TimeDistributed(e)}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(AlphaDropout);var globalMaxPool1d=globalMaxPooling1d,globalMaxPool2d=globalMaxPooling2d,maxPool1d=maxPooling1d,maxPool2d=maxPooling2d;function gaussianNoise(e){return new GaussianNoise(e)}function gaussianDropout(e){return new GaussianDropout(e)}function alphaDropout(e){return new AlphaDropout(e)}function masking(e){return new Masking(e)}var exports_layers=Object.freeze({inputLayer:inputLayer,elu:elu$2,reLU:reLU,leakyReLU:leakyReLU,prelu:prelu$1,softmax:softmax$1,thresholdedReLU:thresholdedReLU,conv1d:conv1d$2,conv2d:conv2d$2,conv2dTranspose:conv2dTranspose$1,conv3d:conv3d$2,separableConv2d:separableConv2d$1,cropping2D:cropping2D,upSampling2d:upSampling2d,depthwiseConv2d:depthwiseConv2d$2,activation:activation,dense:dense,dropout:dropout$1,flatten:flatten$1,repeatVector:repeatVector,reshape:reshape,permute:permute,embedding:embedding,add:add$2,average:average$1,concatenate:concatenate$2,maximum:maximum$2,minimum:minimum$2,multiply:multiply$1,dot:dot$1,batchNormalization:batchNormalization$1,zeroPadding2d:zeroPadding2d,averagePooling1d:averagePooling1d,avgPool1d:avgPool1d,avgPooling1d:avgPooling1d,averagePooling2d:averagePooling2d,avgPool2d:avgPool2d,avgPooling2d:avgPooling2d,globalAveragePooling1d:globalAveragePooling1d,globalAveragePooling2d:globalAveragePooling2d,globalMaxPooling1d:globalMaxPooling1d,globalMaxPooling2d:globalMaxPooling2d,maxPooling1d:maxPooling1d,maxPooling2d:maxPooling2d,gru:gru,gruCell:gruCell,lstm:lstm,lstmCell:lstmCell,simpleRNN:simpleRNN,simpleRNNCell:simpleRNNCell,rnn:rnn$1,stackedRNNCells:stackedRNNCells,bidirectional:bidirectional,timeDistributed:timeDistributed,globalMaxPool1d:globalMaxPool1d,globalMaxPool2d:globalMaxPool2d,maxPool1d:maxPool1d,maxPool2d:maxPool2d,Layer:Layer,RNN:RNN,RNNCell:RNNCell,input:input,gaussianNoise:gaussianNoise,gaussianDropout:gaussianDropout,alphaDropout:alphaDropout,masking:masking});function binaryAccuracy$1(e,t){return binaryAccuracy(e,t)}function binaryCrossentropy$2(e,t){return binaryCrossentropy$1(e,t)}function sparseCategoricalAccuracy$1(e,t){return sparseCategoricalAccuracy(e,t)}function categoricalAccuracy$1(e,t){return categoricalAccuracy(e,t)}function categoricalCrossentropy$2(e,t){return categoricalCrossentropy$1(e,t)}function precision$1(e,t){return precision(e,t)}function recall$1(e,t){return recall(e,t)}function cosineProximity$1(e,t){return cosineProximity(e,t)}function meanAbsoluteError$1(e,t){return meanAbsoluteError(e,t)}function meanAbsolutePercentageError$1(e,t){return meanAbsolutePercentageError(e,t)}function MAPE$2(e,t){return meanAbsolutePercentageError(e,t)}function mape$2(e,t){return meanAbsolutePercentageError(e,t)}function meanSquaredError$1(e,t){return meanSquaredError(e,t)}function MSE$2(e,t){return meanSquaredError(e,t)}function mse$2(e,t){return meanSquaredError(e,t)}var exports_metrics=Object.freeze({binaryAccuracy:binaryAccuracy$1,binaryCrossentropy:binaryCrossentropy$2,sparseCategoricalAccuracy:sparseCategoricalAccuracy$1,categoricalAccuracy:categoricalAccuracy$1,categoricalCrossentropy:categoricalCrossentropy$2,precision:precision$1,recall:recall$1,cosineProximity:cosineProximity$1,meanAbsoluteError:meanAbsoluteError$1,meanAbsolutePercentageError:meanAbsolutePercentageError$1,MAPE:MAPE$2,mape:mape$2,meanSquaredError:meanSquaredError$1,MSE:MSE$2,mse:mse$2}),exports_models=Object.freeze({modelFromJSON:modelFromJSON});function l1l2(e){return new L1L2(e)}function l1$1(e){return l1(e)}function l2$1(e){return l2(e)}var exports_regularizers=Object.freeze({l1l2:l1l2,l1:l1$1,l2:l2$1}),Callback=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.model=null,t}return __extends(t,e),t.prototype.setModel=function(e){if(!(e instanceof LayersModel))throw new Error("model must be a LayersModel, not some other Container");this.model=e},t}(BaseCallback);function less(e,t){return e<t}function greater$1(e,t){return e>t}var EarlyStopping=function(e){function t(t){var n=e.call(this)||this;if(null==t&&(t={}),t.restoreBestWeights)throw new NotImplementedError("restoreBestWeights = True is not implemented in EarlyStopping yet.");return n.monitor=t.monitor||"val_loss",n.minDelta=Math.abs(t.minDelta||0),n.patience=t.patience||0,n.verbose=t.verbose||0,n.mode=t.mode||"auto",n.baseline=t.baseline,-1===["auto","min","max"].indexOf(n.mode)&&(console.warn("EarlyStopping mode '"+n.mode+"' is invalid. Falling back to mode 'auto'."),n.mode="auto"),"min"===n.mode?n.monitorFunc=less:"max"===n.mode?n.monitorFunc=greater$1:-1!==n.monitor.indexOf("acc")?n.monitorFunc=greater$1:n.monitorFunc=less,n.monitorFunc===less&&(n.minDelta*=-1),n}return __extends(t,e),t.prototype.onTrainBegin=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===less?1/0:-1/0,[2]})})},t.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(r){switch(r.label){case 0:return[4,resolveScalarsInLogs(t)];case 1:return r.sent(),null==(n=this.getMonitorValue(t))?[2]:(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)),[2])}})})},t.prototype.onTrainEnd=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return this.stoppedEpoch>0&&this.verbose&&console.log("Epoch "+this.stoppedEpoch+": early stopping."),[2]})})},t.prototype.getMonitorValue=function(e){null==e&&(e={});var t=e[this.monitor];return null==t&&console.warn("Metric for EarlyStopping "+this.monitor+" is not available. Available metrics are: "+Object.keys(e)),t},t}(Callback);function earlyStopping(e){return new EarlyStopping(e)}var callbacks={earlyStopping:earlyStopping};
//# sourceMappingURL=tf-layers.esm.js.map


/***/ }),

/***/ "./node_modules/@tensorflow/tfjs/dist/tf.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs/dist/tf.esm.js ***!
  \******************************************************/
/*! exports provided: data, version, AdadeltaOptimizer, AdagradOptimizer, AdamOptimizer, AdamaxOptimizer, DataStorage, ENV, Environment, KernelBackend, MomentumOptimizer, Optimizer, RMSPropOptimizer, Rank, Reduction, SGDOptimizer, Tensor, TensorBuffer, Variable, abs, acos, acosh, add, addN, addStrict, all, any, argMax, argMin, asin, asinh, atan, atan2, atanh, avgPool, backend, basicLSTMCell, batchNorm, batchNorm2d, batchNorm3d, batchNorm4d, batchNormalization, batchNormalization2d, batchNormalization3d, batchNormalization4d, batchToSpaceND, browser, buffer, cast, ceil, clipByValue, clone, complex, concat, concat1d, concat2d, concat3d, concat4d, conv1d, conv2d, conv2dDerFilter, conv2dTranspose, conv3d, cos, cosh, cumsum, customGrad, deprecationWarn, depthToSpace, depthwiseConv2d, disableDeprecationWarnings, dispose, disposeVariables, div, divStrict, dot, dropout, elu, enableDebugMode, enableProdMode, environment, equal, equalStrict, erf, exp, expandDims, expm1, eye, fft, fill, findBackend, findBackendFactory, floor, floorDiv, fused, gather, gatherND, getBackend, grad, grads, greater, greaterEqual, greaterEqualStrict, greaterStrict, hammingWindow, hannWindow, ifft, imag, image, io, irfft, isFinite, isInf, isNaN, keep, leakyRelu, less, lessEqual, lessEqualStrict, lessStrict, linalg, linspace, localResponseNormalization, log, log1p, logSigmoid, logSoftmax, logSumExp, logicalAnd, logicalNot, logicalOr, logicalXor, losses, matMul, math, max, maxPool, maximum, maximumStrict, mean, memory, min, minimum, minimumStrict, mod, modStrict, moments, movingAverage, mul, mulStrict, multiRNNCell, multinomial, neg, nextFrame, norm, notEqual, notEqualStrict, oneHot, ones, onesLike, op, outerProduct, pad, pad1d, pad2d, pad3d, pad4d, pool, pow, powStrict, prelu, print, prod, profile, rand, randomNormal, randomUniform, range, ready, real, reciprocal, registerBackend, relu, removeBackend, reshape, reverse, reverse1d, reverse2d, reverse3d, reverse4d, rfft, round, rsqrt, scalar, scatterND, selu, separableConv2d, serialization, setBackend, setdiff1dAsync, sigmoid, sign, sin, sinh, slice, slice1d, slice2d, slice3d, slice4d, softmax, softplus, spaceToBatchND, sparseToDense, spectral, split, sqrt, square, squaredDifference, squaredDifferenceStrict, squeeze, stack, step, stridedSlice, sub, subStrict, sum, tan, tanh, tensor, tensor1d, tensor2d, tensor3d, tensor4d, tensor5d, tensor6d, tensor_util, test_util, tidy, tile, time, topk, train, transpose, truncatedNormal, unsortedSegmentSum, unstack, util, valueAndGrad, valueAndGrads, variable, variableGrads, version_core, webgl, where, whereAsync, zeros, zerosLike, constraints, initializers, layers, metrics, models, regularizers, CallbackList, CustomCallback, History, Callback, callbacks, EarlyStopping, InputSpec, SymbolicTensor, LayersModel, input, loadLayersModel, model, registerCallbackConstructor, sequential, RNN, Sequential, LayerVariable, version_layers, GraphModel, loadGraphModel, version_converter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version$1; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AdadeltaOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["AdadeltaOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AdagradOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["AdagradOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AdamOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["AdamOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AdamaxOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["AdamaxOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataStorage", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["DataStorage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ENV", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Environment", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Environment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KernelBackend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["KernelBackend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MomentumOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["MomentumOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Optimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Optimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RMSPropOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["RMSPropOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Rank", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Rank"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Reduction", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Reduction"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SGDOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["SGDOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tensor", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TensorBuffer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["TensorBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Variable", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Variable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "abs", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["acos"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "acosh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["acosh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "add", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addN", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["addN"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["addStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "all", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["all"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "any", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["any"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "argMax", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMax"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "argMin", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["asin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "asinh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["asinh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atan"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "atan2", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atan2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "atanh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atanh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "avgPool", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["avgPool"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "backend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["backend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "basicLSTMCell", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["basicLSTMCell"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNorm", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNorm2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNorm3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNorm4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNormalization", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNormalization"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNormalization2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNormalization2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNormalization3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNormalization3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNormalization4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNormalization4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchToSpaceND", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchToSpaceND"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "browser", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["browser"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["buffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cast", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cast"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ceil"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clipByValue", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clone"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "complex", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["complex"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "conv1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "conv2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "conv2dDerFilter", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2dDerFilter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "conv2dTranspose", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2dTranspose"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "conv3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cos"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cosh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cosh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cumsum", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cumsum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "customGrad", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["customGrad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "deprecationWarn", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["deprecationWarn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "depthToSpace", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthToSpace"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "depthwiseConv2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthwiseConv2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "disableDeprecationWarnings", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["disableDeprecationWarnings"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dispose", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "disposeVariables", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["disposeVariables"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "div", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "divStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["divStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dot"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dropout", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dropout"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "elu", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["elu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "enableDebugMode", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["enableDebugMode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "enableProdMode", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["enableProdMode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "environment", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["environment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "equal", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "equalStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equalStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "erf", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["erf"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["exp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "expandDims", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "expm1", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expm1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "eye", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["eye"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fft", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fft"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fill", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fill"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findBackend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["findBackend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findBackendFactory", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["findBackendFactory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["floor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "floorDiv", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["floorDiv"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fused", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fused"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gather", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["gather"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gatherND", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["gatherND"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getBackend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["getBackend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "grad", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["grad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "grads", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["grads"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "greater", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greater"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "greaterEqual", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greaterEqual"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "greaterEqualStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greaterEqualStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "greaterStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greaterStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hammingWindow", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["hammingWindow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hannWindow", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["hannWindow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ifft", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ifft"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "imag", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["imag"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "image", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "io", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "irfft", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["irfft"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isFinite", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["isFinite"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isInf", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["isInf"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNaN", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["isNaN"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keep", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "leakyRelu", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["leakyRelu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "less", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["less"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lessEqual", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["lessEqual"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lessEqualStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["lessEqualStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lessStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["lessStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "linalg", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["linalg"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "linspace", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["linspace"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "localResponseNormalization", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["localResponseNormalization"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "log", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "log1p", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log1p"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logSigmoid", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logSigmoid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logSoftmax", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logSoftmax"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logSumExp", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logSumExp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logicalAnd", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logicalNot", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalNot"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logicalOr", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalOr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logicalXor", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalXor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "losses", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["losses"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matMul", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["matMul"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "math", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["math"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "max", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "maxPool", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maxPool"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "maximum", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "maximumStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximumStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mean", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "memory", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["memory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "min", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["min"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "minimum", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["minimum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "minimumStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["minimumStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mod", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mod"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "modStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["modStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "moments", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["moments"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "movingAverage", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["movingAverage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mulStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mulStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "multiRNNCell", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["multiRNNCell"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "multinomial", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["multinomial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "neg", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nextFrame", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["nextFrame"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "norm", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["norm"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "notEqual", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["notEqual"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "notEqualStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["notEqualStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "oneHot", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["oneHot"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ones", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ones"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onesLike", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "op", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["op"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "outerProduct", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["outerProduct"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pad", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pad1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pad2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pad3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pad4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pool", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pool"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "powStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["powStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "prelu", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["prelu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "print", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["print"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "prod", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["prod"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "profile", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["profile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rand", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["rand"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomNormal", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomNormal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomUniform", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "range", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["range"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ready", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ready"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "real", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["real"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reciprocal", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reciprocal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerBackend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["registerBackend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "relu", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "removeBackend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["removeBackend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reshape", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rfft", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["rfft"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "round", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["round"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rsqrt", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["rsqrt"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scalar", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scatterND", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scatterND"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selu", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["selu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "separableConv2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["separableConv2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "serialization", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setBackend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["setBackend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setdiff1dAsync", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["setdiff1dAsync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sigmoid", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sigmoid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sign", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sign"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sinh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sinh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "softmax", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "softplus", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softplus"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "spaceToBatchND", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["spaceToBatchND"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sparseToDense", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sparseToDense"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "spectral", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["spectral"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "split", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sqrt"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "square", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["square"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "squaredDifference", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squaredDifference"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "squaredDifferenceStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squaredDifferenceStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "squeeze", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squeeze"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stack", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "step", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["step"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stridedSlice", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stridedSlice"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "subStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["subStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tan"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tanh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tanh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor5d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor5d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor6d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor6d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor_util", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "test_util", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["test_util"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tidy", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tile", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "time", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["time"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "topk", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["topk"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "train", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "truncatedNormal", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["truncatedNormal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unsortedSegmentSum", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unsortedSegmentSum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstack", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "util", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "valueAndGrad", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["valueAndGrad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "valueAndGrads", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["valueAndGrads"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "variable", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["variable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "variableGrads", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["variableGrads"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version_core", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["version_core"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "webgl", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["webgl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "where", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["where"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "whereAsync", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["whereAsync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zeros", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zerosLike", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zerosLike"]; });

/* harmony import */ var _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-layers */ "./node_modules/@tensorflow/tfjs-layers/dist/tf-layers.esm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "constraints", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["constraints"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "initializers", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["initializers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "layers", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["layers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "metrics", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["metrics"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "models", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["models"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "regularizers", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["regularizers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CallbackList", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["CallbackList"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CustomCallback", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["CustomCallback"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "History", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["History"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Callback", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["Callback"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "callbacks", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["callbacks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EarlyStopping", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["EarlyStopping"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InputSpec", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["InputSpec"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SymbolicTensor", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["SymbolicTensor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayersModel", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["LayersModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "input", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["input"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadLayersModel", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["loadLayersModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "model", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["model"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerCallbackConstructor", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["registerCallbackConstructor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sequential", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["sequential"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RNN", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["RNN"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Sequential", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["Sequential"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayerVariable", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["LayerVariable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version_layers", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["version_layers"]; });

/* harmony import */ var _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tensorflow/tfjs-converter */ "./node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GraphModel", function() { return _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_2__["GraphModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadGraphModel", function() { return _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_2__["loadGraphModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version_converter", function() { return _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_2__["version_converter"]; });

/* harmony import */ var _tensorflow_tfjs_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tensorflow/tfjs-data */ "./node_modules/@tensorflow/tfjs-data/dist/tf-data.esm.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "data", function() { return _tensorflow_tfjs_data__WEBPACK_IMPORTED_MODULE_3__; });
// @tensorflow/tfjs Copyright 2019 Google
var version="1.1.2",version$1={"tfjs-core":_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["version_core"],"tfjs-data":_tensorflow_tfjs_data__WEBPACK_IMPORTED_MODULE_3__["version_data"],"tfjs-layers":_tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["version_layers"],"tfjs-converter":_tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_2__["version_converter"],tfjs:version};
//# sourceMappingURL=tf.esm.js.map


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1.js":
/*!******************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = exports;

asn1.bignum = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");

asn1.define = __webpack_require__(/*! ./asn1/api */ "./node_modules/asn1.js/lib/asn1/api.js").define;
asn1.base = __webpack_require__(/*! ./asn1/base */ "./node_modules/asn1.js/lib/asn1/base/index.js");
asn1.constants = __webpack_require__(/*! ./asn1/constants */ "./node_modules/asn1.js/lib/asn1/constants/index.js");
asn1.decoders = __webpack_require__(/*! ./asn1/decoders */ "./node_modules/asn1.js/lib/asn1/decoders/index.js");
asn1.encoders = __webpack_require__(/*! ./asn1/encoders */ "./node_modules/asn1.js/lib/asn1/encoders/index.js");


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/api.js":
/*!**********************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/api.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = __webpack_require__(/*! ../asn1 */ "./node_modules/asn1.js/lib/asn1.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
};

Entity.prototype._createNamed = function createNamed(base) {
  var named;
  try {
    named = __webpack_require__(/*! vm */ "./node_modules/vm-browserify/index.js").runInThisContext(
      '(function ' + this.name + '(entity) {\n' +
      '  this._initNamed(entity);\n' +
      '})'
    );
  } catch (e) {
    named = function (entity) {
      this._initNamed(entity);
    };
  }
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der';
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der';
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Reporter = __webpack_require__(/*! ../base */ "./node_modules/asn1.js/lib/asn1/base/index.js").Reporter;
var Buffer = __webpack_require__(/*! buffer */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  var res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
}

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  var res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
}

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
}

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!(item instanceof EncoderBuffer))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = new Buffer(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var base = exports;

base.Reporter = __webpack_require__(/*! ./reporter */ "./node_modules/asn1.js/lib/asn1/base/reporter.js").Reporter;
base.DecoderBuffer = __webpack_require__(/*! ./buffer */ "./node_modules/asn1.js/lib/asn1/base/buffer.js").DecoderBuffer;
base.EncoderBuffer = __webpack_require__(/*! ./buffer */ "./node_modules/asn1.js/lib/asn1/base/buffer.js").EncoderBuffer;
base.Node = __webpack_require__(/*! ./node */ "./node_modules/asn1.js/lib/asn1/base/node.js");


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/node.js":
/*!****************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/node.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Reporter = __webpack_require__(/*! ../base */ "./node_modules/asn1.js/lib/asn1/base/index.js").Reporter;
var EncoderBuffer = __webpack_require__(/*! ../base */ "./node_modules/asn1.js/lib/asn1/base/index.js").EncoderBuffer;
var DecoderBuffer = __webpack_require__(/*! ../base */ "./node_modules/asn1.js/lib/asn1/base/index.js").DecoderBuffer;
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any', 'contains'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit', 'contains'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  var state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  var state = this._baseState;

  assert(state.use === null);
  state.contains = item;

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input, options) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input, options));

  var result = state['default'];
  var present = true;

  var prevKey = null;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    var start = input.offset;

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        var save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    if (options && options.track && state.tag !== null)
      options.track(input.path(), start, input.length, 'tagged');

    if (options && options.track && state.tag !== null)
      options.track(input.path(), input.offset, input.length, 'content');

    // Select proper method for tag
    if (state.any)
      result = result;
    else if (state.choice === null)
      result = this._decodeGeneric(state.tag, input, options);
    else
      result = this._decodeChoice(input, options);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    }

    // Decode contained/encoded by schema, only in bit or octet strings
    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      var data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)
          ._decode(data, options);
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null, options);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag, options);
  else if (tag === 'null_')
    return this._decodeNull(input, options);
  else if (tag === 'bool')
    return this._decodeBool(input, options);
  else if (tag === 'objDesc')
    return this._decodeStr(input, tag, options);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)
        ._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input, options);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be omitted only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  if (!node) {
    assert(
        false,
        data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else if (tag === 'objDesc')
    return this._encodeStr(data, tag);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
};


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/reporter.js":
/*!********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/reporter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  var state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.exitKey = function exitKey(index) {
  var state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;

  this.exitKey(index);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;

  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;

  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;

  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
};
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ReporterError);

  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/constants/der.js":
/*!********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/constants/der.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var constants = __webpack_require__(/*! ../constants */ "./node_modules/asn1.js/lib/asn1/constants/index.js");

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/constants/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/constants/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    var value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = __webpack_require__(/*! ./der */ "./node_modules/asn1.js/lib/asn1/constants/der.js");


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/decoders/der.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/decoders/der.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var asn1 = __webpack_require__(/*! ../../asn1 */ "./node_modules/asn1.js/lib/asn1.js");
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer))
    data = new base.DecoderBuffer(data, options);

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
    (decodedTag.tagStr + 'of') === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.save();
  var res = this._skipUntilEnd(
      buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    var res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len)
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
                                                    options) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    var res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;
    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'bmpstr') {
    var raw = buffer.raw();
    if (raw.length % 2 === 1)
      return buffer.error('Decoding of string type: bmpstr length mismatch');

    var str = '';
    for (var i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag === 'numstr') {
    var numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' +
                          'numstr unsupported characters');
    }
    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    var printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' +
                          'printstr unsupported characters');
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var result;
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  var first = (identifiers[0] / 40) | 0;
  var second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values) {
    var tmp = values[result.join(' ')];
    if (tmp === undefined)
      tmp = values[result.join('.')];
    if (tmp !== undefined)
      result = tmp;
  }

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num > 4)
    return buf.error('length octect is too long');

  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/decoders/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/decoders/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var decoders = exports;

decoders.der = __webpack_require__(/*! ./der */ "./node_modules/asn1.js/lib/asn1/decoders/der.js");
decoders.pem = __webpack_require__(/*! ./pem */ "./node_modules/asn1.js/lib/asn1/decoders/pem.js");


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/decoders/pem.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/decoders/pem.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Buffer = __webpack_require__(/*! buffer */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer;

var DERDecoder = __webpack_require__(/*! ./der */ "./node_modules/asn1.js/lib/asn1/decoders/der.js");

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);

  var label = options.label.toUpperCase();

  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end = -1;
  for (var i = 0; i < lines.length; i++) {
    var match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  var base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

  var input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/encoders/der.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/encoders/der.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Buffer = __webpack_require__(/*! buffer */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer;

var asn1 = __webpack_require__(/*! ../../asn1 */ "./node_modules/asn1.js/lib/asn1.js");
var base = asn1.base;

// Import DER constants
var der = asn1.constants.der;

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                              primitive,
                                                              cls,
                                                              content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  var lenOctets = 1;
  for (var i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (tag === 'bmpstr') {
    var buf = new Buffer(str.length * 2);
    for (var i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    }
    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s\.]+/g);
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  var size = 0;
  for (var i = 0; i < id.length; i++) {
    var ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  var objid = new Buffer(size);
  var offset = objid.length - 1;
  for (var i = id.length - 1; i >= 0; i--) {
    var ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    var numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = new Buffer(numArray);
  }

  if (Buffer.isBuffer(num)) {
    var size = num.length;
    if (num.length === 0)
      size++;

    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  var size = 1;
  for (var i = num; i >= 0x100; i >>= 8)
    size++;

  var out = new Array(size);
  for (var i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(new Buffer(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  var state = this._baseState;
  var i;
  if (state['default'] === null)
    return false;

  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  var res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/encoders/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/encoders/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var encoders = exports;

encoders.der = __webpack_require__(/*! ./der */ "./node_modules/asn1.js/lib/asn1/encoders/der.js");
encoders.pem = __webpack_require__(/*! ./pem */ "./node_modules/asn1.js/lib/asn1/encoders/pem.js");


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/encoders/pem.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/encoders/pem.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var DEREncoder = __webpack_require__(/*! ./der */ "./node_modules/asn1.js/lib/asn1/encoders/der.js");

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);

  var p = buf.toString('base64');
  var out = [ '-----BEGIN ' + options.label + '-----' ];
  for (var i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/bn.js/lib/bn.js":
/*!**************************************!*\
  !*** ./node_modules/bn.js/lib/bn.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = __webpack_require__(/*! buffer */ 3).Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      r.strip();
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/brorand/index.js":
/*!***************************************!*\
  !*** ./node_modules/brorand/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = __webpack_require__(/*! crypto */ 4);
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}


/***/ }),

/***/ "./node_modules/browserify-aes/aes.js":
/*!********************************************!*\
  !*** ./node_modules/browserify-aes/aes.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

function asUInt32Array (buf) {
  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)

  var len = (buf.length / 4) | 0
  var out = new Array(len)

  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4)
  }

  return out
}

function scrubVec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
}

function cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0]
  var SUB_MIX1 = SUB_MIX[1]
  var SUB_MIX2 = SUB_MIX[2]
  var SUB_MIX3 = SUB_MIX[3]

  var s0 = M[0] ^ keySchedule[0]
  var s1 = M[1] ^ keySchedule[1]
  var s2 = M[2] ^ keySchedule[2]
  var s3 = M[3] ^ keySchedule[3]
  var t0, t1, t2, t3
  var ksRow = 4

  for (var round = 1; round < nRounds; round++) {
    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }

  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  t0 = t0 >>> 0
  t1 = t1 >>> 0
  t2 = t2 >>> 0
  t3 = t3 >>> 0

  return [t0, t1, t2, t3]
}

// AES constants
var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
var G = (function () {
  // Compute double table
  var d = new Array(256)
  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1
    } else {
      d[j] = (j << 1) ^ 0x11b
    }
  }

  var SBOX = []
  var INV_SBOX = []
  var SUB_MIX = [[], [], [], []]
  var INV_SUB_MIX = [[], [], [], []]

  // Walk GF(2^8)
  var x = 0
  var xi = 0
  for (var i = 0; i < 256; ++i) {
    // Compute sbox
    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    SBOX[x] = sx
    INV_SBOX[sx] = x

    // Compute multiplication
    var x2 = d[x]
    var x4 = d[x2]
    var x8 = d[x4]

    // Compute sub bytes, mix columns tables
    var t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    SUB_MIX[3][x] = t

    // Compute inv sub bytes, inv mix columns tables
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    INV_SUB_MIX[3][sx] = t

    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }

  return {
    SBOX: SBOX,
    INV_SBOX: INV_SBOX,
    SUB_MIX: SUB_MIX,
    INV_SUB_MIX: INV_SUB_MIX
  }
})()

function AES (key) {
  this._key = asUInt32Array(key)
  this._reset()
}

AES.blockSize = 4 * 4
AES.keySize = 256 / 8
AES.prototype.blockSize = AES.blockSize
AES.prototype.keySize = AES.keySize
AES.prototype._reset = function () {
  var keyWords = this._key
  var keySize = keyWords.length
  var nRounds = keySize + 6
  var ksRows = (nRounds + 1) * 4

  var keySchedule = []
  for (var k = 0; k < keySize; k++) {
    keySchedule[k] = keyWords[k]
  }

  for (k = keySize; k < ksRows; k++) {
    var t = keySchedule[k - 1]

    if (k % keySize === 0) {
      t = (t << 8) | (t >>> 24)
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])

      t ^= RCON[(k / keySize) | 0] << 24
    } else if (keySize > 6 && k % keySize === 4) {
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])
    }

    keySchedule[k] = keySchedule[k - keySize] ^ t
  }

  var invKeySchedule = []
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)]

    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt
    } else {
      invKeySchedule[ik] =
        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^
        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^
        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]]
    }
  }

  this._nRounds = nRounds
  this._keySchedule = keySchedule
  this._invKeySchedule = invKeySchedule
}

AES.prototype.encryptBlockRaw = function (M) {
  M = asUInt32Array(M)
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)
}

AES.prototype.encryptBlock = function (M) {
  var out = this.encryptBlockRaw(M)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = asUInt32Array(M)

  // swap
  var m1 = M[1]
  M[1] = M[3]
  M[3] = m1

  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrubVec(this._keySchedule)
  scrubVec(this._invKeySchedule)
  scrubVec(this._key)
}

module.exports.AES = AES


/***/ }),

/***/ "./node_modules/browserify-aes/authCipher.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-aes/authCipher.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aes = __webpack_require__(/*! ./aes */ "./node_modules/browserify-aes/aes.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var Transform = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var GHASH = __webpack_require__(/*! ./ghash */ "./node_modules/browserify-aes/ghash.js")
var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/buffer-xor/index.js")
var incr32 = __webpack_require__(/*! ./incr32 */ "./node_modules/browserify-aes/incr32.js")

function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) out++

  var len = Math.min(a.length, b.length)
  for (var i = 0; i < len; ++i) {
    out += (a[i] ^ b[i])
  }

  return out
}

function calcIv (self, iv, ck) {
  if (iv.length === 12) {
    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])])
    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])])
  }
  var ghash = new GHASH(ck)
  var len = iv.length
  var toPad = len % 16
  ghash.update(iv)
  if (toPad) {
    toPad = 16 - toPad
    ghash.update(Buffer.alloc(toPad, 0))
  }
  ghash.update(Buffer.alloc(8, 0))
  var ivBits = len * 8
  var tail = Buffer.alloc(8)
  tail.writeUIntBE(ivBits, 0, 8)
  ghash.update(tail)
  self._finID = ghash.state
  var out = Buffer.from(self._finID)
  incr32(out)
  return out
}
function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  var h = Buffer.alloc(4, 0)

  this._cipher = new aes.AES(key)
  var ck = this._cipher.encryptBlock(h)
  this._ghash = new GHASH(ck)
  iv = calcIv(this, iv, ck)

  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  this._mode = mode

  this._authTag = null
  this._called = false
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = Buffer.alloc(rump, 0)
      this._ghash.update(rump)
    }
  }

  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}

StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')

  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')

  this._authTag = tag
  this._cipher.scrub()
}

StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')

  return this._authTag
}

StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')

  this._authTag = tag
}

StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (this._called) throw new Error('Attempting to set AAD in unsupported state')

  this._ghash.update(buf)
  this._alen += buf.length
}

module.exports = StreamCipher


/***/ }),

/***/ "./node_modules/browserify-aes/browser.js":
/*!************************************************!*\
  !*** ./node_modules/browserify-aes/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ciphers = __webpack_require__(/*! ./encrypter */ "./node_modules/browserify-aes/encrypter.js")
var deciphers = __webpack_require__(/*! ./decrypter */ "./node_modules/browserify-aes/decrypter.js")
var modes = __webpack_require__(/*! ./modes/list.json */ "./node_modules/browserify-aes/modes/list.json")

function getCiphers () {
  return Object.keys(modes)
}

exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),

/***/ "./node_modules/browserify-aes/decrypter.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/decrypter.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var AuthCipher = __webpack_require__(/*! ./authCipher */ "./node_modules/browserify-aes/authCipher.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var MODES = __webpack_require__(/*! ./modes */ "./node_modules/browserify-aes/modes/index.js")
var StreamCipher = __webpack_require__(/*! ./streamCipher */ "./node_modules/browserify-aes/streamCipher.js")
var Transform = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var aes = __webpack_require__(/*! ./aes */ "./node_modules/browserify-aes/aes.js")
var ebtk = __webpack_require__(/*! evp_bytestokey */ "./node_modules/evp_bytestokey/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")

function Decipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Decipher, Transform)

Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}

Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}

Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }

  return null
}

Splitter.prototype.flush = function () {
  if (this.cache.length) return this.cache
}

function unpad (last) {
  var padded = last[15]
  if (padded < 1 || padded > 16) {
    throw new Error('unable to decrypt data')
  }
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) return

  return last.slice(0, 16 - padded)
}

function createDecipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv, true)
  }

  return new Decipher(config.module, password, iv)
}

function createDecipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}

exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv


/***/ }),

/***/ "./node_modules/browserify-aes/encrypter.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/encrypter.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MODES = __webpack_require__(/*! ./modes */ "./node_modules/browserify-aes/modes/index.js")
var AuthCipher = __webpack_require__(/*! ./authCipher */ "./node_modules/browserify-aes/authCipher.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var StreamCipher = __webpack_require__(/*! ./streamCipher */ "./node_modules/browserify-aes/streamCipher.js")
var Transform = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var aes = __webpack_require__(/*! ./aes */ "./node_modules/browserify-aes/aes.js")
var ebtk = __webpack_require__(/*! evp_bytestokey */ "./node_modules/evp_bytestokey/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")

function Cipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Cipher, Transform)

Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []

  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }

  return Buffer.concat(out)
}

var PADDING = Buffer.alloc(16, 0x10)

Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  }

  if (!chunk.equals(PADDING)) {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}

Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}

Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = Buffer.allocUnsafe(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }

  return Buffer.concat([this.cache, padBuff])
}

function createCipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv)
  }

  return new Cipher(config.module, password, iv)
}

function createCipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher


/***/ }),

/***/ "./node_modules/browserify-aes/ghash.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-aes/ghash.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var ZEROES = Buffer.alloc(16, 0)

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}

function fromArray (out) {
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0] >>> 0, 0)
  buf.writeUInt32BE(out[1] >>> 0, 4)
  buf.writeUInt32BE(out[2] >>> 0, 8)
  buf.writeUInt32BE(out[3] >>> 0, 12)
  return buf
}

function GHASH (key) {
  this.h = key
  this.state = Buffer.alloc(16, 0)
  this.cache = Buffer.allocUnsafe(0)
}

// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vähä-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsbVi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi[0] ^= Vi[0]
      Zi[1] ^= Vi[1]
      Zi[2] ^= Vi[2]
      Zi[3] ^= Vi[3]
    }

    // Store the value of LSB(V_i)
    lsbVi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsbVi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}

GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}

GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, ZEROES], 16))
  }

  this.ghash(fromArray([0, abl, 0, bl]))
  return this.state
}

module.exports = GHASH


/***/ }),

/***/ "./node_modules/browserify-aes/incr32.js":
/*!***********************************************!*\
  !*** ./node_modules/browserify-aes/incr32.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}
module.exports = incr32


/***/ }),

/***/ "./node_modules/browserify-aes/modes/cbc.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cbc.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/buffer-xor/index.js")

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/cfb.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cfb.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/buffer-xor/index.js")

function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

exports.encrypt = function (self, data, decrypt) {
  var out = Buffer.allocUnsafe(0)
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = Buffer.allocUnsafe(0)
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/cfb1.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cfb1.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}

function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = Buffer.allocUnsafe(buffer.length)
  buffer = Buffer.concat([buffer, Buffer.from([value])])

  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/cfb8.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cfb8.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam

  self._prev = Buffer.concat([
    self._prev.slice(1),
    Buffer.from([decrypt ? byteParam : out])
  ])

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/ctr.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/ctr.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/buffer-xor/index.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var incr32 = __webpack_require__(/*! ../incr32 */ "./node_modules/browserify-aes/incr32.js")

function getBlock (self) {
  var out = self._cipher.encryptBlockRaw(self._prev)
  incr32(self._prev)
  return out
}

var blockSize = 16
exports.encrypt = function (self, chunk) {
  var chunkNum = Math.ceil(chunk.length / blockSize)
  var start = self._cache.length
  self._cache = Buffer.concat([
    self._cache,
    Buffer.allocUnsafe(chunkNum * blockSize)
  ])
  for (var i = 0; i < chunkNum; i++) {
    var out = getBlock(self)
    var offset = start + i * blockSize
    self._cache.writeUInt32BE(out[0], offset + 0)
    self._cache.writeUInt32BE(out[1], offset + 4)
    self._cache.writeUInt32BE(out[2], offset + 8)
    self._cache.writeUInt32BE(out[3], offset + 12)
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/ecb.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/ecb.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}

exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/index.js":
/*!****************************************************!*\
  !*** ./node_modules/browserify-aes/modes/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var modeModules = {
  ECB: __webpack_require__(/*! ./ecb */ "./node_modules/browserify-aes/modes/ecb.js"),
  CBC: __webpack_require__(/*! ./cbc */ "./node_modules/browserify-aes/modes/cbc.js"),
  CFB: __webpack_require__(/*! ./cfb */ "./node_modules/browserify-aes/modes/cfb.js"),
  CFB8: __webpack_require__(/*! ./cfb8 */ "./node_modules/browserify-aes/modes/cfb8.js"),
  CFB1: __webpack_require__(/*! ./cfb1 */ "./node_modules/browserify-aes/modes/cfb1.js"),
  OFB: __webpack_require__(/*! ./ofb */ "./node_modules/browserify-aes/modes/ofb.js"),
  CTR: __webpack_require__(/*! ./ctr */ "./node_modules/browserify-aes/modes/ctr.js"),
  GCM: __webpack_require__(/*! ./ctr */ "./node_modules/browserify-aes/modes/ctr.js")
}

var modes = __webpack_require__(/*! ./list.json */ "./node_modules/browserify-aes/modes/list.json")

for (var key in modes) {
  modes[key].module = modeModules[modes[key].mode]
}

module.exports = modes


/***/ }),

/***/ "./node_modules/browserify-aes/modes/list.json":
/*!*****************************************************!*\
  !*** ./node_modules/browserify-aes/modes/list.json ***!
  \*****************************************************/
/*! exports provided: aes-128-ecb, aes-192-ecb, aes-256-ecb, aes-128-cbc, aes-192-cbc, aes-256-cbc, aes128, aes192, aes256, aes-128-cfb, aes-192-cfb, aes-256-cfb, aes-128-cfb8, aes-192-cfb8, aes-256-cfb8, aes-128-cfb1, aes-192-cfb1, aes-256-cfb1, aes-128-ofb, aes-192-ofb, aes-256-ofb, aes-128-ctr, aes-192-ctr, aes-256-ctr, aes-128-gcm, aes-192-gcm, aes-256-gcm, default */
/***/ (function(module) {

module.exports = {"aes-128-ecb":{"cipher":"AES","key":128,"iv":0,"mode":"ECB","type":"block"},"aes-192-ecb":{"cipher":"AES","key":192,"iv":0,"mode":"ECB","type":"block"},"aes-256-ecb":{"cipher":"AES","key":256,"iv":0,"mode":"ECB","type":"block"},"aes-128-cbc":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes-192-cbc":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes-256-cbc":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes128":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes192":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes256":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes-128-cfb":{"cipher":"AES","key":128,"iv":16,"mode":"CFB","type":"stream"},"aes-192-cfb":{"cipher":"AES","key":192,"iv":16,"mode":"CFB","type":"stream"},"aes-256-cfb":{"cipher":"AES","key":256,"iv":16,"mode":"CFB","type":"stream"},"aes-128-cfb8":{"cipher":"AES","key":128,"iv":16,"mode":"CFB8","type":"stream"},"aes-192-cfb8":{"cipher":"AES","key":192,"iv":16,"mode":"CFB8","type":"stream"},"aes-256-cfb8":{"cipher":"AES","key":256,"iv":16,"mode":"CFB8","type":"stream"},"aes-128-cfb1":{"cipher":"AES","key":128,"iv":16,"mode":"CFB1","type":"stream"},"aes-192-cfb1":{"cipher":"AES","key":192,"iv":16,"mode":"CFB1","type":"stream"},"aes-256-cfb1":{"cipher":"AES","key":256,"iv":16,"mode":"CFB1","type":"stream"},"aes-128-ofb":{"cipher":"AES","key":128,"iv":16,"mode":"OFB","type":"stream"},"aes-192-ofb":{"cipher":"AES","key":192,"iv":16,"mode":"OFB","type":"stream"},"aes-256-ofb":{"cipher":"AES","key":256,"iv":16,"mode":"OFB","type":"stream"},"aes-128-ctr":{"cipher":"AES","key":128,"iv":16,"mode":"CTR","type":"stream"},"aes-192-ctr":{"cipher":"AES","key":192,"iv":16,"mode":"CTR","type":"stream"},"aes-256-ctr":{"cipher":"AES","key":256,"iv":16,"mode":"CTR","type":"stream"},"aes-128-gcm":{"cipher":"AES","key":128,"iv":12,"mode":"GCM","type":"auth"},"aes-192-gcm":{"cipher":"AES","key":192,"iv":12,"mode":"GCM","type":"auth"},"aes-256-gcm":{"cipher":"AES","key":256,"iv":12,"mode":"GCM","type":"auth"}};

/***/ }),

/***/ "./node_modules/browserify-aes/modes/ofb.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/ofb.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/buffer-xor/index.js")

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/browserify-aes/streamCipher.js":
/*!*****************************************************!*\
  !*** ./node_modules/browserify-aes/streamCipher.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aes = __webpack_require__(/*! ./aes */ "./node_modules/browserify-aes/aes.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var Transform = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")

function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._mode = mode
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}

StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

module.exports = StreamCipher


/***/ }),

/***/ "./node_modules/browserify-cipher/browser.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-cipher/browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DES = __webpack_require__(/*! browserify-des */ "./node_modules/browserify-des/index.js")
var aes = __webpack_require__(/*! browserify-aes/browser */ "./node_modules/browserify-aes/browser.js")
var aesModes = __webpack_require__(/*! browserify-aes/modes */ "./node_modules/browserify-aes/modes/index.js")
var desModes = __webpack_require__(/*! browserify-des/modes */ "./node_modules/browserify-des/modes.js")
var ebtk = __webpack_require__(/*! evp_bytestokey */ "./node_modules/evp_bytestokey/index.js")

function createCipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createCipheriv(suite, keys.key, keys.iv)
}

function createDecipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createDecipheriv(suite, keys.key, keys.iv)
}

function createCipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite })

  throw new TypeError('invalid suite type')
}

function createDecipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true })

  throw new TypeError('invalid suite type')
}

function getCiphers () {
  return Object.keys(desModes).concat(aes.getCiphers())
}

exports.createCipher = exports.Cipher = createCipher
exports.createCipheriv = exports.Cipheriv = createCipheriv
exports.createDecipher = exports.Decipher = createDecipher
exports.createDecipheriv = exports.Decipheriv = createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),

/***/ "./node_modules/browserify-des/index.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-des/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var CipherBase = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var des = __webpack_require__(/*! des.js */ "./node_modules/des.js/lib/des.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
}
modes.des = modes['des-cbc']
modes.des3 = modes['des-ede3-cbc']
module.exports = DES
inherits(DES, CipherBase)
function DES (opts) {
  CipherBase.call(this)
  var modeName = opts.mode.toLowerCase()
  var mode = modes[modeName]
  var type
  if (opts.decrypt) {
    type = 'decrypt'
  } else {
    type = 'encrypt'
  }
  var key = opts.key
  if (!Buffer.isBuffer(key)) {
    key = Buffer.from(key)
  }
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)])
  }
  var iv = opts.iv
  if (!Buffer.isBuffer(iv)) {
    iv = Buffer.from(iv)
  }
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  })
}
DES.prototype._update = function (data) {
  return Buffer.from(this._des.update(data))
}
DES.prototype._final = function () {
  return Buffer.from(this._des.final())
}


/***/ }),

/***/ "./node_modules/browserify-des/modes.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-des/modes.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports['des-ecb'] = {
  key: 8,
  iv: 0
}
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
}
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
}
exports['des-ede3'] = {
  key: 24,
  iv: 0
}
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
}
exports['des-ede'] = {
  key: 16,
  iv: 0
}


/***/ }),

/***/ "./node_modules/browserify-rsa/index.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-rsa/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var bn = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js");
module.exports = crt;
function blind(priv) {
  var r = getr(priv);
  var blinder = r.toRed(bn.mont(priv.modulus))
  .redPow(new bn(priv.publicExponent)).fromRed();
  return {
    blinder: blinder,
    unblinder:r.invm(priv.modulus)
  };
}
function crt(msg, priv) {
  var blinds = blind(priv);
  var len = priv.modulus.byteLength();
  var mod = bn.mont(priv.modulus);
  var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
  var c1 = blinded.toRed(bn.mont(priv.prime1));
  var c2 = blinded.toRed(bn.mont(priv.prime2));
  var qinv = priv.coefficient;
  var p = priv.prime1;
  var q = priv.prime2;
  var m1 = c1.redPow(priv.exponent1);
  var m2 = c2.redPow(priv.exponent2);
  m1 = m1.fromRed();
  m2 = m2.fromRed();
  var h = m1.isub(m2).imul(qinv).umod(p);
  h.imul(q);
  m2.iadd(h);
  return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
}
crt.getr = getr;
function getr(priv) {
  var len = priv.modulus.byteLength();
  var r = new bn(randomBytes(len));
  while (r.cmp(priv.modulus) >=  0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
    r = new bn(randomBytes(len));
  }
  return r;
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/browserify-sign/algos.js":
/*!***********************************************!*\
  !*** ./node_modules/browserify-sign/algos.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./browser/algorithms.json */ "./node_modules/browserify-sign/browser/algorithms.json")


/***/ }),

/***/ "./node_modules/browserify-sign/browser/algorithms.json":
/*!**************************************************************!*\
  !*** ./node_modules/browserify-sign/browser/algorithms.json ***!
  \**************************************************************/
/*! exports provided: sha224WithRSAEncryption, RSA-SHA224, sha256WithRSAEncryption, RSA-SHA256, sha384WithRSAEncryption, RSA-SHA384, sha512WithRSAEncryption, RSA-SHA512, RSA-SHA1, ecdsa-with-SHA1, sha256, sha224, sha384, sha512, DSA-SHA, DSA-SHA1, DSA, DSA-WITH-SHA224, DSA-SHA224, DSA-WITH-SHA256, DSA-SHA256, DSA-WITH-SHA384, DSA-SHA384, DSA-WITH-SHA512, DSA-SHA512, DSA-RIPEMD160, ripemd160WithRSA, RSA-RIPEMD160, md5WithRSAEncryption, RSA-MD5, default */
/***/ (function(module) {

module.exports = {"sha224WithRSAEncryption":{"sign":"rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"RSA-SHA224":{"sign":"ecdsa/rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"sha256WithRSAEncryption":{"sign":"rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"RSA-SHA256":{"sign":"ecdsa/rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"sha384WithRSAEncryption":{"sign":"rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"RSA-SHA384":{"sign":"ecdsa/rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"sha512WithRSAEncryption":{"sign":"rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA512":{"sign":"ecdsa/rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA1":{"sign":"rsa","hash":"sha1","id":"3021300906052b0e03021a05000414"},"ecdsa-with-SHA1":{"sign":"ecdsa","hash":"sha1","id":""},"sha256":{"sign":"ecdsa","hash":"sha256","id":""},"sha224":{"sign":"ecdsa","hash":"sha224","id":""},"sha384":{"sign":"ecdsa","hash":"sha384","id":""},"sha512":{"sign":"ecdsa","hash":"sha512","id":""},"DSA-SHA":{"sign":"dsa","hash":"sha1","id":""},"DSA-SHA1":{"sign":"dsa","hash":"sha1","id":""},"DSA":{"sign":"dsa","hash":"sha1","id":""},"DSA-WITH-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-WITH-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-WITH-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-WITH-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-RIPEMD160":{"sign":"dsa","hash":"rmd160","id":""},"ripemd160WithRSA":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"RSA-RIPEMD160":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"md5WithRSAEncryption":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"},"RSA-MD5":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"}};

/***/ }),

/***/ "./node_modules/browserify-sign/browser/curves.json":
/*!**********************************************************!*\
  !*** ./node_modules/browserify-sign/browser/curves.json ***!
  \**********************************************************/
/*! exports provided: 1.3.132.0.10, 1.3.132.0.33, 1.2.840.10045.3.1.1, 1.2.840.10045.3.1.7, 1.3.132.0.34, 1.3.132.0.35, default */
/***/ (function(module) {

module.exports = {"1.3.132.0.10":"secp256k1","1.3.132.0.33":"p224","1.2.840.10045.3.1.1":"p192","1.2.840.10045.3.1.7":"p256","1.3.132.0.34":"p384","1.3.132.0.35":"p521"};

/***/ }),

/***/ "./node_modules/browserify-sign/browser/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/browserify-sign/browser/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(/*! create-hash */ "./node_modules/create-hash/browser.js")
var stream = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var sign = __webpack_require__(/*! ./sign */ "./node_modules/browserify-sign/browser/sign.js")
var verify = __webpack_require__(/*! ./verify */ "./node_modules/browserify-sign/browser/verify.js")

var algorithms = __webpack_require__(/*! ./algorithms.json */ "./node_modules/browserify-sign/browser/algorithms.json")
Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = new Buffer(algorithms[key].id, 'hex')
  algorithms[key.toLowerCase()] = algorithms[key]
})

function Sign (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hashType = data.hash
  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Sign, stream.Writable)

Sign.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Sign.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc)

  this._hash.update(data)
  return this
}

Sign.prototype.sign = function signMethod (key, enc) {
  this.end()
  var hash = this._hash.digest()
  var sig = sign(hash, key, this._hashType, this._signType, this._tag)

  return enc ? sig.toString(enc) : sig
}

function Verify (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Verify, stream.Writable)

Verify.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Verify.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc)

  this._hash.update(data)
  return this
}

Verify.prototype.verify = function verifyMethod (key, sig, enc) {
  if (typeof sig === 'string') sig = new Buffer(sig, enc)

  this.end()
  var hash = this._hash.digest()
  return verify(sig, hash, key, this._signType, this._tag)
}

function createSign (algorithm) {
  return new Sign(algorithm)
}

function createVerify (algorithm) {
  return new Verify(algorithm)
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/browserify-sign/browser/sign.js":
/*!******************************************************!*\
  !*** ./node_modules/browserify-sign/browser/sign.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var createHmac = __webpack_require__(/*! create-hmac */ "./node_modules/create-hmac/browser.js")
var crt = __webpack_require__(/*! browserify-rsa */ "./node_modules/browserify-rsa/index.js")
var EC = __webpack_require__(/*! elliptic */ "./node_modules/elliptic/lib/elliptic.js").ec
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")
var parseKeys = __webpack_require__(/*! parse-asn1 */ "./node_modules/parse-asn1/index.js")
var curves = __webpack_require__(/*! ./curves.json */ "./node_modules/browserify-sign/browser/curves.json")

function sign (hash, key, hashType, signType, tag) {
  var priv = parseKeys(key)
  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
    return ecSign(hash, priv)
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong private key type')
    return dsaSign(hash, priv, hashType)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = priv.modulus.byteLength()
  var pad = [ 0, 1 ]
  while (hash.length + pad.length + 1 < len) pad.push(0xff)
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) pad.push(hash[i])

  var out = crt(pad, priv)
  return out
}

function ecSign (hash, priv) {
  var curveId = curves[priv.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))

  var curve = new EC(curveId)
  var key = curve.keyFromPrivate(priv.privateKey)
  var out = key.sign(hash)

  return new Buffer(out.toDER())
}

function dsaSign (hash, priv, algo) {
  var x = priv.params.priv_key
  var p = priv.params.p
  var q = priv.params.q
  var g = priv.params.g
  var r = new BN(0)
  var k
  var H = bits2int(hash, q).mod(q)
  var s = false
  var kv = getKey(x, q, hash, algo)
  while (s === false) {
    k = makeKey(q, kv, algo)
    r = makeR(g, k, p, q)
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)
    if (s.cmpn(0) === 0) {
      s = false
      r = new BN(0)
    }
  }
  return toDER(r, s)
}

function toDER (r, s) {
  r = r.toArray()
  s = s.toArray()

  // Pad values
  if (r[0] & 0x80) r = [ 0 ].concat(r)
  if (s[0] & 0x80) s = [ 0 ].concat(s)

  var total = r.length + s.length + 4
  var res = [ 0x30, total, 0x02, r.length ]
  res = res.concat(r, [ 0x02, s.length ], s)
  return new Buffer(res)
}

function getKey (x, q, hash, algo) {
  x = new Buffer(x.toArray())
  if (x.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - x.length)
    zeros.fill(0)
    x = Buffer.concat([ zeros, x ])
  }
  var hlen = hash.length
  var hbits = bits2octets(hash, q)
  var v = new Buffer(hlen)
  v.fill(1)
  var k = new Buffer(hlen)
  k.fill(0)
  k = createHmac(algo, k).update(v).update(new Buffer([ 0 ])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  k = createHmac(algo, k).update(v).update(new Buffer([ 1 ])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  return { k: k, v: v }
}

function bits2int (obits, q) {
  var bits = new BN(obits)
  var shift = (obits.length << 3) - q.bitLength()
  if (shift > 0) bits.ishrn(shift)
  return bits
}

function bits2octets (bits, q) {
  bits = bits2int(bits, q)
  bits = bits.mod(q)
  var out = new Buffer(bits.toArray())
  if (out.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - out.length)
    zeros.fill(0)
    out = Buffer.concat([ zeros, out ])
  }
  return out
}

function makeKey (q, kv, algo) {
  var t
  var k

  do {
    t = new Buffer(0)

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest()
      t = Buffer.concat([ t, kv.v ])
    }

    k = bits2int(t, q)
    kv.k = createHmac(algo, kv.k).update(kv.v).update(new Buffer([ 0 ])).digest()
    kv.v = createHmac(algo, kv.k).update(kv.v).digest()
  } while (k.cmp(q) !== -1)

  return k
}

function makeR (g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)
}

module.exports = sign
module.exports.getKey = getKey
module.exports.makeKey = makeKey

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/browserify-sign/browser/verify.js":
/*!********************************************************!*\
  !*** ./node_modules/browserify-sign/browser/verify.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")
var EC = __webpack_require__(/*! elliptic */ "./node_modules/elliptic/lib/elliptic.js").ec
var parseKeys = __webpack_require__(/*! parse-asn1 */ "./node_modules/parse-asn1/index.js")
var curves = __webpack_require__(/*! ./curves.json */ "./node_modules/browserify-sign/browser/curves.json")

function verify (sig, hash, key, signType, tag) {
  var pub = parseKeys(key)
  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
    return ecVerify(sig, hash, pub)
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong public key type')
    return dsaVerify(sig, hash, pub)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = pub.modulus.byteLength()
  var pad = [ 1 ]
  var padNum = 0
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff)
    padNum++
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }
  pad = new Buffer(pad)
  var red = BN.mont(pub.modulus)
  sig = new BN(sig).toRed(red)

  sig = sig.redPow(new BN(pub.publicExponent))
  sig = new Buffer(sig.fromRed().toArray())
  var out = padNum < 8 ? 1 : 0
  len = Math.min(sig.length, pad.length)
  if (sig.length !== pad.length) out = 1

  i = -1
  while (++i < len) out |= sig[i] ^ pad[i]
  return out === 0
}

function ecVerify (sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))

  var curve = new EC(curveId)
  var pubkey = pub.data.subjectPrivateKey.data

  return curve.verify(hash, sig, pubkey)
}

function dsaVerify (sig, hash, pub) {
  var p = pub.data.p
  var q = pub.data.q
  var g = pub.data.g
  var y = pub.data.pub_key
  var unpacked = parseKeys.signature.decode(sig, 'der')
  var s = unpacked.s
  var r = unpacked.r
  checkValue(s, q)
  checkValue(r, q)
  var montp = BN.mont(p)
  var w = s.invm(q)
  var v = g.toRed(montp)
    .redPow(new BN(hash).mul(w).mod(q))
    .fromRed()
    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
    .mod(p)
    .mod(q)
  return v.cmp(r) === 0
}

function checkValue (b, q) {
  if (b.cmpn(0) <= 0) throw new Error('invalid sig')
  if (b.cmp(q) >= q) throw new Error('invalid sig')
}

module.exports = verify

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/buffer-xor/index.js":
/*!******************************************!*\
  !*** ./node_modules/buffer-xor/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/cipher-base/index.js":
/*!*******************************************!*\
  !*** ./node_modules/cipher-base/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var Transform = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js").Transform
var StringDecoder = __webpack_require__(/*! string_decoder */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")

function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  if (this._final) {
    this.__final = this._final
    this._final = null
  }
  this._decoder = null
  this._encoding = null
}
inherits(CipherBase, Transform)

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc)
  }

  var outData = this._update(data)
  if (this.hashMode) return this

  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }

  return outData
}

CipherBase.prototype.setAutoPadding = function () {}
CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this.__final())
  } catch (e) {
    err = e
  }

  done(err)
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0)
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }

  return out
}

module.exports = CipherBase


/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/create-ecdh/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/create-ecdh/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var elliptic = __webpack_require__(/*! elliptic */ "./node_modules/elliptic/lib/elliptic.js")
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")

module.exports = function createECDH (curve) {
  return new ECDH(curve)
}

var aliases = {
  secp256k1: {
    name: 'secp256k1',
    byteLength: 32
  },
  secp224r1: {
    name: 'p224',
    byteLength: 28
  },
  prime256v1: {
    name: 'p256',
    byteLength: 32
  },
  prime192v1: {
    name: 'p192',
    byteLength: 24
  },
  ed25519: {
    name: 'ed25519',
    byteLength: 32
  },
  secp384r1: {
    name: 'p384',
    byteLength: 48
  },
  secp521r1: {
    name: 'p521',
    byteLength: 66
  }
}

aliases.p224 = aliases.secp224r1
aliases.p256 = aliases.secp256r1 = aliases.prime256v1
aliases.p192 = aliases.secp192r1 = aliases.prime192v1
aliases.p384 = aliases.secp384r1
aliases.p521 = aliases.secp521r1

function ECDH (curve) {
  this.curveType = aliases[curve]
  if (!this.curveType) {
    this.curveType = {
      name: curve
    }
  }
  this.curve = new elliptic.ec(this.curveType.name) // eslint-disable-line new-cap
  this.keys = void 0
}

ECDH.prototype.generateKeys = function (enc, format) {
  this.keys = this.curve.genKeyPair()
  return this.getPublicKey(enc, format)
}

ECDH.prototype.computeSecret = function (other, inenc, enc) {
  inenc = inenc || 'utf8'
  if (!Buffer.isBuffer(other)) {
    other = new Buffer(other, inenc)
  }
  var otherPub = this.curve.keyFromPublic(other).getPublic()
  var out = otherPub.mul(this.keys.getPrivate()).getX()
  return formatReturnValue(out, enc, this.curveType.byteLength)
}

ECDH.prototype.getPublicKey = function (enc, format) {
  var key = this.keys.getPublic(format === 'compressed', true)
  if (format === 'hybrid') {
    if (key[key.length - 1] % 2) {
      key[0] = 7
    } else {
      key[0] = 6
    }
  }
  return formatReturnValue(key, enc)
}

ECDH.prototype.getPrivateKey = function (enc) {
  return formatReturnValue(this.keys.getPrivate(), enc)
}

ECDH.prototype.setPublicKey = function (pub, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc)
  }
  this.keys._importPublic(pub)
  return this
}

ECDH.prototype.setPrivateKey = function (priv, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc)
  }

  var _priv = new BN(priv)
  _priv = _priv.toString(16)
  this.keys = this.curve.genKeyPair()
  this.keys._importPrivate(_priv)
  return this
}

function formatReturnValue (bn, enc, len) {
  if (!Array.isArray(bn)) {
    bn = bn.toArray()
  }
  var buf = new Buffer(bn)
  if (len && buf.length < len) {
    var zeros = new Buffer(len - buf.length)
    zeros.fill(0)
    buf = Buffer.concat([zeros, buf])
  }
  if (!enc) {
    return buf
  } else {
    return buf.toString(enc)
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/create-hash/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/create-hash/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var MD5 = __webpack_require__(/*! md5.js */ "./node_modules/md5.js/index.js")
var RIPEMD160 = __webpack_require__(/*! ripemd160 */ "./node_modules/ripemd160/index.js")
var sha = __webpack_require__(/*! sha.js */ "./node_modules/sha.js/index.js")
var Base = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}


/***/ }),

/***/ "./node_modules/create-hash/md5.js":
/*!*****************************************!*\
  !*** ./node_modules/create-hash/md5.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MD5 = __webpack_require__(/*! md5.js */ "./node_modules/md5.js/index.js")

module.exports = function (buffer) {
  return new MD5().update(buffer).digest()
}


/***/ }),

/***/ "./node_modules/create-hmac/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/create-hmac/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Legacy = __webpack_require__(/*! ./legacy */ "./node_modules/create-hmac/legacy.js")
var Base = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var md5 = __webpack_require__(/*! create-hash/md5 */ "./node_modules/create-hash/md5.js")
var RIPEMD160 = __webpack_require__(/*! ripemd160 */ "./node_modules/ripemd160/index.js")

var sha = __webpack_require__(/*! sha.js */ "./node_modules/sha.js/index.js")

var ZEROS = Buffer.alloc(128)

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key
  if (key.length > blocksize) {
    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
    key = hash.update(key).digest()
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }
  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
  this._hash.update(ipad)
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.update(data)
}

Hmac.prototype._final = function () {
  var h = this._hash.digest()
  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)
  return hash.update(this._opad).update(h).digest()
}

module.exports = function createHmac (alg, key) {
  alg = alg.toLowerCase()
  if (alg === 'rmd160' || alg === 'ripemd160') {
    return new Hmac('rmd160', key)
  }
  if (alg === 'md5') {
    return new Legacy(md5, key)
  }
  return new Hmac(alg, key)
}


/***/ }),

/***/ "./node_modules/create-hmac/legacy.js":
/*!********************************************!*\
  !*** ./node_modules/create-hmac/legacy.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var Base = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")

var ZEROS = Buffer.alloc(128)
var blocksize = 64

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = alg(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = [ipad]
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.push(data)
}

Hmac.prototype._final = function () {
  var h = this._alg(Buffer.concat(this._hash))
  return this._alg(Buffer.concat([this._opad, h]))
}
module.exports = Hmac


/***/ }),

/***/ "./node_modules/crypto-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js")
exports.createHash = exports.Hash = __webpack_require__(/*! create-hash */ "./node_modules/create-hash/browser.js")
exports.createHmac = exports.Hmac = __webpack_require__(/*! create-hmac */ "./node_modules/create-hmac/browser.js")

var algos = __webpack_require__(/*! browserify-sign/algos */ "./node_modules/browserify-sign/algos.js")
var algoKeys = Object.keys(algos)
var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys)
exports.getHashes = function () {
  return hashes
}

var p = __webpack_require__(/*! pbkdf2 */ "./node_modules/pbkdf2/browser.js")
exports.pbkdf2 = p.pbkdf2
exports.pbkdf2Sync = p.pbkdf2Sync

var aes = __webpack_require__(/*! browserify-cipher */ "./node_modules/browserify-cipher/browser.js")

exports.Cipher = aes.Cipher
exports.createCipher = aes.createCipher
exports.Cipheriv = aes.Cipheriv
exports.createCipheriv = aes.createCipheriv
exports.Decipher = aes.Decipher
exports.createDecipher = aes.createDecipher
exports.Decipheriv = aes.Decipheriv
exports.createDecipheriv = aes.createDecipheriv
exports.getCiphers = aes.getCiphers
exports.listCiphers = aes.listCiphers

var dh = __webpack_require__(/*! diffie-hellman */ "./node_modules/diffie-hellman/browser.js")

exports.DiffieHellmanGroup = dh.DiffieHellmanGroup
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup
exports.getDiffieHellman = dh.getDiffieHellman
exports.createDiffieHellman = dh.createDiffieHellman
exports.DiffieHellman = dh.DiffieHellman

var sign = __webpack_require__(/*! browserify-sign */ "./node_modules/browserify-sign/browser/index.js")

exports.createSign = sign.createSign
exports.Sign = sign.Sign
exports.createVerify = sign.createVerify
exports.Verify = sign.Verify

exports.createECDH = __webpack_require__(/*! create-ecdh */ "./node_modules/create-ecdh/browser.js")

var publicEncrypt = __webpack_require__(/*! public-encrypt */ "./node_modules/public-encrypt/browser.js")

exports.publicEncrypt = publicEncrypt.publicEncrypt
exports.privateEncrypt = publicEncrypt.privateEncrypt
exports.publicDecrypt = publicEncrypt.publicDecrypt
exports.privateDecrypt = publicEncrypt.privateDecrypt

// the least I can do is make error messages for the rest of the node.js/crypto api.
// ;[
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error([
//       'sorry, ' + name + ' is not implemented yet',
//       'we accept pull requests',
//       'https://github.com/crypto-browserify/crypto-browserify'
//     ].join('\n'))
//   }
// })

var rf = __webpack_require__(/*! randomfill */ "./node_modules/randomfill/browser.js")

exports.randomFill = rf.randomFill
exports.randomFillSync = rf.randomFillSync

exports.createCredentials = function () {
  throw new Error([
    'sorry, createCredentials is not implemented yet',
    'we accept pull requests',
    'https://github.com/crypto-browserify/crypto-browserify'
  ].join('\n'))
}

exports.constants = {
  'DH_CHECK_P_NOT_SAFE_PRIME': 2,
  'DH_CHECK_P_NOT_PRIME': 1,
  'DH_UNABLE_TO_CHECK_GENERATOR': 4,
  'DH_NOT_SUITABLE_GENERATOR': 8,
  'NPN_ENABLED': 1,
  'ALPN_ENABLED': 1,
  'RSA_PKCS1_PADDING': 1,
  'RSA_SSLV23_PADDING': 2,
  'RSA_NO_PADDING': 3,
  'RSA_PKCS1_OAEP_PADDING': 4,
  'RSA_X931_PADDING': 5,
  'RSA_PKCS1_PSS_PADDING': 6,
  'POINT_CONVERSION_COMPRESSED': 2,
  'POINT_CONVERSION_UNCOMPRESSED': 4,
  'POINT_CONVERSION_HYBRID': 6
}


/***/ }),

/***/ "./node_modules/des.js/lib/des.js":
/*!****************************************!*\
  !*** ./node_modules/des.js/lib/des.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.utils = __webpack_require__(/*! ./des/utils */ "./node_modules/des.js/lib/des/utils.js");
exports.Cipher = __webpack_require__(/*! ./des/cipher */ "./node_modules/des.js/lib/des/cipher.js");
exports.DES = __webpack_require__(/*! ./des/des */ "./node_modules/des.js/lib/des/des.js");
exports.CBC = __webpack_require__(/*! ./des/cbc */ "./node_modules/des.js/lib/des/cbc.js");
exports.EDE = __webpack_require__(/*! ./des/ede */ "./node_modules/des.js/lib/des/ede.js");


/***/ }),

/***/ "./node_modules/des.js/lib/des/cbc.js":
/*!********************************************!*\
  !*** ./node_modules/des.js/lib/des/cbc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};


/***/ }),

/***/ "./node_modules/des.js/lib/des/cipher.js":
/*!***********************************************!*\
  !*** ./node_modules/des.js/lib/des/cipher.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

function Cipher(options) {
  this.options = options;

  this.type = this.options.type;
  this.blockSize = 8;
  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
}
module.exports = Cipher;

Cipher.prototype._init = function _init() {
  // Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0)
    return [];

  if (this.type === 'decrypt')
    return this._updateDecrypt(data);
  else
    return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);

    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - ((data.length - inputOff) % this.blockSize);
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);

  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer)
    first = this.update(buffer);

  var last;
  if (this.type === 'encrypt')
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();

  if (first)
    return first.concat(last);
  else
    return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0)
    return false;

  while (off < buffer.length)
    buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];

  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);

  return this._unpad(out);
};


/***/ }),

/***/ "./node_modules/des.js/lib/des/des.js":
/*!********************************************!*\
  !*** ./node_modules/des.js/lib/des/des.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var des = __webpack_require__(/*! ../des */ "./node_modules/des.js/lib/des.js");
var utils = des.utils;
var Cipher = des.Cipher;

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);

  var state = new DESState();
  this._desState = state;

  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [
  1, 1, 2, 2, 2, 2, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 1
];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);

  assert.equal(key.length, this.blockSize, 'Invalid key length');

  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);

  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;

  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];

  if (this.type === 'encrypt')
    this._encrypt(state, l, r, state.tmp, 0);
  else
    this._decrypt(state, l, r, state.tmp, 0);

  l = state.tmp[0];
  r = state.tmp[1];

  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++)
    buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++)
    assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};


/***/ }),

/***/ "./node_modules/des.js/lib/des/ede.js":
/*!********************************************!*\
  !*** ./node_modules/des.js/lib/des/ede.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var des = __webpack_require__(/*! ../des */ "./node_modules/des.js/lib/des.js");
var Cipher = des.Cipher;
var DES = des.DES;

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [
      DES.create({ type: 'encrypt', key: k1 }),
      DES.create({ type: 'decrypt', key: k2 }),
      DES.create({ type: 'encrypt', key: k3 })
    ];
  } else {
    this.ciphers = [
      DES.create({ type: 'decrypt', key: k3 }),
      DES.create({ type: 'encrypt', key: k2 }),
      DES.create({ type: 'decrypt', key: k1 })
    ];
  }
}

function EDE(options) {
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;


/***/ }),

/***/ "./node_modules/des.js/lib/des/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/des.js/lib/des/utils.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res =  (bytes[0 + off] << 24) |
             (bytes[1 + off] << 16) |
             (bytes[2 + off] << 8) |
             bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = (value >>> 16) & 0xff;
  bytes[2 + off] = (value >>> 8) & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + i)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + i)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
};

var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0,
  13, 22, 7, 18, 5, 9, 16, 24,
  2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16,
  5, 11, 23, 8, 12, 7, 17, 0,
  22, 3, 10, 14, 6, 20, 27, 24
];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> pc2table[i]) & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= (inR >>> pc2table[i]) & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }
  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [
  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
];

exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = (inL >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = (inR >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};

var permuteTable = [
  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
];

exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= (num >>> permuteTable[i]) & 0x1;
  }
  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = '0' + str;

  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(' ');
};


/***/ }),

/***/ "./node_modules/diffie-hellman/browser.js":
/*!************************************************!*\
  !*** ./node_modules/diffie-hellman/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var generatePrime = __webpack_require__(/*! ./lib/generatePrime */ "./node_modules/diffie-hellman/lib/generatePrime.js")
var primes = __webpack_require__(/*! ./lib/primes.json */ "./node_modules/diffie-hellman/lib/primes.json")

var DH = __webpack_require__(/*! ./lib/dh */ "./node_modules/diffie-hellman/lib/dh.js")

function getDiffieHellman (mod) {
  var prime = new Buffer(primes[mod].prime, 'hex')
  var gen = new Buffer(primes[mod].gen, 'hex')

  return new DH(prime, gen)
}

var ENCODINGS = {
  'binary': true, 'hex': true, 'base64': true
}

function createDiffieHellman (prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator)
  }

  enc = enc || 'binary'
  genc = genc || 'binary'
  generator = generator || new Buffer([2])

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc)
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true)
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc)
  }

  return new DH(prime, generator, true)
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/diffie-hellman/lib/dh.js":
/*!***********************************************!*\
  !*** ./node_modules/diffie-hellman/lib/dh.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var MillerRabin = __webpack_require__(/*! miller-rabin */ "./node_modules/miller-rabin/lib/mr.js");
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = __webpack_require__(/*! ./generatePrime */ "./node_modules/diffie-hellman/lib/generatePrime.js");
var randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js");
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;

  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/diffie-hellman/lib/generatePrime.js":
/*!**********************************************************!*\
  !*** ./node_modules/diffie-hellman/lib/generatePrime.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js");
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var TWENTYFOUR = new BN(24);
var MillerRabin = __webpack_require__(/*! miller-rabin */ "./node_modules/miller-rabin/lib/mr.js");
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);

  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }

}


/***/ }),

/***/ "./node_modules/diffie-hellman/lib/primes.json":
/*!*****************************************************!*\
  !*** ./node_modules/diffie-hellman/lib/primes.json ***!
  \*****************************************************/
/*! exports provided: modp1, modp2, modp5, modp14, modp15, modp16, modp17, modp18, default */
/***/ (function(module) {

module.exports = {"modp1":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"},"modp2":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"},"modp5":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"},"modp14":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"},"modp15":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"},"modp16":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"},"modp17":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"},"modp18":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"}};

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic.js":
/*!***********************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = exports;

elliptic.version = __webpack_require__(/*! ../package.json */ "./node_modules/elliptic/package.json").version;
elliptic.utils = __webpack_require__(/*! ./elliptic/utils */ "./node_modules/elliptic/lib/elliptic/utils.js");
elliptic.rand = __webpack_require__(/*! brorand */ "./node_modules/brorand/index.js");
elliptic.curve = __webpack_require__(/*! ./elliptic/curve */ "./node_modules/elliptic/lib/elliptic/curve/index.js");
elliptic.curves = __webpack_require__(/*! ./elliptic/curves */ "./node_modules/elliptic/lib/elliptic/curves.js");

// Protocols
elliptic.ec = __webpack_require__(/*! ./elliptic/ec */ "./node_modules/elliptic/lib/elliptic/ec/index.js");
elliptic.eddsa = __webpack_require__(/*! ./elliptic/eddsa */ "./node_modules/elliptic/lib/elliptic/eddsa/index.js");


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/base.js":
/*!**********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/base.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  for (var j = 0; j < naf.length; j += doubles.step) {
    var nafW = 0;
    for (var k = j + doubles.step - 1; k >= j; k--)
      nafW = (nafW << 1) + naf[k];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (var j = 0; j < repr.length; j++) {
      var nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var k = 0; i >= 0 && naf[i] === 0; i--)
      k++;
    if (i >= 0)
      k++;
    acc = acc.dblp(k);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                       points,
                                                       coeffs,
                                                       len,
                                                       jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  for (var i = 0; i < len; i++) {
    var p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (var i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a]);
      naf[b] = getNAF(coeffs[b], wndWidth[b]);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b] /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (var j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (var i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (var j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (var j = 0; j < len; j++) {
      var z = tmp[j];
      var p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (var i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
                          bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/edwards.js":
/*!*************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/edwards.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(/*! ../curve */ "./node_modules/elliptic/lib/elliptic/curve/index.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Base = curve.base;

var assert = elliptic.utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  if (this.curve.twisted) {
    // E = a * C
    var e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      var h = this.z.redSqr();
      // J = F - 2 * H
      var j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    var e = c.redAdd(d);
    // H = (c * Z1)^2
    var h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    var j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
                          this.y,
                          this.z,
                          this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = exports;

curve.base = __webpack_require__(/*! ./base */ "./node_modules/elliptic/lib/elliptic/curve/base.js");
curve.short = __webpack_require__(/*! ./short */ "./node_modules/elliptic/lib/elliptic/curve/short.js");
curve.mont = __webpack_require__(/*! ./mont */ "./node_modules/elliptic/lib/elliptic/curve/mont.js");
curve.edwards = __webpack_require__(/*! ./edwards */ "./node_modules/elliptic/lib/elliptic/curve/edwards.js");


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/mont.js":
/*!**********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/mont.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(/*! ../curve */ "./node_modules/elliptic/lib/elliptic/curve/index.js");
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Base = curve.base;

var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/short.js":
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/short.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(/*! ../curve */ "./node_modules/elliptic/lib/elliptic/curve/index.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Base = curve.base;

var assert = elliptic.utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();

    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

  // Clean-up references to points and coefficients
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);

  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (var i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (var i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curves.js":
/*!******************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curves.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curves = exports;

var hash = __webpack_require__(/*! hash.js */ "./node_modules/hash.js/lib/hash.js");
var elliptic = __webpack_require__(/*! ../elliptic */ "./node_modules/elliptic/lib/elliptic.js");

var assert = elliptic.utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new elliptic.curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new elliptic.curve.edwards(options);
  else
    this.curve = new elliptic.curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
  ]
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
  ]
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
  ]
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
  ]
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650'
  ]
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9'
  ]
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658'
  ]
});

var pre;
try {
  pre = __webpack_require__(/*! ./precomputed/secp256k1 */ "./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js");
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre
  ]
});


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/ec/index.js":
/*!********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var HmacDRBG = __webpack_require__(/*! hmac-drbg */ "./node_modules/hmac-drbg/lib/hmac-drbg.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;

var KeyPair = __webpack_require__(/*! ./key */ "./node_modules/elliptic/lib/elliptic/ec/key.js");
var Signature = __webpack_require__(/*! ./signature */ "./node_modules/elliptic/lib/elliptic/ec/signature.js");

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);

    options = elliptic.curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof elliptic.curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray()
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  do {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  } while (true);
};

EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8'
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; true; iter++) {
    var k = options.k ?
        options.k(iter) :
        new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);

  if (!this.curve._maxwellTrick) {
    var p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  var p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/ec/key.js":
/*!******************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/key.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/ec/signature.js":
/*!************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/signature.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");

var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
  }
  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0 && (r[1] & 0x80)) {
    r = r.slice(1);
  }
  if (s[0] === 0 && (s[1] & 0x80)) {
    s = s.slice(1);
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/eddsa/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(/*! hash.js */ "./node_modules/hash.js/lib/hash.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = __webpack_require__(/*! ./key */ "./node_modules/elliptic/lib/elliptic/eddsa/key.js");
var Signature = __webpack_require__(/*! ./signature */ "./node_modules/elliptic/lib/elliptic/eddsa/signature.js");

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  var curve = elliptic.curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
               .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/eddsa/key.js":
/*!*********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/key.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/eddsa/signature.js":
/*!***************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/signature.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength)
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js":
/*!*********************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
      ]
    ]
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
      ]
    ]
  }
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/utils.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var minAssert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");
var minUtils = __webpack_require__(/*! minimalistic-crypto-utils */ "./node_modules/minimalistic-crypto-utils/lib/utils.js");

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w) {
  var naf = [];
  var ws = 1 << (w + 1);
  var k = num.clone();
  while (k.cmpn(1) >= 0) {
    var z;
    if (k.isOdd()) {
      var mod = k.andln(ws - 1);
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }
    naf.push(z);

    // Optimization, shift by word if possible
    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
    for (var i = 1; i < shift; i++)
      naf.push(0);
    k.iushrn(shift);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    []
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      var m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      var m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
           this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
                                     bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;



/***/ }),

/***/ "./node_modules/elliptic/package.json":
/*!********************************************!*\
  !*** ./node_modules/elliptic/package.json ***!
  \********************************************/
/*! exports provided: _args, _development, _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _spec, _where, author, bugs, dependencies, description, devDependencies, files, homepage, keywords, license, main, name, repository, scripts, version, default */
/***/ (function(module) {

module.exports = {"_args":[["elliptic@6.4.1","/Users/joeyklee/Cosmos/src/github/joeyklee/magenta-js/sketch"]],"_development":true,"_from":"elliptic@6.4.1","_id":"elliptic@6.4.1","_inBundle":false,"_integrity":"sha512-BsXLz5sqX8OHcsh7CqBMztyXARmGQ3LWPtGjJi6DiJHq5C/qvi9P3OqgswKSDftbu8+IoI/QDTAm2fFnQ9SZSQ==","_location":"/elliptic","_phantomChildren":{},"_requested":{"type":"version","registry":true,"raw":"elliptic@6.4.1","name":"elliptic","escapedName":"elliptic","rawSpec":"6.4.1","saveSpec":null,"fetchSpec":"6.4.1"},"_requiredBy":["/browserify-sign","/create-ecdh"],"_resolved":"https://registry.npmjs.org/elliptic/-/elliptic-6.4.1.tgz","_spec":"6.4.1","_where":"/Users/joeyklee/Cosmos/src/github/joeyklee/magenta-js/sketch","author":{"name":"Fedor Indutny","email":"fedor@indutny.com"},"bugs":{"url":"https://github.com/indutny/elliptic/issues"},"dependencies":{"bn.js":"^4.4.0","brorand":"^1.0.1","hash.js":"^1.0.0","hmac-drbg":"^1.0.0","inherits":"^2.0.1","minimalistic-assert":"^1.0.0","minimalistic-crypto-utils":"^1.0.0"},"description":"EC cryptography","devDependencies":{"brfs":"^1.4.3","coveralls":"^2.11.3","grunt":"^0.4.5","grunt-browserify":"^5.0.0","grunt-cli":"^1.2.0","grunt-contrib-connect":"^1.0.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^1.0.1","grunt-mocha-istanbul":"^3.0.1","grunt-saucelabs":"^8.6.2","istanbul":"^0.4.2","jscs":"^2.9.0","jshint":"^2.6.0","mocha":"^2.1.0"},"files":["lib"],"homepage":"https://github.com/indutny/elliptic","keywords":["EC","Elliptic","curve","Cryptography"],"license":"MIT","main":"lib/elliptic.js","name":"elliptic","repository":{"type":"git","url":"git+ssh://git@github.com/indutny/elliptic.git"},"scripts":{"jscs":"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js","jshint":"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js","lint":"npm run jscs && npm run jshint","test":"npm run lint && npm run unit","unit":"istanbul test _mocha --reporter=spec test/index.js","version":"grunt dist && git add dist/"},"version":"6.4.1"};

/***/ }),

/***/ "./node_modules/evp_bytestokey/index.js":
/*!**********************************************!*\
  !*** ./node_modules/evp_bytestokey/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var MD5 = __webpack_require__(/*! md5.js */ "./node_modules/md5.js/index.js")

/* eslint-disable camelcase */
function EVP_BytesToKey (password, salt, keyBits, ivLen) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')
  if (salt) {
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')
    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')
  }

  var keyLen = keyBits / 8
  var key = Buffer.alloc(keyLen)
  var iv = Buffer.alloc(ivLen || 0)
  var tmp = Buffer.alloc(0)

  while (keyLen > 0 || ivLen > 0) {
    var hash = new MD5()
    hash.update(tmp)
    hash.update(password)
    if (salt) hash.update(salt)
    tmp = hash.digest()

    var used = 0

    if (keyLen > 0) {
      var keyStart = key.length - keyLen
      used = Math.min(keyLen, tmp.length)
      tmp.copy(key, keyStart, 0, used)
      keyLen -= used
    }

    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen
      var length = Math.min(ivLen, tmp.length - used)
      tmp.copy(iv, ivStart, used, used + length)
      ivLen -= length
    }
  }

  tmp.fill(0)
  return { key: key, iv: iv }
}

module.exports = EVP_BytesToKey


/***/ }),

/***/ "./node_modules/hash-base/index.js":
/*!*****************************************!*\
  !*** ./node_modules/hash-base/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var Transform = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js").Transform
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")

function throwIfNotStringOrBuffer (val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer')
  }
}

function HashBase (blockSize) {
  Transform.call(this)

  this._block = Buffer.allocUnsafe(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    this.update(chunk, encoding)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this.digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data')
  if (this._finalized) throw new Error('Digest already called')
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)

  // reset state
  this._block.fill(0)
  this._blockOffset = 0
  for (var i = 0; i < 4; ++i) this._length[i] = 0

  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase


/***/ }),

/***/ "./node_modules/hash.js/lib/hash.js":
/*!******************************************!*\
  !*** ./node_modules/hash.js/lib/hash.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hash = exports;

hash.utils = __webpack_require__(/*! ./hash/utils */ "./node_modules/hash.js/lib/hash/utils.js");
hash.common = __webpack_require__(/*! ./hash/common */ "./node_modules/hash.js/lib/hash/common.js");
hash.sha = __webpack_require__(/*! ./hash/sha */ "./node_modules/hash.js/lib/hash/sha.js");
hash.ripemd = __webpack_require__(/*! ./hash/ripemd */ "./node_modules/hash.js/lib/hash/ripemd.js");
hash.hmac = __webpack_require__(/*! ./hash/hmac */ "./node_modules/hash.js/lib/hash/hmac.js");

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/common.js":
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/common.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/hash.js/lib/hash/utils.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/hmac.js":
/*!***********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/hmac.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/hash.js/lib/hash/utils.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/ripemd.js":
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/ripemd.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ./common */ "./node_modules/hash.js/lib/hash/common.js");

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha.js":
/*!**********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.sha1 = __webpack_require__(/*! ./sha/1 */ "./node_modules/hash.js/lib/hash/sha/1.js");
exports.sha224 = __webpack_require__(/*! ./sha/224 */ "./node_modules/hash.js/lib/hash/sha/224.js");
exports.sha256 = __webpack_require__(/*! ./sha/256 */ "./node_modules/hash.js/lib/hash/sha/256.js");
exports.sha384 = __webpack_require__(/*! ./sha/384 */ "./node_modules/hash.js/lib/hash/sha/384.js");
exports.sha512 = __webpack_require__(/*! ./sha/512 */ "./node_modules/hash.js/lib/hash/sha/512.js");


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/1.js":
/*!************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/1.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ../common */ "./node_modules/hash.js/lib/hash/common.js");
var shaCommon = __webpack_require__(/*! ./common */ "./node_modules/hash.js/lib/hash/sha/common.js");

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/224.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/224.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var SHA256 = __webpack_require__(/*! ./256 */ "./node_modules/hash.js/lib/hash/sha/256.js");

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};



/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/256.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/256.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ../common */ "./node_modules/hash.js/lib/hash/common.js");
var shaCommon = __webpack_require__(/*! ./common */ "./node_modules/hash.js/lib/hash/sha/common.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/384.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/384.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");

var SHA512 = __webpack_require__(/*! ./512 */ "./node_modules/hash.js/lib/hash/sha/512.js");

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/512.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/512.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ../common */ "./node_modules/hash.js/lib/hash/common.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/common.js":
/*!*****************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/common.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/utils.js":
/*!************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/utils.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;


/***/ }),

/***/ "./node_modules/hmac-drbg/lib/hmac-drbg.js":
/*!*************************************************!*\
  !*** ./node_modules/hmac-drbg/lib/hmac-drbg.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(/*! hash.js */ "./node_modules/hash.js/lib/hash.js");
var utils = __webpack_require__(/*! minimalistic-crypto-utils */ "./node_modules/minimalistic-crypto-utils/lib/utils.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/indexof/index.js":
/*!***************************************!*\
  !*** ./node_modules/indexof/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {


var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/md5.js/index.js":
/*!**************************************!*\
  !*** ./node_modules/md5.js/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var HashBase = __webpack_require__(/*! hash-base */ "./node_modules/hash-base/index.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var ARRAY16 = new Array(16)

function MD5 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
}

inherits(MD5, HashBase)

MD5.prototype._update = function () {
  var M = ARRAY16
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d

  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
  c = fnF(c, d, a, b, M[2], 0x242070db, 17)
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
  d = fnG(d, a, b, c, M[10], 0x02441453, 9)
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

  this._a = (this._a + a) | 0
  this._b = (this._b + b) | 0
  this._c = (this._c + c) | 0
  this._d = (this._d + d) | 0
}

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.allocUnsafe(16)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fnF (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
}

function fnG (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
}

function fnH (a, b, c, d, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
}

function fnI (a, b, c, d, m, k, s) {
  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
}

module.exports = MD5


/***/ }),

/***/ "./node_modules/miller-rabin/lib/mr.js":
/*!*********************************************!*\
  !*** ./node_modules/miller-rabin/lib/mr.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var bn = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var brorand = __webpack_require__(/*! brorand */ "./node_modules/brorand/index.js");

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._randbelow = function _randbelow(n) {
  var len = n.bitLength();
  var min_bytes = Math.ceil(len / 8);

  // Generage random bytes until a number less than n is found.
  // This ensures that 0..n-1 have an equal probability of being selected.
  do
    var a = new bn(this.rand.generate(min_bytes));
  while (a.cmp(n) >= 0);

  return a;
};

MillerRabin.prototype._randrange = function _randrange(start, stop) {
  // Generate a random number greater than or equal to start and less than stop.
  var size = stop.sub(start);
  return start.add(this._randbelow(size));
};

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};


/***/ }),

/***/ "./node_modules/minimalistic-assert/index.js":
/*!***************************************************!*\
  !*** ./node_modules/minimalistic-assert/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};


/***/ }),

/***/ "./node_modules/minimalistic-crypto-utils/lib/utils.js":
/*!*************************************************************!*\
  !*** ./node_modules/minimalistic-crypto-utils/lib/utils.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};


/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/buffer/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/buffer/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/events/events.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/events/events.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = $getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  var args = [];
  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/timers-browserify/main.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/timers-browserify/main.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/parse-asn1/aesid.json":
/*!********************************************!*\
  !*** ./node_modules/parse-asn1/aesid.json ***!
  \********************************************/
/*! exports provided: 2.16.840.1.101.3.4.1.1, 2.16.840.1.101.3.4.1.2, 2.16.840.1.101.3.4.1.3, 2.16.840.1.101.3.4.1.4, 2.16.840.1.101.3.4.1.21, 2.16.840.1.101.3.4.1.22, 2.16.840.1.101.3.4.1.23, 2.16.840.1.101.3.4.1.24, 2.16.840.1.101.3.4.1.41, 2.16.840.1.101.3.4.1.42, 2.16.840.1.101.3.4.1.43, 2.16.840.1.101.3.4.1.44, default */
/***/ (function(module) {

module.exports = {"2.16.840.1.101.3.4.1.1":"aes-128-ecb","2.16.840.1.101.3.4.1.2":"aes-128-cbc","2.16.840.1.101.3.4.1.3":"aes-128-ofb","2.16.840.1.101.3.4.1.4":"aes-128-cfb","2.16.840.1.101.3.4.1.21":"aes-192-ecb","2.16.840.1.101.3.4.1.22":"aes-192-cbc","2.16.840.1.101.3.4.1.23":"aes-192-ofb","2.16.840.1.101.3.4.1.24":"aes-192-cfb","2.16.840.1.101.3.4.1.41":"aes-256-ecb","2.16.840.1.101.3.4.1.42":"aes-256-cbc","2.16.840.1.101.3.4.1.43":"aes-256-ofb","2.16.840.1.101.3.4.1.44":"aes-256-cfb"};

/***/ }),

/***/ "./node_modules/parse-asn1/asn1.js":
/*!*****************************************!*\
  !*** ./node_modules/parse-asn1/asn1.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.


var asn1 = __webpack_require__(/*! asn1.js */ "./node_modules/asn1.js/lib/asn1.js")

exports.certificate = __webpack_require__(/*! ./certificate */ "./node_modules/parse-asn1/certificate.js")

var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
  )
})
exports.RSAPrivateKey = RSAPrivateKey

var RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(
    this.key('modulus').int(),
    this.key('publicExponent').int()
  )
})
exports.RSAPublicKey = RSAPublicKey

var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})
exports.PublicKey = PublicKey

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('none').null_().optional(),
    this.key('curve').objid().optional(),
    this.key('params').seq().obj(
      this.key('p').int(),
      this.key('q').int(),
      this.key('g').int()
    ).optional()
  )
})

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPrivateKey').octstr()
  )
})
exports.PrivateKey = PrivateKeyInfo
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('decrypt').seq().obj(
        this.key('kde').seq().obj(
          this.key('id').objid(),
          this.key('kdeparams').seq().obj(
            this.key('salt').octstr(),
            this.key('iters').int()
          )
        ),
        this.key('cipher').seq().obj(
          this.key('algo').objid(),
          this.key('iv').octstr()
        )
      )
    ),
    this.key('subjectPrivateKey').octstr()
  )
})

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo

var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('p').int(),
    this.key('q').int(),
    this.key('g').int(),
    this.key('pub_key').int(),
    this.key('priv_key').int()
  )
})
exports.DSAPrivateKey = DSAPrivateKey

exports.DSAparam = asn1.define('DSAparam', function () {
  this.int()
})

var ECPrivateKey = asn1.define('ECPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('parameters').optional().explicit(0).use(ECParameters),
    this.key('publicKey').optional().explicit(1).bitstr()
  )
})
exports.ECPrivateKey = ECPrivateKey

var ECParameters = asn1.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  })
})

exports.signature = asn1.define('signature', function () {
  this.seq().obj(
    this.key('r').int(),
    this.key('s').int()
  )
})


/***/ }),

/***/ "./node_modules/parse-asn1/certificate.js":
/*!************************************************!*\
  !*** ./node_modules/parse-asn1/certificate.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen



var asn = __webpack_require__(/*! asn1.js */ "./node_modules/asn1.js/lib/asn1.js")

var Time = asn.define('Time', function () {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  })
})

var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
  this.seq().obj(
    this.key('type').objid(),
    this.key('value').any()
  )
})

var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('parameters').optional(),
    this.key('curve').objid().optional()
  )
})

var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})

var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
  this.setof(AttributeTypeValue)
})

var RDNSequence = asn.define('RDNSequence', function () {
  this.seqof(RelativeDistinguishedName)
})

var Name = asn.define('Name', function () {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  })
})

var Validity = asn.define('Validity', function () {
  this.seq().obj(
    this.key('notBefore').use(Time),
    this.key('notAfter').use(Time)
  )
})

var Extension = asn.define('Extension', function () {
  this.seq().obj(
    this.key('extnID').objid(),
    this.key('critical').bool().def(false),
    this.key('extnValue').octstr()
  )
})

var TBSCertificate = asn.define('TBSCertificate', function () {
  this.seq().obj(
    this.key('version').explicit(0).int().optional(),
    this.key('serialNumber').int(),
    this.key('signature').use(AlgorithmIdentifier),
    this.key('issuer').use(Name),
    this.key('validity').use(Validity),
    this.key('subject').use(Name),
    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
    this.key('issuerUniqueID').implicit(1).bitstr().optional(),
    this.key('subjectUniqueID').implicit(2).bitstr().optional(),
    this.key('extensions').explicit(3).seqof(Extension).optional()
  )
})

var X509Certificate = asn.define('X509Certificate', function () {
  this.seq().obj(
    this.key('tbsCertificate').use(TBSCertificate),
    this.key('signatureAlgorithm').use(AlgorithmIdentifier),
    this.key('signatureValue').bitstr()
  )
})

module.exports = X509Certificate


/***/ }),

/***/ "./node_modules/parse-asn1/fixProc.js":
/*!********************************************!*\
  !*** ./node_modules/parse-asn1/fixProc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r\+\/\=]+)[\n\r]+/m
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r\+\/\=]+)-----END \1-----$/m
var evp = __webpack_require__(/*! evp_bytestokey */ "./node_modules/evp_bytestokey/index.js")
var ciphers = __webpack_require__(/*! browserify-aes */ "./node_modules/browserify-aes/browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
module.exports = function (okey, password) {
  var key = okey.toString()
  var match = key.match(findProc)
  var decrypted
  if (!match) {
    var match2 = key.match(fullRegex)
    decrypted = new Buffer(match2[2].replace(/[\r\n]/g, ''), 'base64')
  } else {
    var suite = 'aes' + match[1]
    var iv = Buffer.from(match[2], 'hex')
    var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ''), 'base64')
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
    var out = []
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
    out.push(cipher.update(cipherText))
    out.push(cipher.final())
    decrypted = Buffer.concat(out)
  }
  var tag = key.match(startRegex)[1]
  return {
    tag: tag,
    data: decrypted
  }
}


/***/ }),

/***/ "./node_modules/parse-asn1/index.js":
/*!******************************************!*\
  !*** ./node_modules/parse-asn1/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = __webpack_require__(/*! ./asn1 */ "./node_modules/parse-asn1/asn1.js")
var aesid = __webpack_require__(/*! ./aesid.json */ "./node_modules/parse-asn1/aesid.json")
var fixProc = __webpack_require__(/*! ./fixProc */ "./node_modules/parse-asn1/fixProc.js")
var ciphers = __webpack_require__(/*! browserify-aes */ "./node_modules/browserify-aes/browser.js")
var compat = __webpack_require__(/*! pbkdf2 */ "./node_modules/pbkdf2/browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
module.exports = parseKeys

function parseKeys (buffer) {
  var password
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase
    buffer = buffer.key
  }
  if (typeof buffer === 'string') {
    buffer = Buffer.from(buffer)
  }

  var stripped = fixProc(buffer, password)

  var type = stripped.tag
  var data = stripped.data
  var subtype, ndata
  switch (type) {
    case 'CERTIFICATE':
      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo
      // falls through
    case 'PUBLIC KEY':
      if (!ndata) {
        ndata = asn1.PublicKey.decode(data, 'der')
      }
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey
          return {
            type: 'ec',
            data: ndata
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der')
      data = decrypt(data, password)
      // falls through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der')
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der')
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      }
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der')
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      }
    default: throw new Error('unknown key type ' + type)
  }
}
parseKeys.signature = asn1.signature
function decrypt (data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
  var iv = data.algorithm.decrypt.cipher.iv
  var cipherText = data.subjectPrivateKey
  var keylen = parseInt(algo.split('-')[1], 10) / 8
  var key = compat.pbkdf2Sync(password, salt, iters, keylen, 'sha1')
  var cipher = ciphers.createDecipheriv(algo, key, iv)
  var out = []
  out.push(cipher.update(cipherText))
  out.push(cipher.final())
  return Buffer.concat(out)
}


/***/ }),

/***/ "./node_modules/pbkdf2/browser.js":
/*!****************************************!*\
  !*** ./node_modules/pbkdf2/browser.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.pbkdf2 = __webpack_require__(/*! ./lib/async */ "./node_modules/pbkdf2/lib/async.js")
exports.pbkdf2Sync = __webpack_require__(/*! ./lib/sync */ "./node_modules/pbkdf2/lib/sync-browser.js")


/***/ }),

/***/ "./node_modules/pbkdf2/lib/async.js":
/*!******************************************!*\
  !*** ./node_modules/pbkdf2/lib/async.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {var checkParameters = __webpack_require__(/*! ./precondition */ "./node_modules/pbkdf2/lib/precondition.js")
var defaultEncoding = __webpack_require__(/*! ./default-encoding */ "./node_modules/pbkdf2/lib/default-encoding.js")
var sync = __webpack_require__(/*! ./sync */ "./node_modules/pbkdf2/lib/sync-browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var ZERO_BUF
var subtle = global.crypto && global.crypto.subtle
var toBrowser = {
  'sha': 'SHA-1',
  'sha-1': 'SHA-1',
  'sha1': 'SHA-1',
  'sha256': 'SHA-256',
  'sha-256': 'SHA-256',
  'sha384': 'SHA-384',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  'sha512': 'SHA-512'
}
var checks = []
function checkNative (algo) {
  if (global.process && !global.process.browser) {
    return Promise.resolve(false)
  }
  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false)
  }
  if (checks[algo] !== undefined) {
    return checks[algo]
  }
  ZERO_BUF = ZERO_BUF || Buffer.alloc(8)
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
    .then(function () {
      return true
    }).catch(function () {
      return false
    })
  checks[algo] = prom
  return prom
}

function browserPbkdf2 (password, salt, iterations, length, algo) {
  return subtle.importKey(
    'raw', password, {name: 'PBKDF2'}, false, ['deriveBits']
  ).then(function (key) {
    return subtle.deriveBits({
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: {
        name: algo
      }
    }, key, length << 3)
  }).then(function (res) {
    return Buffer.from(res)
  })
}

function resolvePromise (promise, callback) {
  promise.then(function (out) {
    process.nextTick(function () {
      callback(null, out)
    })
  }, function (e) {
    process.nextTick(function () {
      callback(e)
    })
  })
}
module.exports = function (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }

  digest = digest || 'sha1'
  var algo = toBrowser[digest.toLowerCase()]

  if (!algo || typeof global.Promise !== 'function') {
    return process.nextTick(function () {
      var out
      try {
        out = sync(password, salt, iterations, keylen, digest)
      } catch (e) {
        return callback(e)
      }
      callback(null, out)
    })
  }

  checkParameters(password, salt, iterations, keylen)
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)

  resolvePromise(checkNative(algo).then(function (resp) {
    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)

    return sync(password, salt, iterations, keylen, digest)
  }), callback)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/pbkdf2/lib/default-encoding.js":
/*!*****************************************************!*\
  !*** ./node_modules/pbkdf2/lib/default-encoding.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var defaultEncoding
/* istanbul ignore next */
if (process.browser) {
  defaultEncoding = 'utf-8'
} else {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)

  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'
}
module.exports = defaultEncoding

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/pbkdf2/lib/precondition.js":
/*!*************************************************!*\
  !*** ./node_modules/pbkdf2/lib/precondition.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

function checkBuffer (buf, name) {
  if (typeof buf !== 'string' && !Buffer.isBuffer(buf)) {
    throw new TypeError(name + ' must be a buffer or string')
  }
}

module.exports = function (password, salt, iterations, keylen) {
  checkBuffer(password, 'Password')
  checkBuffer(salt, 'Salt')

  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length')
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/pbkdf2/lib/sync-browser.js":
/*!*************************************************!*\
  !*** ./node_modules/pbkdf2/lib/sync-browser.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var md5 = __webpack_require__(/*! create-hash/md5 */ "./node_modules/create-hash/md5.js")
var RIPEMD160 = __webpack_require__(/*! ripemd160 */ "./node_modules/ripemd160/index.js")
var sha = __webpack_require__(/*! sha.js */ "./node_modules/sha.js/index.js")

var checkParameters = __webpack_require__(/*! ./precondition */ "./node_modules/pbkdf2/lib/precondition.js")
var defaultEncoding = __webpack_require__(/*! ./default-encoding */ "./node_modules/pbkdf2/lib/default-encoding.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var ZEROS = Buffer.alloc(128)
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
}

function Hmac (alg, key, saltLen) {
  var hash = getDigest(alg)
  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  if (key.length > blocksize) {
    key = hash(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])
  var opad = Buffer.allocUnsafe(blocksize + sizes[alg])
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)
  ipad.copy(ipad1, 0, 0, blocksize)
  this.ipad1 = ipad1
  this.ipad2 = ipad
  this.opad = opad
  this.alg = alg
  this.blocksize = blocksize
  this.hash = hash
  this.size = sizes[alg]
}

Hmac.prototype.run = function (data, ipad) {
  data.copy(ipad, this.blocksize)
  var h = this.hash(ipad)
  h.copy(this.opad, this.blocksize)
  return this.hash(this.opad)
}

function getDigest (alg) {
  function shaFunc (data) {
    return sha(alg).update(data).digest()
  }
  function rmd160Func (data) {
    return new RIPEMD160().update(data).digest()
  }

  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func
  if (alg === 'md5') return md5
  return shaFunc
}

function pbkdf2 (password, salt, iterations, keylen, digest) {
  checkParameters(password, salt, iterations, keylen)

  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)

  digest = digest || 'sha1'

  var hmac = new Hmac(digest, password, salt.length)

  var DK = Buffer.allocUnsafe(keylen)
  var block1 = Buffer.allocUnsafe(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var destPos = 0
  var hLen = sizes[digest]
  var l = Math.ceil(keylen / hLen)

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)

    var T = hmac.run(block1, hmac.ipad1)
    var U = T

    for (var j = 1; j < iterations; j++) {
      U = hmac.run(U, hmac.ipad2)
      for (var k = 0; k < hLen; k++) T[k] ^= U[k]
    }

    T.copy(DK, destPos)
    destPos += hLen
  }

  return DK
}

module.exports = pbkdf2


/***/ }),

/***/ "./node_modules/process-nextick-args/index.js":
/*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/public-encrypt/browser.js":
/*!************************************************!*\
  !*** ./node_modules/public-encrypt/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.publicEncrypt = __webpack_require__(/*! ./publicEncrypt */ "./node_modules/public-encrypt/publicEncrypt.js")
exports.privateDecrypt = __webpack_require__(/*! ./privateDecrypt */ "./node_modules/public-encrypt/privateDecrypt.js")

exports.privateEncrypt = function privateEncrypt (key, buf) {
  return exports.publicEncrypt(key, buf, true)
}

exports.publicDecrypt = function publicDecrypt (key, buf) {
  return exports.privateDecrypt(key, buf, true)
}


/***/ }),

/***/ "./node_modules/public-encrypt/mgf.js":
/*!********************************************!*\
  !*** ./node_modules/public-encrypt/mgf.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var createHash = __webpack_require__(/*! create-hash */ "./node_modules/create-hash/browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

module.exports = function (seed, len) {
  var t = Buffer.alloc(0)
  var i = 0
  var c
  while (t.length < len) {
    c = i2ops(i++)
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()])
  }
  return t.slice(0, len)
}

function i2ops (c) {
  var out = Buffer.allocUnsafe(4)
  out.writeUInt32BE(c, 0)
  return out
}


/***/ }),

/***/ "./node_modules/public-encrypt/privateDecrypt.js":
/*!*******************************************************!*\
  !*** ./node_modules/public-encrypt/privateDecrypt.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var parseKeys = __webpack_require__(/*! parse-asn1 */ "./node_modules/parse-asn1/index.js")
var mgf = __webpack_require__(/*! ./mgf */ "./node_modules/public-encrypt/mgf.js")
var xor = __webpack_require__(/*! ./xor */ "./node_modules/public-encrypt/xor.js")
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")
var crt = __webpack_require__(/*! browserify-rsa */ "./node_modules/browserify-rsa/index.js")
var createHash = __webpack_require__(/*! create-hash */ "./node_modules/create-hash/browser.js")
var withPublic = __webpack_require__(/*! ./withPublic */ "./node_modules/public-encrypt/withPublic.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

module.exports = function privateDecrypt (privateKey, enc, reverse) {
  var padding
  if (privateKey.padding) {
    padding = privateKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }

  var key = parseKeys(privateKey)
  var k = key.modulus.byteLength()
  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error')
  }
  var msg
  if (reverse) {
    msg = withPublic(new BN(enc), key)
  } else {
    msg = crt(enc, key)
  }
  var zBuffer = Buffer.alloc(k - msg.length)
  msg = Buffer.concat([zBuffer, msg], k)
  if (padding === 4) {
    return oaep(key, msg)
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    return msg
  } else {
    throw new Error('unknown padding')
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  if (msg[0] !== 0) {
    throw new Error('decryption error')
  }
  var maskedSeed = msg.slice(1, hLen + 1)
  var maskedDb = msg.slice(hLen + 1)
  var seed = xor(maskedSeed, mgf(maskedDb, hLen))
  var db = xor(maskedDb, mgf(seed, k - hLen - 1))
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error')
  }
  var i = hLen
  while (db[i] === 0) {
    i++
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error')
  }
  return db.slice(i)
}

function pkcs1 (key, msg, reverse) {
  var p1 = msg.slice(0, 2)
  var i = 2
  var status = 0
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++
      break
    }
  }
  var ps = msg.slice(2, i - 1)

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
    status++
  }
  if (ps.length < 8) {
    status++
  }
  if (status) {
    throw new Error('decryption error')
  }
  return msg.slice(i)
}
function compare (a, b) {
  a = Buffer.from(a)
  b = Buffer.from(b)
  var dif = 0
  var len = a.length
  if (a.length !== b.length) {
    dif++
    len = Math.min(a.length, b.length)
  }
  var i = -1
  while (++i < len) {
    dif += (a[i] ^ b[i])
  }
  return dif
}


/***/ }),

/***/ "./node_modules/public-encrypt/publicEncrypt.js":
/*!******************************************************!*\
  !*** ./node_modules/public-encrypt/publicEncrypt.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var parseKeys = __webpack_require__(/*! parse-asn1 */ "./node_modules/parse-asn1/index.js")
var randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js")
var createHash = __webpack_require__(/*! create-hash */ "./node_modules/create-hash/browser.js")
var mgf = __webpack_require__(/*! ./mgf */ "./node_modules/public-encrypt/mgf.js")
var xor = __webpack_require__(/*! ./xor */ "./node_modules/public-encrypt/xor.js")
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")
var withPublic = __webpack_require__(/*! ./withPublic */ "./node_modules/public-encrypt/withPublic.js")
var crt = __webpack_require__(/*! browserify-rsa */ "./node_modules/browserify-rsa/index.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

module.exports = function publicEncrypt (publicKey, msg, reverse) {
  var padding
  if (publicKey.padding) {
    padding = publicKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }
  var key = parseKeys(publicKey)
  var paddedMsg
  if (padding === 4) {
    paddedMsg = oaep(key, msg)
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    paddedMsg = new BN(msg)
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus')
    }
  } else {
    throw new Error('unknown padding')
  }
  if (reverse) {
    return crt(paddedMsg, key)
  } else {
    return withPublic(paddedMsg, key)
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var mLen = msg.length
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  var hLen2 = 2 * hLen
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long')
  }
  var ps = Buffer.alloc(k - mLen - hLen2 - 2)
  var dblen = k - hLen - 1
  var seed = randomBytes(hLen)
  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))
  var maskedSeed = xor(seed, mgf(maskedDb, hLen))
  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))
}
function pkcs1 (key, msg, reverse) {
  var mLen = msg.length
  var k = key.modulus.byteLength()
  if (mLen > k - 11) {
    throw new Error('message too long')
  }
  var ps
  if (reverse) {
    ps = Buffer.alloc(k - mLen - 3, 0xff)
  } else {
    ps = nonZero(k - mLen - 3)
  }
  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))
}
function nonZero (len) {
  var out = Buffer.allocUnsafe(len)
  var i = 0
  var cache = randomBytes(len * 2)
  var cur = 0
  var num
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len * 2)
      cur = 0
    }
    num = cache[cur++]
    if (num) {
      out[i++] = num
    }
  }
  return out
}


/***/ }),

/***/ "./node_modules/public-encrypt/withPublic.js":
/*!***************************************************!*\
  !*** ./node_modules/public-encrypt/withPublic.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

function withPublic (paddedMsg, key) {
  return Buffer.from(paddedMsg
    .toRed(BN.mont(key.modulus))
    .redPow(new BN(key.publicExponent))
    .fromRed()
    .toArray())
}

module.exports = withPublic


/***/ }),

/***/ "./node_modules/public-encrypt/xor.js":
/*!********************************************!*\
  !*** ./node_modules/public-encrypt/xor.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function xor (a, b) {
  var len = a.length
  var i = -1
  while (++i < len) {
    a[i] ^= b[i]
  }
  return a
}


/***/ }),

/***/ "./node_modules/randombytes/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/randombytes/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/randomfill/browser.js":
/*!********************************************!*\
  !*** ./node_modules/randomfill/browser.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

function oldBrowser () {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
}
var safeBuffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js")
var randombytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js")
var Buffer = safeBuffer.Buffer
var kBufferMaxLength = safeBuffer.kMaxLength
var crypto = global.crypto || global.msCrypto
var kMaxUint32 = Math.pow(2, 32) - 1
function assertOffset (offset, length) {
  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare
    throw new TypeError('offset must be a number')
  }

  if (offset > kMaxUint32 || offset < 0) {
    throw new TypeError('offset must be a uint32')
  }

  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError('offset out of range')
  }
}

function assertSize (size, offset, length) {
  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare
    throw new TypeError('size must be a number')
  }

  if (size > kMaxUint32 || size < 0) {
    throw new TypeError('size must be a uint32')
  }

  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError('buffer too small')
  }
}
if ((crypto && crypto.getRandomValues) || !process.browser) {
  exports.randomFill = randomFill
  exports.randomFillSync = randomFillSync
} else {
  exports.randomFill = oldBrowser
  exports.randomFillSync = oldBrowser
}
function randomFill (buf, offset, size, cb) {
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  if (typeof offset === 'function') {
    cb = offset
    offset = 0
    size = buf.length
  } else if (typeof size === 'function') {
    cb = size
    size = buf.length - offset
  } else if (typeof cb !== 'function') {
    throw new TypeError('"cb" argument must be a function')
  }
  assertOffset(offset, buf.length)
  assertSize(size, offset, buf.length)
  return actualFill(buf, offset, size, cb)
}

function actualFill (buf, offset, size, cb) {
  if (process.browser) {
    var ourBuf = buf.buffer
    var uint = new Uint8Array(ourBuf, offset, size)
    crypto.getRandomValues(uint)
    if (cb) {
      process.nextTick(function () {
        cb(null, buf)
      })
      return
    }
    return buf
  }
  if (cb) {
    randombytes(size, function (err, bytes) {
      if (err) {
        return cb(err)
      }
      bytes.copy(buf, offset)
      cb(null, buf)
    })
    return
  }
  var bytes = randombytes(size)
  bytes.copy(buf, offset)
  return buf
}
function randomFillSync (buf, offset, size) {
  if (typeof offset === 'undefined') {
    offset = 0
  }
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  assertOffset(offset, buf.length)

  if (size === undefined) size = buf.length - offset

  assertSize(size, offset, buf.length)

  return actualFill(buf, offset, size)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/readable-stream/duplex-browser.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/duplex-browser.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");


/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

var Readable = __webpack_require__(/*! ./_stream_readable */ "./node_modules/readable-stream/lib/_stream_readable.js");
var Writable = __webpack_require__(/*! ./_stream_writable */ "./node_modules/readable-stream/lib/_stream_writable.js");

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(/*! ./_stream_transform */ "./node_modules/readable-stream/lib/_stream_transform.js");

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__(/*! events */ "./node_modules/node-libs-browser/node_modules/events/events.js").EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(/*! util */ 1);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ "./node_modules/readable-stream/lib/internal/streams/BufferList.js");
var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(/*! util-deprecate */ "./node_modules/util-deprecate/browser.js")
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../node-libs-browser/node_modules/timers-browserify/main.js */ "./node_modules/node-libs-browser/node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!*************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
var util = __webpack_require__(/*! util */ 2);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! events */ "./node_modules/node-libs-browser/node_modules/events/events.js").EventEmitter;


/***/ }),

/***/ "./node_modules/readable-stream/passthrough.js":
/*!*****************************************************!*\
  !*** ./node_modules/readable-stream/passthrough.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./readable */ "./node_modules/readable-stream/readable-browser.js").PassThrough


/***/ }),

/***/ "./node_modules/readable-stream/readable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ "./node_modules/readable-stream/lib/_stream_readable.js");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");
exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");
exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ "./node_modules/readable-stream/lib/_stream_transform.js");
exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "./node_modules/readable-stream/lib/_stream_passthrough.js");


/***/ }),

/***/ "./node_modules/readable-stream/transform.js":
/*!***************************************************!*\
  !*** ./node_modules/readable-stream/transform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./readable */ "./node_modules/readable-stream/readable-browser.js").Transform


/***/ }),

/***/ "./node_modules/readable-stream/writable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/writable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");


/***/ }),

/***/ "./node_modules/ripemd160/index.js":
/*!*****************************************!*\
  !*** ./node_modules/ripemd160/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! buffer */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var HashBase = __webpack_require__(/*! hash-base */ "./node_modules/hash-base/index.js")

var ARRAY16 = new Array(16)

var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var words = ARRAY16
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

  var al = this._a | 0
  var bl = this._b | 0
  var cl = this._c | 0
  var dl = this._d | 0
  var el = this._e | 0

  var ar = this._a | 0
  var br = this._b | 0
  var cr = this._c | 0
  var dr = this._d | 0
  var er = this._e | 0

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl
    var tr
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
    } else { // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
    }

    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = tl

    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = tr
  }

  // update state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160


/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/node-libs-browser/node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/sha.js/hash.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/hash.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash


/***/ }),

/***/ "./node_modules/sha.js/index.js":
/*!**************************************!*\
  !*** ./node_modules/sha.js/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = __webpack_require__(/*! ./sha */ "./node_modules/sha.js/sha.js")
exports.sha1 = __webpack_require__(/*! ./sha1 */ "./node_modules/sha.js/sha1.js")
exports.sha224 = __webpack_require__(/*! ./sha224 */ "./node_modules/sha.js/sha224.js")
exports.sha256 = __webpack_require__(/*! ./sha256 */ "./node_modules/sha.js/sha256.js")
exports.sha384 = __webpack_require__(/*! ./sha384 */ "./node_modules/sha.js/sha384.js")
exports.sha512 = __webpack_require__(/*! ./sha512 */ "./node_modules/sha.js/sha512.js")


/***/ }),

/***/ "./node_modules/sha.js/sha.js":
/*!************************************!*\
  !*** ./node_modules/sha.js/sha.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha


/***/ }),

/***/ "./node_modules/sha.js/sha1.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/sha1.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1


/***/ }),

/***/ "./node_modules/sha.js/sha224.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha224.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Sha256 = __webpack_require__(/*! ./sha256 */ "./node_modules/sha.js/sha256.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224


/***/ }),

/***/ "./node_modules/sha.js/sha256.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha256.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256


/***/ }),

/***/ "./node_modules/sha.js/sha384.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha384.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var SHA512 = __webpack_require__(/*! ./sha512 */ "./node_modules/sha.js/sha512.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384


/***/ }),

/***/ "./node_modules/sha.js/sha512.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha512.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512


/***/ }),

/***/ "./node_modules/stream-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = __webpack_require__(/*! events */ "./node_modules/node-libs-browser/node_modules/events/events.js").EventEmitter;
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

inherits(Stream, EE);
Stream.Readable = __webpack_require__(/*! readable-stream/readable.js */ "./node_modules/readable-stream/readable-browser.js");
Stream.Writable = __webpack_require__(/*! readable-stream/writable.js */ "./node_modules/readable-stream/writable-browser.js");
Stream.Duplex = __webpack_require__(/*! readable-stream/duplex.js */ "./node_modules/readable-stream/duplex-browser.js");
Stream.Transform = __webpack_require__(/*! readable-stream/transform.js */ "./node_modules/readable-stream/transform.js");
Stream.PassThrough = __webpack_require__(/*! readable-stream/passthrough.js */ "./node_modules/readable-stream/passthrough.js");

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};


/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return -1;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// UTF-8 replacement characters ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd'.repeat(p);
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd'.repeat(p + 1);
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd'.repeat(p + 2);
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character for each buffered byte of a (partial)
// character needs to be added to the output.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd'.repeat(this.lastTotal - this.lastNeed);
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/vm-browserify/index.js":
/*!*********************************************!*\
  !*** ./node_modules/vm-browserify/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var indexOf = __webpack_require__(/*! indexof */ "./node_modules/indexof/index.js");

var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    forEach(Object_keys(ctx), function (key) {
        context[key] = ctx[key];
    });

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./src/core/sketch_support.ts":
/*!************************************!*\
  !*** ./src/core/sketch_support.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function stringToUint8array(b64encoded) {
    var u8 = new Uint8Array(atob(b64encoded)
        .split("")
        .map(function (c) {
        return c.charCodeAt(0);
    }));
    return u8;
}
exports.stringToUint8array = stringToUint8array;
function stringToArray(b64encoded) {
    var u = stringToUint8array(b64encoded);
    var result = new Int16Array(u.buffer);
    return result;
}
exports.stringToArray = stringToArray;
var returnV = false;
var vVal = 0.0;
function gaussRandom() {
    if (returnV) {
        returnV = false;
        return vVal;
    }
    var u = 2 * Math.random() - 1;
    var v = 2 * Math.random() - 1;
    var r = u * u + v * v;
    if (r === 0 || r > 1) {
        return gaussRandom();
    }
    var c = Math.sqrt(-2 * Math.log(r) / r);
    vVal = v * c;
    returnV = true;
    return u * c;
}
exports.gaussRandom = gaussRandom;
function randf(a, b) {
    return Math.random() * (b - a) + a;
}
exports.randf = randf;
function randi(a, b) {
    return Math.floor(Math.random() * (b - a) + a);
}
exports.randi = randi;
function randn(mu, std) {
    return mu + gaussRandom() * std;
}
exports.randn = randn;
function birandn(mu1, mu2, std1, std2, rho) {
    var z1 = randn(0, 1);
    var z2 = randn(0, 1);
    var x = Math.sqrt(1 - rho * rho) * std1 * z1 + rho * std1 * z2 + mu1;
    var y = std2 * z2 + mu2;
    return [x, y];
}
exports.birandn = birandn;
function sampleSoftmax(zSample) {
    var x = randf(0, 1);
    var N = zSample.length;
    var accumulate = 0;
    var i;
    for (i = 0; i < N; i++) {
        accumulate += zSample[i];
        if (accumulate >= x) {
            return i;
        }
    }
    console.log('error sampling pi index');
    return -1;
}
exports.sampleSoftmax = sampleSoftmax;
function simplifyLine(V, tolerance) {
    if (tolerance === void 0) { tolerance = 2.0; }
    var tol = tolerance;
    function diff(u, v) {
        return [u[0] - v[0], u[1] - v[1]];
    }
    function dot(u, v) {
        return u[0] * v[0] + u[1] * v[1];
    }
    function norm2(v) {
        return v[0] * v[0] + v[1] * v[1];
    }
    function d2(u, v) { return norm2(diff(u, v)); }
    function simplifyDP(tol, v, j, k, mk) {
        if (k <= j + 1) {
            return;
        }
        var maxi = j;
        var maxd2 = 0;
        var tol2 = tol * tol;
        var S = [v[j], v[k]];
        var u = diff(S[1], S[0]);
        var cu = norm2(u);
        var w;
        var pb;
        var b, cw, dv2;
        for (var i_1 = j + 1; i_1 < k; i_1++) {
            w = diff(v[i_1], S[0]);
            cw = dot(w, u);
            if (cw <= 0) {
                dv2 = d2(v[i_1], S[0]);
            }
            else if (cu <= cw) {
                dv2 = d2(v[i_1], S[1]);
            }
            else {
                b = cw / cu;
                pb = [S[0][0] + b * u[0], S[0][1] + b * u[1]];
                dv2 = d2(v[i_1], pb);
            }
            if (dv2 <= maxd2) {
                continue;
            }
            maxi = i_1;
            maxd2 = dv2;
        }
        if (maxd2 > tol2) {
            mk[maxi] = 1;
            simplifyDP(tol, v, j, maxi, mk);
            simplifyDP(tol, v, maxi, k, mk);
        }
        return;
    }
    var n = V.length;
    var sV = [];
    var i, k, m, pv;
    var tol2 = tol * tol;
    var vt = [];
    var mk = [];
    vt[0] = V[0];
    for (i = k = 1, pv = 0; i < n; i++) {
        if (d2(V[i], V[pv]) < tol2) {
            continue;
        }
        vt[k++] = V[i];
        pv = i;
    }
    if (pv < n - 1) {
        vt[k++] = V[n - 1];
    }
    mk[0] = mk[k - 1] = 1;
    simplifyDP(tol, vt, 0, k - 1, mk);
    for (i = m = 0; i < k; i++) {
        if (mk[i]) {
            sV[m++] = vt[i];
        }
    }
    return sV;
}
exports.simplifyLine = simplifyLine;
function simplifyLines(lines, tolerance) {
    var result = [];
    var tol = 2.0;
    if (tolerance) {
        tol = tolerance;
    }
    for (var i = 0; i < lines.length; i++) {
        result.push(simplifyLine(lines[i], tol));
    }
    return result;
}
exports.simplifyLines = simplifyLines;
function linesToStrokes(rawData) {
    var x, y;
    var px = 0, py = 0;
    var dx, dy;
    var pon, poff;
    var stroke = [];
    var i, j;
    var len;
    var p;
    for (i = 0; i < rawData.length; i++) {
        len = rawData[i].length;
        if (len > 1) {
            for (j = 0; j < len; j++) {
                p = rawData[i][j];
                x = p[0];
                y = p[1];
                if (j === len - 1) {
                    poff = 1;
                    pon = 0;
                }
                else {
                    poff = 0;
                    pon = 1;
                }
                dx = x - px;
                dy = y - py;
                px = x;
                py = y;
                stroke.push([dx, dy, pon, poff, 0]);
            }
        }
    }
    stroke.push([0, 0, 0, 0, 1]);
    return stroke.slice(1);
}
exports.linesToStrokes = linesToStrokes;
function lineToStroke(line, lastPoint) {
    var pon, poff;
    var stroke = [];
    var len;
    var p;
    var dx, dy;
    var x, y;
    var px, py;
    var j;
    px = lastPoint[0];
    py = lastPoint[1];
    len = line.length;
    if (len > 1) {
        for (j = 0; j < len; j++) {
            p = line[j];
            x = p[0];
            y = p[1];
            if (j === len - 1) {
                poff = 1;
                pon = 0;
            }
            else {
                poff = 0;
                pon = 1;
            }
            dx = x - px;
            dy = y - py;
            px = x;
            py = y;
            stroke.push([dx, dy, pon, poff, 0]);
        }
    }
    return stroke;
}
exports.lineToStroke = lineToStroke;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var tf = __webpack_require__(/*! @tensorflow/tfjs */ "./node_modules/@tensorflow/tfjs/dist/tf.esm.js");
exports.tf = tf;
__export(__webpack_require__(/*! ./sketch_rnn */ "./src/sketch_rnn/index.ts"));


/***/ }),

/***/ "./src/sketch_rnn/index.ts":
/*!*********************************!*\
  !*** ./src/sketch_rnn/index.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var model_1 = __webpack_require__(/*! ./model */ "./src/sketch_rnn/model.ts");
exports.SketchRNN = model_1.SketchRNN;


/***/ }),

/***/ "./src/sketch_rnn/model.ts":
/*!*********************************!*\
  !*** ./src/sketch_rnn/model.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tf = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
var support = __webpack_require__(/*! ../core/sketch_support */ "./src/core/sketch_support.ts");
var SketchRNN = (function () {
    function SketchRNN(checkpointURL) {
        this.NMIXTURE = 20;
        this.checkpointURL = checkpointURL;
        this.initialized = false;
    }
    SketchRNN.prototype.isInitialized = function () {
        return this.initialized;
    };
    SketchRNN.prototype.instantiateFromJSON = function (info, weightDims, weightStrings) {
        this.forgetBias = tf.scalar(1.0);
        this.info = info;
        this.setPixelFactor(2.0);
        this.weightDims = weightDims;
        this.numUnits = this.weightDims[0][0];
        var rawWeights;
        var maxWeight = 10.0;
        this.weights = [];
        for (var i = 0; i < weightStrings.length; i++) {
            rawWeights = new Float32Array(support.stringToArray(weightStrings[i]));
            var N = rawWeights.length;
            for (var j = 0; j < N; j++) {
                rawWeights[j] = maxWeight * rawWeights[j] / 32767;
            }
            this.weights.push(rawWeights);
        }
        this.outputKernel = tf.tensor2d(this.weights[0], [this.weightDims[0][0], this.weightDims[0][1]]);
        this.outputBias = tf.tensor1d(this.weights[1]);
        var lstmKernelXH = tf.tensor2d(this.weights[2], [this.weightDims[2][0], this.weightDims[2][1]]);
        var lstmKernelHH = tf.tensor2d(this.weights[3], [this.weightDims[3][0], this.weightDims[3][1]]);
        var axis = 0;
        this.lstmKernel = tf.concat2d([lstmKernelXH, lstmKernelHH], axis);
        this.lstmBias = tf.tensor1d(this.weights[4]);
        this.rawVars = [
            this.outputKernel,
            this.outputBias,
            this.lstmKernel,
            this.lstmBias
        ];
    };
    SketchRNN.prototype.initialize = function () {
        return __awaiter(this, void 0, void 0, function () {
            var vars;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.dispose();
                        return [4, fetch(this.checkpointURL)
                                .then(function (response) { return response.json(); })];
                    case 1:
                        vars = _a.sent();
                        this.instantiateFromJSON(vars[0], vars[1], vars[2]);
                        this.initialized = true;
                        console.log('Initialized SketchRNN.');
                        return [2];
                }
            });
        });
    };
    SketchRNN.prototype.dispose = function () {
        if (this.rawVars) {
            for (var i = 0; i < this.rawVars.length; i++) {
                this.rawVars[i].dispose();
            }
            this.rawVars = undefined;
        }
        if (this.forgetBias) {
            this.forgetBias.dispose();
            this.forgetBias = undefined;
        }
        this.initialized = false;
    };
    SketchRNN.prototype.setPixelFactor = function (scale) {
        this.pixelFactor = scale;
        this.scaleFactor = this.info.scale_factor / this.pixelFactor;
    };
    SketchRNN.prototype.update = function (stroke, state) {
        var _this = this;
        var out = tf.tidy(function () {
            var numUnits = _this.numUnits;
            var s = _this.scaleFactor;
            var normStroke = [stroke[0] / s, stroke[1] / s, stroke[2], stroke[3], stroke[4]];
            var x = tf.tensor2d(normStroke, [1, 5]);
            var c = tf.tensor2d(state.c, [1, numUnits]);
            var h = tf.tensor2d(state.h, [1, numUnits]);
            var newState = tf.basicLSTMCell(_this.forgetBias, _this.lstmKernel, _this.lstmBias, x, c, h);
            return tf.concat(newState, 1);
        });
        var newCH = out.dataSync();
        out.dispose();
        var newC = newCH.slice(0, this.numUnits);
        var newH = newCH.slice(this.numUnits, this.numUnits * 2);
        var finalState = {
            c: new Float32Array(newC),
            h: new Float32Array(newH)
        };
        return finalState;
    };
    SketchRNN.prototype.updateStrokes = function (strokes, state, steps) {
        var _this = this;
        var out = tf.tidy(function () {
            var numUnits = _this.numUnits;
            var s = _this.scaleFactor;
            var normStroke;
            var x;
            var c;
            var h;
            var newState;
            var numSteps = strokes.length;
            if (steps) {
                numSteps = steps;
            }
            c = tf.tensor2d(state.c, [1, numUnits]);
            h = tf.tensor2d(state.h, [1, numUnits]);
            for (var i = 0; i < numSteps; i++) {
                normStroke = [strokes[i][0] / s,
                    strokes[i][1] / s,
                    strokes[i][2],
                    strokes[i][3],
                    strokes[i][4]];
                x = tf.tensor2d(normStroke, [1, 5]);
                newState = tf.basicLSTMCell(_this.forgetBias, _this.lstmKernel, _this.lstmBias, x, c, h);
                c = newState[0];
                h = newState[1];
            }
            return tf.concat(newState, 1);
        });
        var newCH = out.dataSync();
        out.dispose();
        var newC = newCH.slice(0, this.numUnits);
        var newH = newCH.slice(this.numUnits, this.numUnits * 2);
        var finalState = {
            c: new Float32Array(newC),
            h: new Float32Array(newH)
        };
        return finalState;
    };
    SketchRNN.prototype.getPDF = function (state, temperature, softmaxTemperature) {
        var _this = this;
        if (temperature === void 0) { temperature = 0.65; }
        var temp = temperature;
        var discreteTemp = 0.5 + temp * 0.5;
        if (softmaxTemperature) {
            discreteTemp = softmaxTemperature;
        }
        var NOUT = this.NMIXTURE;
        var out = tf.tidy(function () {
            var numUnits = _this.numUnits;
            var h = tf.tensor2d(state.h, [1, numUnits]);
            var sqrttemp = tf.scalar(Math.sqrt(temp));
            var softtemp = tf.scalar(discreteTemp);
            var z = tf.add(tf.matMul(h, _this.outputKernel), _this.outputBias)
                .squeeze();
            var _a = tf.split(z, [3, NOUT * 6]), rawPen = _a[0], rst = _a[1];
            var _b = tf.split(rst, 6), rawPi = _b[0], mu1 = _b[1], mu2 = _b[2], rawSigma1 = _b[3], rawSigma2 = _b[4], rawCorr = _b[5];
            var pen = tf.softmax(rawPen.div(softtemp));
            var pi = tf.softmax(rawPi.div(softtemp));
            var sigma1 = tf.exp(rawSigma1).mul(sqrttemp);
            var sigma2 = tf.exp(rawSigma2).mul(sqrttemp);
            var corr = tf.tanh(rawCorr);
            var result = [pi, mu1, mu2, sigma1, sigma2, corr, pen];
            return tf.concat(result);
        });
        var result = out.dataSync();
        out.dispose();
        var pdf = {
            pi: new Float32Array(result.slice(0, NOUT)),
            muX: new Float32Array(result.slice(1 * NOUT, 2 * NOUT)),
            muY: new Float32Array(result.slice(2 * NOUT, 3 * NOUT)),
            sigmaX: new Float32Array(result.slice(3 * NOUT, 4 * NOUT)),
            sigmaY: new Float32Array(result.slice(4 * NOUT, 15 * NOUT)),
            corr: new Float32Array(result.slice(5 * NOUT, 6 * NOUT)),
            pen: new Float32Array(result.slice(6 * NOUT, 6 * NOUT + 3))
        };
        return pdf;
    };
    SketchRNN.prototype.zeroState = function () {
        var result = {
            c: new Float32Array(this.numUnits),
            h: new Float32Array(this.numUnits)
        };
        return result;
    };
    SketchRNN.prototype.copyState = function (rnnState) {
        var result = {
            c: new Float32Array(rnnState.c),
            h: new Float32Array(rnnState.h)
        };
        return result;
    };
    SketchRNN.prototype.zeroInput = function () {
        return [0, 0, 1, 0, 0];
    };
    SketchRNN.prototype.sample = function (pdf) {
        var idx = support.sampleSoftmax(pdf.pi);
        var mu1 = pdf.muX[idx];
        var mu2 = pdf.muY[idx];
        var sigma1 = pdf.sigmaX[idx];
        var sigma2 = pdf.sigmaY[idx];
        var corr = pdf.corr[idx];
        var penIdx = support.sampleSoftmax(pdf.pen);
        var penstate = [0, 0, 0];
        penstate[penIdx] = 1;
        var delta = support.birandn(mu1, mu2, sigma1, sigma2, corr);
        var stroke = [
            delta[0] * this.scaleFactor,
            delta[1] * this.scaleFactor,
            penstate[0],
            penstate[1],
            penstate[2]
        ];
        return stroke;
    };
    SketchRNN.prototype.simplifyLine = function (line, tolerance) {
        return support.simplifyLine(line, tolerance);
    };
    SketchRNN.prototype.simplifyLines = function (lines, tolerance) {
        return support.simplifyLines(lines, tolerance);
    };
    SketchRNN.prototype.linesToStroke = function (lines) {
        return support.linesToStrokes(lines);
    };
    SketchRNN.prototype.lineToStroke = function (line, lastPoint) {
        return support.lineToStroke(line, lastPoint);
    };
    return SketchRNN;
}());
exports.SketchRNN = SketchRNN;


/***/ }),

/***/ 0:
/*!****************************!*\
  !*** node-fetch (ignored) ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 2:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 3:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 4:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 5:
/*!****************************!*\
  !*** node-fetch (ignored) ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 6:
/*!********************************!*\
  !*** string_decoder (ignored) ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 7:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vZGVtb3MvcHJlZGljdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC90Zi1jb252ZXJ0ZXIuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC90Zi1jb3JlLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1kYXRhL2Rpc3QvdGYtZGF0YS5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtbGF5ZXJzL2Rpc3QvdGYtbGF5ZXJzLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy9kaXN0L3RmLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvYmFzZS9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvYmFzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9iYXNlL25vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvYmFzZS9yZXBvcnRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9jb25zdGFudHMvZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2NvbnN0YW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9kZWNvZGVycy9kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvZGVjb2RlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvZGVjb2RlcnMvcGVtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL2Rlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9lbmNvZGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9lbmNvZGVycy9wZW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm9yYW5kL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9hZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2F1dGhDaXBoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2RlY3J5cHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvZW5jcnlwdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9naGFzaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvaW5jcjMyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jYmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2NmYi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiMS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiOC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY3RyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9lY2IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9vZmIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL3N0cmVhbUNpcGhlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jaXBoZXIvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1kZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktZGVzL21vZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXJzYS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL2FsZ29zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vYnJvd3Nlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL2Jyb3dzZXIvc2lnbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL2Jyb3dzZXIvdmVyaWZ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9idWZmZXIteG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jaXBoZXItYmFzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jcmVhdGUtZWNkaC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9tZDUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1obWFjL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1obWFjL2xlZ2FjeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rlcy5qcy9saWIvZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZXMuanMvbGliL2Rlcy9jYmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rlcy5qcy9saWIvZGVzL2NpcGhlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVzLmpzL2xpYi9kZXMvZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZXMuanMvbGliL2Rlcy9lZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rlcy5qcy9saWIvZGVzL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWZmaWUtaGVsbG1hbi9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kaWZmaWUtaGVsbG1hbi9saWIvZGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpZmZpZS1oZWxsbWFuL2xpYi9nZW5lcmF0ZVByaW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9iYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvZWR3YXJkcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvbW9udC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL3Nob3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lYy9rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lYy9zaWduYXR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lZGRzYS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VkZHNhL2tleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VkZHNhL3NpZ25hdHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL3ByZWNvbXB1dGVkL3NlY3AyNTZrMS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldnBfYnl0ZXN0b2tleS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC1iYXNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9obWFjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3JpcGVtZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLzEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLzIyNC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMjU2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS8zODQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLzUxMi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvY29tbW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9obWFjLWRyYmcvbGliL2htYWMtZHJiZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5kZXhvZi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWQ1LmpzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9taWxsZXItcmFiaW4vbGliL21yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9taW5pbWFsaXN0aWMtYXNzZXJ0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9taW5pbWFsaXN0aWMtY3J5cHRvLXV0aWxzL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtbGlicy1icm93c2VyL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL2FzbjEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvY2VydGlmaWNhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvZml4UHJvYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGJrZGYyL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bia2RmMi9saWIvYXN5bmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bia2RmMi9saWIvZGVmYXVsdC1lbmNvZGluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGJrZGYyL2xpYi9wcmVjb25kaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bia2RmMi9saWIvc3luYy1icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9tZ2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L3ByaXZhdGVEZWNyeXB0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC9wdWJsaWNFbmNyeXB0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC93aXRoUHVibGljLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wdWJsaWMtZW5jcnlwdC94b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbmRvbWJ5dGVzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbmRvbWZpbGwvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC1icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JpcGVtZDE2MC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9oYXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zaGEuanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGExLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMjI0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMjU2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMzg0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhNTEyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92bS1icm93c2VyaWZ5L2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9za2V0Y2hfc3VwcG9ydC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NrZXRjaF9ybm4vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NrZXRjaF9ybm4vbW9kZWwudHMiLCJ3ZWJwYWNrOi8vL25vZGUtZmV0Y2ggKGlnbm9yZWQpP2VmZDIiLCJ3ZWJwYWNrOi8vL3V0aWwgKGlnbm9yZWQpIiwid2VicGFjazovLy91dGlsIChpZ25vcmVkKT82YTNmIiwid2VicGFjazovLy9idWZmZXIgKGlnbm9yZWQpIiwid2VicGFjazovLy9jcnlwdG8gKGlnbm9yZWQpIiwid2VicGFjazovLy9ub2RlLWZldGNoIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vc3RyaW5nX2RlY29kZXIgKGlnbm9yZWQpIiwid2VicGFjazovLy9mcyAoaWdub3JlZCkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQTBDLGdDQUFnQztBQUMxRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUF3RCxrQkFBa0I7QUFDMUU7QUFDQSx5REFBaUQsY0FBYztBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQXlDLGlDQUFpQztBQUMxRSx3SEFBZ0gsbUJBQW1CLEVBQUU7QUFDckk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7O0FBR0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQix5QkFB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QixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsbURBQW1ELCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsa0RBQWtELCtCQUErQixFQUFFLCtCQUErQixFQUFFLEVBQUUsa0RBQWtELCtCQUErQixFQUFFLCtCQUErQixFQUFFLEVBQUUsOENBQThDLCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsNERBQTRELCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsbURBQW1ELCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLDRCQUE0QixVQUFVLFdBQVcsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsc0RBQXNELCtCQUErQixVQUFVLDBEQUEwRCxFQUFFLDBEQUEwRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLHVFQUF1RSxFQUFFLHVFQUF1RSxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsa0RBQWtELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsaURBQWlELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUscURBQXFELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsbURBQW1ELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixFQUFFLG9DQUFvQyxVQUFVLCtEQUErRCxFQUFFLHFEQUFx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O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDem5CQSxlQUFlLG1CQUFPLENBQUMsNkRBQVU7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVU7QUFDVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3hIQSxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBYzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDekNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLCtEQUFPOzs7Ozs7Ozs7Ozs7QUNsQi9CLGVBQWUsbUJBQU8sQ0FBQyw2REFBVTs7QUFFakMsV0FBVyxtQkFBTyxDQUFDLHNEQUFZO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BCWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN0SkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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RUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDRCQUE0QjtBQUM3QztBQUNBOztBQUVBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsV0FBVztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFdBQVc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxL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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFLE1BQTZCOzs7Ozs7Ozs7Ozs7O0FDbDJHaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsZUFBUTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7Ozs7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHdEQUFhOztBQUVsQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBOztBQUVBLG1CQUFtQixZQUFZO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDbk9BLFVBQVUsbUJBQU8sQ0FBQyxtREFBTztBQUN6QixhQUFhLG1CQUFPLENBQUMsd0RBQWE7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMsd0RBQWE7QUFDckMsZUFBZSxtQkFBTyxDQUFDLDZEQUFVO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQyx1REFBUztBQUM3QixVQUFVLG1CQUFPLENBQUMsc0RBQVk7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLHlEQUFVOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ3BIQSxjQUFjLG1CQUFPLENBQUMsK0RBQWE7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsK0RBQWE7QUFDckMsWUFBWSxtQkFBTyxDQUFDLHdFQUFtQjs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1pBLGlCQUFpQixtQkFBTyxDQUFDLGlFQUFjO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQyx3REFBYTtBQUNsQyxZQUFZLG1CQUFPLENBQUMsNkRBQVM7QUFDN0IsbUJBQW1CLG1CQUFPLENBQUMscUVBQWdCO0FBQzNDLGdCQUFnQixtQkFBTyxDQUFDLHdEQUFhO0FBQ3JDLFVBQVUsbUJBQU8sQ0FBQyxtREFBTztBQUN6QixXQUFXLG1CQUFPLENBQUMsOERBQWdCO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQyw2REFBVTs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMzSEEsWUFBWSxtQkFBTyxDQUFDLDZEQUFTO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLGlFQUFjO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQyx3REFBYTtBQUNsQyxtQkFBbUIsbUJBQU8sQ0FBQyxxRUFBZ0I7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMsd0RBQWE7QUFDckMsVUFBVSxtQkFBTyxDQUFDLG1EQUFPO0FBQ3pCLFdBQVcsbUJBQU8sQ0FBQyw4REFBZ0I7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLDZEQUFVOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2pIQSxhQUFhLG1CQUFPLENBQUMsd0RBQWE7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxR0EsNkRBQWUsbUJBQU8sQ0FBQyx5REFBVTtBQUNqQyxTQUFTLG1CQUFPLENBQUMsNkNBQU87O0FBRXhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFFBQVE7QUFDekIsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFFBQVE7QUFDekIsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsT0FBTztBQUN4QixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUIsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdFhhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxRUFBVTtBQUM5QixlQUFlLG1CQUFPLENBQUMsK0RBQWdCO0FBQ3ZDLFNBQVMsbUJBQU8sQ0FBQyw2Q0FBTztBQUN4QixlQUFlLG1CQUFPLENBQUMsNkRBQVU7QUFDakM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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S0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSyxlQUFlO0FBQ3BCLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4NkJhOztBQUViOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxtREFBUztBQUM1QixlQUFlLG1CQUFPLENBQUMsNERBQWE7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFFBQVEsbUJBQU8sQ0FBQyw4RkFBeUI7QUFDekMsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQzVNWTs7QUFFYixTQUFTLG1CQUFPLENBQUMsNkNBQU87QUFDeEIsZUFBZSxtQkFBTyxDQUFDLDREQUFXO0FBQ2xDLGVBQWUsbUJBQU8sQ0FBQywrREFBZ0I7QUFDdkM7QUFDQTs7QUFFQSxjQUFjLG1CQUFPLENBQUMsNkRBQU87QUFDN0IsZ0JBQWdCLG1CQUFPLENBQUMseUVBQWE7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQiwyQ0FBMkM7QUFDckU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0EsVUFBVSxNQUFNO0FBQ2hCLFVBQVUsb0JBQW9CO0FBQzlCLFVBQVUsbUJBQW1CO0FBQzdCLFVBQVUsZ0JBQWdCO0FBQzFCLFVBQVUsYUFBYTtBQUN2QixVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzd0JhOztBQUViO0FBQ0EsU0FBUyxtQkFBTyxDQUFDLDZDQUFPO0FBQ3hCLGdCQUFnQixtQkFBTyxDQUFDLHdFQUFxQjtBQUM3QyxlQUFlLG1CQUFPLENBQUMsd0ZBQTJCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIs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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUM1dkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwy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LE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxtQkFBTyxDQUFDLDRFQUFpQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RTs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxtREFBbUQsaUVBQWlFO0FBQ3BIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUNBO0FBQ0E7O0FBRUEsaURBQWlELDBGQUEwRjs7QUFFM0k7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBa0I7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7Ozs7Ozs7O0FDOXFCYTs7QUFFYixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2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QUMsNkRBQVU7QUFDakMsV0FBVyxtQkFBTyxDQUFDLDZDQUFRO0FBQzNCLGFBQWEsbUJBQU8sQ0FBQyx3REFBYTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ25RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsbUJBQU8sQ0FBQyw4RUFBUTtBQUN6QixlQUFlLG1CQUFPLENBQUMsNkRBQVU7O0FBRWpDO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsdUZBQTZCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLHVGQUE2QjtBQUN2RCxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMsaUZBQThCO0FBQ3pELHFCQUFxQixtQkFBTyxDQUFDLHFGQUFnQzs7QUFFN0Q7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5SGE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLHdEQUFhOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNDQUFzQyxzQ0FBc0M7QUFDekc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7OztBQzlRQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRUEsY0FBYyxtQkFBTyxDQUFDLGdEQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDeklBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDSUEsU0FBZ0Isa0JBQWtCLENBQUMsVUFBa0I7SUFDbkQsSUFBTSxFQUFFLEdBQWUsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztTQUNuRCxLQUFLLENBQUMsRUFBRSxDQUFDO1NBQ1QsR0FBRyxDQUFDLFVBQUMsQ0FBUztRQUNiLE9BQU8sQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN6QixDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ04sT0FBTyxFQUFFLENBQUM7QUFDWixDQUFDO0FBUEQsZ0RBT0M7QUFRRCxTQUFnQixhQUFhLENBQUMsVUFBa0I7SUFDOUMsSUFBTSxDQUFDLEdBQWUsa0JBQWtCLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDckQsSUFBTSxNQUFNLEdBQWUsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3BELE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUFKRCxzQ0FJQztBQUtELElBQUksT0FBTyxHQUFHLEtBQUssQ0FBQztBQUNwQixJQUFJLElBQUksR0FBRyxHQUFHLENBQUM7QUFDZixTQUFnQixXQUFXO0lBQ3pCLElBQUksT0FBTyxFQUFFO1FBQ1gsT0FBTyxHQUFHLEtBQUssQ0FBQztRQUNoQixPQUFPLElBQUksQ0FBQztLQUNiO0lBQ0QsSUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDaEMsSUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDaEMsSUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3hCLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQ3BCLE9BQU8sV0FBVyxFQUFFLENBQUM7S0FDdEI7SUFDRCxJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDMUMsSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDYixPQUFPLEdBQUcsSUFBSSxDQUFDO0lBQ2YsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2YsQ0FBQztBQWZELGtDQWVDO0FBQ0QsU0FBZ0IsS0FBSyxDQUFDLENBQVMsRUFBRSxDQUFTO0lBQ3hDLE9BQU8sSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNyQyxDQUFDO0FBRkQsc0JBRUM7QUFDRCxTQUFnQixLQUFLLENBQUMsQ0FBUyxFQUFFLENBQVM7SUFDeEMsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNqRCxDQUFDO0FBRkQsc0JBRUM7QUFDRCxTQUFnQixLQUFLLENBQUMsRUFBVSxFQUFFLEdBQVc7SUFDM0MsT0FBTyxFQUFFLEdBQUcsV0FBVyxFQUFFLEdBQUcsR0FBRyxDQUFDO0FBQ2xDLENBQUM7QUFGRCxzQkFFQztBQUVELFNBQWdCLE9BQU8sQ0FDckIsR0FBVyxFQUNYLEdBQVcsRUFDWCxJQUFZLEVBQ1osSUFBWSxFQUNaLEdBQVc7SUFDWCxJQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3ZCLElBQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDdkIsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLElBQUksR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxFQUFFLEdBQUcsR0FBRyxDQUFDO0lBQ3ZFLElBQU0sQ0FBQyxHQUFHLElBQUksR0FBRyxFQUFFLEdBQUcsR0FBRyxDQUFDO0lBQzFCLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDaEIsQ0FBQztBQVhELDBCQVdDO0FBS0QsU0FBZ0IsYUFBYSxDQUFDLE9BQWdDO0lBQzVELElBQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDdEIsSUFBTSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQztJQUN6QixJQUFJLFVBQVUsR0FBRyxDQUFDLENBQUM7SUFDbkIsSUFBSSxDQUFTLENBQUM7SUFDZCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUN0QixVQUFVLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3pCLElBQUksVUFBVSxJQUFJLENBQUMsRUFBRTtZQUNuQixPQUFPLENBQUMsQ0FBQztTQUNWO0tBQ0Y7SUFDRCxPQUFPLENBQUMsR0FBRyxDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDdkMsT0FBTyxDQUFDLENBQUMsQ0FBQztBQUNaLENBQUM7QUFiRCxzQ0FhQztBQUlELFNBQWdCLFlBQVksQ0FBQyxDQUFhLEVBQUUsU0FBYTtJQUFiLDJDQUFhO0lBZXZELElBQU0sR0FBRyxHQUFHLFNBQVMsQ0FBQztJQUV0QixTQUFTLElBQUksQ0FBQyxDQUFXLEVBQUUsQ0FBVztRQUNwQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUNELFNBQVMsR0FBRyxDQUFDLENBQVcsRUFBRSxDQUFXO1FBQ25DLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFDRCxTQUFTLEtBQUssQ0FBQyxDQUFXO1FBQ3hCLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFDRCxTQUFTLEVBQUUsQ0FBQyxDQUFXLEVBQUUsQ0FBVyxJQUFXLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDO0lBRXpFLFNBQVMsVUFBVSxDQUFDLEdBQVcsRUFBRSxDQUFhLEVBQzVDLENBQVMsRUFBRSxDQUFTLEVBQUUsRUFBWTtRQU9sQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ2QsT0FBTztTQUNSO1FBRUQsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDO1FBQ2IsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1FBQ2QsSUFBTSxJQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUN2QixJQUFNLENBQUMsR0FBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuQyxJQUFNLENBQUMsR0FBYSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JDLElBQU0sRUFBRSxHQUFXLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQU01QixJQUFJLENBQVcsQ0FBQztRQUNoQixJQUFJLEVBQVksQ0FBQztRQUNqQixJQUFJLENBQVMsRUFBRSxFQUFVLEVBQUUsR0FBVyxDQUFDO1FBQ3ZDLEtBQUssSUFBSSxHQUFDLEdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUMsRUFBRSxFQUFFO1lBRXRDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3JCLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ2YsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFO2dCQUNYLEdBQUcsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3RCO2lCQUFNLElBQUksRUFBRSxJQUFJLEVBQUUsRUFBRTtnQkFDbkIsR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDdEI7aUJBQU07Z0JBQ0wsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7Z0JBQ1osRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDOUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7YUFDcEI7WUFFRCxJQUFJLEdBQUcsSUFBSSxLQUFLLEVBQUU7Z0JBQ2hCLFNBQVM7YUFDVjtZQUVELElBQUksR0FBRyxHQUFDLENBQUM7WUFDVCxLQUFLLEdBQUcsR0FBRyxDQUFDO1NBQ2I7UUFDRCxJQUFJLEtBQUssR0FBRyxJQUFJLEVBQUU7WUFFaEIsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUViLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDaEMsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztTQUNqQztRQUVELE9BQU87SUFDVCxDQUFDO0lBRUQsSUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQztJQUNuQixJQUFNLEVBQUUsR0FBZSxFQUFFLENBQUM7SUFDMUIsSUFBSSxDQUFTLEVBQUUsQ0FBUyxFQUFFLENBQVMsRUFBRSxFQUFVLENBQUM7SUFDaEQsSUFBTSxJQUFJLEdBQVcsR0FBRyxHQUFHLEdBQUcsQ0FBQztJQUMvQixJQUFNLEVBQUUsR0FBZSxFQUFFLENBQUM7SUFDMUIsSUFBTSxFQUFFLEdBQWEsRUFBRSxDQUFDO0lBR3hCLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDYixLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUNsQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxFQUFFO1lBQzFCLFNBQVM7U0FDVjtRQUNELEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNmLEVBQUUsR0FBRyxDQUFDLENBQUM7S0FDUjtJQUNELElBQUksRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDZCxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0tBQ3BCO0lBR0QsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3RCLFVBQVUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBR2xDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUMxQixJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUNULEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNqQjtLQUNGO0lBQ0QsT0FBTyxFQUFFLENBQUM7QUFDWixDQUFDO0FBckhELG9DQXFIQztBQUtELFNBQWdCLGFBQWEsQ0FBQyxLQUFtQixFQUMvQyxTQUFrQjtJQUNsQixJQUFNLE1BQU0sR0FBaUIsRUFBRSxDQUFDO0lBQ2hDLElBQUksR0FBRyxHQUFHLEdBQUcsQ0FBQztJQUNkLElBQUksU0FBUyxFQUFFO1FBQ2IsR0FBRyxHQUFHLFNBQVMsQ0FBQztLQUNqQjtJQUNELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3JDLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO0tBQzFDO0lBQ0QsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQVhELHNDQVdDO0FBS0QsU0FBZ0IsY0FBYyxDQUFDLE9BQXFCO0lBQ2xELElBQUksQ0FBUyxFQUFFLENBQVMsQ0FBQztJQUN6QixJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUNuQixJQUFJLEVBQVUsRUFBRSxFQUFVLENBQUM7SUFDM0IsSUFBSSxHQUFXLEVBQUUsSUFBWSxDQUFDO0lBQzlCLElBQU0sTUFBTSxHQUFlLEVBQUUsQ0FBQztJQUM5QixJQUFJLENBQVMsRUFBRSxDQUFTLENBQUM7SUFDekIsSUFBSSxHQUFXLENBQUM7SUFDaEIsSUFBSSxDQUFXLENBQUM7SUFDaEIsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ25DLEdBQUcsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO1FBQ3hCLElBQUksR0FBRyxHQUFHLENBQUMsRUFBRTtZQUNYLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUN4QixDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNsQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNULENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ1QsSUFBSSxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUMsRUFBRTtvQkFDakIsSUFBSSxHQUFHLENBQUMsQ0FBQztvQkFDVCxHQUFHLEdBQUcsQ0FBQyxDQUFDO2lCQUNUO3FCQUFNO29CQUNMLElBQUksR0FBRyxDQUFDLENBQUM7b0JBQ1QsR0FBRyxHQUFHLENBQUMsQ0FBQztpQkFDVDtnQkFDRCxFQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDWixFQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDWixFQUFFLEdBQUcsQ0FBQyxDQUFDO2dCQUNQLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBQ1AsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3JDO1NBQ0Y7S0FDRjtJQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM3QixPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDekIsQ0FBQztBQWpDRCx3Q0FpQ0M7QUFLRCxTQUFnQixZQUFZLENBQUMsSUFBZ0IsRUFDM0MsU0FBbUI7SUFDbkIsSUFBSSxHQUFXLEVBQUUsSUFBWSxDQUFDO0lBQzlCLElBQU0sTUFBTSxHQUFlLEVBQUUsQ0FBQztJQUM5QixJQUFJLEdBQVcsQ0FBQztJQUNoQixJQUFJLENBQVcsQ0FBQztJQUNoQixJQUFJLEVBQVUsRUFBRSxFQUFVLENBQUM7SUFDM0IsSUFBSSxDQUFTLEVBQUUsQ0FBUyxDQUFDO0lBQ3pCLElBQUksRUFBVSxFQUFFLEVBQVUsQ0FBQztJQUMzQixJQUFJLENBQVMsQ0FBQztJQUNkLEVBQUUsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbEIsRUFBRSxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNsQixHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUNsQixJQUFJLEdBQUcsR0FBRyxDQUFDLEVBQUU7UUFDWCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN4QixDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ1osQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNULENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDVCxJQUFJLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxFQUFFO2dCQUNqQixJQUFJLEdBQUcsQ0FBQyxDQUFDO2dCQUNULEdBQUcsR0FBRyxDQUFDLENBQUM7YUFDVDtpQkFBTTtnQkFDTCxJQUFJLEdBQUcsQ0FBQyxDQUFDO2dCQUNULEdBQUcsR0FBRyxDQUFDLENBQUM7YUFDVDtZQUNELEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ1osRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDWixFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ1AsRUFBRSxHQUFHLENBQUMsQ0FBQztZQUNQLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNyQztLQUNGO0lBQ0QsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQWpDRCxvQ0FpQ0M7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlTRCx1R0FBdUM7QUFDL0IsZ0JBQUU7QUFFViwrRUFBNkI7Ozs7Ozs7Ozs7Ozs7OztBQ0g3Qiw4RUFBa0M7QUFBMUIscUNBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSWpCLHNIQUE0QztBQUU1QyxnR0FBa0Q7QUF3RWxEO0lBZ0NFLG1CQUFZLGFBQXFCO1FBUHpCLGFBQVEsR0FBRyxFQUFFLENBQUM7UUFRcEIsSUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7UUFDbkMsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7SUFDM0IsQ0FBQztJQUtELGlDQUFhLEdBQWI7UUFDRSxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDMUIsQ0FBQztJQU1PLHVDQUFtQixHQUEzQixVQUE0QixJQUFtQixFQUM3QyxVQUFzQixFQUN0QixhQUF1QjtRQUV2QixJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDakMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztRQUM3QixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEMsSUFBSSxVQUF3QixDQUFDO1FBQzdCLElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQztRQUN2QixJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztRQUNsQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsYUFBYSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUM3QyxVQUFVLEdBQUcsSUFBSSxZQUFZLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZFLElBQU0sQ0FBQyxHQUFXLFVBQVUsQ0FBQyxNQUFNLENBQUM7WUFDcEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDMUIsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO2FBQ25EO1lBQ0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDL0I7UUFDRCxJQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFDN0MsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2xELElBQUksQ0FBQyxVQUFVLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0MsSUFBTSxZQUFZLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUM5QyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbEQsSUFBTSxZQUFZLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUM5QyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbEQsSUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDO1FBQ2YsSUFBSSxDQUFDLFVBQVUsR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUMsWUFBWSxFQUFFLFlBQVksQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ2xFLElBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFN0MsSUFBSSxDQUFDLE9BQU8sR0FBRztZQUNiLElBQUksQ0FBQyxZQUFZO1lBQ2pCLElBQUksQ0FBQyxVQUFVO1lBQ2YsSUFBSSxDQUFDLFVBQVU7WUFDZixJQUFJLENBQUMsUUFBUTtTQUNkLENBQUM7SUFFSixDQUFDO0lBS0ssOEJBQVUsR0FBaEI7Ozs7Ozt3QkFDRSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7d0JBRUYsV0FBTSxLQUFLLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQztpQ0FDekMsSUFBSSxDQUFDLFVBQUMsUUFBUSxJQUFLLGVBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBZixDQUFlLENBQUM7O3dCQURoQyxJQUFJLEdBQUcsU0FDeUI7d0JBRXRDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUVwRCxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQzt3QkFDeEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDOzs7OztLQUN2QztJQUVELDJCQUFPLEdBQVA7UUFDRSxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDaEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUM1QyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO2FBQzNCO1lBQ0QsSUFBSSxDQUFDLE9BQU8sR0FBRyxTQUFTLENBQUM7U0FDMUI7UUFDRCxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDbkIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUMxQixJQUFJLENBQUMsVUFBVSxHQUFHLFNBQVMsQ0FBQztTQUM3QjtRQUNELElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDO0lBQzNCLENBQUM7SUFTRCxrQ0FBYyxHQUFkLFVBQWUsS0FBYTtRQUUxQixJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztRQUN6QixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDL0QsQ0FBQztJQVVELDBCQUFNLEdBQU4sVUFBTyxNQUFnQixFQUFFLEtBQWdCO1FBQXpDLGlCQTJCQztRQTFCQyxJQUFNLEdBQUcsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDO1lBQ2xCLElBQU0sUUFBUSxHQUFHLEtBQUksQ0FBQyxRQUFRLENBQUM7WUFDL0IsSUFBTSxDQUFDLEdBQUcsS0FBSSxDQUFDLFdBQVcsQ0FBQztZQUMzQixJQUFNLFVBQVUsR0FDZCxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzlELElBQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDMUMsSUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDOUMsSUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDOUMsSUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLGFBQWEsQ0FDL0IsS0FBSSxDQUFDLFVBQVUsRUFDZixLQUFJLENBQUMsVUFBVSxFQUNmLEtBQUksQ0FBQyxRQUFRLEVBQ2IsQ0FBQyxFQUNELENBQUMsRUFDRCxDQUFDLENBQUMsQ0FBQztZQUNMLE9BQU8sRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDaEMsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFNLEtBQUssR0FBRyxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDN0IsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2QsSUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzNDLElBQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQzNELElBQU0sVUFBVSxHQUFhO1lBQzNCLENBQUMsRUFBRSxJQUFJLFlBQVksQ0FBQyxJQUFJLENBQUM7WUFDekIsQ0FBQyxFQUFFLElBQUksWUFBWSxDQUFDLElBQUksQ0FBQztTQUMxQixDQUFDO1FBQ0YsT0FBTyxVQUFVLENBQUM7SUFDcEIsQ0FBQztJQWFELGlDQUFhLEdBQWIsVUFBYyxPQUFtQixFQUFFLEtBQWdCLEVBQUUsS0FBYztRQUFuRSxpQkEyQ0M7UUExQ0MsSUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQztZQUNsQixJQUFNLFFBQVEsR0FBRyxLQUFJLENBQUMsUUFBUSxDQUFDO1lBQy9CLElBQU0sQ0FBQyxHQUFHLEtBQUksQ0FBQyxXQUFXLENBQUM7WUFDM0IsSUFBSSxVQUFtQixDQUFDO1lBQ3hCLElBQUksQ0FBYyxDQUFDO1lBQ25CLElBQUksQ0FBYyxDQUFDO1lBQ25CLElBQUksQ0FBYyxDQUFDO1lBQ25CLElBQUksUUFBdUIsQ0FBQztZQUM1QixJQUFJLFFBQVEsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDO1lBQzlCLElBQUksS0FBSyxFQUFFO2dCQUNULFFBQVEsR0FBRyxLQUFLLENBQUM7YUFDbEI7WUFDRCxDQUFDLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDeEMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ3hDLEtBQUssSUFBSSxDQUFDLEdBQUMsQ0FBQyxFQUFDLENBQUMsR0FBQyxRQUFRLEVBQUMsQ0FBQyxFQUFFLEVBQUU7Z0JBQzNCLFVBQVUsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDO29CQUNmLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDO29CQUNmLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ2IsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDYixPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDN0IsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3BDLFFBQVEsR0FBRyxFQUFFLENBQUMsYUFBYSxDQUN6QixLQUFJLENBQUMsVUFBVSxFQUNmLEtBQUksQ0FBQyxVQUFVLEVBQ2YsS0FBSSxDQUFDLFFBQVEsRUFDYixDQUFDLEVBQ0QsQ0FBQyxFQUNELENBQUMsQ0FBQyxDQUFDO2dCQUNMLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hCLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDakI7WUFDRCxPQUFPLEVBQUUsQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ2hDLENBQUMsQ0FBQyxDQUFDO1FBQ0gsSUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQzdCLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNkLElBQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUMzQyxJQUFNLElBQUksR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUMzRCxJQUFNLFVBQVUsR0FBYTtZQUMzQixDQUFDLEVBQUUsSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDO1lBQ3pCLENBQUMsRUFBRSxJQUFJLFlBQVksQ0FBQyxJQUFJLENBQUM7U0FDMUIsQ0FBQztRQUNGLE9BQU8sVUFBVSxDQUFDO0lBQ3BCLENBQUM7SUFhRCwwQkFBTSxHQUFOLFVBQU8sS0FBZ0IsRUFDckIsV0FBZ0IsRUFDaEIsa0JBQTJCO1FBRjdCLGlCQTBDQztRQXpDQyxnREFBZ0I7UUFFaEIsSUFBTSxJQUFJLEdBQUcsV0FBVyxDQUFDO1FBQ3pCLElBQUksWUFBWSxHQUFXLEdBQUcsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDO1FBQzVDLElBQUksa0JBQWtCLEVBQUU7WUFDdEIsWUFBWSxHQUFHLGtCQUFrQixDQUFDO1NBQ25DO1FBQ0QsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUMzQixJQUFNLEdBQUcsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDO1lBQ2xCLElBQU0sUUFBUSxHQUFHLEtBQUksQ0FBQyxRQUFRLENBQUM7WUFDL0IsSUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFFOUMsSUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDNUMsSUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUV6QyxJQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEtBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxLQUFJLENBQUMsVUFBVSxDQUFDO2lCQUMvRCxPQUFPLEVBQUUsQ0FBQztZQUVQLG1DQUF3QyxFQUF2QyxjQUFNLEVBQUUsV0FBK0IsQ0FBQztZQUN6Qyx5QkFBbUUsRUFBbEUsYUFBSyxFQUFFLFdBQUcsRUFBRSxXQUFHLEVBQUUsaUJBQVMsRUFBRSxpQkFBUyxFQUFFLGVBQTJCLENBQUM7WUFDMUUsSUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDN0MsSUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDM0MsSUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDL0MsSUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDL0MsSUFBTSxJQUFJLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUM5QixJQUFNLE1BQU0sR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBRXpELE9BQU8sRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUMzQixDQUFDLENBQUMsQ0FBQztRQUNILElBQU0sTUFBTSxHQUFHLEdBQUcsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUM5QixHQUFHLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDZCxJQUFNLEdBQUcsR0FBYTtZQUNwQixFQUFFLEVBQUUsSUFBSSxZQUFZLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDM0MsR0FBRyxFQUFFLElBQUksWUFBWSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFDLElBQUksRUFBRSxDQUFDLEdBQUMsSUFBSSxDQUFDLENBQUM7WUFDbkQsR0FBRyxFQUFFLElBQUksWUFBWSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFDLElBQUksRUFBRSxDQUFDLEdBQUMsSUFBSSxDQUFDLENBQUM7WUFDbkQsTUFBTSxFQUFFLElBQUksWUFBWSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFDLElBQUksRUFBRSxDQUFDLEdBQUMsSUFBSSxDQUFDLENBQUM7WUFDdEQsTUFBTSxFQUFFLElBQUksWUFBWSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFDLElBQUksRUFBRSxFQUFFLEdBQUMsSUFBSSxDQUFDLENBQUM7WUFDdkQsSUFBSSxFQUFFLElBQUksWUFBWSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFDLElBQUksRUFBRSxDQUFDLEdBQUMsSUFBSSxDQUFDLENBQUM7WUFDcEQsR0FBRyxFQUFFLElBQUksWUFBWSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFDLElBQUksRUFBRSxDQUFDLEdBQUMsSUFBSSxHQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3RELENBQUM7UUFDRixPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFPRCw2QkFBUyxHQUFUO1FBQ0UsSUFBTSxNQUFNLEdBQWE7WUFDdkIsQ0FBQyxFQUFFLElBQUksWUFBWSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7WUFDbEMsQ0FBQyxFQUFFLElBQUksWUFBWSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7U0FDbkMsQ0FBQztRQUNGLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFTRCw2QkFBUyxHQUFULFVBQVUsUUFBbUI7UUFDM0IsSUFBTSxNQUFNLEdBQWE7WUFDdkIsQ0FBQyxFQUFFLElBQUksWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDL0IsQ0FBQyxFQUFFLElBQUksWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7U0FDaEMsQ0FBQztRQUNGLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFPRCw2QkFBUyxHQUFUO1FBQ0UsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN6QixDQUFDO0lBU0QsMEJBQU0sR0FBTixVQUFPLEdBQWM7UUFHbkIsSUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDMUMsSUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN6QixJQUFNLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3pCLElBQU0sTUFBTSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDL0IsSUFBTSxNQUFNLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUMvQixJQUFNLElBQUksR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzNCLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzlDLElBQU0sUUFBUSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUMzQixRQUFRLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3JCLElBQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzlELElBQU0sTUFBTSxHQUFHO1lBQ2IsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXO1lBQzNCLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVztZQUMzQixRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ1gsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNYLFFBQVEsQ0FBQyxDQUFDLENBQUM7U0FDWixDQUFDO1FBQ0YsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQVVELGdDQUFZLEdBQVosVUFBYSxJQUFnQixFQUFFLFNBQWtCO1FBQy9DLE9BQU8sT0FBTyxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQVVELGlDQUFhLEdBQWIsVUFBYyxLQUFtQixFQUFFLFNBQWtCO1FBQ25ELE9BQU8sT0FBTyxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDakQsQ0FBQztJQVNELGlDQUFhLEdBQWIsVUFBYyxLQUFtQjtRQUMvQixPQUFPLE9BQU8sQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQVVELGdDQUFZLEdBQVosVUFBYSxJQUFnQixFQUFFLFNBQW1CO1FBQ2hELE9BQU8sT0FBTyxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVILGdCQUFDO0FBQUQsQ0FBQztBQXhZWSw4QkFBUzs7Ozs7Ozs7Ozs7O0FDL0Z0QixlOzs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7Ozs7OztBQ0FBLGUiLCJmaWxlIjoicHJlZGljdF9idW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL2RlbW9zL3ByZWRpY3QuanNcIik7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4gLyoqXG4gKiBBdXRob3I6IERhdmlkIEhhIDxoYWRhdmlkQGdvb2dsZS5jb20+XG4gKlxuICogQGZpbGVvdmVydmlldyBCYXNpYyBwNS5qcyBza2V0Y2ggdG8gc2hvdyBob3cgdG8gdXNlIHNrZXRjaC1ybm5cbiAqIHRvIGZpbmlzaCBhIGZpeGVkIGluY29tcGxldGUgZHJhd2luZ3MsIGFuZCBsb29wIHRocm91Z2ggbXVsdGlwbGVcbiAqIGVuZGluZ3MgYXV0b21hdGljYWxseS5cbiAqL1xuXG5pbXBvcnQgKiBhcyBtcyBmcm9tICcuLi9zcmMvaW5kZXgnO1xuXG5jb25zdCBza2V0Y2ggPSBmdW5jdGlvbihwKSB7XG4gIC8vIEF2YWlsYWJsZSBTa2V0Y2hSTk4gbW9kZWxzLlxuICBjb25zdCBCQVNFX1VSTCA9ICdodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vcXVpY2tkcmF3LW1vZGVscy9za2V0Y2hSTk4vbW9kZWxzLyc7XG4gIGNvbnN0IGF2YWlsYWJsZU1vZGVscyA9IFsnYmlyZCcsJ2FudCcsJ2FuZ2VsJywnYmVlJywnYmljeWNsZScsJ2ZsYW1pbmdvJywnZmxvd2VyJywnbW9zcXVpdG8nLCdvd2wnLCdzcGlkZXInLCd5b2dhJ107XG4gIGxldCBtb2RlbDtcblxuICAvLyBNb2RlbCBzdGF0ZS5cbiAgbGV0IG1vZGVsU3RhdGU7IC8vIFN0b3JlIHRoZSBoaWRkZW4gc3RhdGVzIG9mIHJubidzIG5ldXJvbnMuXG4gIGxldCB0ZW1wZXJhdHVyZSA9IDAuMjU7IC8vIENvbnRyb2xzIHRoZSBhbW91bnQgb2YgdW5jZXJ0YWludHkgb2YgdGhlIG1vZGVsLlxuICBsZXQgbW9kZWxMb2FkZWQgPSBmYWxzZTtcblxuICBsZXQgZHgsIGR5OyAvLyBPZmZzZXRzIG9mIHRoZSBwZW4gc3Ryb2tlcywgaW4gcGl4ZWxzLlxuICBsZXQgeCwgeTsgLy8gQWJzb2x1dGUgY29vcmRpbmF0ZXMgb24gdGhlIHNjcmVlbiBvZiB3aGVyZSB0aGUgcGVuIGlzLlxuICBsZXQgcGVuID0gWzAsMCwwXTsgLy8gQ3VycmVudCBwZW4gc3RhdGUsIFtwZW5fZG93biwgcGVuX3VwLCBwZW5fZW5kXS5cbiAgbGV0IHByZXZpb3VzUGVuID0gWzEsIDAsIDBdOyAvLyBQcmV2aW91cyBwZW4gc3RhdGUuXG4gIGNvbnN0IFBFTiA9IHtET1dOOiAwLCBVUDogMSwgRU5EOiAyfTtcblxuICAvKlxuICAgKiBNYWluIHA1IGNvZGVcbiAgICovXG4gIHAuc2V0dXAgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBjb250YWluZXJTaXplID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NrZXRjaCcpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vIEluaXRpYWxpemUgdGhlIGNhbnZhcy5cbiAgICBjb25zdCBzY3JlZW5XaWR0aCA9IE1hdGguZmxvb3IoY29udGFpbmVyU2l6ZS53aWR0aCk7XG4gICAgY29uc3Qgc2NyZWVuSGVpZ2h0ID0gcC53aW5kb3dIZWlnaHQgLyAyO1xuICAgIHAuY3JlYXRlQ2FudmFzKHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpO1xuICAgIHAuZnJhbWVSYXRlKDYwKTtcblxuICAgIHNldHVwTmV3RHJhd2luZygpO1xuICAgIGluaXRNb2RlbCgwKTtcbiAgICBpbml0RE9NRWxlbWVudHMoKTtcbiAgfTtcblxuICBwLmRyYXcgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIW1vZGVsTG9hZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZmluaXNoZWQgdGhlIHByZXZpb3VzIGRyYXdpbmcsIHN0YXJ0IGEgbmV3IG9uZS5cbiAgICBpZiAocHJldmlvdXNQZW5bUEVOLkVORF0gPT09IDEpIHtcbiAgICAgIHJlc3RhcnQoKTtcbiAgICB9XG5cbiAgICAvLyBOZXcgc3RhdGUuXG4gICAgY29uc3QgcGRmID0gbW9kZWwuZ2V0UERGKG1vZGVsU3RhdGUsIHRlbXBlcmF0dXJlKTtcbiAgICBbZHgsIGR5LCAuLi5wZW5dID0gbW9kZWwuc2FtcGxlKHBkZik7XG5cbiAgICAvLyBPbmx5IGRyYXcgb24gdGhlIHBhcGVyIGlmIHRoZSBwZW4gaXMgc3RpbGwgdG91Y2hpbmcgdGhlIHBhcGVyLlxuICAgIGlmIChwcmV2aW91c1BlbltQRU4uRE9XTl0gPT0gMSkge1xuICAgICAgcC5saW5lKHgsIHksIHgrZHgsIHkrZHkpOyAvLyBEcmF3IGxpbmUgY29ubmVjdGluZyBwcmV2IHBvaW50IHRvIGN1cnJlbnQgcG9pbnQuXG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBhYnNvbHV0ZSBjb29yZGluYXRlcyBmcm9tIHRoZSBvZmZzZXRzXG4gICAgeCArPSBkeDtcbiAgICB5ICs9IGR5O1xuXG4gICAgLy8gVXBkYXRlIHRoZSBwcmV2aW91cyBwZW4ncyBzdGF0ZSB0byB0aGUgY3VycmVudCBvbmUgd2UganVzdCBzYW1wbGVkLlxuICAgIHByZXZpb3VzUGVuID0gcGVuO1xuICAgIG1vZGVsU3RhdGUgPSBtb2RlbC51cGRhdGUoW2R4LCBkeSwgLi4ucGVuXSwgbW9kZWxTdGF0ZSk7XG4gIH07XG4gICAvKlxuICAgKiBIZWxwZXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVzdGFydCgpIHtcbiAgICAvLyBJbml0aWFsIHN0cm9rZXMgdGhhdCB3ZSB3aWxsIGF0dGVtcHQgdG8gY29udGludWUuXG4gICAgY29uc3Qgc3Ryb2tlcyA9IFtbLTQsMCwxLDAsMF0sWy0xNSw5LDEsMCwwXSxbLTEwLDE3LDEsMCwwXSxbLTEsMjgsMSwwLDBdLFsxNCwxMywxLDAsMF0sWzEyLDQsMSwwLDBdLFsyMiwxLDEsMCwwXSxbMTQsLTExLDEsMCwwXSxbNSwtMTIsMSwwLDBdLFsyLC0xOSwxLDAsMF0sWy0xMiwtMjMsMSwwLDBdLFstMTMsLTcsMSwwLDBdLFstMTQsLTEsMCwxLDBdXTtcblxuICAgIC8vIERyYXcgc3Ryb2tlcy5cbiAgICBzZXR1cE5ld0RyYXdpbmcoKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBkcmF3U3Ryb2tlcyhzdHJva2VzLCB4LCB5KTtcblxuICAgIC8vIEVuY29kZSB0aGUgc3Ryb2tlcyBpbiB0aGUgbW9kZWwuXG4gICAgbGV0IG5ld1N0YXRlID0gbW9kZWwuemVyb1N0YXRlKCk7XG4gICAgbmV3U3RhdGUgPSBtb2RlbC51cGRhdGUobW9kZWwuemVyb0lucHV0KCksIG5ld1N0YXRlKTtcbiAgICBuZXdTdGF0ZSA9IG1vZGVsLnVwZGF0ZVN0cm9rZXMoc3Ryb2tlcywgbmV3U3RhdGUpO1xuXG4gICAgLy8gUmVzZXQgdGhlIGFjdHVhbCBtb2RlbCB3ZSdyZSB1c2luZyB0byB0aGlzIG9uZSB0aGF0IGhhcyB0aGUgZW5jb2RlZCBzdHJva2VzLlxuICAgIG1vZGVsU3RhdGUgPSBtb2RlbC5jb3B5U3RhdGUobmV3U3RhdGUpO1xuXG4gICAgLy8gUmVzZXQgdGhlIHBlbiBzdGF0ZS5cbiAgICB4ID0gbGFzdFBvaW50WzBdO1xuICAgIHkgPSBsYXN0UG9pbnRbMV07XG4gICAgcHJldmlvdXNQZW4gPSBbMCwgMSwgMF07XG5cbiAgICAvLyBSZXNldCB0aGUgbGluZSBjb2xvdXIuXG4gICAgcC5zdHJva2UocC5jb2xvcihwLnJhbmRvbSg2NCwgMjI0KSwgcC5yYW5kb20oNjQsIDIyNCksIHAucmFuZG9tKDY0LCAyMjQpKSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0dXBOZXdEcmF3aW5nKCkge1xuICAgIHAuYmFja2dyb3VuZCgyNTUsIDI1NSwgMjU1LCAyNTUpO1xuICAgIHAuc3Ryb2tlV2VpZ2h0KDMuMCk7XG4gICAgeCA9IHAud2lkdGggLyAyLjA7XG4gICAgeSA9IHAuaGVpZ2h0IC8gMy4wO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdE1vZGVsKGluZGV4KSB7XG4gICAgbW9kZWxMb2FkZWQgPSBmYWxzZTtcbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIG1vZGVsLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgbW9kZWwgPSBuZXcgbXMuU2tldGNoUk5OKGAke0JBU0VfVVJMfSR7YXZhaWxhYmxlTW9kZWxzW2luZGV4XX0uZ2VuLmpzb25gKTtcblxuICAgIFByb21pc2UuYWxsKFttb2RlbC5pbml0aWFsaXplKCldKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgbW9kZWxMb2FkZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5sb2coJ1NrZXRjaFJOTiBtb2RlbCBsb2FkZWQuJyk7XG5cbiAgICAgIC8vIEluaXRpYWxpemUgdGhlIHNjYWxlIGZhY3RvciBmb3IgdGhlIG1vZGVsLiBCaWdnZXIgLT4gbGFyZ2Ugb3V0cHV0c1xuICAgICAgbW9kZWwuc2V0UGl4ZWxGYWN0b3IoNS4wKTtcbiAgICAgIHJlc3RhcnQoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHZlcnkgc2ltaWxhciB0byB0aGUgcC5kcmF3KCkgbG9vcCwgYnV0IGluc3RlYWQgb2ZcbiAgLy8gc2FtcGxpbmcgZnJvbSB0aGUgbW9kZWwsIGl0IHVzZXMgdGhlIGdpdmVuIHNldCBvZiBzdHJva2VzLlxuICBmdW5jdGlvbiBkcmF3U3Ryb2tlcyhzdHJva2VzLCBzdGFydFgsIHN0YXJ0WSkge1xuICAgIHAuc3Ryb2tlKHAuY29sb3IoMjU1LDAsMCkpO1xuXG4gICAgbGV0IHggPSBzdGFydFg7XG4gICAgbGV0IHkgPSBzdGFydFk7XG4gICAgbGV0IGR4LCBkeTtcbiAgICBsZXQgcGVuID0gWzAsMCwwXSwgcHJldmlvdXNQZW4gPSBbMCwwLDBdO1xuICAgIGZvciggbGV0IGkgPSAwOyBpIDwgc3Ryb2tlcy5sZW5ndGg7IGkrKykge1xuICAgICAgW2R4LCBkeSwgLi4ucGVuXSA9IHN0cm9rZXNbaV07XG5cbiAgICAgIGlmIChwcmV2aW91c1BlbltQRU4uRU5EXSA9PSAxKSB7IC8vIEVuZCBvZiBkcmF3aW5nLlxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gT25seSBkcmF3IG9uIHRoZSBwYXBlciBpZiB0aGUgcGVuIGlzIHN0aWxsIHRvdWNoaW5nIHRoZSBwYXBlci5cbiAgICAgIGlmIChwcmV2aW91c1BlbltQRU4uRE9XTl0gPT0gMSkge1xuICAgICAgICBwLmxpbmUoeCwgeSwgeCtkeCwgeStkeSk7XG4gICAgICB9XG4gICAgICB4ICs9IGR4O1xuICAgICAgeSArPSBkeTtcbiAgICAgIHByZXZpb3VzUGVuID0gcGVuO1xuICAgIH1cbiAgICByZXR1cm4gW3gsIHldOyAvLyBGaW5hbCBjb29yZGluYXRlcy5cbiAgfTtcblxuICBmdW5jdGlvbiBpbml0RE9NRWxlbWVudHMoKSB7XG4gICAgLy8gU2V0dXAgdGhlIERPTSBiaXRzLlxuICAgIHNlbGVjdE1vZGVscy5pbm5lckhUTUwgPSBhdmFpbGFibGVNb2RlbHMubWFwKG0gPT4gYDxvcHRpb24+JHttfTwvb3B0aW9uPmApLmpvaW4oJycpO1xuICAgIHNlbGVjdE1vZGVscy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiBpbml0TW9kZWwoc2VsZWN0TW9kZWxzLnNlbGVjdGVkSW5kZXgpKTtcbiAgICBpbnB1dFRlbXBlcmF0dXJlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcbiAgICAgIHRlbXBlcmF0dXJlID0gcGFyc2VGbG9hdChpbnB1dFRlbXBlcmF0dXJlLnZhbHVlKTtcbiAgICAgIHRleHRUZW1wZXJhdHVyZS50ZXh0Q29udGVudCA9IHRlbXBlcmF0dXJlO1xuICAgIH0pO1xuICAgIHRleHRUZW1wZXJhdHVyZS50ZXh0Q29udGVudCA9IGlucHV0VGVtcGVyYXR1cmUudmFsdWUgPSB0ZW1wZXJhdHVyZTtcbiAgfVxufTtcblxubmV3IHA1KHNrZXRjaCwgJ3NrZXRjaCcpO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuaW1wb3J0e0VOVixjb25jYXQsc2xpY2Usc3RhY2ssdGVuc29yLHRpZHksdW5zdGFjayx1dGlsLGlvLFRlbnNvcixhZGQsYWRkTixtb2QsbXVsLGRpdixmbG9vckRpdixzdWIsbWluaW11bSxtYXhpbXVtLHBvdyxzcXVhcmVkRGlmZmVyZW5jZSxhYnMsYWNvcyxhY29zaCxhc2luLGFzaW5oLGF0YW4sYXRhbjIsYXRhbmgsY2VpbCxjb3MsY29zaCxlbHUsZXJmLGV4cCxleHBtMSxmbG9vcixsb2csbG9nMXAsbmVnLHJlY2lwcm9jYWwscmVsdSxyb3VuZCxzZWx1LHNpZ21vaWQsc2luLHNpZ24sc2luaCxzb2Z0cGx1cyxzcXJ0LHNxdWFyZSx0YW5oLHRhbixjbGlwQnlWYWx1ZSxyc3FydCxwcm9kLGxlYWt5UmVsdSxzY2FsYXIsY29udjFkLGNvbnYyZCxjb252MmRUcmFuc3Bvc2UsZGVwdGh3aXNlQ29udjJkLGF2Z1Bvb2wsbWF4UG9vbCxmaWxsLGxpbnNwYWNlLG9uZUhvdCxvbmVzLG9uZXNMaWtlLHJhbmRvbVVuaWZvcm0scmFuZ2UsdHJ1bmNhdGVkTm9ybWFsLHplcm9zLHplcm9zTGlrZSxpbWFnZSx3aGVyZUFzeW5jLHNldGRpZmYxZEFzeW5jLHRvcGssdGVuc29yMWQsZXF1YWwsbm90RXF1YWwsZ3JlYXRlcixncmVhdGVyRXF1YWwsbGVzcyxsZXNzRXF1YWwsbG9naWNhbEFuZCxsb2dpY2FsTm90LGxvZ2ljYWxPcix3aGVyZSxtYXRNdWwsdHJhbnNwb3NlLGJhdGNoTm9ybSxsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbixzb2Z0bWF4LGxvZ1NvZnRtYXgsc3BhcnNlVG9EZW5zZSxtYXgsbWVhbixtaW4sc3VtLGFsbCxhbnksYXJnTWF4LGFyZ01pbixnYXRoZXIscmV2ZXJzZSxzdHJpZGVkU2xpY2UsdGlsZSxzcGxpdCxzY2F0dGVyTkQsZ2F0aGVyTkQsZmZ0LGlmZnQscmZmdCxpcmZmdCxjYXN0LGV4cGFuZERpbXMsc3F1ZWV6ZSxyZXNoYXBlLHBhZCxzcGFjZVRvQmF0Y2hORCxiYXRjaFRvU3BhY2VORCxkZXB0aFRvU3BhY2V9ZnJvbVwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCI7dmFyIERhdGFUeXBlLFNhdmVyRGVmLF9fYXNzaWduPWZ1bmN0aW9uKCl7cmV0dXJuKF9fYXNzaWduPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxhPTEscj1hcmd1bWVudHMubGVuZ3RoO2E8cjthKyspZm9yKHZhciBuIGluIHQ9YXJndW1lbnRzW2FdKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG4pJiYoZVtuXT10W25dKTtyZXR1cm4gZX0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07ZnVuY3Rpb24gX19hd2FpdGVyKGUsdCxhLHIpe3JldHVybiBuZXcoYXx8KGE9UHJvbWlzZSkpKGZ1bmN0aW9uKG4scyl7ZnVuY3Rpb24gbyhlKXt0cnl7aShyLm5leHQoZSkpfWNhdGNoKGUpe3MoZSl9fWZ1bmN0aW9uIHAoZSl7dHJ5e2koci50aHJvdyhlKSl9Y2F0Y2goZSl7cyhlKX19ZnVuY3Rpb24gaShlKXtlLmRvbmU/bihlLnZhbHVlKTpuZXcgYShmdW5jdGlvbih0KXt0KGUudmFsdWUpfSkudGhlbihvLHApfWkoKHI9ci5hcHBseShlLHR8fFtdKSkubmV4dCgpKX0pfWZ1bmN0aW9uIF9fZ2VuZXJhdG9yKGUsdCl7dmFyIGEscixuLHMsbz17bGFiZWw6MCxzZW50OmZ1bmN0aW9uKCl7aWYoMSZuWzBdKXRocm93IG5bMV07cmV0dXJuIG5bMV19LHRyeXM6W10sb3BzOltdfTtyZXR1cm4gcz17bmV4dDpwKDApLHRocm93OnAoMSkscmV0dXJuOnAoMil9LFwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmKHNbU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSkscztmdW5jdGlvbiBwKHMpe3JldHVybiBmdW5jdGlvbihwKXtyZXR1cm4gZnVuY3Rpb24ocyl7aWYoYSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtmb3IoO287KXRyeXtpZihhPTEsciYmKG49MiZzWzBdP3IucmV0dXJuOnNbMF0/ci50aHJvd3x8KChuPXIucmV0dXJuKSYmbi5jYWxsKHIpLDApOnIubmV4dCkmJiEobj1uLmNhbGwocixzWzFdKSkuZG9uZSlyZXR1cm4gbjtzd2l0Y2gocj0wLG4mJihzPVsyJnNbMF0sbi52YWx1ZV0pLHNbMF0pe2Nhc2UgMDpjYXNlIDE6bj1zO2JyZWFrO2Nhc2UgNDpyZXR1cm4gby5sYWJlbCsrLHt2YWx1ZTpzWzFdLGRvbmU6ITF9O2Nhc2UgNTpvLmxhYmVsKysscj1zWzFdLHM9WzBdO2NvbnRpbnVlO2Nhc2UgNzpzPW8ub3BzLnBvcCgpLG8udHJ5cy5wb3AoKTtjb250aW51ZTtkZWZhdWx0OmlmKCEobj0obj1vLnRyeXMpLmxlbmd0aD4wJiZuW24ubGVuZ3RoLTFdKSYmKDY9PT1zWzBdfHwyPT09c1swXSkpe289MDtjb250aW51ZX1pZigzPT09c1swXSYmKCFufHxzWzFdPm5bMF0mJnNbMV08blszXSkpe28ubGFiZWw9c1sxXTticmVha31pZig2PT09c1swXSYmby5sYWJlbDxuWzFdKXtvLmxhYmVsPW5bMV0sbj1zO2JyZWFrfWlmKG4mJm8ubGFiZWw8blsyXSl7by5sYWJlbD1uWzJdLG8ub3BzLnB1c2gocyk7YnJlYWt9blsyXSYmby5vcHMucG9wKCksby50cnlzLnBvcCgpO2NvbnRpbnVlfXM9dC5jYWxsKGUsbyl9Y2F0Y2goZSl7cz1bNixlXSxyPTB9ZmluYWxseXthPW49MH1pZig1JnNbMF0pdGhyb3cgc1sxXTtyZXR1cm57dmFsdWU6c1swXT9zWzFdOnZvaWQgMCxkb25lOiEwfX0oW3MscF0pfX19ZnVuY3Rpb24gZ2V0UGFyYW1WYWx1ZShlLHQsYSxyKXt2YXIgbj10LmlucHV0UGFyYW1zW2VdO2lmKG4mJnZvaWQgMCE9PW4uaW5wdXRJbmRleFN0YXJ0KXt2YXIgcz1uLmlucHV0SW5kZXhTdGFydCxvPTA9PT1uLmlucHV0SW5kZXhFbmQ/dm9pZCAwOnZvaWQgMD09PW4uaW5wdXRJbmRleEVuZD9zKzE6bi5pbnB1dEluZGV4RW5kO2lmKFwidGVuc29yXCI9PT1uLnR5cGUpcmV0dXJuIGdldFRlbnNvcih0LmlucHV0TmFtZXNbbi5pbnB1dEluZGV4U3RhcnRdLGEscik7aWYoXCJ0ZW5zb3JzXCI9PT1uLnR5cGUpcmV0dXJuIHQuaW5wdXROYW1lcy5zbGljZShzLG8pLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZ2V0VGVuc29yKGUsYSxyKX0pO3ZhciBwPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGdldFRlbnNvcih0LmlucHV0TmFtZXMuc2xpY2UocylbMF0sYSxyKS5kYXRhU3luYygpKTtyZXR1cm5cIm51bWJlclwiPT09bi50eXBlP3BbMF06cH12YXIgaT10LmF0dHJQYXJhbXNbZV07cmV0dXJuIGkmJmkudmFsdWV9ZnVuY3Rpb24gZ2V0VGVuc29yKGUsdCxhKXt2YXIgcj1wYXJzZU5vZGVOYW1lKGUpLG49clswXSxzPXJbMV0sbz1hLmN1cnJlbnRDb250ZXh0SWRzLmZpbmQoZnVuY3Rpb24oZSl7cmV0dXJuISF0W2dldE5vZGVOYW1lV2l0aENvbnRleHRJZChuLGUpXX0pO3JldHVybiB2b2lkIDAhPT1vP3RbZ2V0Tm9kZU5hbWVXaXRoQ29udGV4dElkKG4sbyldW3NdOnZvaWQgMH1mdW5jdGlvbiBnZXRUZW5zb3JzRm9yQ3VycmVudENvbnRlbnh0KGUsdCxhKXtyZXR1cm4gdFtnZXROb2RlTmFtZVdpdGhDb250ZXh0SWQoZSxhLmN1cnJlbnRDb250ZXh0SWQpXX1mdW5jdGlvbiBnZXROb2RlTmFtZUFuZEluZGV4KGUsdCl7dmFyIGE9cGFyc2VOb2RlTmFtZShlKSxyPWFbMF0sbj1hWzFdO3JldHVybltnZXROb2RlTmFtZVdpdGhDb250ZXh0SWQocix0JiZ0LmN1cnJlbnRDb250ZXh0SWQpLG5dfWZ1bmN0aW9uIGdldE5vZGVOYW1lV2l0aENvbnRleHRJZChlLHQpe3JldHVybiB0P2UrXCItXCIrdDplfWZ1bmN0aW9uIHBhcnNlTm9kZU5hbWUoZSl7dmFyIHQ9ZS5sYXN0SW5kZXhPZihcIjpcIik7cmV0dXJuLTE9PT10P1tlLDBdOltlLnN1YnN0cmluZygwLHQpLE51bWJlcihlLnN1YnN0cmluZyh0KzEpKV19ZnVuY3Rpb24gc3BsaXQkMShlLHQpe2Zvcih2YXIgYT1bXSxyPTA7cjxlLmxlbmd0aDtyKz10KWEucHVzaChlLnNsaWNlKHIscit0KSk7cmV0dXJuIGF9IWZ1bmN0aW9uKGUpe2VbZS5EVF9JTlZBTElEPTBdPVwiRFRfSU5WQUxJRFwiLGVbZS5EVF9GTE9BVD0xXT1cIkRUX0ZMT0FUXCIsZVtlLkRUX0RPVUJMRT0yXT1cIkRUX0RPVUJMRVwiLGVbZS5EVF9JTlQzMj0zXT1cIkRUX0lOVDMyXCIsZVtlLkRUX1VJTlQ4PTRdPVwiRFRfVUlOVDhcIixlW2UuRFRfSU5UMTY9NV09XCJEVF9JTlQxNlwiLGVbZS5EVF9JTlQ4PTZdPVwiRFRfSU5UOFwiLGVbZS5EVF9TVFJJTkc9N109XCJEVF9TVFJJTkdcIixlW2UuRFRfQ09NUExFWDY0PThdPVwiRFRfQ09NUExFWDY0XCIsZVtlLkRUX0lOVDY0PTldPVwiRFRfSU5UNjRcIixlW2UuRFRfQk9PTD0xMF09XCJEVF9CT09MXCIsZVtlLkRUX1FJTlQ4PTExXT1cIkRUX1FJTlQ4XCIsZVtlLkRUX1FVSU5UOD0xMl09XCJEVF9RVUlOVDhcIixlW2UuRFRfUUlOVDMyPTEzXT1cIkRUX1FJTlQzMlwiLGVbZS5EVF9CRkxPQVQxNj0xNF09XCJEVF9CRkxPQVQxNlwiLGVbZS5EVF9GTE9BVF9SRUY9MTAxXT1cIkRUX0ZMT0FUX1JFRlwiLGVbZS5EVF9ET1VCTEVfUkVGPTEwMl09XCJEVF9ET1VCTEVfUkVGXCIsZVtlLkRUX0lOVDMyX1JFRj0xMDNdPVwiRFRfSU5UMzJfUkVGXCIsZVtlLkRUX1VJTlQ4X1JFRj0xMDRdPVwiRFRfVUlOVDhfUkVGXCIsZVtlLkRUX0lOVDE2X1JFRj0xMDVdPVwiRFRfSU5UMTZfUkVGXCIsZVtlLkRUX0lOVDhfUkVGPTEwNl09XCJEVF9JTlQ4X1JFRlwiLGVbZS5EVF9TVFJJTkdfUkVGPTEwN109XCJEVF9TVFJJTkdfUkVGXCIsZVtlLkRUX0NPTVBMRVg2NF9SRUY9MTA4XT1cIkRUX0NPTVBMRVg2NF9SRUZcIixlW2UuRFRfSU5UNjRfUkVGPTEwOV09XCJEVF9JTlQ2NF9SRUZcIixlW2UuRFRfQk9PTF9SRUY9MTEwXT1cIkRUX0JPT0xfUkVGXCIsZVtlLkRUX1FJTlQ4X1JFRj0xMTFdPVwiRFRfUUlOVDhfUkVGXCIsZVtlLkRUX1FVSU5UOF9SRUY9MTEyXT1cIkRUX1FVSU5UOF9SRUZcIixlW2UuRFRfUUlOVDMyX1JFRj0xMTNdPVwiRFRfUUlOVDMyX1JFRlwiLGVbZS5EVF9CRkxPQVQxNl9SRUY9MTE0XT1cIkRUX0JGTE9BVDE2X1JFRlwifShEYXRhVHlwZXx8KERhdGFUeXBlPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2VbZS5MRUdBQ1k9MF09XCJMRUdBQ1lcIixlW2UuVjE9MV09XCJWMVwiLGVbZS5WMj0yXT1cIlYyXCJ9KGUuQ2hlY2twb2ludEZvcm1hdFZlcnNpb258fChlLkNoZWNrcG9pbnRGb3JtYXRWZXJzaW9uPXt9KSl9KFNhdmVyRGVmfHwoU2F2ZXJEZWY9e30pKTt2YXIganNvbj1be3RmT3BOYW1lOlwiQWRkXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQWRkTlwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsZW5kOjAsbmFtZTpcInRlbnNvcnNcIix0eXBlOlwidGVuc29yc1wifV19LHt0Zk9wTmFtZTpcIkJpYXNBZGRcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTdWJcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSZWFsRGl2XCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRGl2XCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRmxvb3JEaXZcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJNdWxcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJNYXhpbXVtXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiTWluaW11bVwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlBvd1wiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNxdWFyZWREaWZmZXJlbmNlXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTW9kXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRmxvb3JNb2RcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfV0sYXJpdGhtZXRpYz1PYmplY3QuZnJlZXplKHtqc29uOmpzb259KSxqc29uJDE9W3t0Zk9wTmFtZTpcIkFic1wiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQWNvc1wiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQXNpblwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQXRhblwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQXRhbjJcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwieVwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJDZWlsXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJDbGlwQnlWYWx1ZVwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImNsaXBfdmFsdWVfbWluXCIsbmFtZTpcImNsaXBWYWx1ZU1pblwiLHR5cGU6XCJudW1iZXJcIn0se3RmTmFtZTpcImNsaXBfdmFsdWVfbWF4XCIsbmFtZTpcImNsaXBWYWx1ZU1heFwiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJDb3NcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkNvc2hcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkVsdVwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRXhwXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJGbG9vclwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTG9nXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJOZWdcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJlbHVcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJlbHU2XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcImNsaXBWYWx1ZU1pblwiLG5hbWU6XCJjbGlwVmFsdWVNaW5cIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0Zk5hbWU6XCJjbGlwVmFsdWVNYXhcIixuYW1lOlwiY2xpcFZhbHVlTWF4XCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTo2fV19LHt0Zk9wTmFtZTpcIlNlbHVcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNpZ21vaWRcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNpblwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU2luaFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU3FydFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUnNxcnRcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNxdWFyZVwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVGFuXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJUYW5oXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTaWduXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSb3VuZFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRXhwbTFcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxvZzFwXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSZWNpcHJvY2FsXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTb2Z0cGx1c1wiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQXNpbmhcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkFjb3NoXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBdGFuaFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRXJmXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJQcm9kXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4ZXNcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwia2VlcF9kaW1zXCIsbmFtZTpcImtlZXBEaW1zXCIsdHlwZTpcImJvb2xcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxlYWt5UmVsdVwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImFscGhhXCIsbmFtZTpcImFscGhhXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTouMn0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX1dLGJhc2ljTWF0aD1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kMX0pLGpzb24kMj1be3RmT3BOYW1lOlwiTG9vcENvbmRcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJwcmVkXCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlN3aXRjaFwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImRhdGFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJwcmVkXCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIk1lcmdlXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxlbmQ6MCxuYW1lOlwidGVuc29yc1wiLHR5cGU6XCJ0ZW5zb3JzXCJ9XX0se3RmT3BOYW1lOlwiRW50ZXJcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJmcmFtZV9uYW1lXCIsbmFtZTpcImZyYW1lTmFtZVwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImlzX2NvbnN0YW50XCIsbmFtZTpcImlzQ29uc3RhbnRcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIkV4aXRcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTmV4dEl0ZXJhdGlvblwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheVYzXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwic2l6ZVwiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZHR5cGVcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn0se3RmTmFtZTpcImVsZW1lbnRfc2hhcGVcIixuYW1lOlwiZWxlbWVudFNoYXBlXCIsdHlwZTpcInNoYXBlXCJ9LHt0Zk5hbWU6XCJkeW5hbWljX3NpemVcIixuYW1lOlwiZHluYW1pY1NpemVcIix0eXBlOlwiYm9vbFwifSx7dGZOYW1lOlwiY2xlYXJfYWZ0ZXJfcmVhZFwiLG5hbWU6XCJjbGVhckFmdGVyUmVhZFwiLHR5cGU6XCJib29sXCJ9LHt0Zk5hbWU6XCJpZGVudGljYWxfZWxlbWVudF9zaGFwZXNcIixuYW1lOlwiaWRlbnRpY2FsRWxlbWVudFNoYXBlc1wiLHR5cGU6XCJib29sXCJ9LHt0Zk5hbWU6XCJ0ZW5zb3JfYXJyYXlfbmFtZVwiLG5hbWU6XCJuYW1lXCIsdHlwZTpcInN0cmluZ1wifV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5V3JpdGVWM1wiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvckFycmF5SWRcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoxLG5hbWU6XCJpbmRleFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjIsbmFtZTpcInRlbnNvclwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjMsbmFtZTpcImZsb3dJblwiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheVJlYWRWM1wiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvckFycmF5SWRcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoxLG5hbWU6XCJpbmRleFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjIsbmFtZTpcImZsb3dJblwiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZHR5cGVcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlHYXRoZXJWM1wiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvckFycmF5SWRcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoxLG5hbWU6XCJpbmRpY2VzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJmbG93SW5cIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcImR0eXBlXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9LHt0Zk5hbWU6XCJlbGVtZW50X3NoYXBlXCIsbmFtZTpcImVsZW1lbnRTaGFwZVwiLHR5cGU6XCJzaGFwZVwifV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5U2NhdHRlclYzXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjEsbmFtZTpcImluZGljZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjIsbmFtZTpcInRlbnNvclwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjMsbmFtZTpcImZsb3dJblwiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5Q29uY2F0VjNcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JBcnJheUlkXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MSxuYW1lOlwiZmxvd0luXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJkdHlwZVwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifSx7dGZOYW1lOlwiZWxlbWVudF9zaGFwZV9leGNlcHQwXCIsbmFtZTpcImVsZW1lbnRTaGFwZUV4Y2VwdDBcIix0eXBlOlwic2hhcGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlTcGxpdFYzXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjEsbmFtZTpcInRlbnNvclwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcImxlbmd0aHNcIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjMsbmFtZTpcImZsb3dJblwiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5U2l6ZVYzXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjEsbmFtZTpcImZsb3dJblwiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheUNsb3NlVjNcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JBcnJheUlkXCIsdHlwZTpcIm51bWJlclwifV19XSxjb250cm9sPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQyfSksanNvbiQzPVt7dGZPcE5hbWU6XCJBdmdQb29sXCIsY2F0ZWdvcnk6XCJjb252b2x1dGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcInN0cmlkZXNcIixuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwicGFkZGluZ1wiLG5hbWU6XCJwYWRcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJkYXRhX2Zvcm1hdFwiLG5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcImtzaXplXCIsbmFtZTpcImtlcm5lbFNpemVcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTWF4UG9vbFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzdHJpZGVzXCIsbmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcInBhZGRpbmdcIixuYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJrc2l6ZVwiLG5hbWU6XCJrZXJuZWxTaXplXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkNvbnYxRFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZmlsdGVyXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzdHJpZGVcIixuYW1lOlwic3RyaWRlXCIsdHlwZTpcIm51bWJlclwifSx7dGZOYW1lOlwicGFkZGluZ1wiLG5hbWU6XCJwYWRcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJkYXRhX2Zvcm1hdFwiLG5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLGRlZmF1bHRWYWx1ZTpcIk5XQ1wifSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcImRpbGF0aW9uXCIsbmFtZTpcImRpbGF0aW9uXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToxfV19LHt0Zk9wTmFtZTpcIkNvbnYyRFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZmlsdGVyXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcInVzZUN1ZG5uT25HcHVcIixuYW1lOlwidXNlQ3Vkbm5PbkdwdVwiLHR5cGU6XCJib29sXCJ9LHt0Zk5hbWU6XCJkYXRhX2Zvcm1hdFwiLG5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLGRlZmF1bHRWYWx1ZTpcIk5IV0NcIn0se3RmTmFtZTpcImRpbGF0aW9uc1wiLG5hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJDb252MkRCYWNrcHJvcElucHV0XCIsY2F0ZWdvcnk6XCJjb252b2x1dGlvblwiLGlucHV0czpbe3N0YXJ0OjIsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJmaWx0ZXJcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDowLG5hbWU6XCJvdXRwdXRTaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzdHJpZGVzXCIsbmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcInBhZGRpbmdcIixuYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRGVwdGh3aXNlQ29udjJkXCIsY2F0ZWdvcnk6XCJjb252b2x1dGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImlucHV0XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZmlsdGVyXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzdHJpZGVzXCIsbmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcInBhZGRpbmdcIixuYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixkZWZhdWx0VmFsdWU6XCJOSFdDXCJ9LHt0Zk5hbWU6XCJkaWxhdGlvbnNcIixuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiRGVwdGh3aXNlQ29udjJkTmF0aXZlXCIsY2F0ZWdvcnk6XCJjb252b2x1dGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImlucHV0XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZmlsdGVyXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzdHJpZGVzXCIsbmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcInBhZGRpbmdcIixuYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixkZWZhdWx0VmFsdWU6XCJOSFdDXCJ9LHt0Zk5hbWU6XCJkaWxhdGlvbnNcIixuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcIm51bWJlcltdXCJ9XX1dLGNvbnZvbHV0aW9uPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQzfSksanNvbiQ0PVt7dGZPcE5hbWU6XCJGaWxsXCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoxLG5hbWU6XCJ2YWx1ZVwiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIkxpblNwYWNlXCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInN0YXJ0XCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MSxuYW1lOlwic3RvcFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjIsbmFtZTpcIm51bVwiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJPbmVIb3RcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImRlcHRoXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MixuYW1lOlwib25WYWx1ZVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MX0se3N0YXJ0OjMsbmFtZTpcIm9mZlZhbHVlXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfV0sYXR0cnM6W3t0Zk5hbWU6XCJheGlzXCIsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJPbmVzXCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJPbmVzTGlrZVwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJkdHlwZVwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIlJhbmRvbVVuaWZvcm1cIixjYXRlZ29yeTpcImNyZWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwic2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwibWludmFsXCIsbmFtZTpcIm1pbnZhbFwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmTmFtZTpcIm1heHZhbFwiLG5hbWU6XCJtYXh2YWxcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjF9LHt0Zk5hbWU6XCJkdHlwZVwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifSx7dGZOYW1lOlwic2VlZFwiLG5hbWU6XCJzZWVkXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZOYW1lOlwic2VlZDJcIixuYW1lOlwic2VlZDJcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjAsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJUXCIsdHlwZTpcIm51bWJlclwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSYW5nZVwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzdGFydFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjEsbmFtZTpcInN0b3BcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoyLG5hbWU6XCJzdGVwXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfV0sYXR0cnM6W3t0Zk5hbWU6XCJUaWR4XCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiVHJ1bmNhdGVkTm9ybWFsXCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcIm1lYW5zXCIsbmFtZTpcIm1lYW5cIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0Zk5hbWU6XCJzdGRkZXZcIixuYW1lOlwic3RkRGV2XCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToxfSx7dGZOYW1lOlwic2VlZFwiLG5hbWU6XCJzZWVkXCIsdHlwZTpcIm51bWJlclwifSx7dGZOYW1lOlwic2VlZDJcIixuYW1lOlwic2VlZDJcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjAsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwiZHR5cGVcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn0se3RmTmFtZTpcIlRcIixuYW1lOlwiVFwiLHR5cGU6XCJudW1iZXJcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiWmVyb3NcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwic2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIlplcm9zTGlrZVwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX1dLGNyZWF0aW9uPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQ0fSksanNvbiQ1PVt7dGZPcE5hbWU6XCJOb25NYXhTdXBwcmVzc2lvblYyXCIsY2F0ZWdvcnk6XCJkeW5hbWljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYm94ZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJzY29yZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJtYXhPdXRwdXRTaXplXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MyxuYW1lOlwiaW91VGhyZXNob2xkXCIsdHlwZTpcIm51bWJlclwifV19LHt0Zk9wTmFtZTpcIk5vbk1heFN1cHByZXNzaW9uVjNcIixjYXRlZ29yeTpcImR5bmFtaWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJib3hlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInNjb3Jlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcIm1heE91dHB1dFNpemVcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDozLG5hbWU6XCJpb3VUaHJlc2hvbGRcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDo0LG5hbWU6XCJzY29yZVRocmVzaG9sZFwiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJXaGVyZVwiLGNhdGVnb3J5OlwiZHluYW1pY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImNvbmRpdGlvblwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMaXN0RGlmZlwiLGNhdGVnb3J5OlwiZHluYW1pY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJ5XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19XSxkeW5hbWljPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQ1fSksanNvbiQ2PVt7dGZPcE5hbWU6XCJUb3BLVjJcIixjYXRlZ29yeTpcImV2YWx1YXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwia1wiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwic29ydGVkXCIsbmFtZTpcInNvcnRlZFwiLHR5cGU6XCJib29sXCJ9XX1dLGV2YWx1YXRpb249T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDZ9KSxqc29uJDc9W3t0Zk9wTmFtZTpcIlBsYWNlaG9sZGVyV2l0aERlZmF1bHRcIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiZGVmYXVsdFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwic2hhcGVcIixuYW1lOlwic2hhcGVcIix0eXBlOlwic2hhcGVcIn0se3RmTmFtZTpcImR0eXBlXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiUGxhY2Vob2xkZXJcIixjYXRlZ29yeTpcImdyYXBoXCIsYXR0cnM6W3t0Zk5hbWU6XCJzaGFwZVwiLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJzaGFwZVwifSx7dGZOYW1lOlwiZHR5cGVcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJDb25zdFwiLGNhdGVnb3J5OlwiZ3JhcGhcIn0se3RmT3BOYW1lOlwiSWRlbnRpdHlcIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJJZGVudGl0eU5cIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxlbmQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JzXCJ9XX0se3RmT3BOYW1lOlwiU25hcHNob3RcIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJSYW5rXCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiU2l6ZVwiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlNoYXBlXCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiU2hhcGVOXCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsZW5kOjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yc1wifV19LHt0Zk9wTmFtZTpcIlByaW50XCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJkYXRhXCIsdHlwZTpcInRlbnNvcnNcIn1dLGF0dHJzOlt7dGZOYW1lOlwibWVzc2FnZVwiLG5hbWU6XCJtZXNzYWdlXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiZmlyc3RfblwiLG5hbWU6XCJmaXJzdE5cIix0eXBlOlwibnVtYmVyXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwic3VtbWFyaXplXCIsbmFtZTpcInN1bW1hcml6ZVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6M31dfSx7dGZPcE5hbWU6XCJOb09wXCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbXX0se3RmT3BOYW1lOlwiU3RvcEdyYWRpZW50XCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiRmFrZVF1YW50V2l0aE1pbk1heFZhcnNcIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwibWluXCIsbmFtZTpcIm1pblwiLHR5cGU6XCJudW1iZXJcIn0se3RmTmFtZTpcIm1heFwiLG5hbWU6XCJtYXhcIix0eXBlOlwibnVtYmVyXCJ9XX1dLGdyYXBoPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQ3fSksanNvbiQ4PVt7dGZPcE5hbWU6XCJSZXNpemVCaWxpbmVhclwiLGNhdGVnb3J5OlwiaW1hZ2VcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJpbWFnZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJzaXplXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImFsaWduX2Nvcm5lcnNcIixuYW1lOlwiYWxpZ25Db3JuZXJzXCIsdHlwZTpcImJvb2xcIn0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmVzaXplTmVhcmVzdE5laWdoYm9yXCIsY2F0ZWdvcnk6XCJpbWFnZVwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImltYWdlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInNpemVcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwiYWxpZ25fY29ybmVyc1wiLG5hbWU6XCJhbGlnbkNvcm5lcnNcIix0eXBlOlwiYm9vbFwifSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJDcm9wQW5kUmVzaXplXCIsY2F0ZWdvcnk6XCJpbWFnZVwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImltYWdlXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYm94ZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJib3hJbmRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDozLG5hbWU6XCJjcm9wU2l6ZVwiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJtZXRob2RcIixuYW1lOlwibWV0aG9kXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiZXh0cmFwb2xhdGlvbl92YWx1ZVwiLG5hbWU6XCJleHRyYXBvbGF0aW9uVmFsdWVcIix0eXBlOlwibnVtYmVyXCJ9XX1dLGltYWdlJDE9T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDh9KSxqc29uJDk9W3t0Zk9wTmFtZTpcIkVxdWFsXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTm90RXF1YWxcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJHcmVhdGVyXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiR3JlYXRlckVxdWFsXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTGVzc1wiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxlc3NFcXVhbFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxvZ2ljYWxBbmRcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMb2dpY2FsTm90XCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMb2dpY2FsT3JcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTZWxlY3RcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJjb25kaXRpb25cIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfV0sbG9naWNhbD1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kOX0pLGpzb24kMTA9W3t0Zk9wTmFtZTpcIk1hdE11bFwiLGNhdGVnb3J5OlwibWF0cmljZXNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwidHJhbnNwb3NlX2FcIixuYW1lOlwidHJhbnNwb3NlQVwiLHR5cGU6XCJib29sXCIsZGVmYXVsdFZhbHVlOiExfSx7dGZOYW1lOlwidHJhbnNwb3NlX2JcIixuYW1lOlwidHJhbnNwb3NlQlwiLHR5cGU6XCJib29sXCIsZGVmYXVsdFZhbHVlOiExfSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJCYXRjaE1hdE11bFwiLGNhdGVnb3J5OlwibWF0cmljZXNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiYWRqX3hcIixuYW1lOlwidHJhbnNwb3NlQVwiLHR5cGU6XCJib29sXCIsZGVmYXVsdFZhbHVlOiExfSx7dGZOYW1lOlwiYWRqX3lcIixuYW1lOlwidHJhbnNwb3NlQlwiLHR5cGU6XCJib29sXCIsZGVmYXVsdFZhbHVlOiExfSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJUcmFuc3Bvc2VcIixjYXRlZ29yeTpcIm1hdHJpY2VzXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInBlcm1cIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfV0sbWF0cmljZXM9T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDEwfSksanNvbiQxMT1be3RmT3BOYW1lOlwiRnVzZWRCYXRjaE5vcm1cIixjYXRlZ29yeTpcIm5vcm1hbGl6YXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwic2NhbGVcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJvZmZzZXRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDozLG5hbWU6XCJtZWFuXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6NCxuYW1lOlwidmFyaWFuY2VcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImVwc2lsb25cIixuYW1lOlwiZXBzaWxvblwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6LjAwMX0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkZ1c2VkQmF0Y2hOb3JtVjJcIixjYXRlZ29yeTpcIm5vcm1hbGl6YXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwic2NhbGVcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJvZmZzZXRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDozLG5hbWU6XCJtZWFuXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6NCxuYW1lOlwidmFyaWFuY2VcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImVwc2lsb25cIixuYW1lOlwiZXBzaWxvblwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6LjAwMX0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxSTlwiLGNhdGVnb3J5Olwibm9ybWFsaXphdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImRlcHRoX3JhZGl1c1wiLG5hbWU6XCJyYWRpdXNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjV9LHt0Zk5hbWU6XCJiaWFzXCIsbmFtZTpcImJpYXNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjF9LHt0Zk5hbWU6XCJhbHBoYVwiLG5hbWU6XCJhbHBoYVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MX0se3RmTmFtZTpcImJldGFcIixuYW1lOlwiYmV0YVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6LjV9XX0se3RmT3BOYW1lOlwiU29mdG1heFwiLGNhdGVnb3J5Olwibm9ybWFsaXphdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiTG9nU29mdG1heFwiLGNhdGVnb3J5Olwibm9ybWFsaXphdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiU3BhcnNlVG9EZW5zZVwiLGNhdGVnb3J5Olwibm9ybWFsaXphdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInNwYXJzZUluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJvdXRwdXRTaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MixuYW1lOlwic3BhcnNlVmFsdWVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MyxuYW1lOlwiZGVmYXVsdFZhbHVlXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJ2YWxpZGF0ZV9pbmRpY2VzXCIsbmFtZTpcInZhbGlkYXRlSW5kaWNlc1wiLHR5cGU6XCJib29sXCIsZGVmYXVsdFZhbHVlOiEwLG5vdFN1cHBvcnRlZDohMH1dfV0sbm9ybWFsaXphdGlvbj1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kMTF9KSxqc29uJDEyPVt7dGZPcE5hbWU6XCJNYXhcIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImtlZXBfZGltc1wiLG5hbWU6XCJrZWVwRGltc1wiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiTWVhblwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwia2VlcF9kaW1zXCIsbmFtZTpcImtlZXBEaW1zXCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJNaW5cIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImtlZXBfZGltc1wiLG5hbWU6XCJrZWVwRGltc1wiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiU3VtXCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJrZWVwX2RpbXNcIixuYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIkFsbFwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwia2VlcF9kaW1zXCIsbmFtZTpcImtlZXBEaW1zXCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJBbnlcIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImtlZXBfZGltc1wiLG5hbWU6XCJrZWVwRGltc1wiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiQXJnTWF4XCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJBcmdNaW5cIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwifV19LHt0Zk9wTmFtZTpcIlByb2RcIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImtlZXBfZGltc1wiLG5hbWU6XCJrZWVwRGltc1wiLHR5cGU6XCJib29sXCJ9XX1dLHJlZHVjdGlvbj1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kMTJ9KSxqc29uJDEzPVt7dGZPcE5hbWU6XCJDb25jYXRWMlwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsZW5kOi0xLG5hbWU6XCJ0ZW5zb3JzXCIsdHlwZTpcInRlbnNvcnNcIn0se3N0YXJ0Oi0xLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwifV19LHt0Zk9wTmFtZTpcIkNvbmNhdFwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjEsZW5kOjAsbmFtZTpcInRlbnNvcnNcIix0eXBlOlwidGVuc29yc1wifSx7c3RhcnQ6MCxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJHYXRoZXJWMlwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJpbmRpY2VzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH1dfSx7dGZPcE5hbWU6XCJHYXRoZXJcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiYXhpc1wiLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZOYW1lOlwidmFsaWRhdGVfaW5kaWNlc1wiLG5hbWU6XCJ2YWxpZGF0ZUluZGljZXNcIix0eXBlOlwiYm9vbFwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSZXZlcnNlXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImRpbXNcIix0eXBlOlwiYm9vbFwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSZXZlcnNlVjJcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIlNsaWNlXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJlZ2luXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJzaXplXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiU3RyaWRlZFNsaWNlXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJlZ2luXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJlbmRcIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjMsbmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwiYmVnaW5fbWFza1wiLG5hbWU6XCJiZWdpbk1hc2tcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0Zk5hbWU6XCJlbmRfbWFza1wiLG5hbWU6XCJlbmRNYXNrXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZOYW1lOlwibmV3X2F4aXNfbWFza1wiLG5hbWU6XCJuZXdBeGlzTWFza1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmTmFtZTpcImVsbGlwc2lzX21hc2tcIixuYW1lOlwiZWxsaXBzaXNNYXNrXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZOYW1lOlwic2hyaW5rX2F4aXNfbWFza1wiLG5hbWU6XCJzaHJpbmtBeGlzTWFza1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH1dfSx7dGZPcE5hbWU6XCJQYWNrXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxlbmQ6MCxuYW1lOlwidGVuc29yc1wiLHR5cGU6XCJ0ZW5zb3JzXCJ9XSxhdHRyczpbe3RmTmFtZTpcImF4aXNcIixuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH1dfSx7dGZPcE5hbWU6XCJVbnBhY2tcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImF4aXNcIixuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmTmFtZTpcIm51bVwiLG5hbWU6XCJudW1cIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjAsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRpbGVcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwicmVwc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIlNwbGl0XCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3N0YXJ0OjEsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIm51bV9zcGxpdFwiLG5hbWU6XCJudW1PclNpemVTcGxpdHNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjF9XX0se3RmT3BOYW1lOlwiU3BsaXRWXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcIm51bU9yU2l6ZVNwbGl0c1wiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MixuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH1dfSx7dGZPcE5hbWU6XCJTY2F0dGVyTmRcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJpbmRpY2VzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwidmFsdWVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwic2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJHYXRoZXJOZFwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJpbmRpY2VzXCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlNwYXJzZVRvRGVuc2VcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzcGFyc2VJbmRpY2VzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwib3V0cHV0U2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjIsbmFtZTpcInNwYXJzZVZhbHVlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjMsbmFtZTpcImRlZmF1bHRWYWx1ZVwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwidmFsaWRhdGVfaW5kaWNlc1wiLG5hbWU6XCJ2YWxpZGF0ZUluZGljZXNcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMSxub3RTdXBwb3J0ZWQ6ITB9XX1dLHNsaWNlSm9pbj1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kMTN9KSxqc29uJDE0PVt7dGZPcE5hbWU6XCJGRlRcIixjYXRlZ29yeTpcInNwZWN0cmFsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJJRkZUXCIsY2F0ZWdvcnk6XCJzcGVjdHJhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiUkZGVFwiLGNhdGVnb3J5Olwic3BlY3RyYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZmZ0X2xlbmd0aFwiLHR5cGU6XCJudW1iZXJcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiSVJGRlRcIixjYXRlZ29yeTpcInNwZWN0cmFsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImZmdF9sZW5ndGhcIix0eXBlOlwibnVtYmVyXCIsbm90U3VwcG9ydGVkOiEwfV19XSxzcGVjdHJhbD1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kMTR9KSxqc29uJDE1PVt7dGZPcE5hbWU6XCJDYXN0XCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlNyY1RcIixuYW1lOlwic2R0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwiRHN0VFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIkV4cGFuZERpbXNcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiUGFkXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJwYWRkaW5nXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImNvbnN0YW50X3ZhbHVlXCIsbmFtZTpcImNvbnN0YW50VmFsdWVcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9XX0se3RmT3BOYW1lOlwiUGFkVjJcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInBhZGRpbmdcIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjIsbmFtZTpcImNvbnN0YW50VmFsdWVcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9XX0se3RmT3BOYW1lOlwiUmVzaGFwZVwiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwic2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJTcXVlZXplXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImF4aXNcIix0ZkRlcHJlY2F0ZWROYW1lOlwic3F1ZWV6ZV9kaW1zXCIsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJTcGFjZVRvQmF0Y2hORFwiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYmxvY2tTaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MixuYW1lOlwicGFkZGluZ3NcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJCYXRjaFRvU3BhY2VORFwiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYmxvY2tTaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MixuYW1lOlwiY3JvcHNcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJEZXB0aFRvU3BhY2VcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiYmxvY2tfc2l6ZVwiLG5hbWU6XCJibG9ja1NpemVcIix0eXBlOlwibnVtYmVyXCJ9LHt0Zk5hbWU6XCJkYXRhX2Zvcm1hdFwiLG5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wifV19XSx0cmFuc2Zvcm1hdGlvbj1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kMTV9KSxDT05UUk9MX0ZMT1dfT1BTPVtcIlN3aXRjaFwiLFwiTWVyZ2VcIixcIkVudGVyXCIsXCJFeGl0XCIsXCJOZXh0SXRlcmF0aW9uXCJdLERZTkFNSUNfU0hBUEVfT1BTPVtcIk5vbk1heFN1cHByZXNzaW9uVjJcIixcIk5vbk1heFN1cHByZXNzaW9uVjNcIixcIldoZXJlXCJdLE9wZXJhdGlvbk1hcHBlcj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt2YXIgZT1bYXJpdGhtZXRpYyxiYXNpY01hdGgsY29udHJvbCxjb252b2x1dGlvbixjcmVhdGlvbixkeW5hbWljLGV2YWx1YXRpb24sbG9naWNhbCxpbWFnZSQxLGdyYXBoLG1hdHJpY2VzLG5vcm1hbGl6YXRpb24scmVkdWN0aW9uLHNsaWNlSm9pbixzcGVjdHJhbCx0cmFuc2Zvcm1hdGlvbl0sdD1bXS5jb25jYXQuYXBwbHkoW10sZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuanNvbn0pKTt0aGlzLm9wTWFwcGVycz10LnJlZHVjZShmdW5jdGlvbihlLHQpe3JldHVybiBlW3QudGZPcE5hbWVdPXQsZX0se30pfXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIkluc3RhbmNlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pbnN0YW5jZXx8KHRoaXMuX2luc3RhbmNlPW5ldyB0aGlzKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxlLnByb3RvdHlwZS5pc0NvbnRyb2xGbG93PWZ1bmN0aW9uKGUpe3JldHVybiBDT05UUk9MX0ZMT1dfT1BTLnNvbWUoZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT1lLm9wfSl9LGUucHJvdG90eXBlLmlzRHluYW1pY1NoYXBlPWZ1bmN0aW9uKGUpe3JldHVybiBEWU5BTUlDX1NIQVBFX09QUy5zb21lKGZ1bmN0aW9uKHQpe3JldHVybiB0PT09ZS5vcH0pfSxlLnByb3RvdHlwZS50cmFuc2Zvcm1HcmFwaD1mdW5jdGlvbihlKXt2YXIgdD10aGlzLGE9ITEscj0hMSxuPVtdLHM9W10sbz1lLm5vZGUucmVkdWNlKGZ1bmN0aW9uKGUsbyl7cmV0dXJuIGVbby5uYW1lXT10Lm1hcE5vZGUobyksdC5pc0NvbnRyb2xGbG93KG8pJiYoYT0hMCksdC5pc0R5bmFtaWNTaGFwZShvKSYmKHI9ITApLFwiUGxhY2Vob2xkZXJcIj09PW8ub3AmJm4ucHVzaChlW28ubmFtZV0pLFwiQ29uc3RcIj09PW8ub3AmJnMucHVzaChlW28ubmFtZV0pLGV9LHt9KSxwPVtdLGk9W107cmV0dXJuIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9b1tlXTt0LmlucHV0TmFtZXMuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgYT1nZXROb2RlTmFtZUFuZEluZGV4KGUpWzBdO3QuaW5wdXRzLnB1c2gob1thXSksb1thXS5jaGlsZHJlbi5wdXNoKHQpfSksMD09PXQuaW5wdXRzLmxlbmd0aCYmcC5wdXNoKHQpfSksT2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1vW2VdOzA9PT10LmNoaWxkcmVuLmxlbmd0aCYmaS5wdXNoKHQpfSkse25vZGVzOm8saW5wdXRzOnAsb3V0cHV0czppLHdlaWdodHM6cyxwbGFjZWhvbGRlcnM6bix3aXRoQ29udHJvbEZsb3c6YSx3aXRoRHluYW1pY1NoYXBlOnJ9fSxlLnByb3RvdHlwZS5tYXBOb2RlPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsYT10aGlzLm9wTWFwcGVyc1tlLm9wXTtpZih2b2lkIDA9PT1hKXRocm93IG5ldyBFcnJvcihcIlRlbnNvcmZsb3cgT3AgaXMgbm90IHN1cHBvcnRlZDogXCIrZS5vcCk7dmFyIHI9e25hbWU6ZS5uYW1lLG9wOmUub3AsY2F0ZWdvcnk6YS5jYXRlZ29yeSxpbnB1dE5hbWVzOihlLmlucHV0fHxbXSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnN0YXJ0c1dpdGgoXCJeXCIpP2Uuc3Vic3RyKDEpOmV9KSxpbnB1dHM6W10sY2hpbGRyZW46W10saW5wdXRQYXJhbXM6e30sYXR0clBhcmFtczp7fX07cmV0dXJuIG51bGw9PWUuYXR0ciYmKGUuYXR0cj17fSksbnVsbCE9YS5pbnB1dHMmJihyLmlucHV0UGFyYW1zPWEuaW5wdXRzLnJlZHVjZShmdW5jdGlvbihlLHQpe3JldHVybiBlW3QubmFtZV09e3R5cGU6dC50eXBlLGlucHV0SW5kZXhTdGFydDp0LnN0YXJ0LGlucHV0SW5kZXhFbmQ6dC5lbmR9LGV9LHt9KSksbnVsbCE9YS5hdHRycyYmKHIuYXR0clBhcmFtcz1hLmF0dHJzLnJlZHVjZShmdW5jdGlvbihhLHIpe3ZhciBuPXIudHlwZSxzPXZvaWQgMDtzd2l0Y2goci50eXBlKXtjYXNlXCJzdHJpbmdcIjp2b2lkIDA9PT0ocz10LmdldFN0cmluZ1BhcmFtKGUuYXR0cixyLnRmTmFtZSxyLmRlZmF1bHRWYWx1ZSkpJiZyLnRmRGVwcmVjYXRlZE5hbWUmJihzPXQuZ2V0U3RyaW5nUGFyYW0oZS5hdHRyLHIudGZEZXByZWNhdGVkTmFtZSxyLmRlZmF1bHRWYWx1ZSkpO2JyZWFrO2Nhc2VcIm51bWJlclwiOnZvaWQgMD09PShzPXQuZ2V0TnVtYmVyUGFyYW0oZS5hdHRyLHIudGZOYW1lLHIuZGVmYXVsdFZhbHVlfHwwKSkmJnIudGZEZXByZWNhdGVkTmFtZSYmKHM9dC5nZXROdW1iZXJQYXJhbShlLmF0dHIsci50ZkRlcHJlY2F0ZWROYW1lLHIuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwibnVtYmVyW11cIjp2b2lkIDA9PT0ocz10LmdldE51bWVyaWNBcnJheVBhcmFtKGUuYXR0cixyLnRmTmFtZSxyLmRlZmF1bHRWYWx1ZSkpJiZyLnRmRGVwcmVjYXRlZE5hbWUmJihzPXQuZ2V0TnVtZXJpY0FycmF5UGFyYW0oZS5hdHRyLHIudGZEZXByZWNhdGVkTmFtZSxyLmRlZmF1bHRWYWx1ZSkpO2JyZWFrO2Nhc2VcImJvb2xcIjp2b2lkIDA9PT0ocz10LmdldEJvb2xQYXJhbShlLmF0dHIsci50Zk5hbWUsci5kZWZhdWx0VmFsdWUpKSYmci50ZkRlcHJlY2F0ZWROYW1lJiYocz10LmdldEJvb2xQYXJhbShlLmF0dHIsci50ZkRlcHJlY2F0ZWROYW1lLHIuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwic2hhcGVcIjp2b2lkIDA9PT0ocz10LmdldFRlbnNvclNoYXBlUGFyYW0oZS5hdHRyLHIudGZOYW1lLHIuZGVmYXVsdFZhbHVlKSkmJnIudGZEZXByZWNhdGVkTmFtZSYmKHM9dC5nZXRUZW5zb3JTaGFwZVBhcmFtKGUuYXR0cixyLnRmRGVwcmVjYXRlZE5hbWUsci5kZWZhdWx0VmFsdWUpKTticmVhaztjYXNlXCJkdHlwZVwiOnZvaWQgMD09PShzPXQuZ2V0RHR5cGVQYXJhbShlLmF0dHIsci50Zk5hbWUsci5kZWZhdWx0VmFsdWUpKSYmci50ZkRlcHJlY2F0ZWROYW1lJiYocz10LmdldER0eXBlUGFyYW0oZS5hdHRyLHIudGZEZXByZWNhdGVkTmFtZSxyLmRlZmF1bHRWYWx1ZSkpO2JyZWFrO2Nhc2VcInRlbnNvclwiOmNhc2VcInRlbnNvcnNcIjpicmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHBhcmFtIHR5cGU6IFwiK3IudHlwZStcIiBmb3Igb3A6IFwiK2Uub3ApfXJldHVybiBhW3IubmFtZV09e3ZhbHVlOnMsdHlwZTpufSxhfSx7fSkpLHJ9LGUucHJvdG90eXBlLmRlY29kZUJhc2U2ND1mdW5jdGlvbihlKXt2YXIgdD1FTlYuZ2xvYmFsO2lmKHZvaWQgMCE9PXQuYXRvYilyZXR1cm4gdC5hdG9iKGUpO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBCdWZmZXIpcmV0dXJuIG5ldyBCdWZmZXIoZSxcImJhc2U2NFwiKS50b1N0cmluZygpO3Rocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBkZWNvZGUgYmFzZTY0IGluIHRoaXMgZW52aXJvbm1lbnQuIE1pc3NpbmcgYnVpbHQtaW4gYXRvYigpIG9yIEJ1ZmZlcigpXCIpfSxlLnByb3RvdHlwZS5nZXRTdHJpbmdQYXJhbT1mdW5jdGlvbihlLHQsYSxyKXt2b2lkIDA9PT1yJiYocj0hMSk7dmFyIG49ZVt0XTtpZih2b2lkIDAhPT1uKXt2YXIgcz1BcnJheS5pc0FycmF5KG4ucyk/U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLG4ucyk6dGhpcy5kZWNvZGVCYXNlNjQobi5zKTtyZXR1cm4gcj9zOnMudG9Mb3dlckNhc2UoKX1yZXR1cm4gYX0sZS5wcm90b3R5cGUuZ2V0Qm9vbFBhcmFtPWZ1bmN0aW9uKGUsdCxhKXt2YXIgcj1lW3RdO3JldHVybiByP3IuYjphfSxlLnByb3RvdHlwZS5nZXROdW1iZXJQYXJhbT1mdW5jdGlvbihlLHQsYSl7dmFyIHI9ZVt0XXx8e30sbj1yLmk/ci5pOnIuZj9yLmY6YTtyZXR1cm5cIm51bWJlclwiPT10eXBlb2Ygbj9uOnBhcnNlSW50KG4sMTApfSxlLnByb3RvdHlwZS5nZXREdHlwZVBhcmFtPWZ1bmN0aW9uKGUsdCxhKXt2YXIgcj1lW3RdO2lmKHImJnIudHlwZSl7dmFyIG49ci50eXBlO3N3aXRjaChcInN0cmluZ1wiPT10eXBlb2Ygci50eXBlJiYobj1EYXRhVHlwZVtyLnR5cGVdKSxuKXtjYXNlIERhdGFUeXBlLkRUX0ZMT0FUOnJldHVyblwiZmxvYXQzMlwiO2Nhc2UgRGF0YVR5cGUuRFRfSU5UMzI6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgRGF0YVR5cGUuRFRfQk9PTDpyZXR1cm5cImJvb2xcIjtkZWZhdWx0OnJldHVybiBhfX1yZXR1cm4gYX0sZS5wcm90b3R5cGUuZ2V0VGVuc29yU2hhcGVQYXJhbT1mdW5jdGlvbihlLHQsYSl7dmFyIHI9ZVt0XTtpZihyJiZyLnNoYXBlKXtpZihyLnNoYXBlLnVua25vd25SYW5rKXJldHVybjtpZihudWxsIT1yLnNoYXBlLmRpbSlyZXR1cm4gci5zaGFwZS5kaW0ubWFwKGZ1bmN0aW9uKGUpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBlLnNpemU/ZS5zaXplOnBhcnNlSW50KGUuc2l6ZSwxMCl9KX1yZXR1cm4gYX0sZS5wcm90b3R5cGUuZ2V0TnVtZXJpY0FycmF5UGFyYW09ZnVuY3Rpb24oZSx0LGEpe3ZhciByPWVbdF07cmV0dXJuIHI/KHIubGlzdC5mJiZyLmxpc3QuZi5sZW5ndGg/ci5saXN0LmY6ci5saXN0LmkpLm1hcChmdW5jdGlvbihlKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgZT9lOnBhcnNlSW50KGUsMTApfSk6YX0sZX0oKSxleGVjdXRlT3A9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJCaWFzQWRkXCI6Y2FzZVwiQWRkXCI6cmV0dXJuW2FkZChnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIkFkZE5cIjpyZXR1cm5bYWRkTihnZXRQYXJhbVZhbHVlKFwidGVuc29yc1wiLGUsdCxhKSldO2Nhc2VcIkZsb29yTW9kXCI6Y2FzZVwiTW9kXCI6cmV0dXJuW21vZChnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIk11bFwiOnJldHVyblttdWwoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJSZWFsRGl2XCI6Y2FzZVwiRGl2XCI6cmV0dXJuW2RpdihnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIkZsb29yRGl2XCI6cmV0dXJuW2Zsb29yRGl2KGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiU3ViXCI6cmV0dXJuW3N1YihnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIk1pbmltdW1cIjpyZXR1cm5bbWluaW11bShnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIk1heGltdW1cIjpyZXR1cm5bbWF4aW11bShnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIlBvd1wiOnJldHVybltwb3coZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJTcXVhcmVkRGlmZmVyZW5jZVwiOnJldHVybltzcXVhcmVkRGlmZmVyZW5jZShnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0sZXhlY3V0ZU9wJDE9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJBYnNcIjpyZXR1cm5bYWJzKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiQWNvc1wiOnJldHVyblthY29zKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiQWNvc2hcIjpyZXR1cm5bYWNvc2goZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJBc2luXCI6cmV0dXJuW2FzaW4oZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJBc2luaFwiOnJldHVyblthc2luaChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkF0YW5cIjpyZXR1cm5bYXRhbihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkF0YW4yXCI6cmV0dXJuW2F0YW4yKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJ5XCIsZSx0LGEpKV07Y2FzZVwiQXRhbmhcIjpyZXR1cm5bYXRhbmgoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJDZWlsXCI6cmV0dXJuW2NlaWwoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJDb3NcIjpyZXR1cm5bY29zKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiQ29zaFwiOnJldHVybltjb3NoKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiRWx1XCI6cmV0dXJuW2VsdShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkVyZlwiOnJldHVybltlcmYoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJFeHBcIjpyZXR1cm5bZXhwKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiRXhwbTFcIjpyZXR1cm5bZXhwbTEoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJGbG9vclwiOnJldHVybltmbG9vcihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkxvZ1wiOnJldHVybltsb2coZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJMb2cxcFwiOnJldHVybltsb2cxcChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIk5lZ1wiOnJldHVybltuZWcoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJSZWNpcHJvY2FsXCI6cmV0dXJuW3JlY2lwcm9jYWwoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJSZWx1XCI6cmV0dXJuW3JlbHUoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJSb3VuZFwiOnJldHVybltyb3VuZChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlNlbHVcIjpyZXR1cm5bc2VsdShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlNpZ21vaWRcIjpyZXR1cm5bc2lnbW9pZChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlNpblwiOnJldHVybltzaW4oZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJTaWduXCI6cmV0dXJuW3NpZ24oZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJTaW5oXCI6cmV0dXJuW3NpbmgoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJTb2Z0cGx1c1wiOnJldHVybltzb2Z0cGx1cyhnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlNxcnRcIjpyZXR1cm5bc3FydChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlNxdWFyZVwiOnJldHVybltzcXVhcmUoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJUYW5oXCI6cmV0dXJuW3RhbmgoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJUYW5cIjpyZXR1cm5bdGFuKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiUmVsdTZcIjpjYXNlXCJDbGlwQnlWYWx1ZVwiOnJldHVybltjbGlwQnlWYWx1ZShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiY2xpcFZhbHVlTWluXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJjbGlwVmFsdWVNYXhcIixlLHQsYSkpXTtjYXNlXCJSc3FydFwiOnJldHVybltyc3FydChnZXRUZW5zb3IoZS5pbnB1dE5hbWVzWzBdLHQsYSkpXTtjYXNlXCJQcm9kXCI6cmV0dXJuW3Byb2QoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImF4ZXNcIixlLHQsYSkpXTtjYXNlXCJMZWFreVJlbHVcIjpyZXR1cm5bbGVha3lSZWx1KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJhbHBoYVwiLGUsdCxhKSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0sVGVuc29yQXJyYXk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsYSxyLG4scyxvLHApe3RoaXMubmFtZT10LHRoaXMuZHR5cGU9YSx0aGlzLm1heFNpemU9cix0aGlzLmVsZW1lbnRTaGFwZT1uLHRoaXMuaWRlbnRpY2FsRWxlbWVudFNoYXBlcz1zLHRoaXMuZHluYW1pY1NpemU9byx0aGlzLmNsZWFyQWZ0ZXJSZWFkPXAsdGhpcy50ZW5zb3JzPVtdLHRoaXMuY2xvc2VkXz0hMSx0aGlzLmlkPWUubmV4dElkKyt9cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImNsb3NlZFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbG9zZWRffSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGUucHJvdG90eXBlLmNsZWFyQW5kQ2xvc2U9ZnVuY3Rpb24oKXt0aGlzLnRlbnNvcnMuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gZS50ZW5zb3IuZGlzcG9zZSgpfSksdGhpcy50ZW5zb3JzPVtdLHRoaXMuY2xvc2VkXz0hMH0sZS5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRlbnNvcnMubGVuZ3RofSxlLnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKGUpe2lmKHRoaXMuY2xvc2VkXyl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBcIit0aGlzLm5hbWUrXCIgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO2lmKGU8MHx8ZT49dGhpcy50ZW5zb3JzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byByZWFkIGZyb20gaW5kZXggXCIrZStcIiwgYnV0IGFycmF5IHNpemUgaXM6IFwiK3RoaXMudGVuc29ycy5sZW5ndGgpO3ZhciB0PXRoaXMudGVuc29yc1tlXTtpZih0LmNsZWFyZWQpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgXCIrdGhpcy5uYW1lK1wiOiBDb3VsZCBub3QgcmVhZCBpbmRleCBcIitlK1wiIHR3aWNlIGJlY2F1c2UgaXQgd2FzIGNsZWFyZWQgYWZ0ZXIgYSBwcmV2aW91cyByZWFkIChwZXJoYXBzIHRyeSBzZXR0aW5nIGNsZWFyX2FmdGVyX3JlYWQgPSBmYWxzZT8pLlwiKTtyZXR1cm4gdGhpcy5jbGVhckFmdGVyUmVhZCYmKHQuY2xlYXJlZD0hMCksdC5yZWFkPSEwLHQudGVuc29yfSxlLnByb3RvdHlwZS5yZWFkTWFueT1mdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiBlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gdC5yZWFkKGUpfSl9LGUucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKGUsdCl7aWYodGhpcy5jbG9zZWRfKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IFwiK3RoaXMubmFtZStcIiBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cIik7aWYoZTwwfHwhdGhpcy5keW5hbWljU2l6ZSYmZT49dGhpcy5tYXhTaXplKXRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIHdyaXRlIHRvIGluZGV4IFwiK2UrXCIsIGJ1dCBhcnJheSBpcyBub3QgcmVzaXplYWJsZSBhbmQgc2l6ZSBpczogXCIrdGhpcy5tYXhTaXplKTt2YXIgYT10aGlzLnRlbnNvcnNbZV18fHt9O2lmKHQuZHR5cGUhPT10aGlzLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IFwiK3RoaXMubmFtZStcIjogQ291bGQgbm90IHdyaXRlIHRvIFRlbnNvckFycmF5IGluZGV4IFwiK2UrXCIsXFxuICAgICAgICAgIGJlY2F1c2UgdGhlIHZhbHVlIGR0eXBlIGlzIFwiK3QuZHR5cGUrXCIsIGJ1dCBUZW5zb3JBcnJheSBkdHlwZSBpcyBcIit0aGlzLmR0eXBlK1wiLlwiKTtpZigwIT09dGhpcy5zaXplKCl8fG51bGwhPXRoaXMuZWxlbWVudFNoYXBlJiYwIT09dGhpcy5lbGVtZW50U2hhcGUubGVuZ3RofHwodGhpcy5lbGVtZW50U2hhcGU9dC5zaGFwZSksdGhpcy5hc3NlcnRTaGFwZXNNYXRjaEFsbG93VW5kZWZpbmVkU2l6ZSh0aGlzLmVsZW1lbnRTaGFwZSx0LnNoYXBlLFwiVGVuc29yQXJyYXkgXCIrdGhpcy5uYW1lK1wiOiBDb3VsZCBub3Qgd3JpdGUgdG8gVGVuc29yQXJyYXkgaW5kZXggXCIrZStcIi5cIiksYSYmYS5yZWFkKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IFwiK3RoaXMubmFtZStcIjogQ291bGQgbm90IHdyaXRlIHRvIFRlbnNvckFycmF5IGluZGV4IFwiK2UrXCIsIGJlY2F1c2UgaXQgaGFzIGFscmVhZHkgYmVlbiByZWFkLlwiKTtpZihhJiZhLndyaXR0ZW4pdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgXCIrdGhpcy5uYW1lK1wiOiBDb3VsZCBub3Qgd3JpdGUgdG8gVGVuc29yQXJyYXkgaW5kZXggXCIrZStcIiwgYmVjYXVzZSBpdCBoYXMgYWxyZWFkeSBiZWVuIHdyaXR0ZW4uXCIpO2EudGVuc29yPXQsYS53cml0dGVuPSEwLHRoaXMudGVuc29yc1tlXT1hfSxlLnByb3RvdHlwZS53cml0ZU1hbnk9ZnVuY3Rpb24oZSx0KXt2YXIgYT10aGlzO2lmKGUubGVuZ3RoIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgXCIrdGhpcy5uYW1lK1wiOiBjb3VsZCBub3Qgd3JpdGUgbXVsdGlwbGUgdGVuc29ycyxiZWNhdXNlIHRoZSBpbmRleCBzaXplOiBcIitlLmxlbmd0aCtcIiBpcyBub3QgdGhlIHNhbWUgYXMgdGVuc29ycyBzaXplOiBcIit0Lmxlbmd0aCtcIi5cIik7ZS5mb3JFYWNoKGZ1bmN0aW9uKGUscil7cmV0dXJuIGEud3JpdGUoZSx0W3JdKX0pfSxlLnByb3RvdHlwZS5nYXRoZXI9ZnVuY3Rpb24oZSx0KXtpZih0JiZ0IT09dGhpcy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBkdHlwZSBpcyBcIit0aGlzLmR0eXBlK1wiIGJ1dCBnYXRoZXIgcmVxdWVzdGVkIGR0eXBlIFwiK3QpO2lmKCFlKXtlPVtdO2Zvcih2YXIgYT0wO2E8dGhpcy5zaXplKCk7YSsrKWUucHVzaChhKX1pZigwPT09ZS5sZW5ndGgpcmV0dXJuIHRlbnNvcihbXSxbMF0uY29uY2F0KHRoaXMuZWxlbWVudFNoYXBlKSk7dmFyIHI9dGhpcy5yZWFkTWFueShlKTtyZXR1cm4gdGhpcy5hc3NlcnRTaGFwZXNNYXRjaEFsbG93VW5kZWZpbmVkU2l6ZSh0aGlzLmVsZW1lbnRTaGFwZSxyWzBdLnNoYXBlLFwiVGVuc29yQXJyYXkgc2hhcGUgbWlzbWF0Y2g6IFwiKSxzdGFjayhyLDApfSxlLnByb3RvdHlwZS5jb25jYXQ9ZnVuY3Rpb24oZSl7aWYoZSYmZSE9PXRoaXMuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgZHR5cGUgaXMgXCIrdGhpcy5kdHlwZStcIiBidXQgY29uY2F0IHJlcXVlc3RlZCBkdHlwZSBcIitlKTtpZigwPT09dGhpcy5zaXplKCkpcmV0dXJuIHRlbnNvcihbXSxbMF0uY29uY2F0KHRoaXMuZWxlbWVudFNoYXBlKSk7Zm9yKHZhciB0PVtdLGE9MDthPHRoaXMuc2l6ZSgpO2ErKyl0LnB1c2goYSk7dmFyIHI9dGhpcy5yZWFkTWFueSh0KTtyZXR1cm4gdGhpcy5hc3NlcnRTaGFwZXNNYXRjaEFsbG93VW5kZWZpbmVkU2l6ZSh0aGlzLmVsZW1lbnRTaGFwZSxyWzBdLnNoYXBlLFwiVGVuc29yQXJyYXkgc2hhcGUgbWlzbWF0Y2g6IHRlbnNvciBhcnJheSBzaGFwZSAoXCIrdGhpcy5lbGVtZW50U2hhcGUrXCIpIHZzIGZpcnN0IHRlbnNvciBzaGFwZSAoXCIrclswXS5zaGFwZStcIilcIiksY29uY2F0KHIsMCl9LGUucHJvdG90eXBlLnNjYXR0ZXI9ZnVuY3Rpb24oZSx0KXtpZih0LmR0eXBlIT09dGhpcy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBkdHlwZSBpcyBcIit0aGlzLmR0eXBlK1wiIGJ1dCB0ZW5zb3IgaGFzIGR0eXBlIFwiK3QuZHR5cGUpO2lmKGUubGVuZ3RoIT09dC5zaGFwZVswXSl0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBsZW4oaW5kaWNlcykgPT0gdGVuc29yLnNoYXBlWzBdLCBidXQgc2F3OiBcIitlLmxlbmd0aCtcIiB2cy4gXCIrdC5zaGFwZVswXSk7dmFyIGE9TWF0aC5tYXguYXBwbHkoTWF0aCxlKTtpZighdGhpcy5keW5hbWljU2l6ZSYmYT49dGhpcy5tYXhTaXplKXRocm93IG5ldyBFcnJvcihcIk1heCBpbmRleCBtdXN0IGJlIDwgYXJyYXkgc2l6ZSAoXCIrYStcIiAgdnMuIFwiK3RoaXMubWF4U2l6ZStcIilcIik7dGhpcy53cml0ZU1hbnkoZSx1bnN0YWNrKHQsMCkpfSxlLnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbihlLHQpe3ZhciBhPXRoaXM7aWYodC5kdHlwZSE9PXRoaXMuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgZHR5cGUgaXMgXCIrdGhpcy5kdHlwZStcIiBidXQgdGVuc29yIGhhcyBkdHlwZSBcIit0LmR0eXBlKTt2YXIgcj0wLG49ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHIrPWV9KTtpZihyIT09dC5zaGFwZVswXSl0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBzdW0gb2YgbGVuZ3RocyB0byBiZSBlcXVhbCB0b1xcbiAgICAgICAgICB0ZW5zb3Iuc2hhcGVbMF0sIGJ1dCBzdW0gb2YgbGVuZ3RocyBpc1xcbiAgICAgICAgXCIrcitcIiwgYW5kIHRlbnNvcidzIHNoYXBlIGlzOiBcIit0LnNoYXBlKTtpZighdGhpcy5keW5hbWljU2l6ZSYmZS5sZW5ndGghPT10aGlzLm1heFNpemUpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkncyBzaXplIGlzIG5vdCBlcXVhbCB0byB0aGUgc2l6ZSBvZiBsZW5ndGhzIChcIit0aGlzLm1heFNpemUrXCIgdnMuIFwiK2UubGVuZ3RoK1wiKSwgYW5kIHRoZSBUZW5zb3JBcnJheSBpcyBub3QgbWFya2VkIGFzIGR5bmFtaWNhbGx5IHJlc2l6ZWFibGVcIik7dmFyIHM9MD09PXI/MDp0LnNpemUvcixvPVtdO3RpZHkoZnVuY3Rpb24oKXt0PXQucmVzaGFwZShbMSxyLHNdKTtmb3IodmFyIHA9MDtwPGUubGVuZ3RoOysrcCl7dmFyIGk9WzAsMD09PXA/MDpuW3AtMV0sMF0sdT1bMSxlW3BdLHNdO29bcF09c2xpY2UodCxpLHUpLnJlc2hhcGUoYS5lbGVtZW50U2hhcGUpfXJldHVybiBvfSk7Zm9yKHZhciBwPVtdLGk9MDtpPGUubGVuZ3RoO2krKylwW2ldPWk7dGhpcy53cml0ZU1hbnkocCxvKX0sZS5wcm90b3R5cGUuYXNzZXJ0U2hhcGVzTWF0Y2hBbGxvd1VuZGVmaW5lZFNpemU9ZnVuY3Rpb24oZSx0LGEpe3ZvaWQgMD09PWEmJihhPVwiXCIpLHV0aWwuYXNzZXJ0KHRoaXMuc2hhcGVzRXF1YWxBbGxvd1VuZGVmaW5lZFNpemUoZSx0KSxmdW5jdGlvbigpe3JldHVybiBhK1wiIFNoYXBlcyBcIitlK1wiIGFuZCBcIit0K1wiIG11c3QgbWF0Y2hcIn0pfSxlLnByb3RvdHlwZS5zaGFwZXNFcXVhbEFsbG93VW5kZWZpbmVkU2l6ZT1mdW5jdGlvbihlLHQpe2lmKGUubGVuZ3RoIT09dC5sZW5ndGgpcmV0dXJuITE7Zm9yKHZhciBhPTA7YTxlLmxlbmd0aDthKyspaWYoLTEhPT1lW2FdJiYtMSE9PXRbYV0mJmVbYV0hPT10W2FdKXJldHVybiExO3JldHVybiEwfSxlLm5leHRJZD0wLGV9KCk7ZnVuY3Rpb24gZXhlY3V0ZU9wJDIoZSx0LGEpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHIsbixzLG8scCxpLHUsbSxjLGwsZCx5LGYsaCxnLE4seCxiLFYsUCxULE8sdixTLF8sdyxBLEQsRSxJLE0sQyxrLGosejtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihGKXtzd2l0Y2goRi5sYWJlbCl7Y2FzZSAwOnN3aXRjaChlLm9wKXtjYXNlXCJMb29wQ29uZFwiOnJldHVyblszLDFdO2Nhc2VcIlN3aXRjaFwiOnJldHVyblszLDJdO2Nhc2VcIk1lcmdlXCI6cmV0dXJuWzMsNF07Y2FzZVwiRW50ZXJcIjpyZXR1cm5bMyw1XTtjYXNlXCJFeGl0XCI6cmV0dXJuWzMsNl07Y2FzZVwiTmV4dEl0ZXJhdGlvblwiOnJldHVyblszLDddO2Nhc2VcIlRlbnNvckFycmF5VjNcIjpyZXR1cm5bMyw4XTtjYXNlXCJUZW5zb3JBcnJheVdyaXRlVjNcIjpyZXR1cm5bMyw5XTtjYXNlXCJUZW5zb3JBcnJheVJlYWRWM1wiOnJldHVyblszLDEwXTtjYXNlXCJUZW5zb3JBcnJheUdhdGhlclYzXCI6cmV0dXJuWzMsMTFdO2Nhc2VcIlRlbnNvckFycmF5U2NhdHRlclYzXCI6cmV0dXJuWzMsMTJdO2Nhc2VcIlRlbnNvckFycmF5Q29uY2F0VjNcIjpyZXR1cm5bMywxM107Y2FzZVwiVGVuc29yQXJyYXlTcGxpdFYzXCI6cmV0dXJuWzMsMTRdO2Nhc2VcIlRlbnNvckFycmF5U2l6ZVYzXCI6cmV0dXJuWzMsMTVdO2Nhc2VcIlRlbnNvckFycmF5Q2xvc2VWM1wiOnJldHVyblszLDE2XX1yZXR1cm5bMywxN107Y2FzZSAxOnJldHVyblsyLFtnZXRQYXJhbVZhbHVlKFwicHJlZFwiLGUsdCxhKS5jbG9uZSgpXV07Y2FzZSAyOnJldHVybiByPWdldFBhcmFtVmFsdWUoXCJwcmVkXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcImRhdGFcIixlLHQsYSksWzQsci5kYXRhKCldO2Nhc2UgMzpyZXR1cm5bMixGLnNlbnQoKVswXT9bdm9pZCAwLG4uY2xvbmUoKV06W24uY2xvbmUoKSx2b2lkIDBdXTtjYXNlIDQ6cmV0dXJuWzIsKHM9ZS5pbnB1dE5hbWVzLmZpbmQoZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMCE9PWdldFRlbnNvcihlLHQsYSl9KSk/W2dldFRlbnNvcihzLHQsYSkuY2xvbmUoKV06dm9pZCAwXTtjYXNlIDU6cmV0dXJuIG89Z2V0UGFyYW1WYWx1ZShcImZyYW1lTmFtZVwiLGUsdCxhKSxwPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JcIixlLHQsYSksYS5lbnRlckZyYW1lKG8pLFsyLFtwLmNsb25lKCldXTtjYXNlIDY6cmV0dXJuIGk9Z2V0UGFyYW1WYWx1ZShcInRlbnNvclwiLGUsdCxhKSxhLmV4aXRGcmFtZSgpLFsyLFtpLmNsb25lKCldXTtjYXNlIDc6cmV0dXJuIHU9Z2V0UGFyYW1WYWx1ZShcInRlbnNvclwiLGUsdCxhKSxhLm5leHRJdGVyYXRpb24oKSxbMixbdS5jbG9uZSgpXV07Y2FzZSA4OnJldHVybiBtPWdldFBhcmFtVmFsdWUoXCJzaXplXCIsZSx0LGEpLGM9Z2V0UGFyYW1WYWx1ZShcImR0eXBlXCIsZSx0LGEpLGw9Z2V0UGFyYW1WYWx1ZShcImVsZW1lbnRTaGFwZVwiLGUsdCxhKSxkPWdldFBhcmFtVmFsdWUoXCJkeW5hbWljU2l6ZVwiLGUsdCxhKSx5PWdldFBhcmFtVmFsdWUoXCJjbGVhckFmdGVyUmVhZFwiLGUsdCxhKSxmPWdldFBhcmFtVmFsdWUoXCJpZGVudGljYWxFbGVtZW50U2hhcGVzXCIsZSx0LGEpLGg9Z2V0UGFyYW1WYWx1ZShcIm5hbWVcIixlLHQsYSksZz1uZXcgVGVuc29yQXJyYXkoaCxjLG0sbCxmLGQseSksYS5hZGRUZW5zb3JBcnJheShnKSxbMixbc2NhbGFyKGcuaWQpLHNjYWxhcigxKV1dO2Nhc2UgOTpyZXR1cm4gTj1nZXRQYXJhbVZhbHVlKFwidGVuc29yQXJyYXlJZFwiLGUsdCxhKSx4PWdldFBhcmFtVmFsdWUoXCJpbmRleFwiLGUsdCxhKSxiPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JcIixlLHQsYSksYS5nZXRUZW5zb3JBcnJheShOKS53cml0ZSh4LGIpLFsyLFtzY2FsYXIoMSldXTtjYXNlIDEwOnJldHVybiBWPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JBcnJheUlkXCIsZSx0LGEpLFA9Z2V0UGFyYW1WYWx1ZShcImluZGV4XCIsZSx0LGEpLFsyLFthLmdldFRlbnNvckFycmF5KFYpLnJlYWQoUCldXTtjYXNlIDExOnJldHVybiBUPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JBcnJheUlkXCIsZSx0LGEpLE89Z2V0UGFyYW1WYWx1ZShcImluZGljZXNcIixlLHQsYSksdj1nZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixlLHQsYSksWzIsW2EuZ2V0VGVuc29yQXJyYXkoVCkuZ2F0aGVyKE8sdildXTtjYXNlIDEyOnJldHVybiBTPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JBcnJheUlkXCIsZSx0LGEpLF89Z2V0UGFyYW1WYWx1ZShcImluZGljZXNcIixlLHQsYSksdz1nZXRQYXJhbVZhbHVlKFwidGVuc29yXCIsZSx0LGEpLGEuZ2V0VGVuc29yQXJyYXkoUykuc2NhdHRlcihfLHcpLFsyLFtzY2FsYXIoMSldXTtjYXNlIDEzOnJldHVybiBBPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JBcnJheUlkXCIsZSx0LGEpLEQ9YS5nZXRUZW5zb3JBcnJheShBKSxFPWdldFBhcmFtVmFsdWUoXCJkdHlwZVwiLGUsdCxhKSxbMixbRC5jb25jYXQoRSldXTtjYXNlIDE0OnJldHVybiBJPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JBcnJheUlkXCIsZSx0LGEpLE09Z2V0UGFyYW1WYWx1ZShcInRlbnNvclwiLGUsdCxhKSxDPWdldFBhcmFtVmFsdWUoXCJsZW5ndGhzXCIsZSx0LGEpLGEuZ2V0VGVuc29yQXJyYXkoSSkuc3BsaXQoQyxNKSxbMixbc2NhbGFyKDEpXV07Y2FzZSAxNTpyZXR1cm4gaz1nZXRQYXJhbVZhbHVlKFwidGVuc29yQXJyYXlJZFwiLGUsdCxhKSxqPWEuZ2V0VGVuc29yQXJyYXkoayksWzIsW3NjYWxhcihqLnNpemUoKSxcImludDMyXCIpXV07Y2FzZSAxNjpyZXR1cm4gej1nZXRQYXJhbVZhbHVlKFwidGVuc29yQXJyYXlJZFwiLGUsdCxhKSxhLmdldFRlbnNvckFycmF5KHopLmNsZWFyQW5kQ2xvc2UoKSxbMixbXV07Y2FzZSAxNzp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSl9KX12YXIgZXhlY3V0ZU9wJDM9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJDb252MURcIjp2YXIgcj1nZXRQYXJhbVZhbHVlKFwic3RyaWRlXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcInBhZFwiLGUsdCxhKSxzPWdldFBhcmFtVmFsdWUoXCJkYXRhRm9ybWF0XCIsZSx0LGEpLnRvVXBwZXJDYXNlKCksbz1nZXRQYXJhbVZhbHVlKFwiZGlsYXRpb25cIixlLHQsYSk7cmV0dXJuW2NvbnYxZChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiZmlsdGVyXCIsZSx0LGEpLHIsbixzLG8pXTtjYXNlXCJDb252MkRcIjpyPWdldFBhcmFtVmFsdWUoXCJzdHJpZGVzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcInBhZFwiLGUsdCxhKSxzPWdldFBhcmFtVmFsdWUoXCJkYXRhRm9ybWF0XCIsZSx0LGEpLnRvVXBwZXJDYXNlKCk7dmFyIHA9Z2V0UGFyYW1WYWx1ZShcImRpbGF0aW9uc1wiLGUsdCxhKTtyZXR1cm5bY29udjJkKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJmaWx0ZXJcIixlLHQsYSksW3JbMV0sclsyXV0sbixzLFtwWzBdLHBbMV1dKV07Y2FzZVwiQ29udjJEQmFja3Byb3BJbnB1dFwiOmNhc2VcIkNvbnYyZFRyYW5zcG9zZVwiOnZhciBpPWdldFBhcmFtVmFsdWUoXCJvdXRwdXRTaGFwZVwiLGUsdCxhKTtyPWdldFBhcmFtVmFsdWUoXCJzdHJpZGVzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcInBhZFwiLGUsdCxhKTtyZXR1cm5bY29udjJkVHJhbnNwb3NlKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJmaWx0ZXJcIixlLHQsYSksaSxbclsxXSxyWzJdXSxuKV07Y2FzZVwiRGVwdGh3aXNlQ29udjJkTmF0aXZlXCI6Y2FzZVwiRGVwdGh3aXNlQ29udjJkXCI6cj1nZXRQYXJhbVZhbHVlKFwic3RyaWRlc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJwYWRcIixlLHQsYSkscD1nZXRQYXJhbVZhbHVlKFwiZGlsYXRpb25zXCIsZSx0LGEpLHM9Z2V0UGFyYW1WYWx1ZShcImRhdGFGb3JtYXRcIixlLHQsYSkudG9VcHBlckNhc2UoKTtyZXR1cm5bZGVwdGh3aXNlQ29udjJkKGdldFBhcmFtVmFsdWUoXCJpbnB1dFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiZmlsdGVyXCIsZSx0LGEpLFtyWzFdLHJbMl1dLG4scyxbcFswXSxwWzFdXSldO2Nhc2VcIkF2Z1Bvb2xcIjpyPWdldFBhcmFtVmFsdWUoXCJzdHJpZGVzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcInBhZFwiLGUsdCxhKTt2YXIgdT1nZXRQYXJhbVZhbHVlKFwia2VybmVsU2l6ZVwiLGUsdCxhKTtyZXR1cm5bYXZnUG9vbChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxbdVsxXSx1WzJdXSxbclsxXSxyWzJdXSxuKV07Y2FzZVwiTWF4UG9vbFwiOnI9Z2V0UGFyYW1WYWx1ZShcInN0cmlkZXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwicGFkXCIsZSx0LGEpLHU9Z2V0UGFyYW1WYWx1ZShcImtlcm5lbFNpemVcIixlLHQsYSk7cmV0dXJuW21heFBvb2woZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksW3VbMV0sdVsyXV0sW3JbMV0sclsyXV0sbildO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0sZXhlY3V0ZU9wJDQ9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJGaWxsXCI6dmFyIHI9Z2V0UGFyYW1WYWx1ZShcInNoYXBlXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcImR0eXBlXCIsZSx0LGEpLHM9Z2V0UGFyYW1WYWx1ZShcInZhbHVlXCIsZSx0LGEpO3JldHVybltmaWxsKHIscyxuKV07Y2FzZVwiTGluU3BhY2VcIjp2YXIgbz1nZXRQYXJhbVZhbHVlKFwic3RhcnRcIixlLHQsYSkscD1nZXRQYXJhbVZhbHVlKFwic3RvcFwiLGUsdCxhKSxpPWdldFBhcmFtVmFsdWUoXCJudW1cIixlLHQsYSk7cmV0dXJuW2xpbnNwYWNlKG8scCxpKV07Y2FzZVwiT25lSG90XCI6dmFyIHU9Z2V0UGFyYW1WYWx1ZShcImluZGljZXNcIixlLHQsYSksbT1nZXRQYXJhbVZhbHVlKFwiZGVwdGhcIixlLHQsYSksYz1nZXRQYXJhbVZhbHVlKFwib25WYWx1ZVwiLGUsdCxhKSxsPWdldFBhcmFtVmFsdWUoXCJvZmZWYWx1ZVwiLGUsdCxhKTtyZXR1cm5bb25lSG90KHUsbSxjLGwpXTtjYXNlXCJPbmVzXCI6cmV0dXJuW29uZXMoZ2V0UGFyYW1WYWx1ZShcInNoYXBlXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJkdHlwZVwiLGUsdCxhKSldO2Nhc2VcIk9uZXNMaWtlXCI6cmV0dXJuW29uZXNMaWtlKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiUmFuZG9tVW5pZm9ybVwiOnJldHVybltyYW5kb21Vbmlmb3JtKGdldFBhcmFtVmFsdWUoXCJzaGFwZVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwibWludmFsXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJtYXh2YWxcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImR0eXBlXCIsZSx0LGEpKV07Y2FzZVwiUmFuZ2VcIjpvPWdldFBhcmFtVmFsdWUoXCJzdGFydFwiLGUsdCxhKTt2YXIgZD1nZXRQYXJhbVZhbHVlKFwic3RvcFwiLGUsdCxhKSx5PWdldFBhcmFtVmFsdWUoXCJzdGVwXCIsZSx0LGEpO3JldHVybltyYW5nZShvLGQseSxnZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixlLHQsYSkpXTtjYXNlXCJUcnVuY2F0ZWROb3JtYWxcIjpyPWdldFBhcmFtVmFsdWUoXCJzaGFwZVwiLGUsdCxhKTt2YXIgZj1nZXRQYXJhbVZhbHVlKFwibWVhblwiLGUsdCxhKSxoPWdldFBhcmFtVmFsdWUoXCJzdGREZXZcIixlLHQsYSksZz1nZXRQYXJhbVZhbHVlKFwic2VlZFwiLGUsdCxhKTtyZXR1cm5bdHJ1bmNhdGVkTm9ybWFsKHIsZixoLGdldFBhcmFtVmFsdWUoXCJkdHlwZVwiLGUsdCxhKSxnKV07Y2FzZVwiWmVyb3NcIjpyZXR1cm5bemVyb3MoZ2V0UGFyYW1WYWx1ZShcInNoYXBlXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJkdHlwZVwiLGUsdCxhKSldO2Nhc2VcIlplcm9zTGlrZVwiOnJldHVyblt6ZXJvc0xpa2UoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19O2Z1bmN0aW9uIGV4ZWN1dGVPcCQ1KGUsdCxhKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciByLG4scyxvLHA7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oaSl7c3dpdGNoKGkubGFiZWwpe2Nhc2UgMDpzd2l0Y2goZS5vcCl7Y2FzZVwiTm9uTWF4U3VwcHJlc3Npb25WM1wiOmNhc2VcIk5vbk1heFN1cHByZXNzaW9uVjJcIjpyZXR1cm5bMywxXTtjYXNlXCJXaGVyZVwiOnJldHVyblszLDNdO2Nhc2VcIkxpc3REaWZmXCI6cmV0dXJuWzMsNV19cmV0dXJuWzMsN107Y2FzZSAxOnJldHVybiByPWdldFBhcmFtVmFsdWUoXCJib3hlc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJzY29yZXNcIixlLHQsYSkscz1nZXRQYXJhbVZhbHVlKFwibWF4T3V0cHV0U2l6ZVwiLGUsdCxhKSxvPWdldFBhcmFtVmFsdWUoXCJpb3VUaHJlc2hvbGRcIixlLHQsYSkscD1nZXRQYXJhbVZhbHVlKFwic2NvcmVUaHJlc2hvbGRcIixlLHQsYSksWzQsaW1hZ2Uubm9uTWF4U3VwcHJlc3Npb25Bc3luYyhyLG4scyxvLHApXTtjYXNlIDI6cmV0dXJuWzIsW2kuc2VudCgpXV07Y2FzZSAzOnJldHVybls0LHdoZXJlQXN5bmMoZ2V0UGFyYW1WYWx1ZShcImNvbmRpdGlvblwiLGUsdCxhKSldO2Nhc2UgNDpyZXR1cm5bMixbaS5zZW50KCldXTtjYXNlIDU6cmV0dXJuWzQsc2V0ZGlmZjFkQXN5bmMoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcInlcIixlLHQsYSkpXTtjYXNlIDY6cmV0dXJuWzIsaS5zZW50KCldO2Nhc2UgNzp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSl9KX12YXIgZXhlY3V0ZU9wJDY9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJUb3BLVjJcIjp2YXIgcj1nZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJrXCIsZSx0LGEpLHM9Z2V0UGFyYW1WYWx1ZShcInNvcnRlZFwiLGUsdCxhKSxvPXRvcGsocixuLHMpO3JldHVybltvLnZhbHVlcyxvLmluZGljZXNdO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0sZXhlY3V0ZU9wJDc9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJDb25zdFwiOnJldHVybiB0W2UubmFtZV07Y2FzZVwiUGxhY2Vob2xkZXJXaXRoRGVmYXVsdFwiOnZhciByPWdldFBhcmFtVmFsdWUoXCJkZWZhdWx0XCIsZSx0LGEpO3JldHVybltnZXRUZW5zb3IoZS5uYW1lLHQsYSl8fHJdO2Nhc2VcIlBsYWNlaG9sZGVyXCI6cmV0dXJuW2dldFRlbnNvcihlLm5hbWUsdCxhKV07Y2FzZVwiSWRlbnRpdHlcIjpjYXNlXCJTdG9wR3JhZGllbnRcIjpjYXNlXCJGYWtlUXVhbnRXaXRoTWluTWF4VmFyc1wiOnJldHVybltnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKS5jbG9uZSgpXTtjYXNlXCJJZGVudGl0eU5cIjpyZXR1cm4gZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmNsb25lKCl9KTtjYXNlXCJTbmFwc2hvdFwiOnJldHVybltnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKS5jbG9uZSgpXTtjYXNlXCJTaGFwZVwiOnJldHVyblt0ZW5zb3IxZChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKS5zaGFwZSxcImludDMyXCIpXTtjYXNlXCJTaGFwZU5cIjpyZXR1cm4gZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiB0ZW5zb3IxZChlLnNoYXBlKX0pO2Nhc2VcIlNpemVcIjpyZXR1cm5bc2NhbGFyKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLnNpemUsXCJpbnQzMlwiKV07Y2FzZVwiUmFua1wiOnJldHVybltzY2FsYXIoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkucmFuayxcImludDMyXCIpXTtjYXNlXCJOb09wXCI6cmV0dXJuW107Y2FzZVwiUHJpbnRcIjp2YXIgbj1nZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxzPWdldFBhcmFtVmFsdWUoXCJkYXRhXCIsZSx0LGEpLG89Z2V0UGFyYW1WYWx1ZShcIm1lc3NhZ2VcIixlLHQsYSkscD1nZXRQYXJhbVZhbHVlKFwic3VtbWFyaXplXCIsZSx0LGEpO2NvbnNvbGUud2FybihcIlRoZSBncmFwaCBoYXMgYSB0Zi5wcmludCgpIG9wZXJhdGlvbix1c3VhbGx5IHVzZWQgZm9yIGRlYnVnZ2luZywgd2hpY2ggc2xvd3MgZG93biBwZXJmb3JtYW5jZS5cIiksY29uc29sZS5sb2cobyk7Zm9yKHZhciBpPTA7aTxzLmxlbmd0aDtpKyspY29uc29sZS5sb2coQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc1tpXS5kYXRhU3luYygpKS5zbGljZSgwLHApKTtyZXR1cm5bbl07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSxleGVjdXRlT3AkOD1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcIlJlc2l6ZUJpbGluZWFyXCI6dmFyIHI9Z2V0UGFyYW1WYWx1ZShcImltYWdlc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJzaXplXCIsZSx0LGEpLHM9Z2V0UGFyYW1WYWx1ZShcImFsaWduQ29ybmVyc1wiLGUsdCxhKTtyZXR1cm5baW1hZ2UucmVzaXplQmlsaW5lYXIocixbblswXSxuWzFdXSxzKV07Y2FzZVwiUmVzaXplTmVhcmVzdE5laWdoYm9yXCI6cj1nZXRQYXJhbVZhbHVlKFwiaW1hZ2VzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcInNpemVcIixlLHQsYSkscz1nZXRQYXJhbVZhbHVlKFwiYWxpZ25Db3JuZXJzXCIsZSx0LGEpO3JldHVybltpbWFnZS5yZXNpemVOZWFyZXN0TmVpZ2hib3IocixbblswXSxuWzFdXSxzKV07Y2FzZVwiQ3JvcEFuZFJlc2l6ZVwiOnZhciBvPWdldFBhcmFtVmFsdWUoXCJpbWFnZVwiLGUsdCxhKSxwPWdldFBhcmFtVmFsdWUoXCJib3hlc1wiLGUsdCxhKSxpPWdldFBhcmFtVmFsdWUoXCJib3hJbmRcIixlLHQsYSksdT1nZXRQYXJhbVZhbHVlKFwiY3JvcFNpemVcIixlLHQsYSksbT1nZXRQYXJhbVZhbHVlKFwibWV0aG9kXCIsZSx0LGEpLGM9Z2V0UGFyYW1WYWx1ZShcImV4dHJhcG9sYXRpb25WYWx1ZVwiLGUsdCxhKTtyZXR1cm5baW1hZ2UuY3JvcEFuZFJlc2l6ZShvLHAsaSx1LG0sYyldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0sZXhlY3V0ZU9wJDk9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJFcXVhbFwiOnJldHVybltlcXVhbChnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIk5vdEVxdWFsXCI6cmV0dXJuW25vdEVxdWFsKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiR3JlYXRlclwiOnJldHVybltncmVhdGVyKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiR3JlYXRlckVxdWFsXCI6cmV0dXJuW2dyZWF0ZXJFcXVhbChnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIkxlc3NcIjpyZXR1cm5bbGVzcyhnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIkxlc3NFcXVhbFwiOnJldHVybltsZXNzRXF1YWwoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJMb2dpY2FsQW5kXCI6cmV0dXJuW2xvZ2ljYWxBbmQoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJMb2dpY2FsTm90XCI6cmV0dXJuW2xvZ2ljYWxOb3QoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSkpXTtjYXNlXCJMb2dpY2FsT3JcIjpyZXR1cm5bbG9naWNhbE9yKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiU2VsZWN0XCI6cmV0dXJuW3doZXJlKGdldFBhcmFtVmFsdWUoXCJjb25kaXRpb25cIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19LGV4ZWN1dGVPcCQxMD1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcIkJhdGNoTWF0TXVsXCI6Y2FzZVwiTWF0TXVsXCI6cmV0dXJuW21hdE11bChnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwidHJhbnNwb3NlQVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwidHJhbnNwb3NlQlwiLGUsdCxhKSldO2Nhc2VcIlRyYW5zcG9zZVwiOnJldHVyblt0cmFuc3Bvc2UoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcInBlcm1cIixlLHQsYSkpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19LGV4ZWN1dGVPcCQxMT1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcIkZ1c2VkQmF0Y2hOb3JtXCI6Y2FzZVwiRnVzZWRCYXRjaE5vcm1WMlwiOnJldHVybltiYXRjaE5vcm0oZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcIm1lYW5cIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcInZhcmlhbmNlXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJvZmZzZXRcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcInNjYWxlXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJlcHNpbG9uXCIsZSx0LGEpKV07Y2FzZVwiTFJOXCI6cmV0dXJuW2xvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJyYWRpdXNcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJpYXNcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImFscGhhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiZXRhXCIsZSx0LGEpKV07Y2FzZVwiU29mdG1heFwiOnJldHVybltzb2Z0bWF4KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiTG9nU29mdG1heFwiOnJldHVybltsb2dTb2Z0bWF4KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiU3BhcnNlVG9EZW5zZVwiOnJldHVybltzcGFyc2VUb0RlbnNlKGdldFBhcmFtVmFsdWUoXCJzcGFyc2VJbmRpY2VzXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJvdXRwdXRTaGFwZVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwic3BhcnNlVmFsdWVzXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJkZWZhdWx0VmFsdWVcIixlLHQsYSkpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19LGV4ZWN1dGVPcCQxMj1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcIk1heFwiOnZhciByPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcImtlZXBEaW1zXCIsZSx0LGEpO3JldHVyblttYXgoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscixuKV07Y2FzZVwiTWVhblwiOnI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwia2VlcERpbXNcIixlLHQsYSk7cmV0dXJuW21lYW4oZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscixuKV07Y2FzZVwiTWluXCI6cj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJrZWVwRGltc1wiLGUsdCxhKTtyZXR1cm5bbWluKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHIsbildO2Nhc2VcIlN1bVwiOnI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwia2VlcERpbXNcIixlLHQsYSk7cmV0dXJuW3N1bShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxyLG4pXTtjYXNlXCJBbGxcIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcImtlZXBEaW1zXCIsZSx0LGEpO3JldHVyblthbGwoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscixuKV07Y2FzZVwiQW55XCI6cj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJrZWVwRGltc1wiLGUsdCxhKTtyZXR1cm5bYW55KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHIsbildO2Nhc2VcIkFyZ01heFwiOnI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSk7cmV0dXJuW2FyZ01heChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxyKV07Y2FzZVwiQXJnTWluXCI6cj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKTtyZXR1cm5bYXJnTWluKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHIpXTtjYXNlXCJQcm9kXCI6cj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJrZWVwRGltc1wiLGUsdCxhKTtyZXR1cm5bcHJvZChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxyLG4pXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19LGV4ZWN1dGVPcCQxMz1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcIkNvbmNhdFYyXCI6Y2FzZVwiQ29uY2F0XCI6dmFyIHI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwidGVuc29yc1wiLGUsdCxhKTtyZXR1cm5bY29uY2F0KG4scildO2Nhc2VcIkdhdGhlclYyXCI6Y2FzZVwiR2F0aGVyXCI6cj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKTt2YXIgcz1nZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxvPWdldFBhcmFtVmFsdWUoXCJpbmRpY2VzXCIsZSx0LGEpO3JldHVybltnYXRoZXIocyxvLmFzVHlwZShcImludDMyXCIpLHIpXTtjYXNlXCJSZXZlcnNlVjJcIjpjYXNlXCJSZXZlcnNlXCI6cj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKSxzPWdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpO3JldHVybltyZXZlcnNlKHMscildO2Nhc2VcIlNsaWNlXCI6dmFyIHA9Z2V0UGFyYW1WYWx1ZShcImJlZ2luXCIsZSx0LGEpLGk9Z2V0UGFyYW1WYWx1ZShcInNpemVcIixlLHQsYSk7cmV0dXJuW3NsaWNlKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHAsaSldO2Nhc2VcIlN0cmlkZWRTbGljZVwiOnA9Z2V0UGFyYW1WYWx1ZShcImJlZ2luXCIsZSx0LGEpO3ZhciB1PWdldFBhcmFtVmFsdWUoXCJlbmRcIixlLHQsYSksbT1nZXRQYXJhbVZhbHVlKFwic3RyaWRlc1wiLGUsdCxhKSxjPWdldFBhcmFtVmFsdWUoXCJiZWdpbk1hc2tcIixlLHQsYSksbD1nZXRQYXJhbVZhbHVlKFwiZW5kTWFza1wiLGUsdCxhKSxkPWdldFBhcmFtVmFsdWUoXCJlbGxpcHNpc01hc2tcIixlLHQsYSkseT1nZXRQYXJhbVZhbHVlKFwibmV3QXhpc01hc2tcIixlLHQsYSksZj1nZXRQYXJhbVZhbHVlKFwic2hyaW5rQXhpc01hc2tcIixlLHQsYSksaD1nZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKTtpZigxPT09cC5sZW5ndGgmJmguc2hhcGUubGVuZ3RoPjEpZm9yKHZhciBnPTE7ZzxoLnNoYXBlLmxlbmd0aDtnKyspcC5wdXNoKDApLHUucHVzaChoLnNoYXBlW2ddKSxtLnB1c2gobVswXSk7cmV0dXJuW3N0cmlkZWRTbGljZShoLHAsdSxtLGMsbCxkLHksZildO2Nhc2VcIlBhY2tcIjpyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciByPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcInRlbnNvcnNcIixlLHQsYSkscz1uWzBdLnNoYXBlLG89blswXS5zcXVlZXplKCkuc2hhcGUscD1uLm1hcChmdW5jdGlvbihlKXt2YXIgdD11dGlsLmFycmF5c0VxdWFsKGUuc2hhcGUscyk7aWYoIXQmJiF1dGlsLmFycmF5c0VxdWFsKGUuc3F1ZWV6ZSgpLnNoYXBlLG8pKXRocm93IG5ldyBFcnJvcihcInRoZSBpbnB1dCB0ZW5zb3JzIHNoYXBlIGRvZXMgbm90IG1hdGNoXCIpO3JldHVybiB0P2U6ZS5yZXNoYXBlKHMpfSk7cmV0dXJuW3N0YWNrKHAscildfSk7Y2FzZVwiVW5wYWNrXCI6cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgcj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JcIixlLHQsYSk7cmV0dXJuIHVuc3RhY2sobixyKX0pO2Nhc2VcIlRpbGVcIjp2YXIgTj1nZXRQYXJhbVZhbHVlKFwicmVwc1wiLGUsdCxhKTtyZXR1cm5bdGlsZShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxOKV07Y2FzZVwiU3BsaXRcIjpjYXNlXCJTcGxpdFZcIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpO3ZhciB4PWdldFBhcmFtVmFsdWUoXCJudW1PclNpemVTcGxpdHNcIixlLHQsYSk7cmV0dXJuIHNwbGl0KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHgscik7Y2FzZVwiU2NhdHRlck5kXCI6bz1nZXRQYXJhbVZhbHVlKFwiaW5kaWNlc1wiLGUsdCxhKTt2YXIgYj1nZXRQYXJhbVZhbHVlKFwidmFsdWVzXCIsZSx0LGEpLFY9Z2V0UGFyYW1WYWx1ZShcInNoYXBlXCIsZSx0LGEpO3JldHVybltzY2F0dGVyTkQobyxiLFYpXTtjYXNlXCJHYXRoZXJOZFwiOnZhciBQPWdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpO289Z2V0UGFyYW1WYWx1ZShcImluZGljZXNcIixlLHQsYSk7cmV0dXJuW2dhdGhlck5EKFAsbyldO2Nhc2VcIlNwYXJzZVRvRGVuc2VcIjpvPWdldFBhcmFtVmFsdWUoXCJzcGFyc2VJbmRpY2VzXCIsZSx0LGEpLFY9Z2V0UGFyYW1WYWx1ZShcIm91dHB1dFNoYXBlXCIsZSx0LGEpO3ZhciBUPWdldFBhcmFtVmFsdWUoXCJzcGFyc2VWYWx1ZXNcIixlLHQsYSksTz1nZXRQYXJhbVZhbHVlKFwiZGVmYXVsdFZhbHVlXCIsZSx0LGEpO3JldHVybltzcGFyc2VUb0RlbnNlKG8sVCxWLFQuZHR5cGU9PT1PLmR0eXBlP086Ty5hc1R5cGUoVC5kdHlwZSkpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19LGV4ZWN1dGVPcCQxND1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcIkZGVFwiOnJldHVybltmZnQoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJJRkZUXCI6cmV0dXJuW2lmZnQoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJSRkZUXCI6cmV0dXJuW3JmZnQoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJJUkZGVFwiOnJldHVybltpcmZmdChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0sZXhlY3V0ZU9wJDE1PWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwiQ2FzdFwiOnJldHVybltjYXN0KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJkdHlwZVwiLGUsdCxhKSldO2Nhc2VcIkV4cGFuZERpbXNcIjp2YXIgcj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKTtyZXR1cm5bZXhwYW5kRGltcyhnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxyKV07Y2FzZVwiU3F1ZWV6ZVwiOnI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSk7cmV0dXJuW3NxdWVlemUoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscildO2Nhc2VcIlJlc2hhcGVcIjpyZXR1cm5bcmVzaGFwZShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwic2hhcGVcIixlLHQsYSkpXTtjYXNlXCJQYWRWMlwiOmNhc2VcIlBhZFwiOnJldHVybltwYWQoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksc3BsaXQkMShnZXRQYXJhbVZhbHVlKFwicGFkZGluZ1wiLGUsdCxhKSwyKSxnZXRQYXJhbVZhbHVlKFwiY29uc3RhbnRWYWx1ZVwiLGUsdCxhKSldO2Nhc2VcIlNwYWNlVG9CYXRjaE5EXCI6dmFyIG49Z2V0UGFyYW1WYWx1ZShcImJsb2NrU2hhcGVcIixlLHQsYSkscz1zcGxpdCQxKGdldFBhcmFtVmFsdWUoXCJwYWRkaW5nc1wiLGUsdCxhKSwyKTtyZXR1cm5bc3BhY2VUb0JhdGNoTkQoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksbixzKV07Y2FzZVwiQmF0Y2hUb1NwYWNlTkRcIjpuPWdldFBhcmFtVmFsdWUoXCJibG9ja1NoYXBlXCIsZSx0LGEpO3ZhciBvPXNwbGl0JDEoZ2V0UGFyYW1WYWx1ZShcImNyb3BzXCIsZSx0LGEpLDIpO3JldHVybltiYXRjaFRvU3BhY2VORChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxuLG8pXTtjYXNlXCJEZXB0aFRvU3BhY2VcIjp2YXIgcD1nZXRQYXJhbVZhbHVlKFwiYmxvY2tTaXplXCIsZSx0LGEpLGk9Z2V0UGFyYW1WYWx1ZShcImRhdGFGb3JtYXRcIixlLHQsYSkudG9VcHBlckNhc2UoKTtyZXR1cm5bZGVwdGhUb1NwYWNlKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHAsaSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX07ZnVuY3Rpb24gZXhlY3V0ZU9wJDE2KGUsdCxhKXt2YXIgcj1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUuY2F0ZWdvcnkpe2Nhc2VcImFyaXRobWV0aWNcIjpyZXR1cm4gZXhlY3V0ZU9wKGUsdCxhKTtjYXNlXCJiYXNpY19tYXRoXCI6cmV0dXJuIGV4ZWN1dGVPcCQxKGUsdCxhKTtjYXNlXCJjb250cm9sXCI6cmV0dXJuIGV4ZWN1dGVPcCQyKGUsdCxhKTtjYXNlXCJjb252b2x1dGlvblwiOnJldHVybiBleGVjdXRlT3AkMyhlLHQsYSk7Y2FzZVwiY3JlYXRpb25cIjpyZXR1cm4gZXhlY3V0ZU9wJDQoZSx0LGEpO2Nhc2VcImR5bmFtaWNcIjpyZXR1cm4gZXhlY3V0ZU9wJDUoZSx0LGEpO2Nhc2VcImV2YWx1YXRpb25cIjpyZXR1cm4gZXhlY3V0ZU9wJDYoZSx0LGEpO2Nhc2VcImltYWdlXCI6cmV0dXJuIGV4ZWN1dGVPcCQ4KGUsdCxhKTtjYXNlXCJncmFwaFwiOnJldHVybiBleGVjdXRlT3AkNyhlLHQsYSk7Y2FzZVwibG9naWNhbFwiOnJldHVybiBleGVjdXRlT3AkOShlLHQsYSk7Y2FzZVwibWF0cmljZXNcIjpyZXR1cm4gZXhlY3V0ZU9wJDEwKGUsdCxhKTtjYXNlXCJub3JtYWxpemF0aW9uXCI6cmV0dXJuIGV4ZWN1dGVPcCQxMShlLHQsYSk7Y2FzZVwicmVkdWN0aW9uXCI6cmV0dXJuIGV4ZWN1dGVPcCQxMihlLHQsYSk7Y2FzZVwic2xpY2Vfam9pblwiOnJldHVybiBleGVjdXRlT3AkMTMoZSx0LGEpO2Nhc2VcInNwZWN0cmFsXCI6cmV0dXJuIGV4ZWN1dGVPcCQxNChlLHQsYSk7Y2FzZVwidHJhbnNmb3JtYXRpb25cIjpyZXR1cm4gZXhlY3V0ZU9wJDE1KGUsdCxhKTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19KGUsdCxhKTtyZXR1cm4gciBpbnN0YW5jZW9mIFByb21pc2U/ci50aGVuKGZ1bmN0aW9uKGUpe3JldHVybltdLmNvbmNhdChlKX0pOltdLmNvbmNhdChyKX12YXIgRXhlY3V0aW9uQ29udGV4dD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXt0aGlzLndlaWdodE1hcD1lLHRoaXMudGVuc29yQXJyYXlNYXA9dCx0aGlzLnJvb3RDb250ZXh0PXtpZDowLGZyYW1lTmFtZTpcIlwiLGl0ZXJhdGlvbklkOjB9LHRoaXMuY29udGV4dHM9W3RoaXMucm9vdENvbnRleHRdLHRoaXMubGFzdElkPTAsdGhpcy5nZW5lcmF0ZUN1cnJlbnRDb250ZXh0SWRzKCl9cmV0dXJuIGUucHJvdG90eXBlLm5ld0ZyYW1lPWZ1bmN0aW9uKGUsdCl7cmV0dXJue2lkOmUsZnJhbWVOYW1lOnQsaXRlcmF0aW9uSWQ6MH19LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImN1cnJlbnRDb250ZXh0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnRleHRzfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5jb250ZXh0cyE9PWUmJih0aGlzLmNvbnRleHRzPWUsdGhpcy5nZW5lcmF0ZUN1cnJlbnRDb250ZXh0SWRzKCkpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImN1cnJlbnRDb250ZXh0SWRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2N1cnJlbnRDb250ZXh0SWRzWzBdfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImN1cnJlbnRDb250ZXh0SWRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jdXJyZW50Q29udGV4dElkc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxlLnByb3RvdHlwZS5nZW5lcmF0ZUN1cnJlbnRDb250ZXh0SWRzPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MDt0PHRoaXMuY29udGV4dHMubGVuZ3RoLTE7dCsrKXt2YXIgYT10aGlzLmNvbnRleHRzLnNsaWNlKDAsdGhpcy5jb250ZXh0cy5sZW5ndGgtdCk7ZS5wdXNoKHRoaXMuY29udGV4dElkZm9yQ29udGV4dHMoYSkpfWUucHVzaChcIlwiKSx0aGlzLl9jdXJyZW50Q29udGV4dElkcz1lfSxlLnByb3RvdHlwZS5jb250ZXh0SWRmb3JDb250ZXh0cz1mdW5jdGlvbihlKXtyZXR1cm4gZT9lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gMD09PWUuaWQmJjA9PT1lLml0ZXJhdGlvbklkP1wiXCI6ZS5mcmFtZU5hbWUrXCItXCIrZS5pdGVyYXRpb25JZH0pLmpvaW4oXCIvXCIpOlwiXCJ9LGUucHJvdG90eXBlLmVudGVyRnJhbWU9ZnVuY3Rpb24oZSl7dGhpcy5jb250ZXh0cyYmKHRoaXMubGFzdElkKyssdGhpcy5jb250ZXh0cz10aGlzLmNvbnRleHRzLnNsaWNlKCksdGhpcy5jb250ZXh0cy5wdXNoKHRoaXMubmV3RnJhbWUodGhpcy5sYXN0SWQsZSkpLHRoaXMuX2N1cnJlbnRDb250ZXh0SWRzLnVuc2hpZnQodGhpcy5jb250ZXh0SWRmb3JDb250ZXh0cyh0aGlzLmNvbnRleHRzKSkpfSxlLnByb3RvdHlwZS5leGl0RnJhbWU9ZnVuY3Rpb24oKXtpZighKHRoaXMuY29udGV4dHMmJnRoaXMuY29udGV4dHMubGVuZ3RoPjEpKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBleGl0IGZyYW1lLCB0aGUgY29udGV4dCBpcyBlbXB0eVwiKTt0aGlzLmNvbnRleHRzPXRoaXMuY29udGV4dHMuc2xpY2UoKSx0aGlzLmNvbnRleHRzLnNwbGljZSgtMSksdGhpcy5jdXJyZW50Q29udGV4dElkcy5zaGlmdCgpfSxlLnByb3RvdHlwZS5uZXh0SXRlcmF0aW9uPWZ1bmN0aW9uKCl7aWYoISh0aGlzLmNvbnRleHRzJiZ0aGlzLmNvbnRleHRzLmxlbmd0aD4wKSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaW5jcmVhc2UgZnJhbWUgaXRlcmF0aW9uLCB0aGUgY29udGV4dCBpcyBlbXB0eVwiKTt0aGlzLmNvbnRleHRzPXRoaXMuY29udGV4dHMuc2xpY2UoKSx0aGlzLmxhc3RJZCsrO3ZhciBlPU9iamVjdC5hc3NpZ24oe30sdGhpcy5jb250ZXh0c1t0aGlzLmNvbnRleHRzLmxlbmd0aC0xXSk7ZS5pdGVyYXRpb25JZCs9MSxlLmlkPXRoaXMubGFzdElkLHRoaXMuY29udGV4dHMuc3BsaWNlKC0xLDEsZSksdGhpcy5fY3VycmVudENvbnRleHRJZHMuc3BsaWNlKDAsMSx0aGlzLmNvbnRleHRJZGZvckNvbnRleHRzKHRoaXMuY29udGV4dHMpKX0sZS5wcm90b3R5cGUuZ2V0V2VpZ2h0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLndlaWdodE1hcFtlXX0sZS5wcm90b3R5cGUuYWRkVGVuc29yQXJyYXk9ZnVuY3Rpb24oZSl7dGhpcy50ZW5zb3JBcnJheU1hcFtlLmlkXT1lfSxlLnByb3RvdHlwZS5nZXRUZW5zb3JBcnJheT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50ZW5zb3JBcnJheU1hcFtlXX0sZX0oKSxHcmFwaEV4ZWN1dG9yPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt0aGlzLmdyYXBoPWUsdGhpcy5jb21waWxlZE1hcD1uZXcgTWFwLHRoaXMuX3dlaWdodE1hcD17fSx0aGlzLlNFUEVSQVRPUj1cIixcIix0aGlzLnBsYWNlaG9sZGVycz1lLnBsYWNlaG9sZGVycyx0aGlzLl9vdXRwdXRzPWUub3V0cHV0cyx0aGlzLmNvbXBpbGUoKX1yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwid2VpZ2h0TWFwXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl93ZWlnaHRNYXB9LHNldDpmdW5jdGlvbihlKXt2YXIgdD1PYmplY3Qua2V5cyhlKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGVbdF0ubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlkfSl9KTt0aGlzLndlaWdodElkcz1bXS5jb25jYXQuYXBwbHkoW10sdCksdGhpcy5fd2VpZ2h0TWFwPWV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiaW5wdXRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBsYWNlaG9sZGVycy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJue25hbWU6ZS5uYW1lLHNoYXBlOmUuYXR0clBhcmFtcy5zaGFwZT9lLmF0dHJQYXJhbXMuc2hhcGUudmFsdWU6dm9pZCAwLGR0eXBlOmUuYXR0clBhcmFtcy5kdHlwZT9lLmF0dHJQYXJhbXMuZHR5cGUudmFsdWU6dm9pZCAwfX0pfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcIm91dHB1dHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX291dHB1dHMubWFwKGZ1bmN0aW9uKGUpe3JldHVybntuYW1lOmUubmFtZSxzaGFwZTplLmF0dHJQYXJhbXMuc2hhcGU/ZS5hdHRyUGFyYW1zLnNoYXBlLnZhbHVlOnZvaWQgMCxkdHlwZTplLmF0dHJQYXJhbXMuZHR5cGU/ZS5hdHRyUGFyYW1zLmR0eXBlLnZhbHVlOnZvaWQgMH19KX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJpbnB1dE5vZGVzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBsYWNlaG9sZGVycy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmFtZX0pfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcIm91dHB1dE5vZGVzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm91dHB1dHMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLm5hbWV9KX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJpc0NvbnRyb2xGbG93TW9kZWxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ3JhcGgud2l0aENvbnRyb2xGbG93fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImlzRHluYW1pY1NoYXBlTW9kZWxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ3JhcGgud2l0aER5bmFtaWNTaGFwZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxlLnByb3RvdHlwZS5jb21waWxlPWZ1bmN0aW9uKGUpe2lmKCF0aGlzLmdyYXBoLndpdGhDb250cm9sRmxvdyYmIXRoaXMuZ3JhcGgud2l0aER5bmFtaWNTaGFwZSl7dmFyIHQ9W10sYT1lfHx0aGlzLmdyYXBoLnBsYWNlaG9sZGVycyxyPWEubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLm5hbWV9KS5zb3J0KCkuam9pbih0aGlzLlNFUEVSQVRPUik7aWYoIXRoaXMuY29tcGlsZWRNYXAuZ2V0KHIpKXtmb3IodmFyIG49YS5jb25jYXQodGhpcy5ncmFwaC53ZWlnaHRzKSxzPXt9O24ubGVuZ3RoPjA7KXt2YXIgbz1uLnBvcCgpO3Nbby5uYW1lXT0hMCx0LnB1c2gobyksby5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGUpeyFzW2UubmFtZV0mJmUuaW5wdXROYW1lcy5ldmVyeShmdW5jdGlvbihlKXt2YXIgdD1nZXROb2RlTmFtZUFuZEluZGV4KGUpWzBdO3JldHVybiBzW3RdfSkmJm4ucHVzaChlKX0pfXRoaXMuY29tcGlsZWRNYXAuc2V0KHIsdCl9fX0sZS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihlLHQsYSl7dmFyIHI9dGhpczt2b2lkIDA9PT10JiYodD0hMCk7dmFyIG49T2JqZWN0LmtleXMoZSkuc29ydCgpO3RoaXMuY2hlY2tJbnB1dChlLHQpLHRoaXMuY2hlY2tJbnB1dFNoYXBlQW5kVHlwZShlLHQpLHRoaXMuY29tcGlsZShuLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gci5ncmFwaC5ub2Rlc1tlXX0pKTt2YXIgcz10aGlzLmNhbGN1bGF0ZU91dHB1dHMoYSk7dGhpcy5jaGVja091dHB1dCh0aGlzLmNvbXBpbGVkTWFwLmdldChuLmpvaW4odGhpcy5TRVBFUkFUT1IpKSxzKTt2YXIgbz17fTtyZXR1cm4gdGlkeShmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgRXhlY3V0aW9uQ29udGV4dChyLl93ZWlnaHRNYXAsbyksYT1fX2Fzc2lnbih7fSxyLndlaWdodE1hcCxlKSxwPXIuZ2V0RnJvemVuVGVuc29ySWRzKGEpLGk9e30sdT1yLmNvbXBpbGVkTWFwLmdldChuLmpvaW4oci5TRVBFUkFUT1IpKSxtPTA7bTx1Lmxlbmd0aDttKyspe3ZhciBjPXVbbV07aWYoYVtjLm5hbWVdfHwoYVtjLm5hbWVdPWV4ZWN1dGVPcCQxNihjLGEsdCksci5jaGVja1RlbnNvckZvckRpc3Bvc2FsKGMubmFtZSxjLGEsdCxwLHMsaSkpLHMuZXZlcnkoZnVuY3Rpb24oZSl7cmV0dXJuISFhW2VdfSkpYnJlYWt9cmV0dXJuIHIuZmluZE91dHB1dHMoYSx0LHMpfSl9LGUucHJvdG90eXBlLmdldEZyb3plblRlbnNvcklkcz1mdW5jdGlvbihlKXt2YXIgdD1bXS5jb25jYXQuYXBwbHkoW10sT2JqZWN0LmtleXMoZSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdfSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5pZH0pfSkpO3JldHVybiBuZXcgU2V0KHQpfSxlLnByb3RvdHlwZS5jaGVja1RlbnNvckZvckRpc3Bvc2FsPWZ1bmN0aW9uKGUsdCxhLHIsbixzLG8pe1wiY29udHJvbFwiIT09dC5jYXRlZ29yeSYmLTE9PT1zLmluZGV4T2YoZSkmJihhW2VdLmZvckVhY2goZnVuY3Rpb24oZSl7bnVsbCE9ZSYmKG9bZS5pZF09KG9bZS5pZF18fDApK3QuY2hpbGRyZW4ubGVuZ3RoKX0pLHQuaW5wdXRzLmZvckVhY2goZnVuY3Rpb24oZSl7aWYoXCJjb250cm9sXCIhPT1lLmNhdGVnb3J5KXt2YXIgdD1nZXRUZW5zb3JzRm9yQ3VycmVudENvbnRlbnh0KGUubmFtZSxhLHIpO251bGwhPXQmJnQuZm9yRWFjaChmdW5jdGlvbihlKXtpZihlJiYhbi5oYXMoZS5pZCkpe3ZhciB0PW9bZS5pZF07MT09PXQ/KGUuZGlzcG9zZSgpLGRlbGV0ZSBvW2UuaWRdKTpudWxsIT10JiZvW2UuaWRdLS19fSl9fSkpfSxlLnByb3RvdHlwZS5leGVjdXRlQXN5bmM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBhLHIsbixzLG8scCxpLHUsbT10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGMpe3N3aXRjaChjLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHRoaXMuY2hlY2tJbnB1dChlLCExKSx0aGlzLmNoZWNrSW5wdXRTaGFwZUFuZFR5cGUoZSwhMSksYT17fSxyPW5ldyBFeGVjdXRpb25Db250ZXh0KHRoaXMuX3dlaWdodE1hcCxhKSxuPXRoaXMuY2FsY3VsYXRlT3V0cHV0cyh0KSxbNCx0aGlzLmV4ZWN1dGVXaXRoQ29udHJvbEZsb3coZSxyLG4pXTtjYXNlIDE6cmV0dXJuIHM9Yy5zZW50KCksbz10aGlzLmZpbmRPdXRwdXRzKHMscix0KSxwPU9iamVjdC5rZXlzKG8pLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gb1tlXS5pZH0pLGk9T2JqZWN0LmtleXMoZSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5pZH0pfSksdT1bXS5jb25jYXQuYXBwbHkoW10saSksT2JqZWN0LmtleXMocykuZm9yRWFjaChmdW5jdGlvbihlKXtzW2VdLmZvckVhY2goZnVuY3Rpb24oZSl7ZSYmIWUuaXNEaXNwb3NlZCYmLTE9PT1wLmluZGV4T2YoZS5pZCkmJi0xPT09dS5pbmRleE9mKGUuaWQpJiYtMT09PW0ud2VpZ2h0SWRzLmluZGV4T2YoZS5pZCkmJmUuZGlzcG9zZSgpfSl9KSxbMixvXX19KX0pfSxlLnByb3RvdHlwZS5leGVjdXRlV2l0aENvbnRyb2xGbG93PWZ1bmN0aW9uKGUsdCxhKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciByLG4scyxvLHAsaSx1LG0sYz10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGwpe3N3aXRjaChsLmxhYmVsKXtjYXNlIDA6cj1PYmplY3Qua2V5cyhlKSxuPXIubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBjLmdyYXBoLm5vZGVzW2VdfSkscz1uLmNvbmNhdCh0aGlzLmdyYXBoLndlaWdodHMpLm1hcChmdW5jdGlvbihlKXtyZXR1cm57bm9kZTplLGNvbnRleHRzOnQuY3VycmVudENvbnRleHR9fSksbz1fX2Fzc2lnbih7fSx0aGlzLndlaWdodE1hcCxlKSxwPXt9LGk9dGhpcy5nZXRGcm96ZW5UZW5zb3JJZHMobyksdT17fSxsLmxhYmVsPTE7Y2FzZSAxOnJldHVybiBzLmxlbmd0aD4wPyhtPXRoaXMucHJvY2Vzc1N0YWNrKG4scyx0LG8sdSxpLGEscCksWzQsUHJvbWlzZS5hbGwobSldKTpbMywzXTtjYXNlIDI6cmV0dXJuIGwuc2VudCgpLFszLDFdO2Nhc2UgMzpyZXR1cm5bMixvXX19KX0pfSxlLnByb3RvdHlwZS5wcm9jZXNzU3RhY2s9ZnVuY3Rpb24oZSx0LGEscixuLHMsbyxwKXtmb3IodmFyIGk9dGhpcyx1PVtdLG09ZnVuY3Rpb24oKXt2YXIgbT10LnBvcCgpO2EuY3VycmVudENvbnRleHQ9bS5jb250ZXh0czt2YXIgbD1cIlwiO2lmKFwiRW50ZXJcIj09PW0ubm9kZS5vcCYmZ2V0UGFyYW1WYWx1ZShcImlzQ29uc3RhbnRcIixtLm5vZGUscixhKSYmKGw9Z2V0Tm9kZU5hbWVBbmRJbmRleChtLm5vZGUubmFtZSxhKVswXSksLTE9PT1lLmluZGV4T2YobS5ub2RlKSl7dmFyIGQ9ZXhlY3V0ZU9wJDE2KG0ubm9kZSxyLGEpO2x8fChsPWdldE5vZGVOYW1lQW5kSW5kZXgobS5ub2RlLm5hbWUsYSlbMF0pO3ZhciB5PWEuY3VycmVudENvbnRleHQ7ZCBpbnN0YW5jZW9mIFByb21pc2U/dS5wdXNoKGQudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gcltsXT1lLGEuY3VycmVudENvbnRleHQ9eSxpLmNoZWNrVGVuc29yRm9yRGlzcG9zYWwobCxtLm5vZGUscixhLHMsbyxwKSxpLnByb2Nlc3NDaGlsZE5vZGVzKG0ubm9kZSx0LGEscixuKSxlfSkpOihyW2xdPWQsYy5jaGVja1RlbnNvckZvckRpc3Bvc2FsKGwsbS5ub2RlLHIsYSxzLG8scCksYy5wcm9jZXNzQ2hpbGROb2RlcyhtLm5vZGUsdCxhLHIsbikpfWVsc2UgYy5wcm9jZXNzQ2hpbGROb2RlcyhtLm5vZGUsdCxhLHIsbil9LGM9dGhpczt0Lmxlbmd0aD4wOyltKCk7cmV0dXJuIHV9LGUucHJvdG90eXBlLnByb2Nlc3NDaGlsZE5vZGVzPWZ1bmN0aW9uKGUsdCxhLHIsbil7ZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciBzPWdldE5vZGVOYW1lQW5kSW5kZXgoZS5uYW1lLGEpWzBdO25bc118fChcIk1lcmdlXCI9PT1lLm9wP2UuaW5wdXROYW1lcy5zb21lKGZ1bmN0aW9uKGUpe3JldHVybiEhZ2V0VGVuc29yKGUscixhKX0pJiYobltzXT0hMCx0LnB1c2goe2NvbnRleHRzOmEuY3VycmVudENvbnRleHQsbm9kZTplfSkpOmUuaW5wdXROYW1lcy5ldmVyeShmdW5jdGlvbihlKXtyZXR1cm4hIWdldFRlbnNvcihlLHIsYSl9KSYmKG5bc109ITAsdC5wdXNoKHtjb250ZXh0czphLmN1cnJlbnRDb250ZXh0LG5vZGU6ZX0pKSl9KX0sZS5wcm90b3R5cGUuY2FsY3VsYXRlT3V0cHV0cz1mdW5jdGlvbihlKXtyZXR1cm4hZXx8ZSBpbnN0YW5jZW9mIEFycmF5fHwoZT1bZV0pLGV8fHRoaXMuZ3JhcGgub3V0cHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmFtZX0pfSxlLnByb3RvdHlwZS5maW5kT3V0cHV0cz1mdW5jdGlvbihlLHQsYSl7cmV0dXJuIHRoaXMuY2FsY3VsYXRlT3V0cHV0cyhhKS5yZWR1Y2UoZnVuY3Rpb24oYSxyKXtyZXR1cm4gYVtyXT1nZXRUZW5zb3IocixlLHQpLGF9LHt9KX0sZS5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3ZhciBlPXRoaXM7T2JqZWN0LmtleXModGhpcy53ZWlnaHRNYXApLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIGUud2VpZ2h0TWFwW3RdLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGUuZGlzcG9zZSgpfSl9KX0sZS5wcm90b3R5cGUuY2hlY2tJbnB1dFNoYXBlQW5kVHlwZT1mdW5jdGlvbihlLHQpe3ZvaWQgMD09PXQmJih0PSEwKSx0aGlzLnBsYWNlaG9sZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciByPWVbYS5uYW1lXTtpZih0fHxyKXt2YXIgbj1yWzBdO2lmKGEuYXR0clBhcmFtcy5zaGFwZSYmYS5hdHRyUGFyYW1zLnNoYXBlLnZhbHVlKXt2YXIgcz1hLmF0dHJQYXJhbXMuc2hhcGUudmFsdWUsbz1zLmxlbmd0aD09PW4uc2hhcGUubGVuZ3RoJiZuLnNoYXBlLmV2ZXJ5KGZ1bmN0aW9uKGUsdCl7cmV0dXJuLTE9PT1zW3RdfHxzW3RdPT09ZX0pO3V0aWwuYXNzZXJ0KG8sZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBzaGFwZSBvZiBkaWN0WydcIithLm5hbWUrXCInXSBwcm92aWRlZCBpbiBtb2RlbC5leGVjdXRlKGRpY3QpIG11c3QgYmUgW1wiK3MrXCJdLCBidXQgd2FzIFtcIituLnNoYXBlK1wiXVwifSl9YS5hdHRyUGFyYW1zLmR0eXBlJiZhLmF0dHJQYXJhbXMuZHR5cGUudmFsdWUmJnV0aWwuYXNzZXJ0KG4uZHR5cGU9PT1hLmF0dHJQYXJhbXMuZHR5cGUudmFsdWUsZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBkdHlwZSBvZiBkaWN0WydcIithLm5hbWUrXCInXSBwcm92aWRlZCBpbiBtb2RlbC5leGVjdXRlKGRpY3QpIG11c3QgYmUgXCIrYS5hdHRyUGFyYW1zLmR0eXBlLnZhbHVlK1wiLCBidXQgd2FzIFwiK24uZHR5cGV9KX19KX0sZS5wcm90b3R5cGUuY2hlY2tJbnB1dD1mdW5jdGlvbihlLHQpe3ZhciBhPXRoaXM7dm9pZCAwPT09dCYmKHQ9ITApO3ZhciByPU9iamVjdC5rZXlzKGUpLG49W10scz1bXTt0aGlzLmlucHV0Tm9kZXMuZm9yRWFjaChmdW5jdGlvbihlKXstMT09PXIuaW5kZXhPZihlKSYmbi5wdXNoKGUpfSksci5mb3JFYWNoKGZ1bmN0aW9uKGUpey0xPT09YS5pbnB1dE5vZGVzLmluZGV4T2YoZSkmJnMucHVzaChlKX0pO3ZhciBvPXMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiFhLmdyYXBoLm5vZGVzW2VdfSk7aWYobi5sZW5ndGg+MCYmdCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGljdCBwcm92aWRlZCBpbiBtb2RlbC5leGVjdXRlKGRpY3QpIGhhcyB0aGUga2V5cyBbXCIrcitcIl0sIGJ1dCBpcyBtaXNzaW5nIHRoZSByZXF1aXJlZCBrZXlzOiBbXCIrbitcIl0uXCIpO2lmKHMubGVuZ3RoPjAmJnQpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRpY3QgcHJvdmlkZWQgaW4gbW9kZWwuZXhlY3V0ZShkaWN0KSBoYXMgdW51c2VkIGtleXM6IFtcIitzK1wiXS4gUGxlYXNlIHByb3ZpZGUgb25seSB0aGUgZm9sbG93aW5nIGtleXM6IFtcIit0aGlzLmlucHV0Tm9kZXMrXCJdLlwiKTtpZihvLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcihcIlRoZSBkaWN0IHByb3ZpZGVkIGluIG1vZGVsLmV4ZWN1dGUoZGljdCkgaGFzIGtleXM6IFtcIitvK1wiXSBub3QgcGFydCBvZiBtb2RlbCBncmFwaC5cIil9LGUucHJvdG90eXBlLmNoZWNrT3V0cHV0PWZ1bmN0aW9uKGUsdCl7dmFyIGE9ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmFtZX0pLHI9W107aWYodC5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PXBhcnNlTm9kZU5hbWUoZSlbMF07LTE9PT1hLmluZGV4T2YodCkmJnIucHVzaCh0KX0pLHIubGVuZ3RoPjApdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZvbGxvd2luZyBvdXRwdXRzIGFyZSBub3QgZ2VuZXJhdGVkIGJ5IHRoZSBleGVjdXRpb246IFtcIityK1wiXS5cIil9LGV9KCksVEZIVUJfU0VBUkNIX1BBUkFNPVwiP3RmanMtZm9ybWF0PWZpbGVcIixERUZBVUxUX01PREVMX05BTUU9XCJtb2RlbC5qc29uXCIsR3JhcGhNb2RlbD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXt2b2lkIDA9PT10JiYodD17fSksdGhpcy5tb2RlbFVybD1lLHRoaXMubG9hZE9wdGlvbnM9dCx0aGlzLnZlcnNpb249XCJuL2FcIixudWxsPT10JiYodGhpcy5sb2FkT3B0aW9ucz17fSl9cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcIm1vZGVsVmVyc2lvblwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52ZXJzaW9ufSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImlucHV0Tm9kZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXhlY3V0b3IuaW5wdXROb2Rlc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJvdXRwdXROb2Rlc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5leGVjdXRvci5vdXRwdXROb2Rlc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJpbnB1dHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXhlY3V0b3IuaW5wdXRzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcIm91dHB1dHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXhlY3V0b3Iub3V0cHV0c30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJ3ZWlnaHRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmV4ZWN1dG9yLndlaWdodE1hcH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxlLnByb3RvdHlwZS5maW5kSU9IYW5kbGVyPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5tb2RlbFVybDtpZihudWxsIT1lLmxvYWQpdGhpcy5oYW5kbGVyPWU7ZWxzZSBpZihudWxsIT10aGlzLmxvYWRPcHRpb25zLnJlcXVlc3RJbml0KXRoaXMuaGFuZGxlcj1pby5icm93c2VySFRUUFJlcXVlc3QoZSx0aGlzLmxvYWRPcHRpb25zKTtlbHNle3ZhciB0PWlvLmdldExvYWRIYW5kbGVycyhlLHRoaXMubG9hZE9wdGlvbnMub25Qcm9ncmVzcyk7aWYoMD09PXQubGVuZ3RoKXQucHVzaChpby5icm93c2VySFRUUFJlcXVlc3QoZSx0aGlzLmxvYWRPcHRpb25zKSk7ZWxzZSBpZih0Lmxlbmd0aD4xKXRocm93IG5ldyBFcnJvcihcIkZvdW5kIG1vcmUgdGhhbiBvbmUgKFwiK3QubGVuZ3RoK1wiKSBsb2FkIGhhbmRsZXJzIGZvciBVUkwgJ1wiK1tlXStcIidcIik7dGhpcy5oYW5kbGVyPXRbMF19fSxlLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSx0LGE7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDppZih0aGlzLmZpbmRJT0hhbmRsZXIoKSxudWxsPT10aGlzLmhhbmRsZXIubG9hZCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcHJvY2VlZCB3aXRoIG1vZGVsIGxvYWRpbmcgYmVjYXVzZSB0aGUgSU9IYW5kbGVyIHByb3ZpZGVkIGRvZXMgbm90IGhhdmUgdGhlIGBsb2FkYCBtZXRob2QgaW1wbGVtZW50ZWQuXCIpO3JldHVybls0LHRoaXMuaGFuZGxlci5sb2FkKCldO2Nhc2UgMTpyZXR1cm4gZT1yLnNlbnQoKSx0PWUubW9kZWxUb3BvbG9neSx0aGlzLnZlcnNpb249dC52ZXJzaW9ucy5wcm9kdWNlcitcIi5cIit0LnZlcnNpb25zLm1pbkNvbnN1bWVyLGE9aW8uZGVjb2RlV2VpZ2h0cyhlLndlaWdodERhdGEsZS53ZWlnaHRTcGVjcyksdGhpcy5leGVjdXRvcj1uZXcgR3JhcGhFeGVjdXRvcihPcGVyYXRpb25NYXBwZXIuSW5zdGFuY2UudHJhbnNmb3JtR3JhcGgodCkpLHRoaXMuZXhlY3V0b3Iud2VpZ2h0TWFwPXRoaXMuY29udmVydFRlbnNvck1hcFRvVGVuc29yc01hcChhKSxbMiwhMF19fSl9KX0sZS5wcm90b3R5cGUucHJlZGljdD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmV4ZWN1dGVfKGUsITAsdGhpcy5vdXRwdXROb2Rlcyl9LGUucHJvdG90eXBlLmNvbnN0cnVjdFRlbnNvck1hcD1mdW5jdGlvbihlKXt2YXIgdD1lIGluc3RhbmNlb2YgVGVuc29yP1tlXTplO2lmKHQubGVuZ3RoIT09dGhpcy5pbnB1dE5vZGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0ZW5zb3IgY291bnQgbWlzbWF0Y2gsdGhlIGdyYXBoIG1vZGVsIGhhcyBcIit0aGlzLmlucHV0Tm9kZXMubGVuZ3RoK1wiIHBsYWNlaG9sZGVycywgd2hpbGUgdGhlcmUgYXJlIFwiK3QubGVuZ3RoK1wiIGlucHV0IHRlbnNvcnMuXCIpO3JldHVybiB0aGlzLmlucHV0Tm9kZXMucmVkdWNlKGZ1bmN0aW9uKGUsYSxyKXtyZXR1cm4gZVthXT10W3JdLGV9LHt9KX0sZS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmV4ZWN1dGVfKGUsITEsdCl9LGUucHJvdG90eXBlLmV4ZWN1dGVfPWZ1bmN0aW9uKGUsdCxhKXtpZih2b2lkIDA9PT10JiYodD0hMCksYT1hfHx0aGlzLm91dHB1dE5vZGVzLChlIGluc3RhbmNlb2YgVGVuc29yfHxBcnJheS5pc0FycmF5KGUpKSYmKGU9dGhpcy5jb25zdHJ1Y3RUZW5zb3JNYXAoZSkpLHRoaXMuZXhlY3V0b3IuaXNDb250cm9sRmxvd01vZGVsfHx0aGlzLmV4ZWN1dG9yLmlzRHluYW1pY1NoYXBlTW9kZWwpdGhyb3cgbmV3IEVycm9yKFwiVGhlIG1vZGVsIGNvbnRhaW5zIGNvbnRyb2wgZmxvdyBvciBkeW5hbWljIHNoYXBlIG9wcywgcGxlYXNlIHVzZSBleGVjdXRlQXN5bmMgbWV0aG9kXCIpO3ZhciByPXRoaXMuZXhlY3V0b3IuZXhlY3V0ZSh0aGlzLmNvbnZlcnRUZW5zb3JNYXBUb1RlbnNvcnNNYXAoZSksdCxhKSxuPU9iamVjdC5rZXlzKHIpO3JldHVybiBBcnJheS5pc0FycmF5KGEpJiZhLmxlbmd0aD4xP2EubWFwKGZ1bmN0aW9uKGUpe3JldHVybiByW2VdfSk6cltuWzBdXX0sZS5wcm90b3R5cGUuZXhlY3V0ZUFzeW5jPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgYSxyO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6aWYoIXRoaXMuZXhlY3V0b3IuaXNDb250cm9sRmxvd01vZGVsJiYhdGhpcy5leGVjdXRvci5pc0R5bmFtaWNTaGFwZU1vZGVsKXRocm93IG5ldyBFcnJvcihcIlRoZSBtb2RlbCBkb2VzIG5vdCBjb250YWluIGNvbnRyb2wgZmxvdyBvciBkeW5hbWljIHNoYXBlIG9wcywgcGxlYXNlIHVzZSBleGVjdXRlIG1ldGhvZCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlwiKTtyZXR1cm4gdD10fHx0aGlzLm91dHB1dE5vZGVzLChlIGluc3RhbmNlb2YgVGVuc29yfHxBcnJheS5pc0FycmF5KGUpKSYmKGU9dGhpcy5jb25zdHJ1Y3RUZW5zb3JNYXAoZSkpLFs0LHRoaXMuZXhlY3V0b3IuZXhlY3V0ZUFzeW5jKHRoaXMuY29udmVydFRlbnNvck1hcFRvVGVuc29yc01hcChlKSx0KV07Y2FzZSAxOnJldHVybiBhPW4uc2VudCgpLHI9T2JqZWN0LmtleXMoYSksWzIsQXJyYXkuaXNBcnJheSh0KSYmdC5sZW5ndGg+MT90Lm1hcChmdW5jdGlvbihlKXtyZXR1cm4gYVtlXX0pOmFbclswXV1dfX0pfSl9LGUucHJvdG90eXBlLmNvbnZlcnRUZW5zb3JNYXBUb1RlbnNvcnNNYXA9ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5rZXlzKGUpLnJlZHVjZShmdW5jdGlvbih0LGEpe3JldHVybiB0W2FdPVtlW2FdXSx0fSx7fSl9LGUucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLmV4ZWN1dG9yLmRpc3Bvc2UoKX0sZX0oKTtmdW5jdGlvbiBsb2FkR3JhcGhNb2RlbChlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD17fSksX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBhO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6aWYobnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJtb2RlbFVybCBpbiBsb2FkR3JhcGhNb2RlbCgpIGNhbm5vdCBiZSBudWxsLiBQbGVhc2UgcHJvdmlkZSBhIHVybCBvciBhbiBJT0hhbmRsZXIgdGhhdCBsb2FkcyB0aGUgbW9kZWxcIik7cmV0dXJuIG51bGw9PXQmJih0PXt9KSx0LmZyb21URkh1YiYmbnVsbD09ZS5sb2FkJiYoZS5lbmRzV2l0aChcIi9cIil8fChlKz1cIi9cIiksZT1cIlwiK2UrREVGQVVMVF9NT0RFTF9OQU1FK1RGSFVCX1NFQVJDSF9QQVJBTSksWzQsKGE9bmV3IEdyYXBoTW9kZWwoZSx0KSkubG9hZCgpXTtjYXNlIDE6cmV0dXJuIHIuc2VudCgpLFsyLGFdfX0pfSl9dmFyIHZlcnNpb249XCIxLjEuMlwiO2V4cG9ydHtHcmFwaE1vZGVsLGxvYWRHcmFwaE1vZGVsLHZlcnNpb24gYXMgdmVyc2lvbl9jb252ZXJ0ZXJ9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGYtY29udmVydGVyLmVzbS5qcy5tYXBcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciB0PWZ1bmN0aW9uKGUsbil7cmV0dXJuKHQ9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZX18fGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShuKSYmKHRbbl09ZVtuXSl9KShlLG4pfTtmdW5jdGlvbiBlKGUsbil7ZnVuY3Rpb24gcigpe3RoaXMuY29uc3RydWN0b3I9ZX10KGUsbiksZS5wcm90b3R5cGU9bnVsbD09PW4/T2JqZWN0LmNyZWF0ZShuKTooci5wcm90b3R5cGU9bi5wcm90b3R5cGUsbmV3IHIpfXZhciBuPWZ1bmN0aW9uKCl7cmV0dXJuKG49T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24odCl7Zm9yKHZhciBlLG49MSxyPWFyZ3VtZW50cy5sZW5ndGg7bjxyO24rKylmb3IodmFyIG8gaW4gZT1hcmd1bWVudHNbbl0pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsbykmJih0W29dPWVbb10pO3JldHVybiB0fSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtmdW5jdGlvbiByKHQsZSxuLHIpe3JldHVybiBuZXcobnx8KG49UHJvbWlzZSkpKGZ1bmN0aW9uKG8sYSl7ZnVuY3Rpb24gaSh0KXt0cnl7dShyLm5leHQodCkpfWNhdGNoKHQpe2EodCl9fWZ1bmN0aW9uIHModCl7dHJ5e3Uoci50aHJvdyh0KSl9Y2F0Y2godCl7YSh0KX19ZnVuY3Rpb24gdSh0KXt0LmRvbmU/byh0LnZhbHVlKTpuZXcgbihmdW5jdGlvbihlKXtlKHQudmFsdWUpfSkudGhlbihpLHMpfXUoKHI9ci5hcHBseSh0LGV8fFtdKSkubmV4dCgpKX0pfWZ1bmN0aW9uIG8odCxlKXt2YXIgbixyLG8sYSxpPXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZigxJm9bMF0pdGhyb3cgb1sxXTtyZXR1cm4gb1sxXX0sdHJ5czpbXSxvcHM6W119O3JldHVybiBhPXtuZXh0OnMoMCksdGhyb3c6cygxKSxyZXR1cm46cygyKX0sXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYoYVtTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxhO2Z1bmN0aW9uIHMoYSl7cmV0dXJuIGZ1bmN0aW9uKHMpe3JldHVybiBmdW5jdGlvbihhKXtpZihuKXRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO2Zvcig7aTspdHJ5e2lmKG49MSxyJiYobz0yJmFbMF0/ci5yZXR1cm46YVswXT9yLnRocm93fHwoKG89ci5yZXR1cm4pJiZvLmNhbGwociksMCk6ci5uZXh0KSYmIShvPW8uY2FsbChyLGFbMV0pKS5kb25lKXJldHVybiBvO3N3aXRjaChyPTAsbyYmKGE9WzImYVswXSxvLnZhbHVlXSksYVswXSl7Y2FzZSAwOmNhc2UgMTpvPWE7YnJlYWs7Y2FzZSA0OnJldHVybiBpLmxhYmVsKysse3ZhbHVlOmFbMV0sZG9uZTohMX07Y2FzZSA1OmkubGFiZWwrKyxyPWFbMV0sYT1bMF07Y29udGludWU7Y2FzZSA3OmE9aS5vcHMucG9wKCksaS50cnlzLnBvcCgpO2NvbnRpbnVlO2RlZmF1bHQ6aWYoIShvPShvPWkudHJ5cykubGVuZ3RoPjAmJm9bby5sZW5ndGgtMV0pJiYoNj09PWFbMF18fDI9PT1hWzBdKSl7aT0wO2NvbnRpbnVlfWlmKDM9PT1hWzBdJiYoIW98fGFbMV0+b1swXSYmYVsxXTxvWzNdKSl7aS5sYWJlbD1hWzFdO2JyZWFrfWlmKDY9PT1hWzBdJiZpLmxhYmVsPG9bMV0pe2kubGFiZWw9b1sxXSxvPWE7YnJlYWt9aWYobyYmaS5sYWJlbDxvWzJdKXtpLmxhYmVsPW9bMl0saS5vcHMucHVzaChhKTticmVha31vWzJdJiZpLm9wcy5wb3AoKSxpLnRyeXMucG9wKCk7Y29udGludWV9YT1lLmNhbGwodCxpKX1jYXRjaCh0KXthPVs2LHRdLHI9MH1maW5hbGx5e249bz0wfWlmKDUmYVswXSl0aHJvdyBhWzFdO3JldHVybnt2YWx1ZTphWzBdP2FbMV06dm9pZCAwLGRvbmU6ITB9fShbYSxzXSl9fX12YXIgYSxpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmdsb2JhbD10LHRoaXMuZmxhZ3M9e30sdGhpcy5mbGFnUmVnaXN0cnk9e30sdGhpcy51cmxGbGFncz17fSx0aGlzLnBvcHVsYXRlVVJMRmxhZ3MoKX1yZXR1cm4gdC5wcm90b3R5cGUucmVnaXN0ZXJGbGFnPWZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLmZsYWdSZWdpc3RyeVt0XT17ZXZhbHVhdGlvbkZuOmUsc2V0SG9vazpufSxudWxsIT10aGlzLnVybEZsYWdzW3RdKXt2YXIgcj10aGlzLnVybEZsYWdzW3RdO2NvbnNvbGUud2FybihcIlNldHRpbmcgZmVhdHVyZSBvdmVycmlkZSBmcm9tIFVSTCBcIit0K1wiOiBcIityK1wiLlwiKSx0aGlzLnNldCh0LHIpfX0sdC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe3JldHVybiB0IGluIHRoaXMuZmxhZ3M/dGhpcy5mbGFnc1t0XToodGhpcy5mbGFnc1t0XT10aGlzLmV2YWx1YXRlRmxhZyh0KSx0aGlzLmZsYWdzW3RdKX0sdC5wcm90b3R5cGUuZ2V0TnVtYmVyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldCh0KX0sdC5wcm90b3R5cGUuZ2V0Qm9vbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZXQodCl9LHQucHJvdG90eXBlLmdldEZsYWdzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmxhZ3N9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImZlYXR1cmVzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZsYWdzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLnNldD1mdW5jdGlvbih0LGUpe2lmKG51bGw9PXRoaXMuZmxhZ1JlZ2lzdHJ5W3RdKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgZmxhZyBcIit0K1wiIGFzIGl0IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkLlwiKTt0aGlzLmZsYWdzW3RdPWUsbnVsbCE9dGhpcy5mbGFnUmVnaXN0cnlbdF0uc2V0SG9vayYmdGhpcy5mbGFnUmVnaXN0cnlbdF0uc2V0SG9vayhlKX0sdC5wcm90b3R5cGUuZXZhbHVhdGVGbGFnPWZ1bmN0aW9uKHQpe2lmKG51bGw9PXRoaXMuZmxhZ1JlZ2lzdHJ5W3RdKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBldmFsdWF0ZSBmbGFnICdcIit0K1wiJzogbm8gZXZhbHVhdGlvbiBmdW5jdGlvbiBmb3VuZC5cIik7cmV0dXJuIHRoaXMuZmxhZ1JlZ2lzdHJ5W3RdLmV2YWx1YXRpb25GbigpfSx0LnByb3RvdHlwZS5zZXRGbGFncz1mdW5jdGlvbih0KXt0aGlzLmZsYWdzPU9iamVjdC5hc3NpZ24oe30sdCl9LHQucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5mbGFncz17fSx0aGlzLnVybEZsYWdzPXt9LHRoaXMucG9wdWxhdGVVUkxGbGFncygpfSx0LnByb3RvdHlwZS5wb3B1bGF0ZVVSTEZsYWdzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZih2b2lkIDAhPT10aGlzLmdsb2JhbCYmdm9pZCAwIT09dGhpcy5nbG9iYWwubG9jYXRpb24mJnZvaWQgMCE9PXRoaXMuZ2xvYmFsLmxvY2F0aW9uLnNlYXJjaCl7dmFyIGU9cyh0aGlzLmdsb2JhbC5sb2NhdGlvbi5zZWFyY2gpO2lmKFwidGZqc2ZsYWdzXCJpbiBlKWUudGZqc2ZsYWdzLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciBuPWUuc3BsaXQoXCI6XCIpLHI9blswXSxvPW5bMV07dC51cmxGbGFnc1tyXT1mdW5jdGlvbih0LGUpe2lmKFwidHJ1ZVwiPT09KGU9ZS50b0xvd2VyQ2FzZSgpKXx8XCJmYWxzZVwiPT09ZSlyZXR1cm5cInRydWVcIj09PWU7aWYoXCJcIisgK2U9PT1lKXJldHVybitlO3Rocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSB2YWx1ZSBmbGFnIHZhbHVlIFwiK2UrXCIgZm9yIGZsYWcgXCIrdCtcIi5cIil9KHIsbyl9KX19LHR9KCk7ZnVuY3Rpb24gcyh0KXt2YXIgZT17fTtyZXR1cm4gdC5yZXBsYWNlKC9bPyZdKFtePT8mXSspKD86PShbXiZdKikpPy9nLGZ1bmN0aW9uKHQpe2Zvcih2YXIgbj1bXSxyPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyluW3ItMV09YXJndW1lbnRzW3JdO3JldHVybiBmdW5jdGlvbih0LGUsbil7dFtkZWNvZGVVUklDb21wb25lbnQoZSldPWRlY29kZVVSSUNvbXBvbmVudChufHxcIlwiKX0oZSxuWzBdLG5bMV0pLG4uam9pbihcIj1cIil9KSxlfWZ1bmN0aW9uIHUodCl7YT10fXZhciBsPU9iamVjdC5mcmVlemUoe0Vudmlyb25tZW50OmksZ2V0UXVlcnlQYXJhbXM6cyxnZXQgRU5WKCl7cmV0dXJuIGF9LHNldEVudmlyb25tZW50R2xvYmFsOnV9KTtmdW5jdGlvbiBjKHQpe2Zvcih2YXIgZT10Lmxlbmd0aCxuPTAscj0wO2U+MDspcj1NYXRoLnJhbmRvbSgpKmV8MCxuPXRbLS1lXSx0W2VdPXRbcl0sdFtyXT1ufWZ1bmN0aW9uIGgodCxlLG4pe3JldHVybiBNYXRoLm1heCh0LE1hdGgubWluKGUsbikpfWZ1bmN0aW9uIHAodCl7cmV0dXJuIHQlMj09MD90OnQrMX1mdW5jdGlvbiBmKHQpe2Zvcih2YXIgZT0wLG49MDtuPHQubGVuZ3RoO24rKyllKz10W25dO3JldHVybiBlfWZ1bmN0aW9uIGQodCxlKXtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmdcIj09dHlwZW9mIGU/ZTplKCkpfWZ1bmN0aW9uIHYodCxlLG4pe3ZvaWQgMD09PW4mJihuPVwiXCIpLGQoeCh0LGUpLGZ1bmN0aW9uKCl7cmV0dXJuIG4rXCIgU2hhcGVzIFwiK3QrXCIgYW5kIFwiK2UrXCIgbXVzdCBtYXRjaFwifSl9ZnVuY3Rpb24gbSh0KXtkKG51bGwhPXQsZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBpbnB1dCB0byB0aGUgdGVuc29yIGNvbnN0cnVjdG9yIG11c3QgYmUgYSBub24tbnVsbCB2YWx1ZS5cIn0pfWZ1bmN0aW9uIGcodCxlKXtpZih2b2lkIDA9PT1lJiYoZT1bXSksbnVsbD09ZSYmKGU9W10pLEFycmF5LmlzQXJyYXkodCl8fF8odCkpZm9yKHZhciBuPTA7bjx0Lmxlbmd0aDsrK24pZyh0W25dLGUpO2Vsc2UgZS5wdXNoKHQpO3JldHVybiBlfWZ1bmN0aW9uIHkodCl7aWYoMD09PXQubGVuZ3RoKXJldHVybiAxO2Zvcih2YXIgZT10WzBdLG49MTtuPHQubGVuZ3RoO24rKyllKj10W25dO3JldHVybiBlfWZ1bmN0aW9uIHgodCxlKXtpZih0PT09ZSlyZXR1cm4hMDtpZihudWxsPT10fHxudWxsPT1lKXJldHVybiExO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpcmV0dXJuITE7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspaWYodFtuXSE9PWVbbl0pcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gdyh0KXtyZXR1cm4gdCUxPT0wfWZ1bmN0aW9uIGIodCl7aWYobnVsbCE9TWF0aC50YW5oKXJldHVybiBNYXRoLnRhbmgodCk7aWYodD09PTEvMClyZXR1cm4gMTtpZih0PT09LTEvMClyZXR1cm4tMTt2YXIgZT1NYXRoLmV4cCgyKnQpO3JldHVybihlLTEpLyhlKzEpfWZ1bmN0aW9uIEModCl7dmFyIGU9TWF0aC5jZWlsKE1hdGguc3FydCh0KSk7cmV0dXJuW2UsTWF0aC5jZWlsKHQvZSldfWZ1bmN0aW9uIEUodCxlKXtyZXR1cm4gZTw9dC5sZW5ndGg/dDp0K1wiIFwiLnJlcGVhdChlLXQubGVuZ3RoKX1mdW5jdGlvbiBSKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ZnVuY3Rpb24odCl7cmV0dXJuIDB9KSxuZXcgUHJvbWlzZShmdW5jdGlvbihyLG8pe3ZhciBhPTAsaT1mdW5jdGlvbigpe2lmKHQoKSlyKCk7ZWxzZXt2YXIgcz1lKCsrYSk7bnVsbCE9biYmYT49bj9vKCk6c2V0VGltZW91dChpLHMpfX07aSgpfSl9ZnVuY3Rpb24gUyh0LGUpe2Zvcih2YXIgbj0xLHI9LTEsbz0wO288dC5sZW5ndGg7KytvKWlmKHRbb10+PTApbio9dFtvXTtlbHNlIGlmKC0xPT09dFtvXSl7aWYoLTEhPT1yKXRocm93IEVycm9yKFwiU2hhcGVzIGNhbiBvbmx5IGhhdmUgMSBpbXBsaWNpdCBzaXplLiBGb3VuZCAtMSBhdCBkaW0gXCIrcitcIiBhbmQgZGltIFwiK28pO3I9b31lbHNlIGlmKHRbb108MCl0aHJvdyBFcnJvcihcIlNoYXBlcyBjYW4gbm90IGJlIDwgMC4gRm91bmQgXCIrdFtvXStcIiBhdCBkaW0gXCIrbyk7aWYoLTE9PT1yKXtpZihlPjAmJmUhPT1uKXRocm93IEVycm9yKFwiU2l6ZShcIitlK1wiKSBtdXN0IG1hdGNoIHRoZSBwcm9kdWN0IG9mIHNoYXBlIFwiK3QpO3JldHVybiB0fWlmKDA9PT1uKXRocm93IEVycm9yKFwiQ2Fubm90IGluZmVyIHRoZSBtaXNzaW5nIHNpemUgaW4gW1wiK3QrXCJdIHdoZW4gdGhlcmUgYXJlIDAgZWxlbWVudHNcIik7aWYoZSVuIT0wKXRocm93IEVycm9yKFwiVGhlIGltcGxpY2l0IHNoYXBlIGNhbid0IGJlIGEgZnJhY3Rpb25hbCBudW1iZXIuIEdvdCBcIitlK1wiIC8gXCIrbik7dmFyIGE9dC5zbGljZSgpO3JldHVybiBhW3JdPWUvbixhfWZ1bmN0aW9uIE4odCxlKXt2YXIgbj1lLmxlbmd0aDtyZXR1cm4gZCgodD1udWxsPT10P2UubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV9KTpbXS5jb25jYXQodCkpLmV2ZXJ5KGZ1bmN0aW9uKHQpe3JldHVybiB0Pj0tbiYmdDxufSksZnVuY3Rpb24oKXtyZXR1cm5cIkFsbCB2YWx1ZXMgaW4gYXhpcyBwYXJhbSBtdXN0IGJlIGluIHJhbmdlIFstXCIrbitcIiwgXCIrbitcIikgYnV0IGdvdCBheGlzIFwiK3R9KSxkKHQuZXZlcnkoZnVuY3Rpb24odCl7cmV0dXJuIHcodCl9KSxmdW5jdGlvbigpe3JldHVyblwiQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW50ZWdlcnMgYnV0IGdvdCBheGlzIFwiK3R9KSx0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdDwwP24rdDp0fSl9ZnVuY3Rpb24gayh0LGUpe2Zvcih2YXIgbj1bXSxyPVtdLG89bnVsbD09ZT9udWxsOk4oZSx0KS5zb3J0KCksYT0wLGk9MDtpPHQubGVuZ3RoOysraSl7aWYobnVsbCE9byl7aWYob1thXT09PWkmJjEhPT10W2ldKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHNxdWVlemUgYXhpcyBcIitpK1wiIHNpbmNlIGl0cyBkaW0gJ1wiK3RbaV0rXCInIGlzIG5vdCAxXCIpOyhudWxsPT1vW2FdfHxvW2FdPmkpJiYxPT09dFtpXSYmKG4ucHVzaCh0W2ldKSxyLnB1c2goaSkpLG9bYV08PWkmJmErK30xIT09dFtpXSYmKG4ucHVzaCh0W2ldKSxyLnB1c2goaSkpfXJldHVybntuZXdTaGFwZTpuLGtlcHREaW1zOnJ9fWZ1bmN0aW9uIEkodCxlKXt2YXIgbj1udWxsO2lmKG51bGw9PXR8fFwiZmxvYXQzMlwiPT09dCluPW5ldyBGbG9hdDMyQXJyYXkoZSk7ZWxzZSBpZihcImludDMyXCI9PT10KW49bmV3IEludDMyQXJyYXkoZSk7ZWxzZXtpZihcImJvb2xcIiE9PXQpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIrdCk7bj1uZXcgVWludDhBcnJheShlKX1yZXR1cm4gbn1mdW5jdGlvbiBBKHQsZSl7dmFyIG49bnVsbDtpZihudWxsPT10fHxcImZsb2F0MzJcIj09PXQpbj1uZXcgRmxvYXQzMkFycmF5KGUpO2Vsc2UgaWYoXCJpbnQzMlwiPT09dCluPW5ldyBJbnQzMkFycmF5KGUpO2Vsc2UgaWYoXCJib29sXCI9PT10KW49bmV3IFVpbnQ4QXJyYXkoZSk7ZWxzZXtpZihcInN0cmluZ1wiIT09dCl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBcIit0KTtuPW5ldyBBcnJheShlKX1yZXR1cm4gbn1mdW5jdGlvbiBUKHQsZSxuKXtpZihcImZsb2F0MzJcIj09PWUpZm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBvPXRbcl07aWYoaXNOYU4obyl8fCFpc0Zpbml0ZShvKSl0aHJvdyBFcnJvcihcIlRoZSByZXN1bHQgb2YgdGhlICdcIituK1wiJyBpcyBcIitvK1wiLlwiKX19ZnVuY3Rpb24gRCh0LGUpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO2lmKGlzTmFOKHIpfHwhaXNGaW5pdGUocikpdGhyb3cgRXJyb3IoXCJBIHRlbnNvciBvZiB0eXBlIFwiK2UrXCIgYmVpbmcgdXBsb2FkZWQgY29udGFpbnMgXCIrcitcIi5cIil9fWZ1bmN0aW9uIE8odCxlKXtyZXR1cm5cImNvbXBsZXg2NFwiIT09ZSYmKChcImZsb2F0MzJcIiE9PWV8fFwiY29tcGxleDY0XCI9PT10KSYmKChcImludDMyXCIhPT1lfHxcImZsb2F0MzJcIj09PXR8fFwiY29tcGxleDY0XCI9PT10KSYmKFwiYm9vbFwiIT09ZXx8XCJib29sXCIhPT10KSkpfWZ1bmN0aW9uIF8odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXl8fHQgaW5zdGFuY2VvZiBJbnQzMkFycmF5fHx0IGluc3RhbmNlb2YgVWludDhBcnJheX1mdW5jdGlvbiBNKHQpe2lmKFwiZmxvYXQzMlwiPT09dHx8XCJpbnQzMlwiPT09dClyZXR1cm4gNDtpZihcImNvbXBsZXg2NFwiPT09dClyZXR1cm4gODtpZihcImJvb2xcIj09PXQpcmV0dXJuIDE7dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkdHlwZSBcIit0KX1mdW5jdGlvbiBGKHQpe2lmKG51bGw9PXQpcmV0dXJuIDA7dmFyIGU9MDtyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiBlKz0yKnQubGVuZ3RofSksZX1mdW5jdGlvbiBCKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0fHx0IGluc3RhbmNlb2YgU3RyaW5nfWZ1bmN0aW9uIFAodCl7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiB0fWZ1bmN0aW9uIEwodCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHR9ZnVuY3Rpb24gVyh0KXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0KT9XKHRbMF0pOnQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXk/XCJmbG9hdDMyXCI6dCBpbnN0YW5jZW9mIEludDMyQXJyYXl8fHQgaW5zdGFuY2VvZiBVaW50OEFycmF5P1wiaW50MzJcIjpMKHQpP1wiZmxvYXQzMlwiOkIodCk/XCJzdHJpbmdcIjpQKHQpP1wiYm9vbFwiOlwiZmxvYXQzMlwifWZ1bmN0aW9uIFUodCl7cmV0dXJuISEodCYmdC5jb25zdHJ1Y3RvciYmdC5jYWxsJiZ0LmFwcGx5KX1mdW5jdGlvbiB6KHQsZSl7Zm9yKHZhciBuPWU7bjx0OysrbilpZih0JW49PTApcmV0dXJuIG47cmV0dXJuIHR9ZnVuY3Rpb24gVih0KXt2YXIgZT10Lmxlbmd0aDtpZihlPDIpcmV0dXJuW107dmFyIG49bmV3IEFycmF5KGUtMSk7bltlLTJdPXRbZS0xXTtmb3IodmFyIHI9ZS0zO3I+PTA7LS1yKW5bcl09bltyKzFdKnRbcisxXTtyZXR1cm4gbn1mdW5jdGlvbiBHKHQsZSxuKXtpZihcInN0cmluZ1wiPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBhIHN0cmluZ1tdIHRvIGEgVHlwZWRBcnJheVwiKTtpZihBcnJheS5pc0FycmF5KHQpJiYodD1nKHQpKSxuJiZEKHQsZSksZnVuY3Rpb24odCxlKXtyZXR1cm4gdCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSYmXCJmbG9hdDMyXCI9PT1lfHx0IGluc3RhbmNlb2YgSW50MzJBcnJheSYmXCJpbnQzMlwiPT09ZXx8dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkmJlwiYm9vbFwiPT09ZX0odCxlKSlyZXR1cm4gdDtpZihudWxsPT1lfHxcImZsb2F0MzJcIj09PWV8fFwiY29tcGxleDY0XCI9PT1lKXJldHVybiBuZXcgRmxvYXQzMkFycmF5KHQpO2lmKFwiaW50MzJcIj09PWUpcmV0dXJuIG5ldyBJbnQzMkFycmF5KHQpO2lmKFwiYm9vbFwiPT09ZSl7Zm9yKHZhciByPW5ldyBVaW50OEFycmF5KHQubGVuZ3RoKSxvPTA7bzxyLmxlbmd0aDsrK28pMCE9PU1hdGgucm91bmQodFtvXSkmJihyW29dPTEpO3JldHVybiByfXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiK2UpfWZ1bmN0aW9uIHEodCxlKXtpZigwPT09dC5sZW5ndGgpcmV0dXJuIGVbMF07dmFyIG49dC5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSk7aWYoMD09PW4pcmV0dXJuW107aWYobiE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIltcIit0K1wiXSBkb2VzIG5vdCBtYXRjaCB0aGUgaW5wdXQgc2l6ZS5cIik7cmV0dXJuIGZ1bmN0aW9uIHQoZSxuLHIpe3ZhciBvPW5ldyBBcnJheTtpZigxPT09bi5sZW5ndGgpZm9yKHZhciBhPW5bMF0saT0wO2k8YTtpKyspb1tpXT1yW2UraV07ZWxzZXthPW5bMF07dmFyIHM9bi5zbGljZSgxKSx1PXMucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0pO2ZvcihpPTA7aTxhO2krKylvW2ldPXQoZStpKnUscyxyKX1yZXR1cm4gb30oMCx0LGUpfWZ1bmN0aW9uIEgodCxlKXtmb3IodmFyIG49JCh0LGUpLHI9MDtyPG4ubGVuZ3RoO3IrKyluW3JdPTE7cmV0dXJuIG59ZnVuY3Rpb24gJCh0LGUpe2lmKG51bGw9PWV8fFwiZmxvYXQzMlwiPT09ZXx8XCJjb21wbGV4NjRcIj09PWUpcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodCk7aWYoXCJpbnQzMlwiPT09ZSlyZXR1cm4gbmV3IEludDMyQXJyYXkodCk7aWYoXCJib29sXCI9PT1lKXJldHVybiBuZXcgVWludDhBcnJheSh0KTt0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBcIitlKX1mdW5jdGlvbiBqKCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHBlcmZvcm1hbmNlKXJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgcHJvY2Vzcyl7dmFyIHQ9cHJvY2Vzcy5ocnRpbWUoKTtyZXR1cm4gMWUzKnRbMF0rdFsxXS8xZTZ9dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1lYXN1cmUgdGltZSBpbiB0aGlzIGVudmlyb25tZW50LiBZb3Ugc2hvdWxkIHJ1biB0Zi5qcyBpbiB0aGUgYnJvd3NlciBvciBpbiBOb2RlLmpzXCIpfWZ1bmN0aW9uIEsodCl7dC5mb3JFYWNoKGZ1bmN0aW9uKGUpe2QoTnVtYmVyLmlzSW50ZWdlcihlKSYmZT49MCxmdW5jdGlvbigpe3JldHVyblwiVGVuc29yIG11c3QgaGF2ZSBhIHNoYXBlIGNvbXByaXNlZCBvZiBwb3NpdGl2ZSBpbnRlZ2VycyBidXQgZ290IHNoYXBlIFtcIit0K1wiXS5cIn0pfSl9dmFyIFgsWT1mdW5jdGlvbigpe2lmKG51bGwhPWEuZ2xvYmFsLmZldGNoKXJldHVybiBhLmdsb2JhbC5mZXRjaDtpZihhLmdldChcIklTX05PREVcIikpcmV0dXJuIFEuZmV0Y2hJbXBvcnQoKTt0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCB0aGUgZmV0Y2goKSBtZXRob2QuIFBsZWFzZSBhZGQgeW91ciBvd24gZmV0Y2goKSBmdW5jdGlvbiB0byB0aGUgZ2xvYmFsIG5hbWVzcGFjZS5cIil9LFE9e2ZldGNoSW1wb3J0OmZ1bmN0aW9uKCl7cmV0dXJuIHJlcXVpcmUoXCJub2RlLWZldGNoXCIpfX07ZnVuY3Rpb24gSih0LGUpe3JldHVybiBudWxsPT1YJiYoWD1ZKCkpLFgodCxlKX12YXIgWj1PYmplY3QuZnJlZXplKHtzaHVmZmxlOmMsY2xhbXA6aCxuZWFyZXN0TGFyZ2VyRXZlbjpwLHN1bTpmLHJhbmRVbmlmb3JtOmZ1bmN0aW9uKHQsZSl7dmFyIG49TWF0aC5yYW5kb20oKTtyZXR1cm4gZSpuKygxLW4pKnR9LGRpc3RTcXVhcmVkOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTAscj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbz1OdW1iZXIodFtyXSktTnVtYmVyKGVbcl0pO24rPW8qb31yZXR1cm4gbn0sYXNzZXJ0OmQsYXNzZXJ0U2hhcGVzTWF0Y2g6dixhc3NlcnROb25OdWxsOm0sZmxhdHRlbjpnLHNpemVGcm9tU2hhcGU6eSxpc1NjYWxhclNoYXBlOmZ1bmN0aW9uKHQpe3JldHVybiAwPT09dC5sZW5ndGh9LGFycmF5c0VxdWFsOngsaXNJbnQ6dyx0YW5oOmIsc2l6ZVRvU3F1YXJpc2hTaGFwZTpDLGNyZWF0ZVNodWZmbGVkSW5kaWNlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IFVpbnQzMkFycmF5KHQpLG49MDtuPHQ7KytuKWVbbl09bjtyZXR1cm4gYyhlKSxlfSxyaWdodFBhZDpFLHJlcGVhdGVkVHJ5OlIsaW5mZXJGcm9tSW1wbGljaXRTaGFwZTpTLHBhcnNlQXhpc1BhcmFtOk4sc3F1ZWV6ZVNoYXBlOmssZ2V0VHlwZWRBcnJheUZyb21EVHlwZTpJLGdldEFycmF5RnJvbURUeXBlOkEsY2hlY2tDb21wdXRhdGlvbkZvckVycm9yczpULGNoZWNrQ29udmVyc2lvbkZvckVycm9yczpELGhhc0VuY29kaW5nTG9zczpPLGlzVHlwZWRBcnJheTpfLGJ5dGVzUGVyRWxlbWVudDpNLGJ5dGVzRnJvbVN0cmluZ0FycmF5OkYsaXNTdHJpbmc6Qixpc0Jvb2xlYW46UCxpc051bWJlcjpMLGluZmVyRHR5cGU6Vyxpc0Z1bmN0aW9uOlUsbmVhcmVzdERpdmlzb3I6eixjb21wdXRlU3RyaWRlczpWLHRvVHlwZWRBcnJheTpHLHRvTmVzdGVkQXJyYXk6cSxtYWtlT25lc1R5cGVkQXJyYXk6SCxtYWtlWmVyb3NUeXBlZEFycmF5OiQsbm93OmosYXNzZXJ0Tm9uTmVnYXRpdmVJbnRlZ2VyRGltZW5zaW9uczpLLGdldE5vZGVGZXRjaDpRLGdldCBzeXN0ZW1GZXRjaCgpe3JldHVybiBYfSxmZXRjaDpKfSksdHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dGhpcy5iYWNrZW5kVGltZXI9dCx0aGlzLmxvZ2dlcj1lLG51bGw9PWUmJih0aGlzLmxvZ2dlcj1uZXcgZXQpfXJldHVybiB0LnByb3RvdHlwZS5wcm9maWxlS2VybmVsPWZ1bmN0aW9uKHQsZSl7dmFyIG4scj10aGlzLG89dGhpcy5iYWNrZW5kVGltZXIudGltZShmdW5jdGlvbigpe249ZSgpfSk7cmV0dXJuKEFycmF5LmlzQXJyYXkobik/bjpbbl0pLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIG49ZS5kYXRhU3luYygpO1QobixlLmR0eXBlLHQpLG8udGhlbihmdW5jdGlvbihvKXt2YXIgYT1cIlwiO251bGwhPW8uZ2V0RXh0cmFQcm9maWxlSW5mbyYmKGE9by5nZXRFeHRyYVByb2ZpbGVJbmZvKCkpLHIubG9nZ2VyLmxvZ0tlcm5lbFByb2ZpbGUodCxlLG4sby5rZXJuZWxNcyxhKX0pfSksbn0sdH0oKSxldD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLmxvZ0tlcm5lbFByb2ZpbGU9ZnVuY3Rpb24odCxlLG4scixvKXt2YXIgYT1FKHIrXCJtc1wiLDkpLGk9RSh0LDI1KSxzPWUucmFuayx1PWUuc2l6ZSxsPUUoZS5zaGFwZS50b1N0cmluZygpLDE0KTtjb25zb2xlLmxvZyhcIiVjXCIraStcIlxcdCVjXCIrYStcIlxcdCVjXCIrcytcIkQgXCIrbCtcIlxcdCVjXCIrdStcIlxcdCVjXCIrbyxcImZvbnQtd2VpZ2h0OmJvbGRcIixcImNvbG9yOnJlZFwiLFwiY29sb3I6Ymx1ZVwiLFwiY29sb3I6IG9yYW5nZVwiLFwiY29sb3I6IGdyZWVuXCIpfSx0fSgpLG50PTIwLHJ0PTMsb3Q9NztmdW5jdGlvbiBhdCh0LGUsbixyKXt2YXIgbz1WKGUpLGE9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89eShlKSxhPXJbci5sZW5ndGgtMV0saT1uZXcgQXJyYXkoYSkuZmlsbCgwKSxzPWUubGVuZ3RoLHU9XCJjb21wbGV4NjRcIj09PW4/dXQodCk6dDtpZihzPjEpZm9yKHZhciBsPTA7bDxvL2E7bCsrKWZvcih2YXIgYz1sKmEsaD0wO2g8YTtoKyspaVtoXT1NYXRoLm1heChpW2hdLGl0KHVbYytoXSwwLG4pLmxlbmd0aCk7cmV0dXJuIGl9KHQsZSxuLG8pLGk9ZS5sZW5ndGgscz1mdW5jdGlvbiB0KGUsbixyLG8sYSxpKXt2b2lkIDA9PT1pJiYoaT0hMCk7dmFyIHM9XCJjb21wbGV4NjRcIj09PXI/MjoxO3ZhciB1PW5bMF07dmFyIGw9bi5sZW5ndGg7aWYoMD09PWwpe2lmKFwiY29tcGxleDY0XCI9PT1yKXt2YXIgYz11dChlKTtyZXR1cm5baXQoY1swXSwwLHIpXX1yZXR1cm5cImJvb2xcIj09PXI/W3N0KGVbMF0pXTpbZVswXS50b1N0cmluZygpXX1pZigxPT09bCl7aWYodT5udCl7dmFyIGg9cnQqcyxwPUFycmF5LmZyb20oZS5zbGljZSgwLGgpKSxmPUFycmF5LmZyb20oZS5zbGljZSh1LXJ0KnMsdSkpO3JldHVyblwiY29tcGxleDY0XCI9PT1yJiYocD11dChwKSxmPXV0KGYpKSxbXCJbXCIrcC5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm4gaXQodCxhW2VdLHIpfSkuam9pbihcIiwgXCIpK1wiLCAuLi4sIFwiK2YubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGl0KHQsYVt1LXJ0K2VdLHIpfSkuam9pbihcIiwgXCIpK1wiXVwiXX12YXIgZD1cImNvbXBsZXg2NFwiPT09cj91dChlKTpBcnJheS5mcm9tKGUpO3JldHVybltcIltcIitkLm1hcChmdW5jdGlvbih0LGUpe3JldHVybiBpdCh0LGFbZV0scil9KS5qb2luKFwiLCBcIikrXCJdXCJdfXZhciB2PW4uc2xpY2UoMSk7dmFyIG09by5zbGljZSgxKTt2YXIgZz1vWzBdKnM7dmFyIHk9W107aWYodT5udCl7Zm9yKHZhciB4PTA7eDxydDt4Kyspe3ZhciB3PXgqZyxiPXcrZzt5LnB1c2guYXBwbHkoeSx0KGUuc2xpY2UodyxiKSx2LHIsbSxhLCExKSl9eS5wdXNoKFwiLi4uXCIpO2Zvcih2YXIgeD11LXJ0O3g8dTt4Kyspe3ZhciB3PXgqZyxiPXcrZzt5LnB1c2guYXBwbHkoeSx0KGUuc2xpY2UodyxiKSx2LHIsbSxhLHg9PT11LTEpKX19ZWxzZSBmb3IodmFyIHg9MDt4PHU7eCsrKXt2YXIgdz14KmcsYj13K2c7eS5wdXNoLmFwcGx5KHksdChlLnNsaWNlKHcsYiksdixyLG0sYSx4PT09dS0xKSl9dmFyIEM9Mj09PWw/XCIsXCI6XCJcIjt5WzBdPVwiW1wiK3lbMF0rQztmb3IodmFyIHg9MTt4PHkubGVuZ3RoLTE7eCsrKXlbeF09XCIgXCIreVt4XStDO3ZhciBFPVwiLFxcblwiO2Zvcih2YXIgeD0yO3g8bDt4KyspRSs9XCJcXG5cIjt5W3kubGVuZ3RoLTFdPVwiIFwiK3lbeS5sZW5ndGgtMV0rXCJdXCIrKGk/XCJcIjpFKTtyZXR1cm4geX0odCxlLG4sbyxhKSx1PVtcIlRlbnNvclwiXTtyZXR1cm4gciYmKHUucHVzaChcIiAgZHR5cGU6IFwiK24pLHUucHVzaChcIiAgcmFuazogXCIraSksdS5wdXNoKFwiICBzaGFwZTogW1wiK2UrXCJdXCIpLHUucHVzaChcIiAgdmFsdWVzOlwiKSksdS5wdXNoKHMubWFwKGZ1bmN0aW9uKHQpe3JldHVyblwiICAgIFwiK3R9KS5qb2luKFwiXFxuXCIpKSx1LmpvaW4oXCJcXG5cIil9ZnVuY3Rpb24gaXQodCxlLG4pe3JldHVybiBFKEFycmF5LmlzQXJyYXkodCk/cGFyc2VGbG9hdCh0WzBdLnRvRml4ZWQob3QpKStcIiArIFwiK3BhcnNlRmxvYXQodFsxXS50b0ZpeGVkKG90KSkrXCJqXCI6Qih0KT9cIidcIit0K1wiJ1wiOlwiYm9vbFwiPT09bj9zdCh0KTpwYXJzZUZsb2F0KHQudG9GaXhlZChvdCkpLnRvU3RyaW5nKCksZSl9ZnVuY3Rpb24gc3QodCl7cmV0dXJuIDA9PT10P1wiZmFsc2VcIjpcInRydWVcIn1mdW5jdGlvbiB1dCh0KXtmb3IodmFyIGU9W10sbj0wO248dC5sZW5ndGg7bis9MillLnB1c2goW3Rbbl0sdFtuKzFdXSk7cmV0dXJuIGV9dmFyIGx0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUsbil7dmFyIHI9dGhpcztpZih0aGlzLmR0eXBlPWUsdGhpcy5zaGFwZT10LnNsaWNlKCksdGhpcy5zaXplPXkodCksbnVsbCE9bil7dmFyIG89bi5sZW5ndGg7ZChvPT09dGhpcy5zaXplLGZ1bmN0aW9uKCl7cmV0dXJuXCJMZW5ndGggb2YgdmFsdWVzICdcIitvK1wiJyBkb2VzIG5vdCBtYXRjaCB0aGUgc2l6ZSBpbmZlcnJlZCBieSB0aGUgc2hhcGUgJ1wiK3Iuc2l6ZStcIicuXCJ9KX1pZihcImNvbXBsZXg2NFwiPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJjb21wbGV4NjQgZHR5cGUgVGVuc29yQnVmZmVycyBhcmUgbm90IHN1cHBvcnRlZC4gUGxlYXNlIGNyZWF0ZSBhIFRlbnNvckJ1ZmZlciBmb3IgdGhlIHJlYWwgYW5kIGltYWdpbmFyeSBwYXJ0cyBzZXBhcmF0ZWx5IGFuZCBjYWxsIHRmLmNvbXBsZXgocmVhbCwgaW1hZykuXCIpO3RoaXMudmFsdWVzPW58fEEoZSx0aGlzLnNpemUpLHRoaXMuc3RyaWRlcz1WKHQpfXJldHVybiB0LnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMsbj1bXSxyPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyluW3ItMV09YXJndW1lbnRzW3JdOzA9PT1uLmxlbmd0aCYmKG49WzBdKSxkKG4ubGVuZ3RoPT09dGhpcy5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgbnVtYmVyIG9mIHByb3ZpZGVkIGNvb3JkaW5hdGVzIChcIituLmxlbmd0aCtcIikgbXVzdCBtYXRjaCB0aGUgcmFuayAoXCIrZS5yYW5rK1wiKVwifSk7dmFyIG89dGhpcy5sb2NUb0luZGV4KG4pO3RoaXMudmFsdWVzW29dPXR9LHQucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxlPTA7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl0W2VdPWFyZ3VtZW50c1tlXTswPT09dC5sZW5ndGgmJih0PVswXSk7Zm9yKHZhciBuPTAscj0wLG89dDtyPG8ubGVuZ3RoO3IrKyl7dmFyIGE9b1tyXTtpZihhPDB8fGE+PXRoaXMuc2hhcGVbbl0pe3ZhciBpPVwiUmVxdWVzdGVkIG91dCBvZiByYW5nZSBlbGVtZW50IGF0IFwiK3QrXCIuICAgQnVmZmVyIHNoYXBlPVwiK3RoaXMuc2hhcGU7dGhyb3cgbmV3IEVycm9yKGkpfW4rK31mb3IodmFyIHM9dFt0Lmxlbmd0aC0xXSx1PTA7dTx0Lmxlbmd0aC0xOysrdSlzKz10aGlzLnN0cmlkZXNbdV0qdFt1XTtyZXR1cm4gdGhpcy52YWx1ZXNbc119LHQucHJvdG90eXBlLmxvY1RvSW5kZXg9ZnVuY3Rpb24odCl7aWYoMD09PXRoaXMucmFuaylyZXR1cm4gMDtpZigxPT09dGhpcy5yYW5rKXJldHVybiB0WzBdO2Zvcih2YXIgZT10W3QubGVuZ3RoLTFdLG49MDtuPHQubGVuZ3RoLTE7KytuKWUrPXRoaXMuc3RyaWRlc1tuXSp0W25dO3JldHVybiBlfSx0LnByb3RvdHlwZS5pbmRleFRvTG9jPWZ1bmN0aW9uKHQpe2lmKDA9PT10aGlzLnJhbmspcmV0dXJuW107aWYoMT09PXRoaXMucmFuaylyZXR1cm5bdF07Zm9yKHZhciBlPW5ldyBBcnJheSh0aGlzLnNoYXBlLmxlbmd0aCksbj0wO248ZS5sZW5ndGgtMTsrK24pZVtuXT1NYXRoLmZsb29yKHQvdGhpcy5zdHJpZGVzW25dKSx0LT1lW25dKnRoaXMuc3RyaWRlc1tuXTtyZXR1cm4gZVtlLmxlbmd0aC0xXT10LGV9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJhbmtcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2hhcGUubGVuZ3RofSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLnRvVGVuc29yPWZ1bmN0aW9uKCl7cmV0dXJuIGZ0Lm1ha2UodGhpcy5zaGFwZSx7dmFsdWVzOnRoaXMudmFsdWVzfSx0aGlzLmR0eXBlKX0sdH0oKSxjdD1udWxsLGh0PW51bGwscHQ9bnVsbDt2YXIgZnQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxuLHIsbyl7dGhpcy5rZXB0PSExLHRoaXMuaXNEaXNwb3NlZEludGVybmFsPSExLHRoaXMuc2hhcGU9dC5zbGljZSgpLHRoaXMuZHR5cGU9ZXx8XCJmbG9hdDMyXCIsdGhpcy5zaXplPXkodCksdGhpcy5zdHJpZGVzPVYodCksdGhpcy5kYXRhSWQ9bnVsbCE9cj9yOnt9LHRoaXMuaWQ9Y3QoKS5uZXh0VGVuc29ySWQoKSx0aGlzLnJhbmtUeXBlPXRoaXMucmFuazw1P3RoaXMucmFuay50b1N0cmluZygpOlwiaGlnaGVyXCIsY3QoKS5yZWdpc3RlclRlbnNvcih0aGlzLG8pLG51bGwhPW4mJmN0KCkud3JpdGUodGhpcy5kYXRhSWQsbil9cmV0dXJuIHQubWFrZT1mdW5jdGlvbihlLG4scixvKXtyZXR1cm4gbmV3IHQoZSxyLG4udmFsdWVzLG4uZGF0YUlkLG8pfSx0LnByb3RvdHlwZS5mbGF0dGVuPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5hczFEKCl9LHQucHJvdG90eXBlLmFzU2NhbGFyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksZCgxPT09dGhpcy5zaXplLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgYXJyYXkgbXVzdCBoYXZlIG9ubHkgMSBlbGVtZW50LlwifSksdGhpcy5yZXNoYXBlKFtdKX0sdC5wcm90b3R5cGUuYXMxRD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMucmVzaGFwZShbdGhpcy5zaXplXSl9LHQucHJvdG90eXBlLmFzMkQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnJlc2hhcGUoW3QsZV0pfSx0LnByb3RvdHlwZS5hczNEPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnJlc2hhcGUoW3QsZSxuXSl9LHQucHJvdG90eXBlLmFzNEQ9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5yZXNoYXBlKFt0LGUsbixyXSl9LHQucHJvdG90eXBlLmFzNUQ9ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnJlc2hhcGUoW3QsZSxuLHIsb10pfSx0LnByb3RvdHlwZS5hc1R5cGU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuY2FzdCh0aGlzLHQpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyYW5rXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNoYXBlLmxlbmd0aH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5idWZmZXI9ZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5kYXRhKCldO2Nhc2UgMTpyZXR1cm4gdD1lLnNlbnQoKSxbMixodC5idWZmZXIodGhpcy5zaGFwZSx0aGlzLmR0eXBlLHQpXX19KX0pfSx0LnByb3RvdHlwZS5idWZmZXJTeW5jPWZ1bmN0aW9uKCl7cmV0dXJuIGh0LmJ1ZmZlcih0aGlzLnNoYXBlLHRoaXMuZHR5cGUsdGhpcy5kYXRhU3luYygpKX0sdC5wcm90b3R5cGUuYXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5kYXRhKCldO2Nhc2UgMTpyZXR1cm4gdD1lLnNlbnQoKSxbMixxKHRoaXMuc2hhcGUsdCldfX0pfSl9LHQucHJvdG90eXBlLmFycmF5U3luYz1mdW5jdGlvbigpe3JldHVybiBxKHRoaXMuc2hhcGUsdGhpcy5kYXRhU3luYygpKX0sdC5wcm90b3R5cGUuZGF0YT1mdW5jdGlvbigpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBvKHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksWzIsY3QoKS5yZWFkKHRoaXMuZGF0YUlkKV19KX0pfSx0LnByb3RvdHlwZS5kYXRhU3luYz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGN0KCkucmVhZFN5bmModGhpcy5kYXRhSWQpfSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5pc0Rpc3Bvc2VkfHwoY3QoKS5kaXNwb3NlVGVuc29yKHRoaXMpLHRoaXMuaXNEaXNwb3NlZEludGVybmFsPSEwKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiaXNEaXNwb3NlZFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0Rpc3Bvc2VkSW50ZXJuYWx9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUudGhyb3dJZkRpc3Bvc2VkPWZ1bmN0aW9uKCl7aWYodGhpcy5pc0Rpc3Bvc2VkKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBpcyBkaXNwb3NlZC5cIil9LHQucHJvdG90eXBlLnRvRmxvYXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hc1R5cGUoXCJmbG9hdDMyXCIpfSx0LnByb3RvdHlwZS50b0ludD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFzVHlwZShcImludDMyXCIpfSx0LnByb3RvdHlwZS50b0Jvb2w9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hc1R5cGUoXCJib29sXCIpfSx0LnByb3RvdHlwZS5wcmludD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITEpLGh0LnByaW50KHRoaXMsdCl9LHQucHJvdG90eXBlLnJlc2hhcGU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQucmVzaGFwZSh0aGlzLHQpfSx0LnByb3RvdHlwZS5yZXNoYXBlQXM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5yZXNoYXBlKHQuc2hhcGUpfSx0LnByb3RvdHlwZS5leHBhbmREaW1zPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSxodC5leHBhbmREaW1zKHRoaXMsdCl9LHQucHJvdG90eXBlLmN1bXN1bT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLHZvaWQgMD09PWUmJihlPSExKSx2b2lkIDA9PT1uJiYobj0hMSksaHQuY3Vtc3VtKHRoaXMsdCxlLG4pfSx0LnByb3RvdHlwZS5zcXVlZXplPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnNxdWVlemUodGhpcyx0KX0sdC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5jbG9uZSh0aGlzKX0sdC5wcm90b3R5cGUub25lSG90PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5vbmVIb3QodGhpcyx0LGUsbil9LHQucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0hMSksYXQodGhpcy5kYXRhU3luYygpLHRoaXMuc2hhcGUsdGhpcy5kdHlwZSx0KX0sdC5wcm90b3R5cGUudGlsZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC50aWxlKHRoaXMsdCl9LHQucHJvdG90eXBlLmdhdGhlcj1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0wKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmdhdGhlcih0aGlzLHQsZSl9LHQucHJvdG90eXBlLm1hdE11bD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PWUmJihlPSExKSx2b2lkIDA9PT1uJiYobj0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5tYXRNdWwodGhpcyx0LGUsbil9LHQucHJvdG90eXBlLmRvdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5kb3QodGhpcyx0KX0sdC5wcm90b3R5cGUubm9ybT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PXQmJih0PVwiZXVjbGlkZWFuXCIpLHZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lm5vcm0odGhpcyx0LGUsbil9LHQucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc2xpY2UodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5yZXZlcnNlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnJldmVyc2UodGhpcyx0KX0sdC5wcm90b3R5cGUuY29uY2F0PWZ1bmN0aW9uKGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPTApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksZSBpbnN0YW5jZW9mIHQmJihlPVtlXSksaHQuY29uY2F0KFt0aGlzXS5jb25jYXQoZSksbil9LHQucHJvdG90eXBlLnNwbGl0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc3BsaXQodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5zdGFjaz1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0wKSxodC5zdGFjayhbdGhpcyx0XSxlKX0sdC5wcm90b3R5cGUudW5zdGFjaz1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksaHQudW5zdGFjayh0aGlzLHQpfSx0LnByb3RvdHlwZS5wYWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9MCksaHQucGFkKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuYmF0Y2hOb3JtYWxpemF0aW9uPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIHZvaWQgMD09PW4mJihuPS4wMDEpLHB0KFwidGYuYmF0Y2hOb3JtYWxpemF0aW9uKCkgaXMgZ29pbmcgYXdheS4gVXNlIHRmLmJhdGNoTm9ybSgpIGluc3RlYWQsIGFuZCBub3RlIHRoZSBwb3NpdGlvbmFsIGFyZ3VtZW50IGNoYW5nZSBvZiBzY2FsZSwgb2Zmc2V0LCBhbmQgdmFyaWFuY2VFcHNpbG9uXCIpLHRoaXMuYmF0Y2hOb3JtKHQsZSxvLHIsbil9LHQucHJvdG90eXBlLmJhdGNoTm9ybT1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB2b2lkIDA9PT1vJiYobz0uMDAxKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmJhdGNoTm9ybSh0aGlzLHQsZSxuLHIsbyl9LHQucHJvdG90eXBlLmFsbD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5hbGwodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5hbnk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuYW55KHRoaXMsdCxlKX0sdC5wcm90b3R5cGUubG9nU3VtRXhwPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmxvZ1N1bUV4cCh0aGlzLHQsZSl9LHQucHJvdG90eXBlLnN1bT1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zdW0odGhpcyx0LGUpfSx0LnByb3RvdHlwZS5wcm9kPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnByb2QodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5tZWFuPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lm1lYW4odGhpcyx0LGUpfSx0LnByb3RvdHlwZS5taW49ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubWluKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUubWF4PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lm1heCh0aGlzLHQsZSl9LHQucHJvdG90eXBlLmFyZ01pbj1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5hcmdNaW4odGhpcyx0KX0sdC5wcm90b3R5cGUuYXJnTWF4PWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmFyZ01heCh0aGlzLHQpfSx0LnByb3RvdHlwZS5jYXN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmNhc3QodGhpcyx0KX0sdC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmFkZCh0aGlzLHQpfSx0LnByb3RvdHlwZS5hZGRTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuYWRkU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmF0YW4yPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmF0YW4yKHRoaXMsdCl9LHQucHJvdG90eXBlLnN1Yj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zdWIodGhpcyx0KX0sdC5wcm90b3R5cGUuc3ViU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnN1YlN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQucG93KHRoaXMsdCl9LHQucHJvdG90eXBlLnBvd1N0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5wb3dTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUubXVsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lm11bCh0aGlzLHQpfSx0LnByb3RvdHlwZS5tdWxTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubXVsU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmRpdj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5kaXYodGhpcyx0KX0sdC5wcm90b3R5cGUuZmxvb3JEaXY9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuZmxvb3JEaXYodGhpcyx0KX0sdC5wcm90b3R5cGUuZGl2U3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmRpdlN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5taW5pbXVtPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lm1pbmltdW0odGhpcyx0KX0sdC5wcm90b3R5cGUubWluaW11bVN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5taW5pbXVtU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLm1heGltdW09ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubWF4aW11bSh0aGlzLHQpfSx0LnByb3RvdHlwZS5tYXhpbXVtU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lm1heGltdW1TdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lm1vZCh0aGlzLHQpfSx0LnByb3RvdHlwZS5tb2RTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubW9kU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLnNxdWFyZWREaWZmZXJlbmNlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnNxdWFyZWREaWZmZXJlbmNlKHRoaXMsdCl9LHQucHJvdG90eXBlLnNxdWFyZWREaWZmZXJlbmNlU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnNxdWFyZWREaWZmZXJlbmNlU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLnRyYW5zcG9zZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC50cmFuc3Bvc2UodGhpcyx0KX0sdC5wcm90b3R5cGUubm90RXF1YWw9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubm90RXF1YWwodGhpcyx0KX0sdC5wcm90b3R5cGUubm90RXF1YWxTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubm90RXF1YWxTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUubGVzcz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5sZXNzKHRoaXMsdCl9LHQucHJvdG90eXBlLmxlc3NTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubGVzc1N0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5lcXVhbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5lcXVhbCh0aGlzLHQpfSx0LnByb3RvdHlwZS5lcXVhbFN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5lcXVhbFN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5sZXNzRXF1YWw9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubGVzc0VxdWFsKHRoaXMsdCl9LHQucHJvdG90eXBlLmxlc3NFcXVhbFN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5sZXNzRXF1YWxTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUuZ3JlYXRlcj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5ncmVhdGVyKHRoaXMsdCl9LHQucHJvdG90eXBlLmdyZWF0ZXJTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuZ3JlYXRlclN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5ncmVhdGVyRXF1YWw9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuZ3JlYXRlckVxdWFsKHRoaXMsdCl9LHQucHJvdG90eXBlLmdyZWF0ZXJFcXVhbFN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5ncmVhdGVyRXF1YWxTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUubG9naWNhbEFuZD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5sb2dpY2FsQW5kKHRoaXMsdCl9LHQucHJvdG90eXBlLmxvZ2ljYWxPcj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5sb2dpY2FsT3IodGhpcyx0KX0sdC5wcm90b3R5cGUubG9naWNhbE5vdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmxvZ2ljYWxOb3QodGhpcyl9LHQucHJvdG90eXBlLmxvZ2ljYWxYb3I9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubG9naWNhbFhvcih0aGlzLHQpfSx0LnByb3RvdHlwZS53aGVyZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LndoZXJlKHQsdGhpcyxlKX0sdC5wcm90b3R5cGUubmVnPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubmVnKHRoaXMpfSx0LnByb3RvdHlwZS5jZWlsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuY2VpbCh0aGlzKX0sdC5wcm90b3R5cGUuZmxvb3I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5mbG9vcih0aGlzKX0sdC5wcm90b3R5cGUuc2lnbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnNpZ24odGhpcyl9LHQucHJvdG90eXBlLmlzTmFOPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuaXNOYU4odGhpcyl9LHQucHJvdG90eXBlLmlzSW5mPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuaXNJbmYodGhpcyl9LHQucHJvdG90eXBlLmlzRmluaXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuaXNGaW5pdGUodGhpcyl9LHQucHJvdG90eXBlLmV4cD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmV4cCh0aGlzKX0sdC5wcm90b3R5cGUuZXhwbTE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5leHBtMSh0aGlzKX0sdC5wcm90b3R5cGUubG9nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubG9nKHRoaXMpfSx0LnByb3RvdHlwZS5sb2cxcD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmxvZzFwKHRoaXMpfSx0LnByb3RvdHlwZS5zcXJ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc3FydCh0aGlzKX0sdC5wcm90b3R5cGUucnNxcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5yc3FydCh0aGlzKX0sdC5wcm90b3R5cGUuc3F1YXJlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc3F1YXJlKHRoaXMpfSx0LnByb3RvdHlwZS5yZWNpcHJvY2FsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQucmVjaXByb2NhbCh0aGlzKX0sdC5wcm90b3R5cGUuYWJzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuYWJzKHRoaXMpfSx0LnByb3RvdHlwZS5jbGlwQnlWYWx1ZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmNsaXBCeVZhbHVlKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUucmVsdT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnJlbHUodGhpcyl9LHQucHJvdG90eXBlLmVsdT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmVsdSh0aGlzKX0sdC5wcm90b3R5cGUuc2VsdT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnNlbHUodGhpcyl9LHQucHJvdG90eXBlLmxlYWt5UmVsdT1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9LjIpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubGVha3lSZWx1KHRoaXMsdCl9LHQucHJvdG90eXBlLnByZWx1PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnByZWx1KHRoaXMsdCl9LHQucHJvdG90eXBlLnNpZ21vaWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zaWdtb2lkKHRoaXMpfSx0LnByb3RvdHlwZS5sb2dTaWdtb2lkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubG9nU2lnbW9pZCh0aGlzKX0sdC5wcm90b3R5cGUuc29mdHBsdXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zb2Z0cGx1cyh0aGlzKX0sdC5wcm90b3R5cGUuemVyb3NMaWtlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuemVyb3NMaWtlKHRoaXMpfSx0LnByb3RvdHlwZS5vbmVzTGlrZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lm9uZXNMaWtlKHRoaXMpfSx0LnByb3RvdHlwZS5zaW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zaW4odGhpcyl9LHQucHJvdG90eXBlLmNvcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmNvcyh0aGlzKX0sdC5wcm90b3R5cGUudGFuPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQudGFuKHRoaXMpfSx0LnByb3RvdHlwZS5hc2luPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuYXNpbih0aGlzKX0sdC5wcm90b3R5cGUuYWNvcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmFjb3ModGhpcyl9LHQucHJvdG90eXBlLmF0YW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5hdGFuKHRoaXMpfSx0LnByb3RvdHlwZS5zaW5oPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc2luaCh0aGlzKX0sdC5wcm90b3R5cGUuY29zaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmNvc2godGhpcyl9LHQucHJvdG90eXBlLnRhbmg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC50YW5oKHRoaXMpfSx0LnByb3RvdHlwZS5hc2luaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmFzaW5oKHRoaXMpfSx0LnByb3RvdHlwZS5hY29zaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmFjb3NoKHRoaXMpfSx0LnByb3RvdHlwZS5hdGFuaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmF0YW5oKHRoaXMpfSx0LnByb3RvdHlwZS5lcmY9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5lcmYodGhpcyl9LHQucHJvdG90eXBlLnJvdW5kPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQucm91bmQodGhpcyl9LHQucHJvdG90eXBlLnN0ZXA9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc3RlcCh0aGlzLHQpfSx0LnByb3RvdHlwZS5zb2Z0bWF4PWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0tMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zb2Z0bWF4KHRoaXMsdCl9LHQucHJvdG90eXBlLmxvZ1NvZnRtYXg9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PS0xKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmxvZ1NvZnRtYXgodGhpcyx0KX0sdC5wcm90b3R5cGUucmVzaXplQmlsaW5lYXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuaW1hZ2UucmVzaXplQmlsaW5lYXIodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3I9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuaW1hZ2UucmVzaXplTmVhcmVzdE5laWdoYm9yKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuY29udjFkPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9XCJOV0NcIiksdm9pZCAwPT09byYmKG89MSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5jb252MWQodGhpcyx0LGUsbixyLG8sYSl9LHQucHJvdG90eXBlLmNvbnYyZD1mdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIHZvaWQgMD09PXImJihyPVwiTkhXQ1wiKSx2b2lkIDA9PT1vJiYobz1bMSwxXSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5jb252MmQodGhpcyx0LGUsbixyLG8sYSl9LHQucHJvdG90eXBlLmNvbnYyZFRyYW5zcG9zZT1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmNvbnYyZFRyYW5zcG9zZSh0aGlzLHQsZSxuLHIsbyl9LHQucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRD1mdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIHZvaWQgMD09PXImJihyPVwiTkhXQ1wiKSx2b2lkIDA9PT1vJiYobz1bMSwxXSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5kZXB0aHdpc2VDb252MmQodGhpcyx0LGUsbixyLG8sYSl9LHQucHJvdG90eXBlLnNlcGFyYWJsZUNvbnYyZD1mdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIHZvaWQgMD09PW8mJihvPVsxLDFdKSx2b2lkIDA9PT1hJiYoYT1cIk5IV0NcIiksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zZXBhcmFibGVDb252MmQodGhpcyx0LGUsbixyLG8sYSl9LHQucHJvdG90eXBlLmF2Z1Bvb2w9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuYXZnUG9vbCh0aGlzLHQsZSxuLHIpfSx0LnByb3RvdHlwZS5tYXhQb29sPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lm1heFBvb2wodGhpcyx0LGUsbixyKX0sdC5wcm90b3R5cGUubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb249ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHZvaWQgMD09PXQmJih0PTUpLHZvaWQgMD09PWUmJihlPTEpLHZvaWQgMD09PW4mJihuPTEpLHZvaWQgMD09PXImJihyPS41KSxodC5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbih0aGlzLHQsZSxuLHIpfSx0LnByb3RvdHlwZS5wb29sPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQucG9vbCh0aGlzLHQsZSxuLHIsbyl9LHQucHJvdG90eXBlLnZhcmlhYmxlPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksZHQudmFyaWFibGUodGhpcyx0LGUsbil9LHQucHJvdG90eXBlLnVuc29ydGVkU2VnbWVudFN1bT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnVuc29ydGVkU2VnbWVudFN1bSh0aGlzLHQsZSl9LHQucHJvdG90eXBlLmJhdGNoVG9TcGFjZU5EPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuYmF0Y2hUb1NwYWNlTkQodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5zcGFjZVRvQmF0Y2hORD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnNwYWNlVG9CYXRjaE5EKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUudG9waz1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD0xKSx2b2lkIDA9PT1lJiYoZT0hMCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC50b3BrKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuc3RyaWRlZFNsaWNlPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkscyl7cmV0dXJuIHZvaWQgMD09PXImJihyPTApLHZvaWQgMD09PW8mJihvPTApLHZvaWQgMD09PWEmJihhPTApLHZvaWQgMD09PWkmJihpPTApLHZvaWQgMD09PXMmJihzPTApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc3RyaWRlZFNsaWNlKHRoaXMsdCxlLG4scixvLGEsaSxzKX0sdC5wcm90b3R5cGUuZGVwdGhUb1NwYWNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuZGVwdGhUb1NwYWNlKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuZmZ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc3BlY3RyYWwuZmZ0KHRoaXMpfSx0LnByb3RvdHlwZS5pZmZ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc3BlY3RyYWwuaWZmdCh0aGlzKX0sdC5wcm90b3R5cGUucmZmdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnNwZWN0cmFsLnJmZnQodGhpcyl9LHQucHJvdG90eXBlLmlyZmZ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc3BlY3RyYWwuaXJmZnQodGhpcyl9LHR9KCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGZ0LFN5bWJvbC5oYXNJbnN0YW5jZSx7dmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuISF0JiZudWxsIT10LmRhdGFJZCYmbnVsbCE9dC5zaGFwZSYmbnVsbCE9dC5kdHlwZX19KTt2YXIgZHQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbihlLG4scil7dm9pZCAwPT09biYmKG49ITApO3ZhciBvPXQuY2FsbCh0aGlzLGUuc2hhcGUsZS5kdHlwZSxudWxsLGUuZGF0YUlkKXx8dGhpcztvLnRyYWluYWJsZT1uLG8ubmFtZT1yLG51bGw9PW8ubmFtZSYmKG8ubmFtZT1jdCgpLm5leHRWYXJpYWJsZUlkKCkudG9TdHJpbmcoKSk7dHJ5e2N0KCkucmVnaXN0ZXJWYXJpYWJsZShvKX1jYXRjaCh0KXt0aHJvdyBjdCgpLmRpc3Bvc2VUZW5zb3IobyksdH1yZXR1cm4gb31yZXR1cm4gZShuLHQpLG4udmFyaWFibGU9ZnVuY3Rpb24odCxlLHIsbyl7cmV0dXJuIHZvaWQgMD09PWUmJihlPSEwKSxudWxsIT1vJiZvIT09dC5kdHlwZSYmKHQ9dC5hc1R5cGUobykpLG5ldyBuKHQsZSxyKX0sbi5wcm90b3R5cGUuYXNzaWduPWZ1bmN0aW9uKHQpe2lmKHQuZHR5cGUhPT10aGlzLmR0eXBlKXRocm93IG5ldyBFcnJvcihcImR0eXBlIG9mIHRoZSBuZXcgdmFsdWUgKFwiK3QuZHR5cGUrXCIpIGFuZCBwcmV2aW91cyB2YWx1ZSAoXCIrdGhpcy5kdHlwZStcIikgbXVzdCBtYXRjaFwiKTtpZigheCh0LnNoYXBlLHRoaXMuc2hhcGUpKXRocm93IG5ldyBFcnJvcihcInNoYXBlIG9mIHRoZSBuZXcgdmFsdWUgKFwiK3Quc2hhcGUrXCIpIGFuZCBwcmV2aW91cyB2YWx1ZSAoXCIrdGhpcy5zaGFwZStcIikgbXVzdCBtYXRjaFwiKTtjdCgpLmRpc3Bvc2VUZW5zb3IodGhpcyksdGhpcy5kYXRhSWQ9dC5kYXRhSWQsY3QoKS5yZWdpc3RlclRlbnNvcih0aGlzKX0sbn0oZnQpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShkdCxTeW1ib2wuaGFzSW5zdGFuY2Use3ZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgZnQmJm51bGwhPXQuYXNzaWduJiZ0LmFzc2lnbiBpbnN0YW5jZW9mIEZ1bmN0aW9ufX0pO3ZhciB2dCxtdCxndCx5dCx4dCx3dD1kdC52YXJpYWJsZTshZnVuY3Rpb24odCl7dC5SMD1cIlIwXCIsdC5SMT1cIlIxXCIsdC5SMj1cIlIyXCIsdC5SMz1cIlIzXCIsdC5SND1cIlI0XCIsdC5SNT1cIlI1XCIsdC5SNj1cIlI2XCJ9KHZ0fHwodnQ9e30pKSxmdW5jdGlvbih0KXt0LmZsb2F0MzI9XCJmbG9hdDMyXCIsdC5pbnQzMj1cImludDMyXCIsdC5ib29sPVwiaW50MzJcIix0LmNvbXBsZXg2ND1cImNvbXBsZXg2NFwifShtdHx8KG10PXt9KSksZnVuY3Rpb24odCl7dC5mbG9hdDMyPVwiZmxvYXQzMlwiLHQuaW50MzI9XCJpbnQzMlwiLHQuYm9vbD1cImJvb2xcIix0LmNvbXBsZXg2ND1cImNvbXBsZXg2NFwifShndHx8KGd0PXt9KSksZnVuY3Rpb24odCl7dC5mbG9hdDMyPVwiZmxvYXQzMlwiLHQuaW50MzI9XCJmbG9hdDMyXCIsdC5ib29sPVwiZmxvYXQzMlwiLHQuY29tcGxleDY0PVwiY29tcGxleDY0XCJ9KHl0fHwoeXQ9e30pKSxmdW5jdGlvbih0KXt0LmZsb2F0MzI9XCJjb21wbGV4NjRcIix0LmludDMyPVwiY29tcGxleDY0XCIsdC5ib29sPVwiY29tcGxleDY0XCIsdC5jb21wbGV4NjQ9XCJjb21wbGV4NjRcIn0oeHR8fCh4dD17fSkpO3ZhciBidD17ZmxvYXQzMjp5dCxpbnQzMjptdCxib29sOmd0LGNvbXBsZXg2NDp4dH07ZnVuY3Rpb24gQ3QodCxlKXtpZihcInN0cmluZ1wiPT09dHx8XCJzdHJpbmdcIj09PWUpe2lmKFwic3RyaW5nXCI9PT10JiZcInN0cmluZ1wiPT09ZSlyZXR1cm5cInN0cmluZ1wiO3Rocm93IG5ldyBFcnJvcihcIkNhbiBub3QgdXBjYXN0IFwiK3QrXCIgd2l0aCBcIitlKX1yZXR1cm4gYnRbdF1bZV19ZnVuY3Rpb24gRXQodCl7cmV0dXJuIEN0KHQsXCJpbnQzMlwiKX1mdW5jdGlvbiBSdCh0LGUpe2lmKHQuZHR5cGU9PT1lLmR0eXBlKXJldHVyblt0LGVdO3ZhciBuPUN0KHQuZHR5cGUsZS5kdHlwZSk7cmV0dXJuW3QuY2FzdChuKSxlLmNhc3QobildfWZ1bmN0aW9uIFN0KHQsZSl7ZCh0LmR0eXBlPT09ZS5kdHlwZSxmdW5jdGlvbigpe3JldHVyblwiVGhlIGR0eXBlcyBvZiB0aGUgZmlyc3QoXCIrdC5kdHlwZStcIikgYW5kIHNlY29uZChcIitlLmR0eXBlK1wiKSBpbnB1dCBtdXN0IG1hdGNoXCJ9KX1mdW5jdGlvbiBOdCh0KXt2YXIgZT1bXTtyZXR1cm4gZnVuY3Rpb24gdChlLG4scil7aWYobnVsbD09ZSlyZXR1cm47aWYoZSBpbnN0YW5jZW9mIGZ0KXJldHVybiB2b2lkIG4ucHVzaChlKTtpZihvPWUsIUFycmF5LmlzQXJyYXkobykmJlwib2JqZWN0XCIhPXR5cGVvZiBvKXJldHVybjt2YXIgbzt2YXIgYT1lO2Zvcih2YXIgaSBpbiBhKXt2YXIgcz1hW2ldO3IuaGFzKHMpfHwoci5hZGQocyksdChzLG4scikpfX0odCxlLG5ldyBTZXQpLGV9dmFyIGt0LEl0PU9iamVjdC5mcmVlemUoe21ha2VUeXBlc01hdGNoOlJ0LGFzc2VydFR5cGVzTWF0Y2g6U3QsaXNUZW5zb3JJbkxpc3Q6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKylpZihlW25dLmlkPT09dC5pZClyZXR1cm4hMDtyZXR1cm4hMX0sZ2V0VGVuc29yc0luQ29udGFpbmVyOk50fSksQXQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5yZWdpc3RlcmVkVmFyaWFibGVzPXt9LHRoaXMubmV4dFRhcGVOb2RlSWQ9MCx0aGlzLm51bUJ5dGVzPTAsdGhpcy5udW1UZW5zb3JzPTAsdGhpcy5udW1TdHJpbmdUZW5zb3JzPTAsdGhpcy5udW1EYXRhQnVmZmVycz0wLHRoaXMuZ3JhZGllbnREZXB0aD0wLHRoaXMua2VybmVsRGVwdGg9MCx0aGlzLnNjb3BlU3RhY2s9W10sdGhpcy5uZXh0U2NvcGVJZD0wLHRoaXMudGVuc29ySW5mbz1uZXcgV2Vha01hcCx0aGlzLnByb2ZpbGluZz0hMSx0aGlzLmFjdGl2ZVByb2ZpbGU9e25ld0J5dGVzOjAsbmV3VGVuc29yczowLHBlYWtCeXRlczowLGtlcm5lbHM6W10scmVzdWx0Om51bGx9fXJldHVybiB0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMucmVnaXN0ZXJlZFZhcmlhYmxlcyl0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdF0uZGlzcG9zZSgpfSx0fSgpLFR0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLkVOVj10LHRoaXMucmVnaXN0cnk9e30sdGhpcy5yZWdpc3RyeUZhY3Rvcnk9e30sdGhpcy5zdGF0ZT1uZXcgQXR9cmV0dXJuIHQucHJvdG90eXBlLnJlYWR5PWZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZSxuO3JldHVybiBvKHRoaXMsZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDppZihudWxsIT10aGlzLnBlbmRpbmdCYWNrZW5kSW5pdClyZXR1cm5bMix0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdC50aGVuKGZ1bmN0aW9uKCl7fSldO2lmKG51bGwhPXRoaXMuYmFja2VuZEluc3RhbmNlKXJldHVyblsyXTt0PXRoaXMuZ2V0U29ydGVkQmFja2VuZHMoKSxlPTAsci5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gZTx0Lmxlbmd0aD8obj10W2VdLFs0LHRoaXMuaW5pdGlhbGl6ZUJhY2tlbmQobikuc3VjY2Vzc10pOlszLDRdO2Nhc2UgMjppZihyLnNlbnQoKSlyZXR1cm4gdGhpcy5zZXRCYWNrZW5kKG4pLFsyXTtyLmxhYmVsPTM7Y2FzZSAzOnJldHVybiBlKyssWzMsMV07Y2FzZSA0OnRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBpbml0aWFsaXplIGFueSBiYWNrZW5kcywgYWxsIGJhY2tlbmQgaW5pdGlhbGl6YXRpb25zIGZhaWxlZC5cIil9fSl9KX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiYmFja2VuZFwiLHtnZXQ6ZnVuY3Rpb24oKXtpZihudWxsIT10aGlzLnBlbmRpbmdCYWNrZW5kSW5pdCl0aHJvdyBuZXcgRXJyb3IoXCJCYWNrZW5kICdcIit0aGlzLmJhY2tlbmROYW1lK1wiJyBoYXMgbm90IHlldCBiZWVuIGluaXRpYWxpemVkLiBNYWtlIHN1cmUgdG8gYXdhaXQgdGYucmVhZHkoKSBiZWZvcmUgY2FsbGluZyBvdGhlciBtZXRob2RzXCIpO2lmKG51bGw9PXRoaXMuYmFja2VuZEluc3RhbmNlKXt2YXIgdD10aGlzLmluaXRpYWxpemVCYWNrZW5kc0FuZFJldHVybkJlc3QoKSxlPXQubmFtZTtpZih0LmFzeW5jSW5pdCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgaGlnaGVzdCBwcmlvcml0eSBiYWNrZW5kICdcIitlK1wiJyBoYXMgbm90IHlldCBiZWVuIGluaXRpYWxpemVkLiBNYWtlIHN1cmUgdG8gYXdhaXQgdGYucmVhZHkoKSBiZWZvcmUgY2FsbGluZyBvdGhlciBtZXRob2RzXCIpO3RoaXMuc2V0QmFja2VuZChlKX1yZXR1cm4gdGhpcy5iYWNrZW5kSW5zdGFuY2V9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuYmFja2VuZE5hbWVzPWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucmVnaXN0cnlGYWN0b3J5KX0sdC5wcm90b3R5cGUuZmluZEJhY2tlbmQ9ZnVuY3Rpb24odCl7aWYoISh0IGluIHRoaXMucmVnaXN0cnkpKXtpZighKHQgaW4gdGhpcy5yZWdpc3RyeUZhY3RvcnkpKXJldHVybiBudWxsO2lmKHRoaXMuaW5pdGlhbGl6ZUJhY2tlbmQodCkuYXN5bmNJbml0KXJldHVybiBudWxsfXJldHVybiB0aGlzLnJlZ2lzdHJ5W3RdfSx0LnByb3RvdHlwZS5maW5kQmFja2VuZEZhY3Rvcnk9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW4gdGhpcy5yZWdpc3RyeUZhY3Rvcnk/dGhpcy5yZWdpc3RyeUZhY3RvcnlbdF0uZmFjdG9yeTpudWxsfSx0LnByb3RvdHlwZS5yZWdpc3RlckJhY2tlbmQ9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0xKSx0IGluIHRoaXMucmVnaXN0cnlGYWN0b3J5Pyhjb25zb2xlLndhcm4odCtcIiBiYWNrZW5kIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWQuIFJldXNpbmcgZXhpc3RpbmcgYmFja2VuZCBmYWN0b3J5LlwiKSwhMSk6KHRoaXMucmVnaXN0cnlGYWN0b3J5W3RdPXtmYWN0b3J5OmUscHJpb3JpdHk6bn0sITApfSx0LnByb3RvdHlwZS5zZXRCYWNrZW5kPWZ1bmN0aW9uKHQpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLG4scjtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6aWYobnVsbD09dGhpcy5yZWdpc3RyeUZhY3RvcnlbdF0pdGhyb3cgbmV3IEVycm9yKFwiQmFja2VuZCBuYW1lICdcIit0K1wiJyBub3QgZm91bmQgaW4gcmVnaXN0cnlcIik7cmV0dXJuIHRoaXMuYmFja2VuZE5hbWU9dCxudWxsIT10aGlzLnJlZ2lzdHJ5W3RdP1szLDRdOih0aGlzLmJhY2tlbmRJbnN0YW5jZT1udWxsLGU9dGhpcy5pbml0aWFsaXplQmFja2VuZCh0KSxuPWUuc3VjY2VzcyxlLmFzeW5jSW5pdD9bNCxuXTpbMywyXSk7Y2FzZSAxOnJldHVybiByPW8uc2VudCgpLFszLDNdO2Nhc2UgMjpyPW4sby5sYWJlbD0zO2Nhc2UgMzppZighcilyZXR1cm5bMiwhMV07by5sYWJlbD00O2Nhc2UgNDpyZXR1cm4gdGhpcy5iYWNrZW5kSW5zdGFuY2U9dGhpcy5yZWdpc3RyeVt0XSx0aGlzLnByb2ZpbGVyPW5ldyB0dCh0aGlzLmJhY2tlbmRJbnN0YW5jZSksWzIsITBdfX0pfSl9LHQucHJvdG90eXBlLmluaXRpYWxpemVCYWNrZW5kPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj1EdC5yZWdpc3RyeUZhY3RvcnlbdF07aWYobnVsbD09bil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaW5pdGlhbGl6ZSBiYWNrZW5kIFwiK3QrXCIsIG5vIHJlZ2lzdHJhdGlvbiBmb3VuZC5cIik7dHJ5e3ZhciByPW4uZmFjdG9yeSgpO2lmKFByb21pc2UucmVzb2x2ZShyKT09PXIpe3ZhciBvPXIudGhlbihmdW5jdGlvbihuKXtyZXR1cm4gZS5yZWdpc3RyeVt0XT1uLGUucGVuZGluZ0JhY2tlbmRJbml0PW51bGwsITB9KS5jYXRjaChmdW5jdGlvbihuKXtyZXR1cm4gZS5wZW5kaW5nQmFja2VuZEluaXQ9bnVsbCxjb25zb2xlLndhcm4oXCJJbml0aWFsaXphdGlvbiBvZiBiYWNrZW5kIFwiK3QrXCIgZmFpbGVkXCIpLGNvbnNvbGUud2FybihuLnN0YWNrfHxuLm1lc3NhZ2UpLCExfSk7cmV0dXJuIHRoaXMucGVuZGluZ0JhY2tlbmRJbml0PW8se3N1Y2Nlc3M6byxhc3luY0luaXQ6ITB9fXJldHVybiB0aGlzLnJlZ2lzdHJ5W3RdPXIse3N1Y2Nlc3M6ITAsYXN5bmNJbml0OiExfX1jYXRjaChlKXtyZXR1cm4gY29uc29sZS53YXJuKFwiSW5pdGlhbGl6YXRpb24gb2YgYmFja2VuZCBcIit0K1wiIGZhaWxlZFwiKSxjb25zb2xlLndhcm4oZS5zdGFja3x8ZS5tZXNzYWdlKSx7c3VjY2VzczohMSxhc3luY0luaXQ6ITF9fX0sdC5wcm90b3R5cGUucmVtb3ZlQmFja2VuZD1mdW5jdGlvbih0KXtpZighKHQgaW4gdGhpcy5yZWdpc3RyeUZhY3RvcnkpKXRocm93IG5ldyBFcnJvcih0K1wiIGJhY2tlbmQgbm90IGZvdW5kIGluIHJlZ2lzdHJ5XCIpO3QgaW4gdGhpcy5yZWdpc3RyeSYmKHRoaXMucmVnaXN0cnlbdF0uZGlzcG9zZSgpLGRlbGV0ZSB0aGlzLnJlZ2lzdHJ5W3RdKSxkZWxldGUgdGhpcy5yZWdpc3RyeUZhY3RvcnlbdF19LHQucHJvdG90eXBlLmdldFNvcnRlZEJhY2tlbmRzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZigwPT09T2JqZWN0LmtleXModGhpcy5yZWdpc3RyeUZhY3RvcnkpLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJObyBiYWNrZW5kIGZvdW5kIGluIHJlZ2lzdHJ5LlwiKTtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5yZWdpc3RyeUZhY3RvcnkpLnNvcnQoZnVuY3Rpb24oZSxuKXtyZXR1cm4gdC5yZWdpc3RyeUZhY3Rvcnlbbl0ucHJpb3JpdHktdC5yZWdpc3RyeUZhY3RvcnlbZV0ucHJpb3JpdHl9KX0sdC5wcm90b3R5cGUuaW5pdGlhbGl6ZUJhY2tlbmRzQW5kUmV0dXJuQmVzdD1mdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdldFNvcnRlZEJhY2tlbmRzKCksZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgbj10W2VdLHI9dGhpcy5pbml0aWFsaXplQmFja2VuZChuKSxvPXIuc3VjY2VzcyxhPXIuYXN5bmNJbml0O2lmKGF8fG8pcmV0dXJue25hbWU6bixhc3luY0luaXQ6YX19dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGluaXRpYWxpemUgYW55IGJhY2tlbmRzLCBhbGwgYmFja2VuZCBpbml0aWFsaXphdGlvbnMgZmFpbGVkLlwiKX0sdC5wcm90b3R5cGUubW92ZURhdGE9ZnVuY3Rpb24odCl7dGhpcy53cml0ZSh0LHRoaXMucmVhZFN5bmModCkpfSx0LnByb3RvdHlwZS50aWR5PWZ1bmN0aW9uKHQsZSl7dmFyIG4scj10aGlzLG89bnVsbDtpZihudWxsPT1lKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGEgZnVuY3Rpb24gdG8gdGlkeSgpXCIpO2U9dH1lbHNle2lmKFwic3RyaW5nXCIhPXR5cGVvZiB0JiYhKHQgaW5zdGFuY2VvZiBTdHJpbmcpKXRocm93IG5ldyBFcnJvcihcIldoZW4gY2FsbGluZyB3aXRoIHR3byBhcmd1bWVudHMsIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aWR5KCkgbXVzdCBiZSBhIHN0cmluZ1wiKTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IG5ldyBFcnJvcihcIldoZW4gY2FsbGluZyB3aXRoIHR3byBhcmd1bWVudHMsIHRoZSAybmQgYXJndW1lbnQgdG8gdGlkeSgpIG11c3QgYmUgYSBmdW5jdGlvblwiKTtvPXR9cmV0dXJuIHRoaXMuc2NvcGVkUnVuKGZ1bmN0aW9uKCl7cmV0dXJuIHIuc3RhcnRTY29wZShvKX0sZnVuY3Rpb24oKXtyZXR1cm4gci5lbmRTY29wZShuKX0sZnVuY3Rpb24oKXtyZXR1cm4obj1lKCkpaW5zdGFuY2VvZiBQcm9taXNlJiZjb25zb2xlLmVycm9yKFwiQ2Fubm90IHJldHVybiBhIFByb21pc2UgaW5zaWRlIG9mIHRpZHkuXCIpLG59KX0sdC5wcm90b3R5cGUuc2NvcGVkUnVuPWZ1bmN0aW9uKHQsZSxuKXt0KCk7dHJ5e3ZhciByPW4oKTtyZXR1cm4gZSgpLHJ9Y2F0Y2godCl7dGhyb3cgZSgpLHR9fSx0LnByb3RvdHlwZS5uZXh0VGVuc29ySWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdC5uZXh0VGVuc29ySWQrK30sdC5wcm90b3R5cGUubmV4dFZhcmlhYmxlSWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdC5uZXh0VmFyaWFibGVJZCsrfSx0LnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbih0KXt2YXIgZT1mdC5tYWtlKHQuc2hhcGUse2RhdGFJZDp0LmRhdGFJZH0sdC5kdHlwZSk7cmV0dXJuIHRoaXMuYWRkVGFwZU5vZGUoW3RdLGUsZnVuY3Rpb24odCl7cmV0dXJuW3QudG9GbG9hdCgpXX0pLGV9LHQucHJvdG90eXBlLnJ1bktlcm5lbD1mdW5jdGlvbih0LGUsbil7dmFyIHIsbz10aGlzLGE9W10saT10aGlzLmlzVGFwZU9uKCkscz1udWxsIT10aGlzLnN0YXRlLmFjdGl2ZVNjb3BlP3RoaXMuc3RhdGUuYWN0aXZlU2NvcGUubmFtZTpcIlwiLHU9ZnVuY3Rpb24odCl7aSYmKGE9dC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIG8ua2VlcChvLmNsb25lKHQpKX0pKX0sbD10aGlzLnN0YXRlLm51bUJ5dGVzLGM9dGhpcy5zdGF0ZS5udW1UZW5zb3JzO2lmKHRoaXMuc2NvcGVkUnVuKGZ1bmN0aW9uKCl7cmV0dXJuIG8uc3RhdGUua2VybmVsRGVwdGgrK30sZnVuY3Rpb24oKXtyZXR1cm4gby5zdGF0ZS5rZXJuZWxEZXB0aC0tfSxmdW5jdGlvbigpe3I9by5FTlYuZ2V0Qm9vbChcIkRFQlVHXCIpP28ucHJvZmlsZXIucHJvZmlsZUtlcm5lbChzLGZ1bmN0aW9uKCl7cmV0dXJuIHQoby5iYWNrZW5kLHUpfSk6dChvLmJhY2tlbmQsdSl9KSxpKXt2YXIgaD17aWQ6dGhpcy5zdGF0ZS5uZXh0VGFwZU5vZGVJZCsrLG5hbWU6cyxpbnB1dHM6ZSxvdXRwdXRzOkFycmF5LmlzQXJyYXkocik/cjpbcl0sc2F2ZWQ6YX07bnVsbCE9biYmKGguZ3JhZGllbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIG4odCxhKX0pLHRoaXMuc3RhdGUuYWN0aXZlVGFwZS5wdXNoKGgpfXJldHVybiB0aGlzLnN0YXRlLnByb2ZpbGluZyYmdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLmtlcm5lbHMucHVzaCh7bmFtZTpzLGJ5dGVzQWRkZWQ6dGhpcy5zdGF0ZS5udW1CeXRlcy1sLHRvdGFsQnl0ZXNTbmFwc2hvdDp0aGlzLnN0YXRlLm51bUJ5dGVzLHRlbnNvcnNBZGRlZDp0aGlzLnN0YXRlLm51bVRlbnNvcnMtYyx0b3RhbFRlbnNvcnNTbmFwc2hvdDp0aGlzLnN0YXRlLm51bVRlbnNvcnMsaW5wdXRTaGFwZXM6T2JqZWN0LmtleXMoZSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdLnNoYXBlfSksb3V0cHV0U2hhcGU6QXJyYXkuaXNBcnJheShyKT9yLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZX0pOnIuc2hhcGV9KSxyfSx0LnByb3RvdHlwZS5yZWdpc3RlclRlbnNvcj1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuc3RhdGUudGVuc29ySW5mby5oYXModC5kYXRhSWQpP3RoaXMuc3RhdGUudGVuc29ySW5mby5nZXQodC5kYXRhSWQpLnJlZkNvdW50OjA7aWYodGhpcy5zdGF0ZS5udW1UZW5zb3JzKyssXCJzdHJpbmdcIj09PXQuZHR5cGUmJnRoaXMuc3RhdGUubnVtU3RyaW5nVGVuc29ycysrLDA9PT1uKXt0aGlzLnN0YXRlLm51bURhdGFCdWZmZXJzKys7dmFyIHI9MDtcImNvbXBsZXg2NFwiIT09dC5kdHlwZSYmXCJzdHJpbmdcIiE9PXQuZHR5cGUmJihyPXQuc2l6ZSpNKHQuZHR5cGUpKSx0aGlzLnN0YXRlLnRlbnNvckluZm8uc2V0KHQuZGF0YUlkLHtiYWNrZW5kOm51bGwhPWU/ZTp0aGlzLmJhY2tlbmQsZHR5cGU6dC5kdHlwZSxzaGFwZTp0LnNoYXBlLGJ5dGVzOnIscmVmQ291bnQ6MH0pLHRoaXMuc3RhdGUubnVtQnl0ZXMrPXIsbnVsbCE9ZT9lLnJlZ2lzdGVyKHQuZGF0YUlkLHQuc2hhcGUsdC5kdHlwZSk6dGhpcy5iYWNrZW5kLnJlZ2lzdGVyKHQuZGF0YUlkLHQuc2hhcGUsdC5kdHlwZSl9dGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldCh0LmRhdGFJZCkucmVmQ291bnQrKyx0IGluc3RhbmNlb2YgZHR8fHRoaXMudHJhY2sodCl9LHQucHJvdG90eXBlLnJlZ2lzdGVyVmFyaWFibGU9ZnVuY3Rpb24odCl7aWYobnVsbCE9dGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzW3QubmFtZV0pdGhyb3cgbmV3IEVycm9yKFwiVmFyaWFibGUgd2l0aCBuYW1lIFwiK3QubmFtZStcIiB3YXMgYWxyZWFkeSByZWdpc3RlcmVkXCIpO3RoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlc1t0Lm5hbWVdPXR9LHQucHJvdG90eXBlLmRpc3Bvc2VUZW5zb3I9ZnVuY3Rpb24odCl7aWYodGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmhhcyh0LmRhdGFJZCkpe3RoaXMuc3RhdGUubnVtVGVuc29ycy0tLFwic3RyaW5nXCI9PT10LmR0eXBlJiZ0aGlzLnN0YXRlLm51bVN0cmluZ1RlbnNvcnMtLTt2YXIgZT10aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KHQuZGF0YUlkKTtlLnJlZkNvdW50PD0xPyhcImNvbXBsZXg2NFwiIT09dC5kdHlwZSYmKHRoaXMuc3RhdGUubnVtQnl0ZXMtPWUuYnl0ZXMpLHRoaXMuc3RhdGUubnVtRGF0YUJ1ZmZlcnMtLSxlLmJhY2tlbmQuZGlzcG9zZURhdGEodC5kYXRhSWQpLHRoaXMuc3RhdGUudGVuc29ySW5mby5kZWxldGUodC5kYXRhSWQpKTp0aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KHQuZGF0YUlkKS5yZWZDb3VudC0tfX0sdC5wcm90b3R5cGUuZGlzcG9zZVZhcmlhYmxlcz1mdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLnN0YXRlLnJlZ2lzdGVyZWRWYXJpYWJsZXMpe3ZhciBlPXRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlc1t0XTt0aGlzLmRpc3Bvc2VUZW5zb3IoZSksZGVsZXRlIHRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlc1t0XX19LHQucHJvdG90eXBlLm1lbW9yeT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuYmFja2VuZC5tZW1vcnkoKTtyZXR1cm4gdC5udW1UZW5zb3JzPXRoaXMuc3RhdGUubnVtVGVuc29ycyx0Lm51bURhdGFCdWZmZXJzPXRoaXMuc3RhdGUubnVtRGF0YUJ1ZmZlcnMsdC5udW1CeXRlcz10aGlzLnN0YXRlLm51bUJ5dGVzLHRoaXMuc3RhdGUubnVtU3RyaW5nVGVuc29ycz4wJiYodC51bnJlbGlhYmxlPSEwLG51bGw9PXQucmVhc29ucyYmKHQucmVhc29ucz1bXSksdC5yZWFzb25zLnB1c2goXCJNZW1vcnkgdXNhZ2UgYnkgc3RyaW5nIHRlbnNvcnMgaXMgYXBwcm94aW1hdGUgKDIgYnl0ZXMgcGVyIGNoYXJhY3RlcilcIikpLHR9LHQucHJvdG90eXBlLnByb2ZpbGU9ZnVuY3Rpb24odCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsbjtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLnN0YXRlLnByb2ZpbGluZz0hMCxlPXRoaXMuc3RhdGUubnVtQnl0ZXMsbj10aGlzLnN0YXRlLm51bVRlbnNvcnMsdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLmtlcm5lbHM9W10sdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLnJlc3VsdD10KCksdGhpcy5zdGF0ZS5wcm9maWxpbmc9ITEsdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLnBlYWtCeXRlcz1NYXRoLm1heC5hcHBseShNYXRoLHRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5rZXJuZWxzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC50b3RhbEJ5dGVzU25hcHNob3R9KSksdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLm5ld0J5dGVzPXRoaXMuc3RhdGUubnVtQnl0ZXMtZSx0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUubmV3VGVuc29ycz10aGlzLnN0YXRlLm51bVRlbnNvcnMtbixbMix0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGVdfSl9KX0sdC5wcm90b3R5cGUuaXNUYXBlT249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZS5ncmFkaWVudERlcHRoPjAmJjA9PT10aGlzLnN0YXRlLmtlcm5lbERlcHRofSx0LnByb3RvdHlwZS5hZGRUYXBlTm9kZT1mdW5jdGlvbih0LGUsbil7dmFyIHI9e307dC5mb3JFYWNoKGZ1bmN0aW9uKHQsZSl7cltlXT10fSk7dmFyIG89e2lkOnRoaXMuc3RhdGUubmV4dFRhcGVOb2RlSWQrKyxuYW1lOnRoaXMuc3RhdGUuYWN0aXZlU2NvcGUubmFtZSxpbnB1dHM6cixvdXRwdXRzOltlXSxncmFkaWVudDpmdW5jdGlvbih0KXt2YXIgZT1uKHQpLHI9e307cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbih0LGUpe3JbZV09ZnVuY3Rpb24oKXtyZXR1cm4gdH19KSxyfX07dGhpcy5zdGF0ZS5hY3RpdmVUYXBlLnB1c2gobyl9LHQucHJvdG90eXBlLmtlZXA9ZnVuY3Rpb24odCl7cmV0dXJuIHQua2VwdD0hMCx0fSx0LnByb3RvdHlwZS5zdGFydFRhcGU9ZnVuY3Rpb24oKXswPT09dGhpcy5zdGF0ZS5ncmFkaWVudERlcHRoJiYodGhpcy5zdGF0ZS5hY3RpdmVUYXBlPVtdKSx0aGlzLnN0YXRlLmdyYWRpZW50RGVwdGgrK30sdC5wcm90b3R5cGUuZW5kVGFwZT1mdW5jdGlvbigpe3RoaXMuc3RhdGUuZ3JhZGllbnREZXB0aC0tfSx0LnByb3RvdHlwZS5zdGFydFNjb3BlPWZ1bmN0aW9uKHQpe3ZhciBlPXt0cmFjazpbXSxuYW1lOlwidW5uYW1lZCBzY29wZVwiLGlkOnRoaXMuc3RhdGUubmV4dFNjb3BlSWQrK307dCYmKGUubmFtZT10KSx0aGlzLnN0YXRlLnNjb3BlU3RhY2sucHVzaChlKSx0aGlzLnN0YXRlLmFjdGl2ZVNjb3BlPWV9LHQucHJvdG90eXBlLmVuZFNjb3BlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLG49TnQodCkscj1uZXcgU2V0KG4ubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlkfSkpLG89MDtvPHRoaXMuc3RhdGUuYWN0aXZlU2NvcGUudHJhY2subGVuZ3RoO28rKyl7dmFyIGE9dGhpcy5zdGF0ZS5hY3RpdmVTY29wZS50cmFja1tvXTthLmtlcHR8fHIuaGFzKGEuaWQpfHxhLmRpc3Bvc2UoKX12YXIgaT10aGlzLnN0YXRlLnNjb3BlU3RhY2sucG9wKCk7dGhpcy5zdGF0ZS5hY3RpdmVTY29wZT0wPT09dGhpcy5zdGF0ZS5zY29wZVN0YWNrLmxlbmd0aD9udWxsOnRoaXMuc3RhdGUuc2NvcGVTdGFja1t0aGlzLnN0YXRlLnNjb3BlU3RhY2subGVuZ3RoLTFdLG4uZm9yRWFjaChmdW5jdGlvbih0KXt0LmtlcHR8fHQuc2NvcGVJZCE9PWkuaWR8fGUudHJhY2sodCl9KX0sdC5wcm90b3R5cGUuZ3JhZGllbnRzPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPXRoaXM7aWYodm9pZCAwPT09ciYmKHI9ITEpLGQoZS5sZW5ndGg+MCxmdW5jdGlvbigpe3JldHVyblwiZ3JhZGllbnRzKCkgcmVjZWl2ZWQgYW4gZW1wdHkgbGlzdCBvZiB4cy5cIn0pLG51bGwhPW4mJlwiZmxvYXQzMlwiIT09bi5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJkeSBtdXN0IGhhdmUgJ2Zsb2F0MzInIGR0eXBlLCBidXQgaGFzICdcIituLmR0eXBlK1wiJ1wiKTt2YXIgYT10aGlzLnNjb3BlZFJ1bihmdW5jdGlvbigpe3JldHVybiBvLnN0YXJ0VGFwZSgpfSxmdW5jdGlvbigpe3JldHVybiBvLmVuZFRhcGUoKX0sZnVuY3Rpb24oKXtyZXR1cm4gby50aWR5KFwiZm9yd2FyZFwiLHQpfSk7ZChhIGluc3RhbmNlb2YgZnQsZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSByZXN1bHQgeSByZXR1cm5lZCBieSBmKCkgbXVzdCBiZSBhIHRlbnNvci5cIn0pO3ZhciBpPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9e30sbz17fSxhPTA7YTxlLmxlbmd0aDthKyspcltlW2FdLmlkXT0hMDtmb3IoYT0wO2E8dC5sZW5ndGg7YSsrKXt2YXIgaT0oZD10W2FdKS5pbnB1dHM7Zm9yKHZhciBzIGluIGkpe2Zvcih2YXIgdT1pW3NdLGw9ITEsYz0wO2M8ZS5sZW5ndGg7YysrKWlmKHJbdS5pZF0pe2Qub3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiByW3QuaWRdPSEwfSksbD0hMCxvW2QuaWRdPSEwO2JyZWFrfWlmKGwpYnJlYWt9fXZhciBoPXt9O2hbbi5pZF09ITA7dmFyIHA9e307Zm9yKGE9dC5sZW5ndGgtMTthPj0wO2EtLSlmb3IoaT0oZD10W2FdKS5pbnB1dHMsYz0wO2M8ZC5vdXRwdXRzLmxlbmd0aDtjKyspaWYoaFtkLm91dHB1dHNbY10uaWRdKXtmb3IodmFyIHMgaW4gaSloW2lbc10uaWRdPSEwLHBbZC5pZF09ITA7YnJlYWt9dmFyIGY9W107Zm9yKGE9MDthPHQubGVuZ3RoO2ErKyl7dmFyIGQ7aWYob1soZD10W2FdKS5pZF0mJnBbZC5pZF0pe3ZhciB2PXt9O2Zvcih2YXIgcyBpbiBkLmlucHV0cyl7dmFyIG09ZC5pbnB1dHNbc107clttLmlkXSYmKHZbc109bSl9dmFyIGc9T2JqZWN0LmFzc2lnbih7fSxkKTtnLmlucHV0cz12LGcub3V0cHV0cz1kLm91dHB1dHMsZi5wdXNoKGcpfX1yZXR1cm4gZn0odGhpcy5zdGF0ZS5hY3RpdmVUYXBlLGUsYSk7aWYoIXImJjA9PT1pLmxlbmd0aCYmZS5sZW5ndGg+MCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSBncmFkaWVudCBvZiB5PWYoeCkgd2l0aCByZXNwZWN0IHRvIHguIE1ha2Ugc3VyZSB0aGF0IHRoZSBmIHlvdSBwYXNzZWQgZW5jbG9zZXMgYWxsIG9wZXJhdGlvbnMgdGhhdCBsZWFkIGZyb20geCB0byB5LlwiKTtyZXR1cm4gdGhpcy50aWR5KFwiYmFja3dhcmRcIixmdW5jdGlvbigpe3ZhciB0LHIscz17fTtzW2EuaWRdPW51bGw9PW4/KHQ9YS5zaGFwZSxyPUgoeSh0KSxcImZsb2F0MzJcIiksZnQubWFrZSh0LHt2YWx1ZXM6cn0pKTpuLGZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9ZnVuY3Rpb24ocil7dmFyIG89ZVtyXSxhPVtdO2lmKG8ub3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciBuPXRbZS5pZF07aWYobnVsbCE9bilhLnB1c2gobik7ZWxzZXt2YXIgcj1mdC5tYWtlKGUuc2hhcGUse3ZhbHVlczokKGUuc2l6ZSxlLmR0eXBlKX0sZS5kdHlwZSk7YS5wdXNoKHIpfX0pLG51bGw9PW8uZ3JhZGllbnQpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgZ3JhZGllbnQ6IGdyYWRpZW50IGZ1bmN0aW9uIG5vdCBmb3VuZCBmb3IgXCIrby5uYW1lK1wiLlwiKTt2YXIgaT1vLmdyYWRpZW50KDE9PT1vLm91dHB1dHMubGVuZ3RoP2FbMF06YSkscz1mdW5jdGlvbihlKXtpZighKGUgaW4gaSkpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGJhY2twcm9wIHRocm91Z2ggaW5wdXQgXCIrZStcIi4gQXZhaWxhYmxlIGdyYWRpZW50cyBmb3VuZDogXCIrT2JqZWN0LmtleXMoaSkrXCIuXCIpO3ZhciByPW4oZnVuY3Rpb24oKXtyZXR1cm4gaVtlXSgpfSk7aWYoXCJmbG9hdDMyXCIhPT1yLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIGdyYWRpZW50IGZvciBvcCBcIitvLm5hbWUrXCIuIFRoZSBncmFkaWVudCBvZiBpbnB1dCBcIitlK1wiIG11c3QgaGF2ZSAnZmxvYXQzMicgZHR5cGUsIGJ1dCBoYXMgJ1wiK3IuZHR5cGUrXCInXCIpO3ZhciBhPW8uaW5wdXRzW2VdO2lmKCF4KHIuc2hhcGUsYS5zaGFwZSkpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gZ3JhZGllbnQgZm9yIG9wIFwiK28ubmFtZStcIi4gVGhlIGdyYWRpZW50IG9mIGlucHV0ICdcIitlK1wiJyBoYXMgc2hhcGUgJ1wiK3Iuc2hhcGUrXCInLCB3aGljaCBkb2VzIG5vdCBtYXRjaCB0aGUgc2hhcGUgb2YgdGhlIGlucHV0ICdcIithLnNoYXBlK1wiJ1wiKTtpZihudWxsPT10W2EuaWRdKXRbYS5pZF09cjtlbHNle3ZhciBzPXRbYS5pZF07dFthLmlkXT1zLmFkZChyKSxzLmRpc3Bvc2UoKX19O2Zvcih2YXIgdSBpbiBvLmlucHV0cylzKHUpfSxvPWUubGVuZ3RoLTE7bz49MDtvLS0pcihvKX0ocyxpLGZ1bmN0aW9uKHQpe3JldHVybiBvLnRpZHkodCl9KTt2YXIgdT1lLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gc1t0LmlkXX0pO3JldHVybiAwPT09by5zdGF0ZS5ncmFkaWVudERlcHRoJiYoby5zdGF0ZS5hY3RpdmVUYXBlLmZvckVhY2goZnVuY3Rpb24odCl7Zm9yKHZhciBlIGluIHQuc2F2ZWQpdC5zYXZlZFtlXS5kaXNwb3NlKCl9KSxvLnN0YXRlLmFjdGl2ZVRhcGU9bnVsbCkse3ZhbHVlOmEsZ3JhZHM6dX19KX0sdC5wcm90b3R5cGUuY3VzdG9tR3JhZD1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiBkKFUodCksZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgYmUgYSBmdW5jdGlvbi5cIn0pLGZ1bmN0aW9uKCl7Zm9yKHZhciBuLHI9W10sbz0wO288YXJndW1lbnRzLmxlbmd0aDtvKyspcltvXT1hcmd1bWVudHNbb107ZChyLmV2ZXJ5KGZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgZnR9KSxmdW5jdGlvbigpe3JldHVyblwiVGhlIGFyZ3MgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikoeDEsIHgyLC4uLikgbXVzdCBhbGwgYmUgdGVuc29yc1wifSk7dmFyIGE9e307cmV0dXJuIHIuZm9yRWFjaChmdW5jdGlvbih0LGUpe2FbZV09dH0pLGUucnVuS2VybmVsKGZ1bmN0aW9uKGUsbyl7cmV0dXJuIGQoKG49dC5hcHBseSh2b2lkIDAsci5jb25jYXQoW29dKSkpLnZhbHVlIGluc3RhbmNlb2YgZnQsZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aGVyZSBgb2JqLnZhbHVlYCBpcyBhIHRlbnNvclwifSksZChVKG4uZ3JhZEZ1bmMpLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZnVuY3Rpb24gZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IHJldHVybiBhbiBvYmplY3Qgd2hlcmUgYG9iai5ncmFkRnVuY2AgaXMgYSBmdW5jdGlvbi5cIn0pLG4udmFsdWV9LGEsZnVuY3Rpb24odCxlKXt2YXIgbz1uLmdyYWRGdW5jKHQsZSksYT1BcnJheS5pc0FycmF5KG8pP286W29dO2QoYS5sZW5ndGg9PT1yLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiVGhlIGZ1bmN0aW9uIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdoZXJlIGBvYmouZ3JhZEZ1bmNgIGlzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBzYW1lIG51bWJlciBvZiB0ZW5zb3JzIGFzIGlucHV0cyBwYXNzZWQgdG8gZiguLi4pLlwifSksZChhLmV2ZXJ5KGZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgZnR9KSxmdW5jdGlvbigpe3JldHVyblwiVGhlIGZ1bmN0aW9uIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdoZXJlIGBvYmouZ3JhZEZ1bmNgIGlzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgbGlzdCBvZiBvbmx5IHRlbnNvcnMuXCJ9KTt2YXIgaT17fTtyZXR1cm4gYS5mb3JFYWNoKGZ1bmN0aW9uKHQsZSl7aVtlXT1mdW5jdGlvbigpe3JldHVybiB0fX0pLGl9KX19LHQucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldCh0KTtpZihcInN0cmluZ1wiPT09bi5kdHlwZSl7dmFyIHI9RihlKTt0aGlzLnN0YXRlLm51bUJ5dGVzKz1yLW4uYnl0ZXMsbi5ieXRlcz1yfXRoaXMuYmFja2VuZCE9PW4uYmFja2VuZCYmKG4uYmFja2VuZC5kaXNwb3NlRGF0YSh0KSxuLmJhY2tlbmQ9dGhpcy5iYWNrZW5kLHRoaXMuYmFja2VuZC5yZWdpc3Rlcih0LG4uc2hhcGUsbi5kdHlwZSkpLHRoaXMuYmFja2VuZC53cml0ZSh0LGUpfSx0LnByb3RvdHlwZS5yZWFkU3luYz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldCh0KS5iYWNrZW5kLnJlYWRTeW5jKHQpfSx0LnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KHQpLmJhY2tlbmQucmVhZCh0KX0sdC5wcm90b3R5cGUuZnJvbVBpeGVscz1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmJhY2tlbmQuZnJvbVBpeGVscyh0LGUpfSx0LnByb3RvdHlwZS50aW1lPWZ1bmN0aW9uKHQpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLG47cmV0dXJuIG8odGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybiBlPWooKSxbNCx0aGlzLmJhY2tlbmQudGltZSh0KV07Y2FzZSAxOnJldHVybihuPXIuc2VudCgpKS53YWxsTXM9aigpLWUsWzIsbl19fSl9KX0sdC5wcm90b3R5cGUudHJhY2s9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPXRoaXMuc3RhdGUuYWN0aXZlU2NvcGUmJih0LnNjb3BlSWQ9dGhpcy5zdGF0ZS5hY3RpdmVTY29wZS5pZCx0aGlzLnN0YXRlLmFjdGl2ZVNjb3BlLnRyYWNrLnB1c2godCkpLHR9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJlZ2lzdGVyZWRWYXJpYWJsZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLnN0YXRlLmRpc3Bvc2UoKSx0aGlzLkVOVi5yZXNldCgpLHRoaXMuc3RhdGU9bmV3IEF0LHRoaXMucmVnaXN0cnkpdGhpcy5yZWdpc3RyeVt0XS5kaXNwb3NlKCksZGVsZXRlIHRoaXMucmVnaXN0cnlbdF07dGhpcy5iYWNrZW5kTmFtZT1udWxsLHRoaXMuYmFja2VuZEluc3RhbmNlPW51bGx9LHQubmV4dFRlbnNvcklkPTAsdC5uZXh0VmFyaWFibGVJZD0wLHR9KCk7dmFyIER0PWZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24oKXtpZihudWxsPT1rdCl7dmFyIHQ9dm9pZCAwO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cpdD13aW5kb3c7ZWxzZSBpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsKXQ9Z2xvYmFsO2Vsc2V7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHByb2Nlc3MpdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYSBnbG9iYWwgb2JqZWN0XCIpO3Q9cHJvY2Vzc31rdD10fXJldHVybiBrdH0oKTtpZihudWxsPT10Ll90ZmVuZ2luZSl7dmFyIGU9bmV3IGkodCk7dC5fdGZlbmdpbmU9bmV3IFR0KGUpfXJldHVybiB1KHQuX3RmZW5naW5lLkVOViksY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdC5fdGZlbmdpbmV9LHQuX3RmZW5naW5lfSgpO2Z1bmN0aW9uIE90KCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvd31hLnJlZ2lzdGVyRmxhZyhcIkRFQlVHXCIsZnVuY3Rpb24oKXtyZXR1cm4hMX0sZnVuY3Rpb24odCl7dCYmY29uc29sZS53YXJuKFwiRGVidWdnaW5nIG1vZGUgaXMgT04uIFRoZSBvdXRwdXQgb2YgZXZlcnkgbWF0aCBjYWxsIHdpbGwgYmUgZG93bmxvYWRlZCB0byBDUFUgYW5kIGNoZWNrZWQgZm9yIE5hTnMuIFRoaXMgc2lnbmlmaWNhbnRseSBpbXBhY3RzIHBlcmZvcm1hbmNlLlwiKX0pLGEucmVnaXN0ZXJGbGFnKFwiSVNfQlJPV1NFUlwiLGZ1bmN0aW9uKCl7cmV0dXJuIE90KCl9KSxhLnJlZ2lzdGVyRmxhZyhcIklTX05PREVcIixmdW5jdGlvbigpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBwcm9jZXNzJiZ2b2lkIDAhPT1wcm9jZXNzLnZlcnNpb25zJiZ2b2lkIDAhPT1wcm9jZXNzLnZlcnNpb25zLm5vZGV9KSxhLnJlZ2lzdGVyRmxhZyhcIklTX0NIUk9NRVwiLGZ1bmN0aW9uKCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG5hdmlnYXRvciYmbnVsbCE9bmF2aWdhdG9yJiZudWxsIT1uYXZpZ2F0b3IudXNlckFnZW50JiYvQ2hyb21lLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpJiYvR29vZ2xlIEluYy8udGVzdChuYXZpZ2F0b3IudmVuZG9yKX0pLGEucmVnaXN0ZXJGbGFnKFwiUFJPRFwiLGZ1bmN0aW9uKCl7cmV0dXJuITF9KSxhLnJlZ2lzdGVyRmxhZyhcIlRFTlNPUkxJS0VfQ0hFQ0tfU0hBUEVfQ09OU0lTVEVOQ1lcIixmdW5jdGlvbigpe3JldHVybiFhLmdldEJvb2woXCJQUk9EXCIpfSksYS5yZWdpc3RlckZsYWcoXCJERVBSRUNBVElPTl9XQVJOSU5HU19FTkFCTEVEXCIsZnVuY3Rpb24oKXtyZXR1cm4hMH0pLGEucmVnaXN0ZXJGbGFnKFwiSVNfVEVTVFwiLGZ1bmN0aW9uKCl7cmV0dXJuITF9KTt2YXIgX3Q9e30sTXQ9e2FscGhhOiExLGFudGlhbGlhczohMSxwcmVtdWx0aXBsaWVkQWxwaGE6ITEscHJlc2VydmVEcmF3aW5nQnVmZmVyOiExLGRlcHRoOiExLHN0ZW5jaWw6ITEsZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDohMH07ZnVuY3Rpb24gRnQodCl7dCBpbiBfdHx8KF90W3RdPWZ1bmN0aW9uKHQpe2lmKDEhPT10JiYyIT09dCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0LCBXZWJHTCBpcyBkaXNhYmxlZC5cIik7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtpZihlLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpLGRlbGV0ZSBfdFt0XX0sITEpLDE9PT10KXJldHVybiBlLmdldENvbnRleHQoXCJ3ZWJnbFwiLE10KXx8ZS5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsTXQpO3JldHVybiBlLmdldENvbnRleHQoXCJ3ZWJnbDJcIixNdCl9KHQpKTt2YXIgZT1fdFt0XTtyZXR1cm4gZS5pc0NvbnRleHRMb3N0KCk/KGRlbGV0ZSBfdFt0XSxGdCh0KSk6KGUuZGlzYWJsZShlLkRFUFRIX1RFU1QpLGUuZGlzYWJsZShlLlNURU5DSUxfVEVTVCksZS5kaXNhYmxlKGUuQkxFTkQpLGUuZGlzYWJsZShlLkRJVEhFUiksZS5kaXNhYmxlKGUuUE9MWUdPTl9PRkZTRVRfRklMTCksZS5kaXNhYmxlKGUuU0FNUExFX0NPVkVSQUdFKSxlLmVuYWJsZShlLlNDSVNTT1JfVEVTVCksZS5lbmFibGUoZS5DVUxMX0ZBQ0UpLGUuY3VsbEZhY2UoZS5CQUNLKSxfdFt0XSl9ZnVuY3Rpb24gQnQodCxlLG4pe3ZhciByPW4oKTtyZXR1cm4gZSYmZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRFcnJvcigpO2lmKGUhPT10Lk5PX0VSUk9SKXRocm93IG5ldyBFcnJvcihcIldlYkdMIEVycm9yOiBcIitVdCh0LGUpKX0odCkscn12YXIgUHQ9NS45NmUtOCxMdD02NTUwNDtmdW5jdGlvbiBXdCh0KXtyZXR1cm4hIShhLmdldEJvb2woXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEXCIpfHwwPT09dHx8UHQ8TWF0aC5hYnModCkmJk1hdGguYWJzKHQpPEx0KX1mdW5jdGlvbiBVdCh0LGUpe3N3aXRjaChlKXtjYXNlIHQuTk9fRVJST1I6cmV0dXJuXCJOT19FUlJPUlwiO2Nhc2UgdC5JTlZBTElEX0VOVU06cmV0dXJuXCJJTlZBTElEX0VOVU1cIjtjYXNlIHQuSU5WQUxJRF9WQUxVRTpyZXR1cm5cIklOVkFMSURfVkFMVUVcIjtjYXNlIHQuSU5WQUxJRF9PUEVSQVRJT046cmV0dXJuXCJJTlZBTElEX09QRVJBVElPTlwiO2Nhc2UgdC5JTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTjpyZXR1cm5cIklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OXCI7Y2FzZSB0Lk9VVF9PRl9NRU1PUlk6cmV0dXJuXCJPVVRfT0ZfTUVNT1JZXCI7Y2FzZSB0LkNPTlRFWFRfTE9TVF9XRUJHTDpyZXR1cm5cIkNPTlRFWFRfTE9TVF9XRUJHTFwiO2RlZmF1bHQ6cmV0dXJuXCJVbmtub3duIGVycm9yIGNvZGUgXCIrZX19ZnVuY3Rpb24genQodCxlLG4pe3JldHVybiBoZSh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5nZXRFeHRlbnNpb24obil9LCdFeHRlbnNpb24gXCInK24rJ1wiIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyLicpfWZ1bmN0aW9uIFZ0KHQsZSxuKXt2YXIgcj1oZSh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5jcmVhdGVTaGFkZXIodC5WRVJURVhfU0hBREVSKX0sXCJVbmFibGUgdG8gY3JlYXRlIHZlcnRleCBXZWJHTFNoYWRlci5cIik7aWYoQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuc2hhZGVyU291cmNlKHIsbil9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5jb21waWxlU2hhZGVyKHIpfSksITE9PT10LmdldFNoYWRlclBhcmFtZXRlcihyLHQuQ09NUElMRV9TVEFUVVMpKXRocm93IGNvbnNvbGUubG9nKHQuZ2V0U2hhZGVySW5mb0xvZyhyKSksbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNvbXBpbGUgdmVydGV4IHNoYWRlci5cIik7cmV0dXJuIHJ9ZnVuY3Rpb24gR3QodCxlLG4pe3ZhciByPWhlKHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmNyZWF0ZVNoYWRlcih0LkZSQUdNRU5UX1NIQURFUil9LFwiVW5hYmxlIHRvIGNyZWF0ZSBmcmFnbWVudCBXZWJHTFNoYWRlci5cIik7aWYoQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuc2hhZGVyU291cmNlKHIsbil9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5jb21waWxlU2hhZGVyKHIpfSksITE9PT10LmdldFNoYWRlclBhcmFtZXRlcihyLHQuQ09NUElMRV9TVEFUVVMpKXRocm93IGZ1bmN0aW9uKHQsZSl7dmFyIG49JHQuZXhlYyhlKTtpZihudWxsPT1uKXJldHVybiBjb25zb2xlLmxvZyhcIkNvdWxkbid0IHBhcnNlIGxpbmUgbnVtYmVyIGluIGVycm9yOiBcIitlKSx2b2lkIGNvbnNvbGUubG9nKHQpO2Zvcih2YXIgcj0rblsxXSxvPXQuc3BsaXQoXCJcXG5cIiksYT1vLmxlbmd0aC50b1N0cmluZygpLmxlbmd0aCsyLGk9by5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm4gRSgoZSsxKS50b1N0cmluZygpLGEpK3R9KSxzPTAsdT0wO3U8aS5sZW5ndGg7dSsrKXM9TWF0aC5tYXgoaVt1XS5sZW5ndGgscyk7dmFyIGw9aS5zbGljZSgwLHItMSksYz1pLnNsaWNlKHItMSxyKSxoPWkuc2xpY2Uocik7Y29uc29sZS5sb2cobC5qb2luKFwiXFxuXCIpKSxjb25zb2xlLmxvZyhlLnNwbGl0KFwiXFxuXCIpWzBdKSxjb25zb2xlLmxvZyhcIiVjIFwiK0UoY1swXSxzKSxcImJvcmRlcjoxcHggc29saWQgcmVkOyBiYWNrZ3JvdW5kLWNvbG9yOiNlM2QyZDI7IGNvbG9yOiNhNjE3MTdcIiksY29uc29sZS5sb2coaC5qb2luKFwiXFxuXCIpKX0obix0LmdldFNoYWRlckluZm9Mb2cocikpLG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb21waWxlIGZyYWdtZW50IHNoYWRlci5cIik7cmV0dXJuIHJ9dmFyIHF0LEh0LCR0PS9FUlJPUjogWzAtOV0rOihbMC05XSspOi9nO2Z1bmN0aW9uIGp0KHQsZSl7cmV0dXJuIGhlKHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmNyZWF0ZVByb2dyYW0oKX0sXCJVbmFibGUgdG8gY3JlYXRlIFdlYkdMUHJvZ3JhbS5cIil9ZnVuY3Rpb24gS3QodCxlLG4pe2lmKEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmxpbmtQcm9ncmFtKG4pfSksITE9PT10LmdldFByb2dyYW1QYXJhbWV0ZXIobix0LkxJTktfU1RBVFVTKSl0aHJvdyBjb25zb2xlLmxvZyh0LmdldFByb2dyYW1JbmZvTG9nKG4pKSxuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbGluayB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlcnMuXCIpfWZ1bmN0aW9uIFh0KHQsZSxuKXtpZihCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC52YWxpZGF0ZVByb2dyYW0obil9KSwhMT09PXQuZ2V0UHJvZ3JhbVBhcmFtZXRlcihuLHQuVkFMSURBVEVfU1RBVFVTKSl0aHJvdyBjb25zb2xlLmxvZyh0LmdldFByb2dyYW1JbmZvTG9nKG4pKSxuZXcgRXJyb3IoXCJTaGFkZXIgcHJvZ3JhbSB2YWxpZGF0aW9uIGZhaWxlZC5cIil9ZnVuY3Rpb24gWXQodCxlLG4pe3ZhciByPWhlKHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmNyZWF0ZUJ1ZmZlcigpfSxcIlVuYWJsZSB0byBjcmVhdGUgV2ViR0xCdWZmZXJcIik7cmV0dXJuIEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmJpbmRCdWZmZXIodC5BUlJBWV9CVUZGRVIscil9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5idWZmZXJEYXRhKHQuQVJSQVlfQlVGRkVSLG4sdC5TVEFUSUNfRFJBVyl9KSxyfWZ1bmN0aW9uIFF0KHQsZSxuKXt2YXIgcj1oZSh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5jcmVhdGVCdWZmZXIoKX0sXCJVbmFibGUgdG8gY3JlYXRlIFdlYkdMQnVmZmVyXCIpO3JldHVybiBCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kQnVmZmVyKHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIscil9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5idWZmZXJEYXRhKHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIsbix0LlNUQVRJQ19EUkFXKX0pLHJ9ZnVuY3Rpb24gSnQoKXtyZXR1cm4gMj09PWEuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKT8xOjR9ZnVuY3Rpb24gWnQodCxlKXtyZXR1cm4gaGUodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuY3JlYXRlVGV4dHVyZSgpfSxcIlVuYWJsZSB0byBjcmVhdGUgV2ViR0xUZXh0dXJlLlwiKX1mdW5jdGlvbiB0ZSh0LGUpe3ZhciBuPWEuZ2V0TnVtYmVyKFwiV0VCR0xfTUFYX1RFWFRVUkVfU0laRVwiKTtpZih0PD0wfHxlPD0wKXt2YXIgcj1cIltcIit0K1wieFwiK2UrXCJdXCI7dGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdGVkIHRleHR1cmUgc2l6ZSBcIityK1wiIGlzIGludmFsaWQuXCIpfWlmKHQ+bnx8ZT5uKXtyPVwiW1wiK3QrXCJ4XCIrZStcIl1cIjt0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0ZWQgdGV4dHVyZSBzaXplIFwiK3IrXCIgZ3JlYXRlciB0aGFuIFdlYkdMIG1heGltdW0gb24gdGhpcyBicm93c2VyIC8gR1BVIFwiKyhcIltcIituK1wieFwiK24rXCJdXCIpK1wiLlwiKX19ZnVuY3Rpb24gZWUodCxlKXtyZXR1cm4gaGUodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuY3JlYXRlRnJhbWVidWZmZXIoKX0sXCJVbmFibGUgdG8gY3JlYXRlIFdlYkdMRnJhbWVidWZmZXIuXCIpfWZ1bmN0aW9uIG5lKHQsZSxuLHIsbyxhLGkscyl7dmFyIHU9dC5nZXRBdHRyaWJMb2NhdGlvbihuLHIpO3JldHVybi0xIT09dSYmKEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmJpbmRCdWZmZXIodC5BUlJBWV9CVUZGRVIsbyl9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHUsYSx0LkZMT0FULCExLGkscyl9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh1KX0pLCEwKX1mdW5jdGlvbiByZSh0LGUsbixyKXtwZSh0LHIpLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmFjdGl2ZVRleHR1cmUodC5URVhUVVJFMCtyKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxuKX0pfWZ1bmN0aW9uIG9lKHQsZSxuLHIpe3JldHVybiBoZSh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5nZXRVbmlmb3JtTG9jYXRpb24obixyKX0sJ3VuaWZvcm0gXCInK3IrJ1wiIG5vdCBwcmVzZW50IGluIHByb2dyYW0uJyl9ZnVuY3Rpb24gYWUodCxlLG4pe3JldHVybiB0LmdldFVuaWZvcm1Mb2NhdGlvbihlLG4pfWZ1bmN0aW9uIGllKHQsZSxuLHIsbyxhKXtCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gcmUodCxlLHIsYSl9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC51bmlmb3JtMWkobyxhKX0pfWZ1bmN0aW9uIHNlKHQsZSxuLHIpe0J0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLHIpfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuZnJhbWVidWZmZXJUZXh0dXJlMkQodC5GUkFNRUJVRkZFUix0LkNPTE9SX0FUVEFDSE1FTlQwLHQuVEVYVFVSRV8yRCxuLDApfSl9ZnVuY3Rpb24gdWUodCxlLG4pe0J0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG4pfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuZnJhbWVidWZmZXJUZXh0dXJlMkQodC5GUkFNRUJVRkZFUix0LkNPTE9SX0FUVEFDSE1FTlQwLHQuVEVYVFVSRV8yRCxudWxsLDApfSl9ZnVuY3Rpb24gbGUodCl7dmFyIGU9dC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKHQuRlJBTUVCVUZGRVIpO2lmKGUhPT10LkZSQU1FQlVGRkVSX0NPTVBMRVRFKXRocm93IG5ldyBFcnJvcihcIkVycm9yIGJpbmRpbmcgZnJhbWVidWZmZXI6IFwiK2NlKHQsZSkpfWZ1bmN0aW9uIGNlKHQsZSl7c3dpdGNoKGUpe2Nhc2UgdC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQ6cmV0dXJuXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlRcIjtjYXNlIHQuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQ6cmV0dXJuXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVFwiO2Nhc2UgdC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlM6cmV0dXJuXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlNcIjtjYXNlIHQuRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQ6cmV0dXJuXCJGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRFwiO2RlZmF1bHQ6cmV0dXJuXCJ1bmtub3duIGVycm9yIFwiK2V9fWZ1bmN0aW9uIGhlKHQsZSxuLHIpe3ZhciBvPUJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiBuKCl9KTtpZihudWxsPT1vKXRocm93IG5ldyBFcnJvcihyKTtyZXR1cm4gb31mdW5jdGlvbiBwZSh0LGUpe3ZhciBuPXQuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMtMSxyPWUrdC5URVhUVVJFMDtpZihyPHQuVEVYVFVSRTB8fHI+bil0aHJvdyBuZXcgRXJyb3IoXCJ0ZXh0dXJlVW5pdCBtdXN0IGJlIGluIFwiKyhcIltnbC5URVhUVVJFMCwgZ2wuVEVYVFVSRVwiK24rXCJdXCIpK1wiLlwiKX1mdW5jdGlvbiBmZSh0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0yKSx5KHQuc2xpY2UoMCx0Lmxlbmd0aC1lKSl9ZnVuY3Rpb24gZGUodCl7aWYoMD09PXQubGVuZ3RoKXRocm93IEVycm9yKFwiQ2Fubm90IGdldCByb3dzIGFuZCBjb2x1bW5zIG9mIGFuIGVtcHR5IHNoYXBlIGFycmF5LlwiKTtyZXR1cm5bdC5sZW5ndGg+MT90W3QubGVuZ3RoLTJdOjEsdFt0Lmxlbmd0aC0xXV19ZnVuY3Rpb24gdmUodCxlKXt2YXIgbjt2b2lkIDA9PT1lJiYoZT0hMSk7dmFyIHI9YS5nZXROdW1iZXIoXCJXRUJHTF9NQVhfVEVYVFVSRV9TSVpFXCIpO2lmKGUmJihyKj0yLDE9PT0odD10Lm1hcChmdW5jdGlvbihlLG4pe3JldHVybiBuPj10Lmxlbmd0aC0yP3AodFtuXSk6dFtuXX0pKS5sZW5ndGgmJih0PVsyLHRbMF1dKSksMiE9PXQubGVuZ3RoKXt2YXIgbz1rKHQpO3Q9by5uZXdTaGFwZX12YXIgaT15KHQpO2lmKHQubGVuZ3RoPD0xJiZpPD1yKXJldHVyblsxLGldO2lmKDI9PT10Lmxlbmd0aCYmdFswXTw9ciYmdFsxXTw9cilyZXR1cm4gdDtpZigzPT09dC5sZW5ndGgmJnRbMF0qdFsxXTw9ciYmdFsyXTw9cilyZXR1cm5bdFswXSp0WzFdLHRbMl1dO2lmKDM9PT10Lmxlbmd0aCYmdFswXTw9ciYmdFsxXSp0WzJdPD1yKXJldHVyblt0WzBdLHRbMV0qdFsyXV07aWYoND09PXQubGVuZ3RoJiZ0WzBdKnRbMV0qdFsyXTw9ciYmdFszXTw9cilyZXR1cm5bdFswXSp0WzFdKnRbMl0sdFszXV07aWYoND09PXQubGVuZ3RoJiZ0WzBdPD1yJiZ0WzFdKnRbMl0qdFszXTw9cilyZXR1cm5bdFswXSx0WzFdKnRbMl0qdFszXV07aWYoZSl7dmFyIHM9ZmUodCksdT0yLGw9MjtyZXR1cm4gdC5sZW5ndGgmJih1PShuPWRlKHQpKVswXSxsPW5bMV0pLEMoaT1zKih1LzIpKihsLzIpKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIDIqdH0pfXJldHVybiBDKGkpfWZ1bmN0aW9uIG1lKHQpe3JldHVybiB0JTI9PTB9ZnVuY3Rpb24gZ2UodCxlKXtpZih4KHQ9dC5zbGljZSgtMiksZT1lLnNsaWNlKC0yKSkpcmV0dXJuITA7aWYoIXQubGVuZ3RofHwhZS5sZW5ndGgpcmV0dXJuITA7aWYoMD09PXRbMF18fDA9PT10WzFdfHwwPT09ZVswXXx8MD09PWVbMV0pcmV0dXJuITA7aWYodC5sZW5ndGghPT1lLmxlbmd0aCl7dmFyIG49dC5zbGljZSgtMSlbMF0scj1lLnNsaWNlKC0xKVswXTtpZihuPT09cilyZXR1cm4hMDtpZihtZShuKSYmbWUocikmJigxPT09dFswXXx8MT09PWVbMF0pKXJldHVybiEwfXJldHVybiB0WzFdPT09ZVsxXSYmbWUodFswXSkmJm1lKGVbMF0pfWZ1bmN0aW9uIHllKHQpe2lmKG51bGw9PXF0KXt2YXIgZT1GdCh0KTtxdD1lLmdldFBhcmFtZXRlcihlLk1BWF9URVhUVVJFX1NJWkUpfXJldHVybiBxdH1mdW5jdGlvbiB4ZSh0KXtpZihudWxsPT1IdCl7dmFyIGU9RnQodCk7SHQ9ZS5nZXRQYXJhbWV0ZXIoZS5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyl9cmV0dXJuIE1hdGgubWluKDE2LEh0KX1mdW5jdGlvbiB3ZSh0KXtpZigwPT09dClyZXR1cm4gMDt2YXIgZT1GdCh0KTtyZXR1cm4gYmUoZSxcIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDJcIikmJjI9PT10PzI6YmUoZSxcIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeVwiKT8xOjB9ZnVuY3Rpb24gYmUodCxlKXtyZXR1cm4gbnVsbCE9dC5nZXRFeHRlbnNpb24oZSl9ZnVuY3Rpb24gQ2UodCl7dHJ5e2lmKG51bGwhPUZ0KHQpKXJldHVybiEwfWNhdGNoKHQpe3JldHVybiExfXJldHVybiExfWZ1bmN0aW9uIEVlKHQpe2lmKDA9PT10KXJldHVybiExO3ZhciBlPUZ0KHQpO2lmKDE9PT10KXtpZighYmUoZSxcIk9FU190ZXh0dXJlX2Zsb2F0XCIpKXJldHVybiExfWVsc2UgaWYoIWJlKGUsXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpKXJldHVybiExO3JldHVybiBTZShlLHQpfWZ1bmN0aW9uIFJlKHQpe2lmKDA9PT10KXJldHVybiExO3ZhciBlPUZ0KHQpO2lmKDE9PT10KXtpZighYmUoZSxcIk9FU190ZXh0dXJlX2Zsb2F0XCIpKXJldHVybiExO2lmKCFiZShlLFwiV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0XCIpKXJldHVybiExfWVsc2UgaWYoIWJlKGUsXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpKXJldHVybiExO3JldHVybiBTZShlLHQpfWZ1bmN0aW9uIFNlKHQsZSl7dmFyIG49dC5jcmVhdGVGcmFtZWJ1ZmZlcigpLHI9dC5jcmVhdGVUZXh0dXJlKCk7dC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQscik7dmFyIG89Mj09PWU/dC5SR0JBMzJGOnQuUkdCQTt0LnRleEltYWdlMkQodC5URVhUVVJFXzJELDAsbywxLDEsMCx0LlJHQkEsdC5GTE9BVCxudWxsKSx0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG4pLHQuZnJhbWVidWZmZXJUZXh0dXJlMkQodC5GUkFNRUJVRkZFUix0LkNPTE9SX0FUVEFDSE1FTlQwLHQuVEVYVFVSRV8yRCxyLDApO3ZhciBhPXQuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyh0LkZSQU1FQlVGRkVSKT09PXQuRlJBTUVCVUZGRVJfQ09NUExFVEU7cmV0dXJuIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG51bGwpLHQuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsbnVsbCksdC5kZWxldGVUZXh0dXJlKHIpLHQuZGVsZXRlRnJhbWVidWZmZXIobiksYX1mdW5jdGlvbiBOZSh0KXtyZXR1cm4gMj09PXQmJm51bGwhPUZ0KHQpLmZlbmNlU3luY312YXIga2U9T2JqZWN0LmZyZWV6ZSh7Y2FsbEFuZENoZWNrOkJ0LGNhbkJlUmVwcmVzZW50ZWQ6V3QsZ2V0V2ViR0xFcnJvck1lc3NhZ2U6VXQsZ2V0RXh0ZW5zaW9uT3JUaHJvdzp6dCxjcmVhdGVWZXJ0ZXhTaGFkZXI6VnQsY3JlYXRlRnJhZ21lbnRTaGFkZXI6R3QsY3JlYXRlUHJvZ3JhbTpqdCxsaW5rUHJvZ3JhbTpLdCx2YWxpZGF0ZVByb2dyYW06WHQsY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyOll0LGNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyOlF0LGdldE51bUNoYW5uZWxzOkp0LGNyZWF0ZVRleHR1cmU6WnQsdmFsaWRhdGVUZXh0dXJlU2l6ZTp0ZSxjcmVhdGVGcmFtZWJ1ZmZlcjplZSxiaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlOm5lLGJpbmRUZXh0dXJlVW5pdDpyZSx1bmJpbmRUZXh0dXJlVW5pdDpmdW5jdGlvbih0LGUsbil7cGUodCxuKSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5hY3RpdmVUZXh0dXJlKHQuVEVYVFVSRTArbil9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbnVsbCl9KX0sZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3c6b2UsZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbjphZSxiaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyOmllLGJpbmRDYW52YXNUb0ZyYW1lYnVmZmVyOmZ1bmN0aW9uKHQsZSl7QnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsbnVsbCl9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC52aWV3cG9ydCgwLDAsdC5jYW52YXMud2lkdGgsdC5jYW52YXMuaGVpZ2h0KX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LnNjaXNzb3IoMCwwLHQuY2FudmFzLndpZHRoLHQuY2FudmFzLmhlaWdodCl9KX0sYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXI6c2UsdW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyOnVlLHZhbGlkYXRlRnJhbWVidWZmZXI6bGUsZ2V0RnJhbWVidWZmZXJFcnJvck1lc3NhZ2U6Y2UsZ2V0QmF0Y2hEaW06ZmUsZ2V0Um93c0NvbHM6ZGUsZ2V0VGV4dHVyZVNoYXBlRnJvbUxvZ2ljYWxTaGFwZTp2ZSxpc1Jlc2hhcGVGcmVlOmdlLGdldCBNQVhfVEVYVFVSRV9TSVpFKCl7cmV0dXJuIHF0fSxnZXQgTUFYX1RFWFRVUkVTX0lOX1NIQURFUigpe3JldHVybiBIdH0sZ2V0V2ViR0xNYXhUZXh0dXJlU2l6ZTp5ZSxnZXRNYXhUZXh0dXJlc0luU2hhZGVyOnhlLGdldFdlYkdMRGlzam9pbnRRdWVyeVRpbWVyVmVyc2lvbjp3ZSxpc1dlYkdMVmVyc2lvbkVuYWJsZWQ6Q2UsaXNSZW5kZXJUb0Zsb2F0VGV4dHVyZUVuYWJsZWQ6RWUsaXNEb3dubG9hZEZsb2F0VGV4dHVyZUVuYWJsZWQ6UmUsaXNXZWJHTEZlbmNlRW5hYmxlZDpOZX0pO2Z1bmN0aW9uIEllKCl7YS5zZXQoXCJQUk9EXCIsITApfWZ1bmN0aW9uIEFlKCl7YS5zZXQoXCJERUJVR1wiLCEwKX1mdW5jdGlvbiBUZSgpe2Euc2V0KFwiREVQUkVDQVRJT05fV0FSTklOR1NfRU5BQkxFRFwiLCExKSxjb25zb2xlLndhcm4oXCJUZW5zb3JGbG93LmpzIGRlcHJlY2F0aW9uIHdhcm5pbmdzIGhhdmUgYmVlbiBkaXNhYmxlZC5cIil9ZnVuY3Rpb24gRGUodCl7YS5nZXRCb29sKFwiREVQUkVDQVRJT05fV0FSTklOR1NfRU5BQkxFRFwiKSYmY29uc29sZS53YXJuKHQrXCIgWW91IGNhbiBkaXNhYmxlIGRlcHJlY2F0aW9uIHdhcm5pbmdzIHdpdGggdGYuZGlzYWJsZURlcHJlY2F0aW9uV2FybmluZ3MoKS5cIil9ZnVuY3Rpb24gT2UoKXtEdC5kaXNwb3NlVmFyaWFibGVzKCl9ZnVuY3Rpb24gX2UoKXtyZXR1cm4gRHQubWVtb3J5KCl9ZnVuY3Rpb24gTWUodCl7cmV0dXJuIER0LnByb2ZpbGUodCl9ZnVuY3Rpb24gRmUodCxlKXtyZXR1cm4gRHQudGlkeSh0LGUpfWZ1bmN0aW9uIEJlKHQpe050KHQpLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIHQuZGlzcG9zZSgpfSl9ZnVuY3Rpb24gUGUodCl7cmV0dXJuIER0LmtlZXAodCl9ZnVuY3Rpb24gTGUodCl7cmV0dXJuIER0LnRpbWUodCl9ZnVuY3Rpb24gV2UodCl7cmV0dXJuIER0LnNldEJhY2tlbmQodCl9ZnVuY3Rpb24gVWUoKXtyZXR1cm4gRHQucmVhZHkoKX1mdW5jdGlvbiB6ZSgpe3JldHVybiBEdC5iYWNrZW5kTmFtZX1mdW5jdGlvbiBWZSh0KXtEdC5yZW1vdmVCYWNrZW5kKHQpfWZ1bmN0aW9uIEdlKHQpe3JldHVybiBEdC5maW5kQmFja2VuZCh0KX1mdW5jdGlvbiBxZSh0KXtyZXR1cm4gRHQuZmluZEJhY2tlbmRGYWN0b3J5KHQpfWZ1bmN0aW9uIEhlKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MSksRHQucmVnaXN0ZXJCYWNrZW5kKHQsZSxuKX1mdW5jdGlvbiAkZSgpe3JldHVybiBEdC5iYWNrZW5kfWZ1bmN0aW9uIGplKCl7Zm9yKHZhciB0PVtdLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXRbZV09YXJndW1lbnRzW2VdO2EuZ2V0Qm9vbChcIklTX1RFU1RcIil8fGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLHQpfWZ1bmN0aW9uIEtlKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPSEwKTt2YXIgbz1bXTtpZihyKShvPW8uY29uY2F0KGUuc2xpY2UoMCkpKS5wdXNoKHRbMF0vbiksbz1vLmNvbmNhdCh0LnNsaWNlKDEpKTtlbHNle289by5jb25jYXQodFswXSk7Zm9yKHZhciBhPWUubGVuZ3RoLGk9MDtpPGE7KytpKW89by5jb25jYXQoW3RbaSsxXS9lW2ldLGVbaV1dKTtvPW8uY29uY2F0KHQuc2xpY2UoYSsxKSl9cmV0dXJuIG99ZnVuY3Rpb24gWGUodCxlLG4pe3ZvaWQgMD09PW4mJihuPSEwKTt2YXIgcj1bXTtpZihuKXtyLnB1c2goZSk7Zm9yKHZhciBvPWUrMTtvPHQ7KytvKW88PTIqZT8oci5wdXNoKG8pLHIucHVzaChvLShlKzEpKSk6ci5wdXNoKG8pfWVsc2V7dmFyIGE9W10saT1bXTtmb3Iobz0xO288dDsrK28pbz49MiplKzF8fG8lMj09MT9pLnB1c2gobyk6YS5wdXNoKG8pO3IucHVzaC5hcHBseShyLGEpLHIucHVzaCgwKSxyLnB1c2guYXBwbHkocixpKX1yZXR1cm4gcn1mdW5jdGlvbiBZZSh0LGUsbixyKXt2b2lkIDA9PT1yJiYocj0hMCk7dmFyIG89W107cj9vLnB1c2godFswXS9uKTpvLnB1c2godFswXSpuKTtmb3IodmFyIGE9MTthPHQubGVuZ3RoOysrYSlhPD1lLmxlbmd0aD9yP28ucHVzaChlW2EtMV0qdFthXSk6by5wdXNoKHRbYV0vZVthLTFdKTpvLnB1c2godFthXSk7cmV0dXJuIG99ZnVuY3Rpb24gUWUodCxlKXtmb3IodmFyIG49WzBdLHI9MDtyPGU7KytyKW4ucHVzaCh0W3JdWzBdKTtyZXR1cm4gbn1mdW5jdGlvbiBKZSh0LGUsbil7Zm9yKHZhciByPXQuc2xpY2UoMCwxKSxvPTA7bzxuOysrbylyLnB1c2godFtvKzFdLWVbb11bMF0tZVtvXVsxXSk7cmV0dXJuIHJ9ZnVuY3Rpb24gWmUodCxlKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoOysrbilpZih0W3QubGVuZ3RoLW4tMV0hPT1lLTEtbilyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiB0bih0LGUpe2Zvcih2YXIgbj1bXSxyPXQubGVuZ3RoLG89MDtvPHI7bysrKS0xPT09ZS5pbmRleE9mKG8pJiZuLnB1c2godFtvXSk7cmV0dXJuW24sZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHRbZV19KV19ZnVuY3Rpb24gZW4odCxlKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj10Lmxlbmd0aCtlLmxlbmd0aCxvPVtdLGE9MCxpPTAscz0wO3M8cjtzKyspLTE9PT1uLmluZGV4T2Yocyk/by5wdXNoKHRbYSsrXSk6by5wdXNoKGVbaSsrXSk7cmV0dXJuIG99KHQsZS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIDF9KSxlKX1mdW5jdGlvbiBubih0LGUsbil7ZChaZShlLG4pLGZ1bmN0aW9uKCl7cmV0dXJuIHQrXCIgc3VwcG9ydHMgb25seSBpbm5lci1tb3N0IGF4ZXMgZm9yIG5vdy4gR290IGF4ZXMgXCIrZStcIiBhbmQgcmFuay1cIituK1wiIGlucHV0LlwifSl9ZnVuY3Rpb24gcm4odCxlKXtpZihaZSh0LGUpKXJldHVybiBudWxsO2Zvcih2YXIgbj1bXSxyPTA7cjxlOysrciktMT09PXQuaW5kZXhPZihyKSYmbi5wdXNoKHIpO3JldHVybiB0LmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIG4ucHVzaCh0KX0pLG59ZnVuY3Rpb24gb24odCl7cmV0dXJuIHQubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuW2UsdF19KS5zb3J0KGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbMV0tZVsxXX0pLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdFswXX0pfWZ1bmN0aW9uIGFuKHQsZSl7Zm9yKHZhciBuPVtdLHI9ZS10O3I8ZTsrK3Ipbi5wdXNoKHIpO3JldHVybiBufWZ1bmN0aW9uIHNuKHQsZSl7Zm9yKHZhciBuPXRbMF0uc2xpY2UoKSxyPTE7cjx0Lmxlbmd0aDtyKyspbltlXSs9dFtyXVtlXTtyZXR1cm4gbn1mdW5jdGlvbiB1bih0LGUpe2lmKHQucmFuazwxKXRocm93IG5ldyBFcnJvcihcInRmLmdhdGhlck5EKCkgZXhwZWN0cyB0aGUgaW5wdXQgdG8gYmUgcmFuayAxIG9yIGhpZ2hlciwgYnV0IHRoZSByYW5rIHdhcyBcIit0LnJhbmsrXCIuXCIpO2lmKGUucmFuazwxKXRocm93IG5ldyBFcnJvcihcInRmLmdhdGhlck5EKCkgZXhwZWN0cyB0aGUgaW5kaWNlcyB0byBiZSByYW5rIDEgb3IgaGlnaGVyLCBidXQgdGhlIHJhbmsgd2FzIFwiK2UucmFuaytcIi5cIik7aWYoXCJpbnQzMlwiIT09ZS5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJ0Zi5nYXRoZXJORCgpIGV4cGVjdHMgdGhlIGluZGljZXMgdG8gYmUgaW50MzIgdHlwZSwgYnV0IHRoZSBkdHlwZSB3YXMgXCIrZS5kdHlwZStcIi5cIik7aWYoZS5zaGFwZVtlLnJhbmstMV0+dC5yYW5rKXRocm93IG5ldyBFcnJvcihcImluZGV4IGlubmVybW9zdCBkaW1lbnNpb24gbGVuZ3RoIG11c3QgYmUgPD0gdGVuc29yIHJhbms7IHNhdzogXCIrZS5zaGFwZVtlLnJhbmstMV0rXCIgdnMuIFwiK3QucmFuayk7aWYoMD09PXQuc2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0ZWQgbW9yZSB0aGFuIDAgZW50cmllcywgYnV0IGlucHV0IGlzIGVtcHR5LiBJbnB1dCBzaGFwZTogXCIrdC5zaGFwZStcIi5cIik7Zm9yKHZhciBuPWUuc2hhcGUscj1uW24ubGVuZ3RoLTFdLG89MSxhPTA7YTxuLmxlbmd0aC0xOysrYSlvKj1uW2FdO3ZhciBpPXQuc2hhcGUscz1uLnNsaWNlKCk7cy5wb3AoKTt2YXIgdT0xO2ZvcihhPXI7YTx0LnJhbms7KythKXUqPWlbYV0scy5wdXNoKGlbYV0pO3ZhciBsPVYodC5zaGFwZSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0L3V9KS5jb25jYXQoWzFdKS5zbGljZSgwLHIpO3JldHVybltzLG8sdSxsXX1hLnJlZ2lzdGVyRmxhZyhcIkhBU19XRUJHTFwiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKT4wfSksYS5yZWdpc3RlckZsYWcoXCJXRUJHTF9WRVJTSU9OXCIsZnVuY3Rpb24oKXtyZXR1cm4gQ2UoMik/MjpDZSgxKT8xOjB9KSxhLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0JVRkZFUl9TVVBQT1JURURcIixmdW5jdGlvbigpe3JldHVybiAyPT09YS5nZXQoXCJXRUJHTF9WRVJTSU9OXCIpfSksYS5yZWdpc3RlckZsYWcoXCJXRUJHTF9DUFVfRk9SV0FSRFwiLGZ1bmN0aW9uKCl7cmV0dXJuITF9KSxhLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tcIixmdW5jdGlvbigpe3JldHVybiBhLmdldEJvb2woXCJIQVNfV0VCR0xcIil9KSxhLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfTk9STUFMSVpBVElPTlwiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSxhLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfQ0xJUFwiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSxhLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfREVQVEhXSVNFQ09OVlwiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSxhLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIixmdW5jdGlvbigpe3JldHVybiBhLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpfSksYS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX0FSUkFZX09QRVJBVElPTlNcIixmdW5jdGlvbigpe3JldHVybiBhLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpfSksYS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX0lNQUdFX09QRVJBVElPTlNcIixmdW5jdGlvbigpe3JldHVybiBhLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpfSksYS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX1JFRFVDRVwiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSxhLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0xBWklMWV9VTlBBQ0tcIixmdW5jdGlvbigpe3JldHVybiBhLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpfSksYS5yZWdpc3RlckZsYWcoXCJXRUJHTF9DT05WX0lNMkNPTFwiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSxhLnJlZ2lzdGVyRmxhZyhcIldFQkdMX01BWF9URVhUVVJFX1NJWkVcIixmdW5jdGlvbigpe3JldHVybiB5ZShhLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpfSksYS5yZWdpc3RlckZsYWcoXCJXRUJHTF9NQVhfVEVYVFVSRVNfSU5fU0hBREVSXCIsZnVuY3Rpb24oKXtyZXR1cm4geGUoYS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKX0pLGEucmVnaXN0ZXJGbGFnKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIixmdW5jdGlvbigpe3ZhciB0PWEuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKTtyZXR1cm4gMD09PXQ/MDp3ZSh0KX0pLGEucmVnaXN0ZXJGbGFnKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFXCIsZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT4wJiYodD1uYXZpZ2F0b3IudXNlckFnZW50fHxuYXZpZ2F0b3IudmVuZG9yfHx3aW5kb3cub3BlcmEsISgvKGFuZHJvaWR8YmJcXGQrfG1lZWdvKS4rbW9iaWxlfGF2YW50Z298YmFkYVxcL3xibGFja2JlcnJ5fGJsYXplcnxjb21wYWx8ZWxhaW5lfGZlbm5lY3xoaXB0b3B8aWVtb2JpbGV8aXAoaG9uZXxvZCl8aXJpc3xraW5kbGV8bGdlIHxtYWVtb3xtaWRwfG1tcHxtb2JpbGUuK2ZpcmVmb3h8bmV0ZnJvbnR8b3BlcmEgbShvYnxpbilpfHBhbG0oIG9zKT98cGhvbmV8cChpeGl8cmUpXFwvfHBsdWNrZXJ8cG9ja2V0fHBzcHxzZXJpZXMoNHw2KTB8c3ltYmlhbnx0cmVvfHVwXFwuKGJyb3dzZXJ8bGluayl8dm9kYWZvbmV8d2FwfHdpbmRvd3MgY2V8eGRhfHhpaW5vL2kudGVzdCh0KXx8LzEyMDd8NjMxMHw2NTkwfDNnc298NHRocHw1MFsxLTZdaXw3NzBzfDgwMnN8YSB3YXxhYmFjfGFjKGVyfG9vfHNcXC0pfGFpKGtvfHJuKXxhbChhdnxjYXxjbyl8YW1vaXxhbihleHxueXx5dyl8YXB0dXxhcihjaHxnbyl8YXModGV8dXMpfGF0dHd8YXUoZGl8XFwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3XFwtKG58dSl8YzU1XFwvfGNhcGl8Y2N3YXxjZG1cXC18Y2VsbHxjaHRtfGNsZGN8Y21kXFwtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjXFwtc3xkZXZpfGRpY2F8ZG1vYnxkbyhjfHApb3xkcygxMnxcXC1kKXxlbCg0OXxhaSl8ZW0obDJ8dWwpfGVyKGljfGswKXxlc2w4fGV6KFs0LTddMHxvc3x3YXx6ZSl8ZmV0Y3xmbHkoXFwtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmXFwtNXxnXFwtbW98Z28oXFwud3xvZCl8Z3IoYWR8dW4pfGhhaWV8aGNpdHxoZFxcLShtfHB8dCl8aGVpXFwtfGhpKHB0fHRhKXxocCggaXxpcCl8aHNcXC1jfGh0KGMoXFwtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aVxcLSgyMHxnb3xtYSl8aTIzMHxpYWMoIHxcXC18XFwvKXxpYnJvfGlkZWF8aWcwMXxpa29tfGltMWt8aW5ub3xpcGFxfGlyaXN8amEodHx2KWF8amJyb3xqZW11fGppZ3N8a2RkaXxrZWppfGtndCggfFxcLyl8a2xvbnxrcHQgfGt3Y1xcLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHxcXC1bYS13XSl8bGlid3xseW54fG0xXFwtd3xtM2dhfG01MFxcL3xtYSh0ZXx1aXx4byl8bWMoMDF8MjF8Y2EpfG1cXC1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dChcXC18IHxvfHYpfHp6KXxtdCg1MHxwMXx2ICl8bXdicHxteXdhfG4xMFswLTJdfG4yMFsyLTNdfG4zMCgwfDIpfG41MCgwfDJ8NSl8bjcoMCgwfDEpfDEwKXxuZSgoY3xtKVxcLXxvbnx0Znx3Znx3Z3x3dCl8bm9rKDZ8aSl8bnpwaHxvMmltfG9wKHRpfHd2KXxvcmFufG93ZzF8cDgwMHxwYW4oYXxkfHQpfHBkeGd8cGcoMTN8XFwtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuXFwtMnxwbyhja3xydHxzZSl8cHJveHxwc2lvfHB0XFwtZ3xxYVxcLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8XFwtWzItN118aVxcLSl8cXRla3xyMzgwfHI2MDB8cmFrc3xyaW05fHJvKHZlfHpvKXxzNTVcXC98c2EoZ2V8bWF8bW18bXN8bnl8dmEpfHNjKDAxfGhcXC18b298cFxcLSl8c2RrXFwvfHNlKGMoXFwtfDB8MSl8NDd8bWN8bmR8cmkpfHNnaFxcLXxzaGFyfHNpZShcXC18bSl8c2tcXC0wfHNsKDQ1fGlkKXxzbShhbHxhcnxiM3xpdHx0NSl8c28oZnR8bnkpfHNwKDAxfGhcXC18dlxcLXx2ICl8c3koMDF8bWIpfHQyKDE4fDUwKXx0NigwMHwxMHwxOCl8dGEoZ3R8bGspfHRjbFxcLXx0ZGdcXC18dGVsKGl8bSl8dGltXFwtfHRcXC1tb3x0byhwbHxzaCl8dHMoNzB8bVxcLXxtM3xtNSl8dHhcXC05fHVwKFxcLmJ8ZzF8c2kpfHV0c3R8djQwMHx2NzUwfHZlcml8dmkocmd8dGUpfHZrKDQwfDVbMC0zXXxcXC12KXx2bTQwfHZvZGF8dnVsY3x2eCg1Mnw1M3w2MHw2MXw3MHw4MHw4MXw4M3w4NXw5OCl8dzNjKFxcLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhc1xcLXx5b3VyfHpldG98enRlXFwtL2kudGVzdCh0LnN1YnN0cigwLDQpKSkpO3ZhciB0fSksYS5yZWdpc3RlckZsYWcoXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEXCIsZnVuY3Rpb24oKXtyZXR1cm4gRWUoYS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKX0pLGEucmVnaXN0ZXJGbGFnKFwiV0VCR0xfRE9XTkxPQURfRkxPQVRfRU5BQkxFRFwiLGZ1bmN0aW9uKCl7cmV0dXJuIFJlKGEuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSl9KSxhLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0ZFTkNFX0FQSV9FTkFCTEVEXCIsZnVuY3Rpb24oKXtyZXR1cm4gTmUoYS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKX0pLGEucmVnaXN0ZXJGbGFnKFwiV0VCR0xfU0laRV9VUExPQURfVU5JRk9STVwiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZ2V0Qm9vbChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIik/NDowfSkscHQ9RGU7dmFyIGxuPTMwO2Z1bmN0aW9uIGNuKHQpe3JldHVybiB0PD1sbj90OnoodCxNYXRoLmZsb29yKE1hdGguc3FydCh0KSkpfWZ1bmN0aW9uIGhuKHQsZSxuKXtpZihlLnJhbms8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0Zi5zY2F0dGVyTkQoKSBleHBlY3RzIHRoZSBpbmRpY2VzIHRvIGJlIHJhbmsgMSBvciBoaWdoZXIsIGJ1dCB0aGUgcmFuayB3YXMgXCIrZS5yYW5rK1wiLlwiKTtpZih0LnJhbms8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0Zi5zY2F0dGVyTkQoKSBleHBlY3RzIHRoZSB1cGRhdGVzIHRvIGJlIHJhbmsgMSBvciBoaWdoZXIsIGJ1dCB0aGUgcmFuayB3YXMgXCIrdC5yYW5rK1wiLlwiKTtpZihcImludDMyXCIhPT1lLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIlRoZSBkdHlwZSBvZiAnaW5kaWNlcycgc2hvdWxkIGJlIGludDMyLCBidXQgZ290IGR0eXBlOiBcIitlLmR0eXBlKTtpZihuLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcIk91dHB1dCByYW5rIG11c3QgYmUgZ3JlYXRlciBvciBlcXVhbCB0byAxLCBidXQgZ290IHNoYXBlOiBcIituKTtpZigwPT09bi5sZW5ndGgpe2lmKDA9PT1lLnNpemUpdGhyb3cgbmV3IEVycm9yKFwiSW5kaWNlcyBzcGVjaWZpZWQgZm9yIGVtcHR5IG91dHB1dC4gaW5kaWNlcyBzaGFwZTogXCIrZS5zaGFwZSk7aWYoMD09PXQuc2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJVcGRhdGVzIHNwZWNpZmllZCBmb3IgZW1wdHkgb3V0cHV0LiB1cGRhdGVzIHNoYXBlOiBcIit0LnNoYXBlKX0hZnVuY3Rpb24odCxlLG4pe3ZhciByPWUucmFuaz4xP2Uuc2hhcGVbZS5yYW5rLTFdOjEsbz1lLnJhbms+MT9lLnJhbmstMToxLGE9XCJNdXN0IGhhdmUgdXBkYXRlcy5zaGFwZSA9IGluZGljZXMuc2hhcGVbOmJhdGNoRGltXSArIHNoYXBlW3NsaWNlRGltOl0sIGdvdCB1cGRhdGVzLnNoYXBlOiBcIituLnNoYXBlK1wiLCBpbmRpY2VzLnNoYXBlOiBcIitlLnNoYXBlK1wiLCBzaGFwZTogXCIrdCtcIiwgc2xpY2VEaW06IFwiK3IrXCIsIGFuZCBiYXRjaERpbTogXCIrbytcIi5cIjtpZihuLnJhbms8byl0aHJvdyBuZXcgRXJyb3IoYStcIiB1cGRhdGUucmFuayA8IFwiK28rXCIuIFwiKTtpZih0Lmxlbmd0aDxyKyhuLnJhbmstbykpdGhyb3cgbmV3IEVycm9yKGErXCIgT3V0cHV0IHNoYXBlIGxlbmd0aCA8IFwiKyhyKyhuLnJhbmstbykpKTtpZihuLnJhbmshPT1vK3QubGVuZ3RoLXIpdGhyb3cgbmV3IEVycm9yKGErXCIgdXBkYXRlLnJhbmsgIT0gXCIrKG8rdC5sZW5ndGgtcikpO2Zvcih2YXIgaT0wO2k8bzsrK2kpaWYobi5zaGFwZVtpXSE9PWUuc2hhcGVbaV0pdGhyb3cgbmV3IEVycm9yKGErXCIgdXBkYXRlcy5zaGFwZVtcIitpK1wiXSAoXCIrbi5zaGFwZVtpXStcIikgIT0gaW5kaWNlcy5zaGFwZVtcIitpK1wiXSAoXCIrZS5zaGFwZVtpXStcIikuXCIpO2ZvcihpPTA7aTxuLnJhbmstbzsrK2kpaWYobi5zaGFwZVtpK29dIT09dFtpK3JdKXRocm93IG5ldyBFcnJvcihhK1wiIHVwZGF0ZXMuc2hhcGVbXCIrKGkrbykrXCJdIChcIituLnNoYXBlW2krb10rXCIpICE9IHNoYXBlW1wiKyhpK28pK1wiXSAoXCIrdFtpK29dK1wiKVwiKX0obixlLHQpfWZ1bmN0aW9uIHBuKHQsZSxuKXtmb3IodmFyIHI9ZS5yYW5rPjE/ZS5zaGFwZVtlLnJhbmstMV06MSxvPW4ubGVuZ3RoLGE9MSxpPXI7aTxvOysraSlhKj1uW2ldO3ZhciBzPXI8MT8xOnI7cmV0dXJue3NsaWNlUmFuazpyLG51bVVwZGF0ZXM6ZS5zaXplL3Msc2xpY2VTaXplOmEsc3RyaWRlczpWKG4uc2xpY2UoMCxyKSkuY29uY2F0KFsxXSksb3V0cHV0U2l6ZTp5KG4pfX1mdW5jdGlvbiBmbih0LGUsbixyLG8sYSxpLHMsdSl7aWYodm9pZCAwPT09byYmKG89MCksdm9pZCAwPT09YSYmKGE9MCksdm9pZCAwPT09aSYmKGk9MCksdm9pZCAwPT09cyYmKHM9MCksdm9pZCAwPT09dSYmKHU9MCksMCE9PWkpdGhyb3cgbmV3IEVycm9yKFwiZWxsaXBzaXMgbWFzayBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtpZigwIT09cyl0aHJvdyBuZXcgRXJyb3IoXCJuZXcgYXhpcyBtYXNrIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO2Zvcih2YXIgbD1bXSxjPVtdLGg9W10scD0wO3A8dC5sZW5ndGg7cCsrKWxbcF09ZG4obyxlLHIsdCxwKSxjW3BdPXZuKGEsbixyLHQscCksdSYxPDxwJiYoY1twXT1sW3BdKzEsaC5wdXNoKHApKTt2YXIgZj1uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwoMCk7cmV0dXJuIGY9Zi5tYXAoZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MCxvPXJbZV18fDEsYT1sW2VdOyEobz4wP2E+PWNbZV06YTw9Y1tlXSk7YSs9byluKz0xO3JldHVybiBufSksW2wsZixoXX1mdW5jdGlvbiBkbih0LGUsbixyLG8pe3ZhciBhPWVbb10saT1uW29dfHwxOyh0JjE8PG98fG51bGw9PWEpJiYoYT1pPjA/TnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI6TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO3ZhciBzPXJbb107cmV0dXJuIGE8MCYmKGErPXMpLGE9aCgwLGEscy0xKX1mdW5jdGlvbiB2bih0LGUsbixyLG8pe3ZhciBhPWVbb10saT1uW29dfHwxOyh0JjE8PG98fG51bGw9PWEpJiYoYT1pPjA/TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI6TnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpO3ZhciBzPXJbb107cmV0dXJuIGE8MCYmKGErPXMpLGE9aT4wP2goMCxhLHMpOmgoLTEsYSxzLTEpfWZ1bmN0aW9uIG1uKHQsZSxuKXtmb3IodmFyIHI9bi5sZW5ndGgsbz0wO288bi5sZW5ndGg7bysrKWlmKG5bb10+MSl7cj1vO2JyZWFrfWZvcihvPXIrMTtvPG4ubGVuZ3RoO28rKylpZihlW29dPjB8fG5bb10hPT10W29dKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIGduKHQsZSl7Zm9yKHZhciBuPXQubGVuZ3RoPjA/dFt0Lmxlbmd0aC0xXToxLHI9MDtyPHQubGVuZ3RoLTE7cisrKW4rPXRbcl0qZVtyXTtyZXR1cm4gbn1mdW5jdGlvbiB5bih0KXt2YXIgZT10O2lmKF8odCkpcmV0dXJuW3QubGVuZ3RoXTtpZighQXJyYXkuaXNBcnJheSh0KSlyZXR1cm5bXTtmb3IodmFyIG49W107QXJyYXkuaXNBcnJheShlKXx8XyhlKTspbi5wdXNoKGUubGVuZ3RoKSxlPWVbMF07cmV0dXJuIEFycmF5LmlzQXJyYXkodCkmJmEuZ2V0Qm9vbChcIlRFTlNPUkxJS0VfQ0hFQ0tfU0hBUEVfQ09OU0lTVEVOQ1lcIikmJmZ1bmN0aW9uIHQoZSxuLHIpe3I9cnx8W107aWYoIUFycmF5LmlzQXJyYXkoZSkmJiFfKGUpKXJldHVybiB2b2lkIGQoMD09PW4ubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJFbGVtZW50IGFycltcIityLmpvaW4oXCJdW1wiKStcIl0gaXMgYSBwcmltaXRpdmUsIGJ1dCBzaG91bGQgYmUgYW4gYXJyYXkvVHlwZWRBcnJheSBvZiBcIituWzBdK1wiIGVsZW1lbnRzXCJ9KTtkKG4ubGVuZ3RoPjAsZnVuY3Rpb24oKXtyZXR1cm5cIkVsZW1lbnQgYXJyW1wiK3Iuam9pbihcIl1bXCIpK1wiXSBzaG91bGQgYmUgYSBwcmltaXRpdmUsIGJ1dCBpcyBhbiBhcnJheSBvZiBcIitlLmxlbmd0aCtcIiBlbGVtZW50c1wifSk7ZChlLmxlbmd0aD09PW5bMF0sZnVuY3Rpb24oKXtyZXR1cm5cIkVsZW1lbnQgYXJyW1wiK3Iuam9pbihcIl1bXCIpK1wiXSBzaG91bGQgaGF2ZSBcIituWzBdK1wiIGVsZW1lbnRzLCBidXQgaGFzIFwiK2UubGVuZ3RoK1wiIGVsZW1lbnRzXCJ9KTt2YXIgbz1uLnNsaWNlKDEpO2Zvcih2YXIgYT0wO2E8ZS5sZW5ndGg7KythKXQoZVthXSxvLHIuY29uY2F0KGEpKX0odCxuLFtdKSxufWZ1bmN0aW9uIHhuKHQsZSxuLHIpe2lmKG51bGwhPXQmJihcIm51bWVyaWNcIiE9PXQmJnQhPT1lfHxcIm51bWVyaWNcIj09PXQmJlwic3RyaW5nXCI9PT1lKSl0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCAnXCIrbitcIicgcGFzc2VkIHRvICdcIityK1wiJyBtdXN0IGJlIFwiK3QrXCIgdGVuc29yLCBidXQgZ290IFwiK2UrXCIgdGVuc29yXCIpfWZ1bmN0aW9uIHduKHQsZSxuLHIpe2lmKHZvaWQgMD09PXImJihyPVwibnVtZXJpY1wiKSx0IGluc3RhbmNlb2YgZnQpcmV0dXJuIHhuKHIsdC5kdHlwZSxlLG4pLHQ7dmFyIG89Vyh0KTtpZihcInN0cmluZ1wiIT09byYmW1wiYm9vbFwiLFwiaW50MzJcIixcImZsb2F0MzJcIl0uaW5kZXhPZihyKT49MCYmKG89cikseG4ocixvLGUsbiksbnVsbD09dHx8IV8odCkmJiFBcnJheS5pc0FycmF5KHQpJiZcIm51bWJlclwiIT10eXBlb2YgdCYmXCJib29sZWFuXCIhPXR5cGVvZiB0JiZcInN0cmluZ1wiIT10eXBlb2YgdCl7dmFyIGk9bnVsbD09dD9cIm51bGxcIjp0LmNvbnN0cnVjdG9yLm5hbWU7dGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgJ1wiK2UrXCInIHBhc3NlZCB0byAnXCIrbitcIicgbXVzdCBiZSBhIFRlbnNvciBvciBUZW5zb3JMaWtlLCBidXQgZ290ICdcIitpK1wiJ1wiKX12YXIgcz15bih0KTtfKHQpfHxBcnJheS5pc0FycmF5KHQpfHwodD1bdF0pO3ZhciB1PVwic3RyaW5nXCIhPT1vP0codCxvLGEuZ2V0Qm9vbChcIkRFQlVHXCIpKTpnKHQpO3JldHVybiBmdC5tYWtlKHMse3ZhbHVlczp1fSxvKX1mdW5jdGlvbiBibih0LGUsbixyKXtpZih2b2lkIDA9PT1yJiYocj1cIm51bWVyaWNcIiksIUFycmF5LmlzQXJyYXkodCkpdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgXCIrZStcIiBwYXNzZWQgdG8gXCIrbitcIiBtdXN0IGJlIGEgYFRlbnNvcltdYCBvciBgVGVuc29yTGlrZVtdYFwiKTtyZXR1cm4gdC5tYXAoZnVuY3Rpb24odCxyKXtyZXR1cm4gd24odCxlK1wiW1wiK3IrXCJdXCIsbil9LHIpfWZ1bmN0aW9uIENuKHQpe3JldHVybiBkKFUodCksZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmIHBhc3NlZCBpbiBncmFkKGYpIG11c3QgYmUgYSBmdW5jdGlvblwifSksZnVuY3Rpb24oZSxuKXt2YXIgcj13bihlLFwieFwiLFwidGYuZ3JhZFwiLG51bGwpLG89bnVsbCE9bj93bihuLFwiZHlcIixcInRmLmdyYWRcIik6bnVsbDtyZXR1cm4gRHQudGlkeShmdW5jdGlvbigpe3ZhciBlPUR0LmdyYWRpZW50cyhmdW5jdGlvbigpe3JldHVybiB0KHIpfSxbcl0sbyksbj1lLnZhbHVlLGE9ZS5ncmFkcztyZXR1cm4gbnVsbCE9byYmdihuLnNoYXBlLG8uc2hhcGUsXCJUaGUgc2hhcGUgb2YgZHkgcGFzc2VkIGluIGdyYWQoZikoeCwgZHkpIG11c3QgbWF0Y2ggdGhlIHNoYXBlIHJldHVybmVkIGJ5IGYoeClcIiksSW4oYSksYVswXX0pfX1mdW5jdGlvbiBFbih0KXtyZXR1cm4gZChVKHQpLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZiBwYXNzZWQgaW4gZ3JhZHMoZikgbXVzdCBiZSBhIGZ1bmN0aW9uXCJ9KSxmdW5jdGlvbihlLG4pe2QoQXJyYXkuaXNBcnJheShlKSxmdW5jdGlvbigpe3JldHVyblwiVGhlIGFyZ3MgcGFzc2VkIGluIGdyYWRzKGYpKGFyZ3MpIG11c3QgYmUgYW4gYXJyYXkgb2YgYFRlbnNvcmBzIG9yIGBUZW5zb3JMaWtlYHNcIn0pO3ZhciByPWJuKGUsXCJhcmdzXCIsXCJ0Zi5ncmFkc1wiLG51bGwpLG89bnVsbCE9bj93bihuLFwiZHlcIixcInRmLmdyYWRzXCIpOm51bGw7cmV0dXJuIER0LnRpZHkoZnVuY3Rpb24oKXt2YXIgZT1EdC5ncmFkaWVudHMoZnVuY3Rpb24oKXtyZXR1cm4gdC5hcHBseSh2b2lkIDAscil9LHIsbyksbj1lLnZhbHVlLGE9ZS5ncmFkcztyZXR1cm4gbnVsbCE9byYmdihuLnNoYXBlLG8uc2hhcGUsXCJUaGUgc2hhcGUgb2YgZHkgcGFzc2VkIGluIGdyYWRzKGYpKFt4MSwuLi5dLCBkeSkgbXVzdCBtYXRjaCB0aGUgc2hhcGUgcmV0dXJuZWQgYnkgZihbeDEsLi4uXSlcIiksSW4oYSksYX0pfX1mdW5jdGlvbiBSbih0KXtyZXR1cm4gZChVKHQpLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZiBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkKGYpIG11c3QgYmUgYSBmdW5jdGlvblwifSksZnVuY3Rpb24oZSxuKXtkKGUgaW5zdGFuY2VvZiBmdCxmdW5jdGlvbigpe3JldHVyblwiVGhlIHggcGFzc2VkIGluIHZhbHVlQW5kR3JhZChmKSh4KSBtdXN0IGJlIGEgdGVuc29yXCJ9KSxkKG51bGw9PW58fG4gaW5zdGFuY2VvZiBmdCxmdW5jdGlvbigpe3JldHVyblwiVGhlIGR5IHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWQoZikoeCwgZHkpIG11c3QgYmUgYSB0ZW5zb3JcIn0pO3ZhciByPUR0LmdyYWRpZW50cyhmdW5jdGlvbigpe3JldHVybiB0KGUpfSxbZV0sbiksbz1yLmdyYWRzLGE9ci52YWx1ZTtyZXR1cm4gSW4obykse2dyYWQ6b1swXSx2YWx1ZTphfX19ZnVuY3Rpb24gU24odCl7cmV0dXJuIGQoVSh0KSxmdW5jdGlvbigpe3JldHVyblwiVGhlIGYgcGFzc2VkIGluIHZhbHVlQW5kR3JhZHMoZikgbXVzdCBiZSBhIGZ1bmN0aW9uXCJ9KSxmdW5jdGlvbihlLG4pe2QoQXJyYXkuaXNBcnJheShlKSYmZS5ldmVyeShmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIGZ0fSksZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBhcmdzIHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWRzKGYpKGFyZ3MpIG11c3QgYmUgYXJyYXkgb2YgdGVuc29yc1wifSksZChudWxsPT1ufHxuIGluc3RhbmNlb2YgZnQsZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBkeSBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkcyhmKShhcmdzLCBkeSkgbXVzdCBiZSBhIHRlbnNvclwifSk7dmFyIHI9RHQuZ3JhZGllbnRzKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkodm9pZCAwLGUpfSxlLG4pO3JldHVybiBudWxsIT1uJiZ2KHIudmFsdWUuc2hhcGUsbi5zaGFwZSxcIlRoZSBzaGFwZSBvZiBkeSBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkcyhmKShbeDEsLi4uXSwgZHkpIG11c3QgbWF0Y2ggdGhlIHNoYXBlIHJldHVybmVkIGJ5IGYoW3gxLC4uLl0pXCIpLEluKHIuZ3JhZHMpLHJ9fWZ1bmN0aW9uIE5uKHQsZSl7aWYoZChVKHQpLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZiBwYXNzZWQgaW4gdmFyaWFibGVHcmFkcyhmKSBtdXN0IGJlIGEgZnVuY3Rpb25cIn0pLGQobnVsbD09ZXx8QXJyYXkuaXNBcnJheShlKSYmZS5ldmVyeShmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIGR0fSksZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSB2YXJMaXN0IHBhc3NlZCBpbiB2YXJpYWJsZUdyYWRzKGYsIHZhckxpc3QpIG11c3QgYmUgYW4gYXJyYXkgb2YgdmFyaWFibGVzXCJ9KSxudWxsPT1lKWZvcih2YXIgbiBpbiBlPVtdLER0LnJlZ2lzdGVyZWRWYXJpYWJsZXMpZS5wdXNoKER0LnJlZ2lzdGVyZWRWYXJpYWJsZXNbbl0pO3ZhciByPWUubGVuZ3RoO2QoKGU9ZS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHQudHJhaW5hYmxlfSkpLmxlbmd0aD4wLGZ1bmN0aW9uKCl7cmV0dXJuXCJ2YXJpYWJsZUdyYWRzKCkgZXhwZWN0cyBhdCBsZWFzdCBvbmUgb2YgdGhlIGlucHV0IHZhcmlhYmxlcyB0byBiZSB0cmFpbmFibGUsIGJ1dCBub25lIG9mIHRoZSBcIityK1wiIHZhcmlhYmxlcyBpcyB0cmFpbmFibGUuXCJ9KTt2YXIgbz1EdC5ncmFkaWVudHModCxlLG51bGwsITApLGE9by52YWx1ZSxpPW8uZ3JhZHM7ZChpLnNvbWUoZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPXR9KSxmdW5jdGlvbigpe3JldHVyblwiQ2Fubm90IGZpbmQgYSBjb25uZWN0aW9uIGJldHdlZW4gYW55IHZhcmlhYmxlIGFuZCB0aGUgcmVzdWx0IG9mIHRoZSBsb3NzIGZ1bmN0aW9uIHk9Zih4KS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgb3BlcmF0aW9ucyB0aGF0IHVzZSB2YXJpYWJsZXMgYXJlIGluc2lkZSB0aGUgZnVuY3Rpb24gZiBwYXNzZWQgdG8gbWluaW1pemUoKS5cIn0pLGQoMD09PWEucmFuayxmdW5jdGlvbigpe3JldHVyblwiVGhlIGYgcGFzc2VkIGluIHZhcmlhYmxlR3JhZHMoZikgbXVzdCByZXR1cm4gYSBzY2FsYXIsIGJ1dCBpdCByZXR1cm5lZCBhIHJhbmstXCIrYS5yYW5rK1wiIHRlbnNvclwifSk7dmFyIHM9e307cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbih0LGUpe251bGwhPWlbZV0mJihzW3QubmFtZV09aVtlXSl9KSx7dmFsdWU6YSxncmFkczpzfX1mdW5jdGlvbiBrbih0KXtyZXR1cm4gRHQuY3VzdG9tR3JhZCh0KX1mdW5jdGlvbiBJbih0KXtpZih0LmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09dH0pLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21wdXRlIGdyYWRpZW50IG9mIHk9Zih4KSB3aXRoIHJlc3BlY3QgdG8geC4gTWFrZSBzdXJlIHRoYXRcXG4gICAgdGhlIGYgeW91IHBhc3NlZCBlbmNsb3NlcyBhbGwgb3BlcmF0aW9ucyB0aGF0IGxlYWQgZnJvbSB4IHRvIHkuXCIpfWZ1bmN0aW9uIEFuKHQpe3ZhciBlPU9iamVjdC5rZXlzKHQpO2lmKDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBhbiBvYmplY3Qgd2l0aCBhIHNpbmdsZSBrZXkgKG9wZXJhdGlvbiBuYW1lKSBtYXBwaW5nIHRvIGEgZnVuY3Rpb24uIEdvdCBhbiBvYmplY3Qgd2l0aCBcIitlLmxlbmd0aCtcIiBrZXlzLlwiKTt2YXIgbj1lWzBdLHI9dFtuXTtuLmVuZHNXaXRoKFwiX1wiKSYmKG49bi5zdWJzdHJpbmcoMCxuLmxlbmd0aC0xKSk7dmFyIG89ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sZT0wO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspdFtlXT1hcmd1bWVudHNbZV07RHQuc3RhcnRTY29wZShuKTt0cnl7dmFyIG89ci5hcHBseSh2b2lkIDAsdCk7cmV0dXJuIG8gaW5zdGFuY2VvZiBQcm9taXNlJiZjb25zb2xlLmVycm9yKFwiQ2Fubm90IHJldHVybiBhIFByb21pc2UgaW5zaWRlIG9mIHRpZHkuXCIpLER0LmVuZFNjb3BlKG8pLG99Y2F0Y2godCl7dGhyb3cgRHQuZW5kU2NvcGUobnVsbCksdH19O3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkobyxcIm5hbWVcIix7dmFsdWU6bixjb25maWd1cmFibGU6ITB9KSxvfXZhciBUbj1Bbih7c29mdG1heF86ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0tMSk7dmFyIG49d24odCxcImxvZ2l0c1wiLFwic29mdG1heFwiKTtpZigtMT09PWUmJihlPW4ucmFuay0xKSxlIT09bi5yYW5rLTEpdGhyb3cgRXJyb3IoXCJTb2Z0bWF4IGFsb25nIGEgbm9uLWxhc3QgZGltZW5zaW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLiBMb2dpdHMgd2FzIHJhbmsgXCIrbi5yYW5rK1wiIGFuZCBkaW0gd2FzIFwiK2UpO3JldHVybiBrbihmdW5jdGlvbih0LG4pe3ZhciByPXQubG9nU3VtRXhwKFtlXSwhMCksbz10LnRvRmxvYXQoKS5zdWIocikuZXhwKCk7cmV0dXJuIG4oW29dKSx7dmFsdWU6byxncmFkRnVuYzpmdW5jdGlvbih0LG4pe3ZhciByPW5bMF0sbz10Lm11bChyKTtyZXR1cm4gby5zdWIoby5zdW0oW2VdLCEwKS5tdWwocikpfX19KShuKX19KSxEbj1Bbih7bG9nU29mdG1heF86ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0tMSk7dmFyIG49d24odCxcImxvZ2l0c1wiLFwibG9nU29mdG1heFwiKTtpZigtMT09PWUmJihlPW4ucmFuay0xKSxlIT09bi5yYW5rLTEpdGhyb3cgRXJyb3IoXCJMb2cgU29mdG1heCBhbG9uZyBhIG5vbi1sYXN0IGRpbWVuc2lvbiBpcyBub3QgeWV0IHN1cHBvcnRlZC4gTG9naXRzIHdhcyByYW5rIFwiK24ucmFuaytcIiBhbmQgYXhpcyB3YXMgXCIrZSk7cmV0dXJuIGtuKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5tYXgoZSwhMCksbz10LnN1YihyKSxhPW8udG9GbG9hdCgpLnN1YihvLmV4cCgpLnN1bShlLCEwKS5sb2coKSk7cmV0dXJuIG4oW2FdKSx7dmFsdWU6YSxncmFkRnVuYzpmdW5jdGlvbih0LG4pe3ZhciByPW5bMF0uZXhwKCk7cmV0dXJuIHQuc3ViKHQuc3VtKGUsITApLm11bChyKSl9fX0pKG4pfX0pO3ZhciBPbj1Bbih7Y29tcGxleF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwicmVhbFwiLFwiY29tcGxleFwiKSxyPXduKGUsXCJpbWFnXCIsXCJjb21wbGV4XCIpO3JldHVybiB2KG4uc2hhcGUsci5zaGFwZSxcInJlYWwgYW5kIGltYWcgc2hhcGVzLCBcIituLnNoYXBlK1wiIGFuZCBcIityLnNoYXBlK1wiLCBtdXN0IG1hdGNoIGluIGNhbGwgdG8gdGYuY29tcGxleCgpLlwiKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuY29tcGxleChuLHIpfSx7JHJlYWw6biwkaW1hZzpyfSl9fSksX249QW4oe3JlYWxfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJpbnB1dFwiLFwicmVhbFwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlYWwoZSl9LHskaW5wdXQ6ZX0pfX0pLE1uPUFuKHtpbWFnXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwiaW5wdXRcIixcImltYWdcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5pbWFnKGUpfSx7JGlucHV0OmV9KX19KTtmdW5jdGlvbiBGbih0LGUsbil7aWYobnVsbD09biYmKG49Vyh0KSksXCJjb21wbGV4NjRcIj09PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnN0cnVjdCBhIGNvbXBsZXg2NCB0ZW5zb3IgZGlyZWN0bHkuIFBsZWFzZSB1c2UgdGYuY29tcGxleChyZWFsLCBpbWFnKS5cIik7aWYoIV8odCkmJiFBcnJheS5pc0FycmF5KHQpJiZcIm51bWJlclwiIT10eXBlb2YgdCYmXCJib29sZWFuXCIhPXR5cGVvZiB0JiZcInN0cmluZ1wiIT10eXBlb2YgdCl0aHJvdyBuZXcgRXJyb3IoXCJ2YWx1ZXMgcGFzc2VkIHRvIHRlbnNvcih2YWx1ZXMpIG11c3QgYmUgYSBudW1iZXIvYm9vbGVhbi9zdHJpbmcgb3IgYW4gYXJyYXkgb2YgbnVtYmVycy9ib29sZWFucy9zdHJpbmdzLCBvciBhIFR5cGVkQXJyYXlcIik7dmFyIHI9eW4odCk7aWYobnVsbCE9ZSl7SyhlKTt2YXIgbz15KGUpLGk9eShyKTtkKG89PT1pLGZ1bmN0aW9uKCl7cmV0dXJuXCJCYXNlZCBvbiB0aGUgcHJvdmlkZWQgc2hhcGUsIFtcIitlK1wiXSwgdGhlIHRlbnNvciBzaG91bGQgaGF2ZSBcIitvK1wiIHZhbHVlcyBidXQgaGFzIFwiK2l9KTtmb3IodmFyIHM9MDtzPHIubGVuZ3RoOysrcyl7dmFyIHU9cltzXSxsPXMhPT1yLmxlbmd0aC0xfHx1IT09eShlLnNsaWNlKHMpKTtkKHJbc109PT1lW3NdfHwhbCxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgY3JlYXRpbmcgYSBuZXcgVGVuc29yLiBJbmZlcnJlZCBzaGFwZSAoXCIrcitcIikgZG9lcyBub3QgbWF0Y2ggdGhlIHByb3ZpZGVkIHNoYXBlIChcIitlK1wiKS4gXCJ9KX19cmV0dXJuIF8odCl8fEFycmF5LmlzQXJyYXkodCl8fCh0PVt0XSksZT1lfHxyLHQ9XCJzdHJpbmdcIiE9PW4/Ryh0LG4sYS5nZXRCb29sKFwiREVCVUdcIikpOmcodCksZnQubWFrZShlLHt2YWx1ZXM6dH0sbil9ZnVuY3Rpb24gQm4odCxlKXtpZigoXyh0KXx8QXJyYXkuaXNBcnJheSh0KSkmJlwiY29tcGxleDY0XCIhPT1lKXRocm93IG5ldyBFcnJvcihcIkVycm9yIGNyZWF0aW5nIGEgbmV3IFNjYWxhcjogdmFsdWUgbXVzdCBiZSBhIHByaW1pdGl2ZSAobnVtYmVyfGJvb2xlYW58c3RyaW5nKVwiKTtyZXR1cm4gRm4odCxbXSxlKX1mdW5jdGlvbiBQbih0LGUpe20odCk7dmFyIG49eW4odCk7aWYoMSE9PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjFkKCkgcmVxdWlyZXMgdmFsdWVzIHRvIGJlIGEgZmxhdC9UeXBlZEFycmF5XCIpO3JldHVybiBGbih0LG4sZSl9ZnVuY3Rpb24gTG4odCxlLG4pe2lmKG0odCksbnVsbCE9ZSYmMiE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjJkKCkgcmVxdWlyZXMgc2hhcGUgdG8gaGF2ZSB0d28gbnVtYmVyc1wiKTt2YXIgcj15bih0KTtpZigyIT09ci5sZW5ndGgmJjEhPT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IyZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZigxPT09ci5sZW5ndGgmJm51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yMmQoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQvVHlwZWRBcnJheVwiKTtyZXR1cm4gRm4odCxlPWV8fHIsbil9ZnVuY3Rpb24gV24odCxlLG4pe2lmKG0odCksbnVsbCE9ZSYmMyE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjNkKCkgcmVxdWlyZXMgc2hhcGUgdG8gaGF2ZSB0aHJlZSBudW1iZXJzXCIpO3ZhciByPXluKHQpO2lmKDMhPT1yLmxlbmd0aCYmMSE9PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjNkKCkgcmVxdWlyZXMgdmFsdWVzIHRvIGJlIG51bWJlcltdW11bXSBvciBmbGF0L1R5cGVkQXJyYXlcIik7aWYoMT09PXIubGVuZ3RoJiZudWxsPT1lKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjNkKCkgcmVxdWlyZXMgc2hhcGUgdG8gYmUgcHJvdmlkZWQgd2hlbiBgdmFsdWVzYCBhcmUgYSBmbGF0IGFycmF5XCIpO3JldHVybiBGbih0LGU9ZXx8cixuKX1mdW5jdGlvbiBVbih0LGUsbil7aWYobSh0KSxudWxsIT1lJiY0IT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNGQoKSByZXF1aXJlcyBzaGFwZSB0byBoYXZlIGZvdXIgbnVtYmVyc1wiKTt2YXIgcj15bih0KTtpZig0IT09ci5sZW5ndGgmJjEhPT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I0ZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdW11bXSBvciBmbGF0L1R5cGVkQXJyYXlcIik7aWYoMT09PXIubGVuZ3RoJiZudWxsPT1lKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjRkKCkgcmVxdWlyZXMgc2hhcGUgdG8gYmUgcHJvdmlkZWQgd2hlbiBgdmFsdWVzYCBhcmUgYSBmbGF0IGFycmF5XCIpO3JldHVybiBGbih0LGU9ZXx8cixuKX1mdW5jdGlvbiB6bih0LGUsbil7aWYobSh0KSxudWxsIT1lJiY1IT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNWQoKSByZXF1aXJlcyBzaGFwZSB0byBoYXZlIGZpdmUgbnVtYmVyc1wiKTt2YXIgcj15bih0KTtpZig1IT09ci5sZW5ndGgmJjEhPT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I1ZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdW11bXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZigxPT09ci5sZW5ndGgmJm51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNWQoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQgYXJyYXlcIik7cmV0dXJuIEZuKHQsZT1lfHxyLG4pfWZ1bmN0aW9uIFZuKHQsZSxuKXtpZihtKHQpLG51bGwhPWUmJjYhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I2ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgc2l4IG51bWJlcnNcIik7dmFyIHI9eW4odCk7aWYoNiE9PXIubGVuZ3RoJiYxIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNmQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgbnVtYmVyW11bXVtdW11bXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZigxPT09ci5sZW5ndGgmJm51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNmQoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQgYXJyYXlcIik7cmV0dXJuIEZuKHQsZT1lfHxyLG4pfWZ1bmN0aW9uIEduKHQsZSl7aWYodm9pZCAwPT09ZSYmKGU9XCJmbG9hdDMyXCIpLFwiY29tcGxleDY0XCI9PT1lKXt2YXIgbj1Hbih0LFwiZmxvYXQzMlwiKSxyPXFuKHQsXCJmbG9hdDMyXCIpO3JldHVybiBPbihuLHIpfXZhciBvPUgoeSh0KSxlKTtyZXR1cm4gZnQubWFrZSh0LHt2YWx1ZXM6b30sZSl9ZnVuY3Rpb24gcW4odCxlKXtpZih2b2lkIDA9PT1lJiYoZT1cImZsb2F0MzJcIiksXCJjb21wbGV4NjRcIj09PWUpe3ZhciBuPXFuKHQsXCJmbG9hdDMyXCIpLHI9cW4odCxcImZsb2F0MzJcIik7cmV0dXJuIE9uKG4scil9dmFyIG89JCh5KHQpLGUpO3JldHVybiBmdC5tYWtlKHQse3ZhbHVlczpvfSxlKX1mdW5jdGlvbiBIbih0LGUsbil7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbihyKXtyZXR1cm4gci5maWxsKHQsZSxuKX0se30pfWZ1bmN0aW9uICRuKHQsZSxuKXtpZihuPD0wKXRocm93IG5ldyBFcnJvcihcIlRoZSBudW1iZXIgb2YgdmFsdWVzIHNob3VsZCBiZSBwb3NpdGl2ZS5cIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbihyKXtyZXR1cm4gci5saW5zcGFjZSh0LGUsbil9LHt9KX1mdW5jdGlvbiBqbih0LGUsbixyKXtpZih2b2lkIDA9PT1uJiYobj0xKSx2b2lkIDA9PT1yJiYocj1cImZsb2F0MzJcIiksMD09PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGhhdmUgYSBzdGVwIG9mIHplcm9cIik7aWYodD09PWV8fHQ8ZSYmbjwwfHxlPHQmJm4+MSlyZXR1cm4gcW4oWzBdLHIpO3ZhciBvPSQoTWF0aC5hYnMoTWF0aC5jZWlsKChlLXQpL24pKSxyKTtlPHQmJjE9PT1uJiYobj0tMSksb1swXT10O2Zvcih2YXIgYT0xO2E8by5sZW5ndGg7YSsrKW9bYV09b1thLTFdK247cmV0dXJuIFBuKG8scil9dmFyIEtuPUFuKHtvbmVzTGlrZV86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcIm9uZXNMaWtlXCIpO2lmKFwiY29tcGxleDY0XCI9PT1lLmR0eXBlKXt2YXIgbj1LbihfbihlKSkscj1YbihNbihlKSk7cmV0dXJuIE9uKG4scil9cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5vbmVzTGlrZShlKX0seyR4OmV9LG51bGwpfX0pLFhuPUFuKHt6ZXJvc0xpa2VfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJ6ZXJvc0xpa2VcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC56ZXJvc0xpa2UoZSl9LHskeDplfSxudWxsKX19KSxZbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5kYXRhTW92ZXI9dCx0aGlzLmRhdGE9bmV3IFdlYWtNYXB9cmV0dXJuIHQucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kYXRhLmhhcyh0KXx8dGhpcy5kYXRhTW92ZXIubW92ZURhdGEodCksdGhpcy5kYXRhLmdldCh0KX0sdC5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKHQsZSl7dGhpcy5kYXRhLnNldCh0LGUpfSx0LnByb3RvdHlwZS5oYXM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGF0YS5oYXModCl9LHQucHJvdG90eXBlLmRlbGV0ZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kYXRhLmRlbGV0ZSh0KX0sdH0oKSxRbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLnRpbWU9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZC5cIil9LHQucHJvdG90eXBlLnJlYWQ9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZC5cIil9LHQucHJvdG90eXBlLnJlYWRTeW5jPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWQuXCIpfSx0LnByb3RvdHlwZS5kaXNwb3NlRGF0YT1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkLlwiKX0sdC5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkLlwiKX0sdC5wcm90b3R5cGUuZnJvbVBpeGVscz1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWQuXCIpfSx0LnByb3RvdHlwZS5yZWdpc3Rlcj1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZC5cIil9LHQucHJvdG90eXBlLm1lbW9yeT1mdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWQuXCIpfSx0LnByb3RvdHlwZS5mbG9hdFByZWNpc2lvbj1mdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmVwc2lsb249ZnVuY3Rpb24oKXtyZXR1cm4gMzI9PT10aGlzLmZsb2F0UHJlY2lzaW9uKCk/MWUtNzoxZS00fSx0LnByb3RvdHlwZS5iYXRjaE1hdE11bD1mdW5jdGlvbih0LGUsbixyKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5mdXNlZEJhdGNoTWF0TXVsPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuc3RyaWRlZFNsaWNlPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkscyx1KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS51bnN0YWNrPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUucmV2ZXJzZT1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmNvbmNhdD1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLm5lZz1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5hZGROPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnN1YnRyYWN0PWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUubXVsdGlwbHk9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5yZWFsRGl2aWRlPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuZmxvb3JEaXY9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5zdW09ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5wcm9kPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUudW5zb3J0ZWRTZWdtZW50U3VtPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5hcmdNaW49ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5hcmdNYXg9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5lcXVhbD1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLm5vdEVxdWFsPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUubGVzcz1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmxlc3NFcXVhbD1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmdyZWF0ZXI9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5ncmVhdGVyRXF1YWw9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5sb2dpY2FsTm90PWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmxvZ2ljYWxBbmQ9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5sb2dpY2FsT3I9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS53aGVyZT1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5zZWxlY3Q9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnRvcGs9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLm1pbj1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLm1pbmltdW09ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5tb2Q9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5tYXg9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5tYXhpbXVtPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuYWxsPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuYW55PWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuc3F1YXJlZERpZmZlcmVuY2U9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5jZWlsPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnJvdW5kPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnNpZ249ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuaXNOYU49ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuaXNJbmY9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuaXNGaW5pdGU9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUucG93PWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuZXhwPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmV4cG0xPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmxvZz1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5sb2cxcD1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5zcXJ0PWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnJzcXJ0PWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnNxdWFyZT1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5yZWNpcHJvY2FsPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnJlbHU9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUucHJlbHU9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5lbHU9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuZWx1RGVyPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuc2VsdT1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5pbnQ9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuY2xpcD1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuYWJzPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmNvbXBsZXhBYnM9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuc2lnbW9pZD1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5zb2Z0cGx1cz1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5zaW49ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuY29zPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnRhbj1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5hc2luPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmFjb3M9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuYXRhbj1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5hdGFuMj1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnNpbmg9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuY29zaD1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS50YW5oPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmFzaW5oPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmFjb3NoPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmF0YW5oPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmVyZj1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5zdGVwPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuY29udjJkPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5jb252MmREZXJJbnB1dD1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuY29udjJkRGVyRmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkQ9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRERlcklucHV0PWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkREZXJGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmNvbnYzZD1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuY29udjNkRGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmNvbnYzZERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUubWF4UG9vbD1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLm1heFBvb2xCYWNrcHJvcD1mdW5jdGlvbih0LGUsbixyKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5hdmdQb29sPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuYXZnUG9vbEJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5yZXNoYXBlPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuY2FzdD1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnRpbGU9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5wYWQ9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnRyYW5zcG9zZT1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmdhdGhlcj1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuZ2F0aGVyTkQ9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5zY2F0dGVyTkQ9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmJhdGNoVG9TcGFjZU5EPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5zcGFjZVRvQmF0Y2hORD1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUucmVzaXplQmlsaW5lYXI9ZnVuY3Rpb24odCxlLG4scil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUucmVzaXplQmlsaW5lYXJCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yPWZ1bmN0aW9uKHQsZSxuLHIpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvckJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb249ZnVuY3Rpb24odCxlLG4scixvLGEpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uNEQ9ZnVuY3Rpb24odCxlLG4scixvKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5MUk5HcmFkPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLm11bHRpbm9taWFsPWZ1bmN0aW9uKHQsZSxuLHIpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLm9uZUhvdD1mdW5jdGlvbih0LGUsbixyKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5jdW1zdW09ZnVuY3Rpb24odCxlLG4scil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUubm9uTWF4U3VwcHJlc3Npb249ZnVuY3Rpb24odCxlLG4scixvKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5mZnQ9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuaWZmdD1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5jb21wbGV4PWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUucmVhbD1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5pbWFnPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmNyb3BBbmRSZXNpemU9ZnVuY3Rpb24odCxlLG4scixvLGEpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmRlcHRoVG9TcGFjZT1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuc3BsaXQ9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnNwYXJzZVRvRGVuc2U9ZnVuY3Rpb24odCxlLG4scil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZC5cIil9LHQucHJvdG90eXBlLm9uZXNMaWtlPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnplcm9zTGlrZT1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5saW5zcGFjZT1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHR9KCk7ZnVuY3Rpb24gSm4odCxlLG4pe2lmKFwiY29tcGxleDY0XCI9PT1lKXtpZihcImNvbXBsZXg2NFwiPT09dC5kdHlwZSlyZXR1cm4gdC5jbG9uZSgpO3ZhciByPXFuKHQuc2hhcGUpLG89dC50b0Zsb2F0KCksYT1uLmNvbXBsZXgobyxyKTtyZXR1cm4gci5kaXNwb3NlKCksby5kaXNwb3NlKCksYX1pZighTyh0LmR0eXBlLGUpKXJldHVybiBmdC5tYWtlKHQuc2hhcGUse2RhdGFJZDp0LmRhdGFJZH0sZSk7aWYoXCJjb21wbGV4NjRcIj09PXQuZHR5cGUpe3ZhciBpPW4ucmVhbCh0KTthPWkuY2FzdChlKTtyZXR1cm4gaS5kaXNwb3NlKCksYX1pZihcImludDMyXCI9PT1lKXJldHVybiBuLmludCh0KTtpZihcImJvb2xcIj09PWUpe3ZhciBzPUJuKDAsdC5kdHlwZSk7YT1uLm5vdEVxdWFsKHQscyk7cmV0dXJuIHMuZGlzcG9zZSgpLGF9dGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gQ2FzdDogdW5rbm93biBkdHlwZSBhcmd1bWVudCAoXCIrZStcIilcIil9ZnVuY3Rpb24gWm4odCxlKXtyZXR1cm4gZnQubWFrZShlLHtkYXRhSWQ6dC5kYXRhSWR9LHQuZHR5cGUpfWZ1bmN0aW9uIHRyKHQsZSxuKXt2YXIgcj0oZS10KS8obi0xKSxvPSQobixcImZsb2F0MzJcIik7b1swXT10O2Zvcih2YXIgYT0xO2E8by5sZW5ndGg7YSsrKW9bYV09b1thLTFdK3I7cmV0dXJuIFBuKG8sXCJmbG9hdDMyXCIpfWZ1bmN0aW9uIGVyKHQsZSl7aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbWVyZ2UgcmVhbCBhbmQgaW1hZyBhcnJheXMgb2YgZGlmZmVyZW50IGxlbmd0aHMuIHJlYWw6XCIrdC5sZW5ndGgrXCIsIGltYWc6IFwiK2UubGVuZ3RoK1wiLlwiKTtmb3IodmFyIG49bmV3IEZsb2F0MzJBcnJheSgyKnQubGVuZ3RoKSxyPTA7cjxuLmxlbmd0aDtyKz0yKW5bcl09dFtyLzJdLG5bcisxXT1lW3IvMl07cmV0dXJuIG59ZnVuY3Rpb24gbnIodCxlKXtyZXR1cm57cmVhbDp0WzIqZV0saW1hZzp0WzIqZSsxXX19ZnVuY3Rpb24gcnIodCxlLG4scil7dFsyKnJdPWUsdFsyKnIrMV09bn1mdW5jdGlvbiBvcih0LGUsbil7dmFyIHI9KG4/MjotMikqTWF0aC5QSSoodC9lKTtyZXR1cm57cmVhbDpNYXRoLmNvcyhyKSxpbWFnOk1hdGguc2luKHIpfX1mdW5jdGlvbiBhcih0LGUsbixyLG8pe2Zvcih2YXIgYT1BcnJheS5mcm9tKGUpLm1hcChmdW5jdGlvbih0LGUpe3JldHVybntzY29yZTp0LGJveEluZGV4OmV9fSkuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNjb3JlPm99KS5zb3J0KGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuc2NvcmUtdC5zY29yZX0pLGk9W10scz0wO3M8YS5sZW5ndGg7cysrKXt2YXIgdT1hW3NdLGw9dS5zY29yZSxjPXUuYm94SW5kZXg7aWYobDxvKWJyZWFrO2Zvcih2YXIgaD0hMSxwPWkubGVuZ3RoLTE7cD49MDstLXApe2lmKGlyKHQsYyxpW3BdKT49cil7aD0hMDticmVha319aWYoIWgmJihpLnB1c2goYyksaS5sZW5ndGg+PW4pKWJyZWFrfXJldHVybiBQbihpLFwiaW50MzJcIil9ZnVuY3Rpb24gaXIodCxlLG4pe3ZhciByPXQuc3ViYXJyYXkoNCplLDQqZSs0KSxvPXQuc3ViYXJyYXkoNCpuLDQqbis0KSxhPU1hdGgubWluKHJbMF0sclsyXSksaT1NYXRoLm1pbihyWzFdLHJbM10pLHM9TWF0aC5tYXgoclswXSxyWzJdKSx1PU1hdGgubWF4KHJbMV0sclszXSksbD1NYXRoLm1pbihvWzBdLG9bMl0pLGM9TWF0aC5taW4ob1sxXSxvWzNdKSxoPU1hdGgubWF4KG9bMF0sb1syXSkscD1NYXRoLm1heChvWzFdLG9bM10pLGY9KHMtYSkqKHUtaSksZD0oaC1sKSoocC1jKTtpZihmPD0wfHxkPD0wKXJldHVybiAwO3ZhciB2PU1hdGgubWF4KGEsbCksbT1NYXRoLm1heChpLGMpLGc9TWF0aC5taW4ocyxoKSx5PU1hdGgubWluKHUscCkseD1NYXRoLm1heChnLXYsMCkqTWF0aC5tYXgoeS1tLDApO3JldHVybiB4LyhmK2QteCl9ZnVuY3Rpb24gc3IodCxlLG4pe3ZhciByPW5ldyBBcnJheSh0LnJhbmspLmZpbGwoMCksbz10LnNoYXBlLnNsaWNlKCk7cmV0dXJuIGUubWFwKGZ1bmN0aW9uKGUpe29bbl09ZTt2YXIgYT10LnNsaWNlKHIsbyk7cmV0dXJuIHJbbl0rPWUsYX0pfWZ1bmN0aW9uIHVyKHQsZSxuLHIsbyl7Zm9yKHZhciBhPWVbZS5sZW5ndGgtMV0saT1bdC5sZW5ndGgvYSxhXSxzPWlbMF0sdT1pWzFdLGw9SShuLHMqciksYz1JKFwiaW50MzJcIixzKnIpLGg9MDtoPHM7aCsrKXtmb3IodmFyIHA9aCp1LGY9dC5zdWJhcnJheShwLHArdSksZD1bXSx2PTA7djxmLmxlbmd0aDt2KyspZC5wdXNoKHt2YWx1ZTpmW3ZdLGluZGV4OnZ9KTtkLnNvcnQoZnVuY3Rpb24odCxlKXtyZXR1cm4gZS52YWx1ZS10LnZhbHVlfSk7dmFyIG09aCpyLGc9bC5zdWJhcnJheShtLG0rcikseT1jLnN1YmFycmF5KG0sbStyKTtmb3Iodj0wO3Y8cjt2KyspZ1t2XT1kW3ZdLnZhbHVlLHlbdl09ZFt2XS5pbmRleH12YXIgeD1lLnNsaWNlKCk7cmV0dXJuIHhbeC5sZW5ndGgtMV09cixbRm4obCx4LG4pLEZuKGMseCxcImludDMyXCIpXX12YXIgbHI9QW4oe2NvbmNhdF86ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0wKSxkKHQubGVuZ3RoPj0xLGZ1bmN0aW9uKCl7cmV0dXJuXCJQYXNzIGF0IGxlYXN0IG9uZSB0ZW5zb3IgdG8gY29uY2F0XCJ9KTt2YXIgbj1ibih0LFwidGVuc29yc1wiLFwiY29uY2F0XCIpO2U9TihlLG5bMF0uc2hhcGUpWzBdO3ZhciByPXNuKG4ubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSksZSk7aWYoMD09PXkocikpcmV0dXJuIEZuKFtdLHIpO2lmKDE9PT0obj1uLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gdC5zaXplPjB9KSkubGVuZ3RoKXJldHVybiBuWzBdO3ZhciBvPW4ubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSk7IWZ1bmN0aW9uKHQsZSl7dmFyIG49dFswXS5sZW5ndGg7dC5mb3JFYWNoKGZ1bmN0aW9uKHQsZSl7ZCh0Lmxlbmd0aD09PW4sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbmNhdFwiK24rXCJEOiByYW5rIG9mIHRlbnNvcnNbXCIrZStcIl0gbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgcmFuayBvZiB0aGUgcmVzdCAoXCIrbitcIilcIn0pfSksZChlPj0wJiZlPG4sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbmNhdFwiK24rXCJEOiBheGlzIG11c3QgYmUgYmV0d2VlbiAwIGFuZCBcIisobi0xKStcIi5cIn0pO3ZhciByPXRbMF07dC5mb3JFYWNoKGZ1bmN0aW9uKHQsbyl7Zm9yKHZhciBhPTA7YTxuO2ErKylkKGE9PT1lfHx0W2FdPT09clthXSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29uY2F0XCIrbitcIkQ6IFNoYXBlIG9mIHRlbnNvcnNbXCIrbytcIl0gKFwiK3QrXCIpIGRvZXMgbm90IG1hdGNoIHRoZSBzaGFwZSBvZiB0aGUgcmVzdCAoXCIrcitcIikgYWxvbmcgdGhlIG5vbi1jb25jYXRlbmF0ZWQgYXhpcyBcIitvK1wiLlwifSl9KX0obyxlKTt2YXIgYT1uO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuY29uY2F0KG4sZSl9LGEsZnVuY3Rpb24odCl7dmFyIG49by5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHRbZV19KTtyZXR1cm4gZHIodCxuLGUpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdH19KX0pfX0pLGNyPUFuKHtjb25jYXQxZF86ZnVuY3Rpb24odCl7cmV0dXJuIGxyKHQsMCl9fSksaHI9QW4oe2NvbmNhdDJkXzpmdW5jdGlvbih0LGUpe3JldHVybiBscih0LGUpfX0pLHByPUFuKHtjb25jYXQzZF86ZnVuY3Rpb24odCxlKXtyZXR1cm4gbHIodCxlKX19KSxmcj1Bbih7Y29uY2F0NGRfOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIGxyKHQsZSl9fSksZHI9QW4oe3NwbGl0XzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49MCk7dmFyIHIsbz13bih0LFwieFwiLFwic3BsaXRcIik7cmV0dXJuIG49TihuLG8uc2hhcGUpWzBdLFwibnVtYmVyXCI9PXR5cGVvZiBlPyhkKG8uc2hhcGVbbl0lZT09MCxmdW5jdGlvbigpe3JldHVyblwiTnVtYmVyIG9mIHNwbGl0cyBtdXN0IGV2ZW5seSBkaXZpZGUgdGhlIGF4aXMuXCJ9KSxyPW5ldyBBcnJheShlKS5maWxsKG8uc2hhcGVbbl0vZSkpOihkKG8uc2hhcGVbbl09PT1lLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0K2V9KSxmdW5jdGlvbigpe3JldHVyblwiVGhlIHN1bSBvZiBzaXplcyBtdXN0IG1hdGNoIHRoZSBzaXplIG9mIHRoZSBheGlzIGRpbWVuc2lvbi5cIn0pLHI9ZSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNwbGl0KG8scixuKX0seyR4Om99LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBscih0LG4pfX19KX19KTtcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiZzZWxmO2Z1bmN0aW9uIHZyKHQsZSl7cmV0dXJuIHQoZT17ZXhwb3J0czp7fX0sZS5leHBvcnRzKSxlLmV4cG9ydHN9dmFyIG1yPXZyKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXt2YXIgZSxuPXRoaXMscj0oZT00MDIyODcxMTk3LGZ1bmN0aW9uKHQpe3Q9dC50b1N0cmluZygpO2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj0uMDI1MTk2MDMyODI0MTY5MzgqKGUrPXQuY2hhckNvZGVBdChuKSk7ci09ZT1yPj4+MCxlPShyKj1lKT4+PjAsZSs9NDI5NDk2NzI5Niooci09ZSl9cmV0dXJuIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTAqKGU+Pj4wKX0pO24ubmV4dD1mdW5jdGlvbigpe3ZhciB0PTIwOTE2Mzkqbi5zMCsyLjMyODMwNjQzNjUzODY5NjNlLTEwKm4uYztyZXR1cm4gbi5zMD1uLnMxLG4uczE9bi5zMixuLnMyPXQtKG4uYz0wfHQpfSxuLmM9MSxuLnMwPXIoXCIgXCIpLG4uczE9cihcIiBcIiksbi5zMj1yKFwiIFwiKSxuLnMwLT1yKHQpLG4uczA8MCYmKG4uczArPTEpLG4uczEtPXIodCksbi5zMTwwJiYobi5zMSs9MSksbi5zMi09cih0KSxuLnMyPDAmJihuLnMyKz0xKSxyPW51bGx9ZnVuY3Rpb24gbyh0LGUpe3JldHVybiBlLmM9dC5jLGUuczA9dC5zMCxlLnMxPXQuczEsZS5zMj10LnMyLGV9ZnVuY3Rpb24gYSh0LGUpe3ZhciBuPW5ldyByKHQpLGE9ZSYmZS5zdGF0ZSxpPW4ubmV4dDtyZXR1cm4gaS5pbnQzMj1mdW5jdGlvbigpe3JldHVybiA0Mjk0OTY3Mjk2Km4ubmV4dCgpfDB9LGkuZG91YmxlPWZ1bmN0aW9uKCl7cmV0dXJuIGkoKSsxLjExMDIyMzAyNDYyNTE1NjVlLTE2KigyMDk3MTUyKmkoKXwwKX0saS5xdWljaz1pLGEmJihcIm9iamVjdFwiPT10eXBlb2YgYSYmbyhhLG4pLGkuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbyhuLHt9KX0pLGl9ZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1hOm4mJm4uYW1kP24oZnVuY3Rpb24oKXtyZXR1cm4gYX0pOnRoaXMuYWxlYT1hfSgwLHQsITEpfSksZ3I9dnIoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlPXRoaXMsbj1cIlwiO2UueD0wLGUueT0wLGUuej0wLGUudz0wLGUubmV4dD1mdW5jdGlvbigpe3ZhciB0PWUueF5lLng8PDExO3JldHVybiBlLng9ZS55LGUueT1lLnosZS56PWUudyxlLndePWUudz4+PjE5XnRedD4+Pjh9LHQ9PT0oMHx0KT9lLng9dDpuKz10O2Zvcih2YXIgcj0wO3I8bi5sZW5ndGgrNjQ7cisrKWUueF49MHxuLmNoYXJDb2RlQXQociksZS5uZXh0KCl9ZnVuY3Rpb24gbyh0LGUpe3JldHVybiBlLng9dC54LGUueT10LnksZS56PXQueixlLnc9dC53LGV9ZnVuY3Rpb24gYSh0LGUpe3ZhciBuPW5ldyByKHQpLGE9ZSYmZS5zdGF0ZSxpPWZ1bmN0aW9uKCl7cmV0dXJuKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIGkuZG91YmxlPWZ1bmN0aW9uKCl7ZG97dmFyIHQ9KChuLm5leHQoKT4+PjExKSsobi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2KS8oMTw8MjEpfXdoaWxlKDA9PT10KTtyZXR1cm4gdH0saS5pbnQzMj1uLm5leHQsaS5xdWljaz1pLGEmJihcIm9iamVjdFwiPT10eXBlb2YgYSYmbyhhLG4pLGkuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbyhuLHt9KX0pLGl9ZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1hOm4mJm4uYW1kP24oZnVuY3Rpb24oKXtyZXR1cm4gYX0pOnRoaXMueG9yMTI4PWF9KDAsdCwhMSl9KSx5cj12cihmdW5jdGlvbih0KXshZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dmFyIGU9dGhpcyxuPVwiXCI7ZS5uZXh0PWZ1bmN0aW9uKCl7dmFyIHQ9ZS54XmUueD4+PjI7cmV0dXJuIGUueD1lLnksZS55PWUueixlLno9ZS53LGUudz1lLnYsKGUuZD1lLmQrMzYyNDM3fDApKyhlLnY9ZS52XmUudjw8NF50XnQ8PDEpfDB9LGUueD0wLGUueT0wLGUuej0wLGUudz0wLGUudj0wLHQ9PT0oMHx0KT9lLng9dDpuKz10O2Zvcih2YXIgcj0wO3I8bi5sZW5ndGgrNjQ7cisrKWUueF49MHxuLmNoYXJDb2RlQXQocikscj09bi5sZW5ndGgmJihlLmQ9ZS54PDwxMF5lLng+Pj40KSxlLm5leHQoKX1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuIGUueD10LngsZS55PXQueSxlLno9dC56LGUudz10LncsZS52PXQudixlLmQ9dC5kLGV9ZnVuY3Rpb24gYSh0LGUpe3ZhciBuPW5ldyByKHQpLGE9ZSYmZS5zdGF0ZSxpPWZ1bmN0aW9uKCl7cmV0dXJuKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIGkuZG91YmxlPWZ1bmN0aW9uKCl7ZG97dmFyIHQ9KChuLm5leHQoKT4+PjExKSsobi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2KS8oMTw8MjEpfXdoaWxlKDA9PT10KTtyZXR1cm4gdH0saS5pbnQzMj1uLm5leHQsaS5xdWljaz1pLGEmJihcIm9iamVjdFwiPT10eXBlb2YgYSYmbyhhLG4pLGkuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbyhuLHt9KX0pLGl9ZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1hOm4mJm4uYW1kP24oZnVuY3Rpb24oKXtyZXR1cm4gYX0pOnRoaXMueG9yd293PWF9KDAsdCwhMSl9KSx4cj12cihmdW5jdGlvbih0KXshZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dmFyIGU9dGhpcztlLm5leHQ9ZnVuY3Rpb24oKXt2YXIgdCxuLHI9ZS54LG89ZS5pO3JldHVybiB0PXJbb10sbj0odF49dD4+PjcpXnQ8PDI0LG5ePSh0PXJbbysxJjddKV50Pj4+MTAsbl49KHQ9cltvKzMmN10pXnQ+Pj4zLG5ePSh0PXJbbys0JjddKV50PDw3LHQ9cltvKzcmN10sbl49KHRePXQ8PDEzKV50PDw5LHJbb109bixlLmk9bysxJjcsbn0sZnVuY3Rpb24odCxlKXt2YXIgbixyPVtdO2lmKGU9PT0oMHxlKSlyWzBdPWU7ZWxzZSBmb3IoZT1cIlwiK2Usbj0wO248ZS5sZW5ndGg7KytuKXJbNyZuXT1yWzcmbl08PDE1XmUuY2hhckNvZGVBdChuKStyW24rMSY3XTw8MTM7Zm9yKDtyLmxlbmd0aDw4OylyLnB1c2goMCk7Zm9yKG49MDtuPDgmJjA9PT1yW25dOysrbik7Zm9yKDg9PW4/cls3XT0tMTpyW25dLHQueD1yLHQuaT0wLG49MjU2O24+MDstLW4pdC5uZXh0KCl9KGUsdCl9ZnVuY3Rpb24gbyh0LGUpe3JldHVybiBlLng9dC54LnNsaWNlKCksZS5pPXQuaSxlfWZ1bmN0aW9uIGEodCxlKXtudWxsPT10JiYodD0rbmV3IERhdGUpO3ZhciBuPW5ldyByKHQpLGE9ZSYmZS5zdGF0ZSxpPWZ1bmN0aW9uKCl7cmV0dXJuKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIGkuZG91YmxlPWZ1bmN0aW9uKCl7ZG97dmFyIHQ9KChuLm5leHQoKT4+PjExKSsobi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2KS8oMTw8MjEpfXdoaWxlKDA9PT10KTtyZXR1cm4gdH0saS5pbnQzMj1uLm5leHQsaS5xdWljaz1pLGEmJihhLngmJm8oYSxuKSxpLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG8obix7fSl9KSxpfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9YTpuJiZuLmFtZD9uKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KTp0aGlzLnhvcnNoaWZ0Nz1hfSgwLHQsITEpfSksd3I9dnIoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlPXRoaXM7ZS5uZXh0PWZ1bmN0aW9uKCl7dmFyIHQsbixyPWUudyxvPWUuWCxhPWUuaTtyZXR1cm4gZS53PXI9cisxNjQwNTMxNTI3fDAsbj1vW2ErMzQmMTI3XSx0PW9bYT1hKzEmMTI3XSxuXj1uPDwxMyx0Xj10PDwxNyxuXj1uPj4+MTUsdF49dD4+PjEyLG49b1thXT1uXnQsZS5pPWEsbisocl5yPj4+MTYpfDB9LGZ1bmN0aW9uKHQsZSl7dmFyIG4scixvLGEsaSxzPVtdLHU9MTI4O2ZvcihlPT09KDB8ZSk/KHI9ZSxlPW51bGwpOihlKz1cIlxcMFwiLHI9MCx1PU1hdGgubWF4KHUsZS5sZW5ndGgpKSxvPTAsYT0tMzI7YTx1OysrYSllJiYocl49ZS5jaGFyQ29kZUF0KChhKzMyKSVlLmxlbmd0aCkpLDA9PT1hJiYoaT1yKSxyXj1yPDwxMCxyXj1yPj4+MTUscl49cjw8NCxyXj1yPj4+MTMsYT49MCYmKGk9aSsxNjQwNTMxNTI3fDAsbz0wPT0obj1zWzEyNyZhXV49citpKT9vKzE6MCk7Zm9yKG8+PTEyOCYmKHNbMTI3JihlJiZlLmxlbmd0aHx8MCldPS0xKSxvPTEyNyxhPTUxMjthPjA7LS1hKXI9c1tvKzM0JjEyN10sbj1zW289bysxJjEyN10scl49cjw8MTMsbl49bjw8MTcscl49cj4+PjE1LG5ePW4+Pj4xMixzW29dPXJebjt0Lnc9aSx0Llg9cyx0Lmk9b30oZSx0KX1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuIGUuaT10LmksZS53PXQudyxlLlg9dC5YLnNsaWNlKCksZX1mdW5jdGlvbiBhKHQsZSl7bnVsbD09dCYmKHQ9K25ldyBEYXRlKTt2YXIgbj1uZXcgcih0KSxhPWUmJmUuc3RhdGUsaT1mdW5jdGlvbigpe3JldHVybihuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBpLmRvdWJsZT1mdW5jdGlvbigpe2Rve3ZhciB0PSgobi5uZXh0KCk+Pj4xMSkrKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvKDE8PDIxKX13aGlsZSgwPT09dCk7cmV0dXJuIHR9LGkuaW50MzI9bi5uZXh0LGkucXVpY2s9aSxhJiYoYS5YJiZvKGEsbiksaS5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBvKG4se30pfSksaX1lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPWE6biYmbi5hbWQ/bihmdW5jdGlvbigpe3JldHVybiBhfSk6dGhpcy54b3I0MDk2PWF9KDAsdCwhMSl9KSxicj12cihmdW5jdGlvbih0KXshZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dmFyIGU9dGhpcyxuPVwiXCI7ZS5uZXh0PWZ1bmN0aW9uKCl7dmFyIHQ9ZS5iLG49ZS5jLHI9ZS5kLG89ZS5hO3JldHVybiB0PXQ8PDI1XnQ+Pj43Xm4sbj1uLXJ8MCxyPXI8PDI0XnI+Pj44Xm8sbz1vLXR8MCxlLmI9dD10PDwyMF50Pj4+MTJebixlLmM9bj1uLXJ8MCxlLmQ9cjw8MTZebj4+PjE2Xm8sZS5hPW8tdHwwfSxlLmE9MCxlLmI9MCxlLmM9LTE2NDA1MzE1MjcsZS5kPTEzNjcxMzA1NTEsdD09PU1hdGguZmxvb3IodCk/KGUuYT10LzQyOTQ5NjcyOTZ8MCxlLmI9MHx0KTpuKz10O2Zvcih2YXIgcj0wO3I8bi5sZW5ndGgrMjA7cisrKWUuYl49MHxuLmNoYXJDb2RlQXQociksZS5uZXh0KCl9ZnVuY3Rpb24gbyh0LGUpe3JldHVybiBlLmE9dC5hLGUuYj10LmIsZS5jPXQuYyxlLmQ9dC5kLGV9ZnVuY3Rpb24gYSh0LGUpe3ZhciBuPW5ldyByKHQpLGE9ZSYmZS5zdGF0ZSxpPWZ1bmN0aW9uKCl7cmV0dXJuKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIGkuZG91YmxlPWZ1bmN0aW9uKCl7ZG97dmFyIHQ9KChuLm5leHQoKT4+PjExKSsobi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2KS8oMTw8MjEpfXdoaWxlKDA9PT10KTtyZXR1cm4gdH0saS5pbnQzMj1uLm5leHQsaS5xdWljaz1pLGEmJihcIm9iamVjdFwiPT10eXBlb2YgYSYmbyhhLG4pLGkuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbyhuLHt9KX0pLGl9ZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1hOm4mJm4uYW1kP24oZnVuY3Rpb24oKXtyZXR1cm4gYX0pOnRoaXMudHljaGVpPWF9KDAsdCwhMSl9KSxDcj12cihmdW5jdGlvbih0KXshZnVuY3Rpb24oZSxuKXt2YXIgcixvPXRoaXMsYT0yNTYsaT02LHM9XCJyYW5kb21cIix1PW4ucG93KGEsaSksbD1uLnBvdygyLDUyKSxjPTIqbCxoPWEtMTtmdW5jdGlvbiBwKHQsaCxwKXt2YXIgZz1bXSx5PXYoZnVuY3Rpb24gdChlLG4pe3ZhciByLG89W10sYT10eXBlb2YgZTtpZihuJiZcIm9iamVjdFwiPT1hKWZvcihyIGluIGUpdHJ5e28ucHVzaCh0KGVbcl0sbi0xKSl9Y2F0Y2godCl7fXJldHVybiBvLmxlbmd0aD9vOlwic3RyaW5nXCI9PWE/ZTplK1wiXFwwXCJ9KChoPTE9PWg/e2VudHJvcHk6ITB9Omh8fHt9KS5lbnRyb3B5P1t0LG0oZSldOm51bGw9PXQ/ZnVuY3Rpb24oKXt0cnl7dmFyIHQ7cmV0dXJuIHImJih0PXIucmFuZG9tQnl0ZXMpP3Q9dChhKToodD1uZXcgVWludDhBcnJheShhKSwoby5jcnlwdG98fG8ubXNDcnlwdG8pLmdldFJhbmRvbVZhbHVlcyh0KSksbSh0KX1jYXRjaCh0KXt2YXIgbj1vLm5hdmlnYXRvcixpPW4mJm4ucGx1Z2lucztyZXR1cm5bK25ldyBEYXRlLG8saSxvLnNjcmVlbixtKGUpXX19KCk6dCwzKSxnKSx4PW5ldyBmKGcpLHc9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9eC5nKGkpLGU9dSxuPTA7dDxsOyl0PSh0K24pKmEsZSo9YSxuPXguZygxKTtmb3IoO3Q+PWM7KXQvPTIsZS89MixuPj4+PTE7cmV0dXJuKHQrbikvZX07cmV0dXJuIHcuaW50MzI9ZnVuY3Rpb24oKXtyZXR1cm4gMHx4LmcoNCl9LHcucXVpY2s9ZnVuY3Rpb24oKXtyZXR1cm4geC5nKDQpLzQyOTQ5NjcyOTZ9LHcuZG91YmxlPXcsdihtKHguUyksZSksKGgucGFzc3x8cHx8ZnVuY3Rpb24odCxlLHIsbyl7cmV0dXJuIG8mJihvLlMmJmQobyx4KSx0LnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIGQoeCx7fSl9KSxyPyhuW3NdPXQsZSk6dH0pKHcseSxcImdsb2JhbFwiaW4gaD9oLmdsb2JhbDp0aGlzPT1uLGguc3RhdGUpfWZ1bmN0aW9uIGYodCl7dmFyIGUsbj10Lmxlbmd0aCxyPXRoaXMsbz0wLGk9ci5pPXIuaj0wLHM9ci5TPVtdO2ZvcihufHwodD1bbisrXSk7bzxhOylzW29dPW8rKztmb3Iobz0wO288YTtvKyspc1tvXT1zW2k9aCZpK3RbbyVuXSsoZT1zW29dKV0sc1tpXT1lOyhyLmc9ZnVuY3Rpb24odCl7Zm9yKHZhciBlLG49MCxvPXIuaSxpPXIuaixzPXIuUzt0LS07KWU9c1tvPWgmbysxXSxuPW4qYStzW2gmKHNbb109c1tpPWgmaStlXSkrKHNbaV09ZSldO3JldHVybiByLmk9byxyLmo9aSxufSkoYSl9ZnVuY3Rpb24gZCh0LGUpe3JldHVybiBlLmk9dC5pLGUuaj10LmosZS5TPXQuUy5zbGljZSgpLGV9ZnVuY3Rpb24gdih0LGUpe2Zvcih2YXIgbixyPXQrXCJcIixvPTA7bzxyLmxlbmd0aDspZVtoJm9dPWgmKG5ePTE5KmVbaCZvXSkrci5jaGFyQ29kZUF0KG8rKyk7cmV0dXJuIG0oZSl9ZnVuY3Rpb24gbSh0KXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSgwLHQpfWlmKG5bXCJzZWVkXCIrc109cCx2KG4ucmFuZG9tKCksZSksdC5leHBvcnRzKXt0LmV4cG9ydHM9cDt0cnl7cj1yZXF1aXJlKFwiY3J5cHRvXCIpfWNhdGNoKHQpe319fShbXSxNYXRoKX0pO0NyLmFsZWE9bXIsQ3IueG9yMTI4PWdyLENyLnhvcndvdz15cixDci54b3JzaGlmdDc9eHIsQ3IueG9yNDA5Nj13cixDci50eWNoZWk9YnI7dmFyIEVyPUNyLmFsZWEsUnI9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxuLHIsbyl7dGhpcy5tZWFuPXQsdGhpcy5zdGREZXY9ZSx0aGlzLmR0eXBlPW4sdGhpcy5uZXh0VmFsPU5hTix0aGlzLnRydW5jYXRlZD1yLHRoaXMudHJ1bmNhdGVkJiYodGhpcy51cHBlcj10aGlzLm1lYW4rMip0aGlzLnN0ZERldix0aGlzLmxvd2VyPXRoaXMubWVhbi0yKnRoaXMuc3RkRGV2KTt2YXIgYT1vfHxNYXRoLnJhbmRvbSgpO3RoaXMucmFuZG9tPUVyKGEudG9TdHJpbmcoKSl9cmV0dXJuIHQucHJvdG90eXBlLm5leHRWYWx1ZT1mdW5jdGlvbigpe2lmKCFpc05hTih0aGlzLm5leHRWYWwpKXt2YXIgdD10aGlzLm5leHRWYWw7cmV0dXJuIHRoaXMubmV4dFZhbD1OYU4sdH1mb3IodmFyIGUsbixyPSExOyFyOyl7dmFyIG89dm9pZCAwLGE9dm9pZCAwLGk9dm9pZCAwO2Rve2k9KG89Mip0aGlzLnJhbmRvbSgpLTEpKm8rKGE9Mip0aGlzLnJhbmRvbSgpLTEpKmF9d2hpbGUoaT49MXx8MD09PWkpO3ZhciBzPU1hdGguc3FydCgtMipNYXRoLmxvZyhpKS9pKTtlPXRoaXMubWVhbit0aGlzLnN0ZERldipvKnMsbj10aGlzLm1lYW4rdGhpcy5zdGREZXYqYSpzLHRoaXMudHJ1bmNhdGVkJiYhdGhpcy5pc1ZhbGlkVHJ1bmNhdGVkKGUpfHwocj0hMCl9cmV0dXJuIHRoaXMudHJ1bmNhdGVkJiYhdGhpcy5pc1ZhbGlkVHJ1bmNhdGVkKG4pfHwodGhpcy5uZXh0VmFsPXRoaXMuY29udmVydFZhbHVlKG4pKSx0aGlzLmNvbnZlcnRWYWx1ZShlKX0sdC5wcm90b3R5cGUuY29udmVydFZhbHVlPWZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT10aGlzLmR0eXBlfHxcImZsb2F0MzJcIj09PXRoaXMuZHR5cGU/dDpNYXRoLnJvdW5kKHQpfSx0LnByb3RvdHlwZS5pc1ZhbGlkVHJ1bmNhdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0PD10aGlzLnVwcGVyJiZ0Pj10aGlzLmxvd2VyfSx0fSgpLFNyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUsbixyKXt2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1lJiYoZT0xKSx2b2lkIDA9PT1yJiYocj1NYXRoLnJhbmRvbSgpKTt2YXIgbz10aGlzO2lmKHRoaXMuY2FuUmV0dXJuRmxvYXQ9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09by5kdHlwZXx8XCJmbG9hdDMyXCI9PT1vLmR0eXBlfSx0aGlzLm1pbj10LHRoaXMucmFuZ2U9ZS10LHRoaXMuZHR5cGU9biwhdGhpcy5jYW5SZXR1cm5GbG9hdCgpJiZ0aGlzLnJhbmdlPD0xKXRocm93IG5ldyBFcnJvcihcIlRoZSBkaWZmZXJlbmNlIGJldHdlZW4gXCIrdCtcIiAtIFwiK2UrXCIgPD0gMSBhbmQgZHR5cGUgaXMgbm90IGZsb2F0XCIpO3RoaXMucmFuZG9tPUVyKHIudG9TdHJpbmcoKSl9cmV0dXJuIHQucHJvdG90eXBlLmNvbnZlcnRWYWx1ZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jYW5SZXR1cm5GbG9hdCgpP3Q6TWF0aC5yb3VuZCh0KX0sdC5wcm90b3R5cGUubmV4dFZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29udmVydFZhbHVlKHRoaXMubWluK3RoaXMucmFuZ2UqdGhpcy5yYW5kb20oKSl9LHR9KCk7ZnVuY3Rpb24gTnIodCxlLG4pe3JldHVybiB2b2lkIDA9PT1lJiYoZT1cImZsb2F0MzJcIiksZT1lfHxcImZsb2F0MzJcIixLKHQpLG5ldyBsdCh0LGUsbil9ZnVuY3Rpb24ga3IodCxlKXt2b2lkIDA9PT1lJiYoZT0hMSksY29uc29sZS5sb2codC50b1N0cmluZyhlKSl9dmFyIElyPUFuKHtiYXRjaFRvU3BhY2VORF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPXduKHQsXCJ4XCIsXCJiYXRjaFRvU3BhY2VORFwiKSxvPWUucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0pO3JldHVybiBkKHIucmFuaz49MStlLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiaW5wdXQgcmFuayBpcyBcIityLnJhbmsrXCIgYnV0IHNob3VsZCBiZSA+IHRoYW4gYmxvY2tTaGFwZS5sZW5ndGggXCIrZS5sZW5ndGh9KSxkKG4ubGVuZ3RoPT09ZS5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cImNyb3BzLmxlbmd0aCBpcyBcIituLmxlbmd0aCtcIiBidXQgc2hvdWxkIGJlIGVxdWFsIHRvIGJsb2NrU2hhcGUubGVuZ3RoICBcIitlLmxlbmd0aH0pLGQoci5zaGFwZVswXSVvPT0wLGZ1bmN0aW9uKCl7cmV0dXJuXCJpbnB1dCB0ZW5zb3IgYmF0Y2ggaXMgXCIrci5zaGFwZVswXStcIiBidXQgaXMgbm90IGRpdmlzaWJsZSBieSB0aGUgcHJvZHVjdCBvZiB0aGUgZWxlbWVudHMgb2YgYmxvY2tTaGFwZSBcIitlLmpvaW4oXCIgKiBcIikrXCIgPT09IFwiK299KSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuYmF0Y2hUb1NwYWNlTkQocixlLG4pfSx7JHg6cn0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuc3BhY2VUb0JhdGNoTkQoZSxuKX19fSl9fSksQXI9QW4oe2Nhc3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcInhcIixcImNhc3RcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5jYXN0KG4sZSl9LHskeDpufSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5jbG9uZSgpfX19KX19KSxUcj1Bbih7Y2xvbmVfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJjbG9uZVwiLG51bGwpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIGZ0Lm1ha2UoZS5zaGFwZSx7ZGF0YUlkOmUuZGF0YUlkfSxlLmR0eXBlKX0seyR4OmV9LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LnRvRmxvYXQoKX19fSl9fSksRHI9QW4oe2N1bXN1bV86ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ZSYmKGU9MCksdm9pZCAwPT09biYmKG49ITEpLHZvaWQgMD09PXImJihyPSExKTt2YXIgbz13bih0LFwieFwiLFwiY3Vtc3VtXCIpLGE9cm4oW2V8PTBdLG8ucmFuayksaT1vO251bGwhPWEmJihpPW8udHJhbnNwb3NlKGEpKTt2YXIgcz1hbigxLG8ucmFuaylbMF0sdT1EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuY3Vtc3VtKGkscyxuLHIpfSx7cGVybXV0ZWRYOml9LGZ1bmN0aW9uKHQpe3JldHVybntwZXJtdXRlZFg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5jdW1zdW0oZSxuLCFyKX19fSk7cmV0dXJuIG51bGwhPWEmJih1PXUudHJhbnNwb3NlKGEpKSx1fX0pLE9yPUFuKHtkZXB0aFRvU3BhY2VfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj1cIk5IV0NcIik7dmFyIHI9d24odCxcInhcIixcImRlcHRoVG9TcGFjZVwiKSxvPVwiTkhXQ1wiPT09bj9yLnNoYXBlWzFdOnIuc2hhcGVbMl0sYT1cIk5IV0NcIj09PW4/ci5zaGFwZVsyXTpyLnNoYXBlWzNdLGk9XCJOSFdDXCI9PT1uP3Iuc2hhcGVbM106ci5zaGFwZVsxXTtyZXR1cm4gZChvKmU+PTAsZnVuY3Rpb24oKXtyZXR1cm5cIk5lZ2F0aXZlIGRpbWVuc2lvbiBzaXplIGNhdXNlZCBieSBvdmVyZmxvdyB3aGVuIG11bHRpcGx5aW5nXFxuICAgICAgXCIrbytcIiBhbmQgXCIrZStcIiAgZm9yIGRlcHRoVG9TcGFjZSB3aXRoIGlucHV0IHNoYXBlXFxuICAgICAgXCIrci5zaGFwZX0pLGQoYSplPj0wLGZ1bmN0aW9uKCl7cmV0dXJuXCJOZWdhdGl2ZSBkaW1lbnNpb24gc2l6ZSBjYXVzZWQgYnkgb3ZlcmZsb3cgd2hlbiBtdWx0aXBseWluZ1xcbiAgICAgIFwiK2ErXCIgYW5kIFwiK2UrXCIgZm9yIGRlcHRoVG9TcGFjZSB3aXRoIGlucHV0IHNoYXBlXFxuICAgICAgICAgIFwiK3Iuc2hhcGV9KSxkKGklKGUqZSk9PTAsZnVuY3Rpb24oKXtyZXR1cm5cIkRpbWVuc2lvbiBzaXplIG11c3QgYmUgZXZlbmx5IGRpdmlzaWJsZSBieSBcIitlKmUrXCIgYnV0IGlzIFwiK2krXCIgZm9yIGRlcHRoVG9TcGFjZSB3aXRoIGlucHV0IHNoYXBlIFwiK3Iuc2hhcGV9KSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuZGVwdGhUb1NwYWNlKHIsZSxuKX0seyR4OnJ9KX19KSxfcj1Bbih7ZXhwYW5kRGltc186ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0wKTt2YXIgbj13bih0LFwieFwiLFwiZXhwYW5kRGltc1wiKTtkKGU8PW4ucmFuayxmdW5jdGlvbigpe3JldHVyblwiQXhpcyBtdXN0IGJlIDw9IHJhbmsgb2YgdGhlIHRlbnNvclwifSk7dmFyIHI9bi5zaGFwZS5zbGljZSgpO3JldHVybiBlPDAmJihkKC0obi5yYW5rKzEpPD1lLGZ1bmN0aW9uKCl7cmV0dXJuXCJBeGlzIG11c3QgYmUgaW4gdGhlIGludGVydmFsIFtcIistKG4ucmFuaysxKStcIiwgXCIrbi5yYW5rK1wiXVwifSksZT1uLnJhbmsrZSsxKSxyLnNwbGljZShlLDAsMSksSHIobixyKX19KSxNcj1Bbih7ZXllXzpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1cImZsb2F0MzJcIiksbnVsbD09ZSYmKGU9dCk7Zm9yKHZhciBvPU5yKFt0LGVdLHIpLGE9dDw9ZT90OmUsaT0wO2k8YTsrK2kpby5zZXQoMSxpLGkpO3ZhciBzPW8udG9UZW5zb3IoKS5hczJEKHQsZSk7aWYobnVsbD09bilyZXR1cm4gcztpZigxPT09bi5sZW5ndGgpcmV0dXJuIFhyKF9yKHMsMCksW25bMF0sMSwxXSk7aWYoMj09PW4ubGVuZ3RoKXJldHVybiBYcihfcihfcihzLDApLDApLFtuWzBdLG5bMV0sMSwxXSk7aWYoMz09PW4ubGVuZ3RoKXJldHVybiBYcihfcihfcihfcihzLDApLDApLDApLFtuWzBdLG5bMV0sblsyXSwxLDFdKTt0aHJvdyBuZXcgRXJyb3IoXCJleWUoKSBjdXJyZW50bHkgc3VwcG9ydHMgb25seSAxRCBhbmQgMkQgYmF0Y2hTaGFwZXMsIGJ1dCByZWNlaXZlZCBcIituLmxlbmd0aCtcIkQuXCIpfX0pLEZyPUFuKHttdWx0aW5vbWlhbF86ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9ITEpO3ZhciBvPXduKHQsXCJsb2dpdHNcIixcIm11bHRpbm9taWFsXCIpLGE9by5zaXplLGk9by5yYW5rO2lmKGE8Mil0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBtdWx0aW5vbWlhbDogeW91IG5lZWQgYXQgbGVhc3QgMiBvdXRjb21lcywgYnV0IGdvdCBcIithK1wiLlwiKTtpZihpPjIpdGhyb3cgbmV3IEVycm9yKFwiUmFuayBvZiBwcm9iYWJpbGl0aWVzIG11c3QgYmUgMSBvciAyLCBidXQgaXMgXCIraSk7bj1ufHxNYXRoLnJhbmRvbSgpO3ZhciBzPTE9PT1pP28uYXMyRCgxLC0xKTpvLHU9RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm11bHRpbm9taWFsKHMscixlLG4pfSx7bG9naXRzMkQ6c30pO3JldHVybiAxPT09aT91LmFzMUQoKTp1fX0pLEJyPUFuKHtvbmVIb3RfOmZ1bmN0aW9uKHQsZSxuLHIpe2lmKHZvaWQgMD09PW4mJihuPTEpLHZvaWQgMD09PXImJihyPTApLGU8Mil0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBvbmVIb3Q6IGRlcHRoIG11c3QgYmUgPj0yLCBidXQgaXQgaXMgXCIrZSk7dmFyIG89d24odCxcImluZGljZXNcIixcIm9uZUhvdFwiLFwiaW50MzJcIiksYT1vLnNoYXBlLmNvbmNhdChbZV0pO3JldHVybiBvPW8uZmxhdHRlbigpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5vbmVIb3QobyxlLG4scil9LHskaW5kaWNlczpvfSxmdW5jdGlvbih0KXtyZXR1cm57JGluZGljZXM6ZnVuY3Rpb24oKXtyZXR1cm4gcW4oby5zaGFwZSxcImZsb2F0MzJcIil9fX0pLnJlc2hhcGUoYSl9fSksUHI9QW4oe3BhZF86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPTApO3ZhciByPXduKHQsXCJ4XCIsXCJwYWRcIik7aWYoMD09PXIucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJwYWQoc2NhbGFyKSBpcyBub3QgZGVmaW5lZC4gUGFzcyBub24tc2NhbGFyIHRvIHBhZFwiKTt2YXIgbz1lLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdFswXX0pO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQucGFkKHIsZSxuKX0seyR4OnJ9LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LnNsaWNlKG8sci5zaGFwZSl9fX0pfX0pLExyPUFuKHtwYWQxZF86ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0wKSxkKDI9PT1lLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiSW52YWxpZCBudW1iZXIgb2YgcGFkZGluZ3MuIE11c3QgYmUgbGVuZ3RoIG9mIDIuXCJ9KSxQcih0LFtlXSxuKX19KSxXcj1Bbih7cGFkMmRfOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MCksZCgyPT09ZS5sZW5ndGgmJjI9PT1lWzBdLmxlbmd0aCYmMj09PWVbMV0ubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJJbnZhbGlkIG51bWJlciBvZiBwYWRkaW5ncy4gTXVzdCBiZSBsZW5ndGggb2YgMiBlYWNoLlwifSksUHIodCxlLG4pfX0pLFVyPUFuKHtwYWQzZF86ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0wKSxkKDM9PT1lLmxlbmd0aCYmMj09PWVbMF0ubGVuZ3RoJiYyPT09ZVsxXS5sZW5ndGgmJjI9PT1lWzJdLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiSW52YWxpZCBudW1iZXIgb2YgcGFkZGluZ3MuIE11c3QgYmUgbGVuZ3RoIG9mIDIgZWFjaC5cIn0pLFByKHQsZSxuKX19KSx6cj1Bbih7cGFkNGRfOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MCksZCg0PT09ZS5sZW5ndGgmJjI9PT1lWzBdLmxlbmd0aCYmMj09PWVbMV0ubGVuZ3RoJiYyPT09ZVsyXS5sZW5ndGgmJjI9PT1lWzNdLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiSW52YWxpZCBudW1iZXIgb2YgcGFkZGluZ3MuIE11c3QgYmUgbGVuZ3RoIG9mIDIgZWFjaC5cIn0pLFByKHQsZSxuKX19KSxWcj1Bbih7cmFuZF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPXkodCksbz1udWxsO2lmKG51bGw9PW58fFwiZmxvYXQzMlwiPT09bilvPW5ldyBGbG9hdDMyQXJyYXkocik7ZWxzZSBpZihcImludDMyXCI9PT1uKW89bmV3IEludDMyQXJyYXkocik7ZWxzZXtpZihcImJvb2xcIiE9PW4pdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIrbik7bz1uZXcgVWludDhBcnJheShyKX1mb3IodmFyIGE9MDthPHI7YSsrKW9bYV09ZSgpO3JldHVybiBmdC5tYWtlKHQse3ZhbHVlczpvfSxuKX19KSxHcj1Bbih7cmFuZG9tTm9ybWFsXzpmdW5jdGlvbih0LGUsbixyLG8pe2lmKHZvaWQgMD09PWUmJihlPTApLHZvaWQgMD09PW4mJihuPTEpLG51bGwhPXImJlwiYm9vbFwiPT09cil0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkYXRhIHR5cGUgXCIrcik7Zm9yKHZhciBhPW5ldyBScihlLG4sciwhMSxvKSxpPU5yKHQscikscz0wO3M8aS52YWx1ZXMubGVuZ3RoO3MrKylpLnZhbHVlc1tzXT1hLm5leHRWYWx1ZSgpO3JldHVybiBpLnRvVGVuc29yKCl9fSkscXI9QW4oe3JhbmRvbVVuaWZvcm1fOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09ZSYmKGU9MCksdm9pZCAwPT09biYmKG49MSksdm9pZCAwPT09ciYmKHI9XCJmbG9hdDMyXCIpO2Zvcih2YXIgYT1Ocih0LHIpLGk9bmV3IFNyKGUsbixudWxsLG8pLHM9MDtzPGEudmFsdWVzLmxlbmd0aDtzKyspYS52YWx1ZXNbc109aS5uZXh0VmFsdWUoKTtyZXR1cm4gYS50b1RlbnNvcigpfX0pLEhyPUFuKHtyZXNoYXBlXzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJ4XCIsXCJyZXNoYXBlXCIsbnVsbCk7cmV0dXJuIGU9UyhlLG4uc2l6ZSksZChuLnNpemU9PT15KGUpLGZ1bmN0aW9uKCl7cmV0dXJuXCJuZXcgc2hhcGUgYW5kIG9sZCBzaGFwZSBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLlwifSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlc2hhcGUobixlKX0seyR4Om59LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LnJlc2hhcGUobi5zaGFwZSl9fX0pfX0pLCRyPUFuKHtzcGFjZVRvQmF0Y2hORF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPXduKHQsXCJ4XCIsXCJzcGFjZVRvQmF0Y2hORFwiKTtyZXR1cm4gZChyLnJhbms+PTErZS5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cImlucHV0IHJhbmsgXCIrci5yYW5rK1wiIHNob3VsZCBiZSA+IHRoYW4gW2Jsb2NrU2hhcGVdIFwiK2UubGVuZ3RofSksZChuLmxlbmd0aD09PWUubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJwYWRkaW5ncy5zaGFwZVswXSBcIituLmxlbmd0aCtcIiBtdXN0IGJlIGVxdWFsIHRvIFtibG9ja1NoYXBlXSBcIitlLmxlbmd0aH0pLGQoci5zaGFwZS5yZWR1Y2UoZnVuY3Rpb24odCxyLG8pe3JldHVybiBvPjAmJm88PWUubGVuZ3RoP3QmJihyK25bby0xXVswXStuW28tMV1bMV0pJWVbby0xXT09MDp0fSwhMCksZnVuY3Rpb24oKXtyZXR1cm5cImlucHV0IHNwYXRpYWwgZGltZW5zaW9ucyBcIityLnNoYXBlLnNsaWNlKDEpK1wiIHdpdGggcGFkZGluZ3MgXCIrbi50b1N0cmluZygpK1wiIG11c3QgYmUgZGl2aXNpYmxlIGJ5IGJsb2NrU2hhcGVzIFwiK2UudG9TdHJpbmcoKX0pLER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5zcGFjZVRvQmF0Y2hORChyLGUsbil9LHskeDpyfSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5iYXRjaFRvU3BhY2VORChlLG4pfX19KX19KSxqcj1Bbih7c3F1ZWV6ZV86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwieFwiLFwic3F1ZWV6ZVwiKTtyZXR1cm4gSHIobixrKG4uc2hhcGUsZSkubmV3U2hhcGUpfX0pLEtyPUFuKHtzdGFja186ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0wKTt2YXIgbj1ibih0LFwidGVuc29yc1wiLFwic3RhY2tcIik7aWYoZChuLmxlbmd0aD49MSxmdW5jdGlvbigpe3JldHVyblwiUGFzcyBhdCBsZWFzdCBvbmUgdGVuc29yIHRvIHRmLnN0YWNrXCJ9KSwxPT09bi5sZW5ndGgpcmV0dXJuIG5bMF0uZXhwYW5kRGltcyhlKTt2YXIgcj1uWzBdLnJhbmssbz1uWzBdLnNoYXBlLGE9blswXS5kdHlwZTtkKGU8PXIsZnVuY3Rpb24oKXtyZXR1cm5cIkF4aXMgbXVzdCBiZSA8PSByYW5rIG9mIHRoZSB0ZW5zb3JcIn0pLG4uZm9yRWFjaChmdW5jdGlvbih0KXt2KG8sdC5zaGFwZSxcIkFsbCB0ZW5zb3JzIHBhc3NlZCB0byBzdGFjayBtdXN0IGhhdmUgbWF0Y2hpbmcgc2hhcGVzXCIpfSksbi5mb3JFYWNoKGZ1bmN0aW9uKHQpe2QoYT09PXQuZHR5cGUsZnVuY3Rpb24oKXtyZXR1cm5cIkFsbCB0ZW5zb3JzIHBhc3NlZCB0byBzdGFjayBtdXN0IGhhdmUgbWF0Y2hpbmcgZHR5cGVzXCJ9KX0pO3ZhciBpPW4ubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LmV4cGFuZERpbXMoZSl9KTtyZXR1cm4gbHIoaSxlKX19KSxYcj1Bbih7dGlsZV86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwieFwiLFwidGlsZVwiKTtyZXR1cm4gZChuLnJhbms9PT1lLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gdHJhbnNwb3NlOiByYW5rIG9mIGlucHV0IFwiK24ucmFuaytcIiBtdXN0IG1hdGNoIGxlbmd0aCBvZiByZXBzIFwiK2UrXCIuXCJ9KSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxyKXt2YXIgbz10LnRpbGUobixlKTtyZXR1cm4gcihbbl0pLG99LHskeDpufSxmdW5jdGlvbih0LG4pe3ZhciByPW5bMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7dmFyIG49WG4ocik7aWYoMT09PXIucmFuaylmb3IodmFyIG89MDtvPGVbMF07KytvKW49bi5hZGQodC5zbGljZShbbypyLnNoYXBlWzBdXSxbci5zaGFwZVswXV0pKTtlbHNlIGlmKDI9PT1yLnJhbmspZm9yKG89MDtvPGVbMF07KytvKWZvcih2YXIgYT0wO2E8ZVsxXTsrK2Epbj1uLmFkZCh0LnNsaWNlKFtvKnIuc2hhcGVbMF0sYSpyLnNoYXBlWzFdXSxbci5zaGFwZVswXSxyLnNoYXBlWzFdXSkpO2Vsc2UgaWYoMz09PXIucmFuaylmb3Iobz0wO288ZVswXTsrK28pZm9yKGE9MDthPGVbMV07KythKWZvcih2YXIgaT0wO2k8ZVsyXTsrK2kpbj1uLmFkZCh0LnNsaWNlKFtvKnIuc2hhcGVbMF0sYSpyLnNoYXBlWzFdLGkqci5zaGFwZVsyXV0sW3Iuc2hhcGVbMF0sci5zaGFwZVsxXSxyLnNoYXBlWzJdXSkpO2Vsc2V7aWYoNCE9PXIucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJHcmFkaWVudCBmb3IgdGlsZSBvcGVyYXRpb24gaXMgbm90IGltcGxlbWVudGVkIGZvciByYW5rLVwiK3IucmFuaytcIiB0ZW5zb3JzIHlldC5cIik7Zm9yKG89MDtvPGVbMF07KytvKWZvcihhPTA7YTxlWzFdOysrYSlmb3IoaT0wO2k8ZVsyXTsrK2kpZm9yKHZhciBzPTA7czxlWzNdOysrcyluPW4uYWRkKHQuc2xpY2UoW28qci5zaGFwZVswXSxhKnIuc2hhcGVbMV0saSpyLnNoYXBlWzJdLHMqci5zaGFwZVszXV0sW3Iuc2hhcGVbMF0sci5zaGFwZVsxXSxyLnNoYXBlWzJdLHIuc2hhcGVbM11dKSl9cmV0dXJuIG59fX0pfX0pLFlyPUFuKHt0cnVuY2F0ZWROb3JtYWxfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7aWYodm9pZCAwPT09ZSYmKGU9MCksdm9pZCAwPT09biYmKG49MSksbnVsbCE9ciYmXCJib29sXCI9PT1yKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGRhdGEgdHlwZSBcIityKTtmb3IodmFyIGE9bmV3IFJyKGUsbixyLCEwLG8pLGk9TnIodCxyKSxzPTA7czxpLnZhbHVlcy5sZW5ndGg7cysrKWkudmFsdWVzW3NdPWEubmV4dFZhbHVlKCk7cmV0dXJuIGkudG9UZW5zb3IoKX19KSxRcj1Bbih7dW5zdGFja186ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0wKSxlPWV8fDA7dmFyIG49d24odCxcInhcIixcInVuc3RhY2tcIik7cmV0dXJuIGQoZT49LW4uc2hhcGUubGVuZ3RoJiZlPG4uc2hhcGUubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJBeGlzID0gXCIrZStcIiBpcyBub3QgaW4gWy1cIituLnNoYXBlLmxlbmd0aCtcIiwgXCIrbi5zaGFwZS5sZW5ndGgrXCIpXCJ9KSxlPDAmJihlKz1uLnNoYXBlLmxlbmd0aCksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnVuc3RhY2sobixlKX0seyR4Om59LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBLcih0LGUpfX19KX19KSxKcj1mdW5jdGlvbih0LGUpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBuLHIsYSxpLHMsdSxsLGMsaCxwO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obyl7c3dpdGNoKG8ubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbj13bih0LFwieFwiLFwic2V0ZGlmZjFkXCIpLHI9d24oZSxcInlcIixcInNldGRpZmYxZFwiKSxkKG4uZHR5cGU9PT1yLmR0eXBlLGZ1bmN0aW9uKCl7cmV0dXJuXCJ4IGFuZCB5IHNob3VsZCBoYXZlIHRoZSBzYW1lIGR0eXBlLCBidXQgZ290IHggKFwiK24uZHR5cGUrXCIpIGFuZCB5IChcIityLmR0eXBlK1wiKS5cIn0pLGQoMT09PW4ucmFuayxmdW5jdGlvbigpe3JldHVyblwieCBzaG91bGQgYmUgMUQgdGVuc29yLCBidXQgZ290IHggKFwiK24uc2hhcGUrXCIpLlwifSksZCgxPT09ci5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJ5IHNob3VsZCBiZSAxRCB0ZW5zb3IsIGJ1dCBnb3QgeSAoXCIrci5zaGFwZStcIikuXCJ9KSxbNCxuLmRhdGEoKV07Y2FzZSAxOnJldHVybiBhPW8uc2VudCgpLFs0LHIuZGF0YSgpXTtjYXNlIDI6Zm9yKGk9by5zZW50KCkscz1uZXcgU2V0KGkpLHU9MCxoPTA7aDxhLmxlbmd0aDtoKyspcy5oYXMoYVtoXSl8fHUrKztmb3IobD1uZXcgbHQoW3VdLG4uZHR5cGUpLGM9bmV3IGx0KFt1XSxcImludDMyXCIpLGg9MCxwPTA7aDxhLmxlbmd0aDtoKyspcy5oYXMoYVtoXSl8fChsLnZhbHVlc1twXT1hW2hdLGMudmFsdWVzW3BdPWgscCsrKTtyZXR1cm5bMixbbC50b1RlbnNvcigpLGMudG9UZW5zb3IoKV1dfX0pfSl9O2Z1bmN0aW9uIFpyKHQsZSl7Zm9yKHZhciBuPVtdLHI9MDtyPGUubGVuZ3RoO3IrKyllW3JdJiZuLnB1c2gocik7dmFyIG89TnIodCxcImludDMyXCIpLGE9TnIoW24ubGVuZ3RoLHQubGVuZ3RoXSxcImludDMyXCIpO2ZvcihyPTA7cjxuLmxlbmd0aDtyKyspe3ZhciBpPW8uaW5kZXhUb0xvYyhuW3JdKSxzPXIqdC5sZW5ndGg7YS52YWx1ZXMuc2V0KGkscyl9cmV0dXJuIGEudG9UZW5zb3IoKX12YXIgdG89ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlKXt0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnZhcmlhYmxlTmFtZXM9ZS5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm5cIlRcIitlfSk7dmFyIG49W107dGhpcy52YXJpYWJsZU5hbWVzLmZvckVhY2goZnVuY3Rpb24odCl7bi5wdXNoKFwiZmxvYXQgdlwiK3QrXCIgPSBnZXRcIit0K1wiQXRPdXRDb29yZHMoKTtcIil9KTt2YXIgcj10aGlzLnZhcmlhYmxlTmFtZXMubWFwKGZ1bmN0aW9uKHQpe3JldHVyblwidlwiK3R9KS5qb2luKFwiICsgXCIpO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIituLmpvaW4oXCJcXG4gICAgICAgIFwiKStcIlxcblxcbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gXCIrcitcIjtcXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLGVvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLnVzZXNQYWNrZWRUZXh0dXJlcz0hMCx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy52YXJpYWJsZU5hbWVzPWUubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJUXCIrZX0pO3ZhciBuPVtdO3RoaXMudmFyaWFibGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe24ucHVzaChcInZlYzQgdlwiK3QrXCIgPSBnZXRcIit0K1wiQXRPdXRDb29yZHMoKTtcIil9KTt2YXIgcj10aGlzLnZhcmlhYmxlTmFtZXMubWFwKGZ1bmN0aW9uKHQpe3JldHVyblwidlwiK3R9KS5qb2luKFwiICsgXCIpO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIituLmpvaW4oXCJcXG4gICAgICAgIFwiKStcIlxcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSBcIityK1wiO1xcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksbm89ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdO3ZhciByPXQud2luZG93U2l6ZSxvPXQuYmF0Y2hTaXplLGE9dC5pblNpemUsaT1NYXRoLmNlaWwoYS9yKTtufHx0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcImJlc3RJbmRpY2VzQVwiKSx0aGlzLm91dHB1dFNoYXBlPVtvLGldO3ZhciBzPVwibWF4XCI9PT1lP1wiPlwiOlwiPFwiLHU9bj9cImluT2Zmc2V0ICsgaTtcIjpcInJvdW5kKGdldEJlc3RJbmRpY2VzQShiYXRjaCwgaW5PZmZzZXQgKyBpKSk7XCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IG91dElkeCA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBpbk9mZnNldCA9IG91dElkeCAqIFwiK3IrXCI7XFxuXFxuICAgICAgICBpbnQgYmVzdEluZGV4ID0gaW5PZmZzZXQ7XFxuICAgICAgICBmbG9hdCBiZXN0VmFsdWUgPSBnZXRBKGJhdGNoLCBiZXN0SW5kZXgpO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIityK1wiOyBpKyspIHtcXG4gICAgICAgICAgaW50IGluSWR4ID0gXCIrdStcIjtcXG4gICAgICAgICAgZmxvYXQgY2FuZGlkYXRlID0gZ2V0QShiYXRjaCwgaW5JZHgpO1xcbiAgICAgICAgICBpZiAoY2FuZGlkYXRlIFwiK3MrXCIgYmVzdFZhbHVlKSB7XFxuICAgICAgICAgICAgYmVzdFZhbHVlID0gY2FuZGlkYXRlO1xcbiAgICAgICAgICAgIGJlc3RJbmRleCA9IGluSWR4O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQoYmVzdEluZGV4KSk7XFxuICAgICAgfVxcbiAgICBcIn19KCk7ZnVuY3Rpb24gcm8odCxlKXtyZXR1cm5bXCJ4XCIsXCJ5XCIsXCJ6XCIsXCJ3XCIsXCJ1XCIsXCJ2XCJdLnNsaWNlKDAsZSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiB0K1wiLlwiK2V9KX1mdW5jdGlvbiBvbyh0LGUpe3JldHVybiAxPT09ZT9bdF06cm8odCxlKX1mdW5jdGlvbiBhbyh0LGUpe2Zvcih2YXIgbj10Lmxlbmd0aCxyPVtdLG89MDtvPG47bysrKXt2YXIgYT1uLTEtbyxpPXRbYV18fDE7KGVbZS5sZW5ndGgtMS1vXXx8MSk+MSYmMT09PWkmJnIudW5zaGlmdChhKX1yZXR1cm4gcn1mdW5jdGlvbiBpbyh0LGUpe2Zvcih2YXIgbj1bXSxyPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBvPXRbdC5sZW5ndGgtci0xXSxhPWUubGVuZ3RoLXItMSxpPWVbYV07KG51bGw9PW98fDE9PT1vJiZpPjEpJiZuLnVuc2hpZnQoYSl9cmV0dXJuIG59ZnVuY3Rpb24gc28odCxlKXtmb3IodmFyIG49W10scj1NYXRoLm1heCh0Lmxlbmd0aCxlLmxlbmd0aCksbz0wO288cjtvKyspe3ZhciBhPXRbdC5sZW5ndGgtby0xXTtudWxsPT1hJiYoYT0xKTt2YXIgaT1lW2UubGVuZ3RoLW8tMV07aWYobnVsbD09aSYmKGk9MSksMT09PWEpbi51bnNoaWZ0KGkpO2Vsc2UgaWYoMT09PWkpbi51bnNoaWZ0KGEpO2Vsc2V7aWYoYSE9PWkpdGhyb3cgRXJyb3IoXCJPcGVyYW5kcyBjb3VsZCBub3QgYmUgYnJvYWRjYXN0IHRvZ2V0aGVyIHdpdGggc2hhcGVzIFwiK3QrXCIgYW5kIFwiK2UrXCIuXCIpO24udW5zaGlmdChhKX19cmV0dXJuIG59ZnVuY3Rpb24gdW8oKXt2YXIgdCxlLG4scixvLGkscyx1LGwsYztyZXR1cm4gMj09PWEuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKT8odD1cIiN2ZXJzaW9uIDMwMCBlc1wiLGU9XCJpblwiLG49XCJvdXRcIixyPVwiaW5cIixvPVwidGV4dHVyZVwiLGk9XCJvdXRwdXRDb2xvclwiLHM9XCJvdXQgdmVjNCBvdXRwdXRDb2xvcjtcIix1PVwiXFxuICAgICAgYm9vbCBpc25hbl9jdXN0b20oZmxvYXQgdmFsKSB7XFxuICAgICAgICByZXR1cm4gKHZhbCA+IDAuIHx8IHZhbCA8IDAuIHx8IHZhbCA9PSAwLikgPyBmYWxzZSA6IHRydWU7XFxuICAgICAgfVxcbiAgICBcIixsPVwiXFxuICAgICAgY29uc3QgZmxvYXQgSU5GSU5JVFkgPSB1aW50Qml0c1RvRmxvYXQodWludCgweDdmODAwMDAwKSk7XFxuICAgIFwiLGM9XCJcXG4gICAgICAjZGVmaW5lIHJvdW5kKHZhbHVlKSBuZXdSb3VuZCh2YWx1ZSlcXG4gICAgICBpbnQgbmV3Um91bmQoZmxvYXQgdmFsdWUpIHtcXG4gICAgICAgIHJldHVybiBpbnQoZmxvb3IodmFsdWUgKyAwLjUpKTtcXG4gICAgICB9XFxuXFxuICAgICAgaXZlYzQgbmV3Um91bmQodmVjNCB2YWx1ZSkge1xcbiAgICAgICAgcmV0dXJuIGl2ZWM0KGZsb29yKHZhbHVlICsgdmVjNCgwLjUpKSk7XFxuICAgICAgfVxcbiAgICBcIik6KHQ9XCJcIixlPVwiYXR0cmlidXRlXCIsbj1cInZhcnlpbmdcIixyPVwidmFyeWluZ1wiLG89XCJ0ZXh0dXJlMkRcIixpPVwiZ2xfRnJhZ0NvbG9yXCIscz1cIlwiLHU9XCJcXG4gICAgICBib29sIGlzbmFuX2N1c3RvbShmbG9hdCB2YWwpIHtcXG4gICAgICAgIHJldHVybiAodmFsID4gMC4gfHwgdmFsIDwgMS4gfHwgdmFsID09IDAuKSA/IGZhbHNlIDogdHJ1ZTtcXG4gICAgICB9XFxuICAgIFwiLGw9XCJcXG4gICAgICB1bmlmb3JtIGZsb2F0IElORklOSVRZO1xcblxcbiAgICAgIGJvb2wgaXNpbmYoZmxvYXQgdmFsKSB7XFxuICAgICAgICByZXR1cm4gYWJzKHZhbCkgPT0gSU5GSU5JVFk7XFxuICAgICAgfVxcbiAgICAgIGJ2ZWM0IGlzaW5mKHZlYzQgdmFsKSB7XFxuICAgICAgICByZXR1cm4gZXF1YWwoYWJzKHZhbCksIHZlYzQoSU5GSU5JVFkpKTtcXG4gICAgICB9XFxuICAgIFwiLGM9XCJcXG4gICAgICBpbnQgcm91bmQoZmxvYXQgdmFsdWUpIHtcXG4gICAgICAgIHJldHVybiBpbnQoZmxvb3IodmFsdWUgKyAwLjUpKTtcXG4gICAgICB9XFxuXFxuICAgICAgaXZlYzQgcm91bmQodmVjNCB2YWx1ZSkge1xcbiAgICAgICAgcmV0dXJuIGl2ZWM0KGZsb29yKHZhbHVlICsgdmVjNCgwLjUpKSk7XFxuICAgICAgfVxcbiAgICBcIikse3ZlcnNpb246dCxhdHRyaWJ1dGU6ZSx2YXJ5aW5nVnM6bix2YXJ5aW5nRnM6cix0ZXh0dXJlMkQ6byxvdXRwdXQ6aSxkZWZpbmVPdXRwdXQ6cyxkZWZpbmVTcGVjaWFsTmFOOnUsZGVmaW5lU3BlY2lhbEluZjpsLGRlZmluZVJvdW5kOmN9fWZ1bmN0aW9uIGxvKHQsZSxuKXt2b2lkIDA9PT1uJiYobj1cImluZGV4XCIpO3ZhciByPVYoZSk7cmV0dXJuIHIubWFwKGZ1bmN0aW9uKGUsbyl7cmV0dXJuXCJpbnQgXCIrdFtvXStcIiA9IFwiK24rXCIgLyBcIitlK1wiOyBcIisobz09PXIubGVuZ3RoLTE/XCJpbnQgXCIrdFtvKzFdK1wiID0gXCIrbitcIiAtIFwiK3Rbb10rXCIgKiBcIitlOlwiaW5kZXggLT0gXCIrdFtvXStcIiAqIFwiK2UpK1wiO1wifSkuam9pbihcIlwiKX1mdW5jdGlvbiBjbyh0KXtyZXR1cm4gMT09PXQubGVuZ3RoP1wiXCIrdFswXTpcInZlY1wiK3QubGVuZ3RoK1wiKFwiK3Quam9pbihcIixcIikrXCIpXCJ9ZnVuY3Rpb24gaG8odCxlLG4scil7dmFyIG89W107dC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBlPXkodC5zaGFwZUluZm8ubG9naWNhbFNoYXBlKTt0LnNoYXBlSW5mby5pc1VuaWZvcm0/by5wdXNoKFwidW5pZm9ybSBmbG9hdCBcIit0Lm5hbWUrKGU+MT9cIltcIitlK1wiXVwiOlwiXCIpK1wiO1wiKTooby5wdXNoKFwidW5pZm9ybSBzYW1wbGVyMkQgXCIrdC5uYW1lK1wiO1wiKSxvLnB1c2goXCJ1bmlmb3JtIGludCBvZmZzZXRcIit0Lm5hbWUrXCI7XCIpKX0pO3ZhciBhLGkscz1vLmpvaW4oXCJcXG5cIiksdT10Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPSExKTt2YXIgcj1cIlwiO3IrPW4/Zm8odCk6cG8odCk7dmFyIG89dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLGE9ZS5sb2dpY2FsU2hhcGU7by5sZW5ndGg8PWEubGVuZ3RoJiYocis9bj9mdW5jdGlvbih0LGUpe3ZhciBuLHI9dC5uYW1lLG89ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStyLnNsaWNlKDEpLGE9XCJnZXRcIitvK1wiQXRPdXRDb29yZHNcIixpPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5sZW5ndGgscz1lLmxvZ2ljYWxTaGFwZS5sZW5ndGgsdT1hbyh0LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsZS5sb2dpY2FsU2hhcGUpLGw9Ym8ocyksYz1zLWksaD1bXCJ4XCIsXCJ5XCIsXCJ6XCIsXCJ3XCIsXCJ1XCIsXCJ2XCJdO249MD09PWk/XCJcIjpzPDImJnUubGVuZ3RoPj0xP1wiY29vcmRzID0gMDtcIjp1Lm1hcChmdW5jdGlvbih0KXtyZXR1cm5cImNvb3Jkcy5cIitoW3QrY10rXCIgPSAwO1wifSkuam9pbihcIlxcblwiKTt2YXIgcD1cIlwiO3A9czwyJiZpPjA/XCJjb29yZHNcIjp0LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJjb29yZHMuXCIraFtlK2NdfSkuam9pbihcIiwgXCIpO3ZhciBmPVwicmV0dXJuIG91dHB1dFZhbHVlO1wiLGQ9MT09PXkodC5zaGFwZUluZm8ubG9naWNhbFNoYXBlKSx2PTE9PT15KGUubG9naWNhbFNoYXBlKTtpZigxIT09aXx8ZHx8dil7aWYoZCYmIXYpZj0xPT09cz9cIlxcbiAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueCwgMC4sIDAuKTtcXG4gICAgICBcIjpcIlxcbiAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCk7XFxuICAgICAgXCI7ZWxzZSBpZih1Lmxlbmd0aCl7dmFyIG09aS0yLGc9aS0xO3UuaW5kZXhPZihtKT4tMSYmdS5pbmRleE9mKGcpPi0xP2Y9XCJyZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54KTtcIjp1LmluZGV4T2YobSk+LTE/Zj1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngsIG91dHB1dFZhbHVlLnksIG91dHB1dFZhbHVlLngsIG91dHB1dFZhbHVlLnkpO1wiOnUuaW5kZXhPZihnKT4tMSYmKGY9XCJyZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54eCwgb3V0cHV0VmFsdWUuenopO1wiKX19ZWxzZSBmPVwiXFxuICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueHksIG91dHB1dFZhbHVlLnh5KTtcXG4gICAgXCI7cmV0dXJuXCJcXG4gICAgdmVjNCBcIithK1wiKCkge1xcbiAgICAgIFwiK2wrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgXCIrbitcIlxcbiAgICAgIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRcIitvK1wiKFwiK3ArXCIpO1xcbiAgICAgIFwiK2YrXCJcXG4gICAgfVxcbiAgXCJ9KHQsZSk6ZnVuY3Rpb24odCxlKXt2YXIgbj10Lm5hbWUscj1uLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSksbz1cImdldFwiK3IrXCJBdE91dENvb3Jkc1wiLGE9ZS50ZXhTaGFwZSxpPXQuc2hhcGVJbmZvLnRleFNoYXBlLHM9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aCx1PWUubG9naWNhbFNoYXBlLmxlbmd0aDtpZighdC5zaGFwZUluZm8uaXNVbmlmb3JtJiZzPT09dSYmbnVsbD09dC5zaGFwZUluZm8uZmxhdE9mZnNldCYmeChpLGEpKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrbytcIigpIHtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHJlc3VsdFVWKTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciBsLGM9Ym8odSksaD1hbyh0LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsZS5sb2dpY2FsU2hhcGUpLHA9dS1zLGY9W1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXTtsPTA9PT1zP1wiXCI6dTwyJiZoLmxlbmd0aD49MT9cImNvb3JkcyA9IDA7XCI6aC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJjb29yZHMuXCIrZlt0K3BdK1wiID0gMDtcIn0pLmpvaW4oXCJcXG5cIik7dmFyIGQ9XCJcIjtkPXU8MiYmcz4wP1wiY29vcmRzXCI6dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLm1hcChmdW5jdGlvbih0LGUpe3JldHVyblwiY29vcmRzLlwiK2ZbZStwXX0pLmpvaW4oXCIsIFwiKTtyZXR1cm5cIlxcbiAgICBmbG9hdCBcIitvK1wiKCkge1xcbiAgICAgIFwiK2MrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgXCIrbCtcIlxcbiAgICAgIHJldHVybiBnZXRcIityK1wiKFwiK2QrXCIpO1xcbiAgICB9XFxuICBcIn0odCxlKSk7cmV0dXJuIHJ9KHQsZSxyKX0pLmpvaW4oXCJcXG5cIiksbD1lLnRleFNoYXBlLGM9dW8oKSxoPWZ1bmN0aW9uKHQpe3JldHVyblwiXFxuICAgIGZsb2F0IHNhbXBsZVRleHR1cmUoc2FtcGxlcjJEIHRleHR1cmVTYW1wbGVyLCB2ZWMyIHV2KSB7XFxuICAgICAgcmV0dXJuIFwiK3QudGV4dHVyZTJEK1wiKHRleHR1cmVTYW1wbGVyLCB1dikucjtcXG4gICAgfVxcbiAgXCJ9KGMpLHA9ZnVuY3Rpb24odCl7cmV0dXJuIHQudmVyc2lvbitcIlxcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgIHByZWNpc2lvbiBoaWdocCBpbnQ7XFxuICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XFxuICAgIFwiK3QudmFyeWluZ0ZzK1wiIHZlYzIgcmVzdWx0VVY7XFxuICAgIFwiK3QuZGVmaW5lT3V0cHV0K1wiXFxuICAgIGNvbnN0IHZlYzIgaGFsZkNSID0gdmVjMigwLjUsIDAuNSk7XFxuXFxuICAgIHN0cnVjdCBpdmVjNVxcbiAgICB7XFxuICAgICAgaW50IHg7XFxuICAgICAgaW50IHk7XFxuICAgICAgaW50IHo7XFxuICAgICAgaW50IHc7XFxuICAgICAgaW50IHU7XFxuICAgIH07XFxuXFxuICAgIHN0cnVjdCBpdmVjNlxcbiAgICB7XFxuICAgICAgaW50IHg7XFxuICAgICAgaW50IHk7XFxuICAgICAgaW50IHo7XFxuICAgICAgaW50IHc7XFxuICAgICAgaW50IHU7XFxuICAgICAgaW50IHY7XFxuICAgIH07XFxuXFxuICAgIHVuaWZvcm0gZmxvYXQgTkFOO1xcbiAgICAjZGVmaW5lIGlzbmFuKHZhbHVlKSBpc25hbl9jdXN0b20odmFsdWUpXFxuICAgIFwiK3QuZGVmaW5lU3BlY2lhbE5hTitcIlxcbiAgICBidmVjNCBpc25hbl9jdXN0b20odmVjNCB2YWwpIHtcXG4gICAgICByZXR1cm4gYnZlYzQoaXNuYW4odmFsLngpLCBpc25hbih2YWwueSksIGlzbmFuKHZhbC56KSwgaXNuYW4odmFsLncpKTtcXG4gICAgfVxcblxcbiAgICBcIit0LmRlZmluZVNwZWNpYWxJbmYrXCJcXG4gICAgXCIrdC5kZWZpbmVSb3VuZCtcIlxcblxcbiAgICBpbnQgaW1vZChpbnQgeCwgaW50IHkpIHtcXG4gICAgICByZXR1cm4geCAtIHkgKiAoeCAvIHkpO1xcbiAgICB9XFxuXFxuICAgIGludCBpZGl2KGludCBhLCBpbnQgYiwgZmxvYXQgc2lnbikge1xcbiAgICAgIGludCByZXMgPSBhIC8gYjtcXG4gICAgICBpbnQgbW9kID0gaW1vZChhLCBiKTtcXG4gICAgICBpZiAoc2lnbiA8IDAuICYmIG1vZCAhPSAwKSB7XFxuICAgICAgICByZXMgLT0gMTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHJlcztcXG4gICAgfVxcblxcbiAgICAvL0Jhc2VkIG9uIHRoZSB3b3JrIG9mIERhdmUgSG9za2luc1xcbiAgICAvL2h0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy80ZGpTUldcXG4gICAgI2RlZmluZSBIQVNIU0NBTEUxIDQ0My44OTc1XFxuICAgIGZsb2F0IHJhbmRvbShmbG9hdCBzZWVkKXtcXG4gICAgICB2ZWMyIHAgPSByZXN1bHRVViAqIHNlZWQ7XFxuICAgICAgdmVjMyBwMyAgPSBmcmFjdCh2ZWMzKHAueHl4KSAqIEhBU0hTQ0FMRTEpO1xcbiAgICAgIHAzICs9IGRvdChwMywgcDMueXp4ICsgMTkuMTkpO1xcbiAgICAgIHJldHVybiBmcmFjdCgocDMueCArIHAzLnkpICogcDMueik7XFxuICAgIH1cXG5cXG4gICAgXCIrdm8rXCJcXG4gICAgXCIrbW8rXCJcXG4gICAgXCIrZ28rXCJcXG4gIFwifShjKTtyZXR1cm4gZS5pc1BhY2tlZD8oYT1mdW5jdGlvbih0LGUpe3N3aXRjaCh0Lmxlbmd0aCl7Y2FzZSAwOnJldHVyblwiXFxuICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgcmV0dXJuIDA7XFxuICAgIH1cXG4gIFwiO2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24odCxlKXt2YXIgbj1bTWF0aC5jZWlsKGVbMF0vMiksTWF0aC5jZWlsKGVbMV0vMildO2lmKDE9PT1uWzBdKXJldHVyblwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiAyICogaW50KHJlc3VsdFVWLnggKiBcIituWzFdK1wiLjApO1xcbiAgICAgIH1cXG4gICAgXCI7aWYoMT09PW5bMV0pcmV0dXJuXCJcXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIDIgKiBpbnQocmVzdWx0VVYueSAqIFwiK25bMF0rXCIuMCk7XFxuICAgICAgfVxcbiAgICBcIjtyZXR1cm5cIlxcbiAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIituWzBdK1wiLCBcIituWzFdK1wiKSk7XFxuICAgICAgcmV0dXJuIHJlc1RleFJDLnggKiBcIituWzFdK1wiICsgcmVzVGV4UkMueTtcXG4gICAgfVxcbiAgXCJ9KDAsZSk7Y2FzZSAyOnJldHVybiBmdW5jdGlvbih0LGUpe3ZhciBuPVtNYXRoLmNlaWwoZVswXS8yKSxNYXRoLmNlaWwoZVsxXS8yKV07aWYoeCh0LGUpKXJldHVyblwiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIDIgKiBpdmVjMihyZXN1bHRVVi55eCAqIHZlYzIoXCIrblswXStcIiwgXCIrblsxXStcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIHI9TWF0aC5jZWlsKHRbMV0vMik7cmV0dXJuXCJcXG4gICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIituWzBdK1wiLCBcIituWzFdK1wiKSk7XFxuXFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK25bMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIGludCByID0gMiAqIChpbmRleCAvIFwiK3IrXCIpO1xcbiAgICAgIGludCBjID0gaW1vZChpbmRleCwgXCIrcitcIikgKiAyO1xcblxcbiAgICAgIHJldHVybiBpdmVjMihyLCBjKTtcXG4gICAgfVxcbiAgXCJ9KHQsZSk7Y2FzZSAzOnJldHVybiBuPXQscj1lLG89W01hdGguY2VpbChyWzBdLzIpLE1hdGguY2VpbChyWzFdLzIpXSxhPU1hdGguY2VpbChuWzJdLzIpLGk9YSpNYXRoLmNlaWwoblsxXS8yKSxcIlxcbiAgICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK29bMF0rXCIsIFwiK29bMV0rXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrb1sxXStcIiArIHJlc1RleFJDLnk7XFxuXFxuICAgICAgaW50IGIgPSBpbmRleCAvIFwiK2krXCI7XFxuICAgICAgaW5kZXggLT0gYiAqIFwiK2krXCI7XFxuXFxuICAgICAgaW50IHIgPSAyICogKGluZGV4IC8gXCIrYStcIik7XFxuICAgICAgaW50IGMgPSBpbW9kKGluZGV4LCBcIithK1wiKSAqIDI7XFxuXFxuICAgICAgcmV0dXJuIGl2ZWMzKGIsIHIsIGMpO1xcbiAgICB9XFxuICBcIjtkZWZhdWx0OnJldHVybiBmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1bTWF0aC5jZWlsKGVbMF0vMiksTWF0aC5jZWlsKGVbMV0vMildLHI9TWF0aC5jZWlsKHRbdC5sZW5ndGgtMV0vMiksbz1yKk1hdGguY2VpbCh0W3QubGVuZ3RoLTJdLzIpLGE9byxpPVwiXCIscz1cImIsIHIsIGNcIix1PTI7dTx0Lmxlbmd0aC0xO3UrKylhKj10W3QubGVuZ3RoLXUtMV0saT1cIlxcbiAgICAgIGludCBiXCIrdStcIiA9IGluZGV4IC8gXCIrYStcIjtcXG4gICAgICBpbmRleCAtPSBiXCIrdStcIiAqIFwiK2ErXCI7XFxuICAgIFwiK2kscz1cImJcIit1K1wiLCBcIitzO3JldHVyblwiXFxuICAgIGl2ZWNcIit0Lmxlbmd0aCtcIiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK25bMF0rXCIsIFwiK25bMV0rXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrblsxXStcIiArIHJlc1RleFJDLnk7XFxuXFxuICAgICAgXCIraStcIlxcblxcbiAgICAgIGludCBiID0gaW5kZXggLyBcIitvK1wiO1xcbiAgICAgIGluZGV4IC09IGIgKiBcIitvK1wiO1xcblxcbiAgICAgIGludCByID0gMiAqIChpbmRleCAvIFwiK3IrXCIpO1xcbiAgICAgIGludCBjID0gaW1vZChpbmRleCwgXCIrcitcIikgKiAyO1xcblxcbiAgICAgIHJldHVybiBpdmVjXCIrdC5sZW5ndGgrXCIoXCIrcytcIik7XFxuICAgIH1cXG4gIFwifSh0LGUpfXZhciBuLHIsbyxhLGl9KGUubG9naWNhbFNoYXBlLGwpLGk9ZnVuY3Rpb24odCl7cmV0dXJuXCJcXG4gICAgdm9pZCBzZXRPdXRwdXQodmVjNCB2YWwpIHtcXG4gICAgICBcIit0Lm91dHB1dCtcIiA9IHZhbDtcXG4gICAgfVxcbiAgXCJ9KGMpKTooYT1mdW5jdGlvbih0LGUpe3N3aXRjaCh0Lmxlbmd0aCl7Y2FzZSAwOnJldHVyblwiXFxuICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgcmV0dXJuIDA7XFxuICAgIH1cXG4gIFwiO2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24odCxlKXtpZigxPT09ZVswXSlyZXR1cm5cIlxcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gaW50KHJlc3VsdFVWLnggKiBcIitlWzFdK1wiLjApO1xcbiAgICAgIH1cXG4gICAgXCI7aWYoMT09PWVbMV0pcmV0dXJuXCJcXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIGludChyZXN1bHRVVi55ICogXCIrZVswXStcIi4wKTtcXG4gICAgICB9XFxuICAgIFwiO3JldHVyblwiXFxuICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICByZXR1cm4gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICB9XFxuICBcIn0oMCxlKTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7aWYoeCh0LGUpKXJldHVyblwiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIGl2ZWMyKHJlc3VsdFVWLnl4ICogdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIjtpZigxPT09dFsxXSlyZXR1cm5cIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIitlWzFdK1wiICsgcmVzVGV4UkMueTtcXG4gICAgICAgIHJldHVybiBpdmVjMihpbmRleCwgMCk7XFxuICAgICAgfVxcbiAgICBcIjtpZigxPT09dFswXSlyZXR1cm5cIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIitlWzFdK1wiICsgcmVzVGV4UkMueTtcXG4gICAgICAgIHJldHVybiBpdmVjMigwLCBpbmRleCk7XFxuICAgICAgfVxcbiAgICBcIjtyZXR1cm5cIlxcbiAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrZVsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgICAgaW50IHIgPSBpbmRleCAvIFwiK3RbMV0rXCI7XFxuICAgICAgaW50IGMgPSBpbmRleCAtIHIgKiBcIit0WzFdK1wiO1xcbiAgICAgIHJldHVybiBpdmVjMihyLCBjKTtcXG4gICAgfVxcbiAgXCJ9KHQsZSk7Y2FzZSAzOnJldHVybiBuPWUscj1sbyhbXCJyXCIsXCJjXCIsXCJkXCJdLHQpLFwiXFxuICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrblswXStcIiwgXCIrblsxXStcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIituWzFdK1wiICsgcmVzVGV4UkMueTtcXG4gICAgICBcIityK1wiXFxuICAgICAgcmV0dXJuIGl2ZWMzKHIsIGMsIGQpO1xcbiAgICB9XFxuICBcIjtjYXNlIDQ6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIG49bG8oW1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIl0sdCk7cmV0dXJuXCJcXG4gICAgaXZlYzQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIFwiK24rXCJcXG4gICAgICByZXR1cm4gaXZlYzQociwgYywgZCwgZDIpO1xcbiAgICB9XFxuICBcIn0odCxlKTtjYXNlIDU6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIG49bG8oW1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIixcImQzXCJdLHQpO3JldHVyblwiXFxuICAgIGl2ZWM1IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICogdmVjMihcIitlWzBdK1wiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIrZVsxXStcIikpO1xcblxcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIitlWzFdK1wiICsgcmVzVGV4UkMueTtcXG5cXG4gICAgICBcIituK1wiXFxuXFxuICAgICAgaXZlYzUgb3V0U2hhcGUgPSBpdmVjNShyLCBjLCBkLCBkMiwgZDMpO1xcbiAgICAgIHJldHVybiBvdXRTaGFwZTtcXG4gICAgfVxcbiAgXCJ9KHQsZSk7Y2FzZSA2OnJldHVybiBmdW5jdGlvbih0LGUpe3ZhciBuPWxvKFtcInJcIixcImNcIixcImRcIixcImQyXCIsXCJkM1wiLFwiZDRcIl0sdCk7cmV0dXJuXCJcXG4gICAgaXZlYzYgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcblxcbiAgICAgIFwiK24rXCJcXG5cXG4gICAgICBpdmVjNiByZXN1bHQgPSBpdmVjNihyLCBjLCBkLCBkMiwgZDMsIGQ0KTtcXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuICBcIn0odCxlKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcih0Lmxlbmd0aCtcIi1EIG91dHB1dCBzYW1wbGluZyBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX12YXIgbixyfShlLmxvZ2ljYWxTaGFwZSxsKSxpPWZ1bmN0aW9uKHQpe3JldHVyblwiXFxuICAgIHZvaWQgc2V0T3V0cHV0KGZsb2F0IHZhbCkge1xcbiAgICAgIFwiK3Qub3V0cHV0K1wiID0gdmVjNCh2YWwsIDAsIDAsIDApO1xcbiAgICB9XFxuICBcIn0oYykpLHImJihwKz15byksW3AsaCxpLHMsYSx1LG5dLmpvaW4oXCJcXG5cIil9ZnVuY3Rpb24gcG8odCl7dmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlO3N3aXRjaChlLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10Lm5hbWUsbj1cImdldFwiK2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKTtpZih0LnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuXCJmbG9hdCBcIituK1wiKCkge3JldHVybiBcIitlK1wiO31cIjt2YXIgcj10LnNoYXBlSW5mby50ZXhTaGFwZSxvPXJbMF0sYT1yWzFdO2lmKDE9PT1vJiYxPT09YSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK24rXCIoKSB7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIitlK1wiLCBoYWxmQ1IpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIGk9dC5zaGFwZUluZm8udGV4U2hhcGUscz1pWzBdLHU9aVsxXSxsPXhvKGUpO3JldHVyblwiXFxuICAgIGZsb2F0IFwiK24rXCIoKSB7XFxuICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoXCIrcytcIiwgXCIrdStcIiwgXCIrbCtcIik7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrZStcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCk7Y2FzZSAxOnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10Lm5hbWUsbj1cImdldFwiK2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKTtpZih0LnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIituK1wiKGludCBpbmRleCkge1xcbiAgICAgICAgXCIrd28odCkrXCJcXG4gICAgICB9XFxuICAgIFwiO3ZhciByPXQuc2hhcGVJbmZvLnRleFNoYXBlLG89clswXSxhPXJbMV07aWYoMT09PWEmJjE9PT1vKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrbitcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK2UrXCIsIGhhbGZDUik7XFxuICAgICAgfVxcbiAgICBcIjt2YXIgaT14byhlKTtpZigxPT09YSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK24rXCIoaW50IGluZGV4KSB7XFxuICAgICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChmbG9hdChpbmRleCArIFwiK2krXCIpICsgMC41KSAvIFwiK28rXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIitlK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtpZigxPT09bylyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK24rXCIoaW50IGluZGV4KSB7XFxuICAgICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXggKyBcIitpK1wiKSArIDAuNSkgLyBcIithK1wiLjAsIDAuNSk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIitlK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtyZXR1cm5cIlxcbiAgICBmbG9hdCBcIituK1wiKGludCBpbmRleCkge1xcbiAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KFwiK28rXCIsIFwiK2ErXCIsIGluZGV4ICsgXCIraStcIik7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrZStcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCk7Y2FzZSAyOnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsbj10Lm5hbWUscj1cImdldFwiK24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxvPXQuc2hhcGVJbmZvLnRleFNoYXBlO2lmKG51bGwhPW8mJngoZSxvKSl7dmFyIGE9b1swXSxpPW9bMV07cmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKFwiK2krXCIuMCwgXCIrYStcIi4wKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifXZhciBzPWsoZSksdT1zLm5ld1NoYXBlLGw9cy5rZXB0RGltcyxjPXU7aWYoYy5sZW5ndGg8ZS5sZW5ndGgpe3ZhciBoPUNvKHQsYyk7cmV0dXJuXCJcXG4gICAgICBcIitwbyhoKStcIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgcmV0dXJuIFwiK3IrXCIoXCIrRW8oW1wicm93XCIsXCJjb2xcIl0sbCkrXCIpO1xcbiAgICAgIH1cXG4gICAgXCJ9aWYodC5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICBpbnQgaW5kZXggPSByb3VuZChkb3QodmVjMihyb3csIGNvbCksIHZlYzIoXCIrZVsxXStcIiwgMSkpKTtcXG4gICAgICAgIFwiK3dvKHQpK1wiXFxuICAgICAgfVxcbiAgICBcIjt2YXIgcD1vWzBdLGY9b1sxXSxkPXhvKG4pO2lmKDE9PT1mKXJldHVyblwiXFxuICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIGZsb2F0IGluZGV4ID0gZG90KHZlYzMocm93LCBjb2wsIFwiK2QrXCIpLCB2ZWMzKFwiK2VbMV0rXCIsIDEsIDEpKTtcXG4gICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChpbmRleCArIDAuNSkgLyBcIitwK1wiLjApO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7aWYoMT09PXApcmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgXCIrZCtcIiksIHZlYzMoXCIrZVsxXStcIiwgMSwgMSkpO1xcbiAgICAgIHZlYzIgdXYgPSB2ZWMyKChpbmRleCArIDAuNSkgLyBcIitmK1wiLjAsIDAuNSk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtyZXR1cm5cIlxcbiAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gICAgaW50IGluZGV4ID0gcm93ICogXCIrZVsxXStcIiArIGNvbCArIFwiK2QrXCI7XFxuICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KFwiK3ArXCIsIFwiK2YrXCIsIGluZGV4KTtcXG4gICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgfVxcblwifSh0KTtjYXNlIDM6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxuPXQubmFtZSxyPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLG89ZVsxXSplWzJdLGE9ZVsyXSxpPWsoZSkscz1pLm5ld1NoYXBlLHU9aS5rZXB0RGltcyxsPXM7aWYobC5sZW5ndGg8ZS5sZW5ndGgpe3ZhciBjPUNvKHQsbCk7cmV0dXJuXCJcXG4gICAgICAgIFwiK3BvKGMpK1wiXFxuICAgICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgICByZXR1cm4gXCIrcitcIihcIitFbyhbXCJyb3dcIixcImNvbFwiLFwiZGVwdGhcIl0sdSkrXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIFwifWlmKHQuc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICBpbnQgaW5kZXggPSByb3VuZChkb3QodmVjMyhyb3csIGNvbCwgZGVwdGgpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMyhcIitvK1wiLCBcIithK1wiLCAxKSkpO1xcbiAgICAgICAgXCIrd28odCkrXCJcXG4gICAgICB9XFxuICAgIFwiO3ZhciBoPXQuc2hhcGVJbmZvLnRleFNoYXBlLHA9aFswXSxmPWhbMV0sZD10LnNoYXBlSW5mby5mbGF0T2Zmc2V0O2lmKGY9PT1vJiZudWxsPT1kKXJldHVyblwiXFxuICAgICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgICBmbG9hdCB0ZXhSID0gZmxvYXQocm93KTtcXG4gICAgICAgICAgZmxvYXQgdGV4QyA9IGRvdCh2ZWMyKGNvbCwgZGVwdGgpLCB2ZWMyKFwiK2ErXCIsIDEpKTtcXG4gICAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgICAgdmVjMihcIitmK1wiLjAsIFwiK3ArXCIuMCk7XFxuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtpZihmPT09YSYmbnVsbD09ZClyZXR1cm5cIlxcbiAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgIGZsb2F0IHRleFIgPSBkb3QodmVjMihyb3csIGNvbCksIHZlYzIoXCIrZVsxXStcIiwgMSkpO1xcbiAgICAgIGZsb2F0IHRleEMgPSBmbG9hdChkZXB0aCk7XFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoXCIrZitcIi4wLCBcIitwK1wiLjApO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7dmFyIHY9eG8obik7cmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgICAgICAgaW50IGluZGV4ID0gcm93ICogXCIrbytcIiArIGNvbCAqIFwiK2ErXCIgKyBkZXB0aCArIFwiK3YrXCI7XFxuICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdChcIitwK1wiLCBcIitmK1wiLCBpbmRleCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgICAgfVxcbiAgXCJ9KHQpO2Nhc2UgNDpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLG49dC5uYW1lLHI9XCJnZXRcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSksbz1lWzNdLGE9ZVsyXSpvLGk9ZVsxXSphLHM9ayhlKSx1PXMubmV3U2hhcGUsbD1zLmtlcHREaW1zO2lmKHUubGVuZ3RoPGUubGVuZ3RoKXt2YXIgYz1Dbyh0LHUpO3JldHVyblwiXFxuICAgICAgXCIrcG8oYykrXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgICAgcmV0dXJuIFwiK3IrXCIoXCIrRW8oW1wicm93XCIsXCJjb2xcIixcImRlcHRoXCIsXCJkZXB0aDJcIl0sbCkrXCIpO1xcbiAgICAgIH1cXG4gICAgXCJ9aWYodC5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIGludCBpbmRleCA9IHJvdW5kKGRvdCh2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQoXCIraStcIiwgXCIrYStcIiwgXCIrbytcIiwgMSkpKTtcXG4gICAgICAgIFwiK3dvKHQpK1wiXFxuICAgICAgfVxcbiAgICBcIjt2YXIgaD10LnNoYXBlSW5mby5mbGF0T2Zmc2V0LHA9dC5zaGFwZUluZm8udGV4U2hhcGUsZj1wWzBdLGQ9cFsxXTtpZihkPT09aSYmbnVsbD09aClyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICBmbG9hdCB0ZXhSID0gZmxvYXQocm93KTtcXG4gICAgICAgIGZsb2F0IHRleEMgPVxcbiAgICAgICAgICAgIGRvdCh2ZWMzKGNvbCwgZGVwdGgsIGRlcHRoMiksXFxuICAgICAgICAgICAgICAgIHZlYzMoXCIrYStcIiwgXCIrbytcIiwgMSkpO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZCtcIi4wLCBcIitmK1wiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7aWYoZD09PW8mJm51bGw9PWgpcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgICAgZmxvYXQgdGV4UiA9IGRvdCh2ZWMzKHJvdywgY29sLCBkZXB0aCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzMoXCIrZVsxXSplWzJdK1wiLCBcIitlWzJdK1wiLCAxKSk7XFxuICAgICAgICBmbG9hdCB0ZXhDID0gZmxvYXQoZGVwdGgyKTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZCtcIi4wLCBcIitmK1wiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIHY9eG8obik7cmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXFxuICAgICAgaW50IGluZGV4ID0gcm93ICogXCIraStcIiArIGNvbCAqIFwiK2ErXCIgK1xcbiAgICAgICAgICBkZXB0aCAqIFwiK28rXCIgKyBkZXB0aDI7XFxuICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoXCIrZitcIiwgXCIrZCtcIiwgaW5kZXggKyBcIit2K1wiKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KTtjYXNlIDU6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxuPXQubmFtZSxyPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLG89ZVs0XSxhPWVbM10qbyxpPWVbMl0qYSxzPWVbMV0qaSx1PWsoZSksbD11Lm5ld1NoYXBlLGM9dS5rZXB0RGltcztpZihsLmxlbmd0aDxlLmxlbmd0aCl7dmFyIGg9Q28odCxsKTtyZXR1cm5cIlxcbiAgICAgIFwiK3BvKGgpK1wiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgIHJldHVybiBcIityK1wiKFwiK0VvKFtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiLFwiZGVwdGgyXCIsXCJkZXB0aDNcIl0sYykrXCIpO1xcbiAgICAgIH1cXG4gICAgXCJ9aWYodC5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgIGZsb2F0IGluZGV4ID0gZG90KFxcbiAgICAgICAgICB2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgdmVjNChcIitzK1wiLCBcIitpK1wiLCBcIithK1wiLCBcIitvK1wiKSkgK1xcbiAgICAgICAgICBkZXB0aDM7XFxuICAgICAgICBcIit3byh0KStcIlxcbiAgICAgIH1cXG4gICAgXCI7dmFyIHA9dC5zaGFwZUluZm8uZmxhdE9mZnNldCxmPXQuc2hhcGVJbmZvLnRleFNoYXBlLGQ9ZlswXSx2PWZbMV07aWYodj09PXMmJm51bGw9PXApcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xcbiAgICAgICAgaW50IHRleFIgPSByb3c7XFxuICAgICAgICBmbG9hdCB0ZXhDID0gZG90KHZlYzQoY29sLCBkZXB0aCwgZGVwdGgyLCBkZXB0aDMpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICB2ZWM0KFwiK2krXCIsIFwiK2ErXCIsIFwiK28rXCIsIDEpKTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK3YrXCIuMCwgXCIrZCtcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO2lmKHY9PT1vJiZudWxsPT1wKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgIGZsb2F0IHRleFIgPSBkb3QoXFxuICAgICAgICAgIHZlYzQocm93LCBjb2wsIGRlcHRoLCBkZXB0aDIpLFxcbiAgICAgICAgICB2ZWM0KFwiK2VbMV0qZVsyXSplWzNdK1wiLFxcbiAgICAgICAgICAgICAgIFwiK2VbMl0qZVszXStcIiwgXCIrZVszXStcIiwgMSkpO1xcbiAgICAgICAgaW50IHRleEMgPSBkZXB0aDM7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICB2ZWMyKFwiK3YrXCIuMCwgXCIrZCtcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciBtPXhvKG4pO3JldHVyblwiXFxuICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgICAgIGludCBpbmRleCA9IHJvdyAqIFwiK3MrXCIgKyBjb2wgKiBcIitpK1wiICsgZGVwdGggKiBcIithK1wiICtcXG4gICAgICAgICAgZGVwdGgyICogXCIrbytcIiArIGRlcHRoMyArIFwiK20rXCI7XFxuICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoXCIrZCtcIiwgXCIrditcIiwgaW5kZXgpO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9KHQpO2Nhc2UgNjpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLG49dC5uYW1lLHI9XCJnZXRcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSksbz1rKGUpLGE9by5uZXdTaGFwZSxpPW8ua2VwdERpbXM7aWYoYS5sZW5ndGg8ZS5sZW5ndGgpe3ZhciBzPUNvKHQsYSk7cmV0dXJuXCJcXG4gICAgICBcIitwbyhzKStcIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICAgICAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgICAgcmV0dXJuIFwiK3IrXCIoXCIrRW8oW1wicm93XCIsXCJjb2xcIixcImRlcHRoXCIsXCJkZXB0aDJcIixcImRlcHRoM1wiLFwiZGVwdGg0XCJdLGkpK1wiKTtcXG4gICAgICB9XFxuICAgIFwifXZhciB1PWVbNV0sbD1lWzRdKnUsYz1lWzNdKmwsaD1lWzJdKmMscD1lWzFdKmg7aWYodC5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgICAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZG90KFxcbiAgICAgICAgICB2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgdmVjNChcIitwK1wiLCBcIitoK1wiLCBcIitjK1wiLCBcIitsK1wiKSkgK1xcbiAgICAgICAgICBkb3QoXFxuICAgICAgICAgICAgdmVjMihkZXB0aDMsIGRlcHRoNCksXFxuICAgICAgICAgICAgdmVjMihcIit1K1wiLCAxKSkpO1xcbiAgICAgICAgXCIrd28odCkrXCJcXG4gICAgICB9XFxuICAgIFwiO3ZhciBmPXQuc2hhcGVJbmZvLmZsYXRPZmZzZXQsZD10LnNoYXBlSW5mby50ZXhTaGFwZSx2PWRbMF0sbT1kWzFdO2lmKG09PT1wJiZudWxsPT1mKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgICBpbnQgdGV4UiA9IHJvdztcXG4gICAgICAgIGZsb2F0IHRleEMgPSBkb3QodmVjNChjb2wsIGRlcHRoLCBkZXB0aDIsIGRlcHRoMyksXFxuICAgICAgICAgIHZlYzQoXCIraCtcIiwgXCIrYytcIiwgXCIrbCtcIiwgXCIrdStcIikpICtcXG4gICAgICAgICAgICAgICBmbG9hdChkZXB0aDQpO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrbStcIi4wLCBcIit2K1wiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7aWYobT09PXUmJm51bGw9PWYpcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcXG4gICAgICAgIGZsb2F0IHRleFIgPSBkb3QodmVjNChyb3csIGNvbCwgZGVwdGgsIGRlcHRoMiksXFxuICAgICAgICAgIHZlYzQoXCIrZVsxXSplWzJdKmVbM10qZVs0XStcIixcXG4gICAgICAgICAgICAgICBcIitlWzJdKmVbM10qZVs0XStcIixcXG4gICAgICAgICAgICAgICBcIitlWzNdKmVbNF0rXCIsXFxuICAgICAgICAgICAgICAgXCIrZVs0XStcIikpICsgZmxvYXQoZGVwdGgzKTtcXG4gICAgICAgIGludCB0ZXhDID0gZGVwdGg0O1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgdmVjMihcIittK1wiLjAsIFwiK3YrXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjt2YXIgZz14byhuKTtyZXR1cm5cIlxcbiAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgICAgIGludCBpbmRleCA9IHJvdyAqIFwiK3ArXCIgKyBjb2wgKiBcIitoK1wiICsgZGVwdGggKiBcIitjK1wiICtcXG4gICAgICAgICAgZGVwdGgyICogXCIrbCtcIiArIGRlcHRoMyAqIFwiK3UrXCIgKyBkZXB0aDQgKyBcIitnK1wiO1xcbiAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KFwiK3YrXCIsIFwiK20rXCIsIGluZGV4KTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihlLmxlbmd0aCtcIi1EIGlucHV0IHNhbXBsaW5nIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpfX1mdW5jdGlvbiBmbyh0KXt2YXIgZSxuLHI7c3dpdGNoKHQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gZT10Lm5hbWUsbj1cImdldFwiK2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKSxyPXVvKCksXCJcXG4gICAgdmVjNCBcIituK1wiKCkge1xcbiAgICAgIHJldHVybiBcIityLnRleHR1cmUyRCtcIihcIitlK1wiLCBoYWxmQ1IpO1xcbiAgICB9XFxuICBcIjtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQubmFtZSxuPVwiZ2V0XCIrZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStlLnNsaWNlKDEpLHI9dC5zaGFwZUluZm8udGV4U2hhcGUsbz1bTWF0aC5jZWlsKHJbMF0vMiksTWF0aC5jZWlsKHJbMV0vMildLGE9dW8oKTtyZXR1cm5cIlxcbiAgICB2ZWM0IFwiK24rXCIoaW50IGluZGV4KSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTFEKFxcbiAgICAgICAgXCIrb1swXStcIiwgXCIrb1sxXStcIiwgaW5kZXgpO1xcbiAgICAgIHJldHVybiBcIithLnRleHR1cmUyRCtcIihcIitlK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxuPXQubmFtZSxyPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLG89dC5zaGFwZUluZm8udGV4U2hhcGUsYT1vWzBdLGk9b1sxXSxzPXVvKCk7aWYobnVsbCE9byYmeChlLG8pKXJldHVyblwiXFxuICAgICAgdmVjNCBcIityK1wiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMihjb2wsIHJvdykgKyBoYWxmQ1IpIC8gdmVjMihcIitpK1wiLjAsIFwiK2ErXCIuMCk7XFxuXFxuICAgICAgICByZXR1cm4gXCIrcy50ZXh0dXJlMkQrXCIoXCIrbitcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIHU9W01hdGguY2VpbChvWzBdLzIpLE1hdGguY2VpbChvWzFdLzIpXSxsPU1hdGguY2VpbChlWzFdLzIpO3JldHVyblwiXFxuICAgIHZlYzQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTJEKFwiK2wrXCIsIFwiK3VbMF0rXCIsIFwiK3VbMV0rXCIsIHJvdywgY29sKTtcXG4gICAgICByZXR1cm4gXCIrcy50ZXh0dXJlMkQrXCIoXCIrbitcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCk7Y2FzZSAzOnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsbj10Lm5hbWUscj1cImdldFwiK24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxvPXQuc2hhcGVJbmZvLnRleFNoYXBlLGE9W01hdGguY2VpbChvWzBdLzIpLE1hdGguY2VpbChvWzFdLzIpXTtpZigxPT09ZVswXSl7dmFyIGk9ZS5zbGljZSgxKSxzPUNvKHQsaSk7cmV0dXJuXCJcXG4gICAgICAgIFwiK2ZvKHMpK1wiXFxuICAgICAgICB2ZWM0IFwiK3IrXCIoaW50IGIsIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgcmV0dXJuIFwiK3IrXCIoXCIrRW8oW1wiYlwiLFwicm93XCIsXCJjb2xcIl0sWzEsMl0pK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICBcIn12YXIgdT1hWzBdLGw9YVsxXSxjPU1hdGguY2VpbChlWzJdLzIpLGg9YypNYXRoLmNlaWwoZVsxXS8yKSxwPXVvKCk7cmV0dXJuXCJcXG4gICAgdmVjNCBcIityK1wiKGludCBiLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTNEKFxcbiAgICAgICAgXCIrdStcIiwgXCIrbCtcIiwgXCIraCtcIiwgXCIrYytcIiwgYiwgcm93LCBjb2wpO1xcbiAgICAgIHJldHVybiBcIitwLnRleHR1cmUyRCtcIihcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KTtkZWZhdWx0OnJldHVybiBmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLG49ZS5sZW5ndGgscj10Lm5hbWUsbz1cImdldFwiK3IuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrci5zbGljZSgxKSxhPXQuc2hhcGVJbmZvLnRleFNoYXBlLGk9W01hdGguY2VpbChhWzBdLzIpLE1hdGguY2VpbChhWzFdLzIpXSxzPWlbMF0sdT1pWzFdLGw9TWF0aC5jZWlsKGVbbi0xXS8yKSxjPWwqTWF0aC5jZWlsKGVbbi0yXS8yKSxoPVwiaW50IGIsIGludCByb3csIGludCBjb2xcIixwPVwiYiAqIFwiK2MrXCIgKyAocm93IC8gMikgKiBcIitsK1wiICsgKGNvbCAvIDIpXCIsZj0yO2Y8bi0xO2YrKyloPVwiaW50IGJcIitmK1wiLCBcIitoLGMqPWVbbi1mLTFdLHA9XCJiXCIrZitcIiAqIFwiK2MrXCIgKyBcIitwO3ZhciBkPXVvKCk7cmV0dXJuXCJcXG4gICAgdmVjNCBcIitvK1wiKFwiK2grXCIpIHtcXG4gICAgICBpbnQgaW5kZXggPSBcIitwK1wiO1xcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLyBcIit1K1wiO1xcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogXCIrdStcIjtcXG4gICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMihcIit1K1wiLCBcIitzK1wiKTtcXG4gICAgICByZXR1cm4gXCIrZC50ZXh0dXJlMkQrXCIoXCIrcitcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCl9fXZhciB2bz1cIlxcbnZlYzIgdXZGcm9tRmxhdChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xcbiAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxudmVjMiBwYWNrZWRVVmZyb20xRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xcbiAgaW50IHRleGVsSW5kZXggPSBpbmRleCAvIDI7XFxuICBpbnQgdGV4UiA9IHRleGVsSW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSB0ZXhlbEluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxuXCIsbW89XCJcXG52ZWMyIHBhY2tlZFVWZnJvbTJEKGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCB0ZXhOdW1SLFxcbiAgaW50IHRleE51bUMsIGludCByb3csIGludCBjb2wpIHtcXG4gIGludCB0ZXhlbEluZGV4ID0gKHJvdyAvIDIpICogdGV4ZWxzSW5Mb2dpY2FsUm93ICsgKGNvbCAvIDIpO1xcbiAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiLGdvPVwiXFxudmVjMiBwYWNrZWRVVmZyb20zRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsXFxuICAgIGludCB0ZXhlbHNJbkJhdGNoLCBpbnQgdGV4ZWxzSW5Mb2dpY2FsUm93LCBpbnQgYixcXG4gICAgaW50IHJvdywgaW50IGNvbCkge1xcbiAgaW50IGluZGV4ID0gYiAqIHRleGVsc0luQmF0Y2ggKyAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIix5bz1cIlxcbiAgZmxvYXQgZ2V0Q2hhbm5lbCh2ZWM0IGZyYWcsIHZlYzIgaW5uZXJEaW1zKSB7XFxuICAgIHZlYzIgbW9kQ29vcmQgPSBtb2QoaW5uZXJEaW1zLCAyLik7XFxuICAgIHJldHVybiBtb2RDb29yZC54ID09IDAuID9cXG4gICAgICAobW9kQ29vcmQueSA9PSAwLiA/IGZyYWcuciA6IGZyYWcuZykgOlxcbiAgICAgIChtb2RDb29yZC55ID09IDAuID8gZnJhZy5iIDogZnJhZy5hKTtcXG4gIH1cXG4gIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCBpbnQgZGltKSB7XFxuICAgIGZsb2F0IG1vZENvb3JkID0gbW9kKGZsb2F0KGRpbSksIDIuKTtcXG4gICAgcmV0dXJuIG1vZENvb3JkID09IDAuID8gZnJhZy5yIDogZnJhZy5nO1xcbiAgfVxcblwiO2Z1bmN0aW9uIHhvKHQpe3JldHVyblwib2Zmc2V0XCIrdH1mdW5jdGlvbiB3byh0KXt2YXIgZT10Lm5hbWUsbj15KHQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSk7cmV0dXJuIG48Mj9cInJldHVybiBcIitlK1wiO1wiOlwiXFxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrbitcIjsgaSsrKSB7XFxuICAgICAgaWYgKGkgPT0gaW5kZXgpIHtcXG4gICAgICAgIHJldHVybiBcIitlK1wiW2ldO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgXCJ9ZnVuY3Rpb24gYm8odCl7aWYodDw9MSlyZXR1cm5cImludFwiO2lmKDI9PT10KXJldHVyblwiaXZlYzJcIjtpZigzPT09dClyZXR1cm5cIml2ZWMzXCI7aWYoND09PXQpcmV0dXJuXCJpdmVjNFwiO2lmKDU9PT10KXJldHVyblwiaXZlYzVcIjtpZig2PT09dClyZXR1cm5cIml2ZWM2XCI7dGhyb3cgRXJyb3IoXCJHUFUgZm9yIHJhbmsgXCIrdCtcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX1mdW5jdGlvbiBDbyh0LGUpe3ZhciBuPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodCkpO3JldHVybiBuLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU9ZSxufWZ1bmN0aW9uIEVvKHQsZSl7cmV0dXJuIGUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiB0W2VdfSkuam9pbihcIiwgXCIpfXZhciBSbz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnVzZXNQYWNrZWRUZXh0dXJlcz0hMCxkKHQubGVuZ3RoPjIsZnVuY3Rpb24oKXtyZXR1cm5cIlBhY2tlZCBhcmdcIisobi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpKStcIiBzdXBwb3J0cyBvbmx5IGlucHV0cyB3aXRoIHJhbmsgYWJvdmUgMi5cIn0pO3ZhciBvPXRbdC5sZW5ndGgtMV0sYT1NYXRoLmNlaWwoby9lKTt0aGlzLm91dHB1dFNoYXBlPXQuc2xpY2UoMCwtMSksYT4xJiZ0aGlzLm91dHB1dFNoYXBlLnB1c2goYSkscnx8dGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJiZXN0SW5kaWNlc0FcIik7dmFyIGkscyx1PXRoaXMub3V0cHV0U2hhcGUsbD11Lmxlbmd0aCxjPWJvKGwpLGg9b28oXCJjb29yZHNcIixsKTtpZigxPT09YSl7dmFyIHA9Ym8ocz1sKzEpO2k9XCJcXG4gICAgICAgIFwiK3ArXCIgc291cmNlTG9jUiA9IFwiK3ArXCIoXCIraC5qb2luKCkrXCIsIDApO1xcbiAgICAgICAgKytcIitoW2wtMV0rXCI7XFxuICAgICAgICBcIitwK1wiIHNvdXJjZUxvY0cgPSBcIitwK1wiKFwiK2guam9pbigpK1wiLCAwKTtcXG4gICAgICAgICsrXCIraFtsLTJdK1wiO1xcbiAgICAgICAgXCIrcCtcIiBzb3VyY2VMb2NBID0gXCIrcCtcIihcIitoLmpvaW4oKStcIiwgMCk7XFxuICAgICAgICAtLVwiK2hbbC0xXStcIjtcXG4gICAgICAgIFwiK3ArXCIgc291cmNlTG9jQiA9IFwiK3ArXCIoXCIraC5qb2luKCkrXCIsIDApO1xcbiAgICAgICAgLS1cIitoW2wtMl0rXCI7XCJ9ZWxzZSBzPWwsaT1cIlxcbiAgICAgICAgXCIrYytcIiBzb3VyY2VMb2NSID0gY29vcmRzO1xcbiAgICAgICAgKytcIitoW2wtMV0rXCI7XFxuICAgICAgICBcIitjK1wiIHNvdXJjZUxvY0cgPSBjb29yZHM7XFxuICAgICAgICArK1wiK2hbbC0yXStcIjtcXG4gICAgICAgIFwiK2MrXCIgc291cmNlTG9jQSA9IGNvb3JkcztcXG4gICAgICAgIC0tXCIraFtsLTFdK1wiO1xcbiAgICAgICAgXCIrYytcIiBzb3VyY2VMb2NCID0gY29vcmRzO1xcbiAgICAgICAgLS1cIitoW2wtMl0rXCI7XCI7dmFyIGY9W1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXS5zbGljZSgwLHMpLHY9XCIuXCIrZltzLTFdLG09Zi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJpbnQgXCIrdH0pLGc9b28oXCJzb3VyY2VMb2NSXCIscy0xKS5jb25jYXQoXCJpbklkeC5yXCIpLHk9b28oXCJzb3VyY2VMb2NHXCIscy0xKS5jb25jYXQoXCJpbklkeC5nXCIpLHg9b28oXCJzb3VyY2VMb2NCXCIscy0xKS5jb25jYXQoXCJpbklkeC5iXCIpLHc9b28oXCJzb3VyY2VMb2NBXCIscy0xKS5jb25jYXQoXCJpbklkeC5hXCIpLGI9XCJtYXhcIj09PW4/XCJncmVhdGVyVGhhblwiOlwibGVzc1RoYW5cIixDPXI/XCJcIjpcIlxcbiAgICAgICAgICBpbklkeCA9IHJvdW5kKHZlYzQoZ2V0QmVzdEluZGljZXNBQ2hhbm5lbChcIitnLmpvaW4oKStcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRCZXN0SW5kaWNlc0FDaGFubmVsKFwiK3kuam9pbigpK1wiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEJlc3RJbmRpY2VzQUNoYW5uZWwoXCIreC5qb2luKCkrXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QmVzdEluZGljZXNBQ2hhbm5lbChcIit3LmpvaW4oKStcIikpKTtcIixFPVwidmVjNChcXG4gICAgICAgICAgICBnZXRBQ2hhbm5lbChcIitnLmpvaW4oKStcIiksXFxuICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFDaGFubmVsKFwiK3kuam9pbigpK1wiKSA6IDAuLFxcbiAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBQ2hhbm5lbChcIit4LmpvaW4oKStcIikgOiAwLixcXG4gICAgICAgICAgICBoYXNOZXh0Um93ICYmIGhhc05leHRDb2wgPyBnZXRBQ2hhbm5lbChcIit3LmpvaW4oKStcIikgOiAwLilcIixSPXI/XCJcIjpcIlxcbiAgICAgIGZsb2F0IGdldEJlc3RJbmRpY2VzQUNoYW5uZWwoXCIrbS5qb2luKCkrXCIpIHtcXG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKGdldEJlc3RJbmRpY2VzQShcIitmLmpvaW4oKStcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIitmLnNsaWNlKC0yKS5qb2luKCkrXCIpKTtcXG4gICAgICB9XCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGZsb2F0IGdldEFDaGFubmVsKFwiK20uam9pbigpK1wiKSB7XFxuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChnZXRBKFwiK2Yuam9pbigpK1wiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIitmLnNsaWNlKC0yKS5qb2luKCkrXCIpKTtcXG4gICAgICB9XFxuICAgICAgXCIrUitcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK2MrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBib29sIGhhc05leHRDb2wgPSBcIitoW2wtMV0rXCIgPCBcIisodVtsLTFdLTEpK1wiO1xcbiAgICAgICAgYm9vbCBoYXNOZXh0Um93ID0gXCIraFtsLTJdK1wiIDwgXCIrKHVbbC0yXS0xKStcIjtcXG4gICAgICAgIFwiK2krXCJcXG4gICAgICAgIGl2ZWM0IHNyY0lkeCA9IGl2ZWM0KHNvdXJjZUxvY1JcIit2K1wiLCBzb3VyY2VMb2NHXCIrditcIixcXG4gICAgICAgICAgc291cmNlTG9jQlwiK3YrXCIsIHNvdXJjZUxvY0FcIit2K1wiKSAqIFwiK2UrXCI7XFxuICAgICAgICBpdmVjNCBpbklkeCA9IHNyY0lkeDtcXG4gICAgICAgIHZlYzQgYmVzdEluZGV4ID0gdmVjNChpbklkeCk7XFxuICAgICAgICB2ZWM0IGJlc3RWYWx1ZSA9IFwiK0UrXCI7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK2UrXCI7IGkrKykge1xcbiAgICAgICAgICBpbklkeCA9IHNyY0lkeDtcXG4gICAgICAgICAgXCIrQytcIlxcbiAgICAgICAgICB2ZWM0IGNhbmRpZGF0ZSA9IFwiK0UrXCI7XFxuICAgICAgICAgIGJ2ZWM0IG5hbiA9IGlzbmFuKGNhbmRpZGF0ZSk7XFxuICAgICAgICAgIGJ2ZWM0IHJlcGxhY2UgPSBidmVjNChcXG4gICAgICAgICAgICB2ZWM0KFwiK2IrXCIoY2FuZGlkYXRlLCBiZXN0VmFsdWUpKSAqICh2ZWM0KDEuMCkgLSB2ZWM0KG5hbikpKTtcXG5cXG4gICAgICAgICAgYmVzdFZhbHVlID0gdmVjNChyZXBsYWNlLnggID8gY2FuZGlkYXRlLnggOiBiZXN0VmFsdWUueCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlLnkgID8gY2FuZGlkYXRlLnkgOiBiZXN0VmFsdWUueSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlLnogID8gY2FuZGlkYXRlLnogOiBiZXN0VmFsdWUueixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlLncgID8gY2FuZGlkYXRlLncgOiBiZXN0VmFsdWUudyk7XFxuICAgICAgICAgIGJlc3RJbmRleCA9IG1peChiZXN0SW5kZXgsIHZlYzQoaW5JZHgpLCB2ZWM0KHJlcGxhY2UpKTtcXG4gICAgICAgICAgc3JjSWR4Kys7XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoYmVzdEluZGV4KTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxTbz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT10LmluU2hhcGU7dmFyIGU9dC5maWx0ZXJIZWlnaHQsbj10LmZpbHRlcldpZHRoLHI9dC5zdHJpZGVIZWlnaHQsbz10LnN0cmlkZVdpZHRoLGE9dC5kaWxhdGlvbkhlaWdodCxpPXQuZGlsYXRpb25XaWR0aCxzPXQuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LHU9dC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxsPXMtMS10LnBhZEluZm8udG9wLGM9dS0xLXQucGFkSW5mby5sZWZ0LGg9MS8oZSpuKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2wrXCIsIFwiK2MrXCIpO1xcbiAgICAgIGNvbnN0IGZsb2F0IGF2Z011bHRpcGxpZXIgPSBmbG9hdChcIitoK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuXFxuICAgICAgICBpdmVjMiBkeVJDQ29ybmVyID0gY29vcmRzLnl6IC0gcGFkcztcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeVJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZCkgd2l0aCBwb3MgbWFzayg6LCA6LCBkKSB0byBnZXQgZHgoeFIsIHhDLCBkKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitzK1wiO1xcbiAgICAgICAgICAgIHdSICs9IFwiK2ErXCIpIHtcXG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIrcitcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIit0Lm91dEhlaWdodCtcIi4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrdStcIjtcXG4gICAgICAgICAgICB3Qys9IFwiK2krXCIpIHtcXG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIitvK1wiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIrdC5vdXRXaWR0aCtcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCBpZHlSLCBpZHlDLCBkKTtcXG5cXG4gICAgICAgICAgICBkb3RQcm9kICs9IGR5VmFsdWUgKiBhdmdNdWx0aXBsaWVyO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksTm89ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scixvLGEpe3RoaXMub3V0cHV0U2hhcGU9W10sdGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIm1lYW5cIixcInZhcmlhbmNlXCJdLHNvKHQsZSksc28odCxuKTt2YXIgaT1cIjAuMFwiO251bGwhPXImJihzbyh0LHIpLHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwib2Zmc2V0XCIpLGk9XCJnZXRPZmZzZXRBdE91dENvb3JkcygpXCIpO3ZhciBzPVwiMS4wXCI7bnVsbCE9byYmKHNvKHQsbyksdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJzY2FsZVwiKSxzPVwiZ2V0U2NhbGVBdE91dENvb3JkcygpXCIpLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgeCA9IGdldFhBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgbWVhbiA9IGdldE1lYW5BdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgdmFyaWFuY2UgPSBnZXRWYXJpYW5jZUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBvZmZzZXQgPSBcIitpK1wiO1xcbiAgICAgICAgZmxvYXQgc2NhbGUgPSBcIitzK1wiO1xcbiAgICAgICAgZmxvYXQgaW52ID0gc2NhbGUgKiBpbnZlcnNlc3FydCh2YXJpYW5jZSArIGZsb2F0KFwiK2ErXCIpKTtcXG4gICAgICAgIHNldE91dHB1dChkb3QodmVjMyh4LCAtbWVhbiwgb2Zmc2V0KSwgdmVjMyhpbnYsIGludiwgMSkpKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxrbz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyLG8sYSl7dGhpcy51c2VzUGFja2VkVGV4dHVyZXM9ITAsdGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIm1lYW5cIixcInZhcmlhbmNlXCJdLHNvKHQsZSksc28odCxuKTt2YXIgaT1cInZlYzQoMC4wKVwiO251bGwhPXImJihzbyh0LHIpLHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwib2Zmc2V0XCIpLGk9XCJnZXRPZmZzZXRBdE91dENvb3JkcygpXCIpO3ZhciBzPVwidmVjNCgxLjApXCI7bnVsbCE9byYmKHNvKHQsbyksdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJzY2FsZVwiKSxzPVwiZ2V0U2NhbGVBdE91dENvb3JkcygpXCIpLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgdmVjNCBvZmZzZXQgPSBcIitpK1wiO1xcbiAgICAgICAgdmVjNCBzY2FsZSA9IFwiK3MrXCI7XFxuXFxuICAgICAgICB2ZWM0IHggPSBnZXRYQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgbWVhbiA9IGdldE1lYW5BdE91dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCB2YXJpYW5jZSA9IGdldFZhcmlhbmNlQXRPdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIHZlYzQgaW52ID0gc2NhbGUgKiBpbnZlcnNlc3FydCh2YXJpYW5jZSArIHZlYzQoXCIrYStcIikpO1xcblxcbiAgICAgICAgc2V0T3V0cHV0KCh4IC0gbWVhbikgKiBpbnYgKyBvZmZzZXQpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLElvPVwicmV0dXJuIGFyZWFsICogYnJlYWwgLSBhaW1hZyAqIGJpbWFnO1wiLEFvPVwicmV0dXJuIGFyZWFsICogYmltYWcgKyBhaW1hZyAqIGJyZWFsO1wiLFRvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVJlYWxcIixcIkFJbWFnXCIsXCJCUmVhbFwiLFwiQkltYWdcIl0sdGhpcy5vdXRwdXRTaGFwZT1zbyhlLG4pLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBmbG9hdCBiaW5hcnlPcENvbXBsZXgoXFxuICAgICAgICAgIGZsb2F0IGFyZWFsLCBmbG9hdCBhaW1hZywgZmxvYXQgYnJlYWwsIGZsb2F0IGJpbWFnKSB7XFxuICAgICAgICBcIit0K1wiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IGFyZWFsID0gZ2V0QVJlYWxBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgYWltYWcgPSBnZXRBSW1hZ0F0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBicmVhbCA9IGdldEJSZWFsQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGJpbWFnID0gZ2V0QkltYWdBdE91dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGJpbmFyeU9wQ29tcGxleChhcmVhbCwgYWltYWcsIGJyZWFsLCBiaW1hZykpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLERvPVwicmV0dXJuIGEgKyBiO1wiLE9vPVwicmV0dXJuIGEgLSBiO1wiLF9vPVwicmV0dXJuIGEgKiBiO1wiLE1vPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiLFwiQlwiXSx0aGlzLm91dHB1dFNoYXBlPXNvKGUsbiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGZsb2F0IGJpbmFyeU9wZXJhdGlvbihmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgICAgICBcIit0K1wiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGIgPSBnZXRCQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChiaW5hcnlPcGVyYXRpb24oYSwgYikpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLEZvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPSExKSx0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiLFwiQlwiXSx0aGlzLnN1cHBvcnRzQnJvYWRjYXN0aW5nPSEwLHRoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwLHRoaXMub3V0cHV0U2hhcGU9c28oZSxuKTt2YXIgbz10aGlzLm91dHB1dFNoYXBlLmxlbmd0aCxhPVwiXCI7aWYocilpZigwPT09b3x8MT09PXkodGhpcy5vdXRwdXRTaGFwZSkpYT1cIlxcbiAgICAgICAgICByZXN1bHQueSA9IDAuO1xcbiAgICAgICAgICByZXN1bHQueiA9IDAuO1xcbiAgICAgICAgICByZXN1bHQudyA9IDAuO1xcbiAgICAgICAgXCI7ZWxzZSBpZihhPVwiXFxuICAgICAgICAgIFwiK2JvKG8pK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgXCIsMT09PW8pYSs9XCJcXG4gICAgICAgICAgICByZXN1bHQueSA9IChjb29yZHMgKyAxKSA+PSBcIit0aGlzLm91dHB1dFNoYXBlWzBdK1wiID8gMC4gOiByZXN1bHQueTtcXG4gICAgICAgICAgICByZXN1bHQueiA9IDAuO1xcbiAgICAgICAgICAgIHJlc3VsdC53ID0gMC47XFxuICAgICAgICAgIFwiO2Vsc2V7dmFyIGk9b28oXCJjb29yZHNcIixvKTthKz1cIlxcbiAgICAgICAgICAgIGJvb2wgbmV4dFJvd091dE9mQm91bmRzID1cXG4gICAgICAgICAgICAgIChcIitpW28tMl0rXCIgKyAxKSA+PSBcIit0aGlzLm91dHB1dFNoYXBlW28tMl0rXCI7XFxuICAgICAgICAgICAgYm9vbCBuZXh0Q29sT3V0T2ZCb3VuZHMgPVxcbiAgICAgICAgICAgICAgKFwiK2lbby0xXStcIiArIDEpID49IFwiK3RoaXMub3V0cHV0U2hhcGVbby0xXStcIjtcXG4gICAgICAgICAgICByZXN1bHQueSA9IG5leHRDb2xPdXRPZkJvdW5kcyA/IDAuIDogcmVzdWx0Lnk7XFxuICAgICAgICAgICAgcmVzdWx0LnogPSBuZXh0Um93T3V0T2ZCb3VuZHMgPyAwLiA6IHJlc3VsdC56O1xcbiAgICAgICAgICAgIHJlc3VsdC53ID0gbmV4dENvbE91dE9mQm91bmRzIHx8IG5leHRSb3dPdXRPZkJvdW5kcyA/IDAuIDogcmVzdWx0Lnc7XFxuICAgICAgICAgIFwifXRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2ZWM0IGJpbmFyeU9wZXJhdGlvbih2ZWM0IGEsIHZlYzQgYikge1xcbiAgICAgICAgXCIrdCtcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgYiA9IGdldEJBdE91dENvb3JkcygpO1xcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSBiaW5hcnlPcGVyYXRpb24oYSwgYik7XFxuICAgICAgICBcIithK1wiXFxuXFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxCbz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB1bmlmb3JtIGZsb2F0IG1pbjtcXG4gICAgICB1bmlmb3JtIGZsb2F0IG1heDtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgaWYgKGlzbmFuKHZhbHVlKSkge1xcbiAgICAgICAgICBzZXRPdXRwdXQodmFsdWUpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQoY2xhbXAodmFsdWUsIG1pbiwgbWF4KSk7XFxuICAgICAgfVxcbiAgICBcIn1yZXR1cm4gdC5wcm90b3R5cGUuZ2V0Q3VzdG9tU2V0dXBGdW5jPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcztyZXR1cm4gZnVuY3Rpb24ocixvKXtudWxsPT1uLm1pbkxvYyYmKG4ubWluTG9jPXIuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyhvLFwibWluXCIpLG4ubWF4TG9jPXIuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyhvLFwibWF4XCIpKSxyLmdsLnVuaWZvcm0xZihuLm1pbkxvYyx0KSxyLmdsLnVuaWZvcm0xZihuLm1heExvYyxlKX19LHR9KCksUG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdW5pZm9ybSBmbG9hdCBtaW47XFxuICAgICAgdW5pZm9ybSBmbG9hdCBtYXg7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgdmVjNCB2YWx1ZSA9IGdldEFBdE91dENvb3JkcygpO1xcblxcbiAgICAgICAgaWYgKGFueShpc25hbih2YWx1ZSkpKSB7XFxuICAgICAgICAgIHNldE91dHB1dCh2YWx1ZSk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHNldE91dHB1dChjbGFtcCh2YWx1ZSwgdmVjNChtaW4pLCB2ZWM0KG1heCkpKTtcXG4gICAgICB9XFxuICAgIFwifXJldHVybiB0LnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmM9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO3JldHVybiBmdW5jdGlvbihyLG8pe251bGw9PW4ubWluTG9jJiYobi5taW5Mb2M9ci5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KG8sXCJtaW5cIiksbi5tYXhMb2M9ci5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KG8sXCJtYXhcIikpLHIuZ2wudW5pZm9ybTFmKG4ubWluTG9jLHQpLHIuZ2wudW5pZm9ybTFmKG4ubWF4TG9jLGUpfX0sdH0oKSxMbz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wicmVhbFwiLFwiaW1hZ1wiXSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHJlID0gYWJzKGdldFJlYWxBdE91dENvb3JkcygpKTtcXG4gICAgICAgIGZsb2F0IGltID0gYWJzKGdldEltYWdBdE91dENvb3JkcygpKTtcXG4gICAgICAgIGZsb2F0IG14ID0gbWF4KHJlLCBpbSk7XFxuXFxuICAgICAgICAvLyBzYWRseSB0aGUgbGVuZ3RoIGZ1bmN0aW9uIGluIGdsc2wgaXMgbm90IHVuZGVyZmxvdy1zYWZlXFxuICAgICAgICAvLyAoYXQgbGVhc3Qgbm90IG9uIEludGVsIEdQVXMpLiBTbyB0aGUgc2FmZSBzb2x1dGlvbiBpc1xcbiAgICAgICAgLy8gdG8gZW5zdXJlIHVuZGVyZmxvdy1zYWZldHkgaW4gYWxsIGNhc2VzLlxcbiAgICAgICAgc2V0T3V0cHV0KFxcbiAgICAgICAgICBteCA9PSAwLjAgPyAwLjAgOiBteCAqIGxlbmd0aCh2ZWMyKDEsIG1pbihyZSwgaW0pL214KSlcXG4gICAgICAgICk7XFxuICAgICAgfVxcbiAgICBcIn19KCksV289ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPXNuKHQsMSksdGhpcy52YXJpYWJsZU5hbWVzPXQubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJUXCIrZX0pO3ZhciBlPW5ldyBBcnJheSh0Lmxlbmd0aC0xKTtlWzBdPXRbMF1bMV07Zm9yKHZhciBuPTE7bjxlLmxlbmd0aDtuKyspZVtuXT1lW24tMV0rdFtuXVsxXTt2YXIgcj1bXCJpZiAoeUMgPCBcIitlWzBdK1wiKSBzZXRPdXRwdXQoZ2V0VDAoeVIsIHlDKSk7XCJdO2ZvcihuPTE7bjxlLmxlbmd0aDtuKyspe3ZhciBvPWVbbi0xXTtyLnB1c2goXCJlbHNlIGlmICh5QyA8IFwiK2Vbbl0rXCIpIHNldE91dHB1dChnZXRUXCIrbitcIih5UiwgeUMtXCIrbytcIikpO1wiKX12YXIgYT1lLmxlbmd0aCxpPWVbZS5sZW5ndGgtMV07ci5wdXNoKFwiZWxzZSBzZXRPdXRwdXQoZ2V0VFwiK2ErXCIoeVIsIHlDLVwiK2krXCIpKTtcIiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHlSID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgeUMgPSBjb29yZHMueTtcXG5cXG4gICAgICAgIFwiK3Iuam9pbihcIlxcbiAgICAgICAgXCIpK1wiXFxuICAgICAgfVxcbiAgICBcIn19KCksVW89ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlKXt0aGlzLnVzZXNQYWNrZWRUZXh0dXJlcz0hMCx0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9c24odCxlKTt2YXIgbj10aGlzLm91dHB1dFNoYXBlLHI9bi5sZW5ndGgsbz1ibyhyKSxhPW9vKFwiY29vcmRzXCIsciksaT1bXCJ4XCIsXCJ5XCIsXCJ6XCIsXCJ3XCIsXCJ1XCIsXCJ2XCJdLnNsaWNlKDAscik7dGhpcy52YXJpYWJsZU5hbWVzPXQubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJUXCIrZX0pO3ZhciBzPW5ldyBBcnJheSh0Lmxlbmd0aC0xKTtzWzBdPXRbMF1bZV07Zm9yKHZhciB1PTE7dTxzLmxlbmd0aDt1Kyspc1t1XT1zW3UtMV0rdFt1XVtlXTt2YXIgbD1pW2VdLGM9XCJ2ZWMyKFwiK2kuc2xpY2UoLTIpLmpvaW4oKStcIilcIixoPWkuam9pbigpLHA9XCJpZiAoXCIrbCtcIiA8IFwiK3NbMF0rXCIpXFxuICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsKGdldFQwKFwiK2grXCIpLCBcIitjK1wiKTtcIjtmb3IodT0xO3U8cy5sZW5ndGg7dSsrKXt2YXIgZj1zW3UtMV07cCs9XCJcXG4gICAgICAgIGVsc2UgaWYgKFwiK2wrXCIgPCBcIitzW3VdK1wiKSB7XFxuICAgICAgICAgIFwiK2wrXCIgLT0gXCIrZitcIjtcXG4gICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoZ2V0VFwiK3UrXCIoXCIraCtcIiksIFwiK2MrXCIpO1xcbiAgICAgICAgfVwifXZhciBkPXMubGVuZ3RoO3ArPVwiXFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgXCIrbCtcIiAtPSBcIitzW3MubGVuZ3RoLTFdK1wiO1xcbiAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChnZXRUXCIrZCtcIihcIitoK1wiKSwgXCIrYytcIik7XFxuICAgICAgICB9XCIsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGZsb2F0IGdldFZhbHVlKFwiK2kubWFwKGZ1bmN0aW9uKHQpe3JldHVyblwiaW50IFwiK3R9KStcIikge1xcbiAgICAgICAgXCIrcCtcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitvK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KGdldFZhbHVlKFwiK2ErXCIpLCAwLiwgMC4sIDAuKTtcXG4gICAgICAgIGlmICgrK1wiK2Fbci0xXStcIiA8IFwiK25bci0xXStcIikge1xcbiAgICAgICAgICByZXN1bHQuZyA9IGdldFZhbHVlKFwiK2ErXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCsrXCIrYVtyLTJdK1wiIDwgXCIrbltyLTJdK1wiKSB7XFxuICAgICAgICAgIHJlc3VsdC5hID0gZ2V0VmFsdWUoXCIrYStcIik7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoXCIrYVtyLTJdK1wiIDwgXCIrbltyLTJdK1wiICYmXFxuICAgICAgICAgICAgLS1cIithW3ItMV0rXCIgPCBcIituW3ItMV0rXCIpIHtcXG4gICAgICAgICAgcmVzdWx0LmIgPSBnZXRWYWx1ZShcIithK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLHpvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPXQuZmlsdGVyU2hhcGU7dmFyIGU9dC5zdHJpZGVIZWlnaHQsbj10LnN0cmlkZVdpZHRoLHI9dC5wYWRJbmZvLnRvcCxvPXQucGFkSW5mby5sZWZ0O3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCB3UiA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IHdDID0gY29vcmRzLnk7XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHMuejtcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCBkMSkgd2l0aCBkeSg6LCA6LCBkMikgdG8gZ2V0IGR3KHdSLCB3QywgZDEsIGQyKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGIgPSAwOyBiIDwgXCIrdC5iYXRjaFNpemUrXCI7IGIrKykge1xcbiAgICAgICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgXCIrdC5vdXRIZWlnaHQrXCI7IHlSKyspIHtcXG4gICAgICAgICAgICBpbnQgeFIgPSB3UiArIHlSICogXCIrZStcIiAtIFwiK3IrXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIit0LmluSGVpZ2h0K1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgeUMgPSAwOyB5QyA8IFwiK3Qub3V0V2lkdGgrXCI7IHlDKyspIHtcXG4gICAgICAgICAgICAgIGludCB4QyA9IHdDICsgeUMgKiBcIituK1wiIC0gXCIrbytcIjtcXG5cXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrdC5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIHlSLCB5QywgZDIpO1xcbiAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0WChiLCB4UiwgeEMsIGQxKTtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gKHhWYWx1ZSAqIGR5VmFsdWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLFZvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPXQuaW5TaGFwZTt2YXIgZT10LmZpbHRlckhlaWdodCxuPXQuZmlsdGVyV2lkdGgscj10LnN0cmlkZUhlaWdodCxvPXQuc3RyaWRlV2lkdGgsYT1lLTEtdC5wYWRJbmZvLnRvcCxpPW4tMS10LnBhZEluZm8ubGVmdDt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2ErXCIsIFwiK2krXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgZHlDb3JuZXIgPSBjb29yZHMueXogLSBwYWRzO1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5Q29ybmVyLng7XFxuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQyKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBjb21wdXRlIGR4KHhSLCB4QywgZDEpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK2UrXCI7IHdSKyspIHtcXG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIrcitcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIit0Lm91dEhlaWdodCtcIi4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICBpbnQgd1JQZXJtID0gXCIrZStcIiAtIDEgLSB3UjtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK24rXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIitvK1wiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIrdC5vdXRXaWR0aCtcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgIGludCB3Q1Blcm0gPSBcIituK1wiIC0gMSAtIHdDO1xcblxcbiAgICAgICAgICAgIGZvciAoaW50IGQyID0gMDsgZDIgPCBcIit0Lm91dENoYW5uZWxzK1wiOyBkMisrKSB7XFxuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXREeShiYXRjaCwgaWR5UiwgaWR5QywgZDIpO1xcbiAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3UlBlcm0sIHdDUGVybSwgZDEsIGQyKTtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbHVlICogd1ZhbHVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLEdvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPXQuZmlsdGVyU2hhcGU7dmFyIGU9dC5zdHJpZGVEZXB0aCxuPXQuc3RyaWRlSGVpZ2h0LHI9dC5zdHJpZGVXaWR0aCxvPXQucGFkSW5mby5mcm9udCxhPXQucGFkSW5mby50b3AsaT10LnBhZEluZm8ubGVmdDt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzUgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgd0YgPSBjb29yZHMueDtcXG4gICAgICAgIGludCB3UiA9IGNvb3Jkcy55O1xcbiAgICAgICAgaW50IHdDID0gY29vcmRzLno7XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHMudztcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy51O1xcblxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGIgPSAwOyBiIDwgXCIrdC5iYXRjaFNpemUrXCI7IGIrKykge1xcbiAgICAgICAgICBmb3IgKGludCB5RiA9IDA7IHlGIDwgXCIrdC5vdXREZXB0aCtcIjsgeUYrKykge1xcbiAgICAgICAgICAgIGludCB4RiA9IHdGICsgeUYgKiBcIitlK1wiIC0gXCIrbytcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeEYgPCAwIHx8IHhGID49IFwiK3QuaW5EZXB0aCtcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCBcIit0Lm91dEhlaWdodCtcIjsgeVIrKykge1xcbiAgICAgICAgICAgICAgaW50IHhSID0gd1IgKyB5UiAqIFwiK24rXCIgLSBcIithK1wiO1xcblxcbiAgICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIit0LmluSGVpZ2h0K1wiKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgZm9yIChpbnQgeUMgPSAwOyB5QyA8IFwiK3Qub3V0V2lkdGgrXCI7IHlDKyspIHtcXG4gICAgICAgICAgICAgICAgaW50IHhDID0gd0MgKyB5QyAqIFwiK3IrXCIgLSBcIitpK1wiO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK3QuaW5XaWR0aCtcIikge1xcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCB5RiwgeVIsIHlDLCBkMik7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldFgoYiwgeEYsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9ICh4VmFsdWUgKiBkeVZhbHVlKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxxbz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIixcIldcIl0sdGhpcy5vdXRwdXRTaGFwZT10LmluU2hhcGU7dmFyIGU9dC5maWx0ZXJEZXB0aCxuPXQuZmlsdGVySGVpZ2h0LHI9dC5maWx0ZXJXaWR0aCxvPXQuc3RyaWRlRGVwdGgsYT10LnN0cmlkZUhlaWdodCxpPXQuc3RyaWRlV2lkdGgscz1lLTEtdC5wYWRJbmZvLmZyb250LHU9bi0xLXQucGFkSW5mby50b3AsbD1yLTEtdC5wYWRJbmZvLmxlZnQ7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMzIHBhZHMgPSBpdmVjMyhcIitzK1wiLCBcIit1K1wiLCBcIitsK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzLnU7XFxuXFxuXFxuICAgICAgICBpdmVjMyBkeUNvcm5lciA9IGl2ZWMzKGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLncpIC0gcGFkcztcXG4gICAgICAgIGludCBkeUZDb3JuZXIgPSBkeUNvcm5lci54O1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5Q29ybmVyLnk7XFxuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlDb3JuZXIuejtcXG5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3RiA9IDA7IHdGIDwgXCIrZStcIjsgd0YrKykge1xcbiAgICAgICAgICBmbG9hdCBkeUYgPSBmbG9hdChkeUZDb3JuZXIgKyB3RikgLyBcIitvK1wiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeUYgPCAwLjAgfHwgZHlGID49IFwiK3Qub3V0RGVwdGgrXCIuMCB8fCBmcmFjdChkeUYpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeUYgPSBpbnQoZHlGKTtcXG5cXG4gICAgICAgICAgaW50IHdGUGVybSA9IFwiK2UrXCIgLSAxIC0gd0Y7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIituK1wiOyB3UisrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIrYStcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiK3Qub3V0SGVpZ2h0K1wiLjAgfHxcXG4gICAgICAgICAgICAgIGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICAgIGludCB3UlBlcm0gPSBcIituK1wiIC0gMSAtIHdSO1xcblxcbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIityK1wiOyB3QysrKSB7XFxuICAgICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIitpK1wiLjA7XFxuXFxuICAgICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIit0Lm91dFdpZHRoK1wiLjAgfHxcXG4gICAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICAgIGludCB3Q1Blcm0gPSBcIityK1wiIC0gMSAtIHdDO1xcblxcbiAgICAgICAgICAgICAgZm9yIChpbnQgZDIgPSAwOyBkMiA8IFwiK3Qub3V0Q2hhbm5lbHMrXCI7IGQyKyspIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeUYsIGlkeVIsIGlkeUMsIGQyKTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3RlBlcm0sIHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHhWYWx1ZSAqIHdWYWx1ZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxIbz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT10LmZpbHRlclNoYXBlO3ZhciBlPXQuc3RyaWRlSGVpZ2h0LG49dC5zdHJpZGVXaWR0aCxyPXQucGFkSW5mby50b3Asbz10LnBhZEluZm8ubGVmdCxhPXQub3V0Q2hhbm5lbHMvdC5pbkNoYW5uZWxzO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCB3UiA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IHdDID0gY29vcmRzLnk7XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHMuejtcXG4gICAgICAgIGludCBkbSA9IGNvb3Jkcy53O1xcbiAgICAgICAgaW50IGQyID0gZDEgKiBcIithK1wiICsgZG07XFxuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcblxcbiAgICAgICAgLy8gVE9ETzogVmVjNCBvdmVyIHRoZSBiYXRjaCBzaXplXFxuICAgICAgICBmb3IgKGludCBiID0gMDsgYiA8IFwiK3QuYmF0Y2hTaXplK1wiOyBiKyspIHtcXG4gICAgICAgICAgZm9yIChpbnQgeVIgPSAwOyB5UiA8IFwiK3Qub3V0SGVpZ2h0K1wiOyB5UisrKSB7XFxuICAgICAgICAgICAgaW50IHhSID0gd1IgKyB5UiAqIFwiK2UrXCIgLSBcIityK1wiO1xcblxcbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrdC5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCBcIit0Lm91dFdpZHRoK1wiOyB5QysrKSB7XFxuICAgICAgICAgICAgICBpbnQgeEMgPSB3QyArIHlDICogXCIrbitcIiAtIFwiK28rXCI7XFxuXFxuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK3QuaW5XaWR0aCtcIikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCB5UiwgeUMsIGQyKTtcXG4gICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldFgoYiwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9ICh4VmFsdWUgKiBkeVZhbHVlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSwkbz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIixcIldcIl0sdGhpcy5vdXRwdXRTaGFwZT10LmluU2hhcGU7dmFyIGU9dC5maWx0ZXJIZWlnaHQsbj10LmZpbHRlcldpZHRoLHI9dC5zdHJpZGVIZWlnaHQsbz10LnN0cmlkZVdpZHRoLGE9ZS0xLXQucGFkSW5mby50b3AsaT1uLTEtdC5wYWRJbmZvLmxlZnQscz10Lm91dENoYW5uZWxzL3QuaW5DaGFubmVsczt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2ErXCIsIFwiK2krXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzWzNdO1xcbiAgICAgICAgaXZlYzIgZHlDb3JuZXIgPSBjb29yZHMueXogLSBwYWRzO1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5Q29ybmVyLng7XFxuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlDb3JuZXIueTtcXG5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrZStcIjsgd1IrKykge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIityK1wiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiK3Qub3V0SGVpZ2h0K1wiLjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgIGludCB3UlBlcm0gPSBcIitlK1wiIC0gMSAtIHdSO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrbitcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiK28rXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIit0Lm91dFdpZHRoK1wiLjAgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgaW50IHdDUGVybSA9IFwiK24rXCIgLSAxIC0gd0M7XFxuXFxuICAgICAgICAgICAgLy8gVE9ETzogVmVjNCBvdmVyIHRoZSBjaGFubmVsTXVsXFxuICAgICAgICAgICAgZm9yIChpbnQgZG0gPSAwOyBkbSA8IFwiK3MrXCI7IGRtKyspIHtcXG4gICAgICAgICAgICAgIGludCBkMiA9IGQxICogXCIrcytcIiArIGRtO1xcbiAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeVIsIGlkeUMsIGQyKTtcXG4gICAgICAgICAgICAgIGZsb2F0IHdWYWx1ZSA9IGdldFcod1JQZXJtLCB3Q1Blcm0sIGQxLCBkbSk7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IHhWYWx1ZSAqIHdWYWx1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxqbz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPXQub3V0U2hhcGU7dmFyIGU9dC5wYWRJbmZvLnRvcCxuPXQucGFkSW5mby5sZWZ0LHI9dC5zdHJpZGVIZWlnaHQsbz10LnN0cmlkZVdpZHRoLGE9dC5kaWxhdGlvbkhlaWdodCxpPXQuZGlsYXRpb25XaWR0aCxzPXQuZmlsdGVySGVpZ2h0LHU9dC5maWx0ZXJXaWR0aCxsPTQqTWF0aC5mbG9vcih0LmluQ2hhbm5lbHMvNCksYz10LmluQ2hhbm5lbHMlNDt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiK3IrXCIsIFwiK28rXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIitlK1wiLCBcIituK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy55eiAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGdldCB5KHlSLCB5QywgZDIpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK3MrXCI7IHdSKyspIHtcXG4gICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UiAqIFwiK2ErXCI7XFxuXFxuICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrdC5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIit1K1wiOyB3QysrKSB7XFxuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqIFwiK2krXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIit0LmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCBkMSA9IDA7IGQxIDwgXCIrbCtcIjsgZDEgKz0gNCkge1xcbiAgICAgICAgICAgICAgdmVjNCB4VmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSksXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgZDEgKyAxKSxcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSArIDIpLFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMylcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICB2ZWM0IHdWYWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMSwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAyLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDMsIGQyKVxcbiAgICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoXCIrKDE9PT1jKStcIikge1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPVxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiK2wrXCIpICpcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiK2wrXCIsIGQyKTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiKygyPT09YykrXCIpIHtcXG4gICAgICAgICAgICAgIHZlYzIgeFZhbHVlcyA9IHZlYzIoXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIrbCtcIiksXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIrbCtcIiArIDEpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgdmVjMiB3VmFsdWVzID0gdmVjMihcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiK2wrXCIsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiK2wrXCIgKyAxLCBkMilcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiKygzPT09YykrXCIpIHtcXG4gICAgICAgICAgICAgIHZlYzMgeFZhbHVlcyA9IHZlYzMoXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIrbCtcIiksXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIrbCtcIiArIDEpLFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiK2wrXCIgKyAyKVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIHZlYzMgd1ZhbHVlcyA9IHZlYzMoXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIitsK1wiLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIitsK1wiICsgMSwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIrbCtcIiArIDIsIGQyKVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLEtvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9dC5vdXRTaGFwZTt2YXIgZT10LnBhZEluZm8uZnJvbnQsbj10LnBhZEluZm8udG9wLHI9dC5wYWRJbmZvLmxlZnQsbz10LnN0cmlkZURlcHRoLGE9dC5zdHJpZGVIZWlnaHQsaT10LnN0cmlkZVdpZHRoLHM9dC5kaWxhdGlvbkRlcHRoLHU9dC5kaWxhdGlvbkhlaWdodCxsPXQuZGlsYXRpb25XaWR0aCxjPXQuZmlsdGVyRGVwdGgsaD10LmZpbHRlckhlaWdodCxwPXQuZmlsdGVyV2lkdGgsZj00Kk1hdGguZmxvb3IodC5pbkNoYW5uZWxzLzQpLGQ9dC5pbkNoYW5uZWxzJTQ7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMzIHN0cmlkZXMgPSBpdmVjMyhcIitvK1wiLCBcIithK1wiLCBcIitpK1wiKTtcXG4gICAgICBjb25zdCBpdmVjMyBwYWRzID0gaXZlYzMoXCIrZStcIiwgXCIrbitcIiwgXCIrcitcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzUgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy51O1xcblxcbiAgICAgICAgaXZlYzMgeEZSQ0Nvcm5lciA9IGl2ZWMzKGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLncpICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgeEZDb3JuZXIgPSB4RlJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4RlJDQ29ybmVyLnk7XFxuICAgICAgICBpbnQgeENDb3JuZXIgPSB4RlJDQ29ybmVyLno7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sID8sIGQxKSB3aXRoIHcoOiwgOiwgOiwgZDEsIGQyKSB0byBnZXRcXG4gICAgICAgIC8vIHkoeUYsIHlSLCB5QywgZDIpLiA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGxcXG4gICAgICAgIC8vIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd0YgPSAwOyB3RiA8IFwiK2MrXCI7IHdGKyspIHtcXG4gICAgICAgICAgaW50IHhGID0geEZDb3JuZXIgKyB3RiAqIFwiK3MrXCI7XFxuXFxuICAgICAgICAgIGlmICh4RiA8IDAgfHwgeEYgPj0gXCIrdC5pbkRlcHRoK1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK2grXCI7IHdSKyspIHtcXG4gICAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSICogXCIrdStcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK3QuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrcCtcIjsgd0MrKykge1xcbiAgICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqIFwiK2wrXCI7XFxuXFxuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK3QuaW5XaWR0aCtcIikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZvciAoaW50IGQxID0gMDsgZDEgPCBcIitmK1wiOyBkMSArPSA0KSB7XFxuICAgICAgICAgICAgICAgIHZlYzQgeFZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMSksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAyKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDMpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIHZlYzQgd1ZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBkMSwgZDIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgZDEgKyAxLCBkMiksXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBkMSArIDIsIGQyKSxcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIGQxICsgMywgZDIpXFxuICAgICAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgaWYgKFwiKygxPT09ZCkrXCIpIHtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPVxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIFwiK2YrXCIpICpcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIFwiK2YrXCIsIGQyKTtcXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIrKDI9PT1kKStcIikge1xcbiAgICAgICAgICAgICAgICB2ZWMyIHhWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIFwiK2YrXCIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIFwiK2YrXCIgKyAxKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICB2ZWMyIHdWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgXCIrZitcIiwgZDIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgXCIrZitcIiArIDEsIGQyKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIrKDM9PT1kKStcIikge1xcbiAgICAgICAgICAgICAgICB2ZWMzIHhWYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIFwiK2YrXCIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIFwiK2YrXCIgKyAxKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBcIitmK1wiICsgMilcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgdmVjMyB3VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIFwiK2YrXCIsIGQyKSxcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIFwiK2YrXCIgKyAxLCBkMiksXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBcIitmK1wiICsgMiwgZDIpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLFhvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9dC5vdXRTaGFwZTt2YXIgZT10LmluSGVpZ2h0LG49dC5pbldpZHRoLHI9dC5wYWRJbmZvLnRvcCxvPXQucGFkSW5mby5sZWZ0LGE9dC5zdHJpZGVIZWlnaHQsaT10LnN0cmlkZVdpZHRoLHM9dC5kaWxhdGlvbkhlaWdodCx1PXQuZGlsYXRpb25XaWR0aCxsPXQuZmlsdGVySGVpZ2h0LGM9dC5maWx0ZXJXaWR0aCxoPXQub3V0Q2hhbm5lbHMvdC5pbkNoYW5uZWxzO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIrYStcIiwgXCIraStcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK3IrXCIsIFwiK28rXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xcbiAgICAgICAgaW50IGQxID0gZDIgLyBcIitoK1wiO1xcbiAgICAgICAgaW50IHEgPSBkMiAtIGQxICogXCIraCtcIjtcXG5cXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIHcoOiwgOiwgZDEsIHEpIHRvIGdldCB5KHlSLCB5QywgZDIpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgLy8gVE9ETyhkc21pbGtvdik6IEZsYXR0ZW4gdGhlIHR3byBmb3IgbG9vcHMgYW5kIHZlYzQgdGhlIG9wZXJhdGlvbnMuXFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrbCtcIjsgd1IrKykge1xcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSICogXCIrcytcIjtcXG5cXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIitlK1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK2MrXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogXCIrdStcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK24rXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmbG9hdCB4VmFsID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgZmxvYXQgd1ZhbCA9IGdldFcod1IsIHdDLCBkMSwgcSk7XFxuICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsICogd1ZhbDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLFlvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJXXCJdLHRoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwLHRoaXMub3V0cHV0U2hhcGU9dC5vdXRTaGFwZTtmb3IodmFyIGU9dC5pbkhlaWdodCxuPXQuaW5XaWR0aCxyPXQucGFkSW5mby50b3Asbz10LnBhZEluZm8ubGVmdCxhPXQuc3RyaWRlSGVpZ2h0LGk9dC5zdHJpZGVXaWR0aCxzPXQuZGlsYXRpb25IZWlnaHQsdT10LmRpbGF0aW9uV2lkdGgsbD10LmZpbHRlckhlaWdodCxjPXQuZmlsdGVyV2lkdGgsaD1jLGY9XCJpbnQgeFI7IGludCB4QzsgaW50IHhDT2Zmc2V0O1wiLGQ9MDtkPGw7ZCsrKWZvcih2YXIgdj0wO3Y8Yzt2KyspZis9XCJcXG4gICAgICAgICAgdmVjNCB4VGV4ZWxSXCIrZCtcIkNcIisyKnYrXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgdmVjNCB3UlwiK2QrXCJDXCIrditcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICB2ZWM0IHhSXCIrZCtcIkNcIit2K1wiID0gdmVjNCgwLik7XCI7Zm9yKGQ9MDtkPGw7ZCsrKWZvcih2YXIgbT0wO208aDttKyspe2lmKGYrPVwiXFxuICAgICAgICAgIHhSID0geFJDb3JuZXIgKyBcIitkKnMrXCI7XFxuICAgICAgICAgIHhDID0geENDb3JuZXIgKyBcIisodj0yKm0pKnUrXCI7XFxuICAgICAgICBcIiwxPT09aSl7aWYodjxjJiYoZis9byUyPT0xP1wiXFxuICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxO1xcbiAgICAgICAgICAgICAgICBpZih4UiA+PSAwICYmIHhSIDwgXCIrZStcIiAmJiB4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIrbitcIikge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitkK1wiQ1wiK3YrXCIgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZCtcIkNcIit2K1wiID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIDEgLSAyO1xcbiAgICAgICAgICAgICAgICBpZih4UiA+PSAwICYmIHhSIDwgXCIrZStcIiAmJiB4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIrbitcIikge1xcbiAgICAgICAgICAgICAgICAgIHZlYzQgcHJldmlvdXMgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcXG4gICAgICAgICAgICAgICAgICB4UlwiK2QrXCJDXCIrditcIiA9IHZlYzQocHJldmlvdXMuencsIHhUZXhlbFJcIitkK1wiQ1wiK3YrXCIueHkpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIHhSXCIrZCtcIkNcIit2K1wiID0gdmVjNCgwLCAwLCB4VGV4ZWxSXCIrZCtcIkNcIit2K1wiLnh5KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgXCI6XCJcXG4gICAgICAgICAgICAgICAgaWYoeFIgPj0gMCAmJiB4UiA8IFwiK2UrXCIgJiYgeEMgPj0gMCAmJiB4QyA8IFwiK24rXCIpIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZCtcIkNcIit2K1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2QrXCJDXCIrditcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHhSXCIrZCtcIkNcIit2K1wiID0geFRleGVsUlwiK2QrXCJDXCIrditcIjtcXG4gICAgICAgICAgICAgIFwiLHYrMTxjKSl7dmFyIGc9byUyPT0wP3AodSk6dTt1JTI9PTAmJm8lMj09MXx8dSUyIT0wJiZvJTIhPTE/KGYrPVwiXFxuICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIFwiK28lMitcIiArIFwiK2crXCI7XFxuXFxuICAgICAgICAgICAgICAgICAgaWYoeFIgPj0gMCAmJiB4UiA8IFwiK2UrXCIgJiZcXG4gICAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIituK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZCtcIkNcIisodisyKStcIiA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgXCIsdT4xJiYoZis9XCJcXG4gICAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0IC09IDI7XFxuICAgICAgICAgICAgICAgICAgICBpZih4UiA+PSAwICYmIHhSIDwgXCIrZStcIiAmJlxcbiAgICAgICAgICAgICAgICAgICAgICB4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIrbitcIikge1xcbiAgICAgICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZCtcIkNcIit2K1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZCtcIkNcIit2K1wiID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgXCIpLGYrPVwiXFxuICAgICAgICAgICAgICAgICAgeFJcIitkK1wiQ1wiKyh2KzEpK1wiID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitkK1wiQ1wiK3YrXCIuencsIHhUZXhlbFJcIitkK1wiQ1wiKyh2KzIpK1wiLnh5KTtcXG4gICAgICAgICAgICAgICAgXCIpOmYrPVwiXFxuICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIFwiK2crXCI7XFxuXFxuICAgICAgICAgICAgICAgICAgaWYoeFIgPj0gMCAmJiB4UiA8IFwiK2UrXCIgJiZcXG4gICAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIituK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZCtcIkNcIisodisyKStcIiA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcbiAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICB4UlwiK2QrXCJDXCIrKHYrMSkrXCIgPSB4VGV4ZWxSXCIrZCtcIkNcIisodisyKStcIjtcXG4gICAgICAgICAgICAgICAgXCJ9fWVsc2UgdjxjJiYoZis9XCJcXG4gICAgICAgICAgICAgIGlmKHhSID49IDAgJiYgeFIgPCBcIitlK1wiKSB7XFxuICAgICAgICAgICAgXCIsbyUyPT0xPyhmKz1cIlxcbiAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgMSAtIFwiK2krXCI7XFxuICAgICAgICAgICAgICAgIGlmKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIituK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2QrXCJDXCIrditcIiA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitkK1wiQ1wiK3YrXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZih4QyArIDEgPj0gMCAmJiB4QyArIDEgPCBcIituK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2QrXCJDXCIrKHYrMikrXCIgPSBnZXRYKGJhdGNoLCB4UiwgeEMgKyAxLCBkMSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2QrXCJDXCIrKHYrMikrXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB4UlwiK2QrXCJDXCIrditcIiA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2QrXCJDXCIrditcIi56dywgeFRleGVsUlwiK2QrXCJDXCIrKHYrMikrXCIuencpO1xcbiAgICAgICAgICAgICAgXCIsdisxPGMmJihmKz1cIlxcbiAgICAgICAgICAgICAgICAgIHZlYzQgZmluYWwgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgMSArIFwiK2krXCI7XFxuICAgICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IFwiK24rXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgIHhSXCIrZCtcIkNcIisodisxKStcIiA9IHZlYzQoeFRleGVsUlwiK2QrXCJDXCIrKHYrMikrXCIueHksIGZpbmFsLnh5KTtcXG4gICAgICAgICAgICAgICAgXCIpKTooZis9XCJcXG4gICAgICAgICAgICAgICAgaWYoeEMgPj0gMCAmJiB4QyA8IFwiK24rXCIpIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZCtcIkNcIit2K1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2QrXCJDXCIrditcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyBcIitpK1wiO1xcbiAgICAgICAgICAgICAgICBpZih4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIrbitcIikge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitkK1wiQ1wiKyh2KzIpK1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2QrXCJDXCIrKHYrMikrXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB4UlwiK2QrXCJDXCIrditcIiA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2QrXCJDXCIrditcIi54eSwgeFRleGVsUlwiK2QrXCJDXCIrKHYrMikrXCIueHkpO1xcbiAgICAgICAgICAgICAgXCIsdisxPGMmJihmKz1cIlxcbiAgICAgICAgICAgICAgICAgIHhSXCIrZCtcIkNcIisodisxKStcIiA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZCtcIkNcIit2K1wiLnp3LCB4VGV4ZWxSXCIrZCtcIkNcIisodisyKStcIi56dyk7XFxuICAgICAgICAgICAgICAgIFwiKSksZis9XCJ9XCIpO3Y8YyYmKGYrPVwiXFxuICAgICAgICAgICAgdmVjNCB3VGV4ZWxSXCIrZCtcIkNcIit2K1wiID0gZ2V0VyhcIitkK1wiLCBcIit2K1wiLCBkMSwgcSk7XFxuICAgICAgICAgICAgd1JcIitkK1wiQ1wiK3YrXCIgPSB2ZWM0KHdUZXhlbFJcIitkK1wiQ1wiK3YrXCIueHosIHdUZXhlbFJcIitkK1wiQ1wiK3YrXCIueHopO1xcbiAgICAgICAgICBcIix2KzE8YyYmKGYrPVwiXFxuICAgICAgICAgICAgICB2ZWM0IHdUZXhlbFJcIitkK1wiQ1wiKyh2KzEpK1wiID0gZ2V0VyhcIitkK1wiLCBcIisodisxKStcIiwgZDEsIHEpO1xcbiAgICAgICAgICAgICAgd1JcIitkK1wiQ1wiKyh2KzEpK1wiID1cXG4gICAgICAgICAgICAgICAgdmVjNCh3VGV4ZWxSXCIrZCtcIkNcIisodisxKStcIi54eiwgd1RleGVsUlwiK2QrXCJDXCIrKHYrMSkrXCIueHopO1wiKSl9Zm9yKGQ9MDtkPGw7ZCsrKWZvcih2PTA7djxjO3YrKylmKz1cInJlc3VsdCArPSB4UlwiK2QrXCJDXCIrditcIiAqIHdSXCIrZCtcIkNcIit2K1wiO1wiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIrYStcIiwgXCIraStcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK3IrXCIsIFwiK28rXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG5cXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xcbiAgICAgICAgaW50IGQxID0gZDI7XFxuICAgICAgICBpbnQgcSA9IDA7XFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG5cXG4gICAgICAgIFwiK2YrXCJcXG5cXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLFFvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIsbyl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkltYWdlXCIsXCJCb3hlc1wiLFwiQm94SW5kXCJdLHRoaXMub3V0cHV0U2hhcGU9W107dmFyIGE9dFswXSxpPXRbMV0scz10WzJdLHU9dFszXSxsPWVbMF0sYz1uWzBdLGg9blsxXTt0aGlzLm91dHB1dFNoYXBlPVtsLGMsaCx1XTt2YXIgcD1cImJpbGluZWFyXCI9PT1yPzE6MCxmPVtpLTErXCIuMFwiLHMtMStcIi4wXCJdLGQ9ZlswXSx2PWZbMV0sbT1jPjE/W1wiXCIrKGktMSkvKGMtMSksXCIoeTIteTEpICogaGVpZ2h0X3JhdGlvXCIsXCJ5MSpcIitkK1wiICsgZmxvYXQoeSkqKGhlaWdodF9zY2FsZSlcIl06W1wiMC4wXCIsXCIwLjBcIixcIjAuNSAqICh5MSt5MikgKiBcIitkXSxnPW1bMF0seT1tWzFdLHg9bVsyXSx3PWg+MT9bXCJcIisocy0xKS8oaC0xKSxcIih4Mi14MSkgKiB3aWR0aF9yYXRpb1wiLFwieDEqXCIrditcIiArIGZsb2F0KHgpKih3aWR0aF9zY2FsZSlcIl06W1wiMC4wXCIsXCIwLjBcIixcIjAuNSAqICh4MSt4MikgKiBcIit2XSxiPXdbMF0sQz13WzFdLEU9d1syXTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgZmxvYXQgaGVpZ2h0X3JhdGlvID0gZmxvYXQoXCIrZytcIik7XFxuICAgICAgY29uc3QgZmxvYXQgd2lkdGhfcmF0aW8gPSBmbG9hdChcIitiK1wiKTtcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IHkgPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgeCA9IGNvb3Jkc1syXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgLy8gZ2V0IGJveCB2YWxzXFxuICAgICAgICBmbG9hdCB5MSA9IGdldEJveGVzKGIsMCk7XFxuICAgICAgICBmbG9hdCB4MSA9IGdldEJveGVzKGIsMSk7XFxuICAgICAgICBmbG9hdCB5MiA9IGdldEJveGVzKGIsMik7XFxuICAgICAgICBmbG9hdCB4MiA9IGdldEJveGVzKGIsMyk7XFxuXFxuICAgICAgICAvLyBnZXQgaW1hZ2UgaW4gYmF0Y2ggaW5kZXhcXG4gICAgICAgIGludCBiSW5kID0gcm91bmQoZ2V0Qm94SW5kKGIpKTtcXG4gICAgICAgIGlmKGJJbmQgPCAwIHx8IGJJbmQgPj0gXCIrYStcIikge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmbG9hdCBoZWlnaHRfc2NhbGUgPSBcIit5K1wiO1xcbiAgICAgICAgZmxvYXQgd2lkdGhfc2NhbGUgPSBcIitDK1wiO1xcblxcbiAgICAgICAgZmxvYXQgaW5feSA9IFwiK3grXCI7XFxuICAgICAgICBpZiggaW5feSA8IDAuMCB8fCBpbl95ID4gXCIrZCtcIiApIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiK28rXCIpKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmxvYXQgaW5feCA9IFwiK0UrXCI7XFxuICAgICAgICBpZiggaW5feCA8IDAuMCB8fCBpbl94ID4gXCIrditcIiApIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiK28rXCIpKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmVjMiBzb3VyY2VGcmFjSW5kZXhDUiA9IHZlYzIoaW5feCxpbl95KTtcXG4gICAgICAgIGlmKFwiK3ArXCIgPT0gMSkge1xcbiAgICAgICAgICAvLyBDb21wdXRlIHRoZSBmb3VyIGludGVnZXIgaW5kaWNlcy5cXG4gICAgICAgICAgaXZlYzIgc291cmNlRmxvb3JDUiA9IGl2ZWMyKHNvdXJjZUZyYWNJbmRleENSKTtcXG4gICAgICAgICAgaXZlYzIgc291cmNlQ2VpbENSID0gaXZlYzIoY2VpbChzb3VyY2VGcmFjSW5kZXhDUikpO1xcblxcbiAgICAgICAgICBmbG9hdCB0b3BMZWZ0ID0gZ2V0SW1hZ2UoYiwgc291cmNlRmxvb3JDUi55LCBzb3VyY2VGbG9vckNSLngsIGQpO1xcbiAgICAgICAgICBmbG9hdCBib3R0b21MZWZ0ID0gZ2V0SW1hZ2UoYiwgc291cmNlQ2VpbENSLnksIHNvdXJjZUZsb29yQ1IueCwgZCk7XFxuICAgICAgICAgIGZsb2F0IHRvcFJpZ2h0ID0gZ2V0SW1hZ2UoYiwgc291cmNlRmxvb3JDUi55LCBzb3VyY2VDZWlsQ1IueCwgZCk7XFxuICAgICAgICAgIGZsb2F0IGJvdHRvbVJpZ2h0ID0gZ2V0SW1hZ2UoYiwgc291cmNlQ2VpbENSLnksIHNvdXJjZUNlaWxDUi54LCBkKTtcXG5cXG4gICAgICAgICAgdmVjMiBmcmFjQ1IgPSBzb3VyY2VGcmFjSW5kZXhDUiAtIHZlYzIoc291cmNlRmxvb3JDUik7XFxuXFxuICAgICAgICAgIGZsb2F0IHRvcCA9IHRvcExlZnQgKyAodG9wUmlnaHQgLSB0b3BMZWZ0KSAqIGZyYWNDUi54O1xcbiAgICAgICAgICBmbG9hdCBib3R0b20gPSBib3R0b21MZWZ0ICsgKGJvdHRvbVJpZ2h0IC0gYm90dG9tTGVmdCkgKiBmcmFjQ1IueDtcXG4gICAgICAgICAgZmxvYXQgbmV3VmFsdWUgPSB0b3AgKyAoYm90dG9tIC0gdG9wKSAqIGZyYWNDUi55O1xcbiAgICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29vcmRpbmF0b3JzIG9mIG5lYXJlc3QgbmVpZ2hib3IgcG9pbnQuXFxuICAgICAgICAgIGl2ZWMyIHNvdXJjZU5lYXJlc3RDUiA9IGl2ZWMyKGZsb29yKFxcbiAgICAgICAgICAgIHNvdXJjZUZyYWNJbmRleENSICsgdmVjMigwLjUsMC41KSkpO1xcbiAgICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IGdldEltYWdlKGIsIHNvdXJjZU5lYXJlc3RDUi55LCBzb3VyY2VOZWFyZXN0Q1IueCwgZCk7XFxuICAgICAgICAgIHNldE91dHB1dChuZXdWYWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICBcIn19KCksSm89ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMub3V0cHV0U2hhcGU9dDt2YXIgcj10Lmxlbmd0aCxvPXRbdC5sZW5ndGgtMV0sYT1uP1wiPFwiOlwiPlwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBpbnQgZ2V0SW5kZXgoaW50IGkpIHtcXG4gICAgICAgIFwiKyhuP1wicmV0dXJuIFwiK28rXCIgLWkgLSAxO1wiOlwicmV0dXJuIGk7XCIpK1wiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK2JvKHIpK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGVuZCA9IFwiK1pvKHIsXCJjb29yZHNcIikrXCI7XFxuICAgICAgICBmbG9hdCB2YWwgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCBpID0gXCIrbytcIiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XFxuICAgICAgICAgIGludCBpZHggPSBnZXRJbmRleChpKTtcXG4gICAgICAgICAgaWYgKGlkeCBcIithK1wiIGVuZCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChpZHggPT0gZW5kICYmIFwiK2UrXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBcIitabyhyLFwiY29vcmRzXCIpK1wiID0gaWR4O1xcbiAgICAgICAgICB2YWwgKz0gZ2V0WChcIitmdW5jdGlvbih0LGUpe2lmKDE9PT10KXJldHVyblwiXCIrZTtpZigyPT09dClyZXR1cm4gZStcIi54LCBcIitlK1wiLnlcIjtpZigzPT09dClyZXR1cm4gZStcIi54LCBcIitlK1wiLnksIFwiK2UrXCIuelwiO2lmKDQ9PT10KXJldHVybiBlK1wiLngsIFwiK2UrXCIueSwgXCIrZStcIi56LCBcIitlK1wiLndcIjt0aHJvdyBFcnJvcihcIkN1bXVsYXRpdmUgc3VtIGZvciByYW5rIFwiK3QrXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIil9KHIsXCJjb29yZHNcIikrXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KHZhbCk7XFxuICAgICAgfVxcbiAgICBcIn19KCk7ZnVuY3Rpb24gWm8odCxlKXtpZigxPT09dClyZXR1cm5cIlwiK2U7aWYoMj09PXQpcmV0dXJuIGUrXCIueVwiO2lmKDM9PT10KXJldHVybiBlK1wiLnpcIjtpZig0PT09dClyZXR1cm4gZStcIi53XCI7dGhyb3cgRXJyb3IoXCJDdW11bGF0aXZlIHN1bSBmb3IgcmFuayBcIit0K1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpfXZhciB0YT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMuYmxvY2tTaXplPWUsdGhpcy5kYXRhRm9ybWF0PW4sdGhpcy51c2VyQ29kZT1cIlxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgaW50IGggPSBcIit0aGlzLmdldEhlaWdodENvb3JkU3RyaW5nKCkrXCI7XFxuICAgICAgaW50IHcgPSBcIit0aGlzLmdldFdpZHRoQ29vcmRTdHJpbmcoKStcIjtcXG4gICAgICBpbnQgZCA9IFwiK3RoaXMuZ2V0RGVwdGhDb29yZFN0cmluZygpK1wiO1xcblxcbiAgICAgIGludCBpbl9oID0gaCAvIFwiK2UrXCI7XFxuICAgICAgaW50IG9mZnNldF9oID0gaW1vZChoLCBcIitlK1wiKTtcXG4gICAgICBpbnQgaW5fdyA9IHcgLyBcIitlK1wiO1xcbiAgICAgIGludCBvZmZzZXRfdyA9IGltb2QodywgXCIrZStcIik7XFxuICAgICAgaW50IG9mZnNldF9kID0gKG9mZnNldF9oICogXCIrZStcIiArIG9mZnNldF93KSAqXFxuICAgICAgICBcIit0aGlzLmdldE91dHB1dERlcHRoU2l6ZSgpK1wiO1xcbiAgICAgIGludCBpbl9kID0gZCArIG9mZnNldF9kO1xcblxcbiAgICAgIGZsb2F0IHJlc3VsdCA9IFwiK3RoaXMuZ2V0SW5wdXRTYW1wbGluZ1N0cmluZygpK1wiO1xcbiAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICB9XFxuICBcIn1yZXR1cm4gdC5wcm90b3R5cGUuZ2V0SGVpZ2h0Q29vcmRTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIk5IV0NcIj09PXRoaXMuZGF0YUZvcm1hdD9cImNvb3Jkc1sxXVwiOlwiY29vcmRzWzJdXCJ9LHQucHJvdG90eXBlLmdldFdpZHRoQ29vcmRTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIk5IV0NcIj09PXRoaXMuZGF0YUZvcm1hdD9cImNvb3Jkc1syXVwiOlwiY29vcmRzWzNdXCJ9LHQucHJvdG90eXBlLmdldERlcHRoQ29vcmRTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIk5IV0NcIj09PXRoaXMuZGF0YUZvcm1hdD9cImNvb3Jkc1szXVwiOlwiY29vcmRzWzFdXCJ9LHQucHJvdG90eXBlLmdldE91dHB1dERlcHRoU2l6ZT1mdW5jdGlvbigpe3JldHVyblwiTkhXQ1wiPT09dGhpcy5kYXRhRm9ybWF0P3RoaXMub3V0cHV0U2hhcGVbM106dGhpcy5vdXRwdXRTaGFwZVsxXX0sdC5wcm90b3R5cGUuZ2V0SW5wdXRTYW1wbGluZ1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiTkhXQ1wiPT09dGhpcy5kYXRhRm9ybWF0P1wiZ2V0WChiLCBpbl9oLCBpbl93LCBpbl9kKVwiOlwiZ2V0WChiLCBpbl9kLCBpbl9oLCBpbl93KVwifSx0fSgpLGVhPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdO3ZhciBlPXVvKCk7dGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBmbG9hdCBGTE9BVF9NQVggPSAxLjcwMTQxMTg0ZTM4O1xcbiAgICAgIGNvbnN0IGZsb2F0IEZMT0FUX01JTiA9IDEuMTc1NDk0MzVlLTM4O1xcblxcbiAgICAgIGxvd3AgdmVjNCBlbmNvZGVfZmxvYXQoaGlnaHAgZmxvYXQgdikge1xcbiAgICAgICAgaWYgKGlzbmFuKHYpKSB7XFxuICAgICAgICAgIHJldHVybiB2ZWM0KDI1NSwgMjU1LCAyNTUsIDI1NSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBoaWdocCBmbG9hdCBhdiA9IGFicyh2KTtcXG5cXG4gICAgICAgIGlmKGF2IDwgRkxPQVRfTUlOKSB7XFxuICAgICAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuICAgICAgICB9IGVsc2UgaWYodiA+IEZMT0FUX01BWCkge1xcbiAgICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMTI4LjAsIDEyNy4wKSAvIDI1NS4wO1xcbiAgICAgICAgfSBlbHNlIGlmKHYgPCAtRkxPQVRfTUFYKSB7XFxuICAgICAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAgMTI4LjAsIDI1NS4wKSAvIDI1NS4wO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaGlnaHAgdmVjNCBjID0gdmVjNCgwLDAsMCwwKTtcXG5cXG4gICAgICAgIGhpZ2hwIGZsb2F0IGUgPSBmbG9vcihsb2cyKGF2KSk7XFxuICAgICAgICBoaWdocCBmbG9hdCBtID0gZXhwMihmcmFjdChsb2cyKGF2KSkpIC0gMS4wO1xcblxcbiAgICAgICAgY1syXSA9IGZsb29yKDEyOC4wICogbSk7XFxuICAgICAgICBtIC09IGNbMl0gLyAxMjguMDtcXG4gICAgICAgIGNbMV0gPSBmbG9vcigzMjc2OC4wICogbSk7XFxuICAgICAgICBtIC09IGNbMV0gLyAzMjc2OC4wO1xcbiAgICAgICAgY1swXSA9IGZsb29yKDgzODg2MDguMCAqIG0pO1xcblxcbiAgICAgICAgaGlnaHAgZmxvYXQgZWJpYXMgPSBlICsgMTI3LjA7XFxuICAgICAgICBjWzNdID0gZmxvb3IoZWJpYXMgLyAyLjApO1xcbiAgICAgICAgZWJpYXMgLT0gY1szXSAqIDIuMDtcXG4gICAgICAgIGNbMl0gKz0gZmxvb3IoZWJpYXMpICogMTI4LjA7XFxuXFxuICAgICAgICBjWzNdICs9IDEyOC4wICogc3RlcCgwLjAsIC12KTtcXG5cXG4gICAgICAgIHJldHVybiBjIC8gMjU1LjA7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIFwiK2Uub3V0cHV0K1wiID0gZW5jb2RlX2Zsb2F0KHgpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLG5hPVwicmV0dXJuIHJlYWwgKiBleHBSIC0gaW1hZyAqIGV4cEk7XCIscmE9XCJyZXR1cm4gcmVhbCAqIGV4cEkgKyBpbWFnICogZXhwUjtcIixvYT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInJlYWxcIixcImltYWdcIl07dmFyIHI9ZVsxXTt0aGlzLm91dHB1dFNoYXBlPWU7dmFyIG89bj9cIjIuMCAqIFwiK01hdGguUEk6XCItMi4wICogXCIrTWF0aC5QSSxhPW4/citcIi4wXCI6XCIxLjBcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgZmxvYXQgZXhwb25lbnRNdWx0aXBsaWVyID0gXCIrbytcIjtcXG5cXG4gICAgICBmbG9hdCB1bmFyeU9wQ29tcGxleChmbG9hdCByZWFsLCBmbG9hdCBleHBSLCBmbG9hdCBpbWFnLCBmbG9hdCBleHBJKSB7XFxuICAgICAgICBcIit0K1wiXFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IG11bE1hdERGVChpbnQgYmF0Y2gsIGludCBpbmRleCkge1xcbiAgICAgICAgZmxvYXQgaW5kZXhSYXRpbyA9IGZsb2F0KGluZGV4KSAvIGZsb2F0KFwiK3IrXCIpO1xcbiAgICAgICAgZmxvYXQgZXhwb25lbnRNdWx0aXBsaWVyVGltZXNJbmRleFJhdGlvID1cXG4gICAgICAgICAgICBleHBvbmVudE11bHRpcGxpZXIgKiBpbmRleFJhdGlvO1xcblxcbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIityK1wiOyBpKyspIHtcXG4gICAgICAgICAgLy8geCA9ICgtMnwyICogUEkgLyBOKSAqIGluZGV4ICogaTtcXG4gICAgICAgICAgZmxvYXQgeCA9IGV4cG9uZW50TXVsdGlwbGllclRpbWVzSW5kZXhSYXRpbyAqIGZsb2F0KGkpO1xcbiAgICAgICAgICBmbG9hdCBleHBSID0gY29zKHgpO1xcbiAgICAgICAgICBmbG9hdCBleHBJID0gc2luKHgpO1xcbiAgICAgICAgICBmbG9hdCByZWFsID0gZ2V0UmVhbChiYXRjaCwgaSk7XFxuICAgICAgICAgIGZsb2F0IGltYWcgPSBnZXRJbWFnKGJhdGNoLCBpKTtcXG5cXG4gICAgICAgICAgcmVzdWx0ICs9XFxuICAgICAgICAgICAgICB1bmFyeU9wQ29tcGxleChyZWFsLCBleHBSLCBpbWFnLCBleHBJKSAvIFwiK2ErXCI7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChtdWxNYXRERlQoY29vcmRzWzBdLCBjb29yZHNbMV0pKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxhYT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdW5pZm9ybSBmbG9hdCB2YWx1ZTtcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAvLyBJbnB1dCBjYW4gYmUgb2J0YWluZWQgZnJvbSB1bmlmb3JtIHZhbHVlLlxcbiAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwifXJldHVybiB0LnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztyZXR1cm4gZnVuY3Rpb24obixyKXtudWxsPT1lLnZhbHVlTG9jJiYoZS52YWx1ZUxvYz1uLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cocixcInZhbHVlXCIpKSxuLmdsLnVuaWZvcm0xZihlLnZhbHVlTG9jLHQpfX0sdH0oKSxpYT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXTt2YXIgZT11bygpLG49dFswXSxyPXRbMV07dGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCB0ZXhSID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IHRleEMgPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgZGVwdGggPSBjb29yZHNbMl07XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMihcIityK1wiLjAsIFwiK24rXCIuMCk7XFxuXFxuICAgICAgICB2ZWM0IHZhbHVlcyA9IFwiK2UudGV4dHVyZTJEK1wiKEEsIHV2KTtcXG4gICAgICAgIGZsb2F0IHZhbHVlO1xcbiAgICAgICAgaWYgKGRlcHRoID09IDApIHtcXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMucjtcXG4gICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMSkge1xcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5nO1xcbiAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAyKSB7XFxuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmI7XFxuICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDMpIHtcXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuYTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHNldE91dHB1dChmbG9vcih2YWx1ZSAqIDI1NS4wICsgMC41KSk7XFxuICAgICAgfVxcbiAgICBcIn19KCksc2E9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCIsXCJpbmRpY2VzXCJdO3ZhciByPXQuc2xpY2UoKTtyW25dPWUsdGhpcy5vdXRwdXRTaGFwZT1yLHRoaXMucmFuaz1yLmxlbmd0aDt2YXIgbz1ibyh0aGlzLnJhbmspLGE9ZnVuY3Rpb24odCxlKXt2YXIgbj10Lmxlbmd0aDtpZihuPjQpdGhyb3cgRXJyb3IoXCJHYXRoZXIgZm9yIHJhbmsgXCIrbitcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtpZigxPT09bilyZXR1cm5cImludChnZXRJbmRpY2VzKHJlc1JDKSlcIjtmb3IodmFyIHI9W1wicmVzUkMueFwiLFwicmVzUkMueVwiLFwicmVzUkMuelwiLFwicmVzUkMud1wiXSxvPVtdLGE9MDthPHQubGVuZ3RoO2ErKylhPT09ZT9vLnB1c2goXCJpbnQoZ2V0SW5kaWNlcyhcIityW2FdK1wiKSlcIik6by5wdXNoKFwiXCIrclthXSk7cmV0dXJuIG8uam9pbigpfSh0LG4pO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitvK1wiIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0QShcIithK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIn19KCk7dmFyIHVhLGxhLGNhPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt0aGlzLnNsaWNlRGltPXQsdGhpcy5zdHJpZGVzPWUsdGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcImluZGljZXNcIl0sdGhpcy5vdXRwdXRTaGFwZT1uO3ZhciByPWJvKGUubGVuZ3RoKSxvPWJvKG4ubGVuZ3RoKSxhPXRoaXMuc2xpY2VEaW0+MT9cInN0cmlkZXNbal1cIjpcInN0cmlkZXNcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgICBcIityK1wiIHN0cmlkZXMgPSBcIityK1wiKFwiK3RoaXMuc3RyaWRlcytcIik7XFxuICAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBcIitvK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBpbnQgZmxhdHRlbkluZGV4ID0gMDtcXG4gICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBcIit0aGlzLnNsaWNlRGltK1wiOyBqKyspIHtcXG4gICAgICAgICAgICBpbnQgaW5kZXggPSByb3VuZChnZXRJbmRpY2VzKGNvb3Jkc1swXSwgaikpO1xcbiAgICAgICAgICAgIGZsYXR0ZW5JbmRleCArPSBpbmRleCAqIFwiK2ErXCI7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc2V0T3V0cHV0KGdldFgoZmxhdHRlbkluZGV4LCBjb29yZHNbMV0pKTtcXG4gICAgICAgIH1cXG4gICAgICBcIn19KCk7ZnVuY3Rpb24gaGEodCxlKXtyZXR1cm5bZSx0XX1mdW5jdGlvbiBwYSh0LGUpe3JldHVybiB0KmV9ZnVuY3Rpb24gZmEodCxlLG4pe3ZhciByPWZ1bmN0aW9uKHQsZSl7aWYodCVlIT0wKXRocm93IG5ldyBFcnJvcihcInVucGFja2VkU2l6ZSAoXCIrdCtcIikgbXVzdCBiZSBhIG11bHRpcGxlIG9mIFwiK2UpO3JldHVybiB0L2V9KHQubGVuZ3RoLG4pO2lmKGUubGVuZ3RoPHIpdGhyb3cgbmV3IEVycm9yKFwibWF0cml4IGxlbmd0aCAoXCIrZS5sZW5ndGgrXCIpIG11c3QgYmUgPj0gXCIrcik7Zm9yKHZhciBvPTAsYT0wO2E8dC5sZW5ndGg7YSs9billW28rK109dFthXX1mdW5jdGlvbiBkYSh0LGUpe3JldHVybltNYXRoLm1heCgxLE1hdGguY2VpbChlLzIpKSxNYXRoLm1heCgxLE1hdGguY2VpbCh0LzIpKV19ZnVuY3Rpb24gdmEodCxlKXt2YXIgbj1kYSh0LGUpO3JldHVybiBuWzBdKm5bMV0qNH1mdW5jdGlvbiBtYSh0LGUsbixyLG8pe3ZhciBhPW4qcjtpZihvLmxlbmd0aDxhKXRocm93IG5ldyBFcnJvcihcIm1hdHJpeCBsZW5ndGggKFwiK28ubGVuZ3RoK1wiKSBtdXN0IGJlID49IFwiK2EpO2Zvcih2YXIgaT1yJTI9PTEscz1uJTI9PTEsdT1NYXRoLmZsb29yKHIvMiksbD1NYXRoLmZsb29yKG4vMiksYz1NYXRoLmNlaWwoci8yKSxoPWMqTWF0aC5jZWlsKG4vMiksZj1wKG4pKnAociksZD0wO2Q8ZTtkKyspe2Zvcih2YXIgdj1kKm4qcixtPWQqZixnPWk/NDowLHk9cisoaT8xOjApLHg9bSx3PXYsYj12K3IsQz0wO0M8bDsrK0Mpe2Zvcih2YXIgRT0wO0U8dTsrK0Upb1t3KytdPXRbeCsrXSxvW3crK109dFt4KytdLG9bYisrXT10W3grK10sb1tiKytdPXRbeCsrXTt4Kz1nLHcrPXksYis9eX1pZihpKXt4PW0rNCooYy0xKTt2YXIgUj12K3ItMTtmb3IoZz00KmMseT0yKnIsQz0wO0M8bDsrK0Mpb1tSXT10W3hdLG9bUityXT10W3grMl0seCs9ZyxSKz15fWlmKHMpe2Zvcih4PW0rNCooaC1jKSxSPXYrKG4tMSkqcixFPTA7RTx1OysrRSlvW1IrK109dFt4KytdLG9bUisrXT10W3grK10seCs9MjtpJiYob1t2K24qci0xXT10W3hdKX19cmV0dXJuIG99ZnVuY3Rpb24gZ2EodCxlKXt2YXIgbj11bygpO3JldHVybiBWdCh0LGUsbi52ZXJzaW9uK1wiXFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gICAgXCIrbi5hdHRyaWJ1dGUrXCIgdmVjMyBjbGlwU3BhY2VQb3M7XFxuICAgIFwiK24uYXR0cmlidXRlK1wiIHZlYzIgdXY7XFxuICAgIFwiK24udmFyeWluZ1ZzK1wiIHZlYzIgcmVzdWx0VVY7XFxuXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoY2xpcFNwYWNlUG9zLCAxKTtcXG4gICAgICByZXN1bHRVViA9IHV2O1xcbiAgICB9XCIpfWZ1bmN0aW9uIHlhKHQsZSl7cmV0dXJuIFl0KHQsZSxuZXcgRmxvYXQzMkFycmF5KFstMSwxLDAsMCwxLC0xLC0xLDAsMCwwLDEsMSwwLDEsMSwxLC0xLDAsMSwwXSkpfWZ1bmN0aW9uIHhhKHQsZSl7cmV0dXJuIFF0KHQsZSxuZXcgVWludDE2QXJyYXkoWzAsMSwyLDIsMSwzXSkpfWZ1bmN0aW9uIHdhKHQsZSl7dmFyIG4scixvLGkscyx1LGwsYyxoPXQ7cmV0dXJuIDI9PT1hLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik/KG49aC5SMzJGLHI9aC5SMTZGLG89aC5SR0JBMTZGLGk9aC5SR0JBMzJGLHM9aC5SRUQsdT00LGw9MSxjPWguSEFMRl9GTE9BVCk6KG49dC5SR0JBLHI9dC5SR0JBLG89dC5SR0JBLGk9aC5SR0JBLHM9dC5SR0JBLHU9NCxsPTQsYz1udWxsIT1lP2UuSEFMRl9GTE9BVF9PRVM6bnVsbCkse2ludGVybmFsRm9ybWF0RmxvYXQ6bixpbnRlcm5hbEZvcm1hdEhhbGZGbG9hdDpyLGludGVybmFsRm9ybWF0UGFja2VkSGFsZkZsb2F0Om8saW50ZXJuYWxGb3JtYXRQYWNrZWRGbG9hdDppLHRleHR1cmVGb3JtYXRGbG9hdDpzLGRvd25sb2FkVGV4dHVyZUZvcm1hdDp0LlJHQkEsZG93bmxvYWRVbnBhY2tOdW1DaGFubmVsczp1LGRlZmF1bHROdW1DaGFubmVsczpsLHRleHR1cmVUeXBlSGFsZkZsb2F0OmN9fWZ1bmN0aW9uIGJhKHQsZSxuLHIsbyxhLGkpe3RlKG4scik7dmFyIHM9WnQodCxlKSx1PXQuVEVYVFVSRV8yRDtyZXR1cm4gQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZFRleHR1cmUodSxzKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LnRleFBhcmFtZXRlcmkodSx0LlRFWFRVUkVfV1JBUF9TLHQuQ0xBTVBfVE9fRURHRSl9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC50ZXhQYXJhbWV0ZXJpKHUsdC5URVhUVVJFX1dSQVBfVCx0LkNMQU1QX1RPX0VER0UpfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQudGV4UGFyYW1ldGVyaSh1LHQuVEVYVFVSRV9NSU5fRklMVEVSLHQuTkVBUkVTVCl9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC50ZXhQYXJhbWV0ZXJpKHUsdC5URVhUVVJFX01BR19GSUxURVIsdC5ORUFSRVNUKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LnRleEltYWdlMkQodSwwLG8sbixyLDAsYSxpLG51bGwpfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG51bGwpfSksc31mdW5jdGlvbiBDYSh0LGUsbixyLG8pe3ZhciBhPWhhKG4scik7cmV0dXJuIGJhKHQsZSxhWzBdLGFbMV0sby5pbnRlcm5hbEZvcm1hdEZsb2F0LG8udGV4dHVyZUZvcm1hdEZsb2F0LHQuRkxPQVQpfWZ1bmN0aW9uIEVhKHQsZSxuLHIsbyl7dmFyIGE9aGEobixyKTtyZXR1cm4gYmEodCxlLGFbMF0sYVsxXSxvLmludGVybmFsRm9ybWF0SGFsZkZsb2F0LG8udGV4dHVyZUZvcm1hdEZsb2F0LG8udGV4dHVyZVR5cGVIYWxmRmxvYXQpfWZ1bmN0aW9uIFJhKHQsZSxuLHIsbyl7dmFyIGE9aGEobixyKTtyZXR1cm4gYmEodCxlLGFbMF0sYVsxXSx0LlJHQkEsdC5SR0JBLHQuVU5TSUdORURfQllURSl9ZnVuY3Rpb24gU2EodCxlLG4scixvKXt2YXIgYT1kYShuLHIpO3JldHVybiBiYSh0LGUsYVswXSxhWzFdLG8uaW50ZXJuYWxGb3JtYXRQYWNrZWRGbG9hdCx0LlJHQkEsdC5GTE9BVCl9ZnVuY3Rpb24gTmEodCxlLG4scixvKXt2YXIgYT1kYShuLHIpO3JldHVybiBiYSh0LGUsYVswXSxhWzFdLG8uaW50ZXJuYWxGb3JtYXRQYWNrZWRIYWxmRmxvYXQsdC5SR0JBLG8udGV4dHVyZVR5cGVIYWxmRmxvYXQpfWZ1bmN0aW9uIGthKHQsZSxuLHIpe3JldHVybiBCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kQnVmZmVyKHQuQVJSQVlfQlVGRkVSLHIpfSksbmUodCxlLG4sXCJjbGlwU3BhY2VQb3NcIixyLDMsMjAsMCkmJm5lKHQsZSxuLFwidXZcIixyLDIsMjAsMTIpfWZ1bmN0aW9uIElhKHQsZSxuLHIpe0J0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxuKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LnRleEltYWdlMkQodC5URVhUVVJFXzJELDAsdC5SR0JBLHQuUkdCQSx0LlVOU0lHTkVEX0JZVEUscil9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbnVsbCl9KX1mdW5jdGlvbiBBYSh0LGUsbixyLG8sYSxpKXt0ZShyLG8pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxuKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LnRleFN1YkltYWdlMkQodC5URVhUVVJFXzJELDAsMCwwLHIsbyxpLHQuRkxPQVQsYSl9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbnVsbCl9KX1mdW5jdGlvbiBUYSh0LGUsbixyLG8sYSxpLHMpe3ZhciB1LGw9aGEocixvKSxjPWxbMF0saD1sWzFdLHA9cipvOzE9PT1zLmRlZmF1bHROdW1DaGFubmVscyYmcD09PWEubGVuZ3RoP3U9YTpmdW5jdGlvbih0LGUsbil7dmFyIHI9cGEodC5sZW5ndGgsbik7aWYoZS5sZW5ndGg8cil0aHJvdyBuZXcgRXJyb3IoXCJ1bnBhY2tlZEFycmF5IGxlbmd0aCAoXCIrZS5sZW5ndGgrXCIpIG11c3QgYmUgPj0gXCIrcik7Zm9yKHZhciBvPTAsYT0wO2E8dC5sZW5ndGg7KythKWVbb109dFthXSxvKz1ufShhLHU9bmV3IEZsb2F0MzJBcnJheShwKmkpLGkpLEFhKHQsZSxuLGMsaCx1LHMudGV4dHVyZUZvcm1hdEZsb2F0KX1mdW5jdGlvbiBEYSh0LGUsbixyLG8sYSxpLHMsdSxsKXt2YXIgYz1kYShpLHMpLGg9Y1swXSxmPWNbMV0sZD1uZXcgRmxvYXQzMkFycmF5KHZhKGkscykpOyFmdW5jdGlvbih0LGUsbixyLG8pe2Zvcih2YXIgYT1yJTI9PTEsaT1uJTI9PTEscz1NYXRoLmZsb29yKHIvMiksdT1NYXRoLmZsb29yKG4vMiksbD1NYXRoLmNlaWwoci8yKSxjPWwqTWF0aC5jZWlsKG4vMiksaD1wKG4pKnAociksZj0wO2Y8ZTtmKyspe2Zvcih2YXIgZD1mKm4qcix2PWYqaCxtPWE/NDowLGc9cix5PXYseD0wO3g8dTsrK3gpe2Zvcih2YXIgdz0yKngqcixiPTA7YjxzOysrYil7dmFyIEM9ZCt3KzIqYjtvW3ldPXRbQ10sb1t5KzFdPXRbQysxXSxvW3krMl09dFtDK2ddLG9beSszXT10W0MrZysxXSx5Kz00fXkrPW19aWYoYSl7Qz1kK3ItMSx5PXYrNCoobC0xKTt2YXIgRT0yKnI7Zm9yKG09NCpsLHg9MDt4PHU7Kyt4KW9beV09dFtDXSxvW3krMl09dFtDK3JdLEMrPUUseSs9bX1pZihpKXtmb3IoQz1kKyhuLTEpKnIseT12KzQqKGMtbCksYj0wO2I8czsrK2Ipb1t5KytdPXRbQysrXSxvW3krK109dFtDKytdLHkrPTI7YSYmaSYmKG9bditoLTRdPXRbQ10pfX19KHUscixvLGEsZCksQWEodCxlLG4saCxmLGQsdC5SR0JBKX1mdW5jdGlvbiBPYSh0LGUsbixyLG8pe3ZhciBhPXQuY3JlYXRlQnVmZmVyKCk7QnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZEJ1ZmZlcih0LlBJWEVMX1BBQ0tfQlVGRkVSLGEpfSk7dmFyIGk9NCpwYShuKnIsby5kb3dubG9hZFVucGFja051bUNoYW5uZWxzKTtyZXR1cm4gQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYnVmZmVyRGF0YSh0LlBJWEVMX1BBQ0tfQlVGRkVSLGksdC5TVFJFQU1fUkVBRCl9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5yZWFkUGl4ZWxzKDAsMCxyLG4sdC5SR0JBLHQuRkxPQVQsMCl9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kQnVmZmVyKHQuUElYRUxfUEFDS19CVUZGRVIsbnVsbCl9KSxhfWZ1bmN0aW9uIF9hKHQsZSxuLHIsbyl7dmFyIGE9dCxpPW5ldyBGbG9hdDMyQXJyYXkocGEobipyLG8uZG93bmxvYWRVbnBhY2tOdW1DaGFubmVscykpO2EuYmluZEJ1ZmZlcihhLlBJWEVMX1BBQ0tfQlVGRkVSLGUpLGEuZ2V0QnVmZmVyU3ViRGF0YShhLlBJWEVMX1BBQ0tfQlVGRkVSLDAsaSksYS5iaW5kQnVmZmVyKGEuUElYRUxfUEFDS19CVUZGRVIsbnVsbCk7dmFyIHM9bmV3IEZsb2F0MzJBcnJheShuKnIpO3JldHVybiBmYShpLHMsby5kb3dubG9hZFVucGFja051bUNoYW5uZWxzKSxzfWZ1bmN0aW9uIE1hKHQsZSxuLHIsbyl7dmFyIGE9aGEobixyKSxpPWFbMF0scz1hWzFdLHU9bmV3IEZsb2F0MzJBcnJheShwYShuKnIsby5kb3dubG9hZFVucGFja051bUNoYW5uZWxzKSk7QnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQucmVhZFBpeGVscygwLDAsaSxzLG8uZG93bmxvYWRUZXh0dXJlRm9ybWF0LHQuRkxPQVQsdSl9KTt2YXIgbD1uZXcgRmxvYXQzMkFycmF5KG4qcik7cmV0dXJuIGZhKHUsbCxvLmRvd25sb2FkVW5wYWNrTnVtQ2hhbm5lbHMpLGx9ZnVuY3Rpb24gRmEodCxlLG4scixvKXt2YXIgYT1oYShuLHIpLGk9YVswXSxzPWFbMV0sdT1uZXcgVWludDhBcnJheShwYShuKnIsNCkpO3JldHVybiBCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5yZWFkUGl4ZWxzKDAsMCxpLHMsby5kb3dubG9hZFRleHR1cmVGb3JtYXQsdC5VTlNJR05FRF9CWVRFLHUpfSksbmV3IEZsb2F0MzJBcnJheSh1LmJ1ZmZlcil9ZnVuY3Rpb24gQmEodCxlLG4scixvLGEsaSxzKXt2YXIgdT10LGw9bmV3IEZsb2F0MzJBcnJheSh2YShhLGkpKTt1LmJpbmRCdWZmZXIodS5QSVhFTF9QQUNLX0JVRkZFUixlKSx1LmdldEJ1ZmZlclN1YkRhdGEodS5QSVhFTF9QQUNLX0JVRkZFUiwwLGwpLHUuYmluZEJ1ZmZlcih1LlBJWEVMX1BBQ0tfQlVGRkVSLG51bGwpO3ZhciBjPW5ldyBGbG9hdDMyQXJyYXkoeShbbixyLG9dKSk7cmV0dXJuIG1hKGwsbixyLG8sYyksY31mdW5jdGlvbiBQYSh0LGUsbixyLG8sYSxpLHMpe3ZhciB1PWRhKGEsaSksbD11WzBdLGM9dVsxXSxoPW5ldyBGbG9hdDMyQXJyYXkodmEoYSxpKSk7QnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQucmVhZFBpeGVscygwLDAsbCxjLHQuUkdCQSx0LkZMT0FULGgpfSk7dmFyIHA9bmV3IEZsb2F0MzJBcnJheSh5KFtuLHIsb10pKTtyZXR1cm4gbWEoaCxuLHIsbyxwKX0hZnVuY3Rpb24odCl7dFt0LlJFTkRFUj0wXT1cIlJFTkRFUlwiLHRbdC5VUExPQUQ9MV09XCJVUExPQURcIix0W3QuUElYRUxTPTJdPVwiUElYRUxTXCIsdFt0LkRPV05MT0FEPTNdPVwiRE9XTkxPQURcIn0odWF8fCh1YT17fSkpLGZ1bmN0aW9uKHQpe3RbdC5VTlBBQ0tFRF9GTE9BVDE2PTBdPVwiVU5QQUNLRURfRkxPQVQxNlwiLHRbdC5VTlBBQ0tFRF9GTE9BVDMyPTFdPVwiVU5QQUNLRURfRkxPQVQzMlwiLHRbdC5QQUNLRURfNFgxX1VOU0lHTkVEX0JZVEU9Ml09XCJQQUNLRURfNFgxX1VOU0lHTkVEX0JZVEVcIix0W3QuUEFDS0VEXzJYMl9GTE9BVDMyPTNdPVwiUEFDS0VEXzJYMl9GTE9BVDMyXCIsdFt0LlBBQ0tFRF8yWDJfRkxPQVQxNj00XT1cIlBBQ0tFRF8yWDJfRkxPQVQxNlwifShsYXx8KGxhPXt9KSk7dmFyIExhPU9iamVjdC5mcmVlemUoe2NyZWF0ZVZlcnRleFNoYWRlcjpnYSxjcmVhdGVWZXJ0ZXhCdWZmZXI6eWEsY3JlYXRlSW5kZXhCdWZmZXI6eGEsZ2V0VGV4dHVyZUNvbmZpZzp3YSxjcmVhdGVGbG9hdDMyTWF0cml4VGV4dHVyZTpDYSxjcmVhdGVGbG9hdDE2TWF0cml4VGV4dHVyZTpFYSxjcmVhdGVVbnNpZ25lZEJ5dGVzTWF0cml4VGV4dHVyZTpSYSxjcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlOlNhLGNyZWF0ZUZsb2F0MTZQYWNrZWRNYXRyaXhUZXh0dXJlOk5hLGJpbmRWZXJ0ZXhQcm9ncmFtQXR0cmlidXRlU3RyZWFtczprYSx1cGxvYWRQaXhlbERhdGFUb1RleHR1cmU6SWEsdXBsb2FkTWF0cml4VG9UZXh0dXJlOlRhLHVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZTpEYSxjcmVhdGVCdWZmZXJGcm9tT3V0cHV0VGV4dHVyZTpPYSxkb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tQnVmZmVyOl9hLGRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21PdXRwdXRUZXh0dXJlOk1hLGRvd25sb2FkQnl0ZUVuY29kZWRGbG9hdE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlOkZhLGRvd25sb2FkUGFja2VkTWF0cml4RnJvbUJ1ZmZlcjpCYSxkb3dubG9hZE1hdHJpeEZyb21QYWNrZWRPdXRwdXRUZXh0dXJlOlBhfSksV2E9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMub3V0cHV0VGV4dHVyZT1udWxsLHRoaXMucHJvZ3JhbT1udWxsLHRoaXMuZGlzcG9zZWQ9ITEsdGhpcy52ZXJ0ZXhBdHRyc0FyZUJvdW5kPSExLHRoaXMuaXRlbXNUb1BvbGw9W107dmFyIGU9YS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpO251bGwhPXQ/KHRoaXMuZ2w9dCxmdW5jdGlvbih0LGUpe190W3RdPWV9KGUsdCkpOnRoaXMuZ2w9RnQoZSksMT09PWEuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKT8odGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb249enQodGhpcy5nbCx0aGlzLmRlYnVnLFwiT0VTX3RleHR1cmVfZmxvYXRcIiksdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0XCIpLGEuZ2V0Qm9vbChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIil8fCh0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb249enQodGhpcy5nbCx0aGlzLmRlYnVnLFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiKSx0aGlzLmNvbG9yQnVmZmVySGFsZkZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XCIpKSk6dGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uPXp0KHRoaXMuZ2wsdGhpcy5kZWJ1ZyxcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIiksdGhpcy52ZXJ0ZXhCdWZmZXI9eWEodGhpcy5nbCx0aGlzLmRlYnVnKSx0aGlzLmluZGV4QnVmZmVyPXhhKHRoaXMuZ2wsdGhpcy5kZWJ1ZyksdGhpcy5mcmFtZWJ1ZmZlcj1lZSh0aGlzLmdsLHRoaXMuZGVidWcpLHRoaXMudGV4dHVyZUNvbmZpZz13YSh0aGlzLmdsLHRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbil9cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImRlYnVnXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBhLmdldEJvb2woXCJERUJVR1wiKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZighdGhpcy5kaXNwb3NlZCl7bnVsbCE9dGhpcy5wcm9ncmFtJiZjb25zb2xlLndhcm4oXCJEaXNwb3NpbmcgYSBHUEdQVUNvbnRleHQgdGhhdCBzdGlsbCBoYXMgYSBib3VuZCBXZWJHTFByb2dyYW0uIFRoaXMgaXMgcHJvYmFibHkgYSByZXNvdXJjZSBsZWFrLCBkZWxldGUgdGhlIHByb2dyYW0gd2l0aCBHUEdQVUNvbnRleHQuZGVsZXRlUHJvZ3JhbSBiZWZvcmUgZGlzcG9zaW5nLlwiKSxudWxsIT10aGlzLm91dHB1dFRleHR1cmUmJmNvbnNvbGUud2FybihcIkRpc3Bvc2luZyBhIEdQR1BVQ29udGV4dCB0aGF0IHN0aWxsIGhhcyBhIGJvdW5kIG91dHB1dCBtYXRyaXggdGV4dHVyZS4gIFRoaXMgaXMgcHJvYmFibHkgYSByZXNvdXJjZSBsZWFrLCBkZWxldGUgdGhlIG91dHB1dCBtYXRyaXggdGV4dHVyZSB3aXRoIEdQR1BVQ29udGV4dC5kZWxldGVNYXRyaXhUZXh0dXJlIGJlZm9yZSBkaXNwb3NpbmcuXCIpO3ZhciBlPXRoaXMuZ2w7QnQoZSx0aGlzLmRlYnVnLGZ1bmN0aW9uKCl7cmV0dXJuIGUuZmluaXNoKCl9KSxCdChlLHRoaXMuZGVidWcsZnVuY3Rpb24oKXtyZXR1cm4gZS5iaW5kRnJhbWVidWZmZXIoZS5GUkFNRUJVRkZFUixudWxsKX0pLEJ0KGUsdGhpcy5kZWJ1ZyxmdW5jdGlvbigpe3JldHVybiBlLmRlbGV0ZUZyYW1lYnVmZmVyKHQuZnJhbWVidWZmZXIpfSksQnQoZSx0aGlzLmRlYnVnLGZ1bmN0aW9uKCl7cmV0dXJuIGUuYmluZEJ1ZmZlcihlLkFSUkFZX0JVRkZFUixudWxsKX0pLEJ0KGUsdGhpcy5kZWJ1ZyxmdW5jdGlvbigpe3JldHVybiBlLmJpbmRCdWZmZXIoZS5FTEVNRU5UX0FSUkFZX0JVRkZFUixudWxsKX0pLEJ0KGUsdGhpcy5kZWJ1ZyxmdW5jdGlvbigpe3JldHVybiBlLmRlbGV0ZUJ1ZmZlcih0LmluZGV4QnVmZmVyKX0pLHRoaXMuZGlzcG9zZWQ9ITB9fSx0LnByb3RvdHlwZS5jcmVhdGVGbG9hdDMyTWF0cml4VGV4dHVyZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLENhKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LGUsdGhpcy50ZXh0dXJlQ29uZmlnKX0sdC5wcm90b3R5cGUuY3JlYXRlRmxvYXQxNk1hdHJpeFRleHR1cmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxFYSh0aGlzLmdsLHRoaXMuZGVidWcsdCxlLHRoaXMudGV4dHVyZUNvbmZpZyl9LHQucHJvdG90eXBlLmNyZWF0ZVVuc2lnbmVkQnl0ZXNNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksUmEodGhpcy5nbCx0aGlzLmRlYnVnLHQsZSx0aGlzLnRleHR1cmVDb25maWcpfSx0LnByb3RvdHlwZS51cGxvYWRQaXhlbERhdGFUb1RleHR1cmU9ZnVuY3Rpb24odCxlKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLElhKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LGUpfSx0LnByb3RvdHlwZS5jcmVhdGVGbG9hdDE2UGFja2VkTWF0cml4VGV4dHVyZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLE5hKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LGUsdGhpcy50ZXh0dXJlQ29uZmlnKX0sdC5wcm90b3R5cGUuY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFNhKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LGUsdGhpcy50ZXh0dXJlQ29uZmlnKX0sdC5wcm90b3R5cGUuZGVsZXRlTWF0cml4VGV4dHVyZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5vdXRwdXRUZXh0dXJlPT09dCYmKHVlKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0aGlzLmZyYW1lYnVmZmVyKSx0aGlzLm91dHB1dFRleHR1cmU9bnVsbCksQnQodGhpcy5nbCx0aGlzLmRlYnVnLGZ1bmN0aW9uKCl7cmV0dXJuIGUuZ2wuZGVsZXRlVGV4dHVyZSh0KX0pfSx0LnByb3RvdHlwZS51cGxvYWRNYXRyaXhUb1RleHR1cmU9ZnVuY3Rpb24odCxlLG4scil7dGhpcy50aHJvd0lmRGlzcG9zZWQoKTt2YXIgbz1KdCgpO3JldHVybiBUYSh0aGlzLmdsLHRoaXMuZGVidWcsdCxlLG4scixvLHRoaXMudGV4dHVyZUNvbmZpZyl9LHQucHJvdG90eXBlLnVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZT1mdW5jdGlvbih0LGUsbixyLG8sYSxpKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxEYSh0aGlzLmdsLHRoaXMuZGVidWcsdCxlLG4scixvLGEsaSx0aGlzLnRleHR1cmVDb25maWcpfSx0LnByb3RvdHlwZS5kb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZT1mdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcztyZXR1cm4gdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlcih0LGZ1bmN0aW9uKCl7cmV0dXJuIE1hKHIuZ2wsci5kZWJ1ZyxlLG4sci50ZXh0dXJlQ29uZmlnKX0pfSx0LnByb3RvdHlwZS5kb3dubG9hZEJ5dGVFbmNvZGVkRmxvYXRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZT1mdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcztyZXR1cm4gdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlcih0LGZ1bmN0aW9uKCl7cmV0dXJuIEZhKHIuZ2wsci5kZWJ1ZyxlLG4sci50ZXh0dXJlQ29uZmlnKX0pfSx0LnByb3RvdHlwZS5kb3dubG9hZFBhY2tlZE1hdHJpeEZyb21CdWZmZXI9ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiBCYSh0aGlzLmdsLHQsZSxuLHIsbyxhLHRoaXMudGV4dHVyZUNvbmZpZyl9LHQucHJvdG90eXBlLmRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21CdWZmZXI9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBfYSh0aGlzLmdsLHQsZSxuLHRoaXMudGV4dHVyZUNvbmZpZyl9LHQucHJvdG90eXBlLmNyZWF0ZUJ1ZmZlckZyb21UZXh0dXJlPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcih0KTt2YXIgcj1PYSh0aGlzLmdsLHRoaXMuZGVidWcsZSxuLHRoaXMudGV4dHVyZUNvbmZpZyk7cmV0dXJuIHRoaXMudW5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIoKSxyfSx0LnByb3RvdHlwZS5jcmVhdGVBbmRXYWl0Rm9yRmVuY2U9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmNyZWF0ZUZlbmNlKHRoaXMuZ2wpO3JldHVybiB0aGlzLnBvbGxGZW5jZSh0KX0sdC5wcm90b3R5cGUuY3JlYXRlRmVuY2U9ZnVuY3Rpb24odCl7dmFyIGUsbixyPXRoaXM7aWYoYS5nZXRCb29sKFwiV0VCR0xfRkVOQ0VfQVBJX0VOQUJMRURcIikpe3ZhciBvPXQsaT1vLmZlbmNlU3luYyhvLlNZTkNfR1BVX0NPTU1BTkRTX0NPTVBMRVRFLDApO3QuZmx1c2goKSxuPWZ1bmN0aW9uKCl7dmFyIHQ9by5jbGllbnRXYWl0U3luYyhpLDAsMCk7cmV0dXJuIHQ9PT1vLkFMUkVBRFlfU0lHTkFMRUR8fHQ9PT1vLkNPTkRJVElPTl9TQVRJU0ZJRUR9LGU9aX1lbHNlIGEuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIik+MD8oZT10aGlzLmJlZ2luUXVlcnkoKSx0aGlzLmVuZFF1ZXJ5KCksbj1mdW5jdGlvbigpe3JldHVybiByLmlzUXVlcnlBdmFpbGFibGUoZSxhLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpKX0pOm49ZnVuY3Rpb24oKXtyZXR1cm4hMH07cmV0dXJue3F1ZXJ5OmUsaXNGZW5jZVBhc3NlZDpufX0sdC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkVGV4dHVyZT1mdW5jdGlvbih0LGUsbixyLG8sYSl7dmFyIGk9dGhpcztyZXR1cm4gdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlcih0LGZ1bmN0aW9uKCl7cmV0dXJuIFBhKGkuZ2wsaS5kZWJ1ZyxlLG4scixvLGEsaS50ZXh0dXJlQ29uZmlnKX0pfSx0LnByb3RvdHlwZS5jcmVhdGVQcm9ncmFtPWZ1bmN0aW9uKHQpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCk7dmFyIGU9dGhpcy5nbCxuPUd0KGUsdGhpcy5kZWJ1Zyx0KSxyPWdhKGUsdGhpcy5kZWJ1Zyksbz1qdChlLHRoaXMuZGVidWcpO3JldHVybiBCdChlLHRoaXMuZGVidWcsZnVuY3Rpb24oKXtyZXR1cm4gZS5hdHRhY2hTaGFkZXIobyxyKX0pLEJ0KGUsdGhpcy5kZWJ1ZyxmdW5jdGlvbigpe3JldHVybiBlLmF0dGFjaFNoYWRlcihvLG4pfSksS3QoZSx0aGlzLmRlYnVnLG8pLHRoaXMuZGVidWcmJlh0KGUsdGhpcy5kZWJ1ZyxvKSx0aGlzLnZlcnRleEF0dHJzQXJlQm91bmR8fCh0aGlzLnNldFByb2dyYW0obyksdGhpcy52ZXJ0ZXhBdHRyc0FyZUJvdW5kPWthKGUsdGhpcy5kZWJ1Zyx0aGlzLnByb2dyYW0sdGhpcy52ZXJ0ZXhCdWZmZXIpKSxvfSx0LnByb3RvdHlwZS5kZWxldGVQcm9ncmFtPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0PT09dGhpcy5wcm9ncmFtJiYodGhpcy5wcm9ncmFtPW51bGwpLG51bGwhPXQmJkJ0KHRoaXMuZ2wsdGhpcy5kZWJ1ZyxmdW5jdGlvbigpe3JldHVybiBlLmdsLmRlbGV0ZVByb2dyYW0odCl9KX0sdC5wcm90b3R5cGUuc2V0UHJvZ3JhbT1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5wcm9ncmFtPXQsbnVsbCE9dGhpcy5wcm9ncmFtJiZ0aGlzLmRlYnVnJiZYdCh0aGlzLmdsLHRoaXMuZGVidWcsdGhpcy5wcm9ncmFtKSxCdCh0aGlzLmdsLHRoaXMuZGVidWcsZnVuY3Rpb24oKXtyZXR1cm4gZS5nbC51c2VQcm9ncmFtKHQpfSl9LHQucHJvdG90eXBlLmdldFVuaWZvcm1Mb2NhdGlvbj1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPSEwKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLG4/b2UodGhpcy5nbCx0aGlzLmRlYnVnLHQsZSk6YWUodGhpcy5nbCx0LGUpfSx0LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVMb2NhdGlvbj1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksQnQodGhpcy5nbCx0aGlzLmRlYnVnLGZ1bmN0aW9uKCl7cmV0dXJuIG4uZ2wuZ2V0QXR0cmliTG9jYXRpb24odCxlKX0pfSx0LnByb3RvdHlwZS5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odCxlKX0sdC5wcm90b3R5cGUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMudGhyb3dJZk5vUHJvZ3JhbSgpLGllKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0aGlzLnByb2dyYW0sdCxlLG4pfSx0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXIodCxuLGUpfSx0LnByb3RvdHlwZS5zZXRPdXRwdXRQYWNrZWRNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpO3ZhciByPWRhKGUsbiksbz1yWzBdLGE9clsxXTt0aGlzLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXIodCxvLGEpfSx0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbj1mdW5jdGlvbih0LGUsbixyKXt0aGlzLnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uRHJpdmVyKG4sdCxyLGUpfSx0LnByb3RvdHlwZS5zZXRPdXRwdXRQYWNrZWRNYXRyaXhXcml0ZVJlZ2lvbj1mdW5jdGlvbih0LGUsbixyKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRPdXRwdXRQYWNrZWRNYXRyaXhXcml0ZVJlZ2lvbiBub3QgaW1wbGVtZW50ZWQuXCIpfSx0LnByb3RvdHlwZS5kZWJ1Z1ZhbGlkYXRlPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5wcm9ncmFtJiZYdCh0aGlzLmdsLHRoaXMuZGVidWcsdGhpcy5wcm9ncmFtKSxsZSh0aGlzLmdsKX0sdC5wcm90b3R5cGUuZXhlY3V0ZVByb2dyYW09ZnVuY3Rpb24oKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMudGhyb3dJZk5vUHJvZ3JhbSgpO3ZhciB0PXRoaXMuZ2w7dGhpcy5kZWJ1ZyYmdGhpcy5kZWJ1Z1ZhbGlkYXRlKCksQnQodCx0aGlzLmRlYnVnLGZ1bmN0aW9uKCl7cmV0dXJuIHQuZHJhd0VsZW1lbnRzKHQuVFJJQU5HTEVTLDYsdC5VTlNJR05FRF9TSE9SVCwwKX0pfSx0LnByb3RvdHlwZS5ibG9ja1VudGlsQWxsUHJvZ3JhbXNDb21wbGV0ZWQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksQnQodGhpcy5nbCx0aGlzLmRlYnVnLGZ1bmN0aW9uKCl7cmV0dXJuIHQuZ2wuZmluaXNoKCl9KX0sdC5wcm90b3R5cGUuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbj1mdW5jdGlvbigpe3JldHVybiBudWxsPT10aGlzLmRpc2pvaW50UXVlcnlUaW1lckV4dGVuc2lvbiYmKHRoaXMuZGlzam9pbnRRdWVyeVRpbWVyRXh0ZW5zaW9uPXp0KHRoaXMuZ2wsdGhpcy5kZWJ1ZywyPT09YS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT9cIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDJcIjpcIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeVwiKSksdGhpcy5kaXNqb2ludFF1ZXJ5VGltZXJFeHRlbnNpb259LHQucHJvdG90eXBlLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uKCl9LHQucHJvdG90eXBlLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uKCl9LHQucHJvdG90eXBlLmJlZ2luUXVlcnk9ZnVuY3Rpb24oKXtpZigyPT09YS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKSl7dmFyIHQ9dGhpcy5nbCxlPXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMigpLG49dC5jcmVhdGVRdWVyeSgpO3JldHVybiB0LmJlZ2luUXVlcnkoZS5USU1FX0VMQVBTRURfRVhULG4pLG59dmFyIHI9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxKCksbz1yLmNyZWF0ZVF1ZXJ5RVhUKCk7cmV0dXJuIHIuYmVnaW5RdWVyeUVYVChyLlRJTUVfRUxBUFNFRF9FWFQsbyksb30sdC5wcm90b3R5cGUuZW5kUXVlcnk9ZnVuY3Rpb24oKXtpZigyIT09YS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKSl7dmFyIHQ9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxKCk7dC5lbmRRdWVyeUVYVCh0LlRJTUVfRUxBUFNFRF9FWFQpfWVsc2V7dmFyIGU9dGhpcy5nbCxuPXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMigpO2UuZW5kUXVlcnkobi5USU1FX0VMQVBTRURfRVhUKX19LHQucHJvdG90eXBlLndhaXRGb3JRdWVyeUFuZEdldFRpbWU9ZnVuY3Rpb24odCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGU9dGhpcztyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsUihmdW5jdGlvbigpe3JldHVybiBlLmRpc3Bvc2VkfHxlLmlzUXVlcnlBdmFpbGFibGUodCxhLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpKX0pXTtjYXNlIDE6cmV0dXJuIG4uc2VudCgpLFsyLHRoaXMuZ2V0UXVlcnlUaW1lKHQsYS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKSldfX0pfSl9LHQucHJvdG90eXBlLmdldFF1ZXJ5VGltZT1mdW5jdGlvbih0LGUpe2lmKDA9PT1lKXJldHVybiBudWxsO2lmKDI9PT1lKXt2YXIgbj10aGlzLmdsO3JldHVybiBuLmdldFF1ZXJ5UGFyYW1ldGVyKHQsbi5RVUVSWV9SRVNVTFQpLzFlNn12YXIgcj10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEoKTtyZXR1cm4gci5nZXRRdWVyeU9iamVjdEVYVCh0LHIuUVVFUllfUkVTVUxUX0VYVCkvMWU2fSx0LnByb3RvdHlwZS5pc1F1ZXJ5QXZhaWxhYmxlPWZ1bmN0aW9uKHQsZSl7aWYoMD09PWUpcmV0dXJuITA7aWYoMj09PWUpe3ZhciBuPXRoaXMuZ2wscj10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDIoKSxvPW4uZ2V0UXVlcnlQYXJhbWV0ZXIodCxuLlFVRVJZX1JFU1VMVF9BVkFJTEFCTEUpO3JldHVybiBudWxsPT10aGlzLmRpc2pvaW50JiYodGhpcy5kaXNqb2ludD10aGlzLmdsLmdldFBhcmFtZXRlcihyLkdQVV9ESVNKT0lOVF9FWFQpKSxvJiYhdGhpcy5kaXNqb2ludH1vPShyPXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpKS5nZXRRdWVyeU9iamVjdEVYVCh0LHIuUVVFUllfUkVTVUxUX0FWQUlMQUJMRV9FWFQpO3JldHVybiBudWxsPT10aGlzLmRpc2pvaW50JiYodGhpcy5kaXNqb2ludD10aGlzLmdsLmdldFBhcmFtZXRlcihyLkdQVV9ESVNKT0lOVF9FWFQpKSxvJiYhdGhpcy5kaXNqb2ludH0sdC5wcm90b3R5cGUucG9sbEZlbmNlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKG4pe2UuYWRkSXRlbVRvUG9sbChmdW5jdGlvbigpe3JldHVybiB0LmlzRmVuY2VQYXNzZWQoKX0sZnVuY3Rpb24oKXtyZXR1cm4gbigpfSl9KX0sdC5wcm90b3R5cGUucG9sbEl0ZW1zPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7KytlKXt2YXIgbj10W2VdKCk7aWYoIW4pYnJlYWt9cmV0dXJuIGUtMX0odGhpcy5pdGVtc1RvUG9sbC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuaXNEb25lRm59KSksZT0wO2U8PXQ7KytlKXsoMCx0aGlzLml0ZW1zVG9Qb2xsW2VdLnJlc29sdmVGbikoKX10aGlzLml0ZW1zVG9Qb2xsPXRoaXMuaXRlbXNUb1BvbGwuc2xpY2UodCsxKX0sdC5wcm90b3R5cGUuYWRkSXRlbVRvUG9sbD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7dGhpcy5pdGVtc1RvUG9sbC5wdXNoKHtpc0RvbmVGbjp0LHJlc29sdmVGbjplfSksdGhpcy5pdGVtc1RvUG9sbC5sZW5ndGg+MXx8UihmdW5jdGlvbigpe3JldHVybiBuLnBvbGxJdGVtcygpLDA9PT1uLml0ZW1zVG9Qb2xsLmxlbmd0aH0pfSx0LnByb3RvdHlwZS5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXI9ZnVuY3Rpb24odCl7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSxzZSh0aGlzLmdsLHRoaXMuZGVidWcsdCx0aGlzLmZyYW1lYnVmZmVyKSx0aGlzLmRlYnVnJiZsZSh0aGlzLmdsKX0sdC5wcm90b3R5cGUudW5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXI9ZnVuY3Rpb24oKXtudWxsIT10aGlzLm91dHB1dFRleHR1cmU/KHNlKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0aGlzLm91dHB1dFRleHR1cmUsdGhpcy5mcmFtZWJ1ZmZlciksdGhpcy5kZWJ1ZyYmbGUodGhpcy5nbCkpOnVlKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0aGlzLmZyYW1lYnVmZmVyKX0sdC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhEcml2ZXI9ZnVuY3Rpb24odCxlKXt0aGlzLmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcih0KTt2YXIgbj1lKCk7cmV0dXJuIHRoaXMudW5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIoKSxufSx0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlRHJpdmVyPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpO3ZhciByPXRoaXMuZ2w7c2Uocix0aGlzLmRlYnVnLHQsdGhpcy5mcmFtZWJ1ZmZlciksdGhpcy5kZWJ1ZyYmbGUociksdGhpcy5vdXRwdXRUZXh0dXJlPXQsQnQocix0aGlzLmRlYnVnLGZ1bmN0aW9uKCl7cmV0dXJuIHIudmlld3BvcnQoMCwwLGUsbil9KSxCdChyLHRoaXMuZGVidWcsZnVuY3Rpb24oKXtyZXR1cm4gci5zY2lzc29yKDAsMCxlLG4pfSl9LHQucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uRHJpdmVyPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPXRoaXM7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSxCdCh0aGlzLmdsLHRoaXMuZGVidWcsZnVuY3Rpb24oKXtyZXR1cm4gby5nbC5zY2lzc29yKHQsZSxuLHIpfSl9LHQucHJvdG90eXBlLnRocm93SWZEaXNwb3NlZD1mdW5jdGlvbigpe2lmKHRoaXMuZGlzcG9zZWQpdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIHVzZSBkaXNwb3NlZCBHUEdQVUNvbnRleHQuXCIpfSx0LnByb3RvdHlwZS50aHJvd0lmTm9Qcm9ncmFtPWZ1bmN0aW9uKCl7aWYobnVsbD09dGhpcy5wcm9ncmFtKXRocm93IG5ldyBFcnJvcihcIk5vIEdQVSBwcm9ncmFtIGlzIGN1cnJlbnRseSBzZXQuXCIpfSx0fSgpO2Z1bmN0aW9uIFVhKHQsZSl7aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBFcnJvcihcIkJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBcIit0Lmxlbmd0aCtcIiBpbnB1dHMsIGJ1dCB3YXMgZXhlY3V0ZWQgd2l0aCBcIitlLmxlbmd0aCtcIiBpbnB1dHNcIik7dC5mb3JFYWNoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5sb2dpY2FsU2hhcGUsbz1lW25dLGE9by5zaGFwZTtpZigheChyLGEpKXRocm93IEVycm9yKFwiQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoIGRpZmZlcmVudCBzaGFwZXMgdGhhbiB0aGUgY3VycmVudCBhcmdzLiBTaGFwZXMgXCIrcitcIiBhbmQgXCIrYStcIiBtdXN0IG1hdGNoXCIpO2lmKCF0LmlzVW5pZm9ybXx8IW8uaXNVbmlmb3JtKXt2YXIgaT10LnRleFNoYXBlLHM9by5pc1VuaWZvcm0/bnVsbDpvLnRleERhdGEudGV4U2hhcGU7aWYoIXgoaSxzKSl0aHJvdyBFcnJvcihcIkJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBkaWZmZXJlbnQgdGV4dHVyZSBzaGFwZXMgdGhhbiB0aGUgY3VycmVudCBhcmdzLiBTaGFwZSBcIitpK1wiIGFuZCBcIitzK1wiIG11c3QgbWF0Y2hcIil9fSl9dmFyIHphPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnVzZXNQYWNrZWRUZXh0dXJlcz0hMCx0aGlzLm91dHB1dFNoYXBlPXQ7dmFyIHI9bi5maWx0ZXJXaWR0aCxvPW4uaW5DaGFubmVscyxhPW4uc3RyaWRlV2lkdGgsaT1uLnN0cmlkZUhlaWdodCxzPW4ucGFkSW5mbyx1PW4ub3V0V2lkdGgsbD1uLmRpbGF0aW9uV2lkdGgsYz1uLmRpbGF0aW9uSGVpZ2h0LGg9cy5sZWZ0LHA9cy50b3AsZj1vKnIsZD11bygpO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiByYyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDApO1xcblxcbiAgICAgICAgZm9yKGludCByb3c9MDsgcm93PD0xOyByb3crKykge1xcbiAgICAgICAgICBmb3IoaW50IGNvbD0wOyBjb2w8PTE7IGNvbCsrKSB7XFxuICAgICAgICAgICAgaW50IGJsb2NrSW5kZXggPSByYy55ICsgY29sO1xcbiAgICAgICAgICAgIGludCBwb3MgPSByYy54ICsgcm93O1xcblxcbiAgICAgICAgICAgIGlmKGJsb2NrSW5kZXggPj0gXCIrdFsxXStcIiB8fCBwb3MgPj0gXCIrdFswXStcIikgY29udGludWU7XFxuXFxuICAgICAgICAgICAgaW50IG9mZnNldFkgPSBpbnQoYmxvY2tJbmRleCAvIChcIit1K1wiKSkgKiBcIitpK1wiIC0gXCIrcCtcIjtcXG4gICAgICAgICAgICBpbnQgZDAgPSBvZmZzZXRZICsgXCIrYytcIiAqIChwb3MgLyBcIitmK1wiKTtcXG5cXG4gICAgICAgICAgICBpZihkMCA+PSBcIitlWzBdK1wiIHx8IGQwIDwgMCkgY29udGludWU7XFxuXFxuICAgICAgICAgICAgaW50IG9mZnNldFggPSBpbnQobW9kKGZsb2F0KGJsb2NrSW5kZXgpLCBcIit1K1wiLikgKiBcIithK1wiLiAtIFwiK2grXCIuKTtcXG4gICAgICAgICAgICBpbnQgZDEgPSBvZmZzZXRYICsgXCIrbCtcIiAqIChpbnQobW9kKGZsb2F0KHBvcyksIFwiK2YrXCIuKSAvIFwiK28rXCIuKSk7XFxuXFxuICAgICAgICAgICAgaWYoZDEgPj0gXCIrZVsxXStcIiB8fCBkMSA8IDApIGNvbnRpbnVlO1xcblxcbiAgICAgICAgICAgIHZlYzIgaW5uZXJEaW1zID0gdmVjMihkMSwgaW50KG1vZChmbG9hdChwb3MpLCBcIitvK1wiLikpKTtcXG4gICAgICAgICAgICByZXN1bHRbcm93ICogMiArIGNvbF0gPSBnZXRDaGFubmVsKGdldEEoZDAsIGludChpbm5lckRpbXMueCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludChpbm5lckRpbXMueSkpLCBpbm5lckRpbXMpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBcIitkLm91dHB1dCtcIiA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgIFwifX0oKSxWYT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyLG8pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMub3V0cHV0U2hhcGU9W107dmFyIGEsaT1lLHM9dFszXS0xO3RoaXMub3V0cHV0U2hhcGU9dDt2YXIgdT1cImZsb2F0KFwiK24rXCIpICsgZmxvYXQoXCIrcitcIikgKiBzdW1cIjthPS41PT09bz9cImludmVyc2VzcXJ0KFwiK3UrXCIpXCI6MT09PW8/XCIxLjAvKFwiK3UrXCIpXCI6XCJleHAobG9nKFwiK3UrXCIpICogZmxvYXQoLVwiK28rXCIpKTtcIix0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRYKGIsIHIsIGMsIGQpO1xcbiAgICAgICAgZmxvYXQgc3VtID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgaiA9IC1cIitpK1wiOyBqIDw9IFwiK2krXCI7IGorKykge1xcbiAgICAgICAgICBpbnQgaWR4ID0gZCArIGo7XFxuICAgICAgICAgIGlmIChpZHggPj0gMCAmJiBpZHggPD0gIFwiK3MrXCIpIHtcXG4gICAgICAgICAgICBmbG9hdCB6ID0gZ2V0WChiLCByLCBjLCBpZHgpO1xcbiAgICAgICAgICAgIHN1bSArPSB6ICogejtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZmxvYXQgdmFsID0geCAqIFwiK2ErXCI7XFxuICAgICAgICBzZXRPdXRwdXQodmFsKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxHYT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyLG8pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJpbnB1dEltYWdlXCIsXCJvdXRwdXRJbWFnZVwiLFwiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy5kZXB0aD10WzNdLHRoaXMuZGVwdGhSYWRpdXM9ZSx0aGlzLmJpYXM9bix0aGlzLmFscGhhPXIsdGhpcy5iZXRhPW8sdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgciA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBjID0gY29vcmRzWzJdO1xcblxcbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgZCA9IDA7IGQgPCBcIit0aGlzLmRlcHRoK1wiOyArK2QpIHtcXG4gICAgICAgICAgaW50IGRlcHRoQmVnaW4gPSBpbnQobWF4KDAuMCwgZmxvYXQoZCAtIFwiK2UrXCIpKSk7XFxuICAgICAgICAgIGludCBkZXB0aEVuZCA9IGludChtaW4oZmxvYXQoXCIrdGhpcy5kZXB0aCtcIiksXFxuICAgICAgICAgICAgICBmbG9hdChkICsgXCIrZStcIiArIDEpKSk7XFxuXFxuICAgICAgICAgIGNvbnN0IGludCBNSU5fREVQVEhfQkVHSU4gPSAwO1xcbiAgICAgICAgICBjb25zdCBpbnQgTUFYX0RFUFRIX0VORCA9IFwiK3RoaXMuZGVwdGgrXCI7XFxuXFxuICAgICAgICAgIGZsb2F0IG5vcm0gPSAwLjA7XFxuICAgICAgICAgIGZvciAoaW50IGsgPSBNSU5fREVQVEhfQkVHSU47IGsgPCBNQVhfREVQVEhfRU5EOyArK2spIHtcXG4gICAgICAgICAgICBpZiAoayA8IGRlcHRoQmVnaW4pe1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2UgaWYgKGsgPj0gZGVwdGhCZWdpbiAmJiBrIDwgZGVwdGhFbmQpIHtcXG4gICAgICAgICAgICAgIG5vcm0gKz0gZ2V0SW5wdXRJbWFnZShiLCByLCBjLCBrKSAqIGdldElucHV0SW1hZ2UoYiwgciwgYywgayk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG5vcm0gPSBmbG9hdChcIityK1wiKSAqIG5vcm0gKyBmbG9hdChcIituK1wiKTtcXG5cXG4gICAgICAgICAgZm9yKGludCBrID0gTUlOX0RFUFRIX0JFR0lOOyBrIDwgTUFYX0RFUFRIX0VORDsgKytrKXtcXG4gICAgICAgICAgICBpZiAoayA8IGRlcHRoQmVnaW4pe1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2UgaWYgKGsgPj0gZGVwdGhCZWdpbiAmJiBrIDwgZGVwdGhFbmQpe1xcbiAgICAgICAgICAgICAgZmxvYXQgZHlpID0gLTIuMCAqIGZsb2F0KFwiK3IrXCIpXFxuICAgICAgICAgICAgICAgICogZmxvYXQoXCIrbytcIilcXG4gICAgICAgICAgICAgICAgKiBnZXRJbnB1dEltYWdlKGIgLHIgLGMsIGspICogZ2V0T3V0cHV0SW1hZ2UoYiwgciwgYywgZClcXG4gICAgICAgICAgICAgICAgLyBub3JtO1xcbiAgICAgICAgICAgICAgaWYgKGsgPT0gZCkge1xcbiAgICAgICAgICAgICAgICBkeWkgKz0gcG93KG5vcm0sIC0xLjAgKiBcIitvK1wiKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGlmIChrID09IGNvb3Jkc1szXSkge1xcbiAgICAgICAgICAgICAgICBkeWkgKj0gZ2V0RHkoYiwgciwgYywgZCk7XFxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBkeWk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLHFhPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIsbyl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLnVzZXNQYWNrZWRUZXh0dXJlcz0hMDt2YXIgYSxpPWUscz10WzNdLTE7dGhpcy5vdXRwdXRTaGFwZT10O3ZhciB1PVwiZmxvYXQoXCIrbitcIikgKyBmbG9hdChcIityK1wiKSAqIHN1bVwiO2E9LjU9PT1vP1wiaW52ZXJzZXNxcnQoXCIrdStcIilcIjoxPT09bz9cIjEuMC8oXCIrdStcIilcIjpcImV4cChsb2coXCIrdStcIikgKiBmbG9hdCgtXCIrbytcIikpO1wiLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgciA9IGNvb3Jkcy55O1xcbiAgICAgICAgaW50IGMgPSBjb29yZHMuejtcXG4gICAgICAgIGludCBkID0gY29vcmRzLnc7XFxuXFxuICAgICAgICBib29sIGhhc05leHRDb2wgPSBkIDwgXCIrdGhpcy5vdXRwdXRTaGFwZVszXStcIjtcXG4gICAgICAgIGJvb2wgaGFzTmV4dFJvdyA9IGMgPCBcIit0aGlzLm91dHB1dFNoYXBlWzJdK1wiO1xcblxcbiAgICAgICAgdmVjNCBzdW0gPSB2ZWM0KDAuKTtcXG4gICAgICAgIHZlYzQgeEZyYWdBdE91dHB1dENvb3JkcyA9IGdldFgoYiwgciwgYywgZCk7XFxuXFxuICAgICAgICB2ZWM0IHhBdE91dHB1dENvb3JkcyA9IHZlYzQoXFxuICAgICAgICAgIGdldENoYW5uZWwoeEZyYWdBdE91dHB1dENvb3JkcywgdmVjMihjLCBkKSksXFxuICAgICAgICAgIGhhc05leHRDb2wgP1xcbiAgICAgICAgICAgIGdldENoYW5uZWwoeEZyYWdBdE91dHB1dENvb3JkcywgdmVjMihjLCBkICsgMSkpIDogMC4wLFxcbiAgICAgICAgICBoYXNOZXh0Um93ID9cXG4gICAgICAgICAgICBnZXRDaGFubmVsKHhGcmFnQXRPdXRwdXRDb29yZHMgLCB2ZWMyKGMgKyAxLCBkKSkgOiAwLjAsXFxuICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID9cXG4gICAgICAgICAgICBnZXRDaGFubmVsKHhGcmFnQXRPdXRwdXRDb29yZHMsIHZlYzIoYyArIDEsIGQgKyAxKSkgOiAwLjBcXG4gICAgICAgICk7XFxuXFxuICAgICAgICBpbnQgZmlyc3RDaGFubmVsID0gZCAtIFwiK2krXCI7XFxuICAgICAgICB2ZWMyIGNhY2hlID0gdmVjMigwLik7XFxuICAgICAgICBpZihmaXJzdENoYW5uZWwgPj0gMCl7XFxuICAgICAgICAgIHZlYzQgZmlyc3RDaGFubmVsRnJhZyA9IGdldFgoYiwgciwgYywgZmlyc3RDaGFubmVsKTtcXG4gICAgICAgICAgY2FjaGUueCA9IGdldENoYW5uZWwoZmlyc3RDaGFubmVsRnJhZywgdmVjMihjLCBmaXJzdENoYW5uZWwpKTtcXG4gICAgICAgICAgICBpZihoYXNOZXh0Um93KXtcXG4gICAgICAgICAgICAgIGNhY2hlLnkgPSBnZXRDaGFubmVsKGZpcnN0Q2hhbm5lbEZyYWcsIHZlYzIoYyArIDEsIGZpcnN0Q2hhbm5lbCkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGl2ZWMyIGRlcHRoID0gaXZlYzIoZCwgZCArIDEpO1xcbiAgICAgICAgZm9yIChpbnQgaiA9IC0gXCIraStcIjsgaiA8PSBcIitpK1wiOyBqKyspIHtcXG4gICAgICAgICAgaXZlYzIgaWR4ID0gZGVwdGggKyBqO1xcbiAgICAgICAgICBidmVjMiBhYm92ZUxvd2VyQm91bmQgPSBncmVhdGVyVGhhbkVxdWFsKGlkeCwgaXZlYzIoMCkpO1xcbiAgICAgICAgICBidmVjMiBiZWxvd1VwcGVyQm91bmQgPSBsZXNzVGhhbkVxdWFsKGlkeCwgaXZlYzIoXCIrcytcIikpO1xcblxcbiAgICAgICAgICBib29sIGRlcHRoSW5SYW5nZSA9IGFib3ZlTG93ZXJCb3VuZC54ICYmIGJlbG93VXBwZXJCb3VuZC54O1xcbiAgICAgICAgICBib29sIGRlcHRoUGx1c09uZUluUmFuZ2UgPSBhYm92ZUxvd2VyQm91bmQueSAmJiBiZWxvd1VwcGVyQm91bmQueTtcXG5cXG4gICAgICAgICAgaWYoZGVwdGhJblJhbmdlIHx8IGRlcHRoUGx1c09uZUluUmFuZ2Upe1xcbiAgICAgICAgICAgIHZlYzQgeiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgIHZlYzQgeEZyYWdBdEN1cnJlbnREZXB0aDtcXG4gICAgICAgICAgICB6Lnh6ID0gY2FjaGUueHk7XFxuICAgICAgICAgICAgaWYoZGVwdGhQbHVzT25lSW5SYW5nZSAmJiBoYXNOZXh0Q29sKXtcXG4gICAgICAgICAgICAgIHhGcmFnQXRDdXJyZW50RGVwdGggPSBpZHgueSAhPSBkID9cXG4gICAgICAgICAgICAgICAgZ2V0WChiLCByLCBjLCBpZHgueSkgOiB4RnJhZ0F0T3V0cHV0Q29vcmRzO1xcbiAgICAgICAgICAgICAgei55ID0gZ2V0Q2hhbm5lbCh4RnJhZ0F0Q3VycmVudERlcHRoLCB2ZWMyKGMsIGlkeC55KSk7XFxuICAgICAgICAgICAgICBpZihoYXNOZXh0Um93KXtcXG4gICAgICAgICAgICAgICAgei53ID0gZ2V0Q2hhbm5lbCh4RnJhZ0F0Q3VycmVudERlcHRoLCB2ZWMyKGMgKyAxLCBpZHgueSkpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjYWNoZS54eSA9IHoueXc7XFxuICAgICAgICAgICAgc3VtICs9IHogKiB6O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHhBdE91dHB1dENvb3JkcyAqIFwiK2ErXCI7XFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxIYT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIixcIm1heFBvc1wiXSx0aGlzLm91dHB1dFNoYXBlPXQuaW5TaGFwZTt2YXIgZT10LnN0cmlkZUhlaWdodCxuPXQuc3RyaWRlV2lkdGgscj10LmRpbGF0aW9uSGVpZ2h0LG89dC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsYT10LmVmZmVjdGl2ZUZpbHRlcldpZHRoLGk9by0xLXQucGFkSW5mby50b3Ascz1hLTEtdC5wYWRJbmZvLmxlZnQsdT1vKmEtMTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2krXCIsIFwiK3MrXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgIGl2ZWMyIGR5UkNDb3JuZXIgPSBjb29yZHMueXogLSBwYWRzO1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5UkNDb3JuZXIueDtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeVJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkKSB3aXRoIHBvcyBtYXNrKDosIDosIGQpIHRvIGdldCBkeCh4UiwgeEMsIGQpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK28rXCI7XFxuICAgICAgICAgIHdSICs9IFwiK3IrXCIpIHtcXG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIrZStcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIit0Lm91dEhlaWdodCtcIi4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrYStcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiK24rXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIit0Lm91dFdpZHRoK1wiLjAgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIGlkeVIsIGlkeUMsIGQpO1xcbiAgICAgICAgICAgIGludCBtYXhQb3NWYWx1ZSA9IFwiK3UrXCIgLSBpbnQoZ2V0TWF4UG9zKGIsIGlkeVIsIGlkeUMsIGQpKTtcXG5cXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgdmFsdWUsIGNoZWNrIGl0IGFnYWluc3QgdGhlIHZhbHVlIGZyb20gdGhlXFxuICAgICAgICAgICAgLy8gcG9zaXRpb24gbWF0cml4LlxcbiAgICAgICAgICAgIGludCBjdXJQb3NWYWx1ZSA9IHdSICogXCIrYStcIiArIHdDO1xcbiAgICAgICAgICAgIGZsb2F0IG1hc2sgPSBmbG9hdChtYXhQb3NWYWx1ZSA9PSBjdXJQb3NWYWx1ZSA/IDEuMCA6IDAuMCk7XFxuXFxuICAgICAgICAgICAgZG90UHJvZCArPSBkeVZhbHVlICogbWFzaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLCRhPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2b2lkIDA9PT1uJiYobj0hMSksdm9pZCAwPT09ciYmKHI9ITEpLHZvaWQgMD09PW8mJihvPSExKSx2b2lkIDA9PT1hJiYoYT1udWxsKSx0aGlzLnZhcmlhYmxlTmFtZXM9W1wibWF0cml4QVwiLFwibWF0cml4QlwiXSx0aGlzLnVzZXNQYWNrZWRUZXh0dXJlcz0hMCx0aGlzLm91dHB1dFNoYXBlPWU7dmFyIGk9bj90WzFdOnRbMl0scz1NYXRoLmNlaWwoaS8yKSx1PW4/XCJpICogMiwgcmMueVwiOlwicmMueSwgaSAqIDJcIixsPXI/XCJyYy56LCBpICogMlwiOlwiaSAqIDIsIHJjLnpcIixjPW4/W1wiYS54eHl5XCIsXCJhLnp6d3dcIl06W1wiYS54eHp6XCIsXCJhLnl5d3dcIl0saD1yP1tcImIueHp4elwiLFwiYi55d3l3XCJdOltcImIueHl4eVwiLFwiYi56d3p3XCJdLHA9XCJcIixmPVwiXCI7YSYmKHA9XCJ2ZWM0IGFjdGl2YXRpb24odmVjNCB4KSB7XFxuICAgICAgICBcIithK1wiXFxuICAgICAgfVwiLGY9XCJyZXN1bHQgPSBhY3RpdmF0aW9uKHJlc3VsdCk7XCIpO3ZhciBkPW8/XCJyZXN1bHQgKz0gZ2V0Qmlhc0F0T3V0Q29vcmRzKCk7XCI6XCJcIjtvJiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcImJpYXNcIiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFwiK3ArXCJcXG5cXG4gICAgICBjb25zdCBmbG9hdCBzaGFyZWREaW1lbnNpb24gPSBcIitzK1wiLjA7XFxuXFxuICAgICAgdmVjNCBkb3QyeDJBUm93QkNvbChpdmVjMyByYykge1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDApO1xcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIitzK1wiOyBpKyspIHtcXG4gICAgICAgICAgdmVjNCBhID0gZ2V0TWF0cml4QShyYy54LCBcIit1K1wiKTtcXG4gICAgICAgICAgdmVjNCBiID0gZ2V0TWF0cml4QihyYy54LCBcIitsK1wiKTtcXG5cXG4gICAgICAgICAgcmVzdWx0ICs9IChcIitjWzBdK1wiICogXCIraFswXStcIikgKyAoXCIrY1sxXStcIiAqIFwiK2hbMV0rXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gZG90MngyQVJvd0JDb2wocmMpO1xcblxcbiAgICAgICAgXCIrZCtcIlxcblxcbiAgICAgICAgXCIrZitcIlxcblxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksamE9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wicHJvYnNcIl0sdGhpcy5vdXRwdXRTaGFwZT1bdCxuXSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdW5pZm9ybSBmbG9hdCBzZWVkO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcblxcbiAgICAgICAgZmxvYXQgciA9IHJhbmRvbShzZWVkKTtcXG4gICAgICAgIGZsb2F0IGNkZiA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrKGUtMSkrXCI7IGkrKykge1xcbiAgICAgICAgICBjZGYgKz0gZ2V0UHJvYnMoYmF0Y2gsIGkpO1xcblxcbiAgICAgICAgICBpZiAociA8IGNkZikge1xcbiAgICAgICAgICAgIHNldE91dHB1dChmbG9hdChpKSk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBJZiBubyBvdGhlciBldmVudCBoYXBwZW5lZCwgbGFzdCBldmVudCBoYXBwZW5lZC5cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChcIisoZS0xKStcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiBmdW5jdGlvbihuLHIpe251bGw9PWUuc2VlZExvYyYmKGUuc2VlZExvYz1uLmdldFVuaWZvcm1Mb2NhdGlvbihyLFwic2VlZFwiKSksbi5nbC51bmlmb3JtMWYoZS5zZWVkTG9jLHQpfX0sdH0oKSxLYT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiaW5kaWNlc1wiXSx0aGlzLm91dHB1dFNoYXBlPVt0LGVdLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBpbmRleCA9IHJvdW5kKGdldEluZGljZXMoY29vcmRzLngpKTtcXG4gICAgICAgIHNldE91dHB1dChtaXgoZmxvYXQoXCIrcitcIiksIGZsb2F0KFwiK24rXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICBmbG9hdChpbmRleCA9PSBjb29yZHMueSkpKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxYYT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLmlzUGFja1NoYWRlcj0hMCx0aGlzLm91dHB1dFNoYXBlPXQ7dmFyIGU9dC5sZW5ndGg7aWYoMD09PWUpdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBzZXRPdXRwdXQodmVjNChnZXRBKCksIDAuLCAwLiwgMC4pKTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtlbHNle3ZhciBuPW9vKFwicmNcIixlKSxyPWJvKGUpLG89ZnVuY3Rpb24odCxlLG4pe2lmKDE9PT10KXJldHVyblwicmMgPiBcIitlWzBdO2Zvcih2YXIgcj1cIlwiLG89dC0yO288dDtvKyspcis9bltvXStcIiA+PSBcIitlW29dLG88dC0xJiYocis9XCJ8fFwiKTtyZXR1cm4gcn0oZSx0LG4pLGE9ZnVuY3Rpb24odCxlLG4scil7aWYoMT09PXQpcmV0dXJuXCJcIjt2YXIgbz1yLnNsaWNlKC0yKTtyZXR1cm5cIlxcbiAgICBpbnQgciA9IFwiK29bMF0rXCI7XFxuICAgIGludCBjID0gXCIrb1sxXStcIjtcXG4gICAgaW50IHJwMSA9IHIgKyAxO1xcbiAgICBpbnQgY3AxID0gYyArIDE7XFxuXFxuICAgIGJvb2wgY0VkZ2UgPSBjcDEgPj0gXCIrZStcIjtcXG4gICAgYm9vbCByRWRnZSA9IHJwMSA+PSBcIituK1wiO1xcbiAgXCJ9KGUsdFt0Lmxlbmd0aC0xXSx0W3QubGVuZ3RoLTJdLG4pLGk9ZnVuY3Rpb24odCxlKXt2YXIgbj10Lmxlbmd0aCxyPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPVtdLHI9MDtyPD0xO3IrKylmb3IodmFyIG89MDtvPD0xO28rKyl7Zm9yKHZhciBhPSgwPT09cj9cInJcIjpcInJwMVwiKStcIiwgXCIrKDA9PT1vP1wiY1wiOlwiY3AxXCIpLGk9MjtpPHQ7aSsrKWE9ZVtlLmxlbmd0aC0xLWldK1wiLFwiK2E7bi5wdXNoKGEpfXJldHVybiBufShuLGUpO3JldHVybiAxPT09bj9cImdldEEocmMpLFxcbiAgICAgICAgICAgIHJjICsgMSA+PSBcIit0WzBdK1wiID8gMC4gOiBnZXRBKHJjICsgMSksXFxuICAgICAgICAgICAgMCwgMFwiOlwiZ2V0QShcIityWzBdK1wiKSxcXG4gICAgICAgICAgY0VkZ2UgPyAwLiA6IGdldEEoXCIrclsxXStcIiksXFxuICAgICAgICAgIHJFZGdlID8gMC4gOiBnZXRBKFwiK3JbMl0rXCIpLFxcbiAgICAgICAgICByRWRnZSB8fCBjRWRnZSA/IDAuIDogZ2V0QShcIityWzNdK1wiKVwifSh0LG4pO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgXCIrcitcIiByYyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgICBpZihcIitvK1wiKSB7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KHZlYzQoMCkpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIFwiK2ErXCJcXG5cXG4gICAgICAgICAgICBzZXRPdXRwdXQodmVjNChcIitpK1wiKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICBcIn19fSgpO3ZhciBZYT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT1lLm1hcChmdW5jdGlvbihlLG4pe3JldHVybiBlWzBdK3Rbbl0rZVsxXX0pO3ZhciByPXQubGVuZ3RoLG89Ym8ociksYT1lLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdFswXX0pLmpvaW4oXCIsXCIpLGk9ZS5tYXAoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZVswXSt0W25dfSkuam9pbihcIixcIikscz1bXCJjb29yZHNbMF1cIixcImNvb3Jkc1sxXVwiLFwiY29vcmRzWzJdXCIsXCJjb29yZHNbM11cIl0uc2xpY2UoMCxyKTt0aGlzLnVzZXJDb2RlPTEhPT1yP1wiXFxuICAgICAgXCIrbytcIiBzdGFydCA9IFwiK28rXCIoXCIrYStcIik7XFxuICAgICAgXCIrbytcIiBlbmQgPSBcIitvK1wiKFwiK2krXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK28rXCIgb3V0QyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaWYgKGFueShsZXNzVGhhbihvdXRDLCBzdGFydCkpIHx8IGFueShncmVhdGVyVGhhbkVxdWFsKG91dEMsIGVuZCkpKSB7XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChcIituK1wiKSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBcIitvK1wiIGNvb3JkcyA9IG91dEMgLSBzdGFydDtcXG4gICAgICAgICAgc2V0T3V0cHV0KGdldFgoXCIrcytcIikpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgXCI6XCJcXG4gICAgICAgIGludCBzdGFydCA9IFwiK2ErXCI7XFxuICAgICAgICBpbnQgZW5kID0gXCIraStcIjtcXG5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgaW50IG91dEMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgaWYgKG91dEMgPCBzdGFydCB8fCBvdXRDID49IGVuZCkge1xcbiAgICAgICAgICAgIHNldE91dHB1dChmbG9hdChcIituK1wiKSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KGdldFgob3V0QyAtIHN0YXJ0KSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICBcIn19KCksUWE9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwLHRoaXMub3V0cHV0U2hhcGU9ZS5tYXAoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZVswXSt0W25dK2VbMV19KTtmb3IodmFyIHI9dC5sZW5ndGgsbz1ibyhyKSxhPWUubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0WzBdfSkuam9pbihcIixcIiksaT1lLm1hcChmdW5jdGlvbihlLG4pe3JldHVybiBlWzBdK3Rbbl19KS5qb2luKFwiLFwiKSxzPW9vKFwicmNcIixyKSx1PW9vKFwic291cmNlXCIsciksbD1zW3ItMV0rXCIgPCBcIit0aGlzLm91dHB1dFNoYXBlW3ItMV0sYz0xPT09cj9cInNvdXJjZVwiOlwidmVjMihcIit1LnNsaWNlKC0yKS5qb2luKCkrXCIpXCIsaD1bbytcIiByYyA9IG91dHB1dExvYztcIixzW3ItMV0rXCIgKz0gMTtcXG4gICAgICAgaWYoXCIrbCtcIikge1xcbiAgICAgIFwiLDE9PT1yP1wiXCI6XCJ9XFxuICAgICAgIHJjID0gb3V0cHV0TG9jO1xcbiAgICAgICBcIitzW3ItMl0rXCIgKz0gMTtcXG4gICAgICAgaWYoXCIrc1tyLTJdK1wiIDwgXCIrdGhpcy5vdXRwdXRTaGFwZVtyLTJdK1wiKSB7XCIsMT09PXI/XCJcIjpcIiAgXCIrc1tyLTFdK1wiICs9IDE7XFxuICAgICAgICAgaWYoXCIrbCtcIikge1wiXSxwPTE9PT1yP1wicmMgPCBzdGFydCB8fCByYyA+PSBlbmRcIjpcImFueShsZXNzVGhhbihyYywgc3RhcnQpKSB8fCBhbnkoZ3JlYXRlclRoYW5FcXVhbChyYywgZW5kKSlcIixmPVwiXCIsZD0wLHY9MT09PXI/Mjo0O2Q8djtkKyspZis9XCJcXG4gICAgICAgIFwiK2hbZF0rXCJcXG4gICAgICAgIGlmIChcIitwK1wiKSB7XFxuICAgICAgICAgIHJlc3VsdFtcIitkK1wiXSA9IGZsb2F0KFwiK24rXCIpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgXCIrbytcIiBzb3VyY2UgPSByYyAtIHN0YXJ0O1xcbiAgICAgICAgICByZXN1bHRbXCIrZCtcIl0gPSBnZXRDaGFubmVsKGdldFgoXCIrdS5qb2luKCkrXCIpLCBcIitjK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtmKz0xPT09cj9cIn0gXCI6XCJ9fVwiLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBcIitvK1wiIHN0YXJ0ID0gXCIrbytcIihcIithK1wiKTtcXG4gICAgICBjb25zdCBcIitvK1wiIGVuZCA9IFwiK28rXCIoXCIraStcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbytcIiBvdXRwdXRMb2MgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuICAgICAgICBcIitmK1wiXFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxKYT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbil7aWYodGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sXCJhdmdcIj09PWUmJm4pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgcG9zaXRpb25zIGZvciBhdmVyYWdlIHBvb2wuXCIpO3ZhciByPXQuZmlsdGVyV2lkdGgsbz10LnN0cmlkZUhlaWdodCxhPXQuc3RyaWRlV2lkdGgsaT10LmRpbGF0aW9uSGVpZ2h0LHM9dC5kaWxhdGlvbldpZHRoLHU9dC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsbD10LmVmZmVjdGl2ZUZpbHRlcldpZHRoLGM9dC5wYWRJbmZvLnRvcCxoPXQucGFkSW5mby5sZWZ0O3RoaXMub3V0cHV0U2hhcGU9dC5vdXRTaGFwZTt2YXIgcD1cImF2Z1wiPT09ZSxmPVwiMC4wXCI7aWYocHx8KGY9XCItMS4wIC8gMWUtMjBcIiksbil0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIrbytcIiwgXCIrYStcIik7XFxuICAgICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIrYytcIiwgXCIraCtcIik7XFxuXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XFxuICAgICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgICAvLyBtYXgvbWluIHgoPywgPywgZCkgdG8gZ2V0IHkoeVIsIHlDLCBkKS5cXG4gICAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWRcXG4gICAgICAgICAgZmxvYXQgbWluTWF4VmFsdWUgPSAwLjA7XFxuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlRm91bmQgPSAwLjA7XFxuICAgICAgICAgIGludCBtaW5NYXhQb3NpdGlvbiA9IDA7XFxuICAgICAgICAgIGZsb2F0IGF2Z1ZhbHVlID0gMC4wO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrdStcIjtcXG4gICAgICAgICAgICAgIHdSICs9IFwiK2krXCIpIHtcXG4gICAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrdC5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIitsK1wiO1xcbiAgICAgICAgICAgICAgICB3QyArPSBcIitzK1wiKSB7XFxuICAgICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDO1xcblxcbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIit0LmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldFgoYmF0Y2gsIHhSLCB4QywgZCk7XFxuXFxuICAgICAgICAgICAgICAvLyBJZiBhIG1pbiAvIG1heCB2YWx1ZSBoYXMgYWxyZWFkeSBiZWVuIGZvdW5kLCB1c2UgaXQuIElmIG5vdCxcXG4gICAgICAgICAgICAgIC8vIHVzZSB0aGUgY3VycmVudCB2YWx1ZS5cXG4gICAgICAgICAgICAgIGZsb2F0IGN1cnJNaW5NYXhWYWx1ZSA9IG1peChcXG4gICAgICAgICAgICAgICAgICB2YWx1ZSwgbWluTWF4VmFsdWUsIG1pbk1heFZhbHVlRm91bmQpO1xcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID49IGN1cnJNaW5NYXhWYWx1ZSkge1xcbiAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZSA9IHZhbHVlO1xcbiAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZUZvdW5kID0gMS4wO1xcbiAgICAgICAgICAgICAgICBtaW5NYXhQb3NpdGlvbiA9IHdSICogXCIrbCtcIiArIHdDO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQobWluTWF4UG9zaXRpb24pKTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtlbHNle3ZhciBkPWUrXCIoXCIrZStcIihcIitlK1wiKG1pbk1heFZhbHVlWzBdLCBtaW5NYXhWYWx1ZVsxXSksIG1pbk1heFZhbHVlWzJdKSwgbWluTWF4VmFsdWVbM10pXCI7XCJhdmdcIj09PWUmJihkPVwiYXZnVmFsdWUgLyBjb3VudFwiKTt2YXIgdj00Kk1hdGguZmxvb3Ioci80KSxtPXIlNCxnPVwiXFxuICAgICAgaWYgKFwiK3ArXCIpIHtcXG4gICAgICAgIGF2Z1ZhbHVlICs9IGRvdCh2YWx1ZXMsIG9uZXMpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBtaW5NYXhWYWx1ZSA9IG1heCh2YWx1ZXMsIG1pbk1heFZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIrbytcIiwgXCIrYStcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2MrXCIsIFwiK2grXCIpO1xcbiAgICAgIGNvbnN0IGZsb2F0IGluaXRpYWxpemF0aW9uVmFsdWUgPSBcIitmK1wiO1xcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgICBmbG9hdCBjb3VudCA9IDAuMDtcXG5cXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCB4UiwgaW50IHhDLCBpbnQgZCkge1xcbiAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIit0LmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIGluaXRpYWxpemF0aW9uVmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgICBjb3VudCArPSAxLjA7XFxuICAgICAgICByZXR1cm4gZ2V0WChiYXRjaCwgeFIsIHhDLCBkKTtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy55eiAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIG1heC9taW4geCg/LCA/LCBkKSB0byBnZXQgeSh5UiwgeUMsIGQpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWRcXG4gICAgICAgIHZlYzQgbWluTWF4VmFsdWUgPSB2ZWM0KFwiK2YrXCIpO1xcbiAgICAgICAgZmxvYXQgYXZnVmFsdWUgPSAwLjA7XFxuICAgICAgICBjb3VudCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIit1K1wiO1xcbiAgICAgICAgICAgIHdSICs9IFwiK2krXCIpIHtcXG4gICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UjtcXG5cXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIit0LmluSGVpZ2h0K1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK3YrXCI7IHdDICs9IDQpIHtcXG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogXCIrcytcIjtcXG5cXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyBcIitzK1wiLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAyICogXCIrcytcIiwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMyAqIFwiK3MrXCIsIGQpXFxuICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICBcIitnK1wiXFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyBcIit2K1wiO1xcbiAgICAgICAgICBpZiAoXCIrKDE9PT1tKStcIikge1xcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICBcIitnK1wiXFxuICAgICAgICAgIH0gZWxzZSBpZiAoXCIrKDI9PT1tKStcIikge1xcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIFwiK3MrXCIsIGQpLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiK2crXCJcXG4gICAgICAgICAgfSBlbHNlIGlmIChcIisoMz09PW0pK1wiKSB7XFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgXCIrcytcIiwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMiAqIFwiK3MrXCIsIGQpLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIrZytcIlxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoXCIrZCtcIik7XFxuICAgICAgfVxcbiAgICBcIn19fSgpLFphPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl07dmFyIG49dC53aW5kb3dTaXplLHI9dC5iYXRjaFNpemUsbz10LmluU2l6ZSxhPU1hdGguY2VpbChvL24pO3RoaXMub3V0cHV0U2hhcGU9W3IsYV07dmFyIGk9XCIwLjBcIixzPVwiXCI7XCJwcm9kXCI9PT1lP2k9XCIxLjBcIjpcIm1pblwiPT09ZT8oaT1cIjEuMCAvIDFlLTIwXCIscz1cIm1pblwiKTpcIm1heFwiPT09ZSYmKGk9XCItMS4wIC8gMWUtMjBcIixzPVwibWF4XCIpO3ZhciB1PWUrXCIoXCIrZStcIihcIitlK1wiKG1pbk1heFZhbHVlWzBdLCBtaW5NYXhWYWx1ZVsxXSksIG1pbk1heFZhbHVlWzJdKSwgbWluTWF4VmFsdWVbM10pXCI7XCJzdW1cIj09PWU/dT1cInN1bVZhbHVlXCI6XCJwcm9kXCI9PT1lP3U9XCJwcm9kVmFsdWVcIjpcImFsbFwiPT09ZT91PVwiYWxsVmFsdWVcIjpcImFueVwiPT09ZSYmKHU9XCJhbnlWYWx1ZVwiKTt2YXIgbD00Kk1hdGguZmxvb3Iobi80KSxjPW4lNCxoPVwiXFxuICAgICAgaWYgKFwiKyhcInN1bVwiPT09ZSkrXCIpIHtcXG4gICAgICAgIHN1bVZhbHVlICs9IGRvdCh2YWx1ZXMsIG9uZXMpO1xcbiAgICAgIH0gZWxzZSBpZiAoXCIrKFwicHJvZFwiPT09ZSkrXCIpIHtcXG4gICAgICAgIHZlYzIgdG1wID0gdmVjMih2YWx1ZXNbMF0sIHZhbHVlc1sxXSkgKiB2ZWMyKHZhbHVlc1syXSwgdmFsdWVzWzNdKTtcXG4gICAgICAgIHByb2RWYWx1ZSAqPSB0bXBbMF0gKiB0bXBbMV07XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG1pbk1heFZhbHVlID0gXCIrcytcIih2YWx1ZXMsIG1pbk1heFZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwiLHA9XCJ2ZWM0XCI7XCJhbGxcIj09PWU/KGk9XCIxLjBcIixoPVwiXFxuICAgICAgICBib29sIHJlZHVjZWRBbGxWYWx1ZSA9IGFsbCh2YWx1ZXMpO1xcbiAgICAgICAgZmxvYXQgZmxvYXRlZFJlZHVjZWRBbGxWYWx1ZSA9IGZsb2F0KHJlZHVjZWRBbGxWYWx1ZSk7XFxuICAgICAgICBhbGxWYWx1ZSA9IGZsb2F0KGFsbFZhbHVlID49IDEuMCAmJiBmbG9hdGVkUmVkdWNlZEFsbFZhbHVlID49IDEuMCk7XFxuICAgICAgXCIscD1cImJ2ZWM0XCIpOlwiYW55XCI9PT1lJiYoaT1cIjAuMFwiLGg9XCJcXG4gICAgICAgIGJvb2wgcmVkdWNlZEFueVZhbHVlID0gYW55KHZhbHVlcyk7XFxuICAgICAgICBmbG9hdCBmbG9hdGVkUmVkdWNlZEFueVZhbHVlID0gZmxvYXQocmVkdWNlZEFueVZhbHVlKTtcXG4gICAgICAgIGFueVZhbHVlID0gZmxvYXQoYW55VmFsdWUgPj0gMS4wIHx8IGZsb2F0ZWRSZWR1Y2VkQW55VmFsdWUgPj0gMS4wKTtcXG4gICAgICBcIixwPVwiYnZlYzRcIik7dmFyIGY9XCJcIjtvJW4+MCYmKGY9XCJcXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gXCIrbytcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICBcIiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGZsb2F0IGluaXRpYWxpemF0aW9uVmFsdWUgPSBcIitpK1wiO1xcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCBpbklkeCkge1xcbiAgICAgICAgXCIrZitcIlxcbiAgICAgICAgcmV0dXJuIGdldFgoYmF0Y2gsIGluSWR4KTtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGluT2Zmc2V0ID0gb3V0SWR4ICogXCIrbitcIjtcXG5cXG4gICAgICAgIHZlYzQgbWluTWF4VmFsdWUgPSB2ZWM0KFwiK2krXCIpO1xcbiAgICAgICAgZmxvYXQgcHJvZFZhbHVlID0gMS4wO1xcbiAgICAgICAgZmxvYXQgc3VtVmFsdWUgPSAwLjA7XFxuICAgICAgICBmbG9hdCBhbGxWYWx1ZSA9IDEuMDtcXG4gICAgICAgIGZsb2F0IGFueVZhbHVlID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIitsK1wiOyBpICs9IDQpIHtcXG4gICAgICAgICAgaW50IGluSWR4ID0gaW5PZmZzZXQgKyBpO1xcbiAgICAgICAgICBcIitwK1wiIHZhbHVlcyA9IFwiK3ArXCIoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAyKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAzKVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitoK1wiXFxuICAgICAgICB9XFxuXFxuICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIFwiK2wrXCI7XFxuICAgICAgICBpZiAoXCIrKDE9PT1jKStcIikge1xcbiAgICAgICAgICBcIitwK1wiIHZhbHVlcyA9IFwiK3ArXCIoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitoK1wiXFxuICAgICAgICB9IGVsc2UgaWYgKFwiKygyPT09YykrXCIpIHtcXG4gICAgICAgICAgXCIrcCtcIiB2YWx1ZXMgPSBcIitwK1wiKFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK2grXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIrKDM9PT1jKStcIikge1xcbiAgICAgICAgICBcIitwK1wiIHZhbHVlcyA9IFwiK3ArXCIoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAyKSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK2grXCJcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChcIit1K1wiKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSx0aT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwLHRoaXMub3V0cHV0U2hhcGU9dDtmb3IodmFyIG49XCJcIixyPTA7cjw0O3IrKyl7dmFyIG89XCJ0aGlzUkMgPSByYztcIjtyJTI9PTEmJihvKz1cInRoaXNSQy56ICs9IDE7XCIpLHI+MSYmKG8rPVwidGhpc1JDLnkgKz0gMTtcIiksbis9XCJcXG4gICAgICAgIFwiK28rXCJcXG4gICAgICAgIFwiKyhyPjA/XCJpZih0aGlzUkMueSA8IHJvd3MgJiYgdGhpc1JDLnogPCBjb2xzKXtcIjpcIlwiKStcIlxcbiAgICAgICAgICBpbnQgZmxhdEluZGV4ID0gZ2V0RmxhdEluZGV4KHRoaXNSQyk7XFxuXFxuICAgICAgICAgIGl2ZWMzIGlucHV0UkMgPSBpbnB1dENvb3Jkc0Zyb21SZXNoYXBlZE91dENvb3JkcyhmbGF0SW5kZXgpO1xcbiAgICAgICAgICB2ZWMyIGlucHV0UkNJbm5lckRpbXMgPSB2ZWMyKGZsb2F0KGlucHV0UkMueSksZmxvYXQoaW5wdXRSQy56KSk7XFxuXFxuICAgICAgICAgIHJlc3VsdFtcIityK1wiXSA9XFxuICAgICAgICAgICAgZ2V0Q2hhbm5lbChnZXRBKGlucHV0UkMueCwgaW5wdXRSQy55LCBpbnB1dFJDLnopLCBpbnB1dFJDSW5uZXJEaW1zKTtcXG4gICAgICAgIFwiKyhyPjA/XCJ9XCI6XCJcIikrXCJcXG4gICAgICBcIn10aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgXFxuICAgIGl2ZWMzIGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGludCBpbmRleCkge1xcbiAgICAgIFwiK2xvKFtcInJcIixcImNcIixcImRcIl0sZSkrXCJcXG4gICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XFxuICAgIH1cXG4gIFxcbiAgICAgIFwiK2Z1bmN0aW9uKHQpe3JldHVyblwiXFxuICAgIGludCBnZXRGbGF0SW5kZXgoaXZlYzMgY29vcmRzKSB7XFxuICAgICAgcmV0dXJuIHJvdW5kKFwiK2Z1bmN0aW9uKHQsZSl7aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJWZWN0b3JzIHRvIGJlIGRvdHRlZCBtdXN0IGJlIG9mIHRoZSBzYW1lIGxlbmd0aCAtZ290IFwiK3QubGVuZ3RoK1wiIGFuZCBcIitlLmxlbmd0aCk7Zm9yKHZhciBuPVtdLHI9TWF0aC5mbG9vcih0Lmxlbmd0aC80KSxvPXQubGVuZ3RoJTQsYT0wO2E8cjthKyspe3ZhciBpPXQuc2xpY2UoNCphLDQqYSs0KSxzPWUuc2xpY2UoNCphLDQqYSs0KTtuLnB1c2goY28oaSkrXCIsIFwiK2NvKHMpKX1yZXR1cm4gMCE9PW8mJihpPXQuc2xpY2UoNCpyKSxzPWUuc2xpY2UoNCpyKSwxPT09aS5sZW5ndGgmJihpPWkubWFwKGZ1bmN0aW9uKHQpe3JldHVyblwiZmxvYXQoXCIrdCtcIilcIn0pLHM9cy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJmbG9hdChcIit0K1wiKVwifSkpLG4ucHVzaChjbyhpKStcIiwgXCIrY28ocykpKSxuLm1hcChmdW5jdGlvbih0LGUpe3JldHVyblwiZG90KFwiK3QrXCIpXCJ9KS5qb2luKFwiK1wiKX0oW1wiY29vcmRzLnhcIixcImNvb3Jkcy55XCIsXCJjb29yZHMuelwiXSxWKHQpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC50b1N0cmluZygpfSkuY29uY2F0KFtcIjEuXCJdKSkrXCIpO1xcbiAgICB9XFxuICBcIn0odCkrXCJcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyByYyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG5cXG4gICAgICAgIGl2ZWMzIHRoaXNSQztcXG4gICAgICAgIGludCByb3dzID0gXCIrdFsxXStcIjtcXG4gICAgICAgIGludCBjb2xzID0gXCIrdFsyXStcIjtcXG5cXG4gICAgICAgIFwiK24rXCJcXG5cXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpO3ZhciBlaT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT1lLnNoYXBlO3ZhciByPWUuc2hhcGUsbz1yWzFdLGE9clsyXSxpPXQuc2hhcGUscz1pWzFdLHU9aVsyXSxsPVtuJiZzPjE/by0xOm8sbiYmdT4xP2EtMTphXSxjPVtuJiZzPjE/cy0xOnMsbiYmdT4xP3UtMTp1XSxoPWxbMF0vY1swXSxwPWxbMV0vY1sxXSxmPTEvaCxkPTEvcCx2PTIqTWF0aC5jZWlsKGYpKzIsbT0yKk1hdGguY2VpbChkKSsyO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICBpbnQgciA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBjID0gY29vcmRzWzJdO1xcblxcbiAgICAgICAgZmxvYXQgYWNjdW11bGF0b3IgPSAwLjA7XFxuXFxuICAgICAgICBjb25zdCBmbG9hdCBoZWlnaHRTY2FsZSA9IGZsb2F0KFwiK2grXCIpO1xcbiAgICAgICAgY29uc3QgZmxvYXQgd2lkdGhTY2FsZSA9IGZsb2F0KFwiK3ArXCIpO1xcblxcbiAgICAgICAgY29uc3QgZmxvYXQgaW52SGVpZ2h0U2NhbGUgPSBmbG9hdChcIitmK1wiKTtcXG4gICAgICAgIGNvbnN0IGZsb2F0IGludldpZHRoU2NhbGUgPSBmbG9hdChcIitkK1wiKTtcXG5cXG4gICAgICAgIGNvbnN0IGludCB3aW5IZWlnaHQgPSBpbnQoXCIrditcIik7XFxuICAgICAgICBjb25zdCBpbnQgd2luV2lkdGggPSBpbnQoXCIrbStcIik7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIGJvdW5kcyBmb3Igd2hlcmUgaW4gZHkgd2Ugd2lsbCBsb29rXFxuICAgICAgICBmbG9hdCBzdGFydFJMZXJwID0gZmxvb3IoZmxvYXQocikgKiBpbnZIZWlnaHRTY2FsZSk7XFxuICAgICAgICBpbnQgc3RhcnREeVIgPSBpbnQoc3RhcnRSTGVycCAtIGZsb2F0KHdpbkhlaWdodCAvIDIpKTtcXG5cXG4gICAgICAgIGZsb2F0IHN0YXJ0Q0xlcnAgPSBmbG9vcihmbG9hdChjKSAqIGludldpZHRoU2NhbGUpO1xcbiAgICAgICAgaW50IHN0YXJ0RHlDID0gaW50KHN0YXJ0Q0xlcnAgLSBmbG9hdCh3aW5XaWR0aCAvIDIpKTtcXG5cXG4gICAgICAgIC8vIExvb3Agb3ZlciBkeVxcbiAgICAgICAgZm9yIChpbnQgZHlST2Zmc2V0ID0gMDsgZHlST2Zmc2V0IDwgd2luSGVpZ2h0OyBkeVJPZmZzZXQrKykge1xcbiAgICAgICAgICBpbnQgZHlSID0gZHlST2Zmc2V0ICsgc3RhcnREeVI7XFxuXFxuICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIHdpbmRvdyBleGNlZWRpbmcgdGhlIGJvdW5kcyBvZiBkeVxcbiAgICAgICAgICBpZiAoZHlSIDwgMCB8fCBkeVIgPj0gXCIrcytcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IGR5Q09mZnNldCA9IDA7IGR5Q09mZnNldCA8IHdpbldpZHRoOyBkeUNPZmZzZXQrKykge1xcbiAgICAgICAgICAgIGludCBkeUMgPSBkeUNPZmZzZXQgKyBzdGFydER5QztcXG5cXG4gICAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHRoZSB3aW5kb3cgZXhjZWVkaW5nIHRoZSBib3VuZHMgb2YgZHlcXG4gICAgICAgICAgICBpZiAoZHlDIDwgMCB8fCBkeUMgPj0gXCIrdStcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZsb2F0IGR4UiA9IGZsb2F0KGR5UikgKiBoZWlnaHRTY2FsZTtcXG4gICAgICAgICAgICBpbnQgdG9wRHhSSW5kZXggPSBpbnQoZmxvb3IoZHhSKSk7XFxuICAgICAgICAgICAgaW50IGJvdHRvbUR4UkluZGV4ID0gaW50KG1pbihjZWlsKGR4UiksIFwiKyhvLTEpK1wiLjApKTtcXG4gICAgICAgICAgICBmbG9hdCBkeFJMZXJwID0gZHhSIC0gZmxvYXQodG9wRHhSSW5kZXgpO1xcbiAgICAgICAgICAgIGZsb2F0IGludmVyc2VEeFJMZXJwID0gMS4wIC0gZHhSTGVycDtcXG5cXG4gICAgICAgICAgICBmbG9hdCBkeEMgPSBmbG9hdChkeUMpICogd2lkdGhTY2FsZTtcXG4gICAgICAgICAgICBpbnQgbGVmdER4Q0luZGV4ID0gaW50KGZsb29yKGR4QykpO1xcbiAgICAgICAgICAgIGludCByaWdodER4Q0luZGV4ID0gaW50KG1pbihjZWlsKGR4QyksIFwiKyhhLTEpK1wiLjApKTtcXG4gICAgICAgICAgICBmbG9hdCBkeENMZXJwID0gZHhDIC0gZmxvYXQobGVmdER4Q0luZGV4KTtcXG4gICAgICAgICAgICBmbG9hdCBpbnZlcnNlRHhDTGVycCA9IDEuMCAtIGR4Q0xlcnA7XFxuXFxuICAgICAgICAgICAgaWYgKHIgPT0gdG9wRHhSSW5kZXggJiYgYyA9PSBsZWZ0RHhDSW5kZXgpIHtcXG4gICAgICAgICAgICAgIC8vIHRvcExlZnRcXG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yICs9XFxuICAgICAgICAgICAgICAgIGdldER5KGIsIGR5UiwgZHlDLCBkKSAqIGludmVyc2VEeFJMZXJwICogaW52ZXJzZUR4Q0xlcnA7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChyID09IHRvcER4UkluZGV4ICYmIGMgPT0gcmlnaHREeENJbmRleCkge1xcbiAgICAgICAgICAgICAgLy8gdG9wUmlnaHRcXG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yICs9IGdldER5KGIsIGR5UiwgZHlDLCBkKSAqIGludmVyc2VEeFJMZXJwICogZHhDTGVycDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHIgPT0gYm90dG9tRHhSSW5kZXggJiYgYyA9PSBsZWZ0RHhDSW5kZXgpIHtcXG4gICAgICAgICAgICAgIC8vIGJvdHRvbUxlZnRcXG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yICs9IGdldER5KGIsIGR5UiwgZHlDLCBkKSAqIGR4UkxlcnAgKiBpbnZlcnNlRHhDTGVycDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHIgPT0gYm90dG9tRHhSSW5kZXggJiYgYyA9PSByaWdodER4Q0luZGV4KSB7XFxuICAgICAgICAgICAgICAvLyBib3R0b21SaWdodFxcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz0gZ2V0RHkoYiwgZHlSLCBkeUMsIGQpICogZHhSTGVycCAqIGR4Q0xlcnA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICAvLyBFbmQgbG9vcCBvdmVyIGR5XFxuXFxuICAgICAgICBzZXRPdXRwdXQoYWNjdW11bGF0b3IpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLG5pPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMub3V0cHV0U2hhcGU9W107dmFyIG89dFswXSxhPXRbMV0saT10WzJdLHM9dFszXTt0aGlzLm91dHB1dFNoYXBlPVtvLGUsbixzXTt2YXIgdT1bciYmZT4xP2EtMTphLHImJm4+MT9pLTE6aV0sbD1bciYmZT4xP2UtMTplLHImJm4+MT9uLTE6bl07dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IHZlYzIgZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQyA9IHZlYzIoXFxuICAgICAgICAgIFwiK3VbMF0vbFswXStcIixcXG4gICAgICAgICAgXCIrdVsxXS9sWzFdK1wiKTtcXG4gICAgICBjb25zdCB2ZWMyIGlucHV0U2hhcGVSQyA9IHZlYzIoXCIrYStcIi4wLCBcIitpK1wiLjApO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGl2ZWMyIHlSQyA9IGNvb3Jkcy55ejtcXG5cXG4gICAgICAgIC8vIEZyYWN0aW9uYWwgc291cmNlIGluZGV4LlxcbiAgICAgICAgdmVjMiBzb3VyY2VGcmFjSW5kZXhSQyA9IHZlYzIoeVJDKSAqIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkM7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIHRoZSBmb3VyIGludGVnZXIgaW5kaWNlcy5cXG4gICAgICAgIGl2ZWMyIHNvdXJjZUZsb29yUkMgPSBpdmVjMihzb3VyY2VGcmFjSW5kZXhSQyk7XFxuICAgICAgICBpdmVjMiBzb3VyY2VDZWlsUkMgPSBpdmVjMihcXG4gICAgICAgICAgbWluKGlucHV0U2hhcGVSQyAtIDEuMCwgY2VpbChzb3VyY2VGcmFjSW5kZXhSQykpKTtcXG5cXG4gICAgICAgIGZsb2F0IHRvcExlZnQgPSBnZXRBKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy55LCBkKTtcXG4gICAgICAgIGZsb2F0IGJvdHRvbUxlZnQgPSBnZXRBKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VGbG9vclJDLnksIGQpO1xcbiAgICAgICAgZmxvYXQgdG9wUmlnaHQgPSBnZXRBKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnksIGQpO1xcbiAgICAgICAgZmxvYXQgYm90dG9tUmlnaHQgPSBnZXRBKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueSwgZCk7XFxuXFxuICAgICAgICB2ZWMyIGZyYWNSQyA9IHNvdXJjZUZyYWNJbmRleFJDIC0gdmVjMihzb3VyY2VGbG9vclJDKTtcXG5cXG4gICAgICAgIGZsb2F0IHRvcCA9IHRvcExlZnQgKyAodG9wUmlnaHQgLSB0b3BMZWZ0KSAqIGZyYWNSQy55O1xcbiAgICAgICAgZmxvYXQgYm90dG9tID0gYm90dG9tTGVmdCArIChib3R0b21SaWdodCAtIGJvdHRvbUxlZnQpICogZnJhY1JDLnk7XFxuICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IHRvcCArIChib3R0b20gLSB0b3ApICogZnJhY1JDLng7XFxuXFxuICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLHJpPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwLHRoaXMub3V0cHV0U2hhcGU9W107dmFyIG89dFswXSxhPXRbMV0saT10WzJdLHM9dFszXTt0aGlzLm91dHB1dFNoYXBlPVtvLGUsbixzXTt2YXIgdT1bciYmZT4xP2EtMTphLHImJm4+MT9pLTE6aV0sbD1bciYmZT4xP2UtMTplLHImJm4+MT9uLTE6bl07dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IHZlYzMgZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQyA9IHZlYzMoXFxuICAgICAgICAgIFwiK3VbMF0vbFswXStcIixcXG4gICAgICAgICAgXCIrdVsxXS9sWzFdK1wiLFxcbiAgICAgICAgICBcIit1WzFdL2xbMV0rXCIpO1xcbiAgICAgIGNvbnN0IHZlYzMgaW5wdXRTaGFwZVJDID0gdmVjMyhcIithK1wiLjAsIFwiK2krXCIuMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIraStcIi4wKTtcXG5cXG4gICAgICBmbG9hdCBnZXRBVmFsdWUoaW50IGIsIGludCByLCBpbnQgYywgaW50IGQpIHtcXG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKGdldEEoYiwgciwgYywgZCksIHZlYzIoYywgZCkpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICAvLyBDYWxjdWxhdGUgdmFsdWVzIGZvciBuZXh0IGNvbHVtbiBpbiB5UkMuei5cXG4gICAgICAgIGl2ZWMzIHlSQyA9IGNvb3Jkcy55enogKyBpdmVjMygwLCAwLCAxKTtcXG5cXG4gICAgICAgIC8vIEZyYWN0aW9uYWwgc291cmNlIGluZGV4LlxcbiAgICAgICAgdmVjMyBzb3VyY2VGcmFjSW5kZXhSQyA9IHZlYzMoeVJDKSAqIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkM7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIHRoZSBmb3VyIGludGVnZXIgaW5kaWNlcy5cXG4gICAgICAgIGl2ZWMzIHNvdXJjZUZsb29yUkMgPSBpdmVjMyhzb3VyY2VGcmFjSW5kZXhSQyk7XFxuICAgICAgICBpdmVjMyBzb3VyY2VDZWlsUkMgPSBpdmVjMyhcXG4gICAgICAgICAgbWluKGlucHV0U2hhcGVSQyAtIDEuMCwgY2VpbChzb3VyY2VGcmFjSW5kZXhSQykpKTtcXG4gICAgICAgIFxcbiAgICAgICAgLy8gU2hvdWxkIHdlIGNhbGN1bGF0ZSBuZXh0IGNvbHVtbiBhbmQgcm93IGVsZW1lbnRzIGluIDJ4MiBwYWNrZWQgY2VsbC5cXG4gICAgICAgIGJvb2wgaGFzTmV4dENvbCA9IGQgPCBcIisocy0xKStcIjsgXFxuICAgICAgICBib29sIGhhc05leHRSb3cgPSBjb29yZHMueiA8IFwiKyhuLTEpK1wiO1xcblxcbiAgICAgICAgLy8gSW4gcGFyYWxsZWwsIGNvbnN0cnVjdCBmb3VyIGNvcm5lcnMgZm9yIGFsbCBmb3VyIGNvbXBvbmVudHMgaW5cXG4gICAgICAgIC8vIHBhY2tlZCAyeDIgY2VsbC5cXG4gICAgICAgIHZlYzQgdG9wTGVmdCA9IHZlYzQoXFxuICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUZsb29yUkMueSwgZCksXFxuICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnksIGQgKyAxKVxcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxcbiAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy56LCBkKVxcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxcbiAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/XFxuICAgICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy56LCBkICsgMSkgOiAwLjApO1xcblxcbiAgICAgICAgdmVjNCBib3R0b21MZWZ0ID0gdmVjNChcXG4gICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VGbG9vclJDLnksIGQpLFxcbiAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VGbG9vclJDLnksIGQgKyAxKVxcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxcbiAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VGbG9vclJDLnosIGQpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID9cXG4gICAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUZsb29yUkMueiwgZCArIDEpIDogMC4wKTtcXG5cXG4gICAgICAgIHZlYzQgdG9wUmlnaHQgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VDZWlsUkMueSwgZCksXFxuICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VDZWlsUkMueSwgZCArIDEpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VDZWlsUkMueiwgZClcXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcXG4gICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgP1xcbiAgICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUNlaWxSQy56LCBkICsgMSkgOiAwLjApO1xcblxcbiAgICAgICAgdmVjNCBib3R0b21SaWdodCA9IHZlYzQoXFxuICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlQ2VpbFJDLnksIGQpLFxcbiAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueSwgZCArIDEpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUNlaWxSQy56LCBkKVxcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxcbiAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/XFxuICAgICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueiwgZCArIDEpIDogMC4wKTtcXG5cXG4gICAgICAgIHZlYzMgZnJhY1JDID0gc291cmNlRnJhY0luZGV4UkMgLSB2ZWMzKHNvdXJjZUZsb29yUkMpO1xcblxcbiAgICAgICAgdmVjNCB0b3AgPSBtaXgodG9wTGVmdCwgdG9wUmlnaHQsIGZyYWNSQy55eXp6KTtcXG4gICAgICAgIHZlYzQgYm90dG9tID0gbWl4KGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCBmcmFjUkMueXl6eik7XFxuICAgICAgICB2ZWM0IG5ld1ZhbHVlID0gbWl4KHRvcCwgYm90dG9tLCBmcmFjUkMueCk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLG9pPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPWUuc2hhcGU7dmFyIHI9ZS5zaGFwZSxvPXJbMV0sYT1yWzJdLGk9dC5zaGFwZSxzPWlbMV0sdT1pWzJdLGw9W24mJnM+MT9vLTE6byxuJiZ1PjE/YS0xOmFdLGM9W24mJnM+MT9zLTE6cyxuJiZ1PjE/dS0xOnVdLGg9bFswXS9jWzBdLHA9bFsxXS9jWzFdLGY9MS9oLGQ9MS9wLHY9MipNYXRoLmNlaWwoZikrMixtPTIqTWF0aC5jZWlsKGQpKzI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XFxuXFxuICAgICAgICBmbG9hdCBhY2N1bXVsYXRvciA9IDAuMDtcXG5cXG4gICAgICAgIGNvbnN0IGZsb2F0IGhlaWdodFNjYWxlID0gZmxvYXQoXCIraCtcIik7XFxuICAgICAgICBjb25zdCBmbG9hdCB3aWR0aFNjYWxlID0gZmxvYXQoXCIrcCtcIik7XFxuXFxuICAgICAgICBjb25zdCBmbG9hdCBpbnZIZWlnaHRTY2FsZSA9IGZsb2F0KFwiK2YrXCIpO1xcbiAgICAgICAgY29uc3QgZmxvYXQgaW52V2lkdGhTY2FsZSA9IGZsb2F0KFwiK2QrXCIpO1xcblxcbiAgICAgICAgY29uc3QgaW50IHdpbkhlaWdodCA9IGludChcIit2K1wiKTtcXG4gICAgICAgIGNvbnN0IGludCB3aW5XaWR0aCA9IGludChcIittK1wiKTtcXG5cXG4gICAgICAgIC8vIENvbXB1dGUgYm91bmRzIGZvciB3aGVyZSBpbiBkeSB3ZSB3aWxsIGxvb2tcXG4gICAgICAgIGZsb2F0IHN0YXJ0UkxlcnAgPSBmbG9vcihmbG9hdChyKSAqIGludkhlaWdodFNjYWxlKTtcXG4gICAgICAgIGludCBzdGFydER5UiA9IGludChmbG9vcihzdGFydFJMZXJwIC0gZmxvYXQod2luSGVpZ2h0IC8gMikpKTtcXG5cXG4gICAgICAgIGZsb2F0IHN0YXJ0Q0xlcnAgPSBmbG9vcihmbG9hdChjKSAqIGludldpZHRoU2NhbGUpO1xcbiAgICAgICAgaW50IHN0YXJ0RHlDID0gaW50KGZsb29yKHN0YXJ0Q0xlcnAgLSBmbG9hdCh3aW5XaWR0aCAvIDIpKSk7XFxuXFxuICAgICAgICAvLyBMb29wIG92ZXIgZHlcXG4gICAgICAgIGZvciAoaW50IGR5Uk9mZnNldCA9IDA7IGR5Uk9mZnNldCA8IHdpbkhlaWdodDsgZHlST2Zmc2V0KyspIHtcXG4gICAgICAgICAgaW50IGR5UiA9IGR5Uk9mZnNldCArIHN0YXJ0RHlSO1xcblxcbiAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHRoZSB3aW5kb3cgZXhjZWVkaW5nIHRoZSBib3VuZHMgb2YgZHlcXG4gICAgICAgICAgaWYgKGR5UiA8IDAgfHwgZHlSID49IFwiK3MrXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCBkeUNPZmZzZXQgPSAwOyBkeUNPZmZzZXQgPCB3aW5XaWR0aDsgZHlDT2Zmc2V0KyspIHtcXG4gICAgICAgICAgICBpbnQgZHlDID0gZHlDT2Zmc2V0ICsgc3RhcnREeUM7XFxuXFxuICAgICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgd2luZG93IGV4Y2VlZGluZyB0aGUgYm91bmRzIG9mIGR5XFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAgfHwgZHlDID49IFwiK3UrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmbG9hdCBzb3VyY2VGcmFjUm93ID1cXG4gICAgICAgICAgICAgIGZsb2F0KFwiK2xbMF0rXCIpICpcXG4gICAgICAgICAgICAgICAgKGZsb2F0KGR5UikgLyBmbG9hdChcIitjWzBdK1wiKSk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgc291cmNlRnJhY0NvbCA9XFxuICAgICAgICAgICAgICAgIGZsb2F0KFwiK2xbMV0rXCIpICpcXG4gICAgICAgICAgICAgICAgICAoZmxvYXQoZHlDKSAvIGZsb2F0KFwiK2NbMV0rXCIpKTtcXG5cXG4gICAgICAgICAgICBpbnQgc291cmNlTmVhcmVzdFJvdyA9IGludChtaW4oXFxuICAgICAgICAgICAgICAgIGZsb2F0KGludChcIitvK1wiKSAtIDEpLFxcbiAgICAgICAgICAgICAgICBcIituK1wiID8gZmxvYXQocm91bmQoc291cmNlRnJhY1JvdykpIDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQoZmxvb3Ioc291cmNlRnJhY1JvdykpKSk7XFxuXFxuICAgICAgICAgICAgaW50IHNvdXJjZU5lYXJlc3RDb2wgPSBpbnQobWluKFxcbiAgICAgICAgICAgICAgICBmbG9hdChpbnQoXCIrYStcIikgLSAxKSxcXG4gICAgICAgICAgICAgICAgXCIrbitcIiA/IGZsb2F0KHJvdW5kKHNvdXJjZUZyYWNDb2wpKSA6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0KGZsb29yKHNvdXJjZUZyYWNDb2wpKSkpO1xcblxcbiAgICAgICAgICAgIGlmIChyID09IHNvdXJjZU5lYXJlc3RSb3cgJiYgYyA9PSBzb3VyY2VOZWFyZXN0Q29sKSB7XFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSBnZXREeShiLCBkeVIsIGR5QywgZCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICAvLyBFbmQgbG9vcCBvdmVyIGR5XFxuXFxuICAgICAgICBzZXRPdXRwdXQoYWNjdW11bGF0b3IpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLGFpPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMub3V0cHV0U2hhcGU9W107dmFyIG89dFswXSxhPXRbMV0saT10WzJdLHM9dFszXTt0aGlzLm91dHB1dFNoYXBlPVtvLGUsbixzXTt2YXIgdT1bciYmZT4xP2EtMTphLHImJm4+MT9pLTE6aV0sbD1bciYmZT4xP2UtMTplLHImJm4+MT9uLTE6bl0sYz1yP1wiMC41XCI6XCIwLjBcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgdmVjMiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDID0gdmVjMihcXG4gICAgICAgICAgXCIrdVswXS9sWzBdK1wiLFxcbiAgICAgICAgICBcIit1WzFdL2xbMV0rXCIpO1xcbiAgICAgIGNvbnN0IHZlYzIgaW5wdXRTaGFwZVJDID0gdmVjMihcIithK1wiLjAsIFwiK2krXCIuMCk7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcbiAgICAgICAgaXZlYzIgeVJDID0gY29vcmRzLnl6O1xcblxcbiAgICAgICAgLy8gRnJhY3Rpb25hbCBzb3VyY2UgaW5kZXguXFxuICAgICAgICB2ZWMyIHNvdXJjZUZyYWNJbmRleFJDID0gdmVjMih5UkMpICogZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQztcXG5cXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGNvb3JkaW5hdG9ycyBvZiBuZWFyZXN0IG5laWdoYm9yIHBvaW50LlxcbiAgICAgICAgaXZlYzIgc291cmNlTmVhcmVzdFJDID0gaXZlYzIoXFxuICAgICAgICAgIG1pbihpbnB1dFNoYXBlUkMgLSAxLjAsIGZsb29yKHNvdXJjZUZyYWNJbmRleFJDICsgXCIrYytcIikpKTtcXG5cXG4gICAgICAgIGZsb2F0IG5ld1ZhbHVlID0gZ2V0QShiLCBzb3VyY2VOZWFyZXN0UkMueCwgc291cmNlTmVhcmVzdFJDLnksIGQpO1xcblxcbiAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxpaT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdO3ZhciBuPXQubGVuZ3RoO2lmKG4+NCl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBiYWNrZW5kOiBSZXZlcnNlIG9mIHJhbmstXCIrbitcIiB0ZW5zb3IgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7aWYodGhpcy5vdXRwdXRTaGFwZT10LDEhPT1uKXt2YXIgcj10Lm1hcChmdW5jdGlvbihuLHIpe3JldHVybiBmdW5jdGlvbihuKXtyZXR1cm4tMSE9PWUuaW5kZXhPZihuKSYmMSE9PXRbbl0/dFtuXStcIiAtIGNvb3Jkc1tcIituK1wiXSAtIDFcIjpcImNvb3Jkc1tcIituK1wiXVwifShyKX0pLmpvaW4oXCIsXCIpLG89Ym8obik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK28rXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIityK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIn1lbHNlIHRoaXMudXNlckNvZGU9XCJcXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgaW50IGNvb3JkID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIHNldE91dHB1dChnZXRYKFwiK3RbMF0rXCIgLSBjb29yZCAtIDEpKTtcXG4gICAgICAgIH1cXG4gICAgICBcIn19KCksc2k9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLnVzZXNQYWNrZWRUZXh0dXJlcz0hMDt2YXIgbj10Lmxlbmd0aDtpZihuPjQpdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgYmFja2VuZDogUmV2ZXJzZSBvZiByYW5rLVwiK24rXCIgdGVuc29yIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO3RoaXMub3V0cHV0U2hhcGU9dDt2YXIgcj1vbyhcInJjXCIsbiksbz1yW24tMV0rXCIgKyAxIDwgXCIrdGhpcy5vdXRwdXRTaGFwZVtuLTFdLGE9cltuLTJdK1wiICsgMSA8IFwiK3RoaXMub3V0cHV0U2hhcGVbbi0yXSxpPWJvKG4pO2Z1bmN0aW9uIHMobil7dmFyIHI9dC5tYXAoZnVuY3Rpb24ocixvKXtyZXR1cm4gZnVuY3Rpb24obixyKXtyZXR1cm4tMSE9PWUuaW5kZXhPZihuKSYmMSE9PXRbbl0/dFtuXStcIiAtIFwiK3Jbbl0rXCIgLSAxXCI6XCJcIityW25dfShvLG4pfSk7cmV0dXJuXCJnZXRDaGFubmVsKGdldFgoXCIrci5qb2luKFwiLFwiKStcIiksIHZlYzIoXCIrci5zbGljZSgtMikuam9pbihcIixcIikrXCIpKVwifXRoaXMudXNlckNvZGU9MT09PW4/XCJcXG4gICAgICAgIHZvaWQgbWFpbigpe1xcbiAgICAgICAgICBpbnQgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgcmVzdWx0LnIgPSBnZXRDaGFubmVsKGdldFgoXCIrdFswXStcIiAtIHJjIC0gMSksXFxuICAgICAgICAgICAgXCIrdFswXStcIiAtIHJjIC0gMSk7XFxuICAgICAgICAgIGlmKFwiK28rXCIpe1xcbiAgICAgICAgICAgICAgcmVzdWx0LmcgPSBnZXRDaGFubmVsKGdldFgoXCIrdFswXStcIiAtIChyYyAgKyAxKSAtIDEpLFxcbiAgICAgICAgICAgICAgICBcIit0WzBdK1wiIC0gKHJjICArIDEpIC0gMSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgICB9XFxuICAgICAgXCI6XCJcXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgXCIraStcIiByYyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcbiAgICAgICAgICByZXN1bHQuciA9IFwiK2Z1bmN0aW9uKHQpe3JldHVybiBzKHQpfShyLnNsaWNlKCkpK1wiO1xcbiAgICAgICAgICBpZihcIitvK1wiKXtcXG4gICAgICAgICAgICByZXN1bHQuZyA9IFwiK2Z1bmN0aW9uKHQpe3JldHVybiB0W24tMV09XCIoXCIrdFtuLTFdK1wiICsgMSlcIixzKHQpfShyLnNsaWNlKCkpK1wiO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmKFwiK2ErXCIpIHtcXG4gICAgICAgICAgICByZXN1bHQuYiA9IFwiK2Z1bmN0aW9uKHQpe3JldHVybiB0W24tMl09XCIoXCIrdFtuLTJdK1wiICsgMSlcIixzKHQpfShyLnNsaWNlKCkpK1wiO1xcbiAgICAgICAgICAgIGlmKFwiK28rXCIpIHtcXG4gICAgICAgICAgICAgIHJlc3VsdC5hID0gXCIrZnVuY3Rpb24odCl7cmV0dXJuIHRbbi0xXT1cIihcIit0W24tMV0rXCIgKyAxKVwiLHRbbi0yXT1cIihcIit0W24tMl0rXCIgKyAxKVwiLHModCl9KHIuc2xpY2UoKSkrXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgICAgfVxcbiAgICBcIn19KCksdWk9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dm9pZCAwPT09aSYmKGk9ITApLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ1cGRhdGVzXCIsXCJpbmRpY2VzXCIsXCJkZWZhdWx0VmFsdWVcIl0sdGhpcy5vdXRwdXRTaGFwZT1hO3ZhciBzPWJvKG8ubGVuZ3RoKSx1PWJvKGEubGVuZ3RoKSxsPVwiXCI7MT09PW4/bD1cImlcIjoyPT09biYmKGw9XCJpLCBqXCIpO3ZhciBjPVwiZ2V0SW5kaWNlcyhcIitsK1wiKVwiLGg9XCJcIjsxPT09cj9oPVwiaVwiOjI9PT1yJiYoaD1cImksIGNvb3Jkc1sxXVwiKTt2YXIgcD1cImdldFVwZGF0ZXMoXCIraCtcIilcIixmPWU+MT9cInN0cmlkZXNbal1cIjpcInN0cmlkZXNcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgICBcIitzK1wiIHN0cmlkZXMgPSBcIitzK1wiKFwiK28rXCIpO1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBcIit1K1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBmbG9hdCBzdW0gPSAwLjA7XFxuICAgICAgICAgIGJvb2wgZm91bmQgPSBmYWxzZTtcXG4gICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIit0K1wiOyBpKyspIHtcXG4gICAgICAgICAgICBpbnQgZmxhdHRlbmVkSW5kZXggPSAwO1xcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgXCIrZStcIjsgaisrKSB7XFxuICAgICAgICAgICAgICBpbnQgaW5kZXggPSByb3VuZChcIitjK1wiKTtcXG4gICAgICAgICAgICAgIGZsYXR0ZW5lZEluZGV4ICs9IGluZGV4ICogXCIrZitcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKGZsYXR0ZW5lZEluZGV4ID09IGNvb3Jkc1swXSkge1xcbiAgICAgICAgICAgICAgc3VtICs9IFwiK3ArXCI7XFxuICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChtaXgoZ2V0RGVmYXVsdFZhbHVlKCksIHN1bSwgZmxvYXQoZm91bmQpKSk7XFxuICAgICAgICB9XFxuICAgICAgXCJ9fSgpLGxpPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcInNlZ21lbnRJZHNcIl07dmFyIG49dC53aW5kb3dTaXplLHI9dC5iYXRjaFNpemUsbz10LmluU2l6ZSxhPXQubnVtU2VnbWVudHMsaT1hKk1hdGguY2VpbChvL24pO3RoaXMub3V0cHV0U2hhcGU9W3IsaV07dmFyIHM9NCpNYXRoLmZsb29yKG4vNCksdT1uJTQsbD1cIlxcbiAgICAgICAgc3VtVmFsdWUgKz0gZG90KHZhbHVlcywgc2VnRmlsdGVyKTtcXG4gICAgXCIsYz1cIlwiO28lbj4wJiYoYz1cIlxcbiAgICAgICAgaWYgKGluSWR4IDwgMCB8fCBpbklkeCA+PSBcIitvK1wiKSB7XFxuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIFwiKTt2YXIgaD1cIlwiO28lbj4wJiYoaD1cIlxcbiAgICAgICAgaWYgKGluSWR4IDwgMCB8fCBpbklkeCA+PSBcIitvK1wiKSB7XFxuICAgICAgICAgIHJldHVybiAtMS4wO1xcbiAgICAgICAgfVxcbiAgICAgIFwiKSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9IDAuMDtcXG5cXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCBpbklkeCkge1xcbiAgICAgICAgXCIrYytcIlxcbiAgICAgICAgcmV0dXJuIGdldFgoYmF0Y2gsIGluSWR4KTtcXG4gICAgICB9XFxuXFxuICAgICAgZmxvYXQgZ2V0U2VnbWVudElkQXRJbmRleChpbnQgaW5JZHgpIHtcXG4gICAgICAgIFwiK2grXCJcXG4gICAgICAgIHJldHVybiBnZXRTZWdtZW50SWRzKGluSWR4KTtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGluT2Zmc2V0ID0gaW50KGZsb29yKGZsb2F0KG91dElkeCkgLyBmbG9hdChcXG4gICAgICAgICAgXCIrYStcIikpICogZmxvYXQoXCIrbitcIikpO1xcbiAgICAgICAgaW50IGN1cnJlbnRTZWcgPSBpbnQobW9kKGZsb2F0KG91dElkeCksIGZsb2F0KFwiK2ErXCIpKSk7XFxuXFxuICAgICAgICBmbG9hdCBzdW1WYWx1ZSA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrcytcIjsgaSArPSA0KSB7XFxuICAgICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgaTtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMiksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMylcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgdmVjNCBzZWdGaWx0ZXIgPSB2ZWM0KFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4KSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMSkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDIpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAzKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK2wrXCJcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgXCIrcytcIjtcXG4gICAgICAgIGlmIChcIisoMT09PXUpK1wiKSB7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIGludCBpbklkeFNlZyA9IGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4KSk7XFxuXFxuICAgICAgICAgIHZlYzQgc2VnRmlsdGVyID0gdmVjNChcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICAwLFxcbiAgICAgICAgICAgIDAsXFxuICAgICAgICAgICAgMFxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitsK1wiXFxuICAgICAgICB9IGVsc2UgaWYgKFwiKygyPT09dSkrXCIpIHtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIHZlYzQgc2VnRmlsdGVyID0gdmVjNChcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDEpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgICAwLFxcbiAgICAgICAgICAgICAgMFxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitsK1wiXFxuICAgICAgICB9IGVsc2UgaWYgKFwiKygzPT09dSkrXCIpIHtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMiksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICB2ZWM0IHNlZ0ZpbHRlciA9IHZlYzQoXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHgpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAxKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMikpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICAwXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK2wrXCJcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChzdW1WYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIn19KCksY2k9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3ZhciByLG87aWYodGhpcy52YXJpYWJsZU5hbWVzPVtcImNcIixcImFcIixcImJcIl0sdGhpcy5vdXRwdXRTaGFwZT1lLG4+NCl0aHJvdyBFcnJvcihcIldoZXJlIGZvciByYW5rIFwiK24rXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7aWYoMT09PW4pbz1cInJlc1JDXCIscj1cInJlc1JDXCI7ZWxzZXtmb3IodmFyIGE9W1wicmVzUkMueFwiLFwicmVzUkMueVwiLFwicmVzUkMuelwiLFwicmVzUkMud1wiXSxpPVtdLHM9W10sdT0wO3U8ZS5sZW5ndGg7dSsrKXMucHVzaChcIlwiK2FbdV0pLHU8dCYmaS5wdXNoKFwiXCIrYVt1XSk7cj1pLmpvaW4oKSxvPXMuam9pbigpfXZhciBsPWJvKG4pO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitsK1wiIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBjVmFsID0gZ2V0QyhcIityK1wiKTtcXG4gICAgICAgIGlmIChjVmFsID49IDEuMCkge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0QShcIitvK1wiKSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0QihcIitvK1wiKSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICBcIn19KCksaGk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJzb3VyY2VcIl0sdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMucmFuaz10Lmxlbmd0aDt2YXIgZSxuPWJvKHRoaXMucmFuaykscj1cInVuaWZvcm0gaW50IHN0YXJ0W1wiK3RoaXMucmFuaytcIl07XCIsbz1mdW5jdGlvbih0KXtpZigxPT09dClyZXR1cm5cInNvdXJjZUxvY1wiO2lmKHQ8PTYpcmV0dXJuIHBpLnNsaWNlKDAsdCkubWFwKGZ1bmN0aW9uKHQpe3JldHVyblwic291cmNlTG9jLlwiK3R9KS5qb2luKFwiLFwiKTt0aHJvdyBFcnJvcihcIlNsaWNpbmcgZm9yIHJhbmsgXCIrdCtcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX0odGhpcy5yYW5rKTtlPVwiXFxuICAgICAgICBcIituK1wiIHNvdXJjZUxvYztcXG4gICAgICAgIFwiK24rXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBcIit0Lm1hcChmdW5jdGlvbih0LGUpe3JldHVyblwic291cmNlTG9jLlwiK3BpW2VdK1wiID0gc3RhcnRbXCIrZStcIl0gKyBjb29yZHMuXCIrcGlbZV0rXCI7XCJ9KS5qb2luKFwiXFxuXCIpK1wiXFxuICAgICAgXCIsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFwiK3IrXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitlK1wiXFxuICAgICAgICBzZXRPdXRwdXQoZ2V0U291cmNlKFwiK28rXCIpKTtcXG4gICAgICB9XFxuICAgIFwifXJldHVybiB0LnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztpZih0Lmxlbmd0aCE9PXRoaXMucmFuayl0aHJvdyBFcnJvcihcIlRoZSByYW5rIChcIit0aGlzLnJhbmsrXCIpIG9mIHRoZSBwcm9ncmFtIG11c3QgbWF0Y2ggdGhlIGxlbmd0aCBvZiBzdGFydCAoXCIrdC5sZW5ndGgrXCIpXCIpO3JldHVybiBmdW5jdGlvbihuLHIpe251bGw9PWUuc3RhcnRMb2MmJihlLnN0YXJ0TG9jPW4uZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyhyLFwic3RhcnRcIiksbnVsbD09ZS5zdGFydExvYyl8fG4uZ2wudW5pZm9ybTFpdihlLnN0YXJ0TG9jLHQpfX0sdH0oKSxwaT1bXCJ4XCIsXCJ5XCIsXCJ6XCIsXCJ3XCIsXCJ1XCIsXCJ2XCJdO3ZhciBmaT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInNvdXJjZVwiXSx0aGlzLnVzZXNQYWNrZWRUZXh0dXJlcz0hMCx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy5yYW5rPXQubGVuZ3RoO3ZhciBlPWJvKHRoaXMucmFuayksbj1vbyhcImNvb3Jkc1wiLHRoaXMucmFuaykscj1vbyhcInNvdXJjZUxvY1wiLHRoaXMucmFuayksbz0xPT09dGhpcy5yYW5rP1wic291cmNlTG9jXCI6XCJ2ZWMyKFwiK3Iuc2xpY2UoLTIpLmpvaW4oKStcIilcIixhPVwiZ2V0Q2hhbm5lbChnZXRTb3VyY2UoXCIrci5qb2luKCkrXCIpLCBcIitvK1wiKVwiLGk9XCJcXG4gICAgICByZXN1bHQueCA9IFwiK2ErXCI7XFxuICAgICAgaWYgKCsrXCIrblt0aGlzLnJhbmstMV0rXCIgPCBcIit0W3RoaXMucmFuay0xXStcIikge1xcbiAgICAgICAgKytcIityW3RoaXMucmFuay0xXStcIjtcXG4gICAgICAgIHJlc3VsdC55ID0gXCIrYStcIjtcXG4gICAgICAgIC0tXCIrclt0aGlzLnJhbmstMV0rXCI7XFxuICAgICAgfVxcbiAgICBcIixzPTE9PT10aGlzLnJhbms/XCJcIjpcIlxcbiAgICAgIC0tXCIrblt0aGlzLnJhbmstMV0rXCI7XFxuICAgICAgaWYgKCsrXCIrblt0aGlzLnJhbmstMl0rXCIgPCBcIit0W3RoaXMucmFuay0yXStcIikge1xcbiAgICAgICAgKytcIityW3RoaXMucmFuay0yXStcIjtcXG4gICAgICAgIHJlc3VsdC56ID0gXCIrYStcIjtcXG4gICAgICAgIGlmICgrK1wiK25bdGhpcy5yYW5rLTFdK1wiIDwgXCIrdFt0aGlzLnJhbmstMV0rXCIpIHtcXG4gICAgICAgICAgKytcIityW3RoaXMucmFuay0xXStcIjtcXG4gICAgICAgICAgcmVzdWx0LncgPSBcIithK1wiO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgXCIsdT10aGlzLnJhbms8PTQ/XCJzb3VyY2VMb2MgPSBjb29yZHMgK1xcbiAgICAgICAgICAgIFwiK2UrXCIoXCIrdC5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm5cInN0YXJ0W1wiK2UrXCJdXCJ9KS5qb2luKCkrXCIpO1wiOnQubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHJbZV0rXCIgPSBcIituW2VdK1wiICsgc3RhcnRbXCIrZStcIl07XCJ9KS5qb2luKFwiXFxuXCIpO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB1bmlmb3JtIGludCBzdGFydFtcIit0aGlzLnJhbmsrXCJdO1xcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK2UrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBcIitlK1wiIHNvdXJjZUxvYztcXG4gICAgICAgIFwiK3UrXCIgXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcbiAgICAgICAgXCIraStcIlxcbiAgICAgICAgXCIrcytcIlxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn1yZXR1cm4gdC5wcm90b3R5cGUuZ2V0Q3VzdG9tU2V0dXBGdW5jPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7aWYodC5sZW5ndGghPT10aGlzLnJhbmspdGhyb3cgRXJyb3IoXCJUaGUgcmFuayAoXCIrdGhpcy5yYW5rK1wiKSBvZiB0aGUgcHJvZ3JhbSBtdXN0IG1hdGNoIHRoZSBsZW5ndGggb2Ygc3RhcnQgKFwiK3QubGVuZ3RoK1wiKVwiKTtyZXR1cm4gZnVuY3Rpb24obixyKXtudWxsPT1lLnN0YXJ0TG9jJiYoZS5zdGFydExvYz1uLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cocixcInN0YXJ0XCIpLG51bGw9PWUuc3RhcnRMb2MpfHxuLmdsLnVuaWZvcm0xaXYoZS5zdGFydExvYyx0KX19LHR9KCksZGk9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl07dmFyIG89bi5maWx0ZXIoZnVuY3Rpb24odCxlKXtyZXR1cm4tMT09PXIuaW5kZXhPZihlKX0pO3RoaXMub3V0cHV0U2hhcGU9bzt2YXIgYT1uLmxlbmd0aCxpPWJvKG4ubGVuZ3RoKSxzPWJvKG8ubGVuZ3RoKSx1PVwiXCI7aWYoMT09PWEpdT1cImNvb3JkcyAqIHN0cmlkZXMgKyBiZWdpblwiO2Vsc2V7dmFyIGw9MDt1PW4ubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuLTE9PT1yLmluZGV4T2YoZSk/KGwrKywxPT09by5sZW5ndGg/XCJjb29yZHMgKiBzdHJpZGVzW1wiK2UrXCJdICsgYmVnaW5bXCIrZStcIl1cIjpcImNvb3Jkc1tcIisobC0xKStcIl0gKiBzdHJpZGVzW1wiK2UrXCJdICsgYmVnaW5bXCIrZStcIl1cIik6XCJiZWdpbltcIitlK1wiXVwifSkuam9pbihcIixcIil9dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFwiK2krXCIgYmVnaW4gPSBcIitpK1wiKFwiK3QrXCIpO1xcbiAgICAgIFwiK2krXCIgc3RyaWRlcyA9IFwiK2krXCIoXCIrZStcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrcytcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRYKFwiK3UrXCIpKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSx2aT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5ncGdwdT10LHRoaXMubnVtVXNlZFRleHR1cmVzPTAsdGhpcy5udW1GcmVlVGV4dHVyZXM9MCx0aGlzLmZyZWVUZXh0dXJlcz17fSx0aGlzLmxvZ0VuYWJsZWQ9ITEsdGhpcy51c2VkVGV4dHVyZXM9e319cmV0dXJuIHQucHJvdG90eXBlLmFjcXVpcmVUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcixvPW1pKGUsbiksYT1naSh0LG8sbik7aWYoYSBpbiB0aGlzLmZyZWVUZXh0dXJlc3x8KHRoaXMuZnJlZVRleHR1cmVzW2FdPVtdKSxhIGluIHRoaXMudXNlZFRleHR1cmVzfHwodGhpcy51c2VkVGV4dHVyZXNbYV09W10pLHRoaXMuZnJlZVRleHR1cmVzW2FdLmxlbmd0aD4wKXt0aGlzLm51bUZyZWVUZXh0dXJlcy0tLHRoaXMubnVtVXNlZFRleHR1cmVzKyssdGhpcy5sb2coKTt2YXIgaT10aGlzLmZyZWVUZXh0dXJlc1thXS5zaGlmdCgpO3JldHVybiB0aGlzLnVzZWRUZXh0dXJlc1thXS5wdXNoKGkpLGl9cmV0dXJuIHRoaXMubnVtVXNlZFRleHR1cmVzKyssdGhpcy5sb2coKSxvPT09bGEuUEFDS0VEXzJYMl9GTE9BVDMyP3I9dGhpcy5ncGdwdS5jcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlKHRbMF0sdFsxXSk6bz09PWxhLlBBQ0tFRF8yWDJfRkxPQVQxNj9yPXRoaXMuZ3BncHUuY3JlYXRlRmxvYXQxNlBhY2tlZE1hdHJpeFRleHR1cmUodFswXSx0WzFdKTpvPT09bGEuVU5QQUNLRURfRkxPQVQzMj9yPXRoaXMuZ3BncHUuY3JlYXRlRmxvYXQzMk1hdHJpeFRleHR1cmUodFswXSx0WzFdKTpvPT09bGEuVU5QQUNLRURfRkxPQVQxNj9yPXRoaXMuZ3BncHUuY3JlYXRlRmxvYXQxNk1hdHJpeFRleHR1cmUodFswXSx0WzFdKTpvPT09bGEuUEFDS0VEXzRYMV9VTlNJR05FRF9CWVRFJiYocj10aGlzLmdwZ3B1LmNyZWF0ZVVuc2lnbmVkQnl0ZXNNYXRyaXhUZXh0dXJlKHRbMF0sdFsxXSkpLHRoaXMudXNlZFRleHR1cmVzW2FdLnB1c2gocikscn0sdC5wcm90b3R5cGUucmVsZWFzZVRleHR1cmU9ZnVuY3Rpb24odCxlLG4scil7aWYobnVsbCE9dGhpcy5mcmVlVGV4dHVyZXMpe3ZhciBvPWdpKGUsbWkobixyKSxyKTtvIGluIHRoaXMuZnJlZVRleHR1cmVzfHwodGhpcy5mcmVlVGV4dHVyZXNbb109W10pLHRoaXMuZnJlZVRleHR1cmVzW29dLnB1c2godCksdGhpcy5udW1GcmVlVGV4dHVyZXMrKyx0aGlzLm51bVVzZWRUZXh0dXJlcy0tO3ZhciBhPXRoaXMudXNlZFRleHR1cmVzW29dLGk9YS5pbmRleE9mKHQpO2lmKGk8MCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVsZWFzZSBhIHRleHR1cmUgdGhhdCB3YXMgbmV2ZXIgcHJvdmlkZWQgYnkgdGhpcyB0ZXh0dXJlIG1hbmFnZXJcIik7YS5zcGxpY2UoaSwxKSx0aGlzLmxvZygpfX0sdC5wcm90b3R5cGUubG9nPWZ1bmN0aW9uKCl7aWYodGhpcy5sb2dFbmFibGVkKXt2YXIgdD10aGlzLm51bUZyZWVUZXh0dXJlcyt0aGlzLm51bVVzZWRUZXh0dXJlcztjb25zb2xlLmxvZyhcIkZyZWUvVXNlZFwiLHRoaXMubnVtRnJlZVRleHR1cmVzK1wiIC8gXCIrdGhpcy5udW1Vc2VkVGV4dHVyZXMsXCIoXCIrdCtcIilcIil9fSx0LnByb3RvdHlwZS5nZXROdW1Vc2VkVGV4dHVyZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5udW1Vc2VkVGV4dHVyZXN9LHQucHJvdG90eXBlLmdldE51bUZyZWVUZXh0dXJlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm51bUZyZWVUZXh0dXJlc30sdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYobnVsbCE9dGhpcy5mcmVlVGV4dHVyZXMpe2Zvcih2YXIgZSBpbiB0aGlzLmZyZWVUZXh0dXJlcyl0aGlzLmZyZWVUZXh0dXJlc1tlXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3QuZ3BncHUuZGVsZXRlTWF0cml4VGV4dHVyZShlKX0pO2Zvcih2YXIgZSBpbiB0aGlzLnVzZWRUZXh0dXJlcyl0aGlzLnVzZWRUZXh0dXJlc1tlXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3QuZ3BncHUuZGVsZXRlTWF0cml4VGV4dHVyZShlKX0pO3RoaXMuZnJlZVRleHR1cmVzPW51bGwsdGhpcy51c2VkVGV4dHVyZXM9bnVsbCx0aGlzLm51bVVzZWRUZXh0dXJlcz0wLHRoaXMubnVtRnJlZVRleHR1cmVzPTB9fSx0fSgpO2Z1bmN0aW9uIG1pKHQsZSl7aWYodD09PXVhLlVQTE9BRClyZXR1cm4gZT9sYS5QQUNLRURfMlgyX0ZMT0FUMzI6bGEuVU5QQUNLRURfRkxPQVQzMjtpZih0PT09dWEuUkVOREVSfHxudWxsPT10KXJldHVybiBlP2EuZ2V0Qm9vbChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIik/bGEuUEFDS0VEXzJYMl9GTE9BVDMyOmxhLlBBQ0tFRF8yWDJfRkxPQVQxNjphLmdldEJvb2woXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEXCIpP2xhLlVOUEFDS0VEX0ZMT0FUMzI6bGEuVU5QQUNLRURfRkxPQVQxNjtpZih0PT09dWEuRE9XTkxPQUR8fHQ9PT11YS5QSVhFTFMpcmV0dXJuIGxhLlBBQ0tFRF80WDFfVU5TSUdORURfQllURTt0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGxvZ2ljYWwgdGV4dHVyZSB0eXBlIFwiK3QpfWZ1bmN0aW9uIGdpKHQsZSxuKXtyZXR1cm4gdFswXStcIl9cIit0WzFdK1wiX1wiK2UrXCJfXCIrbn12YXIgeWk9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXTtmb3IodmFyIG49bmV3IEFycmF5KHQubGVuZ3RoKSxyPTA7cjxuLmxlbmd0aDtyKyspbltyXT10W3JdKmVbcl07dGhpcy5vdXRwdXRTaGFwZT1uLHRoaXMucmFuaz1uLmxlbmd0aDt2YXIgbz1ibyh0aGlzLnJhbmspLGE9ZnVuY3Rpb24odCl7dmFyIGU9dC5sZW5ndGg7aWYoZT41KXRocm93IEVycm9yKFwiVGlsZSBmb3IgcmFuayBcIitlK1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO2lmKDE9PT1lKXJldHVyblwiaW1vZChyZXNSQywgXCIrdFswXStcIilcIjtmb3IodmFyIG49W1wicmVzUkMueFwiLFwicmVzUkMueVwiLFwicmVzUkMuelwiLFwicmVzUkMud1wiLFwicmVzUkMudVwiXSxyPVtdLG89MDtvPHQubGVuZ3RoO28rKylyLnB1c2goXCJpbW9kKFwiK25bb10rXCIsIFwiK3Rbb10rXCIpXCIpO3JldHVybiByLmpvaW4oKX0odCk7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK28rXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRBKFwiK2ErXCIpKTtcXG4gICAgICB9XFxuICAgIFwifX0oKTt2YXIgeGk9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXTtmb3IodmFyIG49bmV3IEFycmF5KHQubGVuZ3RoKSxyPTA7cjxuLmxlbmd0aDtyKyspbltyXT10W2Vbcl1dO3RoaXMub3V0cHV0U2hhcGU9bix0aGlzLnJhbms9bi5sZW5ndGg7dmFyIG89Ym8odGhpcy5yYW5rKSxhPWZ1bmN0aW9uKHQpe3ZhciBlPXQubGVuZ3RoO2lmKGU+Nil0aHJvdyBFcnJvcihcIlRyYW5zcG9zZSBmb3IgcmFuayBcIitlK1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO2Zvcih2YXIgbj1bXCJyZXNSQy54XCIsXCJyZXNSQy55XCIsXCJyZXNSQy56XCIsXCJyZXNSQy53XCIsXCJyZXNSQy51XCIsXCJyZXNSQy52XCJdLHI9bmV3IEFycmF5KGUpLG89MDtvPHQubGVuZ3RoO28rKylyW3Rbb11dPW5bb107cmV0dXJuIHIuam9pbigpfShlKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBcIitvK1wiIHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgc2V0T3V0cHV0KGdldEEoXCIrYStcIikpO1xcbiAgICB9XFxuICAgIFwifX0oKTt2YXIgd2k9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnVzZXNQYWNrZWRUZXh0dXJlcz0hMDtmb3IodmFyIG49bmV3IEFycmF5KHQubGVuZ3RoKSxyPTA7cjxuLmxlbmd0aDtyKyspbltyXT10W2Vbcl1dO2lmKHRoaXMub3V0cHV0U2hhcGU9bix0aGlzLnJhbms9bi5sZW5ndGgsdGhpcy5yYW5rPjYpdGhyb3cgRXJyb3IoXCJQYWNrZWQgdHJhbnNwb3NlIGZvciByYW5rIFwiK3RoaXMucmFuaytcIiBpcyBub3QgeWV0IHN1cHBvcnRlZC5cIik7dmFyIG89Ym8odGhpcy5yYW5rKSxhPXJvKFwicmNcIix0aGlzLnJhbmspLGk9bmV3IEFycmF5KHRoaXMucmFuayk7Zm9yKHI9MDtyPGUubGVuZ3RoO3IrKylpW2Vbcl1dPWFbcl07dmFyIHM9XCJ2ZWMyKFwiK2kuc2xpY2UoLTIpLmpvaW4oKStcIilcIix1PVwiKytcIithW3RoaXMucmFuay0xXStcIiA8IFwiK25bdGhpcy5yYW5rLTFdLGw9XCJnZXRDaGFubmVsKGdldEEoXCIraS5qb2luKCkrXCIpLCBcIitzK1wiKVwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIFwiK28rXCIgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcbiAgICAgIHJlc3VsdFswXSA9IFwiK2wrXCI7XFxuICAgICAgaWYoXCIrdStcIikge1xcbiAgICAgICAgcmVzdWx0WzFdID0gXCIrbCtcIjtcXG4gICAgICB9XFxuICAgICAgLS1cIithW3RoaXMucmFuay0xXStcIjtcXG4gICAgICBpZigrK1wiK2FbdGhpcy5yYW5rLTJdK1wiIDwgXCIrblt0aGlzLnJhbmstMl0rXCIpIHtcXG4gICAgICAgIHJlc3VsdFsyXSA9IFwiK2wrXCI7XFxuICAgICAgICBpZihcIit1K1wiKSB7XFxuICAgICAgICAgIHJlc3VsdFszXSA9IFwiK2wrXCI7XFxuICAgICAgICB9XFxuICAgICAgfSAgXFxuICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgIH1cXG4gICAgXCJ9fSgpLGJpPTEuNzU4MDk5MzQwODQ3Mzc2OCxDaT0xLjA1MDcwMDk4NzM1NTQ4MDUsRWk9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGZsb2F0IHVuYXJ5T3BlcmF0aW9uKGZsb2F0IHgpIHtcXG4gICAgICAgIFwiK2UrXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgeCA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgeSA9IHVuYXJ5T3BlcmF0aW9uKHgpO1xcblxcbiAgICAgICAgc2V0T3V0cHV0KHkpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLFJpPVwiaWYgKGlzbmFuKHgpKSByZXR1cm4geDtcIixTaT1cInJldHVybiB4O1wiLE5pPVJpK1wiXFxuICByZXR1cm4gKHggPCAwLjApID8gMC4wIDogeDtcXG5cIixraT1cIlxcbiAgLy8gU3RhYmxlIGFuZCBBdHRyYWN0aW5nIEZpeGVkIFBvaW50ICgwLCAxKSBmb3IgTm9ybWFsaXplZCBXZWlnaHRzLlxcbiAgLy8gc2VlOiBodHRwczovL2FyeGl2Lm9yZy9hYnMvMTcwNi4wMjUxNVxcbiAgZmxvYXQgc2NhbGVBbHBoYSA9IFwiK2JpK1wiO1xcbiAgZmxvYXQgc2NhbGUgPSBcIitDaStcIjtcXG4gIHJldHVybiAoeCA+PSAwLjApID8gc2NhbGUgKiB4IDogc2NhbGVBbHBoYSAqIChleHAoeCkgLSAxLjApO1xcblwiO3ZhciBJaT1cInJldHVybiBleHAoeCk7XCIsQWk9UmkrXCJcXG4gIHJldHVybiBzaW4oeCk7XFxuXCIsVGk9UmkrXCJcXG4gIHJldHVybiBjb3MoeCk7XFxuXCIsRGk9UmkrXCJcXG4gIHJldHVybiBhdGFuKHgpO1xcblwiLE9pPVJpK1wiXFxuICBpZiAoeCA8IDEuMCkgcmV0dXJuIE5BTjtcXG4gIHJldHVybiBsb2coeCArIHNxcnQoeCAqIHggLSAxLjApKTtcIixfaT1SaStcIlxcbiAgaWYgKCh4IDwgLTEuMCkgfHwgKHggPiAxLjApKSByZXR1cm4gTkFOO1xcbiAgcmV0dXJuIChsb2coMS4wICsgeCkgLSBsb2coMS4wIC0geCkpIC8gMi4wO1wiLE1pPVwicmV0dXJuIHg7XCIsRmk9XCJcXG4gIHZlYzQgcmVzdWx0ID0geCAqIHZlYzQoZ3JlYXRlclRoYW5FcXVhbCh4LCB2ZWM0KDAuMCkpKTtcXG4gIGJ2ZWM0IGlzTmFOID0gaXNuYW4oeCk7XFxuXFxuICByZXN1bHQuciA9IGlzTmFOLnIgPyB4LnIgOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA/IHguZyA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc05hTi5iID8geC5iIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzTmFOLmEgPyB4LmEgOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsQmk9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnVzZXNQYWNrZWRUZXh0dXJlcz0hMCx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZlYzQgdW5hcnlPcGVyYXRpb24odmVjNCB4KSB7XFxuICAgICAgICBcIitlK1wiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZlYzQgeCA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCB5ID0gdW5hcnlPcGVyYXRpb24oeCk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQoeSk7XFxuICAgICAgfVxcbiAgICBcIn19KCksUGk9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy51c2VzUGFja2VkVGV4dHVyZXM9ITAsdGhpcy5vdXRwdXRTaGFwZT10O3ZhciBlPXQubGVuZ3RoLG49b28oXCJyY1wiLGUpLHI9Ym8oZSksbz1mdW5jdGlvbih0LGUpe2lmKDE9PT10KXJldHVyblwicmNcIjtmb3IodmFyIG49XCJcIixyPTA7cjx0O3IrKyluKz1lW3JdLHI8dC0xJiYobis9XCIsXCIpO3JldHVybiBufShlLG4pLGE9bi5zbGljZSgtMiksaT1lPD0xP1wicmNcIjpcInZlYzIoXCIrYS5qb2luKFwiLFwiKStcIilcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrcitcIiByYyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCBwYWNrZWRJbnB1dCA9IGdldEEoXCIrbytcIik7XFxuXFxuICAgICAgICBzZXRPdXRwdXQoZ2V0Q2hhbm5lbChwYWNrZWRJbnB1dCwgXCIraStcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLExpPXt9O3ZhciBXaT02MDA7dmFyIFVpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLmdwZ3B1PXQsdGhpcy5wZW5kaW5nUmVhZD1uZXcgV2Vha01hcCx0aGlzLnBlbmRpbmdEaXNwb3NhbD1uZXcgV2Vha1NldCx0aGlzLmRhdGFSZWZDb3VudD1uZXcgV2Vha01hcCx0aGlzLm51bUJ5dGVzSW5HUFU9MCx0aGlzLnVwbG9hZFdhaXRNcz0wLHRoaXMuZG93bmxvYWRXYWl0TXM9MCx0aGlzLndhcm5lZEFib3V0TWVtb3J5PSExLHRoaXMuZGlzcG9zZWQ9ITEsIWEuZ2V0Qm9vbChcIkhBU19XRUJHTFwiKSl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlXCIpO2lmKG51bGw9PXQpe3ZhciBlPUZ0KGEuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSk7dGhpcy5iaW5hcnlDYWNoZT0obj1hLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpaW4gTGk/TGlbbl06KExpW25dPXt9LExpW25dKSx0aGlzLmdwZ3B1PW5ldyBXYShlKSx0aGlzLmNhbnZhcz1lLmNhbnZhcyx0aGlzLmdwZ3B1Q3JlYXRlZExvY2FsbHk9ITB9ZWxzZSB0aGlzLmJpbmFyeUNhY2hlPXt9LHRoaXMuZ3BncHVDcmVhdGVkTG9jYWxseT0hMSx0aGlzLmNhbnZhcz10LmdsLmNhbnZhczt2YXIgbjt0aGlzLnRleHR1cmVNYW5hZ2VyPW5ldyB2aSh0aGlzLmdwZ3B1KSx0aGlzLm51bU1CQmVmb3JlV2FybmluZz1udWxsPT1hLmdsb2JhbC5zY3JlZW4/MTAyNDphLmdsb2JhbC5zY3JlZW4uaGVpZ2h0KmEuZ2xvYmFsLnNjcmVlbi53aWR0aCp3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbypXaS8xMDI0LzEwMjQsdGhpcy50ZXhEYXRhPW5ldyBZbihEdCl9cmV0dXJuIHQucHJvdG90eXBlLnJlZ2lzdGVyPWZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLnRleERhdGEuaGFzKHQpKXRocm93IG5ldyBFcnJvcihcIkRhdGEgYnVmZmVyIGlzIGFscmVhZHkgcmVnaXN0ZXJlZFwiKTt0aGlzLnRleERhdGEuc2V0KHQse3NoYXBlOmUsZHR5cGU6bn0pfSx0LnByb3RvdHlwZS5mcm9tUGl4ZWxzPWZ1bmN0aW9uKHQsZSl7aWYobnVsbD09dCl0aHJvdyBuZXcgRXJyb3IoXCJwaXhlbHMgcGFzc2VkIHRvIHRmLmJyb3dzZXIuZnJvbVBpeGVscygpIGNhbiBub3QgYmUgbnVsbFwiKTt2YXIgbj1bdC5oZWlnaHQsdC53aWR0aF0scj1bdC5oZWlnaHQsdC53aWR0aCxlXTtpZihhLmdldEJvb2woXCJJU19CUk9XU0VSXCIpKXtpZighKHQgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50fHx0IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudHx8dCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50fHx0IGluc3RhbmNlb2YgSW1hZ2VEYXRhKSl0aHJvdyBuZXcgRXJyb3IoXCJwaXhlbHMgcGFzc2VkIHRvIHRmLmJyb3dzZXIuZnJvbVBpeGVscygpIG11c3QgYmUgZWl0aGVyIGFuIEhUTUxWaWRlb0VsZW1lbnQsIEhUTUxJbWFnZUVsZW1lbnQsIEhUTUxDYW52YXNFbGVtZW50IG9yIEltYWdlRGF0YSwgYnV0IHdhcyBcIit0LmNvbnN0cnVjdG9yLm5hbWUpO2lmKHQgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KXtpZihudWxsPT10aGlzLmZyb21QaXhlbHMyRENvbnRleHQpe2lmKFwiY29tcGxldGVcIiE9PWRvY3VtZW50LnJlYWR5U3RhdGUpdGhyb3cgbmV3IEVycm9yKFwiVGhlIERPTSBpcyBub3QgcmVhZHkgeWV0LiBQbGVhc2UgY2FsbCB0Zi5icm93c2VyLmZyb21QaXhlbHMoKSBvbmNlIHRoZSBET00gaXMgcmVhZHkuIE9uZSB3YXkgdG8gZG8gdGhhdCBpcyB0byBhZGQgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGBET01Db250ZW50TG9hZGVkYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0XCIpO3RoaXMuZnJvbVBpeGVsczJEQ29udGV4dD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKX10aGlzLmZyb21QaXhlbHMyRENvbnRleHQuY2FudmFzLndpZHRoPXQud2lkdGgsdGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0LmNhbnZhcy5oZWlnaHQ9dC5oZWlnaHQsdGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0LmRyYXdJbWFnZSh0LDAsMCx0LndpZHRoLHQuaGVpZ2h0KSx0PXRoaXMuZnJvbVBpeGVsczJEQ29udGV4dC5jYW52YXN9fXZhciBvPXRoaXMubWFrZVRlbnNvckhhbmRsZShuLFwiaW50MzJcIik7dGhpcy50ZXhEYXRhLmdldChvLmRhdGFJZCkudXNhZ2U9dWEuUElYRUxTLHRoaXMuZ3BncHUudXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlKHRoaXMuZ2V0VGV4dHVyZShvLmRhdGFJZCksdCk7dmFyIGk9bmV3IGlhKHIpLHM9dGhpcy5jb21waWxlQW5kUnVuKGksW29dKTtyZXR1cm4gdGhpcy5kaXNwb3NlRGF0YShvLmRhdGFJZCksc30sdC5wcm90b3R5cGUubWFrZVRlbnNvckhhbmRsZT1mdW5jdGlvbih0LGUpe3ZhciBuPXt9O3JldHVybiB0aGlzLnJlZ2lzdGVyKG4sdCxlKSx7ZGF0YUlkOm4sc2hhcGU6dCxkdHlwZTplfX0sdC5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24odCxlKXtpZihudWxsPT1lKXRocm93IG5ldyBFcnJvcihcIk1hdGhCYWNrZW5kV2ViR0wud3JpdGUoKTogdmFsdWVzIGNhbiBub3QgYmUgbnVsbFwiKTtpZihhLmdldEJvb2woXCJERUJVR1wiKSlmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtpZighV3QocikpdGhyb3cgRXJyb3IoXCJUaGUgdmFsdWUgXCIrcitcIiBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgb24gdGhpcyBkZXZpY2UuXCIpfXZhciBvPXRoaXMudGV4RGF0YS5nZXQodCk7aWYoXCJjb21wbGV4NjRcIj09PW8uZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHdyaXRlIHRvIGEgY29tcGxleDY0IGR0eXBlLiBQbGVhc2UgdXNlIHRmLmNvbXBsZXgocmVhbCwgaW1hZykuXCIpO3RoaXMucmVsZWFzZUdQVURhdGEodCksby51c2FnZT11YS5VUExPQUQsby52YWx1ZXM9ZX0sdC5wcm90b3R5cGUucmVhZFN5bmM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy50ZXhEYXRhLmdldCh0KSxuPWUudmFsdWVzLHI9ZS5kdHlwZSxvPWUuY29tcGxleFRlbnNvcnMsYT1lLnNsaWNlLGk9ZS5zaGFwZTtpZihudWxsIT1hKXt2YXIgcz1uZXcgRWkoaSxcInJldHVybiB4O1wiKSx1PXRoaXMuY29tcGlsZUFuZFJ1bihzLFt7ZGF0YUlkOnQsc2hhcGU6aSxkdHlwZTpyfV0pLGw9dGhpcy5yZWFkU3luYyh1LmRhdGFJZCk7cmV0dXJuIHUuZGlzcG9zZSgpLGx9aWYobnVsbCE9bilyZXR1cm4gdGhpcy5jb252ZXJ0QW5kQ2FjaGVPbkNQVSh0KTtpZihcInN0cmluZ1wiPT09cilyZXR1cm4gbjt2YXIgYyxoLHA9bnVsbCE9dGhpcy5hY3RpdmVUaW1lcnM7KHAmJihjPXBlcmZvcm1hbmNlLm5vdygpKSxcImNvbXBsZXg2NFwiPT09cik/aD1lcihvLnJlYWwuZGF0YVN5bmMoKSxvLmltYWcuZGF0YVN5bmMoKSk6aD10aGlzLmdldFZhbHVlc0Zyb21UZXh0dXJlKHQpO3JldHVybiBwJiYodGhpcy5kb3dubG9hZFdhaXRNcys9cGVyZm9ybWFuY2Uubm93KCktYyksdGhpcy5jb252ZXJ0QW5kQ2FjaGVPbkNQVSh0LGgpfSx0LnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKHQpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLG4scixpLHMsdSxsLGMsaCxwLGYsZCx2LG0sZyx4LHcsYixDLEUsUixTLE4sayxJLEEsVCxEO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obyl7c3dpdGNoKG8ubGFiZWwpe2Nhc2UgMDppZih0aGlzLnBlbmRpbmdSZWFkLmhhcyh0KSlyZXR1cm4gcj10aGlzLnBlbmRpbmdSZWFkLmdldCh0KSxbMixuZXcgUHJvbWlzZShmdW5jdGlvbih0KXtyZXR1cm4gci5wdXNoKHQpfSldO2lmKGk9dGhpcy50ZXhEYXRhLmdldCh0KSxzPWkudGV4dHVyZSx1PWkudmFsdWVzLGw9aS50ZXhTaGFwZSxjPWkuaXNQYWNrZWQsaD1pLnNoYXBlLHA9aS5zbGljZSxmPWkuZHR5cGUsZD1pLmNvbXBsZXhUZW5zb3JzLG51bGwhPXApcmV0dXJuIHY9bmV3IEVpKGgsXCJyZXR1cm4geDtcIiksbT10aGlzLmNvbXBpbGVBbmRSdW4odixbe2RhdGFJZDp0LHNoYXBlOmgsZHR5cGU6Zn1dKSxnPXRoaXMucmVhZChtLmRhdGFJZCksbS5kaXNwb3NlKCksWzIsZ107aWYobnVsbCE9dSlyZXR1cm5bMix0aGlzLmNvbnZlcnRBbmRDYWNoZU9uQ1BVKHQpXTtpZih0aGlzLnBlbmRpbmdSZWFkLnNldCh0LFtdKSwhYS5nZXRCb29sKFwiV0VCR0xfRE9XTkxPQURfRkxPQVRfRU5BQkxFRFwiKSYmMj09PWEuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IuZGF0YSgpIHdpdGggV0VCR0xfRE9XTkxPQURfRkxPQVRfRU5BQkxFRD1mYWxzZSBhbmQgV0VCR0xfVkVSU0lPTj0yIG5vdCB5ZXQgc3VwcG9ydGVkLlwiKTtyZXR1cm4geD1udWxsLFwiY29tcGxleDY0XCI9PT1mP1szLDJdOih3PWxbMV0sYj1sWzBdLGMmJihlPWRhKGxbMF0sbFsxXSksdz1lWzBdLGI9ZVsxXSksYS5nZXQoXCJXRUJHTF9CVUZGRVJfU1VQUE9SVEVEXCIpJiYoeD10aGlzLmdwZ3B1LmNyZWF0ZUJ1ZmZlckZyb21UZXh0dXJlKHMsYix3KSksWzQsdGhpcy5ncGdwdS5jcmVhdGVBbmRXYWl0Rm9yRmVuY2UoKV0pO2Nhc2UgMTpvLnNlbnQoKSxvLmxhYmVsPTI7Y2FzZSAyOnJldHVyblwiY29tcGxleDY0XCIhPT1mP1szLDRdOls0LFByb21pc2UuYWxsKFtkLnJlYWwuZGF0YSgpLGQuaW1hZy5kYXRhKCldKV07Y2FzZSAzOnJldHVybiBFPW8uc2VudCgpLFI9RVswXSxTPUVbMV0sQz1lcihSLFMpLFszLDVdO2Nhc2UgNDpudWxsPT14P0M9dGhpcy5nZXRWYWx1ZXNGcm9tVGV4dHVyZSh0KTooTj15KGgpLGM/KGs9ZmUoaCksST0xLEE9MSxoLmxlbmd0aCYmKG49ZGUoaCksST1uWzBdLEE9blsxXSksQz10aGlzLmdwZ3B1LmRvd25sb2FkUGFja2VkTWF0cml4RnJvbUJ1ZmZlcih4LGssSSxBLGxbMF0sbFsxXSkuc3ViYXJyYXkoMCxOKSk6Qz10aGlzLmdwZ3B1LmRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21CdWZmZXIoeCxsWzBdLGxbMV0pLnN1YmFycmF5KDAsTikpLG8ubGFiZWw9NTtjYXNlIDU6cmV0dXJuIFQ9dGhpcy5jb252ZXJ0QW5kQ2FjaGVPbkNQVSh0LEMpLEQ9dGhpcy5wZW5kaW5nUmVhZC5nZXQodCksdGhpcy5wZW5kaW5nUmVhZC5kZWxldGUodCksRC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiB0KFQpfSksdGhpcy5wZW5kaW5nRGlzcG9zYWwuaGFzKHQpJiYodGhpcy5wZW5kaW5nRGlzcG9zYWwuZGVsZXRlKHQpLHRoaXMuZGlzcG9zZURhdGEodCkpLFsyLFRdfX0pfSl9LHQucHJvdG90eXBlLmdldFZhbHVlc0Zyb21UZXh0dXJlPWZ1bmN0aW9uKHQpe3ZhciBlLG49dGhpcyxyPXRoaXMudGV4RGF0YS5nZXQodCksbz1yLnNoYXBlLGk9ci5kdHlwZSxzPXIudGV4dHVyZSx1PXIudGV4U2hhcGUsbD15KG8pO2lmKGEuZ2V0Qm9vbChcIldFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRURcIikpe2lmKHRoaXMudGV4RGF0YS5nZXQodCkuaXNQYWNrZWQpe3ZhciBjPWZlKG8pLGg9MSxwPTE7cmV0dXJuIG8ubGVuZ3RoJiYoaD0oZT1kZShvKSlbMF0scD1lWzFdKSx0aGlzLmdwZ3B1LmRvd25sb2FkTWF0cml4RnJvbVBhY2tlZFRleHR1cmUocyxjLGgscCx1WzBdLHVbMV0pLnN1YmFycmF5KDAsbCl9cmV0dXJuIHRoaXMuZ3BncHUuZG93bmxvYWRGbG9hdDMyTWF0cml4RnJvbU91dHB1dFRleHR1cmUocyx1WzBdLHVbMV0pLnN1YmFycmF5KDAsbCl9dmFyIGY9dGhpcy5tYWtlVGVuc29ySGFuZGxlKG8sXCJmbG9hdDMyXCIpO2Yuc2l6ZT15KG8pLHRoaXMudGV4RGF0YS5nZXQoZi5kYXRhSWQpLnVzYWdlPXVhLkRPV05MT0FEO3ZhciBkPUZlKGZ1bmN0aW9uKCl7dmFyIGU9bmV3IGVhKG8pO3JldHVybiBuLmNvbXBpbGVBbmRSdW4oZSxbe3NoYXBlOm8sZHR5cGU6aSxkYXRhSWQ6dH1dLGYsbnVsbCl9KSx2PXRoaXMudGV4RGF0YS5nZXQoZC5kYXRhSWQpLG09dGhpcy5ncGdwdS5kb3dubG9hZEJ5dGVFbmNvZGVkRmxvYXRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZSh2LnRleHR1cmUsdi50ZXhTaGFwZVswXSx2LnRleFNoYXBlWzFdKS5zdWJhcnJheSgwLGwpO3JldHVybiB0aGlzLmRpc3Bvc2VEYXRhKGYuZGF0YUlkKSxtfSx0LnByb3RvdHlwZS50aW1lPWZ1bmN0aW9uKHQpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLG4scixhLGkscyx1O3JldHVybiBvKHRoaXMsZnVuY3Rpb24obyl7c3dpdGNoKG8ubGFiZWwpe2Nhc2UgMDpyZXR1cm4gZT10aGlzLmFjdGl2ZVRpbWVycyxuPVtdLHI9ITEsbnVsbD09dGhpcy5wcm9ncmFtVGltZXJzU3RhY2s/KHRoaXMucHJvZ3JhbVRpbWVyc1N0YWNrPW4scj0hMCk6dGhpcy5hY3RpdmVUaW1lcnMucHVzaChuKSx0aGlzLmFjdGl2ZVRpbWVycz1uLHQoKSxhPWcodGhpcy5hY3RpdmVUaW1lcnMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnF1ZXJ5fSkpLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9dH0pLGk9Zyh0aGlzLmFjdGl2ZVRpbWVycy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pKS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPXR9KSx0aGlzLmFjdGl2ZVRpbWVycz1lLHImJih0aGlzLnByb2dyYW1UaW1lcnNTdGFjaz1udWxsKSxbNCxQcm9taXNlLmFsbChhKV07Y2FzZSAxOnJldHVybiBzPW8uc2VudCgpLHU9e3VwbG9hZFdhaXRNczp0aGlzLnVwbG9hZFdhaXRNcyxkb3dubG9hZFdhaXRNczp0aGlzLmRvd25sb2FkV2FpdE1zLGtlcm5lbE1zOmYocyksZ2V0RXh0cmFQcm9maWxlSW5mbzpmdW5jdGlvbigpe3JldHVybiBzLm1hcChmdW5jdGlvbih0LGUpe3JldHVybntuYW1lOmlbZV0sbXM6dH19KS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZStcIjogXCIrdC5tc30pLmpvaW4oXCIsIFwiKX0sd2FsbE1zOm51bGx9LHRoaXMudXBsb2FkV2FpdE1zPTAsdGhpcy5kb3dubG9hZFdhaXRNcz0wLFsyLHVdfX0pfSl9LHQucHJvdG90eXBlLm1lbW9yeT1mdW5jdGlvbigpe3JldHVybnt1bnJlbGlhYmxlOiExLG51bUJ5dGVzSW5HUFU6dGhpcy5udW1CeXRlc0luR1BVfX0sdC5wcm90b3R5cGUuc3RhcnRUaW1lcj1mdW5jdGlvbigpe3JldHVybiBhLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpPjA/dGhpcy5ncGdwdS5iZWdpblF1ZXJ5KCk6e3N0YXJ0TXM6cGVyZm9ybWFuY2Uubm93KCksZW5kTXM6bnVsbH19LHQucHJvdG90eXBlLmVuZFRpbWVyPWZ1bmN0aW9uKHQpe3JldHVybiBhLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpPjA/KHRoaXMuZ3BncHUuZW5kUXVlcnkoKSx0KToodC5lbmRNcz1wZXJmb3JtYW5jZS5ub3coKSx0KX0sdC5wcm90b3R5cGUuZ2V0UXVlcnlUaW1lPWZ1bmN0aW9uKHQpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obil7cmV0dXJuIGEuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIik+MD9bMix0aGlzLmdwZ3B1LndhaXRGb3JRdWVyeUFuZEdldFRpbWUodCldOlsyLChlPXQpLmVuZE1zLWUuc3RhcnRNc119KX0pfSx0LnByb3RvdHlwZS5kaXNwb3NlRGF0YT1mdW5jdGlvbih0KXtpZighdGhpcy5wZW5kaW5nRGlzcG9zYWwuaGFzKHQpKWlmKHRoaXMucGVuZGluZ1JlYWQuaGFzKHQpKXRoaXMucGVuZGluZ0Rpc3Bvc2FsLmFkZCh0KTtlbHNlIGlmKHRoaXMudGV4RGF0YS5oYXModCkpe3RoaXMucmVsZWFzZUdQVURhdGEodCk7dmFyIGU9dGhpcy50ZXhEYXRhLmdldCh0KS5jb21wbGV4VGVuc29ycztudWxsIT1lJiYoZS5yZWFsLmRpc3Bvc2UoKSxlLmltYWcuZGlzcG9zZSgpKSx0aGlzLnRleERhdGEuZGVsZXRlKHQpfX0sdC5wcm90b3R5cGUucmVsZWFzZUdQVURhdGE9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy50ZXhEYXRhLmdldCh0KSxuPWUudGV4dHVyZSxyPWUuZHR5cGUsbz1lLnRleFNoYXBlLGE9ZS51c2FnZSxpPWUuaXNQYWNrZWQscz1lLnNsaWNlLHU9cyYmcy5vcmlnRGF0YUlkfHx0LGw9dGhpcy5kYXRhUmVmQ291bnQuZ2V0KHUpO2w+MT90aGlzLmRhdGFSZWZDb3VudC5zZXQodSxsLTEpOih0aGlzLmRhdGFSZWZDb3VudC5kZWxldGUodSksbnVsbCE9biYmKHRoaXMubnVtQnl0ZXNJbkdQVS09dGhpcy5jb21wdXRlQnl0ZXMobyxyKSx0aGlzLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKG4sbyxhLGkpKSk7dmFyIGM9dGhpcy50ZXhEYXRhLmdldCh0KTtjLnRleHR1cmU9bnVsbCxjLnRleFNoYXBlPW51bGwsYy5pc1BhY2tlZD0hMSxjLnNsaWNlPW51bGx9LHQucHJvdG90eXBlLmdldFRleHR1cmU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudXBsb2FkVG9HUFUodCksdGhpcy50ZXhEYXRhLmdldCh0KS50ZXh0dXJlfSx0LnByb3RvdHlwZS5nZXRDUFVCYWNrZW5kPWZ1bmN0aW9uKCl7cmV0dXJuIGEuZ2V0Qm9vbChcIldFQkdMX0NQVV9GT1JXQVJEXCIpPyhudWxsPT10aGlzLmNwdUJhY2tlbmQmJih0aGlzLmNwdUJhY2tlbmQ9RHQuZmluZEJhY2tlbmQoXCJjcHVcIikpLHRoaXMuY3B1QmFja2VuZCk6bnVsbH0sdC5wcm90b3R5cGUuc2hvdWxkRXhlY3V0ZU9uQ1BVPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcztyZXR1cm4gdm9pZCAwPT09ZSYmKGU9MTI4KSxudWxsIT10aGlzLmdldENQVUJhY2tlbmQoKSYmdC5ldmVyeShmdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09bi50ZXhEYXRhLmdldCh0LmRhdGFJZCkudGV4dHVyZSYmdC5zaXplPGV9KX0sdC5wcm90b3R5cGUuZ2V0R1BHUFVDb250ZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ3BncHV9LHQucHJvdG90eXBlLmdldENhbnZhcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNhbnZhc30sdC5wcm90b3R5cGUuY29tcGxleD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMubWFrZU91dHB1dEFycmF5KHQuc2hhcGUsXCJjb21wbGV4NjRcIik7cmV0dXJuIHRoaXMudGV4RGF0YS5nZXQobi5kYXRhSWQpLmNvbXBsZXhUZW5zb3JzPXtyZWFsOkR0LmtlZXAodC5jbG9uZSgpKSxpbWFnOkR0LmtlZXAoZS5jbG9uZSgpKX0sbn0sdC5wcm90b3R5cGUucmVhbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCkuY29tcGxleFRlbnNvcnMucmVhbC5jbG9uZSgpfSx0LnByb3RvdHlwZS5pbWFnPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKS5jb21wbGV4VGVuc29ycy5pbWFnLmNsb25lKCl9LHQucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuc2xpY2UodCxlLG4pO3ZhciByPXRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLmlzUGFja2VkLG89bW4odC5zaGFwZSxlLG4pO2lmKHJ8fCFvKXt2YXIgaT1hLmdldEJvb2woXCJXRUJHTF9QQUNLX0FSUkFZX09QRVJBVElPTlNcIik/bmV3IGZpKG4pOm5ldyBoaShuKSxzPWkuZ2V0Q3VzdG9tU2V0dXBGdW5jKGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oaSxbdF0sbnVsbCxzKX1yZXR1cm4gdGhpcy51cGxvYWRUb0dQVSh0LmRhdGFJZCksdGhpcy5zaGFsbG93U2xpY2UodCxlLG4pfSx0LnByb3RvdHlwZS5zaGFsbG93U2xpY2U9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLG89ZnQubWFrZShuLHt9LHQuZHR5cGUsdGhpcyksYT10aGlzLnRleERhdGEuZ2V0KG8uZGF0YUlkKTtPYmplY3QuYXNzaWduKGEsciksYS5zaGFwZT1uLGEuZHR5cGU9dC5kdHlwZTt2YXIgaT1nbihlLHQuc3RyaWRlcyk7ci5zbGljZSYmKGkrPXIuc2xpY2UuZmxhdE9mZnNldCksYS5zbGljZT17ZmxhdE9mZnNldDppLG9yaWdEYXRhSWQ6ci5zbGljZSYmci5zbGljZS5vcmlnRGF0YUlkfHx0LmRhdGFJZH07dmFyIHM9dGhpcy5kYXRhUmVmQ291bnQuZ2V0KGEuc2xpY2Uub3JpZ0RhdGFJZCl8fDE7cmV0dXJuIHRoaXMuZGF0YVJlZkNvdW50LnNldChhLnNsaWNlLm9yaWdEYXRhSWQscysxKSxvfSx0LnByb3RvdHlwZS5zdHJpZGVkU2xpY2U9ZnVuY3Rpb24odCxlLG4scixvLGEsaSxzLHUpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5zdHJpZGVkU2xpY2UodCxlLG4scixvLGEsaSxzLHUpO3ZhciBsPWZuKHQuc2hhcGUsZSxuLHIsbyxhLGkscyx1KSxjPWxbMF0saD1sWzFdLHA9bFsyXSxmPWguZmlsdGVyKGZ1bmN0aW9uKHQsZSl7cmV0dXJuLTE9PT1wLmluZGV4T2YoZSl9KTtpZihmLnNvbWUoZnVuY3Rpb24odCl7cmV0dXJuIDA9PT10fSkpcmV0dXJuIEZuKFtdLGYpO3ZhciBkPW5ldyBkaShjLHIsaCxwKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGQsW3RdKX0sdC5wcm90b3R5cGUucmV2ZXJzZT1mdW5jdGlvbih0LGUpe3ZhciBuPWEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiKT9uZXcgc2kodC5zaGFwZSxlKTpuZXcgaWkodC5zaGFwZSxlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3RdKX0sdC5wcm90b3R5cGUuY29uY2F0PWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUodCkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5jb25jYXQodCxlKTtpZigxPT09dC5sZW5ndGgpcmV0dXJuIHRbMF07aWYodC5sZW5ndGg+YS5nZXROdW1iZXIoXCJXRUJHTF9NQVhfVEVYVFVSRVNfSU5fU0hBREVSXCIpKXt2YXIgbj1NYXRoLmZsb29yKHQubGVuZ3RoLzIpLHI9dGhpcy5jb25jYXQodC5zbGljZSgwLG4pLGUpLG89dGhpcy5jb25jYXQodC5zbGljZShuKSxlKTtyZXR1cm4gdGhpcy5jb25jYXQoW3Isb10sZSl9aWYoYS5nZXRCb29sKFwiV0VCR0xfUEFDS19BUlJBWV9PUEVSQVRJT05TXCIpJiZ0WzBdLnJhbms+MSl7dmFyIGk9bmV3IFVvKHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSksZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihpLHQpfXZhciBzPXNuKHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSksZSksdT10Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5hczJEKC0xLHkodC5zaGFwZS5zbGljZShlKSkpfSksbD1uZXcgV28odS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihsLHUpLnJlc2hhcGUocyl9LHQucHJvdG90eXBlLm5lZz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcInJldHVybiAteDtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLmJhdGNoTWF0TXVsPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPW4/dC5zaGFwZVsyXTp0LnNoYXBlWzFdLGE9cj9lLnNoYXBlWzFdOmUuc2hhcGVbMl0saT1uP3Quc2hhcGVbMV06dC5zaGFwZVsyXSxzPXQuc2hhcGVbMF07aWYoKDE9PT1vfHwxPT09YSkmJmk+MWUzKXtuJiYodD10LnRyYW5zcG9zZShbMCwyLDFdKSksciYmKGU9ZS50cmFuc3Bvc2UoWzAsMiwxXSkpO3ZhciB1PTE9PT1hP3Q6dC5hczNEKHMsaSwxKSxsPTE9PT1hPzI6MSxjPTE9PT1hP2UuYXMzRChzLDEsaSk6ZTtyZXR1cm4gdGhpcy5tdWx0aXBseSh1LGMpLnN1bShsLCEwKX12YXIgaD1DdCh0LmR0eXBlLGUuZHR5cGUpLHA9bmV3ICRhKHQuc2hhcGUsW3MsbyxhXSxuLHIpLGY9dGhpcy5tYWtlUGFja2VkVGVuc29yKHAub3V0cHV0U2hhcGUsaCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwLFt0LGVdLGYpfSx0LnByb3RvdHlwZS5mdXNlZEJhdGNoTWF0TXVsPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2YXIgaT1uP3Quc2hhcGVbMl06dC5zaGFwZVsxXSxzPXI/ZS5zaGFwZVsxXTplLnNoYXBlWzJdLHU9dC5zaGFwZVswXSxsPUN0KHQuZHR5cGUsZS5kdHlwZSksYz1uZXcgJGEodC5zaGFwZSxbdSxpLHNdLG4sciwhIW8sYT9mdW5jdGlvbih0LGUpe2lmKHZvaWQgMD09PWUmJihlPSExKSxcImxpbmVhclwiPT09dClyZXR1cm4gZT9NaTpTaTtpZihcInJlbHVcIj09PXQpcmV0dXJuIGU/Rmk6Tmk7dGhyb3cgbmV3IEVycm9yKFwiQWN0aXZhdGlvbiBcIit0K1wiIGhhcyBub3QgYmVlbiBpbXBsZW1lbnRlZCBmb3IgdGhlIFdlYkdMIGJhY2tlbmQuXCIpfShhLCEwKTpudWxsKSxoPXRoaXMubWFrZVBhY2tlZFRlbnNvcihjLm91dHB1dFNoYXBlLGwpLHA9W3QsZV07cmV0dXJuIG8mJnAucHVzaChvKSx0aGlzLmNvbXBpbGVBbmRSdW4oYyxwLGgpfSx0LnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbih0LGUpe2lmKFwiY29tcGxleDY0XCI9PT10LmR0eXBlKXt2YXIgbj10aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKSxyPXRoaXMudGV4RGF0YS5nZXQoZS5kYXRhSWQpLG89bmV3IFRvKElvLHQuc2hhcGUsZS5zaGFwZSksaT1uZXcgVG8oQW8sdC5zaGFwZSxlLnNoYXBlKSxzPVt0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlKHQsbi5jb21wbGV4VGVuc29ycy5yZWFsKSx0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlKHQsbi5jb21wbGV4VGVuc29ycy5pbWFnKSx0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlKGUsci5jb21wbGV4VGVuc29ycy5yZWFsKSx0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlKGUsci5jb21wbGV4VGVuc29ycy5pbWFnKV0sdT10aGlzLmNvbXBpbGVBbmRSdW4obyxzKSxsPXRoaXMuY29tcGlsZUFuZFJ1bihpLHMpLGM9dGhpcy5jb21wbGV4KHUsbCk7cmV0dXJuIHUuZGlzcG9zZSgpLGwuZGlzcG9zZSgpLGN9aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3QsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQubXVsdGlwbHkodCxlKTtpZihhLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxfbyx0LmR0eXBlKTt2YXIgaD1uZXcgTW8oX28sdC5zaGFwZSxlLnNoYXBlKSxwPXRoaXMubWFrZU91dHB1dEFycmF5KGgub3V0cHV0U2hhcGUsdC5kdHlwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihoLFt0LGVdLHApfSx0LnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb249ZnVuY3Rpb24odCxlLG4scixvLGkpe3ZhciBzPVt0LGUsbl0sdT1udWxsO251bGwhPWkmJih1PWkuc2hhcGUscy5wdXNoKGkpKTt2YXIgbD1udWxsO2lmKG51bGwhPW8mJihsPW8uc2hhcGUscy5wdXNoKG8pKSxhLmdldEJvb2woXCJXRUJHTF9QQUNLX05PUk1BTElaQVRJT05cIikpe3ZhciBjPW5ldyBrbyh0LnNoYXBlLGUuc2hhcGUsbi5zaGFwZSx1LGwscik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihjLHMpfXZhciBoPW5ldyBObyh0LnNoYXBlLGUuc2hhcGUsbi5zaGFwZSx1LGwscik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihoLHMpfSx0LnByb3RvdHlwZS5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dmFyIGk9YS5nZXRCb29sKFwiV0VCR0xfUEFDS19OT1JNQUxJWkFUSU9OXCIpP25ldyBxYSh0LnNoYXBlLGUsbixyLG8pOm5ldyBWYSh0LnNoYXBlLGUsbixyLG8pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oaSxbdF0pfSx0LnByb3RvdHlwZS5MUk5HcmFkPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3ZhciBzPW5ldyBHYShlLnNoYXBlLHIsbyxhLGkpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocyxbZSxuLHRdKX0sdC5wcm90b3R5cGUudGlsZT1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyB5aSh0LnNoYXBlLGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdF0pfSx0LnByb3RvdHlwZS5wYWQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPWEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiKT9uZXcgUWEodC5zaGFwZSxlLG4pOm5ldyBZYSh0LnNoYXBlLGUsbik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0XSl9LHQucHJvdG90eXBlLnRyYW5zcG9zZT1mdW5jdGlvbih0LGUpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC50cmFuc3Bvc2UodCxlKTt2YXIgbj1hLmdldEJvb2woXCJXRUJHTF9QQUNLX0FSUkFZX09QRVJBVElPTlNcIik/bmV3IHdpKHQuc2hhcGUsZSk6bmV3IHhpKHQuc2hhcGUsZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0XSl9LHQucHJvdG90eXBlLmdhdGhlcj1mdW5jdGlvbih0LGUsbil7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3QsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuZ2F0aGVyKHQsZSxuKTt2YXIgcj1uZXcgc2EodC5zaGFwZSxlLnNpemUsbik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKX0sdC5wcm90b3R5cGUuYmF0Y2hUb1NwYWNlTkQ9ZnVuY3Rpb24odCxlLG4pe2QodC5yYW5rPD00LGZ1bmN0aW9uKCl7cmV0dXJuXCJiYXRjaFRvU3BhY2VORCBmb3IgcmFuayA+IDQgd2l0aCBhIFdlYkdMIGJhY2tlbmQgbm90IGltcGxlbWVudGVkIHlldFwifSk7dmFyIHI9ZS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSksbz1LZSh0LnNoYXBlLGUsciksYT1YZShvLmxlbmd0aCxlLmxlbmd0aCksaT1ZZSh0LnNoYXBlLGUscikscz1RZShuLGUubGVuZ3RoKSx1PUplKGksbixlLmxlbmd0aCk7cmV0dXJuIHQucmVzaGFwZShvKS50cmFuc3Bvc2UoYSkucmVzaGFwZShpKS5zbGljZShzLHUpfSx0LnByb3RvdHlwZS5zcGFjZVRvQmF0Y2hORD1mdW5jdGlvbih0LGUsbil7ZCh0LnJhbms8PTQsZnVuY3Rpb24oKXtyZXR1cm5cInNwYWNlVG9CYXRjaE5EIGZvciByYW5rID4gNCB3aXRoIGEgV2ViR0wgYmFja2VuZCBub3QgaW1wbGVtZW50ZWQgeWV0XCJ9KTt2YXIgcj1lLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSxvPVtbMCwwXV07by5wdXNoLmFwcGx5KG8sbik7Zm9yKHZhciBhPTErZS5sZW5ndGg7YTx0LnNoYXBlLmxlbmd0aDsrK2Epby5wdXNoKFswLDBdKTt2YXIgaT10LnBhZChvKSxzPUtlKGkuc2hhcGUsZSxyLCExKSx1PVhlKHMubGVuZ3RoLGUubGVuZ3RoLCExKSxsPVllKGkuc2hhcGUsZSxyLCExKTtyZXR1cm4gaS5yZXNoYXBlKHMpLnRyYW5zcG9zZSh1KS5yZXNoYXBlKGwpfSx0LnByb3RvdHlwZS5yZWR1Y2U9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXQuc2hhcGVbMF0sbz10LnNoYXBlWzFdLGE9Y24obyksaT1uZXcgWmEoe3dpbmRvd1NpemU6YSxpblNpemU6byxiYXRjaFNpemU6cn0sZSkscz1pLm91dHB1dFNoYXBlLHU9c1swXSxsPXNbMV0sYz10aGlzLm1ha2VPdXRwdXRBcnJheShbdSxsXSxuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGksW3RdLGMpLDE9PT1jLnNoYXBlWzFdP2M6dGhpcy5yZWR1Y2UoYyxlLG4pfSx0LnByb3RvdHlwZS5hcmdSZWR1Y2U9ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPW51bGwpO3ZhciByPXQuc2hhcGVbMF0sbz10LnNoYXBlWzFdO251bGwhPW4mJihyPW4uc2hhcGVbMF0sbz1uLnNoYXBlWzFdKTt2YXIgYT1jbihvKSxpPW5ldyBubyh7d2luZG93U2l6ZTphLGluU2l6ZTpvLGJhdGNoU2l6ZTpyfSxlLG51bGw9PW4pLHM9aS5vdXRwdXRTaGFwZSx1PXNbMF0sbD1zWzFdLGM9dGhpcy5tYWtlT3V0cHV0QXJyYXkoW3UsbF0sXCJpbnQzMlwiKSxoPVt0XTtyZXR1cm4gbnVsbCE9biYmaC5wdXNoKG4pLHRoaXMuY29tcGlsZUFuZFJ1bihpLGgsYyksMT09PWMuc2hhcGVbMV0/Yzp0aGlzLmFyZ1JlZHVjZSh0LGUsYyl9LHQucHJvdG90eXBlLmFyZ1JlZHVjZVBhY2tlZD1mdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49bnVsbCk7dmFyIHI9bnVsbCE9bj9uLnNoYXBlOnQuc2hhcGUsbz1jbihyW3IubGVuZ3RoLTFdKSxhPW5ldyBSbyhyLG8sZSxudWxsPT1uKSxpPXRoaXMubWFrZVBhY2tlZFRlbnNvcihhLm91dHB1dFNoYXBlLFwiaW50MzJcIikscz1udWxsPT1uP1t0XTpbdCxuXTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGEscyxpKSxpLnJhbms9PT10LnJhbms/dGhpcy5hcmdSZWR1Y2VQYWNrZWQodCxlLGkpOml9LHQucHJvdG90eXBlLnN1bT1mdW5jdGlvbih0LGUpe25uKFwic3VtXCIsZSx0LnJhbmspO3ZhciBuPXRuKHQuc2hhcGUsZSkscj1uWzBdLG89eShuWzFdKSxhPXQuYXMyRCgtMSxvKSxpPUV0KHQuZHR5cGUpO3JldHVybiB0aGlzLnJlZHVjZShhLFwic3VtXCIsaSkucmVzaGFwZShyKX0sdC5wcm90b3R5cGUucHJvZD1mdW5jdGlvbih0LGUpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5wcm9kKHQsZSk7dmFyIG49dG4odC5zaGFwZSxlKSxyPW5bMF0sbz15KG5bMV0pLGE9dC5hczJEKC0xLG8pLGk9RXQodC5kdHlwZSk7cmV0dXJuIHRoaXMucmVkdWNlKGEsXCJwcm9kXCIsaSkucmVzaGFwZShyKX0sdC5wcm90b3R5cGUudW5zb3J0ZWRTZWdtZW50U3VtPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj0wLG89cm4oW3JdLHQucmFuayksYT10O251bGwhPW8mJihhPXQudHJhbnNwb3NlKG8pLHI9YW4oMSx0LnJhbmspWzBdKTt2YXIgaT1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPVtdLG89dC5sZW5ndGgsYT0wO2E8bzthKyspYSE9PWU/ci5wdXNoKHRbYV0pOnIucHVzaChuKTtyZXR1cm4gcn0oYS5zaGFwZSxyLG4pLHM9eShbYS5zaGFwZVtyXV0pLHU9YS5hczJEKC0xLHMpLGw9RXQodC5kdHlwZSksYz10aGlzLnNlZ09wQ29tcHV0ZSh1LFwidW5zb3J0ZWRTZWdtZW50U3VtXCIsZSxsLG4pLnJlc2hhcGUoaSk7cmV0dXJuIG51bGwhPW8mJihjPWMudHJhbnNwb3NlKG9uKG8pKSksY30sdC5wcm90b3R5cGUuc2VnT3BDb21wdXRlPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dmFyIGE9dC5zaGFwZVswXSxpPXQuc2hhcGVbMV0scz1mdW5jdGlvbih0LGUpe3ZhciBuLHI9ITE7Zm9yKHQ8PWxuPyhuPXQscj0hMCk6bj16KHQsTWF0aC5mbG9vcihNYXRoLnNxcnQodCkpKTshcjspbj5lfHxuPT09dD9yPSEwOm49eih0LG4rMSk7cmV0dXJuIG59KGksbyksdT1uZXcgbGkoe3dpbmRvd1NpemU6cyxpblNpemU6aSxiYXRjaFNpemU6YSxudW1TZWdtZW50czpvfSxlKSxsPXUub3V0cHV0U2hhcGUsYz1sWzBdLGg9bFsxXSxwPXRoaXMubWFrZU91dHB1dEFycmF5KFtjLGhdLHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odSxbdCxuXSxwKSxwLnNoYXBlWzFdPT09bz9wOihuPWpuKDAsbykudGlsZShbaS9zXSksdGhpcy5zZWdPcENvbXB1dGUocCxlLG4scixvKSl9LHQucHJvdG90eXBlLmFyZ01pbk1heFJlZHVjZT1mdW5jdGlvbih0LGUsbil7dmFyIHI9W2VdO2lmKG5uKFwiYXJnXCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLHIsdC5yYW5rKSwhYS5nZXRCb29sKFwiV0VCR0xfUEFDS19SRURVQ0VcIil8fHQucmFuazw9Mil7dmFyIG89dG4odC5zaGFwZSxyKSxpPW9bMF0scz15KG9bMV0pLHU9dC5hczJEKC0xLHMpO3JldHVybiB0aGlzLmFyZ1JlZHVjZSh1LG4pLnJlc2hhcGUoaSl9cmV0dXJuIHRoaXMuYXJnUmVkdWNlUGFja2VkKHQsbil9LHQucHJvdG90eXBlLmFyZ01pbj1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFyZ01pbk1heFJlZHVjZSh0LGUsXCJtaW5cIil9LHQucHJvdG90eXBlLmFyZ01heD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFyZ01pbk1heFJlZHVjZSh0LGUsXCJtYXhcIil9LHQucHJvdG90eXBlLmN1bXN1bT1mdW5jdGlvbih0LGUsbixyKXtpZihlIT09dC5yYW5rLTEpdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgY3Vtc3VtIHNoYWRlciBleHBlY3RzIGFuIGlubmVyLW1vc3QgYXhpcz1cIisodC5yYW5rLTEpK1wiIGJ1dCBnb3QgYXhpcz1cIitlKTt2YXIgbz1uZXcgSm8odC5zaGFwZSxuLHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obyxbdF0pfSx0LnByb3RvdHlwZS5lcXVhbD1mdW5jdGlvbih0LGUpe2lmKGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICByZXR1cm4gdmVjNChlcXVhbChhLCBiKSk7XFxuXCIsXCJib29sXCIpO3ZhciBuPW5ldyBNbyhcInJldHVybiBmbG9hdChhID09IGIpO1wiLHQuc2hhcGUsZS5zaGFwZSkscj10aGlzLm1ha2VPdXRwdXRBcnJheShuLm91dHB1dFNoYXBlLFwiYm9vbFwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0scil9LHQucHJvdG90eXBlLm5vdEVxdWFsPWZ1bmN0aW9uKHQsZSl7aWYoYS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIHJldHVybiB2ZWM0KG5vdEVxdWFsKGEsIGIpKTtcXG5cIixcImJvb2xcIik7dmFyIG49bmV3IE1vKFwicmV0dXJuIGZsb2F0KGEgIT0gYik7XCIsdC5zaGFwZSxlLnNoYXBlKSxyPXRoaXMubWFrZU91dHB1dEFycmF5KG4ub3V0cHV0U2hhcGUsXCJib29sXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxyKX0sdC5wcm90b3R5cGUubGVzcz1mdW5jdGlvbih0LGUpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0LGVdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmxlc3ModCxlKTtpZihhLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxcIlxcbiAgcmV0dXJuIHZlYzQobGVzc1RoYW4oYSwgYikpO1xcblwiLFwiYm9vbFwiKTt2YXIgbj1uZXcgTW8oXCJyZXR1cm4gZmxvYXQoYSA8IGIpO1wiLHQuc2hhcGUsZS5zaGFwZSkscj10aGlzLm1ha2VPdXRwdXRBcnJheShuLm91dHB1dFNoYXBlLFwiYm9vbFwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0scil9LHQucHJvdG90eXBlLmxlc3NFcXVhbD1mdW5jdGlvbih0LGUpe2lmKGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICByZXR1cm4gdmVjNChsZXNzVGhhbkVxdWFsKGEsIGIpKTtcXG5cIixcImJvb2xcIik7dmFyIG49bmV3IE1vKFwicmV0dXJuIGZsb2F0KGEgPD0gYik7XCIsdC5zaGFwZSxlLnNoYXBlKSxyPXRoaXMubWFrZU91dHB1dEFycmF5KG4ub3V0cHV0U2hhcGUsXCJib29sXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxyKX0sdC5wcm90b3R5cGUuZ3JlYXRlcj1mdW5jdGlvbih0LGUpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0LGVdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmdyZWF0ZXIodCxlKTtpZihhLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxcIlxcbiAgcmV0dXJuIHZlYzQoZ3JlYXRlclRoYW4oYSwgYikpO1xcblwiLFwiYm9vbFwiKTt2YXIgbj1uZXcgTW8oXCJyZXR1cm4gZmxvYXQoYSA+IGIpO1wiLHQuc2hhcGUsZS5zaGFwZSkscj10aGlzLm1ha2VPdXRwdXRBcnJheShuLm91dHB1dFNoYXBlLFwiYm9vbFwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0scil9LHQucHJvdG90eXBlLmdyZWF0ZXJFcXVhbD1mdW5jdGlvbih0LGUpe2lmKGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICByZXR1cm4gdmVjNChncmVhdGVyVGhhbkVxdWFsKGEsIGIpKTtcXG5cIixcImJvb2xcIik7dmFyIG49bmV3IE1vKFwicmV0dXJuIGZsb2F0KGEgPj0gYik7XCIsdC5zaGFwZSxlLnNoYXBlKSxyPXRoaXMubWFrZU91dHB1dEFycmF5KG4ub3V0cHV0U2hhcGUsXCJib29sXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxyKX0sdC5wcm90b3R5cGUubG9naWNhbE5vdD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcInJldHVybiBmbG9hdCghKHggPj0gMS4wKSk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5sb2dpY2FsQW5kPWZ1bmN0aW9uKHQsZSl7aWYoYS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIHJldHVybiB2ZWM0KFxcbiAgICB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoYSwgdmVjNCgxLjApKSkgKlxcbiAgICB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoYiwgdmVjNCgxLjApKSkpO1xcblwiLFwiYm9vbFwiKTt2YXIgbj1uZXcgTW8oXCJyZXR1cm4gZmxvYXQoYSA+PSAxLjAgJiYgYiA+PSAxLjApO1wiLHQuc2hhcGUsZS5zaGFwZSkscj10aGlzLm1ha2VPdXRwdXRBcnJheShuLm91dHB1dFNoYXBlLFwiYm9vbFwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0scil9LHQucHJvdG90eXBlLmxvZ2ljYWxPcj1mdW5jdGlvbih0LGUpe2lmKGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICByZXR1cm4gbWluKFxcbiAgICB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoYSwgdmVjNCgxLjApKSkgK1xcbiAgICB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoYiwgdmVjNCgxLjApKSksXFxuICAgIHZlYzQoMS4wKSk7XFxuXCIsXCJib29sXCIpO3ZhciBuPW5ldyBNbyhcInJldHVybiBmbG9hdChhID49IDEuMCB8fCBiID49IDEuMCk7XCIsdC5zaGFwZSxlLnNoYXBlKSxyPXRoaXMubWFrZU91dHB1dEFycmF5KG4ub3V0cHV0U2hhcGUsXCJib29sXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxyKX0sdC5wcm90b3R5cGUuc2VsZWN0PWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgY2kodC5yYW5rLGUuc2hhcGUsZS5yYW5rKSxvPXRoaXMubWFrZU91dHB1dEFycmF5KHIub3V0cHV0U2hhcGUsQ3QoZS5kdHlwZSxuLmR0eXBlKSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGUsbl0sbyl9LHQucHJvdG90eXBlLndoZXJlPWZ1bmN0aW9uKHQpe2plKFwidGYud2hlcmUoKSBpbiB3ZWJnbCBsb2NrcyB0aGUgVUkgdGhyZWFkLiBDYWxsIHRmLndoZXJlQXN5bmMoKSBpbnN0ZWFkXCIpO3ZhciBlPXQuZGF0YVN5bmMoKTtyZXR1cm4gWnIodC5zaGFwZSxlKX0sdC5wcm90b3R5cGUudG9waz1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHVyKHQuZGF0YVN5bmMoKSx0LnNoYXBlLHQuZHR5cGUsZSl9LHQucHJvdG90eXBlLm1pbj1mdW5jdGlvbih0LGUpe25uKFwibWluXCIsZSx0LnJhbmspO3ZhciBuPXRuKHQuc2hhcGUsZSkscj1uWzBdLG89eShuWzFdKSxhPXQuYXMyRCgtMSxvKTtyZXR1cm4gdGhpcy5yZWR1Y2UoYSxcIm1pblwiLGEuZHR5cGUpLnJlc2hhcGUocil9LHQucHJvdG90eXBlLm1pbmltdW09ZnVuY3Rpb24odCxlKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdCxlXSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5taW5pbXVtKHQsZSk7dmFyIG49YS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKT9uZXcgRm8oXCJcXG4gIHZlYzQgcmVzdWx0ID0gdmVjNChtaW4oYSwgYikpO1xcbiAgdmVjNCBpc05hTiA9IG1pbih2ZWM0KGlzbmFuKGEpKSArIHZlYzQoaXNuYW4oYikpLCB2ZWM0KDEuMCkpO1xcbiAgXFxuICByZXN1bHQuciA9IGlzTmFOLnIgPiAwLiA/IE5BTiA6IHJlc3VsdC5yO1xcbiAgcmVzdWx0LmcgPSBpc05hTi5nID4gMC4gPyBOQU4gOiByZXN1bHQuZztcXG4gIHJlc3VsdC5iID0gaXNOYU4uYiA+IDAuID8gTkFOIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzTmFOLmEgPiAwLiA/IE5BTiA6IHJlc3VsdC5hO1xcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIix0LnNoYXBlLGUuc2hhcGUpOm5ldyBNbyhcIlxcbiAgaWYgKGlzbmFuKGEpKSByZXR1cm4gYTtcXG4gIGlmIChpc25hbihiKSkgcmV0dXJuIGI7XFxuXFxuICByZXR1cm4gbWluKGEsIGIpO1xcblwiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdKX0sdC5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKHQsZSl7dmFyIG49YS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKT9uZXcgRm8oXCJcXG4gIHZlYzQgcmVzdWx0ID0gbW9kKGEsIGIpO1xcbiAgdmVjNCBpc05hTiA9IHZlYzQoZXF1YWwoYiwgdmVjNCgwLjApKSk7XFxuICBcXG4gIHJlc3VsdC5yID0gaXNOYU4uciA+IDAuID8gTkFOIDogcmVzdWx0LnI7XFxuICByZXN1bHQuZyA9IGlzTmFOLmcgPiAwLiA/IE5BTiA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc05hTi5iID4gMC4gPyBOQU4gOiByZXN1bHQuYjtcXG4gIHJlc3VsdC5hID0gaXNOYU4uYSA+IDAuID8gTkFOIDogcmVzdWx0LmE7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcblwiLHQuc2hhcGUsZS5zaGFwZSk6bmV3IE1vKFwiaWYgKGIgPT0gMC4wKSByZXR1cm4gTkFOO1xcbiAgcmV0dXJuIG1vZChhLCBiKTtcIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSl9LHQucHJvdG90eXBlLm1heD1mdW5jdGlvbih0LGUpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5tYXgodCxlKTtubihcIm1heFwiLGUsdC5yYW5rKTt2YXIgbj10bih0LnNoYXBlLGUpLHI9blswXSxvPXkoblsxXSksYT10LmFzMkQoLTEsbyk7cmV0dXJuIHRoaXMucmVkdWNlKGEsXCJtYXhcIixhLmR0eXBlKS5yZXNoYXBlKHIpfSx0LnByb3RvdHlwZS5tYXhpbXVtPWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3QsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQubWF4aW11bSh0LGUpO3ZhciBuPWEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIik/bmV3IEZvKFwiXFxuICB2ZWM0IHJlc3VsdCA9IHZlYzQobWF4KGEsIGIpKTtcXG4gIHZlYzQgaXNOYU4gPSBtaW4odmVjNChpc25hbihhKSkgKyB2ZWM0KGlzbmFuKGIpKSwgdmVjNCgxLjApKTtcXG4gIFxcbiAgcmVzdWx0LnIgPSBpc05hTi5yID4gMC4gPyBOQU4gOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA+IDAuID8gTkFOIDogcmVzdWx0Lmc7XFxuICByZXN1bHQuYiA9IGlzTmFOLmIgPiAwLiA/IE5BTiA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc05hTi5hID4gMC4gPyBOQU4gOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTpuZXcgTW8oXCJcXG4gIGlmIChpc25hbihhKSkgcmV0dXJuIGE7XFxuICBpZiAoaXNuYW4oYikpIHJldHVybiBiO1xcblxcbiAgcmV0dXJuIG1heChhLCBiKTtcXG5cIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSl9LHQucHJvdG90eXBlLmFsbD1mdW5jdGlvbih0LGUpe25uKFwiYWxsXCIsZSx0LnJhbmspO3ZhciBuPXRuKHQuc2hhcGUsZSkscj1uWzBdLG89eShuWzFdKSxhPXQuYXMyRCgtMSxvKTtyZXR1cm4gdGhpcy5yZWR1Y2UoYSxcImFsbFwiLGEuZHR5cGUpLnJlc2hhcGUocil9LHQucHJvdG90eXBlLmFueT1mdW5jdGlvbih0LGUpe25uKFwiYW55XCIsZSx0LnJhbmspO3ZhciBuPXRuKHQuc2hhcGUsZSkscj1uWzBdLG89eShuWzFdKSxhPXQuYXMyRCgtMSxvKTtyZXR1cm4gdGhpcy5yZWR1Y2UoYSxcImFueVwiLGEuZHR5cGUpLnJlc2hhcGUocil9LHQucHJvdG90eXBlLnNxdWFyZWREaWZmZXJlbmNlPWZ1bmN0aW9uKHQsZSl7dmFyIG49YS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKT9uZXcgRm8oXCJyZXR1cm4gKGEgLSBiKSAqIChhIC0gYik7XCIsdC5zaGFwZSxlLnNoYXBlKTpuZXcgTW8oXCJyZXR1cm4gKGEgLSBiKSAqIChhIC0gYik7XCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0pfSx0LnByb3RvdHlwZS5yZWFsRGl2aWRlPWZ1bmN0aW9uKHQsZSl7aWYoYS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSl7cmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICAvLyB2ZWM0IG9uZSA9IHZlYzQoZXF1YWwoYSwgYikpO1xcbiAgLy8gcmV0dXJuIG9uZSArICh2ZWM0KDEuMCkgLSBvbmUpICogYSAvIGI7XFxuICB2ZWM0IHJlc3VsdCA9IGEgLyBiO1xcbiAgaWYoYi54ID09IDAuMCkge1xcbiAgICByZXN1bHQueCA9IE5BTjtcXG4gIH0gZWxzZSBpZihhLnggPT0gYi54KSB7XFxuICAgIHJlc3VsdC54ID0gMS47XFxuICB9XFxuICBpZihiLnkgPT0gMC4wKSB7XFxuICAgIHJlc3VsdC55ID0gTkFOO1xcbiAgfSBlbHNlIGlmKGEueSA9PSBiLnkpIHtcXG4gICAgcmVzdWx0LnkgPSAxLjtcXG4gIH1cXG4gIGlmKGIueiA9PSAwLjApIHtcXG4gICAgcmVzdWx0LnogPSBOQU47XFxuICB9IGVsc2UgaWYoYS56ID09IGIueikge1xcbiAgICByZXN1bHQueiA9IDEuO1xcbiAgfVxcbiAgaWYoYi53ID09IDAuMCkge1xcbiAgICByZXN1bHQudyA9IE5BTjtcXG4gIH0gZWxzZSBpZihhLncgPT0gYi53KSB7XFxuICAgIHJlc3VsdC53ID0gMS47XFxuICB9XFxuICBcXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsXCJmbG9hdDMyXCIsITApfXZhciBuPW5ldyBNbyhcIlxcbmlmIChiID09IDAuMCkge1xcbiAgcmV0dXJuIE5BTjtcXG59IFxcbmlmIChhID09IGIpIHtcXG4gIHJldHVybiAxLjA7XFxufTtcXG5yZXR1cm4gYSAvIGI7XCIsdC5zaGFwZSxlLnNoYXBlKSxyPXRoaXMubWFrZU91dHB1dEFycmF5KG4ub3V0cHV0U2hhcGUsXCJmbG9hdDMyXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxyKX0sdC5wcm90b3R5cGUuZmxvb3JEaXY9ZnVuY3Rpb24odCxlKXtpZihhLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxcIlxcbiAgaXZlYzQgaWEgPSByb3VuZChhKTtcXG4gIGl2ZWM0IGliID0gcm91bmQoYik7XFxuICBidmVjNCBjb25kID0gbm90RXF1YWwoaWIsIGl2ZWM0KDApKTtcXG4gIGl2ZWM0IHJlc3VsdCA9IGl2ZWM0KDApO1xcbiAgdmVjNCBzID0gc2lnbihhKSAqIHNpZ24oYik7XFxuXFxuICAvLyBXaW5kb3dzIChEM0QpIHdhbnRzIGd1YXJhbnRlZWQgbm9uLXplcm8gaW50IGRpdmlzaW9uIGF0IGNvbXBpbGUtdGltZS5cXG4gIGlmIChjb25kWzBdKSB7XFxuICAgIHJlc3VsdFswXSA9IGlkaXYoaWFbMF0sIGliWzBdLCBzWzBdKTtcXG4gIH1cXG4gIGlmIChjb25kWzFdKSB7XFxuICAgIHJlc3VsdFsxXSA9IGlkaXYoaWFbMV0sIGliWzFdLCBzWzFdKTtcXG4gIH1cXG4gIGlmIChjb25kWzJdKSB7XFxuICAgIHJlc3VsdFsyXSA9IGlkaXYoaWFbMl0sIGliWzJdLCBzWzJdKTtcXG4gIH1cXG4gIGlmIChjb25kWzNdKSB7XFxuICAgIHJlc3VsdFszXSA9IGlkaXYoaWFbM10sIGliWzNdLCBzWzNdKTtcXG4gIH1cXG4gIHJldHVybiB2ZWM0KHJlc3VsdCk7XFxuXCIsXCJpbnQzMlwiKTt2YXIgbj1uZXcgTW8oXCJcXG4gIGZsb2F0IHMgPSBzaWduKGEpICogc2lnbihiKTtcXG4gIGludCBpYSA9IHJvdW5kKGEpO1xcbiAgaW50IGliID0gcm91bmQoYik7XFxuICBpZiAoaWIgIT0gMCkge1xcbiAgICAvLyBXaW5kb3dzIChEM0QpIHdhbnRzIGd1YXJhbnRlZWQgbm9uLXplcm8gaW50IGRpdmlzaW9uIGF0IGNvbXBpbGUtdGltZS5cXG4gICAgcmV0dXJuIGZsb2F0KGlkaXYoaWEsIGliLCBzKSk7XFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gTkFOO1xcbiAgfVxcblwiLHQuc2hhcGUsZS5zaGFwZSkscj10aGlzLm1ha2VPdXRwdXRBcnJheShuLm91dHB1dFNoYXBlLFwiaW50MzJcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLHIpfSx0LnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCxlKXtpZihcImNvbXBsZXg2NFwiPT09dC5kdHlwZSYmXCJjb21wbGV4NjRcIj09PWUuZHR5cGUpcmV0dXJuIHRoaXMuY29tcGxleFNlcGFyYWJsZUJpbmFyeU9wKHQsZSxEbyk7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3QsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuYWRkKHQsZSk7dmFyIG49Q3QodC5kdHlwZSxlLmR0eXBlKTtpZihhLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxEbyxuKTt2YXIgcj1uZXcgTW8oRG8sdC5zaGFwZSxlLnNoYXBlKSxvPXRoaXMubWFrZU91dHB1dEFycmF5KHIub3V0cHV0U2hhcGUsbik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdLG8pfSx0LnByb3RvdHlwZS5wYWNrZWRCaW5hcnlPcD1mdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PW8mJihvPSExKTt2YXIgYT1uZXcgRm8obix0LnNoYXBlLGUuc2hhcGUsbyksaT10aGlzLm1ha2VQYWNrZWRUZW5zb3IoYS5vdXRwdXRTaGFwZSxyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGEsW3QsZV0saSl9LHQucHJvdG90eXBlLmNvbXBsZXhTZXBhcmFibGVCaW5hcnlPcD1mdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcyxvPXRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLGE9dGhpcy50ZXhEYXRhLmdldChlLmRhdGFJZCksaT1bW28uY29tcGxleFRlbnNvcnMucmVhbCxhLmNvbXBsZXhUZW5zb3JzLnJlYWxdLFtvLmNvbXBsZXhUZW5zb3JzLmltYWcsYS5jb21wbGV4VGVuc29ycy5pbWFnXV0ubWFwKGZ1bmN0aW9uKG8pe3ZhciBhPW9bMF0saT1vWzFdLHM9ci5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckhhbmRsZSh0LGEpLHU9ci5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckhhbmRsZShlLGkpLGw9bmV3IE1vKG4sdC5zaGFwZSxlLnNoYXBlKSxjPXIubWFrZU91dHB1dEFycmF5KGwub3V0cHV0U2hhcGUsQ3QoYS5kdHlwZSxpLmR0eXBlKSk7cmV0dXJuIHIuY29tcGlsZUFuZFJ1bihsLFtzLHVdLGMpfSkscz1pWzBdLHU9aVsxXSxsPXRoaXMuY29tcGxleChzLHUpO3JldHVybiBzLmRpc3Bvc2UoKSx1LmRpc3Bvc2UoKSxsfSx0LnByb3RvdHlwZS5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckhhbmRsZT1mdW5jdGlvbih0LGUpe3JldHVybntkYXRhSWQ6ZS5kYXRhSWQsZHR5cGU6ZS5kdHlwZSxzaGFwZTp0LnNoYXBlfX0sdC5wcm90b3R5cGUuYWRkTj1mdW5jdGlvbih0KXtpZigxPT09dC5sZW5ndGgpcmV0dXJuIHRbMF07aWYodC5sZW5ndGg+YS5nZXQoXCJXRUJHTF9NQVhfVEVYVFVSRVNfSU5fU0hBREVSXCIpKXt2YXIgZT1NYXRoLmZsb29yKHQubGVuZ3RoLzIpLG49dGhpcy5hZGROKHQuc2xpY2UoMCxlKSkscj10aGlzLmFkZE4odC5zbGljZShlKSk7cmV0dXJuIHRoaXMuYWRkTihbbixyXSl9dmFyIG89dC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuZHR5cGV9KS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gQ3QodCxlKX0pLGk9dC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSxzPWEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIiksdT1zP25ldyBlbyh0WzBdLnNoYXBlLGkpOm5ldyB0byh0WzBdLnNoYXBlLGkpLGw9cz90aGlzLm1ha2VQYWNrZWRUZW5zb3IodS5vdXRwdXRTaGFwZSxvKTp0aGlzLm1ha2VPdXRwdXRBcnJheSh1Lm91dHB1dFNoYXBlLG8pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odSx0LGwpfSx0LnByb3RvdHlwZS5zdWJ0cmFjdD1mdW5jdGlvbih0LGUpe2lmKFwiY29tcGxleDY0XCI9PT10LmR0eXBlJiZcImNvbXBsZXg2NFwiPT09ZS5kdHlwZSlyZXR1cm4gdGhpcy5jb21wbGV4U2VwYXJhYmxlQmluYXJ5T3AodCxlLE9vKTtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdCxlXSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5zdWJ0cmFjdCh0LGUpO3ZhciBuPUN0KHQuZHR5cGUsZS5kdHlwZSk7aWYoYS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsT28sdC5kdHlwZSk7dmFyIHI9bmV3IE1vKE9vLHQuc2hhcGUsZS5zaGFwZSksbz10aGlzLm1ha2VPdXRwdXRBcnJheShyLm91dHB1dFNoYXBlLG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSxvKX0sdC5wcm90b3R5cGUucG93PWZ1bmN0aW9uKHQsZSl7dmFyIG49YS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSxyPW4/bmV3IEZvKFwiXFxuICAvLyBpc01vZFJvdW5kMSBoYXMgMSBmb3IgY29tcG9uZW50cyB3aXRoIHJvdW5kKG1vZChiLCAyLjApKSA9PSAxLCAwIG90aGVyd2lzZS5cXG4gIHZlYzQgaXNNb2RSb3VuZDEgPSB2ZWM0KGVxdWFsKHJvdW5kKG1vZChiLCAyLjApKSwgaXZlYzQoMSkpKTtcXG4gIHZlYzQgbXVsdGlwbGllciA9IHNpZ24oYSkgKiBpc01vZFJvdW5kMSArICh2ZWM0KDEuMCkgLSBpc01vZFJvdW5kMSk7XFxuICB2ZWM0IHJlc3VsdCA9IG11bHRpcGxpZXIgKiBwb3coYWJzKGEpLCBiKTtcXG5cXG4gIHZlYzQgaXNOYU4gPSB2ZWM0KGxlc3NUaGFuKGEsIHZlYzQoMC4wKSkpICogdmVjNChsZXNzVGhhbihmbG9vcihiKSwgYikpO1xcbiAgXFxuICByZXN1bHQuciA9IGlzTmFOLnIgPiAwLiA/IE5BTiA6IHJlc3VsdC5yO1xcbiAgcmVzdWx0LmcgPSBpc05hTi5nID4gMC4gPyBOQU4gOiByZXN1bHQuZztcXG4gIHJlc3VsdC5iID0gaXNOYU4uYiA+IDAuID8gTkFOIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzTmFOLmEgPiAwLiA/IE5BTiA6IHJlc3VsdC5hO1xcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIix0LnNoYXBlLGUuc2hhcGUpOm5ldyBNbyhcIlxcbmlmKGEgPCAwLjAgJiYgZmxvb3IoYikgPCBiKXtcXG4gIHJldHVybiBOQU47XFxufVxcbnJldHVybiAocm91bmQobW9kKGIsIDIuMCkpICE9IDEpID9cXG4gICAgcG93KGFicyhhKSwgYikgOiBzaWduKGEpICogcG93KGFicyhhKSwgYik7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKSxvPUN0KHQuZHR5cGUsZS5kdHlwZSksaT1uP3RoaXMubWFrZVBhY2tlZFRlbnNvcihyLm91dHB1dFNoYXBlLG8pOnRoaXMubWFrZU91dHB1dEFycmF5KHIub3V0cHV0U2hhcGUsbyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdLGkpfSx0LnByb3RvdHlwZS5jZWlsPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwicmV0dXJuIGNlaWwoeCk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5mbG9vcj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcInJldHVybiBmbG9vcih4KTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLnNpZ249ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJcXG4gIGlmIChpc25hbih4KSkgeyByZXR1cm4gMC4wOyB9XFxuICByZXR1cm4gc2lnbih4KTtcXG5cIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLmlzTmFOPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwicmV0dXJuIGZsb2F0KGlzbmFuKHgpKTtcIiksbj10aGlzLm1ha2VPdXRwdXRBcnJheShlLm91dHB1dFNoYXBlLFwiYm9vbFwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdLG4pfSx0LnByb3RvdHlwZS5pc0luZj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcInJldHVybiBmbG9hdChpc2luZih4KSk7XCIpLG49dGhpcy5tYWtlT3V0cHV0QXJyYXkoZS5vdXRwdXRTaGFwZSxcImJvb2xcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSxuKX0sdC5wcm90b3R5cGUuaXNGaW5pdGU9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJyZXR1cm4gZmxvYXQoIWlzbmFuKHgpICYmICFpc2luZih4KSk7XCIpLG49dGhpcy5tYWtlT3V0cHV0QXJyYXkoZS5vdXRwdXRTaGFwZSxcImJvb2xcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSxuKX0sdC5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJcXG4gIC8vIE9wZW5HTCBFUyBkb2VzIG5vdCBzdXBwb3J0IHJvdW5kIGZ1bmN0aW9uLlxcbiAgLy8gVGhlIGFsZ29yaXRobSBpcyBiYXNlZCBvbiBiYW5rZXIncyByb3VuZGluZy5cXG4gIGZsb2F0IGJhc2UgPSBmbG9vcih4KTtcXG4gIGlmICgoeCAtIGJhc2UpIDwgMC41KSB7XFxuICAgIHJldHVybiBmbG9vcih4KTtcXG4gIH0gZWxzZSBpZiAoKHggLSBiYXNlKSA+IDAuNSkge1xcbiAgICByZXR1cm4gY2VpbCh4KTtcXG4gIH0gZWxzZSB7XFxuICAgIGlmIChtb2QoYmFzZSwgMi4wKSA9PSAwLjApIHtcXG4gICAgICByZXR1cm4gYmFzZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4gYmFzZSArIDEuMDtcXG4gICAgfVxcbiAgfVxcblwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuZXhwPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBlPWEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIik/bmV3IEJpKHQuc2hhcGUsSWkpOm5ldyBFaSh0LnNoYXBlLElpKSx0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5leHBtMT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcInJldHVybiBleHAoeCkgLSAxLjA7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIGU9YS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKT9uZXcgQmkodC5zaGFwZSxcIlxcbiAgdmVjNCByZXN1bHQgPSBsb2coeCk7XFxuICB2ZWM0IGlzTmFOID0gdmVjNChsZXNzVGhhbih4LCB2ZWM0KDAuMCkpKTtcXG4gIHJlc3VsdC5yID0gaXNOYU4uciA9PSAxLjAgPyBOQU4gOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA9PSAxLjAgPyBOQU4gOiByZXN1bHQuZztcXG4gIHJlc3VsdC5iID0gaXNOYU4uYiA9PSAxLjAgPyBOQU4gOiByZXN1bHQuYjtcXG4gIHJlc3VsdC5hID0gaXNOYU4uYSA9PSAxLjAgPyBOQU4gOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIpOm5ldyBFaSh0LnNoYXBlLFwiaWYgKHggPCAwLjApIHJldHVybiBOQU47XFxuICByZXR1cm4gbG9nKHgpO1wiKSx0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5sb2cxcD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcInJldHVybiBsb2coMS4wICsgeCk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5zcXJ0PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwicmV0dXJuIHNxcnQoeCk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5yc3FydD1mdW5jdGlvbih0KXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQucnNxcnQodCk7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJyZXR1cm4gaW52ZXJzZXNxcnQoeCk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5zcXVhcmU9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJyZXR1cm4geCAqIHg7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5yZWNpcHJvY2FsPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwicmV0dXJuIDEuMCAvIHg7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5yZWx1PWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBlPWEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIik/bmV3IEJpKHQuc2hhcGUsRmkpOm5ldyBFaSh0LnNoYXBlLE5pKSx0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5wcmVsdT1mdW5jdGlvbih0LGUpe3ZhciBuPWEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIik/bmV3IEZvKFwiXFxuICB2ZWM0IGFMZXNzVGhhblplcm8gPSB2ZWM0KGxlc3NUaGFuKGEsIHZlYzQoMC4pKSk7XFxuICByZXR1cm4gKGFMZXNzVGhhblplcm8gKiAoYiAqIGEpKSArICgodmVjNCgxLjApIC0gYUxlc3NUaGFuWmVybykgKiBhKTtcXG5cIix0LnNoYXBlLGUuc2hhcGUpOm5ldyBNbyhcInJldHVybiAoYSA8IDAuKSA/IGIgKiBhIDogYTtcIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSl9LHQucHJvdG90eXBlLmVsdT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcInJldHVybiAoeCA+PSAwLjApID8geCA6IChleHAoeCkgLSAxLjApO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuZWx1RGVyPWZ1bmN0aW9uKHQsZSl7dmFyIG49YS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKT9uZXcgRm8oXCJcXG4gIHZlYzQgYkdURVplcm8gPSB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoYiwgdmVjNCgwLikpKTtcXG4gIHJldHVybiAoYkdURVplcm8gKiBhKSArICgodmVjNCgxLjApIC0gYkdURVplcm8pICogKGEgKiAoYiArIHZlYzQoMS4wKSkpKTtcXG5cIix0LnNoYXBlLGUuc2hhcGUpOm5ldyBNbyhcInJldHVybiAoYiA+PSAxLjApID8gYSA6IGEgKiAoYiArIDEuMCk7XCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0pfSx0LnByb3RvdHlwZS5zZWx1PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLGtpKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuaW50PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwicmV0dXJuIGZsb2F0KGludCh4KSk7XCIpLG49dGhpcy5tYWtlT3V0cHV0QXJyYXkoZS5vdXRwdXRTaGFwZSxcImludDMyXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0sbil9LHQucHJvdG90eXBlLmNsaXA9ZnVuY3Rpb24odCxlLG4pe3ZhciByLG89KHI9YS5nZXRCb29sKFwiV0VCR0xfUEFDS19DTElQXCIpP25ldyBQbyh0LnNoYXBlKTpuZXcgQm8odC5zaGFwZSkpLmdldEN1c3RvbVNldHVwRnVuYyhlLG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdF0sbnVsbCxvKX0sdC5wcm90b3R5cGUuYWJzPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwicmV0dXJuIGFicyh4KTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLmNvbXBsZXhBYnM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCksbj1uZXcgTG8odC5zaGFwZSkscj1bdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckhhbmRsZSh0LGUuY29tcGxleFRlbnNvcnMucmVhbCksdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckhhbmRsZSh0LGUuY29tcGxleFRlbnNvcnMuaW1hZyldO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixyKX0sdC5wcm90b3R5cGUuc2lnbW9pZD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcInJldHVybiAxLjAgLyAoMS4wICsgZXhwKC0xLjAgKiB4KSk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5zb2Z0cGx1cz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcIlxcbiAgZmxvYXQgZXBzaWxvbiA9IDEuMTkyMDkyODk1NTA3ODEyNWUtNztcXG4gIGZsb2F0IHRocmVzaG9sZCA9IGxvZyhlcHNpbG9uKSArIDIuMDtcXG5cXG4gIGJvb2wgdG9vX2xhcmdlID0geCA+IC10aHJlc2hvbGQ7XFxuICBib29sIHRvb19zbWFsbCA9IHggPCB0aHJlc2hvbGQ7XFxuXFxuICBmbG9hdCByZXN1bHQ7XFxuICBmbG9hdCBleHBfeCA9IGV4cCh4KTtcXG5cXG4gIGlmICh0b29fbGFyZ2Upe1xcbiAgICByZXN1bHQgPSB4O1xcbiAgfVxcbiAgZWxzZSBpZiAodG9vX3NtYWxsKXtcXG4gICAgcmVzdWx0ID0gZXhwX3g7XFxuICB9XFxuICBlbHNle1xcbiAgICByZXN1bHQgPSBsb2coZXhwX3ggKyAxLjApO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLnNpbj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxBaSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLmNvcz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxUaSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLnRhbj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcInJldHVybiB0YW4oeCk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5hc2luPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwicmV0dXJuIGFzaW4oeCk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5hY29zPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwicmV0dXJuIGFjb3MoeCk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5hdGFuPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLERpKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuYXRhbjI9ZnVuY3Rpb24odCxlKXt2YXIgbj1hLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpP25ldyBGbyhcIlxcbiAgdmVjNCByZXN1bHQgPSBhdGFuKGEsIGIpO1xcbiAgdmVjNCBpc05hTiA9IG1pbih2ZWM0KGlzbmFuKGEpKSArIHZlYzQoaXNuYW4oYikpLCB2ZWM0KDEuMCkpO1xcbiAgXFxuICByZXN1bHQuciA9IGlzTmFOLnIgPiAwLiA/IE5BTiA6IHJlc3VsdC5yO1xcbiAgcmVzdWx0LmcgPSBpc05hTi5nID4gMC4gPyBOQU4gOiByZXN1bHQuZztcXG4gIHJlc3VsdC5iID0gaXNOYU4uYiA+IDAuID8gTkFOIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzTmFOLmEgPiAwLiA/IE5BTiA6IHJlc3VsdC5hO1xcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIix0LnNoYXBlLGUuc2hhcGUpOm5ldyBNbyhcIlxcbiAgaWYgKGlzbmFuKGEpKSByZXR1cm4gYTtcXG4gIGlmIChpc25hbihiKSkgcmV0dXJuIGI7XFxuXFxuICByZXR1cm4gYXRhbihhLCBiKTtcXG5cIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSl9LHQucHJvdG90eXBlLnNpbmg9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJcXG4gIGZsb2F0IGUyeCA9IGV4cCh4KTtcXG4gIHJldHVybiAoZTJ4IC0gMS4wIC8gZTJ4KSAvIDIuMDtcXG5cIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLmNvc2g9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJcXG4gIGZsb2F0IGUyeCA9IGV4cCgteCk7XFxuICByZXR1cm4gKGUyeCArIDEuMCAvIGUyeCkgLyAyLjA7XFxuXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS50YW5oPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwiXFxuICBmbG9hdCBlMnggPSBleHAoLTIuMCAqIGFicyh4KSk7XFxuICByZXR1cm4gc2lnbih4KSAqICgxLjAgLSBlMngpIC8gKDEuMCArIGUyeCk7XFxuXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5hc2luaD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcInJldHVybiBsb2coeCArIHNxcnQoeCAqIHggKyAxLjApKTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLmFjb3NoPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLE9pKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuYXRhbmg9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsX2kpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5lcmY9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsJ1xcbiAgLy8gRXJyb3IgZnVuY3Rpb24gaXMgY2FsY3VsYXRlZCBhcHByb3hpbWF0ZWx5IHdpdGggZWxlbWVudGFyeSBmdW5jdGlvbi5cXG4gIC8vIFNlZSBcIkhhbmRib29rIG9mIE1hdGhlbWF0aWNhbCBGdW5jdGlvbnMgd2l0aCBGb3JtdWxhcyxcXG4gIC8vIEdyYXBocywgYW5kIE1hdGhlbWF0aWNhbCBUYWJsZXNcIiwgQWJyYW1vd2l0eiBhbmQgU3RlZ3VuLlxcbiAgZmxvYXQgcCA9IDAuMzI3NTkxMTtcXG4gIGZsb2F0IGExID0gMC4yNTQ4Mjk1OTI7XFxuICBmbG9hdCBhMiA9IC0wLjI4NDQ5NjczNjtcXG4gIGZsb2F0IGEzID0gMS40MjE0MTM3NDE7XFxuICBmbG9hdCBhNCA9IC0xLjQ1MzE1MjAyNztcXG4gIGZsb2F0IGE1ID0gMS4wNjE0MDU0Mjk7XFxuXFxuICBmbG9hdCB0ID0gMS4wIC8gKDEuMCArIHAgKiB4KTtcXG4gIHJldHVybiAxLjAgLSAoKCgoKGE1KnQgKyBhNCkqdCkgKyBhMykqdCArIGEyKSp0ICsgYTEpKnQqZXhwKC14KngpO1xcbicpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5zdGVwPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IEVpKHQuc2hhcGUsZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLFJpK1wiXFxuICAgIHJldHVybiB4ID4gMC4wID8gMS4wIDogZmxvYXQoXCIrdCtcIik7XFxuICBcIn0oZSkpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdF0pfSx0LnByb3RvdHlwZS5jb252MmRCeU1hdE11bD1mdW5jdGlvbih0LGUsbil7dmFyIHI9dC5zaGFwZSxvPXRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLGk9bi5pbkNoYW5uZWxzLHM9clswXSpyWzFdKnJbMl0sdT1uLm91dENoYW5uZWxzLGw9KDE9PT1zfHwxPT09dSkmJmk+MWUzLGM9clsyXSUyIT0wJiYhIW8uaXNQYWNrZWQ7aWYobHx8IWEuZ2V0Qm9vbChcIldFQkdMX0xBWklMWV9VTlBBQ0tcIil8fCFhLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpfHwhYyl7dmFyIGg9dGhpcy5yZXNoYXBlKHQsWzEsclswXSpyWzFdKnJbMl0sbi5pbkNoYW5uZWxzXSkscD10aGlzLnJlc2hhcGUoZSxbMSxuLmluQ2hhbm5lbHMsbi5vdXRDaGFubmVsc10pO3JldHVybiB0aGlzLnJlc2hhcGUodGhpcy5iYXRjaE1hdE11bChoLHAsITEsITEpLG4ub3V0U2hhcGUpfXZhciBmPWZ0Lm1ha2UoWzEsclswXSpyWzFdKihyWzJdKzEpLG4uaW5DaGFubmVsc10se2RhdGFJZDp0LmRhdGFJZH0sdC5kdHlwZSx0aGlzKSx2PW8uc2hhcGU7by5zaGFwZT1vLnNoYXBlLnNsaWNlKCksby5zaGFwZVtvLnNoYXBlLmxlbmd0aC0yXSsrLGQoZ2Uoby5zaGFwZSxmLnNoYXBlKSxmdW5jdGlvbigpe3JldHVyblwicGFja2VkIHJlc2hhcGUgXCIrby5zaGFwZStcIiB0byBcIitmLnNoYXBlK1wiIGlzbid0IGZyZWVcIn0pO3ZhciBtPXRoaXMucmVzaGFwZShlLFsxLG4uaW5DaGFubmVscyxuLm91dENoYW5uZWxzXSksZz10aGlzLmJhdGNoTWF0TXVsKGYsbSwhMSwhMSkseT10aGlzLnRleERhdGEuZ2V0KGcuZGF0YUlkKTtyZXR1cm4gZCh5LmlzUGFja2VkLGZ1bmN0aW9uKCl7cmV0dXJuXCJiYXRjaE1hdE11bCByZXN1bHQgaXMgZXhwZWN0ZWQgdG8gYmUgcGFja2VkXCJ9KSxvLnNoYXBlPXYseS5zaGFwZT1uLm91dFNoYXBlLGZ0Lm1ha2Uobi5vdXRTaGFwZSx7ZGF0YUlkOmcuZGF0YUlkfSxnLmR0eXBlLHRoaXMpfSx0LnByb3RvdHlwZS5jb252MmRXaXRoSW0yUm93PWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uLmZpbHRlcldpZHRoLG89bi5maWx0ZXJIZWlnaHQsYT1uLmluQ2hhbm5lbHMsaT1uLm91dFdpZHRoLHM9bi5vdXRIZWlnaHQsdT1yKm8qYSxsPXMqaSxjPVt1LGxdLGg9dC5zcXVlZXplKFswXSkscD1lLnJlc2hhcGUoWzEsdSwtMV0pLGY9bmV3IHphKGMsaC5zaGFwZSxuKSxkPXRoaXMuY29tcGlsZUFuZFJ1bihmLFtoXSkucmVzaGFwZShbMSxjWzBdLGNbMV1dKSx2PW5ldyAkYShkLnNoYXBlLFsxLGwsbi5vdXRDaGFubmVsc10sITAsITEpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odixbZCxwXSkucmVzaGFwZShbMSxzLGksbi5vdXRDaGFubmVsc10pfSx0LnByb3RvdHlwZS5jb252MmQ9ZnVuY3Rpb24odCxlLG4pe2lmKDE9PT1uLmZpbHRlckhlaWdodCYmMT09PW4uZmlsdGVyV2lkdGgmJjE9PT1uLmRpbGF0aW9uSGVpZ2h0JiYxPT09bi5kaWxhdGlvbldpZHRoJiYxPT09bi5zdHJpZGVIZWlnaHQmJjE9PT1uLnN0cmlkZVdpZHRoJiYoXCJTQU1FXCI9PT1uLnBhZEluZm8udHlwZXx8XCJWQUxJRFwiPT09bi5wYWRJbmZvLnR5cGUpKXJldHVybiB0aGlzLmNvbnYyZEJ5TWF0TXVsKHQsZSxuKTtpZihhLmdldEJvb2woXCJXRUJHTF9DT05WX0lNMkNPTFwiKSYmMT09PXQuc2hhcGVbMF0pcmV0dXJuIHRoaXMuY29udjJkV2l0aEltMlJvdyh0LGUsbik7dmFyIHI9bmV3IGpvKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSl9LHQucHJvdG90eXBlLmNvbnYyZERlcklucHV0PWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgVm8obik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKX0sdC5wcm90b3R5cGUuY29udjJkRGVyRmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgem8obik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKX0sdC5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJEPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcjtyZXR1cm4gYS5nZXRCb29sKFwiV0VCR0xfUEFDS19ERVBUSFdJU0VDT05WXCIpJiZuLnN0cmlkZVdpZHRoPD0yJiZuLm91dENoYW5uZWxzL24uaW5DaGFubmVscz09MT8ocj1uZXcgWW8obiksdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0sdGhpcy5tYWtlUGFja2VkVGVuc29yKG4ub3V0U2hhcGUsdC5kdHlwZSkpKToocj1uZXcgWG8obiksdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pKX0sdC5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJERGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyAkbyhuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSx0LnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkREZXJGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBIbyhuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSx0LnByb3RvdHlwZS5jb252M2Q9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBLbyhuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSx0LnByb3RvdHlwZS5jb252M2REZXJJbnB1dD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IHFvKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSl9LHQucHJvdG90eXBlLmNvbnYzZERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IEdvKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSl9LHQucHJvdG90eXBlLm1heFBvb2w9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgSmEoZSxcIm1heFwiLCExKSxyPXRoaXMubWFrZU91dHB1dEFycmF5KG4ub3V0cHV0U2hhcGUsdC5kdHlwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0XSxyKX0sdC5wcm90b3R5cGUuYXZnUG9vbD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBKYShlLFwiYXZnXCIsITEpLHI9dGhpcy5tYWtlT3V0cHV0QXJyYXkobi5vdXRwdXRTaGFwZSxcImZsb2F0MzJcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0XSxyKX0sdC5wcm90b3R5cGUubWF4UG9vbEJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPW5ldyBKYShyLFwibWF4XCIsITApLGE9dGhpcy5jb21waWxlQW5kUnVuKG8sW2VdKSxpPW5ldyBIYShyKSxzPXRoaXMubWFrZU91dHB1dEFycmF5KGkub3V0cHV0U2hhcGUsZS5kdHlwZSksdT10aGlzLmNvbXBpbGVBbmRSdW4oaSxbdCxhXSxzKTtyZXR1cm4gYS5kaXNwb3NlKCksdX0sdC5wcm90b3R5cGUuYXZnUG9vbEJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgU28obiksbz10aGlzLm1ha2VPdXRwdXRBcnJheShyLm91dHB1dFNoYXBlLGUuZHR5cGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdF0sbyl9LHQucHJvdG90eXBlLmNhc3Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gSm4odCxlLHRoaXMpfSx0LnByb3RvdHlwZS51bnN0YWNrPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuc2hhcGVbZV0scj1uZXcgQXJyYXkodC5yYW5rLTEpLG89MCxhPTA7YTx0LnJhbms7YSsrKWEhPT1lJiYocltvKytdPXQuc2hhcGVbYV0pO3ZhciBpPW5ldyBBcnJheSh0LnJhbmspLmZpbGwoMCkscz10LnNoYXBlLnNsaWNlKCk7c1tlXT0xO3ZhciB1PW5ldyBBcnJheShuKTtmb3IoYT0wO2E8dS5sZW5ndGg7YSsrKWlbZV09YSx1W2FdPXRoaXMuc2xpY2UodCxpLHMpLnJlc2hhcGUocik7cmV0dXJuIHV9LHQucHJvdG90eXBlLnJlc2hhcGU9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKTtyZXR1cm4hbi5pc1BhY2tlZHx8Z2UodC5zaGFwZSxlKXx8bnVsbCE9PW4udGV4dHVyZSYmZ2Uobi5zaGFwZSxlKT9abih0LGUpOnRoaXMucGFja2VkUmVzaGFwZSh0LGUpfSx0LnByb3RvdHlwZS5yZXNpemVCaWxpbmVhcj1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1hLmdldEJvb2woXCJXRUJHTF9QQUNLX0lNQUdFX09QRVJBVElPTlNcIik/bmV3IHJpKHQuc2hhcGUsZSxuLHIpOm5ldyBuaSh0LnNoYXBlLGUsbixyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG8sW3RdKX0sdC5wcm90b3R5cGUucmVzaXplQmlsaW5lYXJCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IGVpKHQsZSxuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3RdKX0sdC5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPW5ldyBhaSh0LnNoYXBlLGUsbixyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG8sW3RdKX0sdC5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBvaSh0LGUsbik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0XSl9LHQucHJvdG90eXBlLm11bHRpbm9taWFsPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPWU/dDpUbih0KSxhPW8uc2hhcGVbMF0saT1vLnNoYXBlWzFdLHM9bmV3IGphKGEsaSxuKSx1PXRoaXMubWFrZU91dHB1dEFycmF5KHMub3V0cHV0U2hhcGUsXCJpbnQzMlwiKSxsPXMuZ2V0Q3VzdG9tU2V0dXBGdW5jKHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocyxbb10sdSxsKX0sdC5wcm90b3R5cGUub25lSG90PWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPW5ldyBLYSh0LnNpemUsZSxuLHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obyxbdF0pfSx0LnByb3RvdHlwZS5ub25NYXhTdXBwcmVzc2lvbj1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiBqZShcInRmLm5vbk1heFN1cHByZXNzaW9uKCkgaW4gd2ViZ2wgbG9ja3MgdGhlIFVJIHRocmVhZC4gQ2FsbCB0Zi5ub25NYXhTdXBwcmVzc2lvbkFzeW5jKCkgaW5zdGVhZFwiKSxhcih0LmRhdGFTeW5jKCksZS5kYXRhU3luYygpLG4scixvKX0sdC5wcm90b3R5cGUuY3JvcEFuZFJlc2l6ZT1mdW5jdGlvbih0LGUsbixyLG8sYSl7dmFyIGk9bmV3IFFvKHQuc2hhcGUsZS5zaGFwZSxyLG8sYSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihpLFt0LGUsbl0pfSx0LnByb3RvdHlwZS5kZXB0aFRvU3BhY2U9ZnVuY3Rpb24odCxlLG4pe2QoZT4xLGZ1bmN0aW9uKCl7cmV0dXJuXCJibG9ja1NpemUgc2hvdWxkIGJlID4gMSBmb3IgZGVwdGhUb1NwYWNlLCBidXQgd2FzOiBcIitlfSk7dmFyIHI9dC5zaGFwZVswXSxvPVwiTkhXQ1wiPT09bj90LnNoYXBlWzFdOnQuc2hhcGVbMl0sYT1cIk5IV0NcIj09PW4/dC5zaGFwZVsyXTp0LnNoYXBlWzNdLGk9XCJOSFdDXCI9PT1uP3Quc2hhcGVbM106dC5zaGFwZVsxXSxzPW8qZSx1PWEqZSxsPWkvKGUqZSksYz1uZXcgdGEoXCJOSFdDXCI9PT1uP1tyLHMsdSxsXTpbcixsLHMsdV0sZSxuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGMsW3RdKX0sdC5wcm90b3R5cGUuc3BsaXQ9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBzcih0LGUsbil9LHQucHJvdG90eXBlLnNjYXR0ZXJORD1mdW5jdGlvbih0LGUsbil7dmFyIHI9cG4oMCx0LG4pLG89ci5zbGljZVJhbmssYT1yLm51bVVwZGF0ZXMsaT1yLnNsaWNlU2l6ZSxzPXIuc3RyaWRlcyx1PXIub3V0cHV0U2l6ZSxsPVt1L2ksaV0sYz10LnJlc2hhcGUoW2Esb10pLGg9ZS5yZXNoYXBlKFthLGldKTtpZigwPT09dSlyZXR1cm4gWm4oRm4oW10pLG4pO3ZhciBwPUJuKDApLGY9bmV3IHVpKGEsbyxjLnJhbmssaC5yYW5rLHMsbCk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihmLFtoLGMscF0pLnJlc2hhcGUobil9LHQucHJvdG90eXBlLnNwYXJzZVRvRGVuc2U9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89cG4oMCx0LG4pLGE9by5zbGljZVJhbmssaT1vLm51bVVwZGF0ZXMscz1vLnN0cmlkZXMsdT1vLm91dHB1dFNpemUsbD1uZXcgdWkoaSxhLHQucmFuayxlLnJhbmsscyxbdSwxXSwhMSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihsLFtlLHQscl0pLnJlc2hhcGUobil9LHQucHJvdG90eXBlLmZmdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5mZnRJbXBsKHQsITEpfSx0LnByb3RvdHlwZS5pZmZ0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmZmdEltcGwodCwhMCl9LHQucHJvdG90eXBlLmZmdEltcGw9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKSxyPW5ldyBvYShuYSx0LnNoYXBlLGUpLG89bmV3IG9hKHJhLHQuc2hhcGUsZSksYT1bdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckhhbmRsZSh0LG4uY29tcGxleFRlbnNvcnMucmVhbCksdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckhhbmRsZSh0LG4uY29tcGxleFRlbnNvcnMuaW1hZyldLGk9dGhpcy5jb21waWxlQW5kUnVuKHIsYSkscz10aGlzLmNvbXBpbGVBbmRSdW4obyxhKSx1PXRoaXMuY29tcGxleChpLHMpLmFzMkQodC5zaGFwZVswXSx0LnNoYXBlWzFdKTtyZXR1cm4gaS5kaXNwb3NlKCkscy5kaXNwb3NlKCksdX0sdC5wcm90b3R5cGUuZ2F0aGVyTkQ9ZnVuY3Rpb24odCxlKXt2YXIgbj1lLnNoYXBlLHI9bltuLmxlbmd0aC0xXSxvPXVuKHQsZSksYT1vWzBdLGk9b1sxXSxzPW9bMl0sdT1vWzNdLGw9ZS5yZXNoYXBlKFtpLHJdKSxjPXQucmVzaGFwZShbdC5zaXplL3Msc10pLGg9bmV3IGNhKHIsdSxbaSxzXSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihoLFtjLGxdKS5yZXNoYXBlKGEpfSx0LnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uKHQsZSxuKXtpZihcInN0cmluZ1wiPT09KG49bnx8VyhlKSkpe3ZhciByPUEobix5KHQpKTtyZXR1cm4gci5maWxsKGUpLGZ0Lm1ha2UodCx7dmFsdWVzOnJ9LG4pfXZhciBvPW5ldyBhYSh0LGUpLGE9by5nZXRDdXN0b21TZXR1cEZ1bmMoZSksaT10aGlzLm1ha2VPdXRwdXRBcnJheSh0LG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obyxbXSxpLGEpfSx0LnByb3RvdHlwZS5vbmVzTGlrZT1mdW5jdGlvbih0KXtpZihcInN0cmluZ1wiPT09dC5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJvbmVzTGlrZSBpcyBub3Qgc3VwcG9ydGVkIHVuZGVyIHN0cmluZyBkdHlwZVwiKTtyZXR1cm4gdGhpcy5maWxsKHQuc2hhcGUsMSx0LmR0eXBlKX0sdC5wcm90b3R5cGUuemVyb3NMaWtlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmZpbGwodC5zaGFwZSxcInN0cmluZ1wiPT09dC5kdHlwZT9cIlwiOjAsdC5kdHlwZSl9LHQucHJvdG90eXBlLmxpbnNwYWNlPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdHIodCxlLG4pfSx0LnByb3RvdHlwZS5tYWtlT3V0cHV0QXJyYXk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZnQubWFrZSh0LHt9LGUsdGhpcyl9LHQucHJvdG90eXBlLm1ha2VQYWNrZWRUZW5zb3I9ZnVuY3Rpb24odCxlKXt2YXIgbj1mdC5tYWtlKHQse30sZSx0aGlzKTtyZXR1cm4gdGhpcy50ZXhEYXRhLmdldChuLmRhdGFJZCkuaXNQYWNrZWQ9ITAsbn0sdC5wcm90b3R5cGUudW5wYWNrVGVuc29yPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBQaSh0LnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdLGZ0Lm1ha2UoZS5vdXRwdXRTaGFwZSx7fSx0LmR0eXBlLHRoaXMpKX0sdC5wcm90b3R5cGUucGFja1RlbnNvcj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgWGEodC5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSx0aGlzLm1ha2VQYWNrZWRUZW5zb3IodC5zaGFwZSx0LmR0eXBlKSl9LHQucHJvdG90eXBlLnBhY2tlZFJlc2hhcGU9ZnVuY3Rpb24odCxlKXt2YXIgbj10LnJlc2hhcGUoW2ZlKHQuc2hhcGUpXS5jb25jYXQoZGUodC5zaGFwZSkpKSxyPVtmZShlKV0uY29uY2F0KGRlKGUpKSxvPW5ldyB0aShyLG4uc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obyxbbl0pLnJlc2hhcGUoZSl9LHQucHJvdG90eXBlLmNvbXBpbGVBbmRSdW49ZnVuY3Rpb24odCxlLG4scil7dmFyIG89dGhpcztpZihudWxsPT1uJiYobj10LnVzZXNQYWNrZWRUZXh0dXJlcz90aGlzLm1ha2VQYWNrZWRUZW5zb3IodC5vdXRwdXRTaGFwZSxlWzBdLmR0eXBlKTp0aGlzLm1ha2VPdXRwdXRBcnJheSh0Lm91dHB1dFNoYXBlLGVbMF0uZHR5cGUpKSwwPT09bi5zaXplKXJldHVybiB0aGlzLnRleERhdGEuZ2V0KG4uZGF0YUlkKS52YWx1ZXM9SShuLmR0eXBlLDApLG47dmFyIGk9ZS5tYXAoZnVuY3Rpb24oZSl7aWYoXCJjb21wbGV4NjRcIj09PWUuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiR1BHUFVQcm9ncmFtIGRvZXMgbm90IHN1cHBvcnQgY29tcGxleDY0IGlucHV0LiBGb3IgY29tcGxleDY0IGR0eXBlcywgcGxlYXNlIHNlcGFyYXRlIHRoZSBwcm9ncmFtIGludG8gcmVhbCBhbmQgaW1hZ2luYXJ5IHBhcnRzLlwiKTt2YXIgbj1vLnRleERhdGEuZ2V0KGUuZGF0YUlkKTtpZihudWxsPT1uLnRleHR1cmUpe2lmKCF0LnVzZXNQYWNrZWRUZXh0dXJlcyYmeShlLnNoYXBlKTw9YS5nZXROdW1iZXIoXCJXRUJHTF9TSVpFX1VQTE9BRF9VTklGT1JNXCIpKXJldHVybntzaGFwZTplLnNoYXBlLHRleERhdGE6bnVsbCxpc1VuaWZvcm06ITAsdW5pZm9ybVZhbHVlczpuLnZhbHVlc307dC51c2VzUGFja2VkVGV4dHVyZXMmJihuLmlzUGFja2VkPSEwLG4uc2hhcGU9ZS5zaGFwZSl9ZWxzZSBpZighIW4uaXNQYWNrZWQhPSEhdC51c2VzUGFja2VkVGV4dHVyZXMpZT1uLmlzUGFja2VkP28udW5wYWNrVGVuc29yKGUpOm8ucGFja1RlbnNvcihlKSxuPW8udGV4RGF0YS5nZXQoZS5kYXRhSWQpO2Vsc2UgaWYobi5pc1BhY2tlZCYmIWdlKG4uc2hhcGUsZS5zaGFwZSkpe3ZhciByPWUsaT1lLnNoYXBlO2Uuc2hhcGU9bi5zaGFwZSxlPW8ucGFja2VkUmVzaGFwZShlLGkpLG49by50ZXhEYXRhLmdldChlLmRhdGFJZCksci5zaGFwZT1pfXJldHVybiBvLnVwbG9hZFRvR1BVKGUuZGF0YUlkKSx7c2hhcGU6ZS5zaGFwZSx0ZXhEYXRhOm4saXNVbmlmb3JtOiExfX0pO3RoaXMudXBsb2FkVG9HUFUobi5kYXRhSWQpO3ZhciBzLHU9e3NoYXBlOm4uc2hhcGUsdGV4RGF0YTp0aGlzLnRleERhdGEuZ2V0KG4uZGF0YUlkKSxpc1VuaWZvcm06ITF9LGw9ZnVuY3Rpb24odCxlLG4pe3ZhciByPVwiXCI7ZS5jb25jYXQobikuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgZT1udWxsIT10LnRleERhdGEmJm51bGwhPXQudGV4RGF0YS5zbGljZSYmdC50ZXhEYXRhLnNsaWNlLmZsYXRPZmZzZXQ+MCxuPXQuaXNVbmlmb3JtP1widW5pZm9ybVwiOnQudGV4RGF0YS50ZXhTaGFwZTtyKz10LnNoYXBlK1wiX1wiK24rXCJfXCIrZX0pO3ZhciBvPXQudXNlckNvZGUsYT10LmNvbnN0cnVjdG9yLm5hbWU7cmV0dXJuIGErPVwiX1wiK3IrXCJfXCIrb30odCxpLHUpLGM9dGhpcy5nZXRBbmRTYXZlQmluYXJ5KGwsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scil7dmFyIG89ZS51c2VyQ29kZSxpPW4ubWFwKGZ1bmN0aW9uKHQsbil7dmFyIHI9e2xvZ2ljYWxTaGFwZTp0LnNoYXBlLHRleFNoYXBlOnQuaXNVbmlmb3JtP251bGw6dC50ZXhEYXRhLnRleFNoYXBlLGlzVW5pZm9ybTp0LmlzVW5pZm9ybSxpc1BhY2tlZDohdC5pc1VuaWZvcm0mJnQudGV4RGF0YS5pc1BhY2tlZCxmbGF0T2Zmc2V0Om51bGx9O3JldHVybiBudWxsIT10LnRleERhdGEmJm51bGwhPXQudGV4RGF0YS5zbGljZSYmdC50ZXhEYXRhLnNsaWNlLmZsYXRPZmZzZXQ+MCYmKHIuZmxhdE9mZnNldD10LnRleERhdGEuc2xpY2UuZmxhdE9mZnNldCkse25hbWU6ZS52YXJpYWJsZU5hbWVzW25dLHNoYXBlSW5mbzpyfX0pLHM9aS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGVJbmZvfSksdT17bG9naWNhbFNoYXBlOnIuc2hhcGUsdGV4U2hhcGU6ci50ZXhEYXRhLnRleFNoYXBlLGlzVW5pZm9ybTohMSxpc1BhY2tlZDpyLnRleERhdGEuaXNQYWNrZWQsZmxhdE9mZnNldDpudWxsfSxsPWhvKGksdSxvLGUudXNlc1BhY2tlZFRleHR1cmVzKSxjPXQuY3JlYXRlUHJvZ3JhbShsKSxoPW51bGwscD10LmdldFVuaWZvcm1Mb2NhdGlvbihjLFwiTkFOXCIsITEpOzE9PT1hLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikmJihoPXQuZ2V0VW5pZm9ybUxvY2F0aW9uKGMsXCJJTkZJTklUWVwiLCExKSk7Zm9yKHZhciBmPXt9LGQ9MDtkPGUudmFyaWFibGVOYW1lcy5sZW5ndGg7ZCsrKXt2YXIgdj1lLnZhcmlhYmxlTmFtZXNbZF07Zlt2XT10LmdldFVuaWZvcm1Mb2NhdGlvbihjLHYsITEpLGZbXCJvZmZzZXRcIit2XT10LmdldFVuaWZvcm1Mb2NhdGlvbihjLFwib2Zmc2V0XCIrdiwhMSl9cmV0dXJue3Byb2dyYW06ZSxzb3VyY2U6bCx3ZWJHTFByb2dyYW06Yyx1bmlmb3JtTG9jYXRpb25zOmYsaW5TaGFwZUluZm9zOnMsb3V0U2hhcGVJbmZvOnUsaW5mTG9jOmgsbmFuTG9jOnB9fShvLmdwZ3B1LHQsaSx1KX0pLGg9bnVsbCE9dGhpcy5hY3RpdmVUaW1lcnM7cmV0dXJuIGgmJihzPXRoaXMuc3RhcnRUaW1lcigpKSxmdW5jdGlvbih0LGUsbixyLG8pe1VhKGUuaW5TaGFwZUluZm9zLG4pLFVhKFtlLm91dFNoYXBlSW5mb10sW3JdKTt2YXIgaT1yLnRleERhdGEudGV4dHVyZSxzPXIudGV4RGF0YS50ZXhTaGFwZTtyLnRleERhdGEuaXNQYWNrZWQ/dC5zZXRPdXRwdXRQYWNrZWRNYXRyaXhUZXh0dXJlKGksc1swXSxzWzFdKTp0LnNldE91dHB1dE1hdHJpeFRleHR1cmUoaSxzWzBdLHNbMV0pLHQuc2V0UHJvZ3JhbShlLndlYkdMUHJvZ3JhbSksMT09PWEuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSYmbnVsbCE9PWUuaW5mTG9jJiZ0LmdsLnVuaWZvcm0xZihlLmluZkxvYywxLzApLG51bGwhPT1lLm5hbkxvYyYmdC5nbC51bmlmb3JtMWYoZS5uYW5Mb2MsTmFOKSxuLmZvckVhY2goZnVuY3Rpb24obixyKXt2YXIgbz1lLnByb2dyYW0udmFyaWFibGVOYW1lc1tyXSxhPWUudW5pZm9ybUxvY2F0aW9uc1tvXSxpPWUudW5pZm9ybUxvY2F0aW9uc1tcIm9mZnNldFwiK29dO2lmKG51bGwhPWEpaWYobi5pc1VuaWZvcm0paWYoeShuLnNoYXBlKTwyKXQuZ2wudW5pZm9ybTFmKGEsbi51bmlmb3JtVmFsdWVzWzBdKTtlbHNle3ZhciBzPW4udW5pZm9ybVZhbHVlcztzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5fHwocz1uZXcgRmxvYXQzMkFycmF5KHMpKSx0LmdsLnVuaWZvcm0xZnYoYSxzKX1lbHNlIG51bGwhPW4udGV4RGF0YS5zbGljZSYmbnVsbCE9aSYmdC5nbC51bmlmb3JtMWkoaSxuLnRleERhdGEuc2xpY2UuZmxhdE9mZnNldCksdC5zZXRJbnB1dE1hdHJpeFRleHR1cmUobi50ZXhEYXRhLnRleHR1cmUsYSxyKX0pLG51bGwhPW8mJm8odCxlLndlYkdMUHJvZ3JhbSksdC5leGVjdXRlUHJvZ3JhbSgpfSh0aGlzLmdwZ3B1LGMsaSx1LHIpLGgmJihzPXRoaXMuZW5kVGltZXIocyksdGhpcy5hY3RpdmVUaW1lcnMucHVzaCh7bmFtZTp0LmNvbnN0cnVjdG9yLm5hbWUscXVlcnk6dGhpcy5nZXRRdWVyeVRpbWUocyl9KSksYS5nZXRCb29sKFwiV0VCR0xfTEFaSUxZX1VOUEFDS1wiKXx8IXRoaXMudGV4RGF0YS5nZXQobi5kYXRhSWQpLmlzUGFja2VkfHx0LmlzUGFja1NoYWRlcj9uOnRoaXMudW5wYWNrVGVuc29yKG4pfSx0LnByb3RvdHlwZS5nZXRBbmRTYXZlQmluYXJ5PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQgaW4gdGhpcy5iaW5hcnlDYWNoZXx8KHRoaXMuYmluYXJ5Q2FjaGVbdF09ZSgpKSx0aGlzLmJpbmFyeUNhY2hlW3RdfSx0LnByb3RvdHlwZS5nZXRUZXh0dXJlTWFuYWdlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRleHR1cmVNYW5hZ2VyfSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5kaXNwb3NlZHx8KHRoaXMudGV4dHVyZU1hbmFnZXIuZGlzcG9zZSgpLHRoaXMuY2FudmFzLnJlbW92ZSgpLG51bGwhPXRoaXMuZnJvbVBpeGVsczJEQ29udGV4dCYmdGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0LmNhbnZhcy5yZW1vdmUoKSx0aGlzLmdwZ3B1Q3JlYXRlZExvY2FsbHkmJih0aGlzLmdwZ3B1LnByb2dyYW09bnVsbCx0aGlzLmdwZ3B1LmRpc3Bvc2UoKSksdGhpcy5kaXNwb3NlZD0hMCl9LHQucHJvdG90eXBlLmZsb2F0UHJlY2lzaW9uPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztyZXR1cm4gbnVsbD09dGhpcy5mbG9hdFByZWNpc2lvblZhbHVlJiYodGhpcy5mbG9hdFByZWNpc2lvblZhbHVlPUZlKGZ1bmN0aW9uKCl7dmFyIGU9YS5nZXRCb29sKFwiREVCVUdcIik7YS5zZXQoXCJERUJVR1wiLCExKTt2YXIgbj10LmFicyhCbigxZS04KSkuZGF0YVN5bmMoKVswXTtyZXR1cm4gYS5zZXQoXCJERUJVR1wiLGUpLG4+MD8zMjoxNn0pKSx0aGlzLmZsb2F0UHJlY2lzaW9uVmFsdWV9LHQucHJvdG90eXBlLmVwc2lsb249ZnVuY3Rpb24oKXtyZXR1cm4gMzI9PT10aGlzLmZsb2F0UHJlY2lzaW9uKCk/MWUtNzoxZS00fSx0LnByb3RvdHlwZS51cGxvYWRUb0dQVT1mdW5jdGlvbih0KXt2YXIgZSxuPXRoaXMudGV4RGF0YS5nZXQodCkscj1uLnNoYXBlLG89bi5kdHlwZSxhPW4udmFsdWVzLGk9bi50ZXh0dXJlLHM9bi51c2FnZSx1PW4uaXNQYWNrZWQ7aWYobnVsbD09aSl7dmFyIGwsYz1udWxsIT10aGlzLmFjdGl2ZVRpbWVycztjJiYobD1wZXJmb3JtYW5jZS5ub3coKSk7dmFyIGg9dmUocix1KTtuLnRleFNoYXBlPWg7dmFyIHA9dGhpcy5hY3F1aXJlVGV4dHVyZShoLHMsbyx1KTtpZihuLnRleHR1cmU9cCxudWxsIT1hKXtpZih1KXt2YXIgZj1mZShyKSxkPTEsdj0xO3IubGVuZ3RoJiYoZD0oZT1kZShyKSlbMF0sdj1lWzFdKSx0aGlzLmdwZ3B1LnVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZShwLGYsZCx2LGhbMF0saFsxXSx6aShhKSl9ZWxzZSB0aGlzLmdwZ3B1LnVwbG9hZE1hdHJpeFRvVGV4dHVyZShwLGhbMF0saFsxXSx6aShhKSk7bi52YWx1ZXM9bnVsbCxjJiYodGhpcy51cGxvYWRXYWl0TXMrPXBlcmZvcm1hbmNlLm5vdygpLWwpfX19LHQucHJvdG90eXBlLmNvbnZlcnRBbmRDYWNoZU9uQ1BVPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy50ZXhEYXRhLmdldCh0KSxyPW4uZHR5cGU7cmV0dXJuIHRoaXMucmVsZWFzZUdQVURhdGEodCksbi51c2FnZT11YS5VUExPQUQsbnVsbCE9ZSYmKG4udmFsdWVzPWZ1bmN0aW9uKHQsZSl7aWYoXCJmbG9hdDMyXCI9PT1lfHxcImNvbXBsZXg2NFwiPT09ZSlyZXR1cm4gdDtpZihcImludDMyXCI9PT1lfHxcImJvb2xcIj09PWUpe2Zvcih2YXIgbj1cImludDMyXCI9PT1lP25ldyBJbnQzMkFycmF5KHQubGVuZ3RoKTpuZXcgVWludDhBcnJheSh0Lmxlbmd0aCkscj0wO3I8bi5sZW5ndGg7KytyKW5bcl09TWF0aC5yb3VuZCh0W3JdKTtyZXR1cm4gbn10aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGR0eXBlIFwiK2UpfShlLHIpKSxuLnZhbHVlc30sdC5wcm90b3R5cGUuYWNxdWlyZVRleHR1cmU9ZnVuY3Rpb24odCxlLG4scil7aWYodGhpcy5udW1CeXRlc0luR1BVKz10aGlzLmNvbXB1dGVCeXRlcyh0LG4pLCF0aGlzLndhcm5lZEFib3V0TWVtb3J5JiZ0aGlzLm51bUJ5dGVzSW5HUFU+MTAyNCp0aGlzLm51bU1CQmVmb3JlV2FybmluZyoxMDI0KXt2YXIgbz0odGhpcy5udW1CeXRlc0luR1BVLzEwMjQvMTAyNCkudG9GaXhlZCgyKTt0aGlzLndhcm5lZEFib3V0TWVtb3J5PSEwLGNvbnNvbGUud2FybihcIkhpZ2ggbWVtb3J5IHVzYWdlIGluIEdQVTogXCIrbytcIiBNQiwgbW9zdCBsaWtlbHkgZHVlIHRvIGEgbWVtb3J5IGxlYWtcIil9cmV0dXJuIHRoaXMudGV4dHVyZU1hbmFnZXIuYWNxdWlyZVRleHR1cmUodCxlLHIpfSx0LnByb3RvdHlwZS5jb21wdXRlQnl0ZXM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdFswXSp0WzFdKk0oZSl9LHR9KCk7ZnVuY3Rpb24gemkodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXk/dDpuZXcgRmxvYXQzMkFycmF5KHQpfU90KCkmJkR0LnJlZ2lzdGVyQmFja2VuZChcIndlYmdsXCIsZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFVpfSwyKTt2YXIgVmk9QW4oe2Fic186ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImFic1wiKTtyZXR1cm5cImNvbXBsZXg2NFwiPT09ZS5kdHlwZT9EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuY29tcGxleEFicyhlKX0seyR4OmV9KTpEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LmFicyhlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4udG9GbG9hdCgpLnN0ZXAoLTEpKX19fSl9fSksR2k9QW4oe2Fjb3NfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJhY29zXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LmFjb3MoZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdlN0cmljdChCbigxKS5zdWIobi50b0Zsb2F0KCkuc3F1YXJlKCkpLnNxcnQoKSkubmVnKCl9fX0pfX0pLHFpPUFuKHthY29zaF86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImFjb3NoXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LmFjb3NoKGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXZTdHJpY3Qobi50b0Zsb2F0KCkuc3F1YXJlKCkuc3ViKDEpLnNxcnQoKSl9fX0pfX0pLEhpPUFuKHthc2luXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwiYXNpblwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5hc2luKGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXZTdHJpY3QoQm4oMSkuc3ViKG4udG9GbG9hdCgpLnNxdWFyZSgpKS5zcXJ0KCkpfX19KX19KSwkaT1Bbih7YXNpbmhfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJhc2luaFwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5hc2luaChlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2U3RyaWN0KEJuKDEpLmFkZChuLnRvRmxvYXQoKS5zcXVhcmUoKSkuc3FydCgpKX19fSl9fSksamk9QW4oe2F0YW5fOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJhdGFuXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LmF0YW4oZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdihuLnRvRmxvYXQoKS5zcXVhcmUoKS5hZGQoMSkpfX19KX19KSxLaT1Bbih7YXRhbmhfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJhdGFuaFwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5hdGFuaChlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2KEJuKDEpLnN1YihuLnRvRmxvYXQoKS5zcXVhcmUoKSkpfX19KX19KSxYaT1Bbih7Y2VpbF86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImNlaWxcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5jZWlsKGUpfSx7JHg6ZX0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KX19KSxZaT1Bbih7Y2xpcEJ5VmFsdWVfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj13bih0LFwieFwiLFwiY2xpcEJ5VmFsdWVcIik7cmV0dXJuIGQoZTw9bixmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY2xpcDogbWluIChcIitlK1wiKSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBtYXggKFwiK24rXCIpLlwifSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbyl7dmFyIGE9dC5jbGlwKHIsZSxuKTtyZXR1cm4gbyhbcl0pLGF9LHskeDpyfSxmdW5jdGlvbih0LHIpe3ZhciBvPXJbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQud2hlcmUoby5ncmVhdGVyRXF1YWwoZSkubG9naWNhbEFuZChvLmxlc3NFcXVhbChuKSksWG4odCkpfX19KX19KSxRaT1Bbih7Y29zXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwiY29zXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LmNvcyhlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIG4udG9GbG9hdCgpLnNpbigpLm5lZygpLm11bCh0KX19fSl9fSksSmk9QW4oe2Nvc2hfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJjb3NoXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LmNvc2goZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBuLnRvRmxvYXQoKS5zaW5oKCkubXVsU3RyaWN0KHQpfX19KX19KSxaaT1Bbih7ZXJmXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwiZXJmXCIpO3JldHVybiBkKFwiaW50MzJcIj09PWUuZHR5cGV8fFwiZmxvYXQzMlwiPT09ZS5kdHlwZSxmdW5jdGlvbigpe3JldHVyblwiSW5wdXQgZHR5cGUgbXVzdCBiZSBgaW50MzJgIG9yIGBmbG9hdDMyYC5cIn0pLFwiaW50MzJcIj09PWUuZHR5cGUmJihlPWUudG9GbG9hdCgpKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LmVyZihlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4uc3F1YXJlKCkubmVnKCkuZXhwKCkubXVsKDIvTWF0aC5zcXJ0KE1hdGguUEkpKSl9fX0pfX0pLHRzPUFuKHtleHBfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJleHBcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQuZXhwKGUpO3JldHVybiBuKFtyXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsU3RyaWN0KGVbMF0pfX19KX19KSxlcz1Bbih7ZXhwbTFfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJleHBtMVwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5leHBtMShlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4uZXhwKCkpfX19KX19KSxucz1Bbih7Zmxvb3JfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJmbG9vclwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmZsb29yKGUpfSx7JHg6ZX0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KX19KSxycz1Bbih7bG9nXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwibG9nXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LmxvZyhlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2KG4udG9GbG9hdCgpKX19fSl9fSksb3M9QW4oe2xvZzFwXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwibG9nMXBcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQubG9nMXAoZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdihuLmFkZCgxKSl9fX0pfX0pLGFzPUFuKHtsb2dTaWdtb2lkXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwibG9nU2lnbW9pZFwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5zb2Z0cGx1cyhlLm5lZygpKS5uZWcoKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4ubmVnKCkuc2lnbW9pZCgpKX19fSl9fSksaXM9QW4oe25lZ186ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcIm5lZ1wiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5lZyhlKX0seyR4OmV9LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0Lm5lZygpfX19KX19KSxzcz1Bbih7cmVjaXByb2NhbF86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcInJlY2lwcm9jYWxcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQucmVjaXByb2NhbChlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2KG4uc3F1YXJlKCkubmVnKCkpfX19KX19KSx1cz1Bbih7cm91bmRfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJyb3VuZFwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJvdW5kKGUpfSx7JHg6ZX0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KX19KSxscz1Bbih7cnNxcnRfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJyc3FydFwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5yc3FydChlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2KG4ucG93KDEuNSkubXVsKDIpKS5uZWcoKX19fSl9fSksY3M9QW4oe3NpZ21vaWRfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJzaWdtb2lkXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LnNpZ21vaWQoZSk7cmV0dXJuIG4oW3JdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLm11bChCbigxKS5zdWIobikpKX19fSl9fSksaHM9QW4oe3NpZ25fOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJzaWduXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2lnbihlKX0seyR4OmV9LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbih0KX19fSl9fSkscHM9QW4oe2lzTmFOXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwiaXNOYU5cIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5pc05hTihlKX0seyR4OmV9LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbih0KX19fSl9fSksZnM9QW4oe2lzSW5mXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwiaXNJbmZcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5pc0luZihlKX0seyR4OmV9LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbih0KX19fSl9fSksZHM9QW4oe2lzRmluaXRlXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwiaXNGaW5pdGVcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5pc0Zpbml0ZShlKX0seyR4OmV9LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbih0KX19fSl9fSksdnM9QW4oe3Npbl86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcInNpblwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5zaW4oZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBuLnRvRmxvYXQoKS5jb3MoKS5tdWwodCl9fX0pfX0pLG1zPUFuKHtzaW5oXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwic2luaFwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5zaW5oKGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gbi50b0Zsb2F0KCkuY29zaCgpLm11bFN0cmljdCh0KX19fSl9fSksZ3M9QW4oe3NvZnRwbHVzXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwic29mdHBsdXNcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQuc29mdHBsdXMoZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLnNpZ21vaWQoKSl9fX0pfX0pLHlzPUFuKHtzcXJ0XzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwic3FydFwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5zcXJ0KGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXYobi50b0Zsb2F0KCkuc3FydCgpLm11bCgyKSl9fX0pfX0pLHhzPUFuKHtzcXVhcmVfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJzcXVhcmVcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3JldHVybiBuKFtlXSksdC5zcXVhcmUoZSl9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4udG9GbG9hdCgpLm11bCgyKSl9fX0pfX0pLHdzPUFuKHtzdGVwXzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPTApO3ZhciBuPXduKHQsXCJ4XCIsXCJzdGVwXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3RlcChuLGUpfSx7JHg6bn0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KX19KSxicz1Bbih7dGFuXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwidGFuXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LnRhbihlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2KG4uY29zKCkuc3F1YXJlKCkpfX19KX19KSxDcz1Bbih7dGFuaF86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcInRhbmhcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQudGFuaChlKTtyZXR1cm4gbihbcl0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIEJuKDEpLnN1YihuLnNxdWFyZSgpKS5tdWxTdHJpY3QodCl9fX0pfX0pO2Z1bmN0aW9uIEVzKHQsZSxuLHIsbyxhKXt2YXIgaSxzLHU9d24odCxcInhcIixcImJhdGNoTm9ybVwiKSxsPXduKGUsXCJtZWFuXCIsXCJiYXRjaE5vcm1cIiksYz13bihuLFwidmFyaWFuY2VcIixcImJhdGNoTm9ybVwiKTtyZXR1cm4gbnVsbCE9byYmKGk9d24obyxcInNjYWxlXCIsXCJiYXRjaE5vcm1cIikpLG51bGwhPXImJihzPXduKHIsXCJvZmZzZXRcIixcImJhdGNoTm9ybVwiKSksZCgyPT09dS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0zRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSksZCgyPT09bC5yYW5rfHwxPT09bC5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0yRDogbWVhbiBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2wucmFuaytcIi5cIn0pLGQoMj09PWMucmFua3x8MT09PWMucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtMkQ6IHZhcmlhbmNlIG11c3QgYmUgcmFuayAyIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrYy5yYW5rK1wiLlwifSksbnVsbCE9aSYmZCgyPT09aS5yYW5rfHwxPT09aS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0yRDogc2NhbGUgbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitpLnJhbmsrXCIuXCJ9KSxudWxsIT1zJiZkKDI9PT1zLnJhbmt8fDE9PT1zLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTJEOiBvZmZzZXQgbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitzLnJhbmsrXCIuXCJ9KSxOcyh1LGwsYyxzLGksYSl9ZnVuY3Rpb24gUnModCxlLG4scixvLGEpe3ZhciBpLHMsdT13bih0LFwieFwiLFwiYmF0Y2hOb3JtXCIpLGw9d24oZSxcIm1lYW5cIixcImJhdGNoTm9ybVwiKSxjPXduKG4sXCJ2YXJpYW5jZVwiLFwiYmF0Y2hOb3JtXCIpO3JldHVybiBudWxsIT1vJiYoaT13bihvLFwic2NhbGVcIixcImJhdGNoTm9ybVwiKSksbnVsbCE9ciYmKHM9d24ocixcIm9mZnNldFwiLFwiYmF0Y2hOb3JtXCIpKSxkKDM9PT11LnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTNEOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSxkKDM9PT1sLnJhbmt8fDE9PT1sLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTNEOiBtZWFuIG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrbC5yYW5rK1wiLlwifSksZCgzPT09Yy5yYW5rfHwxPT09Yy5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0zRDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitjLnJhbmsrXCIuXCJ9KSxudWxsIT1pJiZkKDM9PT1pLnJhbmt8fDE9PT1pLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTNEOiBzY2FsZSBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2kucmFuaytcIi5cIn0pLG51bGwhPXMmJmQoMz09PXMucmFua3x8MT09PXMucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtM0Q6IG9mZnNldCBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK3MucmFuaytcIi5cIn0pLE5zKHUsbCxjLHMsaSxhKX1mdW5jdGlvbiBTcyh0LGUsbixyLG8sYSl7dmFyIGkscyx1PXduKHQsXCJ4XCIsXCJiYXRjaE5vcm1cIiksbD13bihlLFwibWVhblwiLFwiYmF0Y2hOb3JtXCIpLGM9d24obixcInZhcmlhbmNlXCIsXCJiYXRjaE5vcm1cIik7cmV0dXJuIG51bGwhPW8mJihpPXduKG8sXCJzY2FsZVwiLFwiYmF0Y2hOb3JtXCIpKSxudWxsIT1yJiYocz13bihyLFwib2Zmc2V0XCIsXCJiYXRjaE5vcm1cIikpLGQoND09PXUucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtNEQ6IHggbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pLGQoND09PWwucmFua3x8MT09PWwucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtNEQ6IG1lYW4gbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitsLnJhbmsrXCIuXCJ9KSxkKDQ9PT1jLnJhbmt8fDE9PT1jLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTREOiB2YXJpYW5jZSBtdXN0IGJlIHJhbmsgNCBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2MucmFuaytcIi5cIn0pLG51bGwhPWkmJmQoND09PWkucmFua3x8MT09PWkucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtNEQ6IHNjYWxlIG11c3QgYmUgcmFuayA0IG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIraS5yYW5rK1wiLlwifSksbnVsbCE9cyYmZCg0PT09cy5yYW5rfHwxPT09cy5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm00RDogb2Zmc2V0IG11c3QgYmUgcmFuayA0IG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrcy5yYW5rK1wiLlwifSksTnModSxsLGMscyxpLGEpfWZ1bmN0aW9uIE5zKHQsZSxuLHIsbyxhKXtudWxsPT1hJiYoYT0uMDAxKTt2YXIgaSxzLHUsbD13bih0LFwieFwiLFwiYmF0Y2hOb3JtXCIpLGM9d24oZSxcIm1lYW5cIixcImJhdGNoTm9ybVwiKSxoPXduKG4sXCJ2YXJpYW5jZVwiLFwiYmF0Y2hOb3JtXCIpO251bGwhPW8mJihpPXduKG8sXCJzY2FsZVwiLFwiYmF0Y2hOb3JtXCIpKSxudWxsIT1yJiYocz13bihyLFwib2Zmc2V0XCIsXCJiYXRjaE5vcm1cIikpLGQoYy5yYW5rPT09aC5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJCYXRjaCBub3JtYWxpemF0aW9uIGdyYWRpZW50IHJlcXVpcmVzIG1lYW4gYW5kIHZhcmlhbmNlIHRvIGhhdmUgZXF1YWwgcmFua3MuXCJ9KSxkKG51bGw9PXN8fGMucmFuaz09PXMucmFuayxmdW5jdGlvbigpe3JldHVyblwiQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCBvZmZzZXQgdG8gaGF2ZSBlcXVhbCByYW5rcy5cIn0pLGQobnVsbD09aXx8Yy5yYW5rPT09aS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJCYXRjaCBub3JtYWxpemF0aW9uIGdyYWRpZW50IHJlcXVpcmVzIG1lYW4gYW5kIHNjYWxlIHRvIGhhdmUgZXF1YWwgcmFua3MuXCJ9KSx1PTA9PT1sLnJhbmt8fDE9PT1sLnJhbms/bC5hczREKDEsMSwxLGwuc2l6ZSk6Mj09PWwucmFuaz9sLmFzNEQoMSwxLGwuc2hhcGVbMF0sbC5zaGFwZVsxXSk6Mz09PWwucmFuaz9sLmFzNEQoMSxsLnNoYXBlWzBdLGwuc2hhcGVbMV0sbC5zaGFwZVsyXSk6bDtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5iYXRjaE5vcm1hbGl6YXRpb24odSxrcyhjKSxrcyhoKSxhLGtzKGkpLGtzKHMpKTtyZXR1cm4gZShbbCxjLGgsaV0pLG59LHskeDpsLCRtZWFuOmMsJHZhcmlhbmNlOmgsJHNjYWxlOmksJG9mZnNldDpzfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdLG89ZVsyXSxpPWVbM10scz1udWxsPT1pP0JuKDEpOmksbD1pbyhyLnNoYXBlLHUuc2hhcGUpLGM9W107aWYoMT09PXIucmFuayl7Zm9yKHZhciBoPTA7aDx1LnNoYXBlLmxlbmd0aC0xOysraCljLnB1c2godS5zaGFwZVtoXSk7Yy5wdXNoKDEpfXZhciBwPW4uc3ViKHIpLGY9dC5tdWwocyksZD1scyhvLmFkZChCbihhKSkpLHY9ZC5tdWwoZCkubXVsKGQpLm11bChCbigtLjUpKTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gMT09PXIucmFuaz90Lm11bChYcihkLmFzNEQoMSwxLDEsci5zaGFwZVswXSksYykpLm11bChzKS5yZXNoYXBlKG4uc2hhcGUpOnQubXVsKGQpLm11bChzKS5yZXNoYXBlKG4uc2hhcGUpfSwkbWVhbjpmdW5jdGlvbigpe3ZhciB0PWQubXVsKEJuKC0xKSkubXVsKGYpO3JldHVybiAxPT09ci5yYW5rJiYodD10LnN1bShsKSksdC5yZXNoYXBlKHIuc2hhcGUpfSwkdmFyaWFuY2U6ZnVuY3Rpb24oKXt2YXIgdD12Lm11bChwKS5tdWwoZik7cmV0dXJuIDE9PT1yLnJhbmsmJih0PXQuc3VtKGwpKSx0LnJlc2hhcGUoci5zaGFwZSl9LCRzY2FsZTpmdW5jdGlvbigpe3ZhciBlPXAubXVsKGQpLG49dC5tdWwoZSk7cmV0dXJuIDE9PT1yLnJhbmsmJihuPW4uc3VtKGwpKSxuLnJlc2hhcGUoci5zaGFwZSl9LCRvZmZzZXQ6ZnVuY3Rpb24oKXt2YXIgZT10O3JldHVybiAxPT09ci5yYW5rJiYoZT1lLnN1bShsKSksZS5yZXNoYXBlKHIuc2hhcGUpfX19KS5yZXNoYXBlKGwuc2hhcGUpfWZ1bmN0aW9uIGtzKHQpe3JldHVybiBudWxsPT10P251bGw6MD09PXQucmFuaz90LmFzMUQoKToxPT09dC5yYW5rP3Q6Mj09PXQucmFuaz90LmFzNEQoMSwxLHQuc2hhcGVbMF0sdC5zaGFwZVsxXSk6Mz09PXQucmFuaz90LmFzNEQoMSx0LnNoYXBlWzBdLHQuc2hhcGVbMV0sdC5zaGFwZVsyXSk6dH1mdW5jdGlvbiBJcygpe0RlKFwidGYuYmF0Y2hOb3JtYWxpemF0aW9uKCkgaXMgZ29pbmcgYXdheS4gVXNlIHRmLmJhdGNoTm9ybSgpIGluc3RlYWQsIGFuZCBub3RlIHRoZSBwb3NpdGlvbmFsIGFyZ3VtZW50IGNoYW5nZSBvZiBzY2FsZSwgb2Zmc2V0LCBhbmQgdmFyaWFuY2VFcHNpbG9uXCIpfXZhciBBcz1Bbih7YmF0Y2hOb3JtYWxpemF0aW9uMmRfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjAwMSksSXMoKSxFcyh0LGUsbixhLG8scil9fSksVHM9QW4oe2JhdGNoTm9ybWFsaXphdGlvbjNkXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIHZvaWQgMD09PXImJihyPS4wMDEpLElzKCksUnModCxlLG4sYSxvLHIpfX0pLERzPUFuKHtiYXRjaE5vcm1hbGl6YXRpb240ZF86ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB2b2lkIDA9PT1yJiYocj0uMDAxKSxJcygpLFNzKHQsZSxuLGEsbyxyKX19KSxPcz1Bbih7YmF0Y2hOb3JtYWxpemF0aW9uXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIHZvaWQgMD09PXImJihyPS4wMDEpLElzKCksTnModCxlLG4sYSxvLHIpfX0pLF9zPUFuKHtiYXRjaE5vcm1fOk5zfSksTXM9QW4oe2JhdGNoTm9ybTJkXzpFc30pLEZzPUFuKHtiYXRjaE5vcm0zZF86UnN9KSxCcz1Bbih7YmF0Y2hOb3JtNGRfOlNzfSk7ZnVuY3Rpb24gUHModCxlLG4scixvLGEsaSl7dm9pZCAwPT09aSYmKGk9XCJjaGFubmVsc0xhc3RcIik7dmFyIHMsdT1VcyhlKSxsPXVbMF0sYz11WzFdO2lmKFwiY2hhbm5lbHNMYXN0XCI9PT1pKXM9W2wsYyx0WzNdLHRbM11dO2Vsc2V7aWYoXCJjaGFubmVsc0ZpcnN0XCIhPT1pKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YUZvcm1hdCBcIitpKTtzPVtsLGMsdFsxXSx0WzFdXX1yZXR1cm4gTHModCxzLG4scixvLGEsITEsaSl9ZnVuY3Rpb24gTHModCxlLG4scixvLGEsaSxzKXt2b2lkIDA9PT1pJiYoaT0hMSksdm9pZCAwPT09cyYmKHM9XCJjaGFubmVsc0xhc3RcIik7dmFyIHU9Wy0xLC0xLC0xLC0xXSxsPXVbMF0sYz11WzFdLGg9dVsyXSxwPXVbM107aWYoXCJjaGFubmVsc0xhc3RcIj09PXMpbD10WzBdLGM9dFsxXSxoPXRbMl0scD10WzNdO2Vsc2V7aWYoXCJjaGFubmVsc0ZpcnN0XCIhPT1zKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YUZvcm1hdCBcIitzKTtsPXRbMF0scD10WzFdLGM9dFsyXSxoPXRbM119dmFyIGYsdj1lWzBdLG09ZVsxXSxnPWVbM10seT1VcyhuKSx4PXlbMF0sYj15WzFdLEM9VXMociksRT1DWzBdLFI9Q1sxXSxTPVZzKHYsRSksTj1WcyhtLFIpLGs9ZnVuY3Rpb24odCxlLG4scixvLGEsaSxzKXt2YXIgdSxsLGM7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpe3ZhciBoPTA9PT10P1wiVkFMSURcIjpcIk5VTUJFUlwiO3U9e3RvcDp0LGJvdHRvbTp0LGxlZnQ6dCxyaWdodDp0LHR5cGU6aH07dmFyIHA9ZnVuY3Rpb24odCxlLG4scixvLGEpe251bGw9PW8mJihvPWZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPTEpO3ZhciBvPVZzKGUscik7cmV0dXJuIE1hdGguZmxvb3IoKHRbMF0qKG4tMSktbitvKS8yKX0odCxlLHIpKTt2YXIgaT10WzBdLHM9dFsxXSx1PUdzKChpLWUrMipvKS9yKzEsYSk7ZCh3KHUpLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgb3V0cHV0ICMgb2Ygcm93cyAoXCIrdStcIikgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgdGhlIHN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wifSk7dmFyIGw9R3MoKHMtZSsyKm8pL3IrMSxhKTtyZXR1cm4gZCh3KGwpLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgb3V0cHV0ICMgb2YgY29sdW1ucyAoXCIrbCtcIikgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgdGhlIHN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wifSksW3UsbCxuXX0oW2UsbiwxXSxhLDEscix0LHMpO2w9cFswXSxjPXBbMV19ZWxzZSBpZihcInNhbWVcIj09PXQpe2w9TWF0aC5jZWlsKGUvciksYz1NYXRoLmNlaWwobi9vKTt2YXIgZj1NYXRoLm1heCgwLChsLTEpKnIrYS1lKSx2PU1hdGgubWF4KDAsKGMtMSkqbytpLW4pLG09TWF0aC5mbG9vcihmLzIpLGc9Zi1tLHk9TWF0aC5mbG9vcih2LzIpLHg9di15O3U9e3RvcDptLGJvdHRvbTpnLGxlZnQ6eSxyaWdodDp4LHR5cGU6XCJTQU1FXCJ9fWVsc2V7aWYoXCJ2YWxpZFwiIT09dCl0aHJvdyBFcnJvcihcIlVua25vd24gcGFkZGluZyBwYXJhbWV0ZXI6IFwiK3QpO3U9e3RvcDowLGJvdHRvbTowLGxlZnQ6MCxyaWdodDowLHR5cGU6XCJWQUxJRFwifSxsPU1hdGguY2VpbCgoZS1hKzEpL3IpLGM9TWF0aC5jZWlsKChuLWkrMSkvbyl9cmV0dXJue3BhZEluZm86dSxvdXRIZWlnaHQ6bCxvdXRXaWR0aDpjfX0obyxjLGgseCxiLFMsTixhKSxJPWsucGFkSW5mbyxBPWsub3V0SGVpZ2h0LFQ9ay5vdXRXaWR0aCxEPWk/ZypwOmc7cmV0dXJuXCJjaGFubmVsc0ZpcnN0XCI9PT1zP2Y9W2wsRCxBLFRdOlwiY2hhbm5lbHNMYXN0XCI9PT1zJiYoZj1bbCxBLFQsRF0pLHtiYXRjaFNpemU6bCxkYXRhRm9ybWF0OnMsaW5IZWlnaHQ6YyxpbldpZHRoOmgsaW5DaGFubmVsczpwLG91dEhlaWdodDpBLG91dFdpZHRoOlQsb3V0Q2hhbm5lbHM6RCxwYWRJbmZvOkksc3RyaWRlSGVpZ2h0Ongsc3RyaWRlV2lkdGg6YixmaWx0ZXJIZWlnaHQ6dixmaWx0ZXJXaWR0aDptLGVmZmVjdGl2ZUZpbHRlckhlaWdodDpTLGVmZmVjdGl2ZUZpbHRlcldpZHRoOk4sZGlsYXRpb25IZWlnaHQ6RSxkaWxhdGlvbldpZHRoOlIsaW5TaGFwZTp0LG91dFNoYXBlOmYsZmlsdGVyU2hhcGU6ZX19ZnVuY3Rpb24gV3ModCxlLG4scixvLGEsaSl7dm9pZCAwPT09YSYmKGE9ITEpLHZvaWQgMD09PWkmJihpPVwiY2hhbm5lbHNMYXN0XCIpO3ZhciBzPVstMSwtMSwtMSwtMSwtMV0sdT1zWzBdLGw9c1sxXSxjPXNbMl0saD1zWzNdLHA9c1s0XTtpZihcImNoYW5uZWxzTGFzdFwiPT09aSl1PXRbMF0sbD10WzFdLGM9dFsyXSxoPXRbM10scD10WzRdO2Vsc2V7aWYoXCJjaGFubmVsc0ZpcnN0XCIhPT1pKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YUZvcm1hdCBcIitpKTt1PXRbMF0scD10WzFdLGw9dFsyXSxjPXRbM10saD10WzRdfXZhciBmLGQ9ZVswXSx2PWVbMV0sbT1lWzJdLGc9ZVs0XSx5PXpzKG4pLHg9eVswXSx3PXlbMV0sYj15WzJdLEM9enMociksRT1DWzBdLFI9Q1sxXSxTPUNbMl0sTj1mdW5jdGlvbih0LGUsbixyLG8sYSxpLHMsdSxsKXt2YXIgYyxoLHAsZjtpZihcInNhbWVcIj09PXQpe2g9TWF0aC5jZWlsKGUvbykscD1NYXRoLmNlaWwobi9hKSxmPU1hdGguY2VpbChyL2kpO3ZhciBkPShoLTEpKm8rcy1lLHY9KHAtMSkqYSt1LW4sbT0oZi0xKSppK2wtcixnPU1hdGguZmxvb3IoZC8yKSx5PWQtZyx4PU1hdGguZmxvb3Iodi8yKSx3PXYteCxiPU1hdGguZmxvb3IobS8yKSxDPW0tYjtjPXt0b3A6eCxib3R0b206dyxsZWZ0OmIscmlnaHQ6Qyxmcm9udDpnLGJhY2s6eSx0eXBlOlwiU0FNRVwifX1lbHNle2lmKFwidmFsaWRcIiE9PXQpdGhyb3cgRXJyb3IoXCJVbmtub3duIHBhZGRpbmcgcGFyYW1ldGVyOiBcIit0KTtjPXt0b3A6MCxib3R0b206MCxsZWZ0OjAscmlnaHQ6MCxmcm9udDowLGJhY2s6MCx0eXBlOlwiVkFMSURcIn0saD1NYXRoLmNlaWwoKGUtcysxKS9vKSxwPU1hdGguY2VpbCgobi11KzEpL2EpLGY9TWF0aC5jZWlsKChyLWwrMSkvaSl9cmV0dXJue3BhZEluZm86YyxvdXREZXB0aDpoLG91dEhlaWdodDpwLG91dFdpZHRoOmZ9fShvLGwsYyxoLHgsdyxiLFZzKGQsRSksVnModixSKSxWcyhtLFMpKSxrPU4ucGFkSW5mbyxJPU4ub3V0RGVwdGgsQT1OLm91dEhlaWdodCxUPU4ub3V0V2lkdGgsRD1hP2cqcDpnO3JldHVyblwiY2hhbm5lbHNGaXJzdFwiPT09aT9mPVt1LEQsSSxBLFRdOlwiY2hhbm5lbHNMYXN0XCI9PT1pJiYoZj1bdSxJLEEsVCxEXSkse2JhdGNoU2l6ZTp1LGRhdGFGb3JtYXQ6aSxpbkRlcHRoOmwsaW5IZWlnaHQ6YyxpbldpZHRoOmgsaW5DaGFubmVsczpwLG91dERlcHRoOkksb3V0SGVpZ2h0OkEsb3V0V2lkdGg6VCxvdXRDaGFubmVsczpELHBhZEluZm86ayxzdHJpZGVEZXB0aDp4LHN0cmlkZUhlaWdodDp3LHN0cmlkZVdpZHRoOmIsZmlsdGVyRGVwdGg6ZCxmaWx0ZXJIZWlnaHQ6dixmaWx0ZXJXaWR0aDptLGRpbGF0aW9uRGVwdGg6RSxkaWxhdGlvbkhlaWdodDpSLGRpbGF0aW9uV2lkdGg6UyxpblNoYXBlOnQsb3V0U2hhcGU6ZixmaWx0ZXJTaGFwZTplfX1mdW5jdGlvbiBVcyh0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdD9bdCx0XTp0fWZ1bmN0aW9uIHpzKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0P1t0LHQsdF06dH1mdW5jdGlvbiBWcyh0LGUpe3JldHVybiBlPD0xP3Q6dCsodC0xKSooZS0xKX1mdW5jdGlvbiBHcyh0LGUpe2lmKCFlKXJldHVybiB0O3N3aXRjaChlKXtjYXNlXCJyb3VuZFwiOnJldHVybiBNYXRoLnJvdW5kKHQpO2Nhc2VcImNlaWxcIjpyZXR1cm4gTWF0aC5jZWlsKHQpO2Nhc2VcImZsb29yXCI6cmV0dXJuIE1hdGguZmxvb3IodCk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHJvdW5kaW5nTW9kZSBcIitlKX19ZnVuY3Rpb24gcXModCl7dmFyIGU9VXModCksbj1lWzBdLHI9ZVsxXTtyZXR1cm4gMT09PW4mJjE9PT1yfWZ1bmN0aW9uIEhzKHQsZSl7cmV0dXJuIHFzKHQpfHxxcyhlKX1mdW5jdGlvbiAkcyh0LGUsbixyLG8sYSl7ZCh0Lmxlbmd0aD09PWUucmFuayxmdW5jdGlvbigpe3JldHVyblwiTGVuZ3RoIG9mIGluU2hhcGUgKFwiK3QubGVuZ3RoK1wiKSBhbmQgcmFuayBvZiBkeSAoXCIrZS5yYW5rK1wiKSBtdXN0IG1hdGNoXCJ9KTt2YXIgaT10LHM9ZSx1PSExOzM9PT1lLnJhbmsmJih1PSEwLHM9ZS5hczREKDEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0pLGk9WzEsdFswXSx0WzFdLHRbMl1dKTt2YXIgbD1pWzNdLGM9cy5zaGFwZVszXTtkKDQ9PT1pLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGluU2hhcGUgbXVzdCBiZSBsZW5ndGggNCwgYnV0IGdvdCBsZW5ndGggXCIraS5sZW5ndGgrXCIuXCJ9KSxkKDQ9PT1zLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBkeSBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK3MucmFua30pLGQoND09PW4ucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK24ucmFua30pLGQobD09PW4uc2hhcGVbMl0sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBkZXB0aCBvZiBpbnB1dCAoXCIrbCtcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK24uc2hhcGVbMl0rXCIuXCJ9KSxkKGM9PT1uLnNoYXBlWzNdLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZGVwdGggb2Ygb3V0cHV0IChcIitjK1wiKSBtdXN0IG1hdGNoIG91dHB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK24uc2hhcGVbM10rXCIuXCJ9KSxudWxsIT1hJiZkKHcobyksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIithK1wiIGJ1dCBnb3QgcGFkIFwiK28rXCIuXCJ9KTt2YXIgaD1McyhpLG4uc2hhcGUsciwxLG8sYSkscD1EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgcj10LmNvbnYyZERlcklucHV0KHMsbixoKTtyZXR1cm4gZShbbixzXSkscn0se2R5NEQ6cyxmaWx0ZXI6bn0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLGk9ZVsxXTtyZXR1cm57ZHk0RDpmdW5jdGlvbigpe3JldHVybiBZcyh0LG4scixvLFwiTkhXQ1wiLDEsYSl9LGZpbHRlcjpmdW5jdGlvbigpe3JldHVybiBKcyh0LGksbi5zaGFwZSxyLG8sYSl9fX0pO3JldHVybiB1P3AuYXMzRChwLnNoYXBlWzFdLHAuc2hhcGVbMl0scC5zaGFwZVszXSk6cH1mdW5jdGlvbiBqcyh0LGUsbixyLG8sYSl7dmFyIGk9dDszPT09dC5yYW5rJiYoaT10LmFzNEQoMSx0LnNoYXBlWzBdLHQuc2hhcGVbMV0sdC5zaGFwZVsyXSkpO3ZhciBzPWU7Mz09PXMucmFuayYmKHM9ZS5hczREKDEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0pKSxkKDQ9PT1pLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3Qgc2hhcGUgXCIraS5zaGFwZStcIi5cIn0pLGQoND09PXMucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBkeSBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBzaGFwZSBcIitzLnNoYXBlK1wiLlwifSksZCg0PT09bi5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZmlsdGVyU2hhcGUgbXVzdCBiZSBsZW5ndGggNCwgYnV0IGdvdCBcIituK1wiLlwifSksZChpLnNoYXBlWzNdPT09blsyXSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBkZXB0aCBvZiBpbnB1dCBcIitpLnNoYXBlWzNdK1wiKSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGluIGZpbHRlciAoXCIrblsyXStcIi5cIn0pLGQocy5zaGFwZVszXT09PW5bM10sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZGVwdGggb2YgZHkgKFwiK3Muc2hhcGVbM10rXCIpIG11c3QgbWF0Y2ggb3V0cHV0IGRlcHRoIGZvciBmaWx0ZXIgKFwiK25bM10rXCIpLlwifSksbnVsbCE9YSYmZCh3KG8pLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK2ErXCIgYnV0IGdvdCBwYWQgXCIrbytcIi5cIn0pO3ZhciB1PUxzKGkuc2hhcGUsbixyLDEsbyxhKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbnYyZERlckZpbHRlcihpLHMsdSl9LHt4NEQ6aSxkeTREOnN9KX1mdW5jdGlvbiBLcyh0KXt2YXIgZT1mdW5jdGlvbih0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdD9bdCx0LHRdOjI9PT10Lmxlbmd0aD9bdFswXSx0WzFdLDFdOnR9KHQpLG49ZVswXSxyPWVbMV0sbz1lWzJdO3JldHVybiAxPT09biYmMT09PXImJjE9PT1vfXZhciBYcz1Bbih7Y29udjFkXzpmdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1vJiYobz1cIk5XQ1wiKSx2b2lkIDA9PT1hJiYoYT0xKTt2YXIgcz13bih0LFwieFwiLFwiY29udjFkXCIpLHU9d24oZSxcImZpbHRlclwiLFwiY29udjFkXCIpLGw9cyxjPSExOzI9PT1zLnJhbmsmJihjPSEwLGw9cy5hczNEKDEscy5zaGFwZVswXSxzLnNoYXBlWzFdKSksZCgzPT09bC5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MWQ6IGlucHV0IG11c3QgYmUgcmFuayAzLCBidXQgZ290IHJhbmsgXCIrbC5yYW5rK1wiLlwifSksZCgzPT09dS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MWQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgMywgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pLG51bGwhPWkmJmQodyhyKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjFkOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitpK1wiIGJ1dCBnb3QgcGFkIFwiK3IrXCIuXCJ9KSxkKGwuc2hhcGVbMl09PT11LnNoYXBlWzFdLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MWQ6IGRlcHRoIG9mIGlucHV0IChcIitsLnNoYXBlWzJdK1wiKSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIrdS5zaGFwZVsxXStcIi5cIn0pLGQoSHMobixhKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjFEOiBFaXRoZXIgc3RyaWRlIG9yIGRpbGF0aW9uIG11c3QgYmUgMS4gR290IHN0cmlkZSBcIituK1wiIGFuZCBkaWxhdGlvbiAnXCIrYStcIidcIn0pLGQoXCJOV0NcIj09PW8sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYxZDogZ290IGRhdGFGb3JtYXQgb2YgXCIrbytcIiBidXQgb25seSBOV0MgaXMgY3VycmVudGx5IHN1cHBvcnRlZC5cIn0pO3ZhciBoPXUuYXM0RCgxLHUuc2hhcGVbMF0sdS5zaGFwZVsxXSx1LnNoYXBlWzJdKSxwPWwuYXM0RChsLnNoYXBlWzBdLDEsbC5zaGFwZVsxXSxsLnNoYXBlWzJdKSxmPVlzKHAsaCxbMSxuXSxyLFwiTkhXQ1wiLFsxLGFdLGkpO3JldHVybiBjP2YuYXMyRChmLnNoYXBlWzJdLGYuc2hhcGVbM10pOmYuYXMzRChmLnNoYXBlWzBdLGYuc2hhcGVbMl0sZi5zaGFwZVszXSl9fSksWXM9QW4oe2NvbnYyZF86ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dm9pZCAwPT09byYmKG89XCJOSFdDXCIpLHZvaWQgMD09PWEmJihhPVsxLDFdKTt2YXIgcz13bih0LFwieFwiLFwiY29udjJkXCIpLHU9d24oZSxcImZpbHRlclwiLFwiY29udjJkXCIpLGw9cyxjPSExOzM9PT1zLnJhbmsmJihjPSEwLGw9cy5hczREKDEscy5zaGFwZVswXSxzLnNoYXBlWzFdLHMuc2hhcGVbMl0pKSxkKDQ9PT1sLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIitsLnJhbmsrXCIuXCJ9KSxkKDQ9PT11LnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSksbnVsbCE9aSYmZCh3KHIpLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmQ6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK2krXCIgYnV0IGdvdCBwYWQgXCIrcitcIi5cIn0pLGQobC5zaGFwZVszXT09PXUuc2hhcGVbMl0sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZDogZGVwdGggb2YgaW5wdXQgKFwiK2wuc2hhcGVbM10rXCIpIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIGZpbHRlciBcIit1LnNoYXBlWzJdK1wiLlwifSksZChIcyhuLGEpLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MkQ6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK24rXCIgYW5kIGRpbGF0aW9ucyAnXCIrYStcIidcIn0pLGQoXCJOSFdDXCI9PT1vLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmQ6IGdvdCBkYXRhRm9ybWF0IG9mIFwiK28rXCIgYnV0IG9ubHkgTkhXQyBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLlwifSk7dmFyIGg9THMobC5zaGFwZSx1LnNoYXBlLG4sYSxyLGkpLHA9RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5jb252MmQobCx1LGgpO3JldHVybiBlKFt1LGxdKSxufSx7eDpsLCRmaWx0ZXI6dX0sZnVuY3Rpb24odCxlKXt2YXIgbz1lLGk9b1swXSxzPW9bMV07cmV0dXJuIGQocXMoYSksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGdyYWRpZW50IG9mIGNvbnYyRDogZGlsYXRpb24gcmF0ZXMgZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIGluIGdyYWRpZW50cy4gR290IGRpbGF0aW9ucyAnXCIrYStcIidcIn0pLHt4OmZ1bmN0aW9uKCl7cmV0dXJuICRzKHMuc2hhcGUsdCxpLG4scil9LCRmaWx0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4ganMocyx0LGkuc2hhcGUsbixyKX19fSk7cmV0dXJuIGM/cC5hczNEKHAuc2hhcGVbMV0scC5zaGFwZVsyXSxwLnNoYXBlWzNdKTpwfX0pLFFzPUFuKHtjb252M2RfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2b2lkIDA9PT1vJiYobz1cIk5ESFdDXCIpLHZvaWQgMD09PWEmJihhPVsxLDEsMV0pO3ZhciBpPXduKHQsXCJ4XCIsXCJjb252M2RcIikscz13bihlLFwiZmlsdGVyXCIsXCJjb252M2RcIiksdT1pLGw9ITE7ND09PWkucmFuayYmKGw9ITAsdT1pLmFzNUQoMSxpLnNoYXBlWzBdLGkuc2hhcGVbMV0saS5zaGFwZVsyXSxpLnNoYXBlWzNdKSksZCg1PT09dS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2Q6IGlucHV0IG11c3QgYmUgcmFuayA1LCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSksZCg1PT09cy5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2Q6IGZpbHRlciBtdXN0IGJlIHJhbmsgNSwgYnV0IGdvdCByYW5rIFwiK3MucmFuaytcIi5cIn0pLGQodS5zaGFwZVs0XT09PXMuc2hhcGVbM10sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZDogZGVwdGggb2YgaW5wdXQgKFwiK3Uuc2hhcGVbNF0rXCIpIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIGZpbHRlciBcIitzLnNoYXBlWzNdK1wiLlwifSksZChmdW5jdGlvbih0LGUpe3JldHVybiBLcyh0KXx8S3MoZSl9KG4sYSksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzRDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrbitcIiBhbmQgZGlsYXRpb25zICdcIithK1wiJ1wifSksZChcIk5ESFdDXCI9PT1vLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2Q6IGdvdCBkYXRhRm9ybWF0IG9mIFwiK28rXCIgYnV0IG9ubHkgTkRIV0MgaXMgY3VycmVudGx5IHN1cHBvcnRlZC5cIn0pO3ZhciBjPVdzKHUuc2hhcGUscy5zaGFwZSxuLGEsciksaD1EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbj10LmNvbnYzZCh1LHMsYyk7cmV0dXJuIGUoW3Usc10pLG59LHt4OnUsJGZpbHRlcjpzfSxmdW5jdGlvbih0LGUpe2QoS3MoYSksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGdyYWRpZW50IG9mIGNvbnYzRDogZGlsYXRpb24gcmF0ZXMgZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIGluIGdyYWRpZW50cy4gR290IGRpbGF0aW9ucyAnXCIrYStcIidcIn0pO3ZhciBvPWVbMF0saT1lWzFdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIsbyl7ZCh0Lmxlbmd0aD09PWUucmFuayxmdW5jdGlvbigpe3JldHVyblwiTGVuZ3RoIG9mIGluU2hhcGUgKFwiK3QubGVuZ3RoK1wiKSBhbmQgcmFuayBvZiBkeSAoXCIrZS5yYW5rK1wiKSBtdXN0IG1hdGNoXCJ9KTt2YXIgYT10LGk9ZSxzPSExOzQ9PT1lLnJhbmsmJihzPSEwLGk9ZS5hczVEKDEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0sZS5zaGFwZVszXSksYT1bMSx0WzBdLHRbMV0sdFsyXSx0WzNdXSk7dmFyIHU9YVs0XSxsPWkuc2hhcGVbNF07ZCg1PT09YS5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlcklucHV0OiBpblNoYXBlIG11c3QgYmUgbGVuZ3RoIDUsIGJ1dCBnb3QgbGVuZ3RoIFwiK2EubGVuZ3RoK1wiLlwifSksZCg1PT09aS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJJbnB1dDogZHkgbXVzdCBiZSByYW5rIDUsIGJ1dCBnb3QgcmFuayBcIitpLnJhbmt9KSxkKDU9PT1uLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlcklucHV0OiBmaWx0ZXIgbXVzdCBiZSByYW5rIDUsIGJ1dCBnb3QgcmFuayBcIituLnJhbmt9KSxkKHU9PT1uLnNoYXBlWzNdLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJJbnB1dDogZGVwdGggb2YgaW5wdXQgKFwiK3UrXCIpIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIGZpbHRlciBcIituLnNoYXBlWzNdK1wiLlwifSksZChsPT09bi5zaGFwZVs0XSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVySW5wdXQ6IGRlcHRoIG9mIG91dHB1dCAoXCIrbCtcIikgbXVzdCBtYXRjaCBvdXRwdXQgZGVwdGggZm9yIGZpbHRlciBcIituLnNoYXBlWzRdK1wiLlwifSk7dmFyIGM9V3MoYSxuLnNoYXBlLHIsMSxvKSxoPUR0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb252M2REZXJJbnB1dChpLG4sYyl9LHtkeTVEOml9KTtyZXR1cm4gcz9oLmFzNEQoaC5zaGFwZVsxXSxoLnNoYXBlWzJdLGguc2hhcGVbM10saC5zaGFwZVs0XSk6aH0oby5zaGFwZSx0LGksbixyKX0sJGZpbHRlcjpmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyLG8pe3ZhciBhPXQ7ND09PXQucmFuayYmKGE9dC5hczVEKDEsdC5zaGFwZVswXSx0LnNoYXBlWzFdLHQuc2hhcGVbMl0sdC5zaGFwZVszXSkpO3ZhciBpPWU7ND09PWkucmFuayYmKGk9ZS5hczVEKDEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0sZS5zaGFwZVszXSkpLGQoNT09PWEucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVyRmlsdGVyOiBpbnB1dCBtdXN0IGJlIHJhbmsgNSwgYnV0IGdvdCBzaGFwZSBcIithLnNoYXBlK1wiLlwifSksZCg1PT09aS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJGaWx0ZXI6IGR5IG11c3QgYmUgcmFuayA1LCBidXQgZ290IHNoYXBlIFwiK2kuc2hhcGUrXCIuXCJ9KSxkKDU9PT1uLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVyRmlsdGVyOiBmaWx0ZXJTaGFwZSBtdXN0IGJlIGxlbmd0aCA1LCBidXQgZ290IFwiK24rXCIuXCJ9KSxkKGEuc2hhcGVbNF09PT1uWzNdLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJGaWx0ZXI6IGRlcHRoIG9mIGlucHV0IFwiK2Euc2hhcGVbNF0rXCIpIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggaW4gZmlsdGVyIChcIituWzNdK1wiLlwifSksZChpLnNoYXBlWzRdPT09bls0XSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVyRmlsdGVyOiBkZXB0aCBvZiBkeSAoXCIraS5zaGFwZVs0XStcIikgbXVzdCBtYXRjaCBvdXRwdXQgZGVwdGggZm9yIGZpbHRlciAoXCIrbls0XStcIikuXCJ9KTt2YXIgcz1XcyhhLnNoYXBlLG4sciwxLG8pO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuY29udjNkRGVyRmlsdGVyKGEsaSxzKX0se3g1RDphLGR5NUQ6aX0pfShvLHQsaS5zaGFwZSxuLHIpfX19KTtyZXR1cm4gbD9oLmFzNEQoaC5zaGFwZVsxXSxoLnNoYXBlWzJdLGguc2hhcGVbM10saC5zaGFwZVs0XSk6aH19KSxKcz1Bbih7Y29udjJkRGVyRmlsdGVyXzpqc30pLFpzPUFuKHtkZXB0aHdpc2VDb252MmRfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PW8mJihvPVwiTkhXQ1wiKSx2b2lkIDA9PT1hJiYoYT1bMSwxXSk7dmFyIHM9d24odCxcInhcIixcImRlcHRod2lzZUNvbnYyZFwiKSx1PXduKGUsXCJmaWx0ZXJcIixcImRlcHRod2lzZUNvbnYyZFwiKSxsPXMsYz0hMTszPT09cy5yYW5rJiYoYz0hMCxsPXMuYXM0RCgxLHMuc2hhcGVbMF0scy5zaGFwZVsxXSxzLnNoYXBlWzJdKSksZCg0PT09bC5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrbC5yYW5rK1wiLlwifSksZCg0PT09dS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pLGQobC5zaGFwZVszXT09PXUuc2hhcGVbMl0sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGRlcHRod2lzZUNvbnYyZDogbnVtYmVyIG9mIGlucHV0IGNoYW5uZWxzIChcIitsLnNoYXBlWzNdK1wiKSBtdXN0IG1hdGNoIHRoZSBpbkNoYW5uZWxzIGRpbWVuc2lvbiBpbiBmaWx0ZXIgXCIrdS5zaGFwZVsyXStcIi5cIn0pLG51bGw9PWEmJihhPVsxLDFdKSxkKEhzKG4sYSksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGRlcHRod2lzZUNvbnYyZDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrbitcIiBhbmQgZGlsYXRpb25zICdcIithK1wiJ1wifSksbnVsbCE9aSYmZCh3KHIpLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK2krXCIgYnV0IGdvdCBwYWQgXCIrcitcIi5cIn0pO3ZhciBoPUxzKGwuc2hhcGUsdS5zaGFwZSxuLGEscixpLCEwKSxwPUR0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBuPXQuZGVwdGh3aXNlQ29udjJEKGwsdSxoKTtyZXR1cm4gZShbbCx1XSksbn0se3g6bCwkZmlsdGVyOnV9LGZ1bmN0aW9uKHQsZSl7ZChxcyhhKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZ3JhZGllbnQgb2YgZGVwdGh3aXNlQ29udjJkOiBkaWxhdGlvbiByYXRlcyBncmVhdGVyIHRoYW4gMSBhcmUgbm90IHlldCBzdXBwb3J0ZWQuIEdvdCBkaWxhdGlvbnMgJ1wiK2ErXCInXCJ9KTt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyKXt2YXIgbz1lLGE9ITE7Mz09PWUucmFuayYmKGE9ITAsbz1lLmFzNEQoMSxlLnNoYXBlWzBdLGUuc2hhcGVbMV0sZS5zaGFwZVsyXSkpO3ZhciBpPUR0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5kZXB0aHdpc2VDb252MkREZXJJbnB1dChvLG4scil9LHtkeTREOm99KTtyZXR1cm4gYT9pLmFzM0QoaS5zaGFwZVsxXSxpLnNoYXBlWzJdLGkuc2hhcGVbM10pOml9KG4uc2hhcGUsdCxyLGgpfSwkZmlsdGVyOmZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPXQ7Mz09PXQucmFuayYmKG89dC5hczREKDEsdC5zaGFwZVswXSx0LnNoYXBlWzFdLHQuc2hhcGVbMl0pKTt2YXIgYT1lO3JldHVybiAzPT09YS5yYW5rJiYoYT1lLmFzNEQoMSxlLnNoYXBlWzBdLGUuc2hhcGVbMV0sZS5zaGFwZVsyXSkpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5kZXB0aHdpc2VDb252MkREZXJGaWx0ZXIobyxhLHIpfSx7eDREOm8sZHk0RDphfSl9KG4sdCxyLnNoYXBlLGgpfX19KTtyZXR1cm4gYz9wLmFzM0QocC5zaGFwZVsxXSxwLnNoYXBlWzJdLHAuc2hhcGVbM10pOnB9fSksdHU9QW4oe3NlcGFyYWJsZUNvbnYyZF86ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dm9pZCAwPT09YSYmKGE9WzEsMV0pLHZvaWQgMD09PWkmJihpPVwiTkhXQ1wiKTt2YXIgcz13bih0LFwieFwiLFwic2VwYXJhYmxlQ29udjJkXCIpLHU9d24oZSxcImRlcHRod2lzZUZpbHRlclwiLFwic2VwYXJhYmxlQ29udjJkXCIpLGw9d24obixcInBvaW50d2lzZUZpbHRlclwiLFwic2VwYXJhYmxlQ29udjJkXCIpLGM9cyxoPSExO2lmKDM9PT1zLnJhbmsmJihoPSEwLGM9cy5hczREKDEscy5zaGFwZVswXSxzLnNoYXBlWzFdLHMuc2hhcGVbMl0pKSxcIk5DSFdcIj09PWkpdGhyb3cgbmV3IEVycm9yKFwic2VwYXJhYmxlQ29udjJkIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IGRhdGFGb3JtYXQgTkNIVzsgb25seSBOSFdDIGlzIHN1cHBvcnRlZFwiKTtkKDQ9PT1jLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIitjLnJhbmsrXCIuXCJ9KSxkKDQ9PT11LnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogZGVwdGh3aXNlIGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pLGQoND09PWwucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiBwb2ludHdpc2UgZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSksZCgxPT09bC5zaGFwZVswXSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiB0aGUgZmlyc3QgZGltZW5zaW9uIG9mIHBvaW50d2lzZSBmaWx0ZXIgIG11c3QgYmUgMSwgYnV0IGdvdCBcIitsLnNoYXBlWzBdK1wiLlwifSksZCgxPT09bC5zaGFwZVsxXSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiB0aGUgc2Vjb25kIGRpbWVuc2lvbiBvZiBwb2ludHdpc2UgZmlsdGVyIG11c3QgYmUgMSwgYnV0IGdvdCBcIitsLnNoYXBlWzFdK1wiLlwifSk7dmFyIHA9dS5zaGFwZVsyXSxmPXUuc2hhcGVbM107ZChsLnNoYXBlWzJdPT09cCpmLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IHRoZSB0aGlyZCBkaW1lbnNpb24gb2YgcG9pbnR3aXNlIGZpbHRlciBtdXN0IGJlIFwiK3AqZitcIiwgYnV0IGdvdCBcIitsLnNoYXBlWzJdK1wiLlwifSk7dmFyIHY9WnMoYyx1LHIsbyxpLGEpLG09WXModixsLDEsXCJ2YWxpZFwiLGkpO3JldHVybiBoP20uYXMzRChtLnNoYXBlWzFdLG0uc2hhcGVbMl0sbS5zaGFwZVszXSk6bX19KSxldT1Bbih7Y29udjJkVHJhbnNwb3NlXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuICRzKG4sd24odCxcInhcIixcImNvbnYyZFRyYW5zcG9zZVwiKSx3bihlLFwiZmlsdGVyXCIsXCJjb252MmRUcmFuc3Bvc2VcIikscixvLGEpfX0pO3ZhciBudT1Bbih7bWF0TXVsXzpmdW5jdGlvbih0LGUsbixyKXt2YXIgbzt2b2lkIDA9PT1uJiYobj0hMSksdm9pZCAwPT09ciYmKHI9ITEpO3ZhciBhPXduKHQsXCJhXCIsXCJtYXRNdWxcIiksaT13bihlLFwiYlwiLFwibWF0TXVsXCIpO289UnQoYSxpKSxhPW9bMF0saT1vWzFdO3ZhciBzPW4/YS5zaGFwZVthLnJhbmstMl06YS5zaGFwZVthLnJhbmstMV0sdT1yP2kuc2hhcGVbaS5yYW5rLTFdOmkuc2hhcGVbaS5yYW5rLTJdLGw9bj9hLnNoYXBlW2EucmFuay0xXTphLnNoYXBlW2EucmFuay0yXSxjPXI/aS5zaGFwZVtpLnJhbmstMl06aS5zaGFwZVtpLnJhbmstMV0saD1hLnNoYXBlLnNsaWNlKDAsLTIpLHA9aS5zaGFwZS5zbGljZSgwLC0yKSxmPXkoaCksdj15KHApO2QoYS5yYW5rPj0yJiZpLnJhbms+PTImJmEucmFuaz09PWkucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF0TXVsOiBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsgb2YgYXQgbGVhc3QgMiwgZ290IHJhbmtzIFwiK2EucmFuaytcIiBhbmQgXCIraS5yYW5rK1wiLlwifSksZCh4KGgscCksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1hdE11bDogb3V0ZXIgZGltZW5zaW9ucyAoXCIraCtcIikgYW5kIChcIitwK1wiKSBvZiBUZW5zb3JzIHdpdGggc2hhcGVzIFwiK2Euc2hhcGUrXCIgYW5kIFwiK2kuc2hhcGUrXCIgbXVzdCBtYXRjaC5cIn0pLGQocz09PXUsZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1hdE11bDogaW5uZXIgc2hhcGVzIChcIitzK1wiKSBhbmQgKFwiK3UrXCIpIG9mIFRlbnNvcnMgd2l0aCBzaGFwZXMgXCIrYS5zaGFwZStcIiBhbmQgXCIraS5zaGFwZStcIiBhbmQgdHJhbnNwb3NlQT1cIituK1wiIGFuZCB0cmFuc3Bvc2VCPVwiK3IrXCIgbXVzdCBtYXRjaC5cIn0pO3ZhciBtPWEuc2hhcGUuc2xpY2UoMCwtMikuY29uY2F0KFtsLGNdKSxnPW4/YS5hczNEKGYscyxsKTphLmFzM0QoZixsLHMpLHc9cj9pLmFzM0QodixjLHUpOmkuYXMzRCh2LHUsYyk7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBvPXQuYmF0Y2hNYXRNdWwoZyx3LG4scik7cmV0dXJuIGUoW2csd10pLG99LHskYTpnLCRiOnd9LGZ1bmN0aW9uKHQsZSl7dmFyIG89ZSxhPW9bMF0saT1vWzFdO3JldHVybiBufHxyPyFuJiZyP3skYTpmdW5jdGlvbigpe3JldHVybiB0Lm1hdE11bChpLCExLCExKX0sJGI6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tYXRNdWwoYSwhMCwhMSl9fTpuJiYhcj97JGE6ZnVuY3Rpb24oKXtyZXR1cm4gaS5tYXRNdWwodCwhMSwhMCl9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIGEubWF0TXVsKHQsITEsITEpfX06eyRhOmZ1bmN0aW9uKCl7cmV0dXJuIGkubWF0TXVsKHQsITAsITApfSwkYjpmdW5jdGlvbigpe3JldHVybiB0Lm1hdE11bChhLCEwLCEwKX19OnskYTpmdW5jdGlvbigpe3JldHVybiB0Lm1hdE11bChpLCExLCEwKX0sJGI6ZnVuY3Rpb24oKXtyZXR1cm4gYS5tYXRNdWwodCwhMCwhMSl9fX0pLnJlc2hhcGUobSl9fSkscnU9QW4oe2RvdF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwidDFcIixcImRvdFwiKSxyPXduKGUsXCJ0MlwiLFwiZG90XCIpO2QoISgxIT09bi5yYW5rJiYyIT09bi5yYW5rfHwxIT09ci5yYW5rJiYyIT09ci5yYW5rKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZG90OiBpbnB1dHMgbXVzdCBhbGwgYmUgcmFuayAxIG9yIDIsIGJ1dCBnb3QgcmFua3MgXCIrbi5yYW5rK1wiIGFuZCBcIityLnJhbmsrXCIuXCJ9KTt2YXIgbz0xPT09bi5yYW5rP24uc2l6ZTpuLnNoYXBlWzFdLGE9MT09PXIucmFuaz9yLnNpemU6ci5zaGFwZVswXTtyZXR1cm4gZChvPT09YSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZG90OiBpbm5lciBkaW1lbnNpb25zIG9mIGlucHV0cyBtdXN0IG1hdGNoLCBidXQgZ290IFwiK28rXCIgYW5kIFwiK2ErXCIuXCJ9KSwxPT09bi5yYW5rJiYxPT09ci5yYW5rP24uYXMyRCgxLC0xKS5tYXRNdWwoci5hczJEKC0xLDEpKS5hc1NjYWxhcigpOjE9PT1uLnJhbmsmJjI9PT1yLnJhbms/bi5hczJEKDEsLTEpLm1hdE11bChyLmFzMkQoci5zaGFwZVswXSxyLnNoYXBlWzFdKSkuYXMxRCgpOjI9PT1uLnJhbmsmJjE9PT1yLnJhbms/bi5tYXRNdWwoci5hczJEKC0xLDEpKS5hczFEKCk6bi5tYXRNdWwoci5hczJEKHIuc2hhcGVbMF0sci5zaGFwZVsxXSkpfX0pLG91PUFuKHtvdXRlclByb2R1Y3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcInYxXCIsXCJvdXRlclByb2R1Y3RcIikscj13bihlLFwidjJcIixcIm91dGVyUHJvZHVjdFwiKTtyZXR1cm4gZCgxPT09bi5yYW5rJiYxPT09ci5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBvdXRlclByb2R1Y3Q6IGlucHV0cyBtdXN0IGJlIHJhbmsgMSwgYnV0IGdvdCByYW5rcyBcIituLnJhbmsrXCIgYW5kIFwiK3IucmFuaytcIi5cIn0pLG4uYXMyRCgtMSwxKS5tYXRNdWwoci5hczJEKDEsLTEpKX19KTt2YXIgYXU9QW4oe3JldmVyc2VfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcInhcIixcInJldmVyc2VcIik7aWYoMD09PW4ucmFuaylyZXR1cm4gbi5jbG9uZSgpO3ZhciByPU4oZSxuLnNoYXBlKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJldmVyc2UobixyKX0seyR4Om59LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LnJldmVyc2Uocil9fX0pLnJlc2hhcGVBcyhuKX19KSxpdT1Bbih7cmV2ZXJzZTFkXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwicmV2ZXJzZVwiKTtyZXR1cm4gZCgxPT09ZS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiByZXZlcnNlMUQ6IHggbXVzdCBiZSByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2UucmFuaytcIi5cIn0pLGF1KGUsMCl9fSksc3U9QW4oe3JldmVyc2UyZF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwieFwiLFwicmV2ZXJzZVwiKTtyZXR1cm4gZCgyPT09bi5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiByZXZlcnNlMkQ6IHggbXVzdCBiZSByYW5rIDIgYnV0IGdvdCByYW5rIFwiK24ucmFuaytcIi5cIn0pLGF1KG4sZSl9fSksdXU9QW4oe3JldmVyc2UzZF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwieFwiLFwicmV2ZXJzZVwiKTtyZXR1cm4gZCgzPT09bi5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiByZXZlcnNlM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIFwiK24ucmFuaytcIi5cIn0pLGF1KG4sZSl9fSksbHU9QW4oe3JldmVyc2U0ZF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwieFwiLFwicmV2ZXJzZVwiKTtyZXR1cm4gZCg0PT09bi5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiByZXZlcnNlNEQ6IHggbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK24ucmFuaytcIi5cIn0pLGF1KG4sZSl9fSk7ZnVuY3Rpb24gY3UodCxlLG4scixvLGEpe3ZhciBpPXduKHQsXCJ4XCIsXCJtYXhQb29sXCIpLHM9aSx1PSExOzM9PT1pLnJhbmsmJih1PSEwLHM9aS5hczREKDEsaS5zaGFwZVswXSxpLnNoYXBlWzFdLGkuc2hhcGVbMl0pKSxudWxsPT1yJiYocj1bMSwxXSksZCg0PT09cy5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrcy5yYW5rK1wiLlwifSksZChIcyhuLHIpLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIituK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK3IrXCInXCJ9KSxudWxsIT1hJiZkKHcobyksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2w6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK2ErXCIgYnV0IGdvdCBwYWQgXCIrbytcIi5cIn0pO3ZhciBsPVBzKHMuc2hhcGUsZSxuLHIsbyxhKSxjPUR0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBuPXQubWF4UG9vbChzLGwpO3JldHVybiBlKFtzLG5dKSxufSx7eDpzfSxmdW5jdGlvbih0LGEpe3ZhciBpPWFbMF0scz1hWzFdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkscyl7dmFyIHU9d24odCxcImR5XCIsXCJtYXhQb29sQmFja3Byb3BcIiksbD13bihlLFwiaW5wdXRcIixcIm1heFBvb2xCYWNrcHJvcFwiKSxjPXduKG4sXCJvdXRwdXRcIixcIm1heFBvb2xCYWNrcHJvcFwiKTtkKGwucmFuaz09PXUucmFuayxmdW5jdGlvbigpe3JldHVyblwiUmFuayBvZiBpbnB1dCAoXCIrbC5yYW5rK1wiKSBkb2VzIG5vdCBtYXRjaCByYW5rIG9mIGR5IChcIit1LnJhbmsrXCIpXCJ9KSxudWxsPT1hJiYoYT1bMSwxXSksZChIcyhvLGEpLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sQmFja1Byb3A6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK28rXCIgYW5kIGRpbGF0aW9ucyAnXCIrYStcIidcIn0pLGQoND09PXUucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbEJhY2twcm9wOiBkeSBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSksZCg0PT09bC5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sQmFja3Byb3A6IGlucHV0IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIitsLnJhbmsrXCIuXCJ9KSxudWxsIT1zJiZkKHcoaSksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2xCYWNrcHJvcDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIrcytcIiBidXQgZ290IHBhZCBcIitpK1wiLlwifSk7dmFyIGg9UHMobC5zaGFwZSxyLG8sYSxpLHMpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQubWF4UG9vbEJhY2twcm9wKHUsbCxjLGgpfSx7JGR5OnUsJGlucHV0Omx9KX0odCxpLHMsZSxuLHIsbyl9fX0pO3JldHVybiB1P2MuYXMzRChjLnNoYXBlWzFdLGMuc2hhcGVbMl0sYy5zaGFwZVszXSk6Y31mdW5jdGlvbiBodSh0LGUsbixyLG8sYSl7dmFyIGk9d24odCxcInhcIixcImF2Z1Bvb2xcIixcImZsb2F0MzJcIik7bnVsbD09ciYmKHI9WzEsMV0pLGQoSHMobixyKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrbitcIiBhbmQgZGlsYXRpb25zICdcIityK1wiJ1wifSk7dmFyIHM9aSx1PSExOzM9PT1pLnJhbmsmJih1PSEwLHM9aS5hczREKDEsaS5zaGFwZVswXSxpLnNoYXBlWzFdLGkuc2hhcGVbMl0pKSxkKDQ9PT1zLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGF2Z1Bvb2w6IHggbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK3MucmFuaytcIi5cIn0pLG51bGwhPWEmJmQodyhvKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIrYStcIiBidXQgZ290IHBhZCBcIitvK1wiLlwifSk7dmFyIGw9UHMocy5zaGFwZSxlLG4scixvLGEpLGM9RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmF2Z1Bvb2wocyxsKX0se3g6c30sZnVuY3Rpb24odCl7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBpPXduKHQsXCJkeVwiLFwiYXZnUG9vbEJhY2twcm9wXCIpLHM9d24oZSxcImlucHV0XCIsXCJhdmdQb29sQmFja3Byb3BcIik7ZChzLnJhbms9PT1pLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIlJhbmsgb2YgaW5wdXQgKFwiK3MucmFuaytcIikgZG9lcyBub3QgbWF0Y2ggcmFuayBvZiBkeSAoXCIraS5yYW5rK1wiKVwifSksbnVsbD09byYmKG89WzEsMV0pLGQoSHMocixvKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbEJhY2twcm9wOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIityK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK28rXCInXCJ9KTt2YXIgdT1zLGw9aSxjPSExOzM9PT1zLnJhbmsmJihjPSEwLHU9cy5hczREKDEscy5zaGFwZVswXSxzLnNoYXBlWzFdLHMuc2hhcGVbMl0pLGw9aS5hczREKDEsaS5zaGFwZVswXSxpLnNoYXBlWzFdLGkuc2hhcGVbMl0pKSxkKDQ9PT1sLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGF2Z1Bvb2xCYWNrcHJvcDogZHkgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK2wucmFuaytcIi5cIn0pLGQoND09PXUucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbEJhY2twcm9wOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSk7dmFyIGg9UHModS5zaGFwZSxuLHIsbyxhKSxwPUR0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5hdmdQb29sQmFja3Byb3AobCx1LGgpfSx7ZHk0RDpsLGlucHV0NEQ6dX0pO3JldHVybiBjP3AuYXMzRChwLnNoYXBlWzFdLHAuc2hhcGVbMl0scC5zaGFwZVszXSk6cH0odCxzLGUsbixyLG8pfX19KTtyZXR1cm4gYz1jLmNhc3QoaS5kdHlwZSksdT9jLmFzM0QoYy5zaGFwZVsxXSxjLnNoYXBlWzJdLGMuc2hhcGVbM10pOmN9dmFyIHB1PUFuKHttYXhQb29sXzpmdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiBjdSh0LGUsbiwxLHIsbyl9fSksZnU9QW4oe2F2Z1Bvb2xfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIGh1KHQsZSxuLDEscixvKX19KSxkdT1Bbih7cG9vbF86ZnVuY3Rpb24odCxlLG4scixvLGEpe251bGw9PW8mJihvPVsxLDFdKSxudWxsPT1hJiYoYT0xKSwwPT09ciYmKHI9XCJ2YWxpZFwiKTt2YXIgaT13bih0LFwieFwiLFwibWF4UG9vbFwiKSxzPWksdT0hMTszPT09aS5yYW5rJiYodT0hMCxzPWkuYXM0RCgxLGkuc2hhcGVbMF0saS5zaGFwZVsxXSxpLnNoYXBlWzJdKSksZChIcyhhLG8pLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBwb29sOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIithK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK28rXCInXCJ9KTt2YXIgbCxjPVBzKHMuc2hhcGUsZSxhLG8sciksaD1bYy5kaWxhdGlvbkhlaWdodCxjLmRpbGF0aW9uV2lkdGhdO2w9XCJzYW1lXCI9PT1yP2Z1bmN0aW9uKHQsZSl7dmFyIG49dC5tYXAoZnVuY3Rpb24odCxuKXtyZXR1cm4gdCsodC0xKSooZVtuXS0xKX0pLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC0xfSkscj1uLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5mbG9vcih0LzIpfSksbz1uLm1hcChmdW5jdGlvbih0LGUpe3JldHVybiB0LXJbZV19KTtyZXR1cm4gbi5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm5bcltlXSxvW2VdXX0pfShbYy5maWx0ZXJIZWlnaHQsYy5maWx0ZXJXaWR0aF0saCk6W1swLDBdLFswLDBdXTt2YXIgcD0xPT09aFswXSYmMT09PWhbMV0sZj1mdW5jdGlvbih0LGUsbil7dmFyIHI9bi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHRbMF19KSxvPW4ubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0WzFdfSksYT10LmNvbmNhdChyLG8pLGk9ZS5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm4odC1hW2VdJXQpJXR9KSxzPW8ubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQraVtlXX0pLHU9ZS5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm5bcltlXSxzW2VdXX0pLGw9ZS5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm5bMCxpW2VdXX0pO3JldHVyblt1LGxdfShbYy5pbkhlaWdodCxjLmluV2lkdGhdLGgsbCksdj1mWzBdLG09ZlsxXSxnPXA/cjpcInZhbGlkXCIseT1wP3M6JHIocyxoLHYpLHg9KFwiYXZnXCI9PT1uP2Z1bmN0aW9uKCl7cmV0dXJuIGh1KHksZSxhLDEsZyl9OmZ1bmN0aW9uKCl7cmV0dXJuIGN1KHksZSxhLDEsZyl9KSgpLHc9cD94OklyKHgsaCxtKTtyZXR1cm4gdT93LmFzM0Qody5zaGFwZVsxXSx3LnNoYXBlWzJdLHcuc2hhcGVbM10pOnd9fSk7dmFyIHZ1PUFuKHtzbGljZV86ZnVuY3Rpb24odCxlLG4pe3ZhciByLG8sYT13bih0LFwieFwiLFwic2xpY2VcIik7aWYoMD09PWEucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJTbGljaW5nIHNjYWxhciBpcyBub3QgcG9zc2libGVcIik7cj1cIm51bWJlclwiPT10eXBlb2YgZT9bZV0uY29uY2F0KG5ldyBBcnJheShhLnJhbmstMSkuZmlsbCgwKSk6ZS5sZW5ndGg8YS5yYW5rP2UuY29uY2F0KG5ldyBBcnJheShhLnJhbmstZS5sZW5ndGgpLmZpbGwoMCkpOmUuc2xpY2UoKSxvPShvPW51bGw9PW4/bmV3IEFycmF5KGEucmFuaykuZmlsbCgtMSk6XCJudW1iZXJcIj09dHlwZW9mIG4/W25dLmNvbmNhdChuZXcgQXJyYXkoYS5yYW5rLTEpLmZpbGwoLTEpKTpuLmxlbmd0aDxhLnJhbms/bi5jb25jYXQobmV3IEFycmF5KGEucmFuay1uLmxlbmd0aCkuZmlsbCgtMSkpOm4pLm1hcChmdW5jdGlvbih0LGUpe3JldHVybiB0Pj0wP3Q6KGQoLTE9PT10LGZ1bmN0aW9uKCl7cmV0dXJuXCJCYWQgdmFsdWUgaW4gc2l6ZVwifSksYS5zaGFwZVtlXS1yW2VdKX0pLGZ1bmN0aW9uKHQsZSxuKXtkKHQucmFuaz09PWUubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBzbGljZVwiK3QucmFuaytcIkQ6IExlbmd0aCBvZiBiZWdpbiBcIitlK1wiIG11c3QgbWF0Y2ggdGhlIHJhbmsgb2YgdGhlIGFycmF5IChcIit0LnJhbmsrXCIpLlwifSksZCh0LnJhbms9PT1uLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gc2xpY2VcIit0LnJhbmsrXCJEOiBMZW5ndGggb2Ygc2l6ZSBcIituK1wiIG11c3QgbWF0Y2ggdGhlIHJhbmsgb2YgdGhlIGFycmF5IChcIit0LnJhbmsrXCIpLlwifSk7Zm9yKHZhciByPWZ1bmN0aW9uKHIpe2QoZVtyXStuW3JdPD10LnNoYXBlW3JdLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBzbGljZVwiK3QucmFuaytcIkQ6IGJlZ2luW1wiK3IrXCJdICsgc2l6ZVtcIityK1wiXSAoXCIrKGVbcl0rbltyXSkrXCIpIHdvdWxkIG92ZXJmbG93IGlucHV0LnNoYXBlW1wiK3IrXCJdIChcIit0LnNoYXBlW3JdK1wiKVwifSl9LG89MDtvPHQucmFuazsrK28pcihvKX0oYSxyLG8pO3ZhciBpPWEuc2hhcGU7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5zbGljZShhLHIsbyl9LHskeDphfSxmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5yYW5rO24rKyllLnB1c2goW3Jbbl0saVtuXS1yW25dLW9bbl1dKTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5wYWQoZSl9fX0pfX0pLG11PUFuKHtzbGljZTFkXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9d24odCxcInhcIixcInNsaWNlMWRcIik7cmV0dXJuIGQoMT09PXIucmFuayxmdW5jdGlvbigpe3JldHVyblwic2xpY2UxZCBleHBlY3RzIGEgcmFuay0xIHRlbnNvciwgYnV0IGdvdCBhIHJhbmstXCIrci5yYW5rK1wiIHRlbnNvclwifSksdnUocixbZV0sW25dKX19KSxndT1Bbih7c2xpY2UyZF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPXduKHQsXCJ4XCIsXCJzbGljZTJkXCIpO3JldHVybiBkKDI9PT1yLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cInNsaWNlMmQgZXhwZWN0cyBhIHJhbmstMiB0ZW5zb3IsIGJ1dCBnb3QgYSByYW5rLVwiK3IucmFuaytcIiB0ZW5zb3JcIn0pLHZ1KHIsZSxuKX19KSx5dT1Bbih7c2xpY2UzZF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPXduKHQsXCJ4XCIsXCJzbGljZTNkXCIpO3JldHVybiBkKDM9PT1yLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cInNsaWNlM2QgZXhwZWN0cyBhIHJhbmstMyB0ZW5zb3IsIGJ1dCBnb3QgYSByYW5rLVwiK3IucmFuaytcIiB0ZW5zb3JcIn0pLHZ1KHIsZSxuKX19KSx4dT1Bbih7c2xpY2U0ZF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPXduKHQsXCJ4XCIsXCJzbGljZTRkXCIpO3JldHVybiBkKDQ9PT1yLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cInNsaWNlNGQgZXhwZWN0cyBhIHJhbmstNCB0ZW5zb3IsIGJ1dCBnb3QgYSByYW5rLVwiK3IucmFuaytcIiB0ZW5zb3JcIn0pLHZ1KHIsZSxuKX19KTtmdW5jdGlvbiB3dSh0LGUsbixyLG8pe3JldHVybiBlLnJhbms8bi5yYW5rJiYoZT1lLnJlc2hhcGUoZW4oZS5zaGFwZSxyKSkpLHQucmFuazxuLnJhbmsmJih0PXQucmVzaGFwZShlbih0LnNoYXBlLHIpKSkseyR4OmZ1bmN0aW9uKCl7dmFyIHI9dC5tdWwobi5lcXVhbChlKS5jYXN0KHQuZHR5cGUpKTtyZXR1cm4gbnVsbD09bz9yOnIudHJhbnNwb3NlKG8pfX19dmFyIGJ1PUFuKHthbGxfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9d24odCxcInhcIixcImFsbFwiLFwiYm9vbFwiKSxvPU4oZSxyLnNoYXBlKSxhPW8saT1ybihhLHIucmFuayk7bnVsbCE9aSYmKHI9ci50cmFuc3Bvc2UoaSksYT1hbihhLmxlbmd0aCxyLnJhbmspKTt2YXIgcz1EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuYWxsKHIsYSl9LHskeDpyfSk7aWYobil7dmFyIHU9ZW4ocy5zaGFwZSxvKTtyZXR1cm4gcy5yZXNoYXBlKHUpfXJldHVybiBzfX0pLEN1PUFuKHthbnlfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9d24odCxcInhcIixcImFueVwiLFwiYm9vbFwiKSxvPU4oZSxyLnNoYXBlKSxhPW8saT1ybihhLHIucmFuayk7bnVsbCE9aSYmKHI9ci50cmFuc3Bvc2UoaSksYT1hbihhLmxlbmd0aCxyLnJhbmspKTt2YXIgcz1EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuYW55KHIsYSl9LHskeDpyfSk7aWYobil7dmFyIHU9ZW4ocy5zaGFwZSxvKTtyZXR1cm4gcy5yZXNoYXBlKHUpfXJldHVybiBzfX0pLEV1PUFuKHthcmdNYXhfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9MCk7dmFyIG49d24odCxcInhcIixcImFyZ01heFwiKTtudWxsPT1lJiYoZT0wKTt2YXIgcj1OKGUsbi5zaGFwZSksbz1ybihyLG4ucmFuayk7cmV0dXJuIG51bGwhPW8mJihuPW4udHJhbnNwb3NlKG8pLHI9YW4oci5sZW5ndGgsbi5yYW5rKSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG89dC5hcmdNYXgobixyWzBdKTtyZXR1cm4gZShbbl0pLG99LHskeDpufSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKG4pfX19KX19KSxSdT1Bbih7YXJnTWluXzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPTApO3ZhciBuPXduKHQsXCJ4XCIsXCJhcmdNaW5cIik7bnVsbD09ZSYmKGU9MCk7dmFyIHI9TihlLG4uc2hhcGUpLG89cm4ocixuLnJhbmspO3JldHVybiBudWxsIT1vJiYobj1uLnRyYW5zcG9zZShvKSxyPWFuKHIubGVuZ3RoLG4ucmFuaykpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBvPXQuYXJnTWluKG4sclswXSk7cmV0dXJuIGUoW25dKSxvfSx7JHg6bn0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbihuKX19fSl9fSksU3U9QW4oe2xvZ1N1bUV4cF86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj13bih0LFwieFwiLFwibG9nU3VtRXhwXCIpLG89TihlLHIuc2hhcGUpLGE9ci5tYXgobywhMCksaT1yLnN1YihhKS5leHAoKS5zdW0obykubG9nKCkscz1hLnJlc2hhcGUoaS5zaGFwZSkuYWRkKGkpO2lmKG4pe3ZhciB1PWVuKHMuc2hhcGUsbyk7cmV0dXJuIHMucmVzaGFwZSh1KX1yZXR1cm4gc319KSxOdT1Bbih7bWF4XzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpO3ZhciByPXduKHQsXCJ4XCIsXCJtYXhcIiksbz1yLGE9TihlLHIuc2hhcGUpLGk9YSxzPXJuKGksci5yYW5rKTtudWxsIT1zJiYocj1yLnRyYW5zcG9zZShzKSxpPWFuKGkubGVuZ3RoLHIucmFuaykpO3ZhciB1PUR0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBuPXQubWF4KHIsaSk7cmV0dXJuIGUoW28sbl0pLG59LHskeDpyfSxmdW5jdGlvbih0LGUpe3JldHVybiB3dSh0LGVbMV0sZVswXSxhLHMpfSk7aWYobil7dmFyIGw9ZW4odS5zaGFwZSxhKTt1PXUucmVzaGFwZShsKX1yZXR1cm4gdX19KSxrdT1Bbih7bWVhbl86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj13bih0LFwieFwiLFwibWVhblwiKSxvPU4oZSxyLnNoYXBlKSxhPXkodG4oci5zaGFwZSxvKVsxXSk7cmV0dXJuIGtuKGZ1bmN0aW9uKHQpe3ZhciByPUJuKGEpO3JldHVybnt2YWx1ZTooci5kdHlwZT09PXQuZHR5cGU/dDp0LmNhc3Qoci5kdHlwZSkpLmRpdihyKS5zdW0oZSxuKSxncmFkRnVuYzpmdW5jdGlvbihlKXt2YXIgbj10LnNoYXBlLnNsaWNlKCk7cmV0dXJuIG8uZm9yRWFjaChmdW5jdGlvbih0KXtuW3RdPTF9KSxlLnJlc2hhcGUobikubXVsKEduKHQuc2hhcGUsXCJmbG9hdDMyXCIpKS5kaXYoYSl9fX0pKHIpfX0pLEl1PUFuKHttaW5fOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9d24odCxcInhcIixcIm1pblwiKSxvPXIsYT1OKGUsci5zaGFwZSksaT1hLHM9cm4oaSxyLnJhbmspO251bGwhPXMmJihyPXIudHJhbnNwb3NlKHMpLGk9YW4oaS5sZW5ndGgsci5yYW5rKSk7dmFyIHU9RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5taW4ocixpKTtyZXR1cm4gZShbbyxuXSksbn0seyR4OnJ9LGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHd1KHQsZVsxXSxlWzBdLGEscyl9KTtpZihuKXt2YXIgbD1lbih1LnNoYXBlLGEpO3U9dS5yZXNoYXBlKGwpfXJldHVybiB1fX0pLEF1PUFuKHttb21lbnRzXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpO3ZhciByPU4oZSwodD13bih0LFwieFwiLFwibW9tZW50c1wiKSkuc2hhcGUpLG89dC5tZWFuKHIsbiksYT1vLnNoYXBlO258fChhPWVuKG8uc2hhcGUscikpO3ZhciBpPXQudG9GbG9hdCgpLnN1YihvLnJlc2hhcGUoYSkpLnNxdWFyZSgpO3JldHVybnttZWFuOm8sdmFyaWFuY2U6aS5tZWFuKHIsbil9fX0pLFR1PUFuKHtzdW1fOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9d24odCxcInhcIixcInN1bVwiKTtcImJvb2xcIj09PXIuZHR5cGUmJihyPXIudG9JbnQoKSk7dmFyIG89TihlLHIuc2hhcGUpO3JldHVybiBrbihmdW5jdGlvbih0KXt2YXIgZT1ybihvLHQucmFuaykscj1vLGE9dDtudWxsIT1lJiYoYT10LnRyYW5zcG9zZShlKSxyPWFuKHIubGVuZ3RoLHQucmFuaykpO3ZhciBpPUR0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5zdW0oYSxyKX0se3Blcm11dGVkWDphfSk7aWYobil7dmFyIHM9ZW4oaS5zaGFwZSxvKTtpPWkucmVzaGFwZShzKX1yZXR1cm57dmFsdWU6aSxncmFkRnVuYzpmdW5jdGlvbihlKXt2YXIgbj10LnNoYXBlLnNsaWNlKCk7cmV0dXJuIG8uZm9yRWFjaChmdW5jdGlvbih0KXtuW3RdPTF9KSxlLnJlc2hhcGUobikubXVsKEduKHQuc2hhcGUsXCJmbG9hdDMyXCIpKX19fSkocil9fSksRHU9QW4oe3Byb2RfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9d24odCxcInhcIixcInByb2RcIik7XCJib29sXCI9PT1yLmR0eXBlJiYocj1yLnRvSW50KCkpO3ZhciBvPU4oZSxyLnNoYXBlKSxhPXJuKG8sci5yYW5rKSxpPW8scz1yO251bGwhPWEmJihzPXIudHJhbnNwb3NlKGEpLGk9YW4oaS5sZW5ndGgsci5yYW5rKSk7dmFyIHU9RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnByb2QocyxpKX0se3Blcm11dGVkWDpzfSk7aWYobil7dmFyIGw9ZW4odS5zaGFwZSxvKTt1PXUucmVzaGFwZShsKX1yZXR1cm4gdX19KTt2YXIgT3U9QW4oe2VxdWFsXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9d24odCxcImFcIixcImVxdWFsXCIpLG89d24oZSxcImJcIixcImVxdWFsXCIpO3JldHVybiBuPVJ0KHIsbykscj1uWzBdLG89blsxXSxzbyhyLnNoYXBlLG8uc2hhcGUpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5lcXVhbChyLG8pfSx7JGE6ciwkYjpvfSl9fSksX3U9QW4oe2VxdWFsU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJhXCIsXCJlcXVhbFN0cmljdFwiKSxyPXduKGUsXCJiXCIsXCJlcXVhbFN0cmljdFwiKTtyZXR1cm4gdihuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBlcXVhbFN0cmljdDogXCIpLG4uZXF1YWwocil9fSksTXU9QW4oe2dyZWF0ZXJfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj13bih0LFwiYVwiLFwiZ3JlYXRlclwiKSxvPXduKGUsXCJiXCIsXCJncmVhdGVyXCIpO3JldHVybiBuPVJ0KHIsbykscj1uWzBdLG89blsxXSxzbyhyLnNoYXBlLG8uc2hhcGUpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5ncmVhdGVyKHIsbyl9LHskYTpyLCRiOm99KX19KSxGdT1Bbih7Z3JlYXRlckVxdWFsXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9d24odCxcImFcIixcImdyZWF0ZXJFcXVhbFwiKSxvPXduKGUsXCJiXCIsXCJncmVhdGVyRXF1YWxcIik7cmV0dXJuIG49UnQocixvKSxyPW5bMF0sbz1uWzFdLHNvKHIuc2hhcGUsby5zaGFwZSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5ncmVhdGVyRXF1YWwocixvKTtyZXR1cm4gZShbcixvXSksbn0seyRhOnIsJGI6b30sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57JGE6ZnVuY3Rpb24oKXtyZXR1cm4gWG4obil9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHIpfX19KX19KSxCdT1Bbih7Z3JlYXRlckVxdWFsU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJhXCIsXCJncmVhdGVyRXF1YWxTdHJpY3RcIikscj13bihlLFwiYlwiLFwiZ3JlYXRlckVxdWFsU3RyaWN0XCIpO3JldHVybiB2KG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIGdyZWF0ZXJFcXVhbFN0cmljdDogXCIpLG4uZ3JlYXRlckVxdWFsKHIpfX0pLFB1PUFuKHtncmVhdGVyU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJhXCIsXCJncmVhdGVyU3RyaWN0XCIpLHI9d24oZSxcImJcIixcImdyZWF0ZXJTdHJpY3RcIik7cmV0dXJuIHYobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gZ3JlYXRlclN0cmljdDogXCIpLG4uZ3JlYXRlcihyKX19KSxMdT1Bbih7bGVzc186ZnVuY3Rpb24odCxlKXt2YXIgbixyPXduKHQsXCJhXCIsXCJsZXNzXCIpLG89d24oZSxcImJcIixcImxlc3NcIik7cmV0dXJuIG49UnQocixvKSxyPW5bMF0sbz1uWzFdLHNvKHIuc2hhcGUsby5zaGFwZSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0Lmxlc3MocixvKX0seyRhOnIsJGI6b30pfX0pLFd1PUFuKHtsZXNzRXF1YWxfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj13bih0LFwiYVwiLFwibGVzc0VxdWFsXCIpLG89d24oZSxcImJcIixcImxlc3NFcXVhbFwiKTtyZXR1cm4gbj1SdChyLG8pLHI9blswXSxvPW5bMV0sc28oci5zaGFwZSxvLnNoYXBlKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQubGVzc0VxdWFsKHIsbyl9LHskYTpyLCRiOm99KX19KSxVdT1Bbih7bGVzc0VxdWFsU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJhXCIsXCJsZXNzRXF1YWxTdHJpY3RcIikscj13bihlLFwiYlwiLFwibGVzc0VxdWFsU3RyaWN0XCIpO3JldHVybiB2KG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIGxlc3NFcXVhbFN0cmljdDogXCIpLG4ubGVzc0VxdWFsKHIpfX0pLHp1PUFuKHtsZXNzU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJhXCIsXCJsZXNzU3RyaWN0XCIpLHI9d24oZSxcImJcIixcImxlc3NTdHJpY3RcIik7cmV0dXJuIHYobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gbGVzc1N0cmljdDogXCIpLG4ubGVzcyhyKX19KSxWdT1Bbih7bm90RXF1YWxfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj13bih0LFwiYVwiLFwibm90RXF1YWxcIiksbz13bihlLFwiYlwiLFwibm90RXF1YWxcIik7cmV0dXJuIG49UnQocixvKSxyPW5bMF0sbz1uWzFdLHNvKHIuc2hhcGUsby5zaGFwZSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5vdEVxdWFsKHIsbyl9LHskYTpyLCRiOm99KX19KSxHdT1Bbih7bm90RXF1YWxTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcImFcIixcIm5vdEVxdWFsU3RyaWN0XCIpLHI9d24oZSxcImJcIixcIm5vdEVxdWFsU3RyaWN0XCIpO3JldHVybiB2KG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIG5vdEVxdWFsU3RyaWN0OiBcIiksbi5ub3RFcXVhbChyKX19KTt2YXIgcXU9QW4oe2FkZF86ZnVuY3Rpb24odCxlKXt2YXIgbixyPXduKHQsXCJhXCIsXCJhZGRcIiksbz13bihlLFwiYlwiLFwiYWRkXCIpO249UnQocixvKSxyPW5bMF0sbz1uWzFdO3ZhciBhPXNvKHIuc2hhcGUsby5zaGFwZSk7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5hZGQocixvKX0seyRhOnIsJGI6b30sZnVuY3Rpb24odCl7cmV0dXJueyRhOmZ1bmN0aW9uKCl7dmFyIGU9dCxuPWlvKHIuc2hhcGUsYSk7cmV0dXJuIG4ubGVuZ3RoPjAmJihlPWUuc3VtKG4pKSxlLnJlc2hhcGUoci5zaGFwZSl9LCRiOmZ1bmN0aW9uKCl7dmFyIGU9dCxuPWlvKG8uc2hhcGUsYSk7cmV0dXJuIG4ubGVuZ3RoPjAmJihlPWUuc3VtKG4pKSxlLnJlc2hhcGUoby5zaGFwZSl9fX0pfX0pLEh1PUFuKHthZGROXzpmdW5jdGlvbih0KXtkKEFycmF5LmlzQXJyYXkodCksZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBhcmd1bWVudCBwYXNzZWQgdG8gdGYuYWRkTigpIG11c3QgYmUgYSBsaXN0IG9mIHRlbnNvcnNcIn0pLGQodC5sZW5ndGg+PTEsZnVuY3Rpb24oKXtyZXR1cm5cIk11c3QgcGFzcyBhdCBsZWFzdCBvbmUgdGVuc29yIHRvIHRmLmFkZE4oKSwgYnV0IGdvdCBcIit0Lmxlbmd0aH0pO3ZhciBlPXQubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHduKHQsXCJ0ZW5zb3JzXCIrZSxcImFkZE5cIil9KSxuPWVbMF07ZS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2lmKHQuZHR5cGUhPT1uLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIkFsbCB0ZW5zb3JzIHBhc3NlZCB0byB0Zi5hZGROKCkgbXVzdCBoYXZlIHRoZSBzYW1lIGR0eXBlXCIpfSksZS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2lmKCF4KHQuc2hhcGUsbi5zaGFwZSkpdGhyb3cgbmV3IEVycm9yKFwiQWxsIHRlbnNvcnMgcGFzc2VkIHRvIHRmLmFkZE4oKSBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGVcIil9KTt2YXIgcj1lO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuYWRkTihlKX0scixmdW5jdGlvbih0KXt2YXIgbj17fTtyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGUscil7bltyXT1mdW5jdGlvbigpe3JldHVybiB0LmNsb25lKCl9fSksbn0pfX0pLCR1PUFuKHthZGRTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcImFcIixcImFkZFN0cmljdFwiKSxyPXduKGUsXCJiXCIsXCJhZGRTdHJpY3RcIik7cmV0dXJuIHYobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gYWRkU3RyaWN0OiBcIiksbi5hZGQocil9fSksanU9QW4oe2F0YW4yXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9d24odCxcImFcIixcImF0YW4yXCIpLG89d24oZSxcImJcIixcImF0YW4yXCIpO249UnQocixvKSxyPW5bMF0sbz1uWzFdO3ZhciBhPXNvKHIuc2hhcGUsby5zaGFwZSk7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBuPXQuYXRhbjIocixvKTtyZXR1cm4gZShbcixvXSksbn0seyRhOnIsJGI6b30sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57JGE6ZnVuY3Rpb24oKXt2YXIgZT1xdShuLnNxdWFyZSgpLHIuc3F1YXJlKCkpLG89dC5tdWwoci5kaXYoZSkpLGk9aW8obi5zaGFwZSxhKTtyZXR1cm4gaS5sZW5ndGg+MCYmKG89by5zdW0oaSkpLG8ucmVzaGFwZShuLnNoYXBlKX0sJGI6ZnVuY3Rpb24oKXt2YXIgZT1xdShuLnNxdWFyZSgpLHIuc3F1YXJlKCkpLG89aXModC5tdWwobi5kaXYoZSkpKSxpPWlvKHIuc2hhcGUsYSk7cmV0dXJuIGkubGVuZ3RoPjAmJihvPW8uc3VtKGkpKSxvLnJlc2hhcGUoci5zaGFwZSl9fX0pfX0pLEt1PUFuKHtkaXZfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj13bih0LFwiYVwiLFwiZGl2XCIpLG89d24oZSxcImJcIixcImRpdlwiKTtpZihuPVJ0KHIsbykscj1uWzBdLG89blsxXSxcImludDMyXCI9PT1yLmR0eXBlJiZcImludDMyXCI9PT1vLmR0eXBlKXJldHVybiBZdShyLG8pO3ZhciBhPXNvKHIuc2hhcGUsby5zaGFwZSk7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBuPXQucmVhbERpdmlkZShyLG8pO3JldHVybiBlKFtyLG9dKSxufSx7JGE6ciwkYjpvfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnskYTpmdW5jdGlvbigpe3ZhciBlPXQuZGl2KHIudG9GbG9hdCgpKSxvPWlvKG4uc2hhcGUsYSk7cmV0dXJuIG8ubGVuZ3RoPjA/ZS5zdW0obykucmVzaGFwZShuLnNoYXBlKTplfSwkYjpmdW5jdGlvbigpe3ZhciBlPXQubXVsKG4udG9GbG9hdCgpKSxvPWlvKHIuc2hhcGUsYSk7by5sZW5ndGg+MCYmKGU9ZS5zdW0obykucmVzaGFwZShyLnNoYXBlKSk7dmFyIGk9ci5zcXVhcmUoKTtyZXR1cm4gZS5kaXYoaS50b0Zsb2F0KCkpLm5lZygpfX19KX19KSxYdT1Bbih7ZGl2U3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJhXCIsXCJkaXZcIikscj13bihlLFwiYlwiLFwiZGl2XCIpO3JldHVybiB2KG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIGRpdmlkZVN0cmljdDogXCIpLG4uZGl2KHIpfX0pLFl1PUFuKHtmbG9vckRpdl86ZnVuY3Rpb24odCxlKXt2YXIgbixyPXduKHQsXCJhXCIsXCJmbG9vckRpdlwiKSxvPXduKGUsXCJiXCIsXCJmbG9vckRpdlwiKTtuPVJ0KHIsbykscj1uWzBdLG89blsxXTt2YXIgYT1zbyhyLnNoYXBlLG8uc2hhcGUpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbj10LmZsb29yRGl2KHIsbyk7cmV0dXJuIGUoW3Isb10pLG59LHskYTpyLCRiOm99LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV07cmV0dXJueyRhOmZ1bmN0aW9uKCl7dmFyIGU9dC5kaXYoci50b0Zsb2F0KCkpLG89aW8obi5zaGFwZSxhKTtyZXR1cm4gby5sZW5ndGg+MD9lLnN1bShvKS5yZXNoYXBlKG4uc2hhcGUpOmV9LCRiOmZ1bmN0aW9uKCl7dmFyIGU9dC5tdWwobi50b0Zsb2F0KCkpLG89aW8oci5zaGFwZSxhKTtvLmxlbmd0aD4wJiYoZT1lLnN1bShvKS5yZXNoYXBlKHIuc2hhcGUpKTt2YXIgaT1yLnNxdWFyZSgpO3JldHVybiBlLmRpdihpLnRvRmxvYXQoKSkubmVnKCl9fX0pfX0pLFF1PUFuKHttYXhpbXVtXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9d24odCxcImFcIixcIm1heGltdW1cIiksbz13bihlLFwiYlwiLFwibWF4aW11bVwiKTtyZXR1cm4gbj1SdChyLG8pLHI9blswXSxvPW5bMV0sXCJib29sXCI9PT1yLmR0eXBlJiYocj1yLnRvSW50KCksbz1vLnRvSW50KCkpLHNvKHIuc2hhcGUsby5zaGFwZSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5tYXhpbXVtKHIsbyk7cmV0dXJuIGUoW3Isb10pLG59LHskYTpyLCRiOm99LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV07cmV0dXJueyRhOmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4uZ3JlYXRlckVxdWFsKHIpLnRvRmxvYXQoKSl9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4ubGVzcyhyKS50b0Zsb2F0KCkpfX19KX19KSxKdT1Bbih7bWF4aW11bVN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwiYVwiLFwibWF4aW11bVN0cmljdFwiKSxyPXduKGUsXCJiXCIsXCJtYXhpbXVtU3RyaWN0XCIpO3JldHVybiB2KG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIG1heGltdW1TdHJpY3Q6IFwiKSxuLm1heGltdW0ocil9fSksWnU9QW4oe21pbmltdW1fOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj13bih0LFwiYVwiLFwibWluaW11bVwiKSxvPXduKGUsXCJiXCIsXCJtaW5pbXVtXCIpO3JldHVybiBuPVJ0KHIsbykscj1uWzBdLG89blsxXSxcImJvb2xcIj09PXIuZHR5cGUmJihyPXIudG9JbnQoKSxvPW8udG9JbnQoKSksc28oci5zaGFwZSxvLnNoYXBlKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbj10Lm1pbmltdW0ocixvKTtyZXR1cm4gZShbcixvXSksbn0seyRhOnIsJGI6b30sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57JGE6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5sZXNzRXF1YWwocikudG9GbG9hdCgpKX0sJGI6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5ncmVhdGVyKHIpLnRvRmxvYXQoKSl9fX0pfX0pLHRsPUFuKHttaW5pbXVtU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJhXCIsXCJtaW5pbXVtU3RyaWN0XCIpLHI9d24oZSxcImJcIixcIm1pbmltdW1TdHJpY3RcIik7cmV0dXJuIHYobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gbWluaW11bVN0cmljdDogXCIpLG4ubWluaW11bShyKX19KSxlbD1Bbih7bW9kXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9d24odCxcImFcIixcIm1vZFwiKSxvPXduKGUsXCJiXCIsXCJtb2RcIik7bj1SdChyLG8pLHI9blswXSxvPW5bMV07dmFyIGE9c28oci5zaGFwZSxvLnNoYXBlKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5tb2QocixvKTtyZXR1cm4gZShbcixvXSksbn0seyRhOnIsJGI6b30sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57JGE6ZnVuY3Rpb24oKXt2YXIgZT1pbyhuLnNoYXBlLGEpO3JldHVybiBlLmxlbmd0aD4wP3Quc3VtKGUpLnJlc2hhcGUobi5zaGFwZSk6dH0sJGI6ZnVuY3Rpb24oKXt2YXIgZT10Lm11bChuLmRpdihyKS5mbG9vcigpLm5lZygpKSxvPWlvKHIuc2hhcGUsYSk7cmV0dXJuIG8ubGVuZ3RoPjA/ZS5zdW0obykucmVzaGFwZShyLnNoYXBlKTplfX19KX19KSxubD1Bbih7bW9kU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJhXCIsXCJtb2RTdHJpY3RcIikscj13bihlLFwiYlwiLFwibW9kU3RyaWN0XCIpO3JldHVybiB2KG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIG1vZFN0cmljdDogXCIpLG4ubW9kKHIpfX0pLHJsPUFuKHttdWxfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj13bih0LFwiYVwiLFwibXVsXCIpLG89d24oZSxcImJcIixcIm11bFwiKTtuPVJ0KHIsbykscj1uWzBdLG89blsxXTt2YXIgYT1zbyhyLnNoYXBlLG8uc2hhcGUpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbj10Lm11bHRpcGx5KHIsbyk7cmV0dXJuIGUoW3Isb10pLG59LHskYTpyLCRiOm99LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV07cmV0dXJueyRhOmZ1bmN0aW9uKCl7dmFyIGU9dC5tdWwoci50b0Zsb2F0KCkpLG89aW8obi5zaGFwZSxhKTtyZXR1cm4gby5sZW5ndGg+MD9lLnN1bShvKS5yZXNoYXBlKG4uc2hhcGUpOmV9LCRiOmZ1bmN0aW9uKCl7dmFyIGU9dC5tdWwobi50b0Zsb2F0KCkpLG89aW8oci5zaGFwZSxhKTtyZXR1cm4gby5sZW5ndGg+MD9lLnN1bShvKS5yZXNoYXBlKHIuc2hhcGUpOmV9fX0pfX0pLG9sPUFuKHttdWxTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcImFcIixcIm11bFwiKSxyPXduKGUsXCJiXCIsXCJtdWxcIik7cmV0dXJuIHYobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gbXVsdGlwbHlTdHJpY3Q6IFwiKSxuLm11bChyKX19KSxhbD1Bbih7cG93XzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJiYXNlXCIsXCJwb3dcIikscj13bihlLFwiZXhwXCIsXCJwb3dcIiksbz1zbyhuLnNoYXBlLHIuc2hhcGUpO3JldHVybiB0PW4uY2FzdChDdChuLmR0eXBlLHIuZHR5cGUpKSxlPXIuY2FzdChDdChuLmR0eXBlLHIuZHR5cGUpKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbz10LnBvdyhuLHIpO3JldHVybiBlKFtuLHIsb10pLG99LHskYmFzZTpuLCRleHA6cn0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXSxhPWVbMl07cmV0dXJueyRiYXNlOmZ1bmN0aW9uKCl7dmFyIGU9ci50b0Zsb2F0KCksYT10Lm11bChlLm11bChuLnBvdyhlLnN1YihCbigxKSkpKSksaT1pbyhuLnNoYXBlLG8pO3JldHVybiBpLmxlbmd0aD4wJiYoYT1hLnN1bShpKSksYS5yZXNoYXBlKG4uc2hhcGUpfSwkZXhwOmZ1bmN0aW9uKCl7dmFyIGU9bi5ncmVhdGVyKDApLGk9bi5sb2coKS53aGVyZShlLFhuKG4pKSxzPXQubXVsKGEubXVsKGkpKSx1PWlvKHIuc2hhcGUsbyk7cmV0dXJuIHUubGVuZ3RoPjAmJihzPXMuc3VtKHUpKSxzLnJlc2hhcGUoci5zaGFwZSl9fX0pfX0pLGlsPUFuKHtwb3dTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHYodC5zaGFwZSxlLnNoYXBlLFwiRXJyb3IgaW4gcG93U3RyaWN0OiBcIiksdC5wb3coZSl9fSksc2w9QW4oe3NxdWFyZWREaWZmZXJlbmNlXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9d24odCxcImFcIixcInNxdWFyZWREaWZmZXJlbmNlXCIpLG89d24oZSxcImJcIixcInNxdWFyZWREaWZmZXJlbmNlXCIpO3JldHVybiBuPVJ0KHIsbykscj1uWzBdLG89blsxXSxzbyhyLnNoYXBlLG8uc2hhcGUpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBuPXQuc3F1YXJlZERpZmZlcmVuY2UocixvKTtyZXR1cm4gZShbcixvXSksbn0seyRhOnIsJGI6b30sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXSxvPUJuKDIpO3JldHVybnskYTpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLnN1YihyKS5tdWwobykpfSwkYjpmdW5jdGlvbigpe3JldHVybiB0Lm11bChyLnN1YihuKS5tdWwobykpfX19KX19KSx1bD1Bbih7c3F1YXJlZERpZmZlcmVuY2VTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcImFcIixcInNxdWFyZWREaWZmZXJlbmNlU3RyaWN0XCIpLHI9d24oZSxcImJcIixcInNxdWFyZWREaWZmZXJlbmNlU3RyaWN0XCIpO3JldHVybiB2KG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIHNxdWFyZWREaWZmZXJlbmNlU3RyaWN0OiBcIiksbi5zcXVhcmVkRGlmZmVyZW5jZShyKX19KSxsbD1Bbih7c3ViXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9d24odCxcImFcIixcInN1YlwiKSxvPXduKGUsXCJiXCIsXCJzdWJcIik7bj1SdChyLG8pLHI9blswXSxvPW5bMV07dmFyIGE9c28oci5zaGFwZSxvLnNoYXBlKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnN1YnRyYWN0KHIsbyl9LHskYTpyLCRiOm99LGZ1bmN0aW9uKHQpe3JldHVybnskYTpmdW5jdGlvbigpe3ZhciBlPXQsbj1pbyhyLnNoYXBlLGEpO3JldHVybiBuLmxlbmd0aD4wJiYoZT1lLnN1bShuKSksZS5yZXNoYXBlKHIuc2hhcGUpfSwkYjpmdW5jdGlvbigpe3ZhciBlPXQsbj1pbyhvLnNoYXBlLGEpO3JldHVybiBuLmxlbmd0aD4wJiYoZT1lLnN1bShuKSksZS5uZWcoKS5yZXNoYXBlKG8uc2hhcGUpfX19KX19KSxjbD1Bbih7c3ViU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJhXCIsXCJzdWJTdHJpY3RcIikscj13bihlLFwiYlwiLFwic3ViU3RyaWN0XCIpO3JldHVybiB2KG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIHN1YlN0cmljdDogXCIpLG4uc3ViKHIpfX0pO3ZhciBobD1Bbih7bG9naWNhbEFuZF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwiYVwiLFwibG9naWNhbEFuZFwiLFwiYm9vbFwiKSxyPXduKGUsXCJiXCIsXCJsb2dpY2FsQW5kXCIsXCJib29sXCIpO3JldHVybiBzbyhuLnNoYXBlLHIuc2hhcGUpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5sb2dpY2FsQW5kKG4scil9LHskYTpuLCRiOnJ9KX19KSxwbD1Bbih7bG9naWNhbE5vdF86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImxvZ2ljYWxOb3RcIixcImJvb2xcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5sb2dpY2FsTm90KGUpfSx7JHg6ZX0pfX0pLGZsPUFuKHtsb2dpY2FsT3JfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcImFcIixcImxvZ2ljYWxPclwiLFwiYm9vbFwiKSxyPXduKGUsXCJiXCIsXCJsb2dpY2FsT3JcIixcImJvb2xcIik7cmV0dXJuIHNvKG4uc2hhcGUsci5zaGFwZSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmxvZ2ljYWxPcihuLHIpfSx7JGE6biwkYjpyfSl9fSksZGw9QW4oe2xvZ2ljYWxYb3JfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcImFcIixcImxvZ2ljYWxYb3JcIixcImJvb2xcIikscj13bihlLFwiYlwiLFwibG9naWNhbFhvclwiLFwiYm9vbFwiKTtyZXR1cm4gc28obi5zaGFwZSxyLnNoYXBlKSxmbCh0LGUpLmxvZ2ljYWxBbmQoaGwodCxlKS5sb2dpY2FsTm90KCkpfX0pLHZsPUFuKHt3aGVyZV86ZnVuY3Rpb24odCxlLG4pe3ZhciByPXduKGUsXCJhXCIsXCJ3aGVyZVwiKSxvPXduKG4sXCJiXCIsXCJ3aGVyZVwiKSxhPXduKHQsXCJjb25kaXRpb25cIixcIndoZXJlXCIsXCJib29sXCIpO3JldHVybiB2KHIuc2hhcGUsby5zaGFwZSxcIkVycm9yIGluIHdoZXJlOiBcIiksMT09PWEucmFuaz9kKGEuc2hhcGVbMF09PT1yLnNoYXBlWzBdLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZmlyc3QgZGltZW5zaW9uIG9mIGBhYCBtdXN0IG1hdGNoIHRoZSBzaXplIG9mIGBjb25kaXRpb25gLlwifSk6dihhLnNoYXBlLG8uc2hhcGUsXCJFcnJvciBpbiB3aGVyZTogXCIpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBuPXQuc2VsZWN0KGEscixvKTtyZXR1cm4gZShbYV0pLG59LHskY29uZGl0aW9uOmEsJGE6ciwkYjpvfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyRjb25kaXRpb246ZnVuY3Rpb24oKXtyZXR1cm4gWG4obikudG9GbG9hdCgpfSwkYTpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLmNhc3QodC5kdHlwZSkpfSwkYjpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLmxvZ2ljYWxOb3QoKS5jYXN0KHQuZHR5cGUpKX19fSl9fSksbWw9ZnVuY3Rpb24odCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsbixyO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obyl7c3dpdGNoKG8ubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCwoZT13bih0LFwiY29uZGl0aW9uXCIsXCJ3aGVyZUFzeW5jXCIsXCJib29sXCIpKS5kYXRhKCldO2Nhc2UgMTpyZXR1cm4gbj1vLnNlbnQoKSxyPVpyKGUuc2hhcGUsbiksdCE9PWUmJmUuZGlzcG9zZSgpLFsyLHJdfX0pfSl9O3ZhciBnbD1Bbih7ZWx1XzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwiZWx1XCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LmVsdShlKTtyZXR1cm4gbihbcl0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbihlKXtyZXR1cm4gZS5lbHVEZXIodCxuKX0se2R5OnQseTpufSl9fX0pfX0pLHlsPUFuKHtsZWFreVJlbHVfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9LjIpO3ZhciBuPXduKHQsXCJ4XCIsXCJsZWFreVJlbHVcIik7cmV0dXJuIFF1KEJuKGUpLm11bChuKSxuKX19KSx4bD1Bbih7cHJlbHVfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcInhcIixcInByZWx1XCIpLHI9d24oZSxcImFscGhhXCIsXCJwcmVsdVwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG89dC5wcmVsdShuLHIpO3JldHVybiBlKFtuLHJdKSxvfSx7JHg6biwkYWxwaGE6cn0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXSxvPW4uZ3JlYXRlcigwKTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdmwobyx0LHQubXVsKHIpKX0sJGFscGhhOmZ1bmN0aW9uKCl7dmFyIGU9dmwobyxYbih0KSx0Lm11bChuKSksYT1pbyhyLnNoYXBlLHQuc2hhcGUpO3JldHVybiBhLmxlbmd0aD4wJiYoZT1lLnN1bShhKSksZS5yZXNoYXBlKHIuc2hhcGUpfX19KX19KSx3bD1Bbih7cmVsdV86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcInJlbHVcIik7cmV0dXJuXCJib29sXCI9PT1lLmR0eXBlP2UudG9JbnQoKTpEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LnJlbHUoZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0Lm11bFN0cmljdChuLnN0ZXAoKS50b0Zsb2F0KCkpfX19KX19KSxibD1Bbih7c2VsdV86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcInNlbHVcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQuc2VsdShlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7dmFyIGU9bi5ncmVhdGVyKEJuKDApKSxyPUJuKGJpKSxvPUJuKENpKSxhPXQubXVsKG8pLGk9dC5tdWwocikubXVsKG4udG9GbG9hdCgpLmV4cCgpKTtyZXR1cm4gdmwoZSxhLGkpfX19KX19KTt2YXIgQ2w9QW4oe3RyYW5zcG9zZV86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwieFwiLFwidHJhbnNwb3NlXCIpO3JldHVybiBudWxsPT1lJiYoZT1uLnNoYXBlLm1hcChmdW5jdGlvbih0LGUpe3JldHVybiBlfSkucmV2ZXJzZSgpKSxkKG4ucmFuaz09PWUubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiB0cmFuc3Bvc2U6IHJhbmsgb2YgaW5wdXQgXCIrbi5yYW5rK1wiIG11c3QgbWF0Y2ggbGVuZ3RoIG9mIHBlcm0gXCIrZStcIi5cIn0pLGUuZm9yRWFjaChmdW5jdGlvbih0KXtkKHQ+PTAmJnQ8bi5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJBbGwgZW50cmllcyBpbiAncGVybScgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIFwiKyhuLnJhbmstMSkrXCIgYnV0IGdvdCBcIitlfSl9KSxuLnJhbms8PTE/bi5jbG9uZSgpOkR0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC50cmFuc3Bvc2UobixlKX0seyR4Om59LGZ1bmN0aW9uKHQpe3ZhciBuPW9uKGUpO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LnRyYW5zcG9zZShuKX19fSl9fSk7dmFyIEVsPUFuKHtsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbl86ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1lJiYoZT01KSx2b2lkIDA9PT1uJiYobj0xKSx2b2lkIDA9PT1yJiYocj0xKSx2b2lkIDA9PT1vJiYobz0uNSk7dmFyIGE9d24odCxcInhcIixcImxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uXCIpO2QoND09PWEucmFua3x8Mz09PWEucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb246IHggbXVzdCBiZSByYW5rIDMgb3IgNCBidXQgZ290XFxuICAgICAgICAgICAgICAgcmFuayBcIithLnJhbmsrXCIuXCJ9KSxkKHcoZSksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uOiBkZXB0aFJhZGl1cyBtdXN0IGJlIGFuIGludGVnZXIgYnV0IGdvdCBkZXB0aFJhZGl1cyBcIitlK1wiLlwifSk7dmFyIGk9YSxzPSExOzM9PT1hLnJhbmsmJihzPSEwLGk9YS5hczREKDEsYS5zaGFwZVswXSxhLnNoYXBlWzFdLGEuc2hhcGVbMl0pKTt2YXIgdT1EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxhKXt2YXIgcz10LmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uNEQoaSxlLG4scixvKTtyZXR1cm4gYShbaSxzXSksc30se3g0RDppfSxmdW5jdGlvbih0LGEpe3ZhciBpPWFbMF0scz1hWzFdO3JldHVybnt4NEQ6ZnVuY3Rpb24oKXtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKGEpe3JldHVybiBhLkxSTkdyYWQodCxpLHMsZSxuLHIsbyl9LHt9KX19fSk7cmV0dXJuIHM/dS5hczNEKHUuc2hhcGVbMV0sdS5zaGFwZVsyXSx1LnNoYXBlWzNdKTp1fX0pO3ZhciBSbD1Bbih7bm9ybV86ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ZSYmKGU9XCJldWNsaWRlYW5cIiksdm9pZCAwPT09biYmKG49bnVsbCksdm9pZCAwPT09ciYmKHI9ITEpO3ZhciBvPWZ1bmN0aW9uIHQoZSxuLHIpe2lmKHZvaWQgMD09PXImJihyPW51bGwpLDA9PT1lLnJhbmspcmV0dXJuIGUuYWJzKCk7aWYoMSE9PWUucmFuayYmbnVsbD09PXIpcmV0dXJuIHQoZS5yZXNoYXBlKFstMV0pLG4scik7aWYoMT09PWUucmFua3x8XCJudW1iZXJcIj09dHlwZW9mIHJ8fEFycmF5LmlzQXJyYXkocikmJjE9PT1yLmxlbmd0aCl7aWYoMT09PW4pcmV0dXJuIGUuYWJzKCkuc3VtKHIpO2lmKG49PT0xLzApcmV0dXJuIGUuYWJzKCkubWF4KHIpO2lmKG49PT0tMS8wKXJldHVybiBlLmFicygpLm1pbihyKTtpZihcImV1Y2xpZGVhblwiPT09bnx8Mj09PW4pcmV0dXJuIGUuYWJzKCkucG93KEJuKDIsXCJpbnQzMlwiKSkuc3VtKHIpLnNxcnQoKTt0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBub3JtOiBpbnZhbGlkIG9yZCB2YWx1ZTogXCIrbil9aWYoQXJyYXkuaXNBcnJheShyKSYmMj09PXIubGVuZ3RoKXtpZigxPT09bilyZXR1cm4gZS5hYnMoKS5zdW0oclswXSkubWF4KHJbMV0tMSk7aWYobj09PTEvMClyZXR1cm4gZS5hYnMoKS5zdW0oclsxXSkubWF4KHJbMF0pO2lmKG49PT0tMS8wKXJldHVybiBlLmFicygpLnN1bShyWzFdKS5taW4oclswXSk7aWYoXCJmcm9cIj09PW58fFwiZXVjbGlkZWFuXCI9PT1uKXJldHVybiBlLnNxdWFyZSgpLnN1bShyKS5zcXJ0KCk7dGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gbm9ybTogaW52YWxpZCBvcmQgdmFsdWU6IFwiK24pfXRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIG5vcm06IGludmFsaWQgYXhpczogXCIrcil9KHQ9d24odCxcInhcIixcIm5vcm1cIiksZSxuKSxhPW8uc2hhcGU7aWYocil7dmFyIGk9TihuLHQuc2hhcGUpO2E9ZW4oby5zaGFwZSxpKX1yZXR1cm4gby5yZXNoYXBlKGEpfX0pO2Z1bmN0aW9uIFNsKHQsZSl7Zm9yKHZhciBuPVtdLHI9dDtyPGU7KytyKW4ucHVzaChyKTtyZXR1cm4gbn1mdW5jdGlvbiBObCh0KXtmb3IodmFyIGU9W10sbj0wO248dC5sZW5ndGg7KytuKWZvcih2YXIgcj0wO3I8dFtuXS5sZW5ndGg7KytyKWUucHVzaCh0W25dW3JdKTtyZXR1cm4gZX12YXIga2w9QW4oe2dhdGhlcl86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPTApO3ZhciByPXduKHQsXCJ4XCIsXCJnYXRoZXJcIiksbz13bihlLFwiaW5kaWNlc1wiLFwiZ2F0aGVyXCIsXCJpbnQzMlwiKTtuPU4obixyLnNoYXBlKVswXTt2YXIgYT1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPXQuc2hhcGVbbl0sbz1bXSxhPTEsaT0xLHM9MDtzPG47cysrKW8ucHVzaCh0LnNoYXBlW3NdKSxhKj10LnNoYXBlW3NdO2ZvcihzPTA7czxlLnJhbms7cysrKW8ucHVzaChlLnNoYXBlW3NdKTtmb3Iocz1uKzE7czx0LnJhbms7cysrKW8ucHVzaCh0LnNoYXBlW3NdKSxpKj10LnNoYXBlW3NdO3JldHVybntiYXRjaFNpemU6YSxzbGljZVNpemU6aSxkaW1TaXplOnIsb3V0cHV0U2hhcGU6b319KHIsbyxuKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIGE9dC5nYXRoZXIocixvLmZsYXR0ZW4oKSxuKTtyZXR1cm4gZShbb10pLGF9LHskeDpyfSxmdW5jdGlvbih0LGUpe3ZhciBvPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7dmFyIGU9ci5zaGFwZSxhPW8uc2l6ZSxpPWUuc2xpY2UoMCxuKSxzPWkubGVuZ3RoLHU9ZS5zbGljZShuLGUubGVuZ3RoKS5zbGljZSgxKSxsPXUubGVuZ3RoLGM9U2woMCxzKSxoPVNsKHMrMSxzKzErbCkscD1ObChbaSxbYV0sdV0pLGY9dC5yZXNoYXBlKHApLGQ9by5yZXNoYXBlKFthXSksdj1ObChbW3NdLGMsaF0pLG09Zi50cmFuc3Bvc2UodiksZz1JbChtLGQsci5zaGFwZVtuXSkseT1vbih2KTtyZXR1cm4gZz1nLnRyYW5zcG9zZSh5KX19fSkucmVzaGFwZShhLm91dHB1dFNoYXBlKX19KSxJbD1Bbih7dW5zb3J0ZWRTZWdtZW50U3VtXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9d24odCxcInhcIixcInVuc29ydGVkU2VnbWVudFN1bVwiKSxvPXduKGUsXCJzZWdtZW50SWRzXCIsXCJ1bnNvcnRlZFNlZ21lbnRTdW1cIixcImludDMyXCIpO3JldHVybiBkKHcobiksZnVuY3Rpb24oKXtyZXR1cm5cIm51bVNlZ21lbnRzIG11c3QgYmUgb2YgZHR5cGUgaW50XCJ9KSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgYT10LnVuc29ydGVkU2VnbWVudFN1bShyLG8sbik7cmV0dXJuIGUoW29dKSxhfSx7JHg6cn0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1RdShlLFhuKGUpKSxyPWtsKHQsbiksbz1GdShlLEJuKDAsXCJpbnQzMlwiKSksYT1yLnJhbmstby5yYW5rLGk9MDtpPGE7KytpKW89X3IobyxpKzEpO289aGwobyxHbihyLnNoYXBlLFwiYm9vbFwiKSk7dmFyIHM9WG4ocik7cmV0dXJuIHZsKG8scixzKX0odCxuKX19fSl9fSk7dmFyIEFsPUFuKHtiYXNpY0xTVE1DZWxsXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7dmFyIGk9d24odCxcImZvcmdldEJpYXNcIixcImJhc2ljTFNUTUNlbGxcIikscz13bihlLFwibHN0bUtlcm5lbFwiLFwiYmFzaWNMU1RNQ2VsbFwiKSx1PXduKG4sXCJsc3RtQmlhc1wiLFwiYmFzaWNMU1RNQ2VsbFwiKSxsPXduKHIsXCJkYXRhXCIsXCJiYXNpY0xTVE1DZWxsXCIpLGM9d24obyxcImNcIixcImJhc2ljTFNUTUNlbGxcIiksaD13bihhLFwiaFwiLFwiYmFzaWNMU1RNQ2VsbFwiKSxwPWwuY29uY2F0KGgsMSkubWF0TXVsKHMpLmFkZCh1KSxmPXAuc2hhcGVbMF0sZD1wLnNoYXBlWzFdLzQsdj1bZixkXSxtPXAuc2xpY2UoWzAsMF0sdiksZz1wLnNsaWNlKFswLGRdLHYpLHk9cC5zbGljZShbMCwyKmRdLHYpLHg9cC5zbGljZShbMCwzKmRdLHYpLHc9bS5zaWdtb2lkKCkubXVsU3RyaWN0KGcudGFuaCgpKS5hZGRTdHJpY3QoYy5tdWxTdHJpY3QoaS5hZGQoeSkuc2lnbW9pZCgpKSksYj13LnRhbmgoKS5tdWxTdHJpY3QoeC5zaWdtb2lkKCkpO3JldHVyblt3LGJdfX0pLFRsPUFuKHttdWx0aVJOTkNlbGxfOmZ1bmN0aW9uKHQsZSxuLHIpe2Zvcih2YXIgbz13bihlLFwiZGF0YVwiLFwibXVsdGlSTk5DZWxsXCIpLGE9Ym4obixcImNcIixcIm11bHRpUk5OQ2VsbFwiKSxpPWJuKHIsXCJoXCIsXCJtdWx0aVJOTkNlbGxcIikscz1vLHU9W10sbD0wO2w8dC5sZW5ndGg7bCsrKXt2YXIgYz10W2xdKHMsYVtsXSxpW2xdKTt1LnB1c2goY1swXSksdS5wdXNoKGNbMV0pLHM9Y1sxXX12YXIgaD1bXSxwPVtdO2ZvcihsPTA7bDx1Lmxlbmd0aDtsKz0yKWgucHVzaCh1W2xdKSxwLnB1c2godVtsKzFdKTtyZXR1cm5baCxwXX19KTt2YXIgRGw9QW4oe21vdmluZ0F2ZXJhZ2VfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09byYmKG89ITApO3ZhciBhPXduKHQsXCJ2XCIsXCJtb3ZpbmdBdmVyYWdlXCIpLGk9d24oZSxcInhcIixcIm1vdmluZ0F2ZXJhZ2VcIikscz13bihuLFwiZGVjYXlcIixcIm1vdmluZ0F2ZXJhZ2VcIik7U3QoYSxpKSxkKHgoYS5zaGFwZSxpLnNoYXBlKSxmdW5jdGlvbigpe3JldHVyblwiU2hhcGUgbWlzbWF0Y2ggaW4gdiBhbmQgeFwifSk7dmFyIHU9Qm4oMSksbD11LnN1YihzKSxjPWkuc3ViKGEpLm11bChsKTtpZihvKXtkKG51bGwhPXIsZnVuY3Rpb24oKXtyZXR1cm5cIldoZW4gdXNpbmcgemVyb0RlYmlhczogdHJ1ZSwgc3RlcCBpcyByZXF1aXJlZC5cIn0pO3ZhciBoPXduKHIsXCJzdGVwXCIsXCJtb3ZpbmdBdmVyYWdlXCIpO2M9Yy5kaXYodS5zdWIoYWwocyxoKSkpfXJldHVybiBhLmFkZChjKX19KTt2YXIgT2w9QW4oe3N0cmlkZWRTbGljZV86ZnVuY3Rpb24odCxlLG4scixvLGEsaSxzLHUpe2lmKHZvaWQgMD09PW8mJihvPTApLHZvaWQgMD09PWEmJihhPTApLHZvaWQgMD09PWkmJihpPTApLHZvaWQgMD09PXMmJihzPTApLHZvaWQgMD09PXUmJih1PTApLDAhPT1pKXRocm93IG5ldyBFcnJvcihcImVsbGlwc2lzIG1hc2sgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7aWYoMCE9PXMpdGhyb3cgbmV3IEVycm9yKFwibmV3IGF4aXMgbWFzayBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTt2YXIgbD13bih0LFwieFwiLFwic3RyaWRlZFNsaWNlXCIpO2lmKHIuZXZlcnkoZnVuY3Rpb24odCl7cmV0dXJuIDE9PT10fSkpe3ZhciBjPWZuKGwuc2hhcGUsZSxuLHIsbyxhLGkscyx1KSxoPWNbMF0scD1jWzFdLGY9Y1syXSxkPXAuZmlsdGVyKGZ1bmN0aW9uKHQsZSl7cmV0dXJuLTE9PT1mLmluZGV4T2YoZSl9KTtyZXR1cm4gdnUobCxoLHApLnJlc2hhcGUoZCl9cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5zdHJpZGVkU2xpY2UobCxlLG4scixvLGEsaSxzLHUpfSx7JHg6bH0pfX0pO3ZhciBfbD1Bbih7dG9wa186ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPTEpLHZvaWQgMD09PW4mJihuPSEwKTt2YXIgcj13bih0LFwieFwiLFwidG9wa1wiKTtpZigwPT09ci5yYW5rKXRocm93IG5ldyBFcnJvcihcInRvcGsoKSBleHBlY3RzIHRoZSBpbnB1dCB0byBiZSBvZiByYW5rIDEgb3IgaGlnaGVyXCIpO3ZhciBvPXIuc2hhcGVbci5zaGFwZS5sZW5ndGgtMV07aWYoZT5vKXRocm93IG5ldyBFcnJvcihcIidrJyBwYXNzZWQgdG8gdG9waygpIG11c3QgYmUgPD0gdGhlIGxhc3QgZGltZW5zaW9uIChcIitvK1wiKSBidXQgZ290IFwiK2UpO3ZhciBhPUR0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC50b3BrKHIsZSxuKX0seyR4OnJ9KTtyZXR1cm57dmFsdWVzOmFbMF0saW5kaWNlczphWzFdfX19KTt2YXIgTWw9QW4oe3NjYXR0ZXJORF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPXduKHQsXCJpbmRpY2VzXCIsXCJzY2F0dGVyTkRcIixcImludDMyXCIpLG89d24oZSxcInVwZGF0ZXNcIixcInNjYXR0ZXJORFwiKTtyZXR1cm4gaG4obyxyLG4pLER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5zY2F0dGVyTkQocixvLG4pfSx7JGluZGljZXM6ciwkdXBkYXRlczpvfSl9fSk7dmFyIEZsPUFuKHtmZnRfOmZ1bmN0aW9uKHQpe2QoXCJjb21wbGV4NjRcIj09PXQuZHR5cGUsZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBkdHlwZSBmb3IgdGYuc3BlY3RyYWwuZmZ0KCkgbXVzdCBiZSBjb21wbGV4NjQgYnV0IGdvdCBcIit0LmR0eXBlK1wiLlwifSk7dmFyIGU9dC5zaGFwZVt0LnNoYXBlLmxlbmd0aC0xXSxuPXQuc2l6ZS9lLHI9dC5hczJEKG4sZSk7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5mZnQocil9LHtpbnB1dDp0fSkucmVzaGFwZSh0LnNoYXBlKX19KSxCbD1Bbih7aWZmdF86ZnVuY3Rpb24odCl7ZChcImNvbXBsZXg2NFwiPT09dC5kdHlwZSxmdW5jdGlvbigpe3JldHVyblwiVGhlIGR0eXBlIGZvciB0Zi5zcGVjdHJhbC5pZmZ0KCkgbXVzdCBiZSBjb21wbGV4NjQgYnV0IGdvdCBcIit0LmR0eXBlK1wiLlwifSk7dmFyIGU9dC5zaGFwZVt0LnNoYXBlLmxlbmd0aC0xXSxuPXQuc2l6ZS9lLHI9dC5hczJEKG4sZSk7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5pZmZ0KHIpfSx7aW5wdXQ6dH0pLnJlc2hhcGUodC5zaGFwZSl9fSksUGw9QW4oe3JmZnRfOmZ1bmN0aW9uKHQpe2QoXCJmbG9hdDMyXCI9PT10LmR0eXBlLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZHR5cGUgZm9yIHJmZnQoKSBtdXN0IGJlIHJlYWwgdmFsdWUgYnV0IGdvdCBcIit0LmR0eXBlfSk7dmFyIGU9dC5zaGFwZVt0LnNoYXBlLmxlbmd0aC0xXSxuPXQuc2l6ZS9lLHI9dC56ZXJvc0xpa2UoKSxvPU9uKHQscikuYXMyRChuLGUpLGE9RmwobyksaT1NYXRoLmZsb29yKGUvMikrMSxzPV9uKGEpLHU9TW4oYSksbD1zLnNwbGl0KFtpLGUtaV0scy5zaGFwZS5sZW5ndGgtMSksYz11LnNwbGl0KFtpLGUtaV0sdS5zaGFwZS5sZW5ndGgtMSksaD10LnNoYXBlLnNsaWNlKCk7cmV0dXJuIGhbdC5zaGFwZS5sZW5ndGgtMV09aSxPbihsWzBdLGNbMF0pLnJlc2hhcGUoaCl9fSksTGw9QW4oe2lyZmZ0XzpmdW5jdGlvbih0KXt2YXIgZT10LnNoYXBlW3Quc2hhcGUubGVuZ3RoLTFdLG49dC5zaXplL2U7aWYoZTw9Mil7dmFyIHI9dC5hczJEKG4sZSksbz1CbChyKTtyZXR1cm4gX24obyl9dmFyIGE9W24sMiooZS0xKV0saT1fbih0KS5hczJEKG4sZSkscz1Nbih0KS5hczJEKG4sZSksdT1pLnNsaWNlKFswLDFdLFtuLGUtMl0pLnJldmVyc2UoMSksbD1zLnNsaWNlKFswLDFdLFtuLGUtMl0pLnJldmVyc2UoMSkubXVsKEJuKC0xKSksYz1pLmNvbmNhdCh1LDEpLGg9cy5jb25jYXQobCwxKTtyZXR1cm4gcj1PbihjLGgpLmFzMkQoYVswXSxhWzFdKSxvPUJsKHIpLF9uKG8pfX0pLFdsPU9iamVjdC5mcmVlemUoe2ZmdDpGbCxpZmZ0OkJsLHJmZnQ6UGwsaXJmZnQ6TGx9KTt2YXIgVWw9QW4oe3NwYXJzZVRvRGVuc2VfOmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPTApO3ZhciBvPXduKHQsXCJzcGFyc2VJbmRpY2VzXCIsXCJzcGFyc2VUb0RlbnNlXCIsXCJpbnQzMlwiKSxhPXduKGUsXCJzcGFyc2VWYWx1ZXNcIixcInNwYXJzZVRvRGVuc2VcIiksaT13bihyLFwiZGVmYXVsdFZhbHVlXCIsXCJzcGFyc2VUb0RlbnNlXCIsYS5kdHlwZSk7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIpe2lmKFwiaW50MzJcIiE9PXQuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwidGYuc3BhcnNlVG9EZW5zZSgpIGV4cGVjdHMgdGhlIGluZGljZXMgdG8gYmUgaW50MzIgdHlwZSwgYnV0IHRoZSBkdHlwZSB3YXMgXCIrdC5kdHlwZStcIi5cIik7aWYodC5yYW5rPjIpdGhyb3cgbmV3IEVycm9yKFwic3BhcnNlSW5kaWNlcyBzaG91bGQgYmUgYSBzY2FsYXIsIHZlY3Rvciwgb3IgbWF0cml4LCBidXQgZ290IHNoYXBlIFwiK3Quc2hhcGUrXCIuXCIpO3ZhciBvPXQucmFuaz4wP3Quc2hhcGVbMF06MSxhPXQucmFuaz4xP3Quc2hhcGVbMV06MTtpZihuLmxlbmd0aCE9PWEpdGhyb3cgbmV3IEVycm9yKFwib3V0cHV0U2hhcGUgaGFzIGluY29ycmVjdCBudW1iZXIgb2YgZWxlbWVudHM6LCBcIituLmxlbmd0aCtcIiwgc2hvdWxkIGJlOiBcIithK1wiLlwiKTt2YXIgaT1lLnNpemU7aWYoMCE9PWUucmFuayYmKDEhPT1lLnJhbmt8fGkhPT1vKSl0aHJvdyBuZXcgRXJyb3IoXCJzcGFyc2VWYWx1ZXMgaGFzIGluY29ycmVjdCBzaGFwZSBcIitlLnNoYXBlK1wiLCBzaG91bGQgYmUgW10gb3IgW1wiK28rXCJdXCIpO2lmKGUuZHR5cGUhPT1yLmR0eXBlKXRocm93IG5ldyBFcnJvcihcInNwYXJzZVZhbHVlcy5kdHlwZSBtdXN0IG1hdGNoIGRlZmF1bHRWYWx1ZXMuZHR5cGVcIil9KG8sYSxuLGkpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5zcGFyc2VUb0RlbnNlKG8sYSxuLGkpfSx7JHNwYXJzZUluZGljZXM6bywkc3BhcnNlVmFsdWVzOmEsJGRlZmF1bHRWYWx1ZTppfSl9fSk7dmFyIHpsPUFuKHtnYXRoZXJORF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bihlLFwiaW5kaWNlc1wiLFwiZ2F0aGVyTkRcIixcImludDMyXCIpLHI9d24odCxcInhcIixcImdhdGhlck5EXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2F0aGVyTkQocixuKX0seyR4OnIsJGluZGljZXM6bn0pfX0pO3ZhciBWbD1Bbih7ZHJvcG91dF86ZnVuY3Rpb24odCxlLG4scil7aWYobnVsbCE9biYmIXgodC5zaGFwZSxuKSl0aHJvdyBuZXcgRXJyb3IoXCJOb24tZGVmYXVsdCBub2lzZSBzaGFwZSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0OiBcIitKU09OLnN0cmluZ2lmeShuKSk7dmFyIG89cXIodC5zaGFwZSwwLDEsXCJmbG9hdDMyXCIscikuZ3JlYXRlcihlKTtyZXR1cm4gbz1vLmRpdihsbCgxLGUpKSx0Lm11bChvKX19KTtmdW5jdGlvbiBHbCh0LGUsbil7Zm9yKHZhciByPTEtdCUyLG89bmV3IEZsb2F0MzJBcnJheSh0KSxhPTA7YTx0OysrYSl7dmFyIGk9MipNYXRoLlBJKmEvKHQrci0xKTtvW2FdPWUtbipNYXRoLmNvcyhpKX1yZXR1cm4gUG4obyxcImZsb2F0MzJcIil9dmFyIHFsLEhsPUFuKHtoYW5uV2luZG93XzpmdW5jdGlvbih0KXtyZXR1cm4gR2wodCwuNSwuNSl9fSksJGw9QW4oe2hhbW1pbmdXaW5kb3dfOmZ1bmN0aW9uKHQpe3JldHVybiBHbCh0LC41NCwuNDYpfX0pOyFmdW5jdGlvbih0KXt0W3QuTk9ORT0wXT1cIk5PTkVcIix0W3QuTUVBTj0xXT1cIk1FQU5cIix0W3QuU1VNPTJdPVwiU1VNXCIsdFt0LlNVTV9CWV9OT05aRVJPX1dFSUdIVFM9M109XCJTVU1fQllfTk9OWkVST19XRUlHSFRTXCJ9KHFsfHwocWw9e30pKTt2YXIgamw9QW4oe2Fic29sdXRlRGlmZmVyZW5jZV86ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9cWwuU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIG89d24odCxcImxhYmVsc1wiLFwiYWJzb2x1dGVEaWZmZXJlbmNlXCIpLGE9d24oZSxcInByZWRpY3Rpb25zXCIsXCJhYnNvbHV0ZURpZmZlcmVuY2VcIiksaT1udWxsO251bGwhPW4mJihpPXduKG4sXCJ3ZWlnaHRzXCIsXCJhYnNvbHV0ZURpZmZlcmVuY2VcIikpLHYoby5zaGFwZSxhLnNoYXBlLFwiRXJyb3IgaW4gYWJzb2x1dGVEaWZmZXJlbmNlOiBcIik7dmFyIHM9by5zdWIoYSkuYWJzKCk7cmV0dXJuIEtsKHMsaSxyKX19KSxLbD1Bbih7Y29tcHV0ZVdlaWdodGVkTG9zc186ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPXFsLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciByPXduKHQsXCJsb3NzZXNcIixcImNvbXB1dGVXZWlnaHRlZExvc3NcIiksbz1udWxsO251bGwhPWUmJihvPXduKGUsXCJ3ZWlnaHRzXCIsXCJjb21wdXRlV2VpZ2h0ZWRMb3NzXCIpKTt2YXIgYT1udWxsPT1vP3I6ci5tdWwobyk7aWYobj09PXFsLk5PTkUpcmV0dXJuIGE7aWYobj09PXFsLlNVTSlyZXR1cm4gYS5zdW0oKTtpZihuPT09cWwuTUVBTil7aWYobnVsbD09bylyZXR1cm4gYS5tZWFuKCk7dmFyIGk9ci5zaXplL28uc2l6ZSxzPWEuc3VtKCkuZGl2KG8uc3VtKCkpO3JldHVybiBpPjE/cy5kaXYoQm4oaSkpOnN9aWYobj09PXFsLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpe2lmKG51bGw9PW8pcmV0dXJuIGEuc3VtKCkuZGl2KEJuKHIuc2l6ZSkpO3ZhciB1PW8ubXVsKEduKHIuc2hhcGUpKS5ub3RFcXVhbChCbigwKSkuc3VtKCkudG9GbG9hdCgpO3JldHVybiBhLnN1bSgpLmRpdih1KX10aHJvdyBFcnJvcihcIlVua25vd24gcmVkdWN0aW9uOiBcIituKX19KSxYbD1Bbih7Y29zaW5lRGlzdGFuY2VfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09byYmKG89cWwuU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIGE9d24odCxcImxhYmVsc1wiLFwiY29zaW5lRGlzdGFuY2VcIiksaT13bihlLFwicHJlZGljdGlvbnNcIixcImNvc2luZURpc3RhbmNlXCIpLHM9bnVsbDtudWxsIT1yJiYocz13bihyLFwid2VpZ2h0c1wiLFwiY29zaW5lRGlzdGFuY2VcIikpLHYoYS5zaGFwZSxpLnNoYXBlLFwiRXJyb3IgaW4gY29zaW5lRGlzdGFuY2U6IFwiKTt2YXIgdT1CbigxKS5zdWIoYS5tdWwoaSkuc3VtKG4sITApKTtyZXR1cm4gS2wodSxzLG8pfX0pLFlsPUFuKHtoaW5nZUxvc3NfOmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPXFsLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBvPXduKHQsXCJsYWJlbHNcIixcImhpbmdlTG9zc1wiKSxhPXduKGUsXCJwcmVkaWN0aW9uc1wiLFwiaGluZ2VMb3NzXCIpLGk9bnVsbDtudWxsIT1uJiYoaT13bihuLFwid2VpZ2h0c1wiLFwiaGluZ2VMb3NzXCIpKSx2KG8uc2hhcGUsYS5zaGFwZSxcIkVycm9yIGluIGhpbmdlTG9zczogXCIpO3ZhciBzPUJuKDEpO289Qm4oMikubXVsKG8pLnN1YihzKTt2YXIgdT1zLnN1YihvLm11bChhKSkucmVsdSgpO3JldHVybiBLbCh1LGkscil9fSksUWw9QW4oe2h1YmVyTG9zc186ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1yJiYocj0xKSx2b2lkIDA9PT1vJiYobz1xbC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgYT13bih0LFwibGFiZWxzXCIsXCJodWJlckxvc3NcIiksaT13bihlLFwicHJlZGljdGlvbnNcIixcImh1YmVyTG9zc1wiKSxzPW51bGw7bnVsbCE9biYmKHM9d24obixcIndlaWdodHNcIixcImh1YmVyTG9zc1wiKSksdihhLnNoYXBlLGkuc2hhcGUsXCJFcnJvciBpbiBodWJlckxvc3M6IFwiKTt2YXIgdT1CbihyKSxsPWkuc3ViKGEpLmFicygpLGM9WnUobCx1KSxoPWwuc3ViKGMpLHA9Qm4oLjUpLm11bChjLnNxdWFyZSgpKS5hZGQodS5tdWwoaCkpO3JldHVybiBLbChwLHMsbyl9fSksSmw9QW4oe2xvZ0xvc3NfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09ciYmKHI9MWUtNyksdm9pZCAwPT09byYmKG89cWwuU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIGE9d24odCxcImxhYmVsc1wiLFwibG9nTG9zc1wiKSxpPXduKGUsXCJwcmVkaWN0aW9uc1wiLFwibG9nTG9zc1wiKSxzPW51bGw7bnVsbCE9biYmKHM9d24obixcIndlaWdodHNcIixcImxvZ0xvc3NcIikpLHYoYS5zaGFwZSxpLnNoYXBlLFwiRXJyb3IgaW4gbG9nTG9zczogXCIpO3ZhciB1PUJuKDEpLGw9Qm4ociksYz1hLm11bChpLmFkZChsKS5sb2coKSkubmVnKCkuc3ViKHUuc3ViKGEpLm11bCh1LnN1YihpKS5hZGQobCkubG9nKCkpKTtyZXR1cm4gS2woYyxzLG8pfX0pLFpsPUFuKHttZWFuU3F1YXJlZEVycm9yXzpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1xbC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgbz13bih0LFwibGFiZWxzXCIsXCJtZWFuU3F1YXJlZEVycm9yXCIpLGE9d24oZSxcInByZWRpY3Rpb25zXCIsXCJtZWFuU3F1YXJlZEVycm9yXCIpLGk9bnVsbDtudWxsIT1uJiYoaT13bihuLFwid2VpZ2h0c1wiLFwibWVhblNxdWFyZWRFcnJvclwiKSksdihvLnNoYXBlLGEuc2hhcGUsXCJFcnJvciBpbiBtZWFuU3F1YXJlZEVycm9yOiBcIik7dmFyIHM9by5zcXVhcmVkRGlmZmVyZW5jZShhKTtyZXR1cm4gS2wocyxpLHIpfX0pLHRjPUFuKHtzaWdtb2lkQ3Jvc3NFbnRyb3B5XzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PXImJihyPTApLHZvaWQgMD09PW8mJihvPXFsLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBhPXduKHQsXCJtdWx0aUNsYXNzTGFiZWxzXCIsXCJzaWdtb2lkQ3Jvc3NFbnRyb3B5XCIpLGk9d24oZSxcImxvZ2l0c1wiLFwic2lnbW9pZENyb3NzRW50cm9weVwiKSxzPW51bGw7aWYobnVsbCE9biYmKHM9d24obixcIndlaWdodHNcIixcInNpZ21vaWRDcm9zc0VudHJvcHlcIikpLHYoYS5zaGFwZSxpLnNoYXBlLFwiRXJyb3IgaW4gc2lnbW9pZENyb3NzRW50cm9weTogXCIpLHI+MCl7dmFyIHU9Qm4ociksbD1CbigxKSxjPUJuKC41KTthPWEubXVsKGwuc3ViKHUpKS5hZGQoYy5tdWwodSkpfXZhciBoPWZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcImxhYmVsc1wiLFwic2lnbW9pZENyb3NzRW50cm9weVdpdGhMb2dpdHNcIikscj13bihlLFwibG9naXRzXCIsXCJzaWdtb2lkQ3Jvc3NFbnRyb3B5V2l0aExvZ2l0c1wiKTt2KG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIHNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzOiBcIik7dmFyIG89ci5yZWx1KCksYT1yLm11bChuKSxpPXIuYWJzKCkubmVnKCkuZXhwKCkubG9nMXAoKTtyZXR1cm4gby5zdWIoYSkuYWRkKGkpfShhLGkpO3JldHVybiBLbChoLHMsbyl9fSksZWM9QW4oe3NvZnRtYXhDcm9zc0VudHJvcHlfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09ciYmKHI9MCksdm9pZCAwPT09byYmKG89cWwuU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIGE9d24odCxcIm9uZWhvdExhYmVsc1wiLFwic29mdG1heENyb3NzRW50cm9weVwiKSxpPXduKGUsXCJsb2dpdHNcIixcInNvZnRtYXhDcm9zc0VudHJvcHlcIikscz1udWxsO2lmKG51bGwhPW4mJihzPXduKG4sXCJ3ZWlnaHRzXCIsXCJzb2Z0bWF4Q3Jvc3NFbnRyb3B5XCIpKSx2KGEuc2hhcGUsaS5zaGFwZSxcIkVycm9yIGluIHNvZnRtYXhDcm9zc0VudHJvcHk6IFwiKSxyPjApe3ZhciB1PUJuKHIpLGw9Qm4oMSksYz1CbihhLnNoYXBlWzFdKTthPWEubXVsKGwuc3ViKHUpKS5hZGQodS5kaXYoYykpfXZhciBoPWZ1bmN0aW9uKHQsZSxuKXtpZih2b2lkIDA9PT1uJiYobj0tMSksLTE9PT1uJiYobj1lLnJhbmstMSksbiE9PWUucmFuay0xKXRocm93IEVycm9yKFwiU29mdG1heCBjcm9zcyBlbnRyb3B5IGFsb25nIGEgbm9uLWxhc3QgZGltZW5zaW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLiBMYWJlbHMgLyBsb2dpdHMgd2FzIHJhbmsgXCIrZS5yYW5rK1wiIGFuZCBkaW0gd2FzIFwiK24pO3JldHVybiBrbihmdW5jdGlvbih0LGUscil7dmFyIG89ZS5sb2dTdW1FeHAoW25dLCEwKSxhPWUudG9GbG9hdCgpLnN1YihvKTtyZXR1cm4gcihbdCxhXSkse3ZhbHVlOmEubXVsKHQpLm5lZygpLnN1bShbbl0pLGdyYWRGdW5jOmZ1bmN0aW9uKHQsZSl7dmFyIHI9ZVswXSxvPWVbMV0sYT1lbih0LnNoYXBlLFtuXSk7cmV0dXJuW3QucmVzaGFwZShhKS5tdWwoci50b0Zsb2F0KCkuc3ViKG8uZXhwKCkpKSx0LnJlc2hhcGUoYSkubXVsKG8uZXhwKCkuc3ViKHIudG9GbG9hdCgpKSldfX19KSh0LGUpfShhLGkpO3JldHVybiBLbChoLHMsbyl9fSksbmM9T2JqZWN0LmZyZWV6ZSh7Z2V0IFJlZHVjdGlvbigpe3JldHVybiBxbH0sYWJzb2x1dGVEaWZmZXJlbmNlOmpsLGNvbXB1dGVXZWlnaHRlZExvc3M6S2wsY29zaW5lRGlzdGFuY2U6WGwsaGluZ2VMb3NzOllsLGh1YmVyTG9zczpRbCxsb2dMb3NzOkpsLG1lYW5TcXVhcmVkRXJyb3I6Wmwsc2lnbW9pZENyb3NzRW50cm9weTp0Yyxzb2Z0bWF4Q3Jvc3NFbnRyb3B5OmVjfSk7ZnVuY3Rpb24gcmModCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITEpLER0LnRpZHkoZnVuY3Rpb24oKXtpZigyIT09dC5zaGFwZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwicXIyZCgpIHJlcXVpcmVzIGEgMkQgVGVuc29yLCBidXQgZ290IGEgXCIrdC5zaGFwZS5sZW5ndGgrXCJEIFRlbnNvci5cIik7Zm9yKHZhciBuPXQuc2hhcGVbMF0scj10LnNoYXBlWzFdLG89TXIobiksYT10LmNsb25lKCksaT1MbihbWzFdXSxbMSwxXSkscz1pLmNsb25lKCksdT1uPj1yP3I6bixsPWZ1bmN0aW9uKHQpe3ZhciBlLHU9YSxsPXMsYz1vO2U9RHQudGlkeShmdW5jdGlvbigpe3ZhciBlPWEuc2xpY2UoW3QsdF0sW24tdCwxXSksdT1lLm5vcm0oKSxsPWEuc2xpY2UoW3QsdF0sWzEsMV0pLGM9bC5zaWduKCkubmVnKCksaD1sLnN1YihjLm11bCh1KSkscD1lLmRpdihoKTtzPTE9PT1wLnNoYXBlWzBdP2kuY2xvbmUoKTppLmNvbmNhdChwLnNsaWNlKFsxLDBdLFtwLnNoYXBlWzBdLTEscC5zaGFwZVsxXV0pLDApO3ZhciBmPWMubWF0TXVsKGgpLmRpdih1KS5uZWcoKSxkPWEuc2xpY2UoW3QsMF0sW24tdCxyXSksdj1mLm11bChzKTthPTA9PT10P2Quc3ViKHYubWF0TXVsKHMudHJhbnNwb3NlKCkubWF0TXVsKGQpKSk6YS5zbGljZShbMCwwXSxbdCxyXSkuY29uY2F0KGQuc3ViKHYubWF0TXVsKHMudHJhbnNwb3NlKCkubWF0TXVsKGQpKSksMCk7dmFyIG09by5zbGljZShbMCx0XSxbbixvLnNoYXBlWzFdLXRdKTtyZXR1cm4gbz0wPT09dD9tLnN1YihtLm1hdE11bChzKS5tYXRNdWwodi50cmFuc3Bvc2UoKSkpOm8uc2xpY2UoWzAsMF0sW24sdF0pLmNvbmNhdChtLnN1YihtLm1hdE11bChzKS5tYXRNdWwodi50cmFuc3Bvc2UoKSkpLDEpLFtzLGEsb119KSxzPWVbMF0sYT1lWzFdLG89ZVsyXSxCZShbdSxsLGNdKX0sYz0wO2M8dTsrK2MpbChjKTtyZXR1cm4hZSYmbj5yJiYobz1vLnNsaWNlKFswLDBdLFtuLHJdKSxhPWEuc2xpY2UoWzAsMF0sW3Iscl0pKSxbbyxhXX0pfXZhciBvYz1Bbih7Z3JhbVNjaG1pZHRfOmZ1bmN0aW9uKHQpe3ZhciBlO2lmKEFycmF5LmlzQXJyYXkodCkpe2U9ITEsZChudWxsIT10JiZ0Lmxlbmd0aD4wLGZ1bmN0aW9uKCl7cmV0dXJuXCJHcmFtLVNjaG1pZHQgcHJvY2VzczogaW5wdXQgbXVzdCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBvciBlbXB0eVwifSk7Zm9yKHZhciBuPXRbMF0uc2hhcGVbMF0scj1mdW5jdGlvbihlKXtkKHRbZV0uc2hhcGVbMF09PT1uLGZ1bmN0aW9uKCl7cmV0dXJuXCJHcmFtLVNjaG1pZHQ6IE5vbi11bmlxdWUgbGVuZ3RocyBmb3VuZCBpbiB0aGUgaW5wdXQgdmVjdG9yczogKFwiK3RbZV0uc2hhcGVbMF0rXCIgdnMuIFwiK24rXCIpXCJ9KX0sbz0xO288dC5sZW5ndGg7KytvKXIobyl9ZWxzZSBlPSEwLHQ9ZHIodCx0LnNoYXBlWzBdLDApLm1hcChmdW5jdGlvbih0KXtyZXR1cm4ganIodCxbMF0pfSk7ZCh0Lmxlbmd0aDw9dFswXS5zaGFwZVswXSxmdW5jdGlvbigpe3JldHVyblwiR3JhbS1TY2htaWR0OiBOdW1iZXIgb2YgdmVjdG9ycyAoXCIrdC5sZW5ndGgrXCIpIGV4Y2VlZHMgbnVtYmVyIG9mIGRpbWVuc2lvbnMgKFwiK3RbMF0uc2hhcGVbMF0rXCIpLlwifSk7dmFyIGE9W10saT10LHM9ZnVuY3Rpb24odCl7YS5wdXNoKER0LnRpZHkoZnVuY3Rpb24oKXt2YXIgZT1pW3RdO2lmKHQ+MClmb3IodmFyIG49MDtuPHQ7KytuKXt2YXIgcj1UdShhW25dLm11bFN0cmljdChlKSkubXVsKGFbbl0pO2U9ZS5zdWIocil9cmV0dXJuIGUuZGl2KFJsKGUsXCJldWNsaWRlYW5cIikpfSkpfTtmb3Iobz0wO288dC5sZW5ndGg7KytvKXMobyk7cmV0dXJuIGU/S3IoYSwwKTphfX0pLGFjPUFuKHtxcl86ZnVuY3Rpb24odCxlKXtpZih2b2lkIDA9PT1lJiYoZT0hMSksdC5yYW5rPDIpdGhyb3cgbmV3IEVycm9yKFwicXIoKSByZXF1aXJlcyBpbnB1dCB0ZW5zb3IgdG8gaGF2ZSBhIHJhbmsgPj0gMiwgYnV0IGdvdCByYW5rIFwiK3QucmFuayk7aWYoMj09PXQucmFuaylyZXR1cm4gcmModCxlKTt2YXIgbj10LnNoYXBlLnNsaWNlKDAsdC5zaGFwZS5sZW5ndGgtMikucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0pLHI9UXIodC5yZXNoYXBlKFtuLHQuc2hhcGVbdC5zaGFwZS5sZW5ndGgtMl0sdC5zaGFwZVt0LnNoYXBlLmxlbmd0aC0xXV0pLDApLG89W10sYT1bXTtyZXR1cm4gci5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBuPXJjKHQsZSkscj1uWzBdLGk9blsxXTtvLnB1c2gociksYS5wdXNoKGkpfSksW0tyKG8sMCkucmVzaGFwZSh0LnNoYXBlKSxLcihhLDApLnJlc2hhcGUodC5zaGFwZSldfX0pLGljPU9iamVjdC5mcmVlemUoe2dyYW1TY2htaWR0Om9jLHFyOmFjfSk7ZnVuY3Rpb24gc2ModCxlLG4scixvKXtudWxsPT1yJiYocj0uNSksbnVsbD09byYmKG89TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTt2YXIgYT10LnNoYXBlWzBdO3JldHVybiBuPU1hdGgubWluKG4sYSksZCgwPD1yJiZyPD0xLGZ1bmN0aW9uKCl7cmV0dXJuXCJpb3VUaHJlc2hvbGQgbXVzdCBiZSBpbiBbMCwgMV0sIGJ1dCB3YXMgJ1wiK3IrXCInXCJ9KSxkKDI9PT10LnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cImJveGVzIG11c3QgYmUgYSAyRCB0ZW5zb3IsIGJ1dCB3YXMgb2YgcmFuayAnXCIrdC5yYW5rK1wiJ1wifSksZCg0PT09dC5zaGFwZVsxXSxmdW5jdGlvbigpe3JldHVyblwiYm94ZXMgbXVzdCBoYXZlIDQgY29sdW1ucywgYnV0IDJuZCBkaW1lbnNpb24gd2FzIFwiK3Quc2hhcGVbMV19KSxkKDE9PT1lLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cInNjb3JlcyBtdXN0IGJlIGEgMUQgdGVuc29yXCJ9KSxkKGUuc2hhcGVbMF09PT1hLGZ1bmN0aW9uKCl7cmV0dXJuXCJzY29yZXMgaGFzIGluY29tcGF0aWJsZSBzaGFwZSB3aXRoIGJveGVzLiBFeHBlY3RlZCBcIithK1wiLCBidXQgd2FzIFwiK2Uuc2hhcGVbMF19KSx7bWF4T3V0cHV0U2l6ZTpuLGlvdVRocmVzaG9sZDpyLHNjb3JlVGhyZXNob2xkOm99fXZhciB1Yz1Bbih7cmVzaXplQmlsaW5lYXJfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9d24odCxcImltYWdlc1wiLFwicmVzaXplQmlsaW5lYXJcIik7ZCgzPT09ci5yYW5rfHw0PT09ci5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiByZXNpemVCaWxpbmVhcjogeCBtdXN0IGJlIHJhbmsgMyBvciA0LCBidXQgZ290IHJhbmsgXCIrci5yYW5rK1wiLlwifSksZCgyPT09ZS5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHJlc2l6ZUJpbGluZWFyOiBuZXcgc2hhcGUgbXVzdCAyRCwgYnV0IGdvdCBzaGFwZSBcIitlK1wiLlwifSk7dmFyIG89cixhPSExOzM9PT1yLnJhbmsmJihhPSEwLG89ci5hczREKDEsci5zaGFwZVswXSxyLnNoYXBlWzFdLHIuc2hhcGVbMl0pKTt2YXIgaT1lWzBdLHM9ZVsxXSx1PUR0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3JldHVybiBlKFtvXSksdC5yZXNpemVCaWxpbmVhcihvLGkscyxuKX0se2JhdGNoSW1hZ2VzOm99LGZ1bmN0aW9uKHQsZSl7cmV0dXJue2JhdGNoSW1hZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbihyKXtyZXR1cm4gci5yZXNpemVCaWxpbmVhckJhY2twcm9wKHQsZVswXSxuKX0se30pfX19KTtyZXR1cm4gYT91LmFzM0QodS5zaGFwZVsxXSx1LnNoYXBlWzJdLHUuc2hhcGVbM10pOnV9fSksbGM9QW4oe3Jlc2l6ZU5lYXJlc3ROZWlnaGJvcl86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPSExKTt2YXIgcj13bih0LFwiaW1hZ2VzXCIsXCJyZXNpemVOZWFyZXN0TmVpZ2hib3JcIik7ZCgzPT09ci5yYW5rfHw0PT09ci5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiByZXNpemVOZWFyZXN0TmVpZ2hib3I6IHggbXVzdCBiZSByYW5rIDMgb3IgNCwgYnV0IGdvdCByYW5rIFwiK3IucmFuaytcIi5cIn0pLGQoMj09PWUubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiByZXNpemVOZWFyZXN0TmVpZ2hib3I6IG5ldyBzaGFwZSBtdXN0IDJELCBidXQgZ290IHNoYXBlIFwiK2UrXCIuXCJ9KSxkKFwiZmxvYXQzMlwiPT09ci5kdHlwZXx8XCJpbnQzMlwiPT09ci5kdHlwZSxmdW5jdGlvbigpe3JldHVyblwiYGltYWdlc2AgbXVzdCBoYXZlIGBpbnQzMmAgb3IgYGZsb2F0MzJgIGFzIGR0eXBlXCJ9KTt2YXIgbz1yLGE9ITE7Mz09PXIucmFuayYmKGE9ITAsbz1yLmFzNEQoMSxyLnNoYXBlWzBdLHIuc2hhcGVbMV0sci5zaGFwZVsyXSkpO3ZhciBpPWVbMF0scz1lWzFdLHU9RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUoW29dKSx0LnJlc2l6ZU5lYXJlc3ROZWlnaGJvcihvLGkscyxuKX0se2JhdGNoSW1hZ2VzOm99LGZ1bmN0aW9uKHQsZSl7cmV0dXJue2JhdGNoSW1hZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbihyKXtyZXR1cm4gci5yZXNpemVOZWFyZXN0TmVpZ2hib3JCYWNrcHJvcCh0LGVbMF0sbil9LHt9KX19fSk7cmV0dXJuIGE/dS5hczNEKHUuc2hhcGVbMV0sdS5zaGFwZVsyXSx1LnNoYXBlWzNdKTp1fX0pLGNjPUFuKHtub25NYXhTdXBwcmVzc2lvbl86ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1yJiYocj0uNSksdm9pZCAwPT09byYmKG89TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTt2YXIgYT13bih0LFwiYm94ZXNcIixcIm5vbk1heFN1cHByZXNzaW9uXCIpLGk9d24oZSxcInNjb3Jlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25cIikscz1zYyhhLGksbixyLG8pO3JldHVybiBuPXMubWF4T3V0cHV0U2l6ZSxyPXMuaW91VGhyZXNob2xkLG89cy5zY29yZVRocmVzaG9sZCxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQubm9uTWF4U3VwcHJlc3Npb24oYSxpLG4scixvKX0seyRib3hlczphfSl9fSksaGM9ZnVuY3Rpb24odCxlLG4sYSxpKXtyZXR1cm4gdm9pZCAwPT09YSYmKGE9LjUpLHZvaWQgMD09PWkmJihpPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSkscih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgcixzLHUsbCxjLGg7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOnJldHVybiByPXduKHQsXCJib3hlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25Bc3luY1wiKSxzPXduKGUsXCJzY29yZXNcIixcIm5vbk1heFN1cHByZXNzaW9uQXN5bmNcIiksdT1zYyhyLHMsbixhLGkpLG49dS5tYXhPdXRwdXRTaXplLGE9dS5pb3VUaHJlc2hvbGQsaT11LnNjb3JlVGhyZXNob2xkLFs0LHIuZGF0YSgpXTtjYXNlIDE6cmV0dXJuIGw9by5zZW50KCksWzQscy5kYXRhKCldO2Nhc2UgMjpyZXR1cm4gYz1vLnNlbnQoKSxoPWFyKGwsYyxuLGEsaSksciE9PXQmJnIuZGlzcG9zZSgpLHMhPT1lJiZzLmRpc3Bvc2UoKSxbMixoXX19KX0pfSxwYz1Bbih7Y3JvcEFuZFJlc2l6ZV86ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBpPXduKHQsXCJpbWFnZVwiLFwiY3JvcEFuZFJlc2l6ZVwiLFwiZmxvYXQzMlwiKSxzPXduKGUsXCJib3hlc1wiLFwiY3JvcEFuZFJlc2l6ZVwiLFwiZmxvYXQzMlwiKSx1PXduKG4sXCJib3hJbmRcIixcImNyb3BBbmRSZXNpemVcIixcImludDMyXCIpO289b3x8XCJiaWxpbmVhclwiLGE9YXx8MDt2YXIgbD1zLnNoYXBlWzBdO3JldHVybiBkKDQ9PT1pLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNyb3BBbmRSZXNpemU6IGltYWdlIG11c3QgYmUgcmFuayA0LGJ1dCBnb3QgcmFuayBcIitpLnJhbmsrXCIuXCJ9KSxkKDI9PT1zLnJhbmsmJjQ9PT1zLnNoYXBlWzFdLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjcm9wQW5kUmVzaXplOiBib3hlcyBtdXN0IGJlIGhhdmUgc2l6ZSBbXCIrbCtcIiw0XSBidXQgaGFkIHNoYXBlIFwiK3Muc2hhcGUrXCIuXCJ9KSxkKDE9PT11LnJhbmsmJnUuc2hhcGVbMF09PT1sLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjcm9wQW5kUmVzaXplOiBib3hJbmQgbXVzdCBiZSBoYXZlIHNpemUgW1wiK2wrXCJdIGJ1dCBoYWQgc2hhcGUgXCIrcy5zaGFwZStcIi5cIn0pLGQoMj09PXIubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjcm9wQW5kUmVzaXplOiBjcm9wU2l6ZSBtdXN0IGJlIG9mIGxlbmd0aCAyLCBidXQgZ290IGxlbmd0aCBcIityLmxlbmd0aCtcIi5cIn0pLGQoclswXT49MSYmclsxXT49MSxmdW5jdGlvbigpe3JldHVyblwiY3JvcFNpemUgbXVzdCBiZSBhdGxlYXN0IFsxLDFdLCBidXQgd2FzIFwiK3J9KSxkKFwiYmlsaW5lYXJcIj09PW98fFwibmVhcmVzdFwiPT09byxmdW5jdGlvbigpe3JldHVyblwibWV0aG9kIG11c3QgYmUgYmlsaW5lYXIgb3IgbmVhcmVzdCwgYnV0IHdhcyBcIitvfSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuY3JvcEFuZFJlc2l6ZShpLHMsdSxyLG8sYSl9LHskaW1hZ2U6aSwkYm94ZXM6c30pfX0pLGZjPU9iamVjdC5mcmVlemUoe3Jlc2l6ZUJpbGluZWFyOnVjLHJlc2l6ZU5lYXJlc3ROZWlnaGJvcjpsYyxub25NYXhTdXBwcmVzc2lvbjpjYyxub25NYXhTdXBwcmVzc2lvbkFzeW5jOmhjLGNyb3BBbmRSZXNpemU6cGN9KTt2YXIgZGM9QW4oe21hdE11bF86ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBpO3ZvaWQgMD09PW4mJihuPSExKSx2b2lkIDA9PT1yJiYocj0hMSksdm9pZCAwPT09YSYmKGE9XCJsaW5lYXJcIik7dmFyIHM9d24odCxcImFcIixcImZ1c2VkIG1hdE11bFwiKSx1PXduKGUsXCJiXCIsXCJmdXNlZCBtYXRNdWxcIik7aT1SdChzLHUpLHM9aVswXSx1PWlbMV07dmFyIGw9bj9zLnNoYXBlW3MucmFuay0yXTpzLnNoYXBlW3MucmFuay0xXSxjPXI/dS5zaGFwZVt1LnJhbmstMV06dS5zaGFwZVt1LnJhbmstMl0saD1uP3Muc2hhcGVbcy5yYW5rLTFdOnMuc2hhcGVbcy5yYW5rLTJdLHA9cj91LnNoYXBlW3UucmFuay0yXTp1LnNoYXBlW3UucmFuay0xXSxmPXMuc2hhcGUuc2xpY2UoMCwtMiksdj11LnNoYXBlLnNsaWNlKDAsLTIpLG09eShmKSxnPXkodik7ZChzLnJhbms+PTImJnUucmFuaz49MiYmcy5yYW5rPT09dS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBmdXNlZCBtYXRNdWw6IGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgcmFuayBvZiBhdCBsZWFzdCAyLCBnb3QgcmFua3MgXCIrcy5yYW5rK1wiIGFuZCBcIit1LnJhbmsrXCIuXCJ9KSxkKHgoZix2KSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZnVzZWQgbWF0TXVsOiBvdXRlciBkaW1lbnNpb25zIChcIitmK1wiKSBhbmQgKFwiK3YrXCIpIG9mIFRlbnNvcnMgd2l0aCBzaGFwZXMgXCIrcy5zaGFwZStcIiBhbmQgXCIrdS5zaGFwZStcIiBtdXN0IG1hdGNoLlwifSksZChsPT09YyxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZnVzZWQgbWF0TXVsOiBpbm5lciBzaGFwZXMgKFwiK2wrXCIpIGFuZCAoXCIrYytcIikgb2YgVGVuc29ycyB3aXRoIHNoYXBlcyBcIitzLnNoYXBlK1wiIGFuZCBcIit1LnNoYXBlK1wiIGFuZCB0cmFuc3Bvc2VBPVwiK24rXCIgYW5kIHRyYW5zcG9zZUI9XCIrcitcIiBtdXN0IG1hdGNoLlwifSk7dmFyIHcsYj1zLnNoYXBlLnNsaWNlKDAsLTIpLmNvbmNhdChbaCxwXSksQz1uP3MuYXMzRChtLGwsaCk6cy5hczNEKG0saCxsKSxFPXI/dS5hczNEKGcscCxjKTp1LmFzM0QoZyxjLHApO251bGwhPW8mJnNvKGIsKHc9UnQodz13bihvLFwiYmlhc1wiLFwiZnVzZWQgbWF0TXVsXCIpLHMpWzBdKS5zaGFwZSk7dmFyIFI9eyRhOkMsJGI6RX07cmV0dXJuIG51bGwhPW8mJihSLiRiaWFzPXcpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBvPXQuZnVzZWRCYXRjaE1hdE11bChDLEUsbixyLHcsYSk7cmV0dXJuIGUoW0MsRSxvXSksb30sUixmdW5jdGlvbih0LGUpe3ZhciBpLHM9ZVswXSx1PWVbMV0sbD1lWzJdO2lmKG51bGw9PWF8fFwibGluZWFyXCI9PT1hKWk9dDtlbHNle2lmKFwicmVsdVwiIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJHcmFkaWVudCBmb3IgYWN0aXZhdGlvbiBcIithK1wiIGhhcyBub3QgYmVlbiBpbXBsZW1lbnRlZCB5ZXQuXCIpO2k9dC5tdWwobC5zdGVwKCkpfXZhciBjPXt9O3JldHVybiBudWxsIT1vJiYoYz17JGJpYXM6ZnVuY3Rpb24oKXt2YXIgdD1pLGU9aW8ody5zaGFwZSxpLnNoYXBlKTtyZXR1cm4gZS5sZW5ndGg+MCYmKHQ9dC5zdW0oZSkpLHQucmVzaGFwZSh3LnNoYXBlKX19KSxufHxyPyFuJiZyP09iamVjdC5hc3NpZ24oeyRhOmZ1bmN0aW9uKCl7cmV0dXJuIGkubWF0TXVsKHUsITEsITEpfSwkYjpmdW5jdGlvbigpe3JldHVybiBpLm1hdE11bChzLCEwLCExKX19LGMpOm4mJiFyP09iamVjdC5hc3NpZ24oeyRhOmZ1bmN0aW9uKCl7cmV0dXJuIHUubWF0TXVsKGksITEsITApfSwkYjpmdW5jdGlvbigpe3JldHVybiBzLm1hdE11bChpLCExLCExKX19LGMpOk9iamVjdC5hc3NpZ24oeyRhOmZ1bmN0aW9uKCl7cmV0dXJuIHUubWF0TXVsKGksITAsITApfSwkYjpmdW5jdGlvbigpe3JldHVybiBpLm1hdE11bChzLCEwLCEwKX19LGMpOk9iamVjdC5hc3NpZ24oeyRhOmZ1bmN0aW9uKCl7cmV0dXJuIGkubWF0TXVsKHUsITEsITApfSwkYjpmdW5jdGlvbigpe3JldHVybiBzLm1hdE11bChpLCEwLCExKX19LGMpfSkucmVzaGFwZShiKX19KSx2Yz1PYmplY3QuZnJlZXplKHttYXRNdWw6ZGN9KSxtYz1PYmplY3QuZnJlZXplKHtpbWFnZTpmYyxsaW5hbGc6aWMsbG9zc2VzOm5jLHNwZWN0cmFsOldsLGZ1c2VkOnZjLG9wOkFuLGJhdGNoTm9ybWFsaXphdGlvbjJkOkFzLGJhdGNoTm9ybWFsaXphdGlvbjNkOlRzLGJhdGNoTm9ybWFsaXphdGlvbjRkOkRzLGJhdGNoTm9ybWFsaXphdGlvbjpPcyxiYXRjaE5vcm06X3MsYmF0Y2hOb3JtMmQ6TXMsYmF0Y2hOb3JtM2Q6RnMsYmF0Y2hOb3JtNGQ6QnMsY29tcGxleDpPbixyZWFsOl9uLGltYWc6TW4sY29uY2F0OmxyLGNvbmNhdDFkOmNyLGNvbmNhdDJkOmhyLGNvbmNhdDNkOnByLGNvbmNhdDRkOmZyLHNwbGl0OmRyLGNvbnYxZDpYcyxjb252MmQ6WXMsY29udjNkOlFzLGNvbnYyZERlckZpbHRlcjpKcyxkZXB0aHdpc2VDb252MmQ6WnMsc2VwYXJhYmxlQ29udjJkOnR1LGNvbnYyZFRyYW5zcG9zZTpldSxtYXRNdWw6bnUsZG90OnJ1LG91dGVyUHJvZHVjdDpvdSxyZXZlcnNlOmF1LHJldmVyc2UxZDppdSxyZXZlcnNlMmQ6c3UscmV2ZXJzZTNkOnV1LHJldmVyc2U0ZDpsdSxtYXhQb29sOnB1LGF2Z1Bvb2w6ZnUscG9vbDpkdSxzbGljZTp2dSxzbGljZTFkOm11LHNsaWNlMmQ6Z3Usc2xpY2UzZDp5dSxzbGljZTRkOnh1LGFiczpWaSxhY29zOkdpLGFjb3NoOnFpLGFzaW46SGksYXNpbmg6JGksYXRhbjpqaSxhdGFuaDpLaSxjZWlsOlhpLGNsaXBCeVZhbHVlOllpLGNvczpRaSxjb3NoOkppLGVyZjpaaSxleHA6dHMsZXhwbTE6ZXMsZmxvb3I6bnMsbG9nOnJzLGxvZzFwOm9zLGxvZ1NpZ21vaWQ6YXMsbmVnOmlzLHJlY2lwcm9jYWw6c3Mscm91bmQ6dXMscnNxcnQ6bHMsc2lnbW9pZDpjcyxzaWduOmhzLGlzTmFOOnBzLGlzSW5mOmZzLGlzRmluaXRlOmRzLHNpbjp2cyxzaW5oOm1zLHNvZnRwbHVzOmdzLHNxcnQ6eXMsc3F1YXJlOnhzLHN0ZXA6d3MsdGFuOmJzLHRhbmg6Q3MsYWxsOmJ1LGFueTpDdSxhcmdNYXg6RXUsYXJnTWluOlJ1LGxvZ1N1bUV4cDpTdSxtYXg6TnUsbWVhbjprdSxtaW46SXUsbW9tZW50czpBdSxzdW06VHUscHJvZDpEdSxlcXVhbDpPdSxlcXVhbFN0cmljdDpfdSxncmVhdGVyOk11LGdyZWF0ZXJFcXVhbDpGdSxncmVhdGVyRXF1YWxTdHJpY3Q6QnUsZ3JlYXRlclN0cmljdDpQdSxsZXNzOkx1LGxlc3NFcXVhbDpXdSxsZXNzRXF1YWxTdHJpY3Q6VXUsbGVzc1N0cmljdDp6dSxub3RFcXVhbDpWdSxub3RFcXVhbFN0cmljdDpHdSxhZGQ6cXUsYWRkTjpIdSxhZGRTdHJpY3Q6JHUsYXRhbjI6anUsZGl2Okt1LGRpdlN0cmljdDpYdSxmbG9vckRpdjpZdSxtYXhpbXVtOlF1LG1heGltdW1TdHJpY3Q6SnUsbWluaW11bTpadSxtaW5pbXVtU3RyaWN0OnRsLG1vZDplbCxtb2RTdHJpY3Q6bmwsbXVsOnJsLG11bFN0cmljdDpvbCxwb3c6YWwscG93U3RyaWN0OmlsLHNxdWFyZWREaWZmZXJlbmNlOnNsLHNxdWFyZWREaWZmZXJlbmNlU3RyaWN0OnVsLHN1YjpsbCxzdWJTdHJpY3Q6Y2wsZWx1OmdsLGxlYWt5UmVsdTp5bCxwcmVsdTp4bCxyZWx1OndsLHNlbHU6YmwsbG9naWNhbEFuZDpobCxsb2dpY2FsTm90OnBsLGxvZ2ljYWxPcjpmbCxsb2dpY2FsWG9yOmRsLHdoZXJlOnZsLHdoZXJlQXN5bmM6bWwsYnVmZmVyOk5yLHByaW50OmtyLGJhdGNoVG9TcGFjZU5EOklyLGNhc3Q6QXIsY2xvbmU6VHIsY3Vtc3VtOkRyLGRlcHRoVG9TcGFjZTpPcixleHBhbmREaW1zOl9yLGV5ZTpNcixtdWx0aW5vbWlhbDpGcixvbmVIb3Q6QnIscGFkOlByLHBhZDFkOkxyLHBhZDJkOldyLHBhZDNkOlVyLHBhZDRkOnpyLHJhbmQ6VnIscmFuZG9tTm9ybWFsOkdyLHJhbmRvbVVuaWZvcm06cXIscmVzaGFwZTpIcixzcGFjZVRvQmF0Y2hORDokcixzcXVlZXplOmpyLHN0YWNrOktyLHRpbGU6WHIsdHJ1bmNhdGVkTm9ybWFsOllyLHVuc3RhY2s6UXIsc2V0ZGlmZjFkQXN5bmM6SnIsZmlsbDpIbixsaW5zcGFjZTokbixvbmVzOkduLHJhbmdlOmpuLHNjYWxhcjpCbix0ZW5zb3I6Rm4sdGVuc29yMWQ6UG4sdGVuc29yMmQ6TG4sdGVuc29yM2Q6V24sdGVuc29yNGQ6VW4sdGVuc29yNWQ6em4sdGVuc29yNmQ6Vm4semVyb3M6cW4sb25lc0xpa2U6S24semVyb3NMaWtlOlhuLHRyYW5zcG9zZTpDbCxzb2Z0bWF4OlRuLGxvZ1NvZnRtYXg6RG4sbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb246RWwsbm9ybTpSbCxnYXRoZXI6a2wsdW5zb3J0ZWRTZWdtZW50U3VtOklsLGJhc2ljTFNUTUNlbGw6QWwsbXVsdGlSTk5DZWxsOlRsLG1vdmluZ0F2ZXJhZ2U6RGwsc3RyaWRlZFNsaWNlOk9sLHRvcGs6X2wsc2NhdHRlck5EOk1sLGZmdDpGbCxpZmZ0OkJsLHJmZnQ6UGwsaXJmZnQ6TGwsc3BhcnNlVG9EZW5zZTpVbCxnYXRoZXJORDp6bCxkcm9wb3V0OlZsLGhhbm5XaW5kb3c6SGwsaGFtbWluZ1dpbmRvdzokbH0pO3ZhciBnYz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt0aGlzLmJsb2NrU2l6ZT00OCx0aGlzLmZpcnN0VXNlPSEwLGEuZ2V0KFwiSVNfQlJPV1NFUlwiKSYmKHRoaXMuZnJvbVBpeGVsczJEQ29udGV4dD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKSksdGhpcy5kYXRhPW5ldyBZbihEdCl9cmV0dXJuIHQucHJvdG90eXBlLnJlZ2lzdGVyPWZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLmZpcnN0VXNlJiYodGhpcy5maXJzdFVzZT0hMSxhLmdldChcIklTX05PREVcIikmJmplKFwiXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbkhpIHRoZXJlIPCfkYsuIExvb2tzIGxpa2UgeW91IGFyZSBydW5uaW5nIFRlbnNvckZsb3cuanMgaW4gTm9kZS5qcy4gVG8gc3BlZWQgdGhpbmdzIHVwIGRyYW1hdGljYWxseSwgaW5zdGFsbCBvdXIgbm9kZSBiYWNrZW5kLCB3aGljaCBiaW5kcyB0byBUZW5zb3JGbG93IEMrKywgYnkgcnVubmluZyBucG0gaSBAdGVuc29yZmxvdy90ZmpzLW5vZGUsIG9yIG5wbSBpIEB0ZW5zb3JmbG93L3RmanMtbm9kZS1ncHUgaWYgeW91IGhhdmUgQ1VEQS4gVGhlbiBjYWxsIHJlcXVpcmUoJ0B0ZW5zb3JmbG93L3RmanMtbm9kZScpOyAoLWdwdSBzdWZmaXggZm9yIENVREEpIGF0IHRoZSBzdGFydCBvZiB5b3VyIHByb2dyYW0uIFZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMtbm9kZSBmb3IgbW9yZSBkZXRhaWxzLlxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG5cIikpLHRoaXMuZGF0YS5oYXModCkpdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBidWZmZXIgaXMgYWxyZWFkeSByZWdpc3RlcmVkXCIpO3RoaXMuZGF0YS5zZXQodCx7ZHR5cGU6bn0pfSx0LnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbih0LGUpe2lmKG51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwiTWF0aEJhY2tlbmRDUFUud3JpdGUoKTogdmFsdWVzIGNhbiBub3QgYmUgbnVsbFwiKTt0aGlzLmRhdGEuZ2V0KHQpLnZhbHVlcz1lfSx0LnByb3RvdHlwZS5mcm9tUGl4ZWxzPWZ1bmN0aW9uKHQsZSl7aWYobnVsbD09dCl0aHJvdyBuZXcgRXJyb3IoXCJwaXhlbHMgcGFzc2VkIHRvIHRmLmJyb3dzZXIuZnJvbVBpeGVscygpIGNhbiBub3QgYmUgbnVsbFwiKTt2YXIgbixyO2lmKGEuZ2V0KFwiSVNfTk9ERVwiKSYmbnVsbD09dC5nZXRDb250ZXh0KXRocm93IG5ldyBFcnJvcihcIldoZW4gcnVubmluZyBpbiBub2RlLCBwaXhlbHMgbXVzdCBiZSBhbiBIVE1MQ2FudmFzRWxlbWVudCBsaWtlIHRoZSBvbmUgcmV0dXJuZWQgYnkgdGhlIGBjYW52YXNgIG5wbSBwYWNrYWdlXCIpO2lmKG51bGwhPXQuZ2V0Q29udGV4dCluPXQuZ2V0Q29udGV4dChcIjJkXCIpLmdldEltYWdlRGF0YSgwLDAsdC53aWR0aCx0LmhlaWdodCkuZGF0YTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBJbWFnZURhdGEpbj10LmRhdGE7ZWxzZXtpZighKHQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50fHx0IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkpdGhyb3cgbmV3IEVycm9yKFwicGl4ZWxzIHBhc3NlZCB0byB0Zi5icm93c2VyLmZyb21QaXhlbHMoKSBtdXN0IGJlIGVpdGhlciBhbiBIVE1MVmlkZW9FbGVtZW50LCBIVE1MSW1hZ2VFbGVtZW50LCBIVE1MQ2FudmFzRWxlbWVudCBvciBJbWFnZURhdGEsIGJ1dCB3YXMgXCIrdC5jb25zdHJ1Y3Rvci5uYW1lKTtpZihudWxsPT10aGlzLmZyb21QaXhlbHMyRENvbnRleHQpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcmVhZCBwaXhlbHMgZnJvbSBIVE1MSW1hZ2VFbGVtZW50IG91dHNpZGUgdGhlIGJyb3dzZXIuXCIpO3RoaXMuZnJvbVBpeGVsczJEQ29udGV4dC5jYW52YXMud2lkdGg9dC53aWR0aCx0aGlzLmZyb21QaXhlbHMyRENvbnRleHQuY2FudmFzLmhlaWdodD10LmhlaWdodCx0aGlzLmZyb21QaXhlbHMyRENvbnRleHQuZHJhd0ltYWdlKHQsMCwwLHQud2lkdGgsdC5oZWlnaHQpLG49dGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0LmdldEltYWdlRGF0YSgwLDAsdC53aWR0aCx0LmhlaWdodCkuZGF0YX1pZig0PT09ZSlyPW5ldyBJbnQzMkFycmF5KG4pO2Vsc2V7dmFyIG89dC53aWR0aCp0LmhlaWdodDtyPW5ldyBJbnQzMkFycmF5KG8qZSk7Zm9yKHZhciBpPTA7aTxvO2krKylmb3IodmFyIHM9MDtzPGU7KytzKXJbaSplK3NdPW5bNCppK3NdfXJldHVybiBXbihyLFt0LmhlaWdodCx0LndpZHRoLGVdLFwiaW50MzJcIil9LHQucHJvdG90eXBlLnJlYWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihlKXtyZXR1cm5bMix0aGlzLnJlYWRTeW5jKHQpXX0pfSl9LHQucHJvdG90eXBlLnJlYWRTeW5jPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZGF0YS5nZXQodCksbj1lLmR0eXBlLHI9ZS5jb21wbGV4VGVuc29ycztyZXR1cm5cImNvbXBsZXg2NFwiPT09bj9lcihyLnJlYWwuZGF0YVN5bmMoKSxyLmltYWcuZGF0YVN5bmMoKSk6dGhpcy5kYXRhLmdldCh0KS52YWx1ZXN9LHQucHJvdG90eXBlLmRpc3Bvc2VEYXRhPWZ1bmN0aW9uKHQpe2lmKHRoaXMuZGF0YS5oYXModCkpe3ZhciBlPXRoaXMuZGF0YS5nZXQodCkuY29tcGxleFRlbnNvcnM7bnVsbCE9ZSYmKGUucmVhbC5kaXNwb3NlKCksZS5pbWFnLmRpc3Bvc2UoKSksdGhpcy5kYXRhLmRlbGV0ZSh0KX19LHQucHJvdG90eXBlLnRpbWU9ZnVuY3Rpb24odCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihuKXtyZXR1cm4gZT1qKCksdCgpLFsyLHtrZXJuZWxNczpqKCktZX1dfSl9KX0sdC5wcm90b3R5cGUubWVtb3J5PWZ1bmN0aW9uKCl7cmV0dXJue3VucmVsaWFibGU6ITAscmVhc29uczpbXCJUaGUgcmVwb3J0ZWQgbWVtb3J5IGlzIGFuIHVwcGVyIGJvdW5kLiBEdWUgdG8gYXV0b21hdGljIGdhcmJhZ2UgY29sbGVjdGlvbiwgdGhlIHRydWUgYWxsb2NhdGVkIG1lbW9yeSBtYXkgYmUgbGVzcy5cIl19fSx0LnByb3RvdHlwZS5jb21wbGV4PWZ1bmN0aW9uKHQsZSl7dmFyIG49ZnQubWFrZSh0LnNoYXBlLHt9LFwiY29tcGxleDY0XCIpO3JldHVybiB0aGlzLmRhdGEuZ2V0KG4uZGF0YUlkKS5jb21wbGV4VGVuc29ycz17cmVhbDpEdC5rZWVwKHQuY2xvbmUoKSksaW1hZzpEdC5rZWVwKGUuY2xvbmUoKSl9LG59LHQucHJvdG90eXBlLnJlYWw9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGF0YS5nZXQodC5kYXRhSWQpLmNvbXBsZXhUZW5zb3JzLnJlYWwuY2xvbmUoKX0sdC5wcm90b3R5cGUuaW1hZz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kYXRhLmdldCh0LmRhdGFJZCkuY29tcGxleFRlbnNvcnMuaW1hZy5jbG9uZSgpfSx0LnByb3RvdHlwZS5hc3NlcnROb3RDb21wbGV4PWZ1bmN0aW9uKHQsZSl7QXJyYXkuaXNBcnJheSh0KXx8KHQ9W3RdKSx0LmZvckVhY2goZnVuY3Rpb24odCl7bnVsbCE9dCYmZChcImNvbXBsZXg2NFwiIT09dC5kdHlwZSxmdW5jdGlvbigpe3JldHVybiBlK1wiIGRvZXMgbm90IHN1cHBvcnQgY29tcGxleDY0IHRlbnNvcnMuXCJ9KX0pfSx0LnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbih0LGUsbil7aWYodGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJzbGljZVwiKSxtbih0LnNoYXBlLGUsbikpe3ZhciByPWduKGUsdC5zdHJpZGVzKSxvPXkobik7cmV0dXJuIEZuKHQuZGF0YVN5bmMoKS5zdWJhcnJheShyLHIrbyksbix0LmR0eXBlKX1mb3IodmFyIGE9TnIobix0LmR0eXBlKSxpPXQuYnVmZmVyU3luYygpLHM9MDtzPGEuc2l6ZTsrK3Mpe3ZhciB1PWEuaW5kZXhUb0xvYyhzKS5tYXAoZnVuY3Rpb24odCxuKXtyZXR1cm4gdCtlW25dfSk7YS52YWx1ZXNbc109aS5nZXQuYXBwbHkoaSx1KX1yZXR1cm4gYS50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5zdHJpZGVkU2xpY2U9ZnVuY3Rpb24odCxlLG4scixvLGEsaSxzLHUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwic3RyaWRlZFNsaWNlXCIpO3ZhciBsPWZuKHQuc2hhcGUsZSxuLHIsbyxhLGkscyx1KSxjPWxbMF0saD1sWzFdLHA9bFsyXSxmPWguZmlsdGVyKGZ1bmN0aW9uKHQsZSl7cmV0dXJuLTE9PT1wLmluZGV4T2YoZSl9KTtpZihmLnNvbWUoZnVuY3Rpb24odCl7cmV0dXJuIDA9PT10fSkpcmV0dXJuIEZuKFtdLGYpO2Zvcih2YXIgZD1OcihoLHQuZHR5cGUpLHY9dC5idWZmZXJTeW5jKCksbT0wO208ZC5zaXplO20rKyl7Zm9yKHZhciBnPWQuaW5kZXhUb0xvYyhtKSx5PW5ldyBBcnJheShnLmxlbmd0aCkseD0wO3g8eS5sZW5ndGg7eCsrKXlbeF09Z1t4XSpyW3hdK2NbeF07ZC5zZXQuYXBwbHkoZCxbdi5nZXQuYXBwbHkodix5KV0uY29uY2F0KGcpKX1yZXR1cm4gZC50b1RlbnNvcigpLnJlc2hhcGUoZil9LHQucHJvdG90eXBlLnVuc3RhY2s9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5zaGFwZVtlXSxyPW5ldyBBcnJheSh0LnJhbmstMSksbz0wLGE9MDthPHQucmFuazthKyspYSE9PWUmJihyW28rK109dC5zaGFwZVthXSk7dmFyIGk9bmV3IEFycmF5KHQucmFuaykuZmlsbCgwKSxzPXQuc2hhcGUuc2xpY2UoKTtzW2VdPTE7dmFyIHU9bmV3IEFycmF5KG4pO2ZvcihhPTA7YTx1Lmxlbmd0aDthKyspaVtlXT1hLHVbYV09dGhpcy5zbGljZSh0LGkscykucmVzaGFwZShyKTtyZXR1cm4gdX0sdC5wcm90b3R5cGUucmV2ZXJzZT1mdW5jdGlvbih0LGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwicmV2ZXJzZVwiKTtmb3IodmFyIG49TnIodC5zaGFwZSx0LmR0eXBlKSxyPXQuYnVmZmVyU3luYygpLG89ZnVuY3Rpb24obyl7dmFyIGE9bi5pbmRleFRvTG9jKG8pLGk9YS5zbGljZSgpO2UuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gaVtlXT10LnNoYXBlW2VdLTEtaVtlXX0pLG4uc2V0LmFwcGx5KG4sW3IuZ2V0LmFwcGx5KHIsaSldLmNvbmNhdChhKSl9LGE9MDthPG4uc2l6ZTthKyspbyhhKTtyZXR1cm4gbi50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5jb25jYXQ9ZnVuY3Rpb24odCxlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImNvbmNhdFwiKTt2YXIgbj10Lm1hcChmdW5jdGlvbih0KXt2YXIgbj15KHQuc2hhcGUuc2xpY2UoZSkpO3JldHVybiB0LmFzMkQoLTEsbil9KSxyPXNuKG4ubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSksMSksbz1OcihyLHRbMF0uZHR5cGUpLnZhbHVlcztpZigxPT09blswXS5zaGFwZVswXSl7dmFyIGE9MDtuLmZvckVhY2goZnVuY3Rpb24odCl7by5zZXQodC5kYXRhU3luYygpLGEpLGErPXQuc2l6ZX0pfWVsc2V7dmFyIGk9MDtuLmZvckVhY2goZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZGF0YVN5bmMoKSxuPTAsYT0wO2E8dC5zaGFwZVswXTsrK2EpZm9yKHZhciBzPWEqclsxXStpLHU9MDt1PHQuc2hhcGVbMV07Kyt1KW9bcyt1XT1lW24rK107aSs9dC5zaGFwZVsxXX0pfXZhciBzPXNuKHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSksZSk7cmV0dXJuIEZuKG8scyx0WzBdLmR0eXBlKX0sdC5wcm90b3R5cGUubmVnPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcIm5lZ1wiKSx0aGlzLm11bHRpcGx5KEJuKC0xKSx0KX0sdC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJjb21wbGV4NjRcIj09PXQuZHR5cGV8fFwiY29tcGxleDY0XCI9PT1lLmR0eXBlP3RoaXMuYnJvYWRjYXN0ZWRCaW5hcnlDb21wbGV4T3AodC5jYXN0KFwiY29tcGxleDY0XCIpLGUuY2FzdChcImNvbXBsZXg2NFwiKSxmdW5jdGlvbih0LGUsbixyKXtyZXR1cm57cmVhbDp0K24saW1hZzplK3J9fSk6dGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxDdCh0LmR0eXBlLGUuZHR5cGUpLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQrZX0pfSx0LnByb3RvdHlwZS5hZGROPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiYWRkTlwiKTtmb3IodmFyIGU9dC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuZGF0YVN5bmMoKX0pLG49TnIodFswXS5zaGFwZSx0WzBdLmR0eXBlKSxyPW4udmFsdWVzLG89MDtvPHQubGVuZ3RoO28rKylmb3IodmFyIGE9ZVtvXSxpPTA7aTxyLmxlbmd0aDtpKyspcltpXSs9YVtpXTtyZXR1cm4gbi50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5zdWJ0cmFjdD1mdW5jdGlvbih0LGUpe3JldHVyblwiY29tcGxleDY0XCI9PT10LmR0eXBlfHxcImNvbXBsZXg2NFwiPT09ZS5kdHlwZT90aGlzLmJyb2FkY2FzdGVkQmluYXJ5Q29tcGxleE9wKHQuY2FzdChcImNvbXBsZXg2NFwiKSxlLmNhc3QoXCJjb21wbGV4NjRcIiksZnVuY3Rpb24odCxlLG4scil7cmV0dXJue3JlYWw6dC1uLGltYWc6ZS1yfX0pOnRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsQ3QodC5kdHlwZSxlLmR0eXBlKSxmdW5jdGlvbih0LGUpe3JldHVybiB0LWV9KX0sdC5wcm90b3R5cGUucG93PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcInBvd1wiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLHQuZHR5cGUsZnVuY3Rpb24odCxlKXtyZXR1cm4gTWF0aC5wb3codCxlKX0pfSx0LnByb3RvdHlwZS5iYXRjaE1hdE11bD1mdW5jdGlvbih0LGUsbixyKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJtYXRNdWxcIik7Zm9yKHZhciBvPW4/dC5zaGFwZVsxXTp0LnNoYXBlWzJdLGE9bj90LnNoYXBlWzJdOnQuc2hhcGVbMV0saT1yP2Uuc2hhcGVbMV06ZS5zaGFwZVsyXSxzPXQuc2hhcGVbMF0sdT10LmRhdGFTeW5jKCksbD1lLmRhdGFTeW5jKCksYz1uP1t0LnN0cmlkZXNbMF0sMSx0LnN0cmlkZXNbMV1dOlt0LnN0cmlkZXNbMF0sdC5zdHJpZGVzWzFdLDFdLGg9Y1swXSxwPWNbMV0sZj1jWzJdLGQ9cj9bMSxlLnN0cmlkZXNbMV0sZS5zdHJpZGVzWzBdXTpbZS5zdHJpZGVzWzFdLDEsZS5zdHJpZGVzWzBdXSx2PWRbMF0sbT1kWzFdLGc9ZFsyXSx5PWEqaSx4PU5yKFtzLGEsaV0sdC5kdHlwZSksdz14LnZhbHVlcyxiPXRoaXMuYmxvY2tTaXplLEM9MDtDPHM7QysrKWZvcih2YXIgRT0wO0U8YTtFKz1iKWZvcih2YXIgUj0wO1I8aTtSKz1iKWZvcih2YXIgUz0wO1M8bztTKz1iKWZvcih2YXIgTj1NYXRoLm1pbihFK2IsYSksaz1NYXRoLm1pbihSK2IsaSksST1NYXRoLm1pbihTK2IsbyksQT1FO0E8TjtBKyspZm9yKHZhciBUPVI7VDxrO1QrKyl7Zm9yKHZhciBEPTAsTz1TO088STtPKyspRCs9dVtDKmgrQSpwK08qZl0qbFtPKnYrVCptK0MqZ107d1tDKnkrKEEqaStUKV0rPUR9cmV0dXJuIHgudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUuZnVzZWRCYXRjaE1hdE11bD1mdW5jdGlvbih0LGUsbixyLG8sYSl7dmFyIGk9dGhpcy5iYXRjaE1hdE11bCh0LGUsbixyKTtyZXR1cm4gbyYmKGk9dGhpcy5hZGQoaSxvKSksYSYmKGk9ZnVuY3Rpb24odCxlLG4pe2lmKFwibGluZWFyXCI9PT1lKXJldHVybiB0LmxpbmVhcihuKTtpZihcInJlbHVcIj09PWUpcmV0dXJuIHQucmVsdShuKTt0aHJvdyBuZXcgRXJyb3IoXCJBY3RpdmF0aW9uIFwiK2UrXCIgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIGZvciB0aGUgQ1BVIGJhY2tlbmQuXCIpfSh0aGlzLGEsaSkpLGl9LHQucHJvdG90eXBlLm11bHRpcGx5PWZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJjb21wbGV4NjRcIj09PXQuZHR5cGV8fFwiY29tcGxleDY0XCI9PT1lLmR0eXBlP3RoaXMuYnJvYWRjYXN0ZWRCaW5hcnlDb21wbGV4T3AodC5jYXN0KFwiY29tcGxleDY0XCIpLGUuY2FzdChcImNvbXBsZXg2NFwiKSxmdW5jdGlvbih0LGUsbixyKXtyZXR1cm57cmVhbDp0Km4tZSpyLGltYWc6dCpyK2Uqbn19KTp0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLEN0KHQuZHR5cGUsZS5kdHlwZSksZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSl9LHQucHJvdG90eXBlLnJlYWxEaXZpZGU9ZnVuY3Rpb24odCxlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJyZWFsRGl2aWRlXCIpO3JldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFwiZmxvYXQzMlwiLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQvZX0pfSx0LnByb3RvdHlwZS5mbG9vckRpdj1mdW5jdGlvbih0LGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcImZsb29yRGl2XCIpO3JldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFwiaW50MzJcIixmdW5jdGlvbih0LGUpe3JldHVybiBNYXRoLmZsb29yKHQvZSl9KX0sdC5wcm90b3R5cGUuc3VtPWZ1bmN0aW9uKHQsZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJzdW1cIiksbm4oXCJzdW1cIixlLHQucmFuayk7Zm9yKHZhciBuPXRuKHQuc2hhcGUsZSkscj1uWzBdLG89blsxXSxhPXFuKHIsQ3QodC5kdHlwZSxcImludDMyXCIpKSxpPXkobykscz1hLmRhdGFTeW5jKCksdT10LmRhdGFTeW5jKCksbD0wO2w8cy5sZW5ndGg7KytsKXtmb3IodmFyIGM9bCppLGg9MCxwPTA7cDxpOysrcCloKz11W2MrcF07c1tsXT1ofXJldHVybiBhfSx0LnByb3RvdHlwZS5wcm9kPWZ1bmN0aW9uKHQsZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJzdW1cIik7Zm9yKHZhciBuPXRuKHQuc2hhcGUsZSkscj1uWzBdLG89blsxXSxhPXFuKHIsQ3QodC5kdHlwZSxcImludDMyXCIpKSxpPXkobykscz1hLmRhdGFTeW5jKCksdT10LmRhdGFTeW5jKCksbD0wO2w8cy5sZW5ndGg7KytsKXtmb3IodmFyIGM9bCppLGg9MSxwPTA7cDxpOysrcCloKj11W2MrcF07c1tsXT1ofXJldHVybiBhfSx0LnByb3RvdHlwZS51bnNvcnRlZFNlZ21lbnRTdW09ZnVuY3Rpb24odCxlLG4pe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwidW5zb3J0ZWRTZWdtZW50U3VtXCIpO2Zvcih2YXIgcj1bXSxvPXQucmFuay1lLnJhbmssYT0wO2E8bzsrK2EpZT1lLmV4cGFuZERpbXMoYSsxKTtmb3IoYT0wO2E8bjsrK2Epe3ZhciBpPUJuKGEsXCJpbnQzMlwiKSxzPU91KGksZSkuYXNUeXBlKFwiZmxvYXQzMlwiKS5tdWwodCkuc3VtKDApO3IucHVzaChzKX1yZXR1cm4gS3Iocil9LHQucHJvdG90eXBlLmFyZ01pbj1mdW5jdGlvbih0LGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiYXJnTWluXCIpO3ZhciBuPVtlXTtubihcImFyZ01pblwiLG4sdC5yYW5rKTtmb3IodmFyIHI9dG4odC5zaGFwZSxuKSxvPXJbMF0sYT1yWzFdLGk9cW4obyxcImludDMyXCIpLHM9eShhKSx1PWkuZGF0YVN5bmMoKSxsPXQuZGF0YVN5bmMoKSxjPTA7Yzx1Lmxlbmd0aDsrK2Mpe2Zvcih2YXIgaD1jKnMscD1sW2hdLGY9MCxkPTA7ZDxzOysrZCl7dmFyIHY9bFtoK2RdO3Y8cCYmKHA9dixmPWQpfXVbY109Zn1yZXR1cm4gaX0sdC5wcm90b3R5cGUuYXJnTWF4PWZ1bmN0aW9uKHQsZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJhcmdNYXhcIik7dmFyIG49W2VdO25uKFwiYXJnTWF4XCIsbix0LnJhbmspO2Zvcih2YXIgcj10bih0LnNoYXBlLG4pLG89clswXSxhPXJbMV0saT1xbihvLFwiaW50MzJcIikscz15KGEpLHU9aS5kYXRhU3luYygpLGw9dC5kYXRhU3luYygpLGM9MDtjPHUubGVuZ3RoOysrYyl7Zm9yKHZhciBoPWMqcyxwPWxbaF0sZj0wLGQ9MDtkPHM7KytkKXt2YXIgdj1sW2grZF07dj5wJiYocD12LGY9ZCl9dVtjXT1mfXJldHVybiBpfSx0LnByb3RvdHlwZS5jdW1zdW09ZnVuY3Rpb24odCxlLG4scil7aWYodGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJjdW1zdW1cIiksZSE9PXQucmFuay0xKXRocm93IG5ldyBFcnJvcihcImJhY2tlbmQuY3Vtc3VtIGluIENQVSBleHBlY3RzIGFuIGlubmVyLW1vc3QgYXhpcz1cIisodC5yYW5rLTEpK1wiIGJ1dCBnb3QgYXhpcz1cIitlKTtmb3IodmFyIG89Q3QodC5kdHlwZSxcImludDMyXCIpLGE9cW4odC5zaGFwZSxvKSxpPWEuZGF0YVN5bmMoKSxzPXQuZGF0YVN5bmMoKSx1PXQuc2hhcGVbdC5yYW5rLTFdLGw9cj9mdW5jdGlvbih0LGUpe3JldHVybiB0K3UtZS0xfTpmdW5jdGlvbih0LGUpe3JldHVybiB0K2V9LGM9MDtjPHMubGVuZ3RoO2MrPXUpZm9yKHZhciBoPTA7aDx1O2grKyl7dmFyIHA9bChjLGgpO2lmKDA9PT1oKWlbcF09bj8wOnNbcF07ZWxzZXt2YXIgZj1sKGMsaC0xKTtpW3BdPW4/c1tmXStpW2ZdOnNbcF0raVtmXX19cmV0dXJuIGF9LHQucHJvdG90eXBlLmVxdWFsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcImVxdWFsXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJib29sXCIsZnVuY3Rpb24odCxlKXtyZXR1cm4gdD09PWU/MTowfSl9LHQucHJvdG90eXBlLm5vdEVxdWFsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcIm5vdEVxdWFsXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJib29sXCIsZnVuY3Rpb24odCxlKXtyZXR1cm4gdCE9PWU/MTowfSl9LHQucHJvdG90eXBlLmxlc3M9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwibGVzc1wiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFwiYm9vbFwiLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ8ZT8xOjB9KX0sdC5wcm90b3R5cGUubGVzc0VxdWFsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcImxlc3NFcXVhbFwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFwiYm9vbFwiLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ8PWU/MTowfSl9LHQucHJvdG90eXBlLmdyZWF0ZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwiZ3JlYXRlclwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFwiYm9vbFwiLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ+ZT8xOjB9KX0sdC5wcm90b3R5cGUuZ3JlYXRlckVxdWFsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcImdyZWF0ZXJFcXVhbFwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFwiYm9vbFwiLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ+PWU/MTowfSl9LHQucHJvdG90eXBlLmxvZ2ljYWxOb3Q9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJsb2dpY2FsTm90XCIpO2Zvcih2YXIgZT10LmRhdGFTeW5jKCksbj1uZXcgVWludDhBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKW5bcl09ZVtyXT8wOjE7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOm59LFwiYm9vbFwiKX0sdC5wcm90b3R5cGUubG9naWNhbEFuZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJsb2dpY2FsQW5kXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJib29sXCIsZnVuY3Rpb24odCxlKXtyZXR1cm4gdCYmZX0pfSx0LnByb3RvdHlwZS5sb2dpY2FsT3I9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwibG9naWNhbE9yXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJib29sXCIsZnVuY3Rpb24odCxlKXtyZXR1cm4gdHx8ZX0pfSx0LnByb3RvdHlwZS5zZWxlY3Q9ZnVuY3Rpb24odCxlLG4pe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlLG5dLFwic2VsZWN0XCIpO2Zvcih2YXIgcj10LmRhdGFTeW5jKCksbz1lLmRhdGFTeW5jKCksYT1uLmRhdGFTeW5jKCksaT1xbihlLnNoYXBlLEN0KGUuZHR5cGUsbi5kdHlwZSkpLHM9aS5kYXRhU3luYygpLHU9MCxsPTA9PT10LnJhbmt8fHQucmFuaz4xfHwxPT09ZS5yYW5rPzE6ZS5zaGFwZVsxXSxjPTA7YzxyLmxlbmd0aDtjKyspZm9yKHZhciBoPTA7aDxsO2grKykxPT09cltjXT9zW3UrK109b1tjXTpzW3UrK109YVtjXTtyZXR1cm4gaX0sdC5wcm90b3R5cGUud2hlcmU9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KFt0XSxcIndoZXJlXCIpO3ZhciBlPXQuZGF0YVN5bmMoKTtyZXR1cm4gWnIodC5zaGFwZSxlKX0sdC5wcm90b3R5cGUudG9waz1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwidG9wa1wiKSx1cih0LmRhdGFTeW5jKCksdC5zaGFwZSx0LmR0eXBlLGUpfSx0LnByb3RvdHlwZS5taW49ZnVuY3Rpb24odCxlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcIm1pblwiKSxubihcIm1pblwiLGUsdC5yYW5rKTtmb3IodmFyIG49dG4odC5zaGFwZSxlKSxyPW5bMF0sbz1uWzFdLGE9cW4ocix0LmR0eXBlKSxpPXkobykscz1hLmRhdGFTeW5jKCksdT10LmRhdGFTeW5jKCksbD0wO2w8cy5sZW5ndGg7KytsKXtmb3IodmFyIGM9bCppLGg9dVtjXSxwPTA7cDxpOysrcCl7dmFyIGY9dVtjK3BdO2Y8aCYmKGg9Zil9c1tsXT1ofXJldHVybiBhfSx0LnByb3RvdHlwZS5taW5pbXVtPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcIm1pbmltdW1cIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSx0LmR0eXBlLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIE1hdGgubWluKHQsZSl9KX0sdC5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcIm1vZFwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLHQuZHR5cGUsZnVuY3Rpb24odCxlKXt2YXIgbj10JWU7cmV0dXJuIHQ8MCYmZTwwfHx0Pj0wJiZlPj0wP246KG4rZSklZX0pfSx0LnByb3RvdHlwZS5tYXg9ZnVuY3Rpb24odCxlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcIm1heFwiKSxubihcIm1heFwiLGUsdC5yYW5rKTtmb3IodmFyIG49dG4odC5zaGFwZSxlKSxyPW5bMF0sbz1uWzFdLGE9cW4ocix0LmR0eXBlKSxpPXkobykscz1hLmRhdGFTeW5jKCksdT10LmRhdGFTeW5jKCksbD0wO2w8cy5sZW5ndGg7KytsKXtmb3IodmFyIGM9bCppLGg9dVtjXSxwPTA7cDxpOysrcCl7dmFyIGY9dVtjK3BdO2Y+aCYmKGg9Zil9c1tsXT1ofXJldHVybiBhfSx0LnByb3RvdHlwZS5tYXhpbXVtPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcIm1heGltdW1cIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSx0LmR0eXBlLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIE1hdGgubWF4KHQsZSl9KX0sdC5wcm90b3R5cGUuYWxsPWZ1bmN0aW9uKHQsZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJhbGxcIiksbm4oXCJhbGxcIixlLHQucmFuayk7Zm9yKHZhciBuPXRuKHQuc2hhcGUsZSkscj1uWzBdLG89blsxXSxhPXFuKHIsdC5kdHlwZSksaT15KG8pLHM9YS5kYXRhU3luYygpLHU9dC5kYXRhU3luYygpLGw9MDtsPHMubGVuZ3RoOysrbCl7Zm9yKHZhciBjPWwqaSxoPXVbY10scD0wO3A8aTsrK3Ape3ZhciBmPXVbYytwXTtoPWgmJmZ9c1tsXT1ofXJldHVybiBhfSx0LnByb3RvdHlwZS5hbnk9ZnVuY3Rpb24odCxlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImFueVwiKSxubihcImFueVwiLGUsdC5yYW5rKTtmb3IodmFyIG49dG4odC5zaGFwZSxlKSxyPW5bMF0sbz1uWzFdLGE9cW4ocix0LmR0eXBlKSxpPXkobykscz1hLmRhdGFTeW5jKCksdT10LmRhdGFTeW5jKCksbD0wO2w8cy5sZW5ndGg7KytsKXtmb3IodmFyIGM9bCppLGg9dVtjXSxwPTA7cDxpOysrcCl7dmFyIGY9dVtjK3BdO2g9aHx8Zn1zW2xdPWh9cmV0dXJuIGF9LHQucHJvdG90eXBlLnNxdWFyZWREaWZmZXJlbmNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcInNxdWFyZWREaWZmZXJlbmNlXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsdC5kdHlwZSxmdW5jdGlvbih0LGUpe3ZhciBuPXQtZTtyZXR1cm4gbipufSl9LHQucHJvdG90eXBlLmNlaWw9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJjZWlsXCIpO2Zvcih2YXIgZT10LmRhdGFTeW5jKCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpbltyXT1NYXRoLmNlaWwoZVtyXSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOm59KX0sdC5wcm90b3R5cGUuZmxvb3I9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJmbG9vclwiKTtmb3IodmFyIGU9dC5kYXRhU3luYygpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKW5bcl09TWF0aC5mbG9vcihlW3JdKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6bn0pfSx0LnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwieFwiKTtmb3IodmFyIGU9dC5kYXRhU3luYygpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKWVbcl08MD9uW3JdPS0xOmVbcl0+MD9uW3JdPTE6bltyXT0wO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczpufSl9LHQucHJvdG90eXBlLmlzTmFOPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwieFwiKTtmb3IodmFyIGU9dC5kYXRhU3luYygpLG49bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcilOdW1iZXIuaXNOYU4oZVtyXSkmJihuW3JdPTEpO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczpufSxcImJvb2xcIil9LHQucHJvdG90eXBlLmlzSW5mPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwieFwiKTtmb3IodmFyIGU9dC5kYXRhU3luYygpLG49bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcilNYXRoLmFicyhlW3JdKT09PTEvMCYmKG5bcl09MSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOm59LFwiYm9vbFwiKX0sdC5wcm90b3R5cGUuaXNGaW5pdGU9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJ4XCIpO2Zvcih2YXIgZT10LmRhdGFTeW5jKCksbj1uZXcgVWludDhBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKU51bWJlci5pc0Zpbml0ZShlW3JdKSYmKG5bcl09MSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOm59LFwiYm9vbFwiKX0sdC5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJyb3VuZFwiKTtmb3IodmFyIGU9dC5kYXRhU3luYygpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKXt2YXIgbz1NYXRoLmZsb29yKGVbcl0pO2Vbcl0tbzwuNT9uW3JdPU1hdGguZmxvb3IoZVtyXSk6ZVtyXS1vPi41P25bcl09TWF0aC5jZWlsKGVbcl0pOm5bcl09byUyPT0wP286bysxfXJldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczpufSl9LHQucHJvdG90eXBlLmV4cD1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImV4cFwiKTtmb3IodmFyIGU9dC5kYXRhU3luYygpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKW5bcl09TWF0aC5leHAoZVtyXSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOm59KX0sdC5wcm90b3R5cGUuZXhwbTE9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJleHBtMVwiKTtmb3IodmFyIGU9dC5kYXRhU3luYygpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKW5bcl09TWF0aC5leHBtMShlW3JdKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6bn0pfSx0LnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJsb2dcIik7Zm9yKHZhciBlPXQuZGF0YVN5bmMoKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcil7dmFyIG89ZVtyXTtuW3JdPU1hdGgubG9nKG8pfXJldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczpufSl9LHQucHJvdG90eXBlLmxvZzFwPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwibG9nMXBcIik7Zm9yKHZhciBlPXQuZGF0YVN5bmMoKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcil7dmFyIG89ZVtyXTtuW3JdPU1hdGgubG9nMXAobyl9cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOm59KX0sdC5wcm90b3R5cGUuc3FydD1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInNxcnRcIik7Zm9yKHZhciBlPXQuZGF0YVN5bmMoKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcil7dmFyIG89ZVtyXTtuW3JdPU1hdGguc3FydChvKX1yZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6bn0pfSx0LnByb3RvdHlwZS5yc3FydD1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInJzcXJ0XCIpO2Zvcih2YXIgZT10LmRhdGFTeW5jKCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3Ipe3ZhciBvPWVbcl07bltyXT0xL01hdGguc3FydChvKX1yZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6bn0pfSx0LnByb3RvdHlwZS5zcXVhcmU9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJzcXVhcmVcIik7Zm9yKHZhciBlPXQuZGF0YVN5bmMoKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcil7dmFyIG89ZVtyXTtuW3JdPW8qb31yZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6bn0pfSx0LnByb3RvdHlwZS5yZWNpcHJvY2FsPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwicmVjaXByb2NhbFwiKTtmb3IodmFyIGU9dC5kYXRhU3luYygpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKW5bcl09MS9lW3JdO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczpufSl9LHQucHJvdG90eXBlLmxpbmVhcj1mdW5jdGlvbih0KXtyZXR1cm4gdH0sdC5wcm90b3R5cGUucmVsdT1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInJlbHVcIik7Zm9yKHZhciBlPXFuKHQuc2hhcGUsdC5kdHlwZSksbj1lLmRhdGFTeW5jKCkscj10LmRhdGFTeW5jKCksbz0wO288ci5sZW5ndGg7KytvKW5bb109TWF0aC5tYXgoMCxyW29dKTtyZXR1cm4gZX0sdC5wcm90b3R5cGUucHJlbHU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwicHJlbHVcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSx0LmR0eXBlLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ8MD9lKnQ6dH0pfSx0LnByb3RvdHlwZS5lbHU9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJlbHVcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXQuZGF0YVN5bmMoKSxyPTA7cjxuLmxlbmd0aDsrK3Ipe3ZhciBvPW5bcl07ZVtyXT1vPj0wP286TWF0aC5leHAobyktMX1yZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS5lbHVEZXI9ZnVuY3Rpb24odCxlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJlbHVEZXJcIik7Zm9yKHZhciBuPW5ldyBGbG9hdDMyQXJyYXkoZS5zaXplKSxyPWUuZGF0YVN5bmMoKSxvPXQuZGF0YVN5bmMoKSxhPTA7YTxyLmxlbmd0aDsrK2Epe3ZhciBpPXJbYV07blthXT1pPj0xP29bYV06b1thXSooaSsxKX1yZXR1cm4gZnQubWFrZShlLnNoYXBlLHt2YWx1ZXM6bn0pfSx0LnByb3RvdHlwZS5zZWx1PWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwic2VsdVwiKTtmb3IodmFyIGU9Ymksbj1DaSxyPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxvPXQuZGF0YVN5bmMoKSxhPTA7YTxvLmxlbmd0aDsrK2Epe3ZhciBpPW9bYV07clthXT1pPj0wP24qaTplKihNYXRoLmV4cChpKS0xKX1yZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6cn0pfSx0LnByb3RvdHlwZS5jbGlwPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImNsaXBcIik7Zm9yKHZhciByPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxvPXQuZGF0YVN5bmMoKSxhPTA7YTxvLmxlbmd0aDsrK2Epe3ZhciBpPW9bYV07clthXT1pPm4/bjppPGU/ZTppfXJldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczpyfSl9LHQucHJvdG90eXBlLmFicz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dC5kYXRhU3luYygpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguYWJzKG5bcl0pO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLmNvbXBsZXhBYnM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXQuZGF0YVN5bmMoKSxyPTA7cjx0LnNpemU7KytyKXt2YXIgbz1uWzIqcl0sYT1uWzIqcisxXTtlW3JdPU1hdGguaHlwb3QobyxhKX1yZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS5pbnQ9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJpbnRcIik7Zm9yKHZhciBlPW5ldyBJbnQzMkFycmF5KHQuc2l6ZSksbj10LmRhdGFTeW5jKCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09bltyXTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6ZX0sXCJpbnQzMlwiKX0sdC5wcm90b3R5cGUuc2lnbW9pZD1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInNpZ21vaWRcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXQuZGF0YVN5bmMoKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT0xLygxK01hdGguZXhwKC1uW3JdKSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOmV9KX0sdC5wcm90b3R5cGUuc29mdHBsdXM9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJzb2Z0cGx1c1wiKTtmb3IodmFyIGU9TWF0aC5sb2coMS4xOTIwOTI4OTU1MDc4MTI1ZS03KSsyLG49bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLHI9dC5kYXRhU3luYygpLG89MDtvPHIubGVuZ3RoOysrbyl7dmFyIGE9cltvXT4tZSxpPXJbb108ZSxzPU1hdGguZXhwKHJbb10pLHU9dm9pZCAwO3U9aT9zOmE/cltvXTpNYXRoLmxvZygxK3MpLG5bb109dX1yZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6bn0pfSx0LnByb3RvdHlwZS5zaW49ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJzaW5cIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXQuZGF0YVN5bmMoKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLnNpbihuW3JdKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS5jb3M9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJjb3NcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXQuZGF0YVN5bmMoKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmNvcyhuW3JdKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS50YW49ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJ0YW5cIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXQuZGF0YVN5bmMoKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLnRhbihuW3JdKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS5hc2luPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiYXNpblwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dC5kYXRhU3luYygpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguYXNpbihuW3JdKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS5hY29zPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiYWNvc1wiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dC5kYXRhU3luYygpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguYWNvcyhuW3JdKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS5hdGFuPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiYXRhblwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dC5kYXRhU3luYygpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguYXRhbihuW3JdKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS5hdGFuMj1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJhdGFuMlwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLHQuZHR5cGUsZnVuY3Rpb24odCxlKXtyZXR1cm4gTWF0aC5hdGFuMih0LGUpfSl9LHQucHJvdG90eXBlLnNpbmg9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJzaW5oXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10LmRhdGFTeW5jKCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5zaW5oKG5bcl0pO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLmNvc2g9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJjb3NoXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10LmRhdGFTeW5jKCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5jb3NoKG5bcl0pO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLnRhbmg9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJ0YW5oXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10LmRhdGFTeW5jKCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09YihuW3JdKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS5hc2luaD1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImFzaW5oXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10LmRhdGFTeW5jKCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5hc2luaChuW3JdKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS5hY29zaD1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImFjb3NoXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10LmRhdGFTeW5jKCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5hY29zaChuW3JdKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS5hdGFuaD1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImF0YW5oXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10LmRhdGFTeW5jKCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5hdGFuaChuW3JdKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS5lcmY9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJlcmZcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXQuZGF0YVN5bmMoKSxyPTA7cjxuLmxlbmd0aDsrK3Ipe3ZhciBvPW5bcl0sYT0xLygxKy4zMjc1OTExKm8pO2Vbcl09MS0oKCgoMS4wNjE0MDU0MjkqYS0xLjQ1MzE1MjAyNykqYSsxLjQyMTQxMzc0MSkqYS0uMjg0NDk2NzM2KSphKy4yNTQ4Mjk1OTIpKmEqTWF0aC5leHAoLW8qbyl9cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOmV9KX0sdC5wcm90b3R5cGUuc3RlcD1mdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPTApLHRoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwic3RlcFwiKTtmb3IodmFyIG49bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLHI9dC5kYXRhU3luYygpLG89MDtvPHIubGVuZ3RoOysrbyl7dmFyIGE9cltvXTtpc05hTihhKT9uW29dPU5hTjpuW29dPWE+MD8xOmV9cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOm59KX0sdC5wcm90b3R5cGUuY29udjJkPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJjb252MmRcIik7Zm9yKHZhciByPW4uZmlsdGVySGVpZ2h0LG89bi5maWx0ZXJXaWR0aCxhPW4uZGlsYXRpb25IZWlnaHQsaT1uLmRpbGF0aW9uV2lkdGgscz1uLnBhZEluZm8ubGVmdCx1PW4ucGFkSW5mby50b3AsbD1OcihuLm91dFNoYXBlLHQuZHR5cGUpLGM9dC5kYXRhU3luYygpLGg9ZS5kYXRhU3luYygpLHA9bC52YWx1ZXMsZj0wO2Y8bi5iYXRjaFNpemU7KytmKWZvcih2YXIgZD1mKnQuc3RyaWRlc1swXSx2PWYqbC5zdHJpZGVzWzBdLG09MDttPG4ub3V0SGVpZ2h0OysrbSlmb3IodmFyIGc9dittKmwuc3RyaWRlc1sxXSx5PW0qbi5zdHJpZGVIZWlnaHQtcyx4PTA7eDxyO3grKyl7dmFyIHc9eSt4KmE7aWYoISh3PDB8fHc+PW4uaW5IZWlnaHQpKWZvcih2YXIgYj14KmUuc3RyaWRlc1swXSxDPWQrdyp0LnN0cmlkZXNbMV0sRT0wO0U8bi5vdXRXaWR0aDsrK0UpZm9yKHZhciBSPWcrRSpuLm91dENoYW5uZWxzLFM9RSpuLnN0cmlkZVdpZHRoLXUsTj0wO048bztOKyspe3ZhciBrPVMrTippO2lmKCEoazwwfHxrPj1uLmluV2lkdGgpKWZvcih2YXIgST1iK04qZS5zdHJpZGVzWzFdLEE9QytrKm4uaW5DaGFubmVscyxUPUksRD0wO0Q8bi5pbkNoYW5uZWxzOysrRCl7Zm9yKHZhciBPPWNbQStEXSxfPTA7XzxuLm91dENoYW5uZWxzOysrXylwW1IrX10rPU8qaFtUK19dO1QrPW4ub3V0Q2hhbm5lbHN9fX1yZXR1cm4gbC50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5jb252M2Q9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj1uLmZpbHRlckRlcHRoLG89bi5maWx0ZXJIZWlnaHQsYT1uLmZpbHRlcldpZHRoLGk9bi5kaWxhdGlvbkRlcHRoLHM9bi5kaWxhdGlvbkhlaWdodCx1PW4uZGlsYXRpb25XaWR0aCxsPW4ucGFkSW5mby5mcm9udCxjPW4ucGFkSW5mby5sZWZ0LGg9bi5wYWRJbmZvLnRvcCxwPU5yKG4ub3V0U2hhcGUsdC5kdHlwZSksZj10LmRhdGFTeW5jKCksZD1lLmRhdGFTeW5jKCksdj1wLnZhbHVlcyxtPTA7bTxuLmJhdGNoU2l6ZTsrK20pZm9yKHZhciBnPW0qdC5zdHJpZGVzWzBdLHk9bSpwLnN0cmlkZXNbMF0seD0wO3g8bi5vdXREZXB0aDsrK3gpZm9yKHZhciB3PXkreCpwLnN0cmlkZXNbMV0sYj14Km4uc3RyaWRlRGVwdGgtbCxDPTA7QzxyO0MrKyl7dmFyIEU9YitDKmk7aWYoIShFPDB8fEU+PW4uaW5EZXB0aCkpZm9yKHZhciBSPUMqZS5zdHJpZGVzWzBdLFM9ZytFKnQuc3RyaWRlc1sxXSxOPTA7TjxuLm91dEhlaWdodDsrK04pZm9yKHZhciBrPXcrTipwLnN0cmlkZXNbMl0sST1OKm4uc3RyaWRlSGVpZ2h0LWgsQT0wO0E8bztBKyspe3ZhciBUPUkrQSpzO2lmKCEoVDwwfHxUPj1uLmluSGVpZ2h0KSlmb3IodmFyIEQ9UitBKmUuc3RyaWRlc1sxXSxPPVMrVCp0LnN0cmlkZXNbMl0sXz0wO188bi5vdXRXaWR0aDsrK18pZm9yKHZhciBNPWsrXypuLm91dENoYW5uZWxzLEY9XypuLnN0cmlkZVdpZHRoLWMsQj0wO0I8YTtCKyspe3ZhciBQPUYrQip1O2lmKCEoUDwwfHxQPj1uLmluV2lkdGgpKWZvcih2YXIgTD1EK0IqZS5zdHJpZGVzWzJdLFc9TytQKm4uaW5DaGFubmVscyxVPUwsej0wO3o8bi5pbkNoYW5uZWxzOysreil7Zm9yKHZhciBWPWZbVyt6XSxHPTA7RzxuLm91dENoYW5uZWxzOysrRyl2W00rR10rPVYqZFtVK0ddO1UrPW4ub3V0Q2hhbm5lbHN9fX19cmV0dXJuIHAudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUuY29udjJkRGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcImNvbnYyZERlcklucHV0XCIpO2Zvcih2YXIgcj1OcihuLmluU2hhcGUsXCJmbG9hdDMyXCIpLG89ci52YWx1ZXMsYT1yLnN0cmlkZXMsaT1hWzBdLHM9YVsxXSx1PWFbMl0sbD10LmRhdGFTeW5jKCksYz10LnN0cmlkZXMsaD1jWzBdLHA9Y1sxXSxmPWNbMl0sZD1lLmRhdGFTeW5jKCksdj1lLnN0cmlkZXMsbT12WzBdLGc9dlsxXSx5PXZbMl0seD1uLmJhdGNoU2l6ZSx3PW4uZmlsdGVySGVpZ2h0LGI9bi5maWx0ZXJXaWR0aCxDPW4uaW5DaGFubmVscyxFPW4uaW5IZWlnaHQsUj1uLmluV2lkdGgsUz1uLm91dENoYW5uZWxzLE49bi5vdXRIZWlnaHQsaz1uLm91dFdpZHRoLEk9bi5zdHJpZGVIZWlnaHQsQT1uLnN0cmlkZVdpZHRoLFQ9dy0xLW4ucGFkSW5mby50b3AsRD1iLTEtbi5wYWRJbmZvLmxlZnQsTz0wO088eDsrK08pZm9yKHZhciBfPTA7XzxDOysrXylmb3IodmFyIE09MDtNPEU7KytNKWZvcih2YXIgRj1NLVQsQj1NYXRoLm1heCgwLE1hdGguY2VpbChGL0kpKSxQPU1hdGgubWluKE4sKHcrRikvSSksTD0wO0w8UjsrK0wpe2Zvcih2YXIgVz1MLUQsVT1NYXRoLm1heCgwLE1hdGguY2VpbChXL0EpKSx6PU1hdGgubWluKGssKGIrVykvQSksVj0wLEc9QjtHPFA7KytHKWZvcih2YXIgcT1HKkktRixIPVU7SDx6OysrSClmb3IodmFyICQ9aCpPK3AqRytmKkgsaj1tKih3LTEtcSkrZyooYi0xLShIKkEtVykpK3kqXyxLPTA7SzxTOysrSyl7Vis9bFskK0tdKmRbaitLXX1vW2kqTytzKk0rdSpMK19dPVZ9cmV0dXJuIHIudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUuY29udjNkRGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj1OcihuLmluU2hhcGUsXCJmbG9hdDMyXCIpLG89ci52YWx1ZXMsYT1yLnN0cmlkZXMsaT1hWzBdLHM9YVsxXSx1PWFbMl0sbD1hWzNdLGM9dC5kYXRhU3luYygpLGg9dC5zdHJpZGVzLHA9aFswXSxmPWhbMV0sZD1oWzJdLHY9aFszXSxtPWUuZGF0YVN5bmMoKSxnPWUuc3RyaWRlcyx5PWdbMF0seD1nWzFdLHc9Z1syXSxiPWdbM10sQz1uLmJhdGNoU2l6ZSxFPW4uZmlsdGVyRGVwdGgsUj1uLmZpbHRlckhlaWdodCxTPW4uZmlsdGVyV2lkdGgsTj1uLmluQ2hhbm5lbHMsaz1uLmluRGVwdGgsST1uLmluSGVpZ2h0LEE9bi5pbldpZHRoLFQ9bi5vdXRDaGFubmVscyxEPW4ub3V0RGVwdGgsTz1uLm91dEhlaWdodCxfPW4ub3V0V2lkdGgsTT1uLnN0cmlkZURlcHRoLEY9bi5zdHJpZGVIZWlnaHQsQj1uLnN0cmlkZVdpZHRoLFA9RS0xLW4ucGFkSW5mby5mcm9udCxMPVItMS1uLnBhZEluZm8udG9wLFc9Uy0xLW4ucGFkSW5mby5sZWZ0LFU9MDtVPEM7KytVKWZvcih2YXIgej0wO3o8TjsrK3opZm9yKHZhciBWPTA7VjxrOysrVilmb3IodmFyIEc9Vi1QLHE9TWF0aC5tYXgoMCxNYXRoLmNlaWwoRy9NKSksSD1NYXRoLm1pbihELChFK0cpL00pLCQ9MDskPEk7KyskKWZvcih2YXIgaj0kLUwsSz1NYXRoLm1heCgwLE1hdGguY2VpbChqL0YpKSxYPU1hdGgubWluKE8sKFIraikvRiksWT0wO1k8QTsrK1kpe2Zvcih2YXIgUT1ZLVcsSj1NYXRoLm1heCgwLE1hdGguY2VpbChRL0IpKSxaPU1hdGgubWluKF8sKFMrUSkvQiksdHQ9MCxldD1xO2V0PEg7KytldClmb3IodmFyIG50PWV0Kk0tRyxydD1LO3J0PFg7KytydClmb3IodmFyIG90PXJ0KkYtaixhdD1KO2F0PFo7KythdClmb3IodmFyIGl0PXAqVStmKmV0K2QqcnQrdiphdCxzdD15KihFLTEtbnQpK3gqKFItMS1vdCkrdyooUy0xLShhdCpCLVEpKStiKnosdXQ9MDt1dDxUOysrdXQpe3R0Kz1jW2l0K3V0XSptW3N0K3V0XX1vW2kqVStzKlYrdSokK2wqWSt6XT10dH1yZXR1cm4gci50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5jb252MmREZXJGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcImNvbnYyZERlckZpbHRlclwiKTtmb3IodmFyIHI9bi5zdHJpZGVIZWlnaHQsbz1uLnN0cmlkZVdpZHRoLGE9bi5maWx0ZXJIZWlnaHQsaT1uLmZpbHRlcldpZHRoLHM9TnIobi5maWx0ZXJTaGFwZSxcImZsb2F0MzJcIiksdT1uLnBhZEluZm8ubGVmdCxsPW4ucGFkSW5mby50b3AsYz10LmJ1ZmZlclN5bmMoKSxoPWUuYnVmZmVyU3luYygpLHA9MDtwPGE7KytwKWZvcih2YXIgZj1NYXRoLm1heCgwLE1hdGguY2VpbCgobC1wKS9yKSksZD1NYXRoLm1pbihuLm91dEhlaWdodCwobi5pbkhlaWdodCtsLXApL3IpLHY9MDt2PGk7Kyt2KWZvcih2YXIgbT1NYXRoLm1heCgwLE1hdGguY2VpbCgodS12KS9vKSksZz1NYXRoLm1pbihuLm91dFdpZHRoLChuLmluV2lkdGgrdS12KS9vKSx5PTA7eTxuLmluQ2hhbm5lbHM7Kyt5KWZvcih2YXIgeD0wO3g8bi5vdXRDaGFubmVsczsrK3gpe2Zvcih2YXIgdz0wLGI9MDtiPG4uYmF0Y2hTaXplOysrYilmb3IodmFyIEM9ZjtDPGQ7KytDKWZvcih2YXIgRT1wK0Mqci1sLFI9bTtSPGc7KytSKXt2YXIgUz12K1Iqby11O3crPWMuZ2V0KGIsRSxTLHkpKmguZ2V0KGIsQyxSLHgpfXMuc2V0KHcscCx2LHkseCl9cmV0dXJuIHMudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUuY29udjNkRGVyRmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9bi5zdHJpZGVEZXB0aCxvPW4uc3RyaWRlSGVpZ2h0LGE9bi5zdHJpZGVXaWR0aCxpPW4uZmlsdGVyRGVwdGgscz1uLmZpbHRlckhlaWdodCx1PW4uZmlsdGVyV2lkdGgsbD1OcihuLmZpbHRlclNoYXBlLFwiZmxvYXQzMlwiKSxjPWwudmFsdWVzLGg9bC5zdHJpZGVzLHA9aFswXSxmPWhbMV0sZD1oWzJdLHY9aFszXSxtPWUuZGF0YVN5bmMoKSxnPWUuc3RyaWRlcyx5PWdbMF0seD1nWzFdLHc9Z1syXSxiPWdbM10sQz10LmRhdGFTeW5jKCksRT10LnN0cmlkZXMsUj1FWzBdLFM9RVsxXSxOPUVbMl0saz1FWzNdLEk9bi5wYWRJbmZvLmZyb250LEE9bi5wYWRJbmZvLmxlZnQsVD1uLnBhZEluZm8udG9wLEQ9MDtEPGk7KytEKWZvcih2YXIgTz1NYXRoLm1heCgwLE1hdGguY2VpbCgoSS1EKS9yKSksXz1NYXRoLm1pbihuLm91dERlcHRoLChuLmluRGVwdGgrSS1EKS9yKSxNPUQqcCxGPTA7RjxzOysrRilmb3IodmFyIEI9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKFQtRikvbykpLFA9TWF0aC5taW4obi5vdXRIZWlnaHQsKG4uaW5IZWlnaHQrVC1GKS9vKSxMPUYqZitNLFc9MDtXPHU7KytXKWZvcih2YXIgVT1NYXRoLm1heCgwLE1hdGguY2VpbCgoQS1XKS9hKSksej1NYXRoLm1pbihuLm91dFdpZHRoLChuLmluV2lkdGgrQS1XKS9hKSxWPVcqZCtMLEc9MDtHPG4uaW5DaGFubmVsczsrK0cpZm9yKHZhciBxPUcqditWLEg9MDtIPG4ub3V0Q2hhbm5lbHM7KytIKXtmb3IodmFyICQ9MCxqPTA7ajxuLmJhdGNoU2l6ZTsrK2opZm9yKHZhciBLPWoqUixYPWoqeSxZPU87WTxfOysrWSlmb3IodmFyIFE9KEQrWSpyLUkpKlMrSyxKPVkqeCtYLFo9QjtaPFA7KytaKWZvcih2YXIgdHQ9KEYrWipvLVQpKk4rUSxldD1aKncrSixudD1VO250PHo7KytudCl7dmFyIHJ0PW50KmIrZXQ7JCs9Q1soVytudCphLUEpKmsrdHQrR10qbVtydCtIXX1jW3ErSF09JH1yZXR1cm4gbC50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkQ9ZnVuY3Rpb24odCxlLG4pe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcImRlcHRod2lzZUNvbnYyRFwiKTtmb3IodmFyIHI9bi5maWx0ZXJIZWlnaHQsbz1uLmZpbHRlcldpZHRoLGE9bi5kaWxhdGlvbkhlaWdodCxpPW4uZGlsYXRpb25XaWR0aCxzPW4ucGFkSW5mby5sZWZ0LHU9bi5wYWRJbmZvLnRvcCxsPW4ub3V0Q2hhbm5lbHMvbi5pbkNoYW5uZWxzLGM9TnIobi5vdXRTaGFwZSx0LmR0eXBlKSxoPXQuZGF0YVN5bmMoKSxwPWUuZGF0YVN5bmMoKSxmPWMudmFsdWVzLGQ9MDtkPG4uYmF0Y2hTaXplOysrZClmb3IodmFyIHY9ZCp0LnN0cmlkZXNbMF0sbT1kKmMuc3RyaWRlc1swXSxnPTA7ZzxuLm91dEhlaWdodDsrK2cpZm9yKHZhciB5PW0rZypjLnN0cmlkZXNbMV0seD1nKm4uc3RyaWRlSGVpZ2h0LXMsdz0wO3c8cjsrK3cpe3ZhciBiPXgrdyphO2lmKCEoYjwwfHxiPj1uLmluSGVpZ2h0KSlmb3IodmFyIEM9dyplLnN0cmlkZXNbMF0sRT12K2IqdC5zdHJpZGVzWzFdLFI9MDtSPG4ub3V0V2lkdGg7KytSKWZvcih2YXIgUz15K1IqYy5zdHJpZGVzWzJdLE49UipuLnN0cmlkZVdpZHRoLXUsaz0wO2s8bzsrK2spe3ZhciBJPU4rayppO2lmKCEoSTwwfHxJPj1uLmluV2lkdGgpKWZvcih2YXIgQT1DK2sqZS5zdHJpZGVzWzFdLFQ9RStJKm4uaW5DaGFubmVscyxEPVMsTz1BLF89MDtfPG4uaW5DaGFubmVsczsrK18pe2Zvcih2YXIgTT1oW1QrX10sRj0wO0Y8bDsrK0YpZltEK0ZdKz1NKnBbTytGXTtEKz1sLE8rPWx9fX1yZXR1cm4gYy50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkREZXJJbnB1dD1mdW5jdGlvbih0LGUsbil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwiZGVwdGh3aXNlQ29udjJERGVySW5wdXRcIik7Zm9yKHZhciByPU5yKG4uaW5TaGFwZSxcImZsb2F0MzJcIiksbz1yLnZhbHVlcyxhPXIuc3RyaWRlcyxpPWFbMF0scz1hWzFdLHU9YVsyXSxsPXQuZGF0YVN5bmMoKSxjPXQuc3RyaWRlcyxoPWNbMF0scD1jWzFdLGY9Y1syXSxkPWUuZGF0YVN5bmMoKSx2PWUuc3RyaWRlcyxtPXZbMF0sZz12WzFdLHk9dlsyXSx4PW4uYmF0Y2hTaXplLHc9bi5maWx0ZXJIZWlnaHQsYj1uLmZpbHRlcldpZHRoLEM9bi5pbkNoYW5uZWxzLEU9bi5pbkhlaWdodCxSPW4uaW5XaWR0aCxTPW4ub3V0Q2hhbm5lbHMsTj1uLm91dEhlaWdodCxrPW4ub3V0V2lkdGgsST1uLnN0cmlkZUhlaWdodCxBPW4uc3RyaWRlV2lkdGgsVD13LTEtbi5wYWRJbmZvLnRvcCxEPWItMS1uLnBhZEluZm8ubGVmdCxPPVMvQyxfPTA7Xzx4OysrXylmb3IodmFyIE09MDtNPEM7KytNKWZvcih2YXIgRj0wO0Y8RTsrK0YpZm9yKHZhciBCPUYtVCxQPU1hdGgubWF4KDAsTWF0aC5jZWlsKEIvSSkpLEw9TWF0aC5taW4oTiwodytCKS9JKSxXPTA7VzxSOysrVyl7Zm9yKHZhciBVPVctRCx6PU1hdGgubWF4KDAsTWF0aC5jZWlsKFUvQSkpLFY9TWF0aC5taW4oaywoYitVKS9BKSxHPTAscT1QO3E8TDsrK3EpZm9yKHZhciBIPXEqSS1CLCQ9ejskPFY7KyskKWZvcih2YXIgaj1oKl8rcCpxK2YqJCxLPW0qKHctMS1IKStnKihiLTEtKCQqQS1VKSkreSpNLFg9MDtYPE87KytYKXtHKz1sW2orKE0qTytYKV0qZFtLK1hdfW9baSpfK3MqRit1KlcrTV09R31yZXR1cm4gci50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkREZXJGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcImRlcHRod2lzZUNvbnYyRERlckZpbHRlclwiKTtmb3IodmFyIHI9bi5zdHJpZGVIZWlnaHQsbz1uLnN0cmlkZVdpZHRoLGE9bi5maWx0ZXJIZWlnaHQsaT1uLmZpbHRlcldpZHRoLHM9TnIobi5maWx0ZXJTaGFwZSxcImZsb2F0MzJcIiksdT1uLnBhZEluZm8ubGVmdCxsPW4ucGFkSW5mby50b3AsYz1uLm91dENoYW5uZWxzL24uaW5DaGFubmVscyxoPXQuYnVmZmVyU3luYygpLHA9ZS5idWZmZXJTeW5jKCksZj0wO2Y8YTsrK2YpZm9yKHZhciBkPU1hdGgubWF4KDAsTWF0aC5jZWlsKChsLWYpL3IpKSx2PU1hdGgubWluKG4ub3V0SGVpZ2h0LChuLmluSGVpZ2h0K2wtZikvciksbT0wO208aTsrK20pZm9yKHZhciBnPU1hdGgubWF4KDAsTWF0aC5jZWlsKCh1LW0pL28pKSx5PU1hdGgubWluKG4ub3V0V2lkdGgsKG4uaW5XaWR0aCt1LW0pL28pLHg9MDt4PG4ub3V0Q2hhbm5lbHM7Kyt4KXtmb3IodmFyIHc9TWF0aC50cnVuYyh4L2MpLGI9eCVjLEM9MCxFPTA7RTxuLmJhdGNoU2l6ZTsrK0UpZm9yKHZhciBSPWQ7Ujx2OysrUilmb3IodmFyIFM9ZitSKnItbCxOPWc7Tjx5OysrTil7dmFyIGs9bStOKm8tdTtDKz1oLmdldChFLFMsayx3KSpwLmdldChFLFIsTix4KX1zLnNldChDLGYsbSx3LGIpfXJldHVybiBzLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLnRpbGU9ZnVuY3Rpb24odCxlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInRpbGVcIik7Zm9yKHZhciBuPW5ldyBBcnJheSh0LnJhbmspLHI9MDtyPG4ubGVuZ3RoO3IrKyluW3JdPXQuc2hhcGVbcl0qZVtyXTt2YXIgbz1OcihuLHQuZHR5cGUpLGE9dC5idWZmZXJTeW5jKCk7Zm9yKHI9MDtyPG8udmFsdWVzLmxlbmd0aDsrK3Ipe2Zvcih2YXIgaT1vLmluZGV4VG9Mb2Mocikscz1uZXcgQXJyYXkodC5yYW5rKSx1PTA7dTxzLmxlbmd0aDt1Kyspc1t1XT1pW3VdJXQuc2hhcGVbdV07dmFyIGw9YS5sb2NUb0luZGV4KHMpO28udmFsdWVzW3JdPWEudmFsdWVzW2xdfXJldHVybiBvLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLnBhZD1mdW5jdGlvbih0LGUsbil7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJwYWRcIik7dmFyIHI9ZS5tYXAoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZVswXSt0LnNoYXBlW25dK2VbMV19KSxvPWUubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0WzBdfSksYT10LmJ1ZmZlclN5bmMoKSxpPU5yKHIsdC5kdHlwZSk7MCE9PW4mJmkudmFsdWVzLmZpbGwobik7Zm9yKHZhciBzPTA7czx0LnNpemU7cysrKXt2YXIgdT1hLmluZGV4VG9Mb2MocyksbD11Lm1hcChmdW5jdGlvbih0LGUpe3JldHVybiB0K29bZV19KTtpLnNldC5hcHBseShpLFthLmdldC5hcHBseShhLHUpXS5jb25jYXQobCkpfXJldHVybiBpLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLnRyYW5zcG9zZT1mdW5jdGlvbih0LGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwidHJhbnNwb3NlXCIpO2Zvcih2YXIgbj1uZXcgQXJyYXkodC5yYW5rKSxyPTA7cjxuLmxlbmd0aDtyKyspbltyXT10LnNoYXBlW2Vbcl1dO3ZhciBvPXQuZGF0YVN5bmMoKSxhPU5yKG4sdC5kdHlwZSksaT10LmJ1ZmZlclN5bmMoKTtmb3Iocj0wO3I8dC5zaXplOysrcil7Zm9yKHZhciBzPWkuaW5kZXhUb0xvYyhyKSx1PW5ldyBBcnJheShzLmxlbmd0aCksbD0wO2w8dS5sZW5ndGg7bCsrKXVbbF09c1tlW2xdXTt2YXIgYz1hLmxvY1RvSW5kZXgodSk7YS52YWx1ZXNbY109b1tyXX1yZXR1cm4gYS50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5nYXRoZXI9ZnVuY3Rpb24odCxlLG4pe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcImdhdGhlclwiKTt2YXIgcj10LnNoYXBlLnNsaWNlKCksbz1lLmRhdGFTeW5jKCk7cltuXT1vLmxlbmd0aDtmb3IodmFyIGE9TnIocix0LmR0eXBlKSxpPXQuYnVmZmVyU3luYygpLHM9MDtzPGEuc2l6ZTsrK3Mpe3ZhciB1PWEuaW5kZXhUb0xvYyhzKSxsPXUuc2xpY2UoKTtsW25dPW9bdVtuXV07dmFyIGM9aS5sb2NUb0luZGV4KGwpO2EudmFsdWVzW3NdPWkudmFsdWVzW2NdfXJldHVybiBhLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLmJhdGNoVG9TcGFjZU5EPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW3RdLFwiYmF0Y2hUb1NwYWNlTkRcIik7dmFyIHI9ZS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSksbz1LZSh0LnNoYXBlLGUsciksYT1YZShvLmxlbmd0aCxlLmxlbmd0aCksaT1ZZSh0LnNoYXBlLGUscikscz1RZShuLGUubGVuZ3RoKSx1PUplKGksbixlLmxlbmd0aCk7cmV0dXJuIHQucmVzaGFwZShvKS50cmFuc3Bvc2UoYSkucmVzaGFwZShpKS5zbGljZShzLHUpfSx0LnByb3RvdHlwZS5zcGFjZVRvQmF0Y2hORD1mdW5jdGlvbih0LGUsbil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFt0XSxcInNwYWNlVG9CYXRjaE5EXCIpO3ZhciByPWUucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0pLG89W1swLDBdXTtvLnB1c2guYXBwbHkobyxuKTtmb3IodmFyIGE9MStlLmxlbmd0aDthPHQuc2hhcGUubGVuZ3RoOysrYSlvLnB1c2goWzAsMF0pO3ZhciBpPXQucGFkKG8pLHM9S2UoaS5zaGFwZSxlLHIsITEpLHU9WGUocy5sZW5ndGgsZS5sZW5ndGgsITEpLGw9WWUoaS5zaGFwZSxlLHIsITEpO3JldHVybiBpLnJlc2hhcGUocykudHJhbnNwb3NlKHUpLnJlc2hhcGUobCl9LHQucHJvdG90eXBlLnBvb2w9ZnVuY3Rpb24odCxlLG4pe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwicG9vbFwiKTtmb3IodmFyIHI9ZS5zdHJpZGVIZWlnaHQsbz1lLnN0cmlkZVdpZHRoLGE9ZS5kaWxhdGlvbkhlaWdodCxpPWUuZGlsYXRpb25XaWR0aCxzPWUuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LHU9ZS5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxsPWUucGFkSW5mby50b3AsYz1lLnBhZEluZm8ubGVmdCxoPVwibWF4XCI9PT1uP051bWJlci5ORUdBVElWRV9JTkZJTklUWTpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkscD10LmRhdGFTeW5jKCksZj1OcihlLm91dFNoYXBlLHQuZHR5cGUpLGQ9Zi52YWx1ZXMsdj1lLm91dFNoYXBlWzFdKmUub3V0U2hhcGVbMl0qZS5vdXRTaGFwZVszXSxtPWUub3V0U2hhcGVbMl0qZS5vdXRTaGFwZVszXSxnPWUub3V0U2hhcGVbM10seT0wO3k8ZS5iYXRjaFNpemU7Kyt5KWZvcih2YXIgeD15KnYsdz15KnQuc3RyaWRlc1swXSxiPTA7YjxlLmluQ2hhbm5lbHM7KytiKWZvcih2YXIgQz0wO0M8ZS5vdXRIZWlnaHQ7KytDKWZvcih2YXIgRT1DKnItbCxSPU1hdGgubWF4KDAsRSksUz1NYXRoLm1pbihlLmluSGVpZ2h0LHMrRSksTj14K0MqbSxrPTA7azxlLm91dFdpZHRoOysrayl7Zm9yKHZhciBJPWsqby1jLEE9TWF0aC5tYXgoMCxJKSxUPU1hdGgubWluKGUuaW5XaWR0aCx1K0kpLEQ9aCxPPTAsXz0wLE09UjtNPFM7TSs9YSl7Zm9yKHZhciBGPXcrTSp0LnN0cmlkZXNbMV0sQj1BO0I8VDtCKz1pKXt2YXIgUD1wW0YrQip0LnN0cmlkZXNbMl0rYl07XCJtYXhcIj09PW4mJlA+RD9EPVA6XCJhdmdcIj09PW4mJihPKz1QLF8rKyl9aWYoaXNOYU4oRCkpYnJlYWt9ZFtOK2sqZytiXT1cImF2Z1wiPT09bj9PL186RH1yZXR1cm4gZi50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5tYXhQb29sPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMucG9vbCh0LGUsXCJtYXhcIil9LHQucHJvdG90eXBlLm1heFBvb2xQb3NpdGlvbnM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49TnIoZS5vdXRTaGFwZSxcImludDMyXCIpLHI9ZS5zdHJpZGVIZWlnaHQsbz1lLnN0cmlkZVdpZHRoLGE9ZS5kaWxhdGlvbkhlaWdodCxpPWUuZGlsYXRpb25XaWR0aCxzPWUuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LHU9ZS5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxsPWUucGFkSW5mby50b3AsYz1lLnBhZEluZm8ubGVmdCxoPXQuYnVmZmVyU3luYygpLHA9MDtwPGUuYmF0Y2hTaXplOysrcClmb3IodmFyIGY9MDtmPGUuaW5DaGFubmVsczsrK2YpZm9yKHZhciBkPTA7ZDxlLm91dEhlaWdodDsrK2Qpe2Zvcih2YXIgdj1kKnItbCxtPXY7bTwwOyltKz1hO2Zvcih2YXIgZz1NYXRoLm1pbihlLmluSGVpZ2h0LHMrdikseT0wO3k8ZS5vdXRXaWR0aDsrK3kpe2Zvcih2YXIgeD15Km8tYyx3PXg7dzwwOyl3Kz1pO2Zvcih2YXIgYj1NYXRoLm1pbihlLmluV2lkdGgsdSt4KSxDPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSxFPS0xLFI9bTtSPGc7Uis9YSlmb3IodmFyIFM9Ui12LE49dztOPGI7Tis9aSl7dmFyIGs9Ti14LEk9aC5nZXQocCxSLE4sZik7ST5DJiYoQz1JLEU9Uyp1K2spfW4uc2V0KEUscCxkLHksZil9fXJldHVybiBuLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLm1heFBvb2xCYWNrcHJvcD1mdW5jdGlvbih0LGUsbixyKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW2Usbl0sXCJtYXhQb29sQmFja3Byb3BcIik7Zm9yKHZhciBvPXRoaXMubWF4UG9vbFBvc2l0aW9ucyhlLHIpLGE9ci5zdHJpZGVIZWlnaHQsaT1yLnN0cmlkZVdpZHRoLHM9ci5kaWxhdGlvbkhlaWdodCx1PXIuZGlsYXRpb25XaWR0aCxsPXIuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGM9ci5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxoPWMtMS1yLnBhZEluZm8ubGVmdCxwPWwtMS1yLnBhZEluZm8udG9wLGY9TnIoZS5zaGFwZSxcImZsb2F0MzJcIiksZD1vLmJ1ZmZlclN5bmMoKSx2PXQuYnVmZmVyU3luYygpLG09MDttPHIuYmF0Y2hTaXplOysrbSlmb3IodmFyIGc9MDtnPHIuaW5DaGFubmVsczsrK2cpZm9yKHZhciB5PTA7eTxyLmluSGVpZ2h0OysreSlmb3IodmFyIHg9MDt4PHIuaW5XaWR0aDsrK3gpe2Zvcih2YXIgdz15LXAsYj14LWgsQz0wLEU9MDtFPGw7RSs9cyl7dmFyIFI9KHcrRSkvYTtpZighKFI8MHx8Uj49ci5vdXRIZWlnaHR8fE1hdGguZmxvb3IoUikhPT1SKSlmb3IodmFyIFM9MDtTPGM7Uys9dSl7dmFyIE49KGIrUykvaTtpZighKE48MHx8Tj49ci5vdXRXaWR0aHx8TWF0aC5mbG9vcihOKSE9PU4pKXt2YXIgaz1sKmMtMS1kLmdldChtLFIsTixnKT09PUUqYytTPzE6MDtpZigwIT09aylDKz12LmdldChtLFIsTixnKSprfX19Zi5zZXQoQyxtLHkseCxnKX1yZXR1cm4gZi50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5hdmdQb29sQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcImF2Z1Bvb2xCYWNrcHJvcFwiKTtmb3IodmFyIHI9bi5zdHJpZGVIZWlnaHQsbz1uLnN0cmlkZVdpZHRoLGE9bi5maWx0ZXJIZWlnaHQsaT1uLmZpbHRlcldpZHRoLHM9bi5kaWxhdGlvbkhlaWdodCx1PW4uZGlsYXRpb25XaWR0aCxsPW4uZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGM9bi5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxoPWMtMS1uLnBhZEluZm8ubGVmdCxwPWwtMS1uLnBhZEluZm8udG9wLGY9TnIoZS5zaGFwZSxcImZsb2F0MzJcIiksZD0xLyhhKmkpLHY9dC5idWZmZXJTeW5jKCksbT0wO208bi5iYXRjaFNpemU7KyttKWZvcih2YXIgZz0wO2c8bi5pbkNoYW5uZWxzOysrZylmb3IodmFyIHk9MDt5PG4uaW5IZWlnaHQ7Kyt5KWZvcih2YXIgeD0wO3g8bi5pbldpZHRoOysreCl7Zm9yKHZhciB3PXktcCxiPXgtaCxDPTAsRT0wO0U8bDtFKz1zKXt2YXIgUj0odytFKS9yO2lmKCEoUjwwfHxSPj1uLm91dEhlaWdodHx8TWF0aC5mbG9vcihSKSE9PVIpKWZvcih2YXIgUz0wO1M8YztTKz11KXt2YXIgTj0oYitTKS9vO2lmKCEoTjwwfHxOPj1uLm91dFdpZHRofHxNYXRoLmZsb29yKE4pIT09TikpQys9di5nZXQobSxSLE4sZyl9fWYuc2V0KEMqZCxtLHkseCxnKX1yZXR1cm4gZi50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5jYXN0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEpuKHQsZSx0aGlzKX0sdC5wcm90b3R5cGUucmVzaGFwZT1mdW5jdGlvbih0LGUpe3JldHVybiBabih0LGUpfSx0LnByb3RvdHlwZS5hdmdQb29sPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiYXZnUG9vbFwiKSx0aGlzLnBvb2wodCxlLFwiYXZnXCIpLnRvRmxvYXQoKX0sdC5wcm90b3R5cGUucmVzaXplQmlsaW5lYXI9ZnVuY3Rpb24odCxlLG4scil7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJyZXNpemVCaWxpbmVhclwiKTtmb3IodmFyIG89dC5zaGFwZSxhPW9bMF0saT1vWzFdLHM9b1syXSx1PW9bM10sbD10LmRhdGFTeW5jKCksYz1uZXcgRmxvYXQzMkFycmF5KHkoW2EsZSxuLHVdKSksaD1bciYmZT4xP2ktMTppLHImJm4+MT9zLTE6c10scD1bciYmZT4xP2UtMTplLHImJm4+MT9uLTE6bl0sZj0wLGQ9aFswXS9wWzBdLHY9aFsxXS9wWzFdLG09MDttPGE7bSsrKWZvcih2YXIgZz0wO2c8ZTtnKyspZm9yKHZhciB4PWQqZyx3PU1hdGguZmxvb3IoeCksYj14LXcsQz1NYXRoLm1pbihpLTEsTWF0aC5jZWlsKHgpKSxFPW0qdC5zdHJpZGVzWzBdK3cqdC5zdHJpZGVzWzFdLFI9bSp0LnN0cmlkZXNbMF0rQyp0LnN0cmlkZXNbMV0sUz0wO1M8bjtTKyspZm9yKHZhciBOPXYqUyxrPU1hdGguZmxvb3IoTiksST1OLWssQT1NYXRoLm1pbihzLTEsTWF0aC5jZWlsKE4pKSxUPUUrayp0LnN0cmlkZXNbMl0sRD1SK2sqdC5zdHJpZGVzWzJdLE89RSsgK0EqdC5zdHJpZGVzWzJdLF89UitBKnQuc3RyaWRlc1syXSxNPTA7TTx1O00rKyl7dmFyIEY9bFtUK01dLEI9bFtEK01dLFA9RisobFtPK01dLUYpKkksTD1QKyhCKyhsW18rTV0tQikqSS1QKSpiO2NbZisrXT1MfXJldHVybiBGbihjLFthLGUsbix1XSl9LHQucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcInJlc2l6ZUJpbGluZWFyQmFja3Byb3BcIik7Zm9yKHZhciByPWUuc2hhcGUsbz1yWzBdLGE9clsxXSxpPXJbMl0scz1yWzNdLHU9dC5zaGFwZSxsPXVbMV0sYz11WzJdLGg9bmV3IEZsb2F0MzJBcnJheShvKmEqaSpzKSxwPVtuJiZsPjE/YS0xOmEsbiYmYz4xP2ktMTppXSxmPVtuJiZsPjE/bC0xOmwsbiYmYz4xP2MtMTpjXSxkPXBbMF0vZlswXSx2PXBbMV0vZlsxXSxtPXQuZGF0YVN5bmMoKSxnPTAseT0wO3k8bzt5KyspZm9yKHZhciB4PXkqZS5zdHJpZGVzWzBdLHc9MDt3PGw7dysrKWZvcih2YXIgYj13KmQsQz1NYXRoLmZsb29yKGIpLEU9TWF0aC5taW4oTWF0aC5jZWlsKGIpLGEtMSksUj14K0MqZS5zdHJpZGVzWzFdLFM9eCtFKmUuc3RyaWRlc1sxXSxOPWItQyxrPTEtTixJPTA7STxjO0krKylmb3IodmFyIEE9SSp2LFQ9TWF0aC5mbG9vcihBKSxEPU1hdGgubWluKE1hdGguY2VpbChBKSxpLTEpLE89QS1ULF89MS1PLE09UitUKmUuc3RyaWRlc1syXSxGPVIrRCplLnN0cmlkZXNbMl0sQj1TK1QqZS5zdHJpZGVzWzJdLFA9UytEKmUuc3RyaWRlc1syXSxMPWsqXyxXPWsqTyxVPU4qXyx6PU4qTyxWPTA7VjxzO1YrKyl7dmFyIEc9bVtnKytdO2hbTStWXSs9RypMLGhbRitWXSs9RypXLGhbQitWXSs9RypVLGhbUCtWXSs9Ryp6fXJldHVybiBVbihoLFtvLGksYSxzXSxlLmR0eXBlKX0sdC5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwicmVzaXplTmVhcmVzdE5laWdoYm9yXCIpO2Zvcih2YXIgbz10LnNoYXBlLGE9b1swXSxpPW9bMV0scz1vWzJdLHU9b1szXSxsPXQuZGF0YVN5bmMoKSxjPW5ldyBGbG9hdDMyQXJyYXkoYSplKm4qdSksaD1bciYmZT4xP2ktMTppLHImJm4+MT9zLTE6c10scD1bciYmZT4xP2UtMTplLHImJm4+MT9uLTE6bl0sZj1oWzBdL3BbMF0sZD1oWzFdL3BbMV0sdj0wLG09MDttPGE7bSsrKWZvcih2YXIgZz1tKnQuc3RyaWRlc1swXSx5PTA7eTxlO3krKylmb3IodmFyIHg9Zip5LHc9ZytNYXRoLm1pbihpLTEscj9NYXRoLnJvdW5kKHgpOk1hdGguZmxvb3IoeCkpKnQuc3RyaWRlc1sxXSxiPTA7YjxuO2IrKylmb3IodmFyIEM9ZCpiLEU9dytNYXRoLm1pbihzLTEscj9NYXRoLnJvdW5kKEMpOk1hdGguZmxvb3IoQykpKnQuc3RyaWRlc1syXSxSPTA7Ujx1O1IrKyl7dmFyIFM9bFtFK1JdO2NbdisrXT1TfXJldHVybiBGbihjLFthLGUsbix1XSx0LmR0eXBlKX0sdC5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcInJlc2l6ZU5lYXJlc3ROZWlnaGJvckJhY2twcm9wXCIpO2Zvcih2YXIgcj1lLnNoYXBlLG89clswXSxhPXJbMV0saT1yWzJdLHM9clszXSx1PXQuc2hhcGUsbD11WzFdLGM9dVsyXSxoPW5ldyBGbG9hdDMyQXJyYXkobyphKmkqcykscD10LmRhdGFTeW5jKCksZj1bbiYmbD4xP2EtMTphLG4mJmM+MT9pLTE6aV0sZD1bbiYmbD4xP2wtMTpsLG4mJmM+MT9jLTE6Y10sdj1mWzBdL2RbMF0sbT1mWzFdL2RbMV0sZz0xL3YseT0xL20seD0yKk1hdGguY2VpbChnKSsyLHc9MipNYXRoLmNlaWwoeSkrMixiPTA7YjxvO2IrKylmb3IodmFyIEM9YiplLnN0cmlkZXNbMF0sRT0wO0U8YTtFKyspZm9yKHZhciBSPUMrRSplLnN0cmlkZXNbMV0sUz1NYXRoLmZsb29yKEUqZyksTj1NYXRoLmZsb29yKFMteC8yKSxrPTA7azxpO2srKylmb3IodmFyIEk9UitrKmUuc3RyaWRlc1syXSxBPU1hdGguZmxvb3Ioayp5KSxUPU1hdGguZmxvb3IoQS13LzIpLEQ9MDtEPHM7RCsrKXtmb3IodmFyIE89MCxfPTA7Xzx4O18rKyl7dmFyIE09XytOO2lmKCEoTTwwfHxNPj1sKSl7dmFyIEY9QytNKnQuc3RyaWRlc1sxXSxCPU0qdjtpZihFPT09TWF0aC5taW4oYS0xLG4/TWF0aC5yb3VuZChCKTpNYXRoLmZsb29yKEIpKSlmb3IodmFyIFA9MDtQPHc7UCsrKXt2YXIgTD1QK1Q7aWYoIShMPDB8fEw+PWMpKXt2YXIgVz1GK0wqdC5zdHJpZGVzWzJdLFU9TCptO2s9PT1NYXRoLm1pbihpLTEsbj9NYXRoLnJvdW5kKFUpOk1hdGguZmxvb3IoVSkpJiYoTys9cFtXK0RdKX19fX1oW0krRF09T31yZXR1cm4gVW4oaCxlLnNoYXBlLGUuZHR5cGUpfSx0LnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb249ZnVuY3Rpb24odCxlLG4scixvLGEpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlLG4sbyxhXSxcImJhdGNoTm9ybVwiKTtmb3IodmFyIGk9dC5kYXRhU3luYygpLHM9ZS5kYXRhU3luYygpLHU9bi5kYXRhU3luYygpLGw9bz9vLmRhdGFTeW5jKCk6bmV3IEZsb2F0MzJBcnJheShbMV0pLGM9YT9hLmRhdGFTeW5jKCk6bmV3IEZsb2F0MzJBcnJheShbMF0pLGg9bmV3IEZsb2F0MzJBcnJheShpLmxlbmd0aCkscD1jLmxlbmd0aCxmPWwubGVuZ3RoLGQ9dS5sZW5ndGgsdj1zLmxlbmd0aCxtPTAsZz0wLHk9MCx4PTAsdz0wO3c8aS5sZW5ndGg7Kyt3KWhbd109Y1ttKytdKyhpW3ddLXNbZysrXSkqbFt5KytdL01hdGguc3FydCh1W3grK10rciksbT49cCYmKG09MCksZz49diYmKGc9MCkseT49ZiYmKHk9MCkseD49ZCYmKHg9MCk7cmV0dXJuIFVuKGgsdC5zaGFwZSl9LHQucHJvdG90eXBlLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uNEQ9ZnVuY3Rpb24odCxlLG4scixvKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uNERcIik7dmFyIGE9dC5zaGFwZVszXSxpPWEtMSxzPXQuZGF0YVN5bmMoKSx1PXQuc2l6ZSxsPW5ldyBGbG9hdDMyQXJyYXkodSk7ZnVuY3Rpb24gYyh0KXtmb3IodmFyIG49dCVhLHI9dC1uK01hdGgubWF4KDAsbi1lKSxvPXQtbitNYXRoLm1pbihuK2UsaSksdT0wO3I8PW87cisrKXt2YXIgbD1zW3JdO3UrPWwqbH1yZXR1cm4gdX1mb3IodmFyIGg9MDtoPHU7aCsrKXt2YXIgcD1jKGgpLGY9c1toXSpNYXRoLnBvdyhuK3IqcCwtbyk7bFtoXT1mfXJldHVybiBVbihsLHQuc2hhcGUpfSx0LnByb3RvdHlwZS5MUk5HcmFkPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiTFJOR3JhZFwiKTtmb3IodmFyIHM9dC5zaGFwZVszXSx1PXQuZGF0YVN5bmMoKSxsPWUuZGF0YVN5bmMoKSxjPW4uZGF0YVN5bmMoKSxoPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxwPXQuc2l6ZSxmPTA7ZjxwO2YrKyl7Zm9yKHZhciBkPWYlcyx2PWYtZCtNYXRoLm1heCgwLGQtciksbT1mLWQrTWF0aC5taW4ocyxkK3IrMSksZz0wLHk9djt5PG07eSsrKWcrPU1hdGgucG93KGxbeV0sMik7Zz1hKmcrbztmb3IoeT12O3k8bTt5Kyspe3ZhciB4PS0yKmEqaSpsW3ldKmNbZl0vZztmPT09eSYmKHgrPU1hdGgucG93KGcsLWkpKSx4Kj11W2ZdLGhbeV0rPXh9fXJldHVybiBVbihoLHQuc2hhcGUpfSx0LnByb3RvdHlwZS5tdWx0aW5vbWlhbD1mdW5jdGlvbih0LGUsbixyKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcIm11bHRpbm9taWFsXCIpO2Zvcih2YXIgbz1lP3Q6VG4odCksYT1vLnNoYXBlWzBdLGk9by5zaGFwZVsxXSxzPXFuKFthLG5dLFwiaW50MzJcIiksdT1zLmRhdGFTeW5jKCksbD1vLmRhdGFTeW5jKCksYz0wO2M8YTsrK2Mpe3ZhciBoPWMqaSxwPW5ldyBGbG9hdDMyQXJyYXkoaS0xKTtwWzBdPWxbaF07Zm9yKHZhciBmPTE7ZjxwLmxlbmd0aDsrK2YpcFtmXT1wW2YtMV0rbFtoK2ZdO2Zvcih2YXIgZD1FcihyLnRvU3RyaW5nKCkpLHY9YypuLG09MDttPG47KyttKXt2YXIgZz1kKCk7dVt2K21dPXAubGVuZ3RoO2Zvcih2YXIgeT0wO3k8cC5sZW5ndGg7eSsrKWlmKGc8cFt5XSl7dVt2K21dPXk7YnJlYWt9fX1yZXR1cm4gc30sdC5wcm90b3R5cGUub25lSG90PWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwib25lSG90XCIpO3ZhciBvPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKmUpO28uZmlsbChyKTtmb3IodmFyIGE9dC5kYXRhU3luYygpLGk9MDtpPHQuc2l6ZTsrK2kpYVtpXT49MCYmYVtpXTxlJiYob1tpKmUrYVtpXV09bik7cmV0dXJuIExuKG8sW3Quc2l6ZSxlXSxcImludDMyXCIpfSx0LnByb3RvdHlwZS5ub25NYXhTdXBwcmVzc2lvbj1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcIm5vbk1heFN1cHByZXNzaW9uXCIpLGFyKHQuZGF0YVN5bmMoKSxlLmRhdGFTeW5jKCksbixyLG8pfSx0LnByb3RvdHlwZS5mZnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZmZ0QmF0Y2godCwhMSl9LHQucHJvdG90eXBlLmlmZnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZmZ0QmF0Y2godCwhMCl9LHQucHJvdG90eXBlLmZmdEJhdGNoPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuc2hhcGVbMF0scj10LnNoYXBlWzFdLG89TnIodC5zaGFwZSxcImZsb2F0MzJcIiksYT1Ocih0LnNoYXBlLFwiZmxvYXQzMlwiKSxpPV9uKHQpLmFzMkQobixyKSxzPU1uKHQpLmFzMkQobixyKSx1PTA7dTxuO3UrKylmb3IodmFyIGw9aS5zbGljZShbdSwwXSxbMSxyXSksYz1zLnNsaWNlKFt1LDBdLFsxLHJdKSxoPU9uKGwsYykscD10aGlzLmZmdEltcGwoaCxlKS5kYXRhU3luYygpLGY9MDtmPHI7ZisrKXt2YXIgZD1ucihwLGYpO28udmFsdWVzW3UqcitmXT1kLnJlYWwsYS52YWx1ZXNbdSpyK2ZdPWQuaW1hZ31yZXR1cm4gT24oby50b1RlbnNvcigpLGEudG9UZW5zb3IoKSkuYXMyRChuLHIpfSx0LnByb3RvdHlwZS5mZnRJbXBsPWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5hczFEKCkscj1uLnNpemU7aWYodGhpcy5pc0V4cG9uZW50T2YyKHIpKXt2YXIgbz10aGlzLmZmdFJhZGl4MihuLHIsZSkuYXMyRCh0LnNoYXBlWzBdLHQuc2hhcGVbMV0pO3JldHVybiBlJiYobz1PbihfbihvKS5kaXYoQm4ocikpLE1uKG8pLmRpdihCbihyKSkpKSxvfXZhciBhPXQuZGF0YVN5bmMoKSxpPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQubGVuZ3RoLzIpLG49bmV3IEZsb2F0MzJBcnJheSh0Lmxlbmd0aC8yKSxyPTA7cjx0Lmxlbmd0aDtyKz0yKWVbci8yXT10W3JdLG5bci8yXT10W3IrMV07cmV0dXJue3JlYWw6ZSxpbWFnOm59fSh0aGlzLmZvdXJpZXJUcmFuc2Zvcm1CeU1hdG11bChhLHIsZSkpO3JldHVybiBPbihpLnJlYWwsaS5pbWFnKS5hczJEKHQuc2hhcGVbMF0sdC5zaGFwZVsxXSl9LHQucHJvdG90eXBlLmlzRXhwb25lbnRPZjI9ZnVuY3Rpb24odCl7cmV0dXJuIDA9PSh0JnQtMSl9LHQucHJvdG90eXBlLmZmdFJhZGl4Mj1mdW5jdGlvbih0LGUsbil7aWYoMT09PWUpcmV0dXJuIHQ7dmFyIHI9dC5kYXRhU3luYygpLG89ZS8yLGE9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPU1hdGguY2VpbCh0Lmxlbmd0aC80KSxuPW5ldyBGbG9hdDMyQXJyYXkoZSkscj1uZXcgRmxvYXQzMkFycmF5KGUpLG89MDtvPHQubGVuZ3RoO28rPTQpbltNYXRoLmZsb29yKG8vNCldPXRbb10scltNYXRoLmZsb29yKG8vNCldPXRbbysxXTtyZXR1cm57cmVhbDpuLGltYWc6cn19KHIpLGk9T24oYS5yZWFsLGEuaW1hZykuYXMxRCgpLHM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPU1hdGguZmxvb3IodC5sZW5ndGgvNCksbj1uZXcgRmxvYXQzMkFycmF5KGUpLHI9bmV3IEZsb2F0MzJBcnJheShlKSxvPTI7bzx0Lmxlbmd0aDtvKz00KW5bTWF0aC5mbG9vcihvLzQpXT10W29dLHJbTWF0aC5mbG9vcihvLzQpXT10W28rMV07cmV0dXJue3JlYWw6bixpbWFnOnJ9fShyKSx1PU9uKHMucmVhbCxzLmltYWcpLmFzMUQoKTtpPXRoaXMuZmZ0UmFkaXgyKGksbyxuKSx1PXRoaXMuZmZ0UmFkaXgyKHUsbyxuKTt2YXIgbD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgRmxvYXQzMkFycmF5KHQvMikscj1uZXcgRmxvYXQzMkFycmF5KHQvMiksbz0wO288TWF0aC5jZWlsKHQvMik7bysrKXt2YXIgYT0oZT8yOi0yKSpNYXRoLlBJKihvL3QpO25bb109TWF0aC5jb3MoYSkscltvXT1NYXRoLnNpbihhKX1yZXR1cm57cmVhbDpuLGltYWc6cn19KGUsbiksYz1PbihsLnJlYWwsbC5pbWFnKS5tdWwodSksaD1pLmFkZChjKSxwPWkuc3ViKGMpLGY9X24oaCkuY29uY2F0KF9uKHApKSxkPU1uKGgpLmNvbmNhdChNbihwKSk7cmV0dXJuIE9uKGYsZCkuYXMxRCgpfSx0LnByb3RvdHlwZS5mb3VyaWVyVHJhbnNmb3JtQnlNYXRtdWw9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj1uZXcgRmxvYXQzMkFycmF5KDIqZSksbz0wO288ZTtvKyspe2Zvcih2YXIgYT0wLGk9MCxzPTA7czxlO3MrKyl7dmFyIHU9b3IobypzLGUsbiksbD1ucih0LHMpO2ErPWwucmVhbCp1LnJlYWwtbC5pbWFnKnUuaW1hZyxpKz1sLnJlYWwqdS5pbWFnK2wuaW1hZyp1LnJlYWx9biYmKGEvPWUsaS89ZSkscnIocixhLGksbyl9cmV0dXJuIHJ9LHQucHJvdG90eXBlLmRlcHRoVG9TcGFjZT1mdW5jdGlvbih0LGUsbil7ZChcIk5IV0NcIj09PW4sZnVuY3Rpb24oKXtyZXR1cm5cIk9ubHkgTkhXQyBkYXRhRm9ybWF0IHN1cHBvcnRlZCBvbiBDUFUgZm9yIGRlcHRoVG9TcGFjZS4gR290IFwiK259KSxkKGU+MSxmdW5jdGlvbigpe3JldHVyblwiYmxvY2tTaXplIHNob3VsZCBiZSA+IDEgZm9yIGRlcHRoVG9TcGFjZSwgYnV0IHdhczogXCIrZX0pO2Zvcih2YXIgcj10LnNoYXBlWzBdLG89dC5zaGFwZVsxXSxhPXQuc2hhcGVbMl0saT10LnNoYXBlWzNdLHM9byplLHU9YSplLGw9aS8oZSplKSxjPXQuZGF0YVN5bmMoKSxoPW5ldyBGbG9hdDMyQXJyYXkocipzKnUqbCkscD0wLGY9MDtmPHI7KytmKWZvcih2YXIgdj0wO3Y8czsrK3YpZm9yKHZhciBtPU1hdGguZmxvb3Iodi9lKSxnPXYlZSx5PTA7eTx1OysreSlmb3IodmFyIHg9TWF0aC5mbG9vcih5L2UpLHc9KGcqZSt5JWUpKmwsYj0wO2I8bDsrK2Ipe3ZhciBDPWIrdytpKih4K2EqKG0rbypmKSk7aFtwKytdPWNbQ119cmV0dXJuIFVuKGgsW3Iscyx1LGxdKX0sdC5wcm90b3R5cGUuYnJvYWRjYXN0ZWRCaW5hcnlPcD1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1zbyh0LnNoYXBlLGUuc2hhcGUpLGE9TnIobyxuKSxpPXQuZGF0YVN5bmMoKSxzPWUuZGF0YVN5bmMoKSx1PWFvKHQuc2hhcGUsbyksbD1hbyhlLnNoYXBlLG8pLGM9YS52YWx1ZXM7aWYodS5sZW5ndGgrbC5sZW5ndGg9PT0wKWZvcih2YXIgaD0wO2g8Yy5sZW5ndGg7KytoKWNbaF09cihpW2glaS5sZW5ndGhdLHNbaCVzLmxlbmd0aF0pO2Vsc2V7dmFyIHA9dC5idWZmZXJTeW5jKCksZj1lLmJ1ZmZlclN5bmMoKSxkPWZ1bmN0aW9uKG4pe3ZhciBvPWEuaW5kZXhUb0xvYyhuKSxoPW8uc2xpY2UoLXQucmFuayk7dS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiBoW3RdPTB9KTt2YXIgZD1wLmxvY1RvSW5kZXgoaCksdj1vLnNsaWNlKC1lLnJhbmspO2wuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gdlt0XT0wfSk7dmFyIG09Zi5sb2NUb0luZGV4KHYpO2Nbbl09cihpW2RdLHNbbV0pfTtmb3IoaD0wO2g8Yy5sZW5ndGg7KytoKWQoaCl9cmV0dXJuIGEudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUuYnJvYWRjYXN0ZWRCaW5hcnlDb21wbGV4T3A9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXNvKHQuc2hhcGUsZS5zaGFwZSksbz1OcihyLFwiZmxvYXQzMlwiKSxhPU5yKHIsXCJmbG9hdDMyXCIpLGk9dC5kYXRhU3luYygpLHM9ZS5kYXRhU3luYygpLHU9YW8odC5zaGFwZSxyKSxsPWFvKGUuc2hhcGUsciksYz1vLnZhbHVlcyxoPWEudmFsdWVzO2lmKHUubGVuZ3RoK2wubGVuZ3RoPT09MClmb3IodmFyIHA9MDtwPGMubGVuZ3RoO3ArKyl7dmFyIGY9cCVpLmxlbmd0aCxkPXAlcy5sZW5ndGgsdj1uKGlbMipmXSxpWzIqZisxXSxzWzIqZF0sc1syKmQrMV0pO2NbcF09di5yZWFsLGhbcF09di5pbWFnfWVsc2V7dmFyIG09dGhpcy5kYXRhLmdldCh0LmRhdGFJZCkuY29tcGxleFRlbnNvcnMucmVhbC5idWZmZXJTeW5jKCksZz10aGlzLmRhdGEuZ2V0KGUuZGF0YUlkKS5jb21wbGV4VGVuc29ycy5yZWFsLmJ1ZmZlclN5bmMoKSx5PWZ1bmN0aW9uKHIpe3ZhciBhPW8uaW5kZXhUb0xvYyhyKSxwPWEuc2xpY2UoLXQucmFuayk7dS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiBwW3RdPTB9KTt2YXIgZj1tLmxvY1RvSW5kZXgocCksZD1hLnNsaWNlKC1lLnJhbmspO2wuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gZFt0XT0wfSk7dmFyIHY9Zy5sb2NUb0luZGV4KGQpLHk9bihpWzIqZl0saVsyKmYrMV0sc1syKnZdLHNbMip2KzFdKTtjW3JdPXkucmVhbCxoW3JdPXkuaW1hZ307Zm9yKHA9MDtwPGMubGVuZ3RoO3ArKyl5KHApfXJldHVybiB0aGlzLmNvbXBsZXgoby50b1RlbnNvcigpLGEudG9UZW5zb3IoKSl9LHQucHJvdG90eXBlLnNwbGl0PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gc3IodCxlLG4pfSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7fSx0LnByb3RvdHlwZS5mbG9hdFByZWNpc2lvbj1mdW5jdGlvbigpe3JldHVybiAzMn0sdC5wcm90b3R5cGUuZXBzaWxvbj1mdW5jdGlvbigpe3JldHVybiAxZS03fSx0LnByb3RvdHlwZS5jcm9wQW5kUmVzaXplPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtmb3IodmFyIGk9dC5zaGFwZSxzPWlbMF0sdT1pWzFdLGw9aVsyXSxjPWlbM10saD1lLnNoYXBlWzBdLHA9clswXSxmPXJbMV0sZD1OcihbaCxwLGYsY10sdC5kdHlwZSksdj1lLmRhdGFTeW5jKCksbT1uLmRhdGFTeW5jKCksZz10LmRhdGFTeW5jKCkseT10LnN0cmlkZXMseD1kLnN0cmlkZXMsdz0wO3c8aDt3Kyspe3ZhciBiPTQqdyxDPXZbYl0sRT12W2IrMV0sUj12W2IrMl0sUz12W2IrM10sTj1tW3ddO2lmKCEoTj49cykpZm9yKHZhciBrPXA+MT8oUi1DKSoodS0xKS8ocC0xKTowLEk9Zj4xPyhTLUUpKihsLTEpLyhmLTEpOjAsQT0wO0E8cDtBKyspe3ZhciBUPXA+MT9DKih1LTEpK0EqazouNSooQytSKSoodS0xKTtpZihUPDB8fFQ+dS0xKWZvcih2YXIgRD0wO0Q8ZjtEKyspZm9yKHZhciBPPTA7TzxjO08rKyl7dmFyIF89TytEKnhbMl0rQSp4WzFdK3cqeFswXTtkLnZhbHVlc1tfXT1hfWVsc2UgaWYoXCJiaWxpbmVhclwiPT09byl7dmFyIE09TWF0aC5mbG9vcihUKSxGPU1hdGguY2VpbChUKSxCPVQtTTtmb3IoRD0wO0Q8ZjtEKyspe2lmKChIPWY+MT9FKihsLTEpK0QqSTouNSooRStTKSoobC0xKSk8MHx8SD5sLTEpZm9yKE89MDtPPGM7TysrKXtfPU8rRCp4WzJdK0EqeFsxXSt3KnhbMF07ZC52YWx1ZXNbX109YX1lbHNle3ZhciBQPU1hdGguZmxvb3IoSCksTD1NYXRoLmNlaWwoSCksVz1ILVA7Zm9yKE89MDtPPGM7TysrKXt2YXIgVT1nW189TytQKnlbMl0rTSp5WzFdK04qeVswXV0sej1nW189TytMKnlbMl0rTSp5WzFdK04qeVswXV0sVj1nW189TytQKnlbMl0rRip5WzFdK04qeVswXV0sRz1VKyh6LVUpKlcscT1WKyhnW189TytMKnlbMl0rRip5WzFdK04qeVswXV0tVikqVztfPU8rRCp4WzJdK0EqeFsxXSt3KnhbMF0sZC52YWx1ZXNbX109RysocS1HKSpCfX19fWVsc2UgZm9yKEQ9MDtEPGY7KytEKXt2YXIgSDtpZigoSD1mPjE/RSoobC0xKStEKkk6LjUqKEUrUykqKGwtMSkpPDB8fEg+bC0xKWZvcihPPTA7TzxjO08rKyl7Xz1PK0QqeFsyXStBKnhbMV0rdyp4WzBdO2QudmFsdWVzW19dPWF9ZWxzZXt2YXIgJD1NYXRoLnJvdW5kKEgpLGo9TWF0aC5yb3VuZChUKTtmb3IoTz0wO088YztPKyspe3ZhciBLPU8rJCp5WzJdK2oqeVsxXStOKnlbMF0sWD1PK0QqeFsyXStBKnhbMV0rdyp4WzBdO2QudmFsdWVzW1hdPWdbS119fX19fXJldHVybiBkLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLnNwYXJzZVRvRGVuc2U9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89cG4oMCx0LG4pLGE9by5zbGljZVJhbmssaT1vLm51bVVwZGF0ZXMscz1vLnNsaWNlU2l6ZSx1PW8uc3RyaWRlcyxsPW8ub3V0cHV0U2l6ZTtyZXR1cm4gdGhpcy5zY2F0dGVyKHQsZSxuLGwscyxpLGEsdSxyLCExKX0sdC5wcm90b3R5cGUuZ2F0aGVyTkQ9ZnVuY3Rpb24odCxlKXt2YXIgbj1lLnNoYXBlLHI9bltuLmxlbmd0aC0xXSxvPXVuKHQsZSksYT1vWzBdLGk9b1sxXSxzPW9bMl0sdT1vWzNdO2lmKDA9PT1pKXJldHVybiBGbihbXSxhLHQuZHR5cGUpO2Zvcih2YXIgbD1uZXcgbHQoW2ksc10sdC5kdHlwZSksYz1lLmRhdGFTeW5jKCksaD10LmRhdGFTeW5jKCkscD0wO3A8aTtwKyspe2Zvcih2YXIgZj1bXSxkPTAsdj0wO3Y8cjt2Kyspe3ZhciBtPWNbcCpyK3ZdO2QrPW0qdVt2XSxmLnB1c2gobSl9aWYoZDwwfHxkPj10LnNpemUvcyl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluZGljZXM6IFwiK2YrXCIgZG9lcyBub3QgaW5kZXggaW50byBcIit0LnNoYXBlKTtmb3IodmFyIGc9MDtnPHM7ZysrKWwudmFsdWVzW3AqcytnXT1oW2QqcytnXX1yZXR1cm4gbC50b1RlbnNvcigpLnJlc2hhcGUoYSl9LHQucHJvdG90eXBlLnNjYXR0ZXJORD1mdW5jdGlvbih0LGUsbil7dmFyIHI9cG4oMCx0LG4pLG89ci5zbGljZVJhbmssYT1yLm51bVVwZGF0ZXMsaT1yLnNsaWNlU2l6ZSxzPXIuc3RyaWRlcyx1PXIub3V0cHV0U2l6ZSxsPUJuKDApO3JldHVybiB0aGlzLnNjYXR0ZXIodCxlLG4sdSxpLGEsbyxzLGwsITApfSx0LnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BKG49bnx8VyhlKSx5KHQpKTtyZXR1cm4gci5maWxsKGUpLGZ0Lm1ha2UodCx7dmFsdWVzOnJ9LG4pfSx0LnByb3RvdHlwZS5vbmVzTGlrZT1mdW5jdGlvbih0KXtpZihcInN0cmluZ1wiPT09dC5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJvbmVzTGlrZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBzdHJpbmcgdGVuc29yc1wiKTtyZXR1cm4gdGhpcy5maWxsKHQuc2hhcGUsMSx0LmR0eXBlKX0sdC5wcm90b3R5cGUuemVyb3NMaWtlPWZ1bmN0aW9uKHQpe3ZhciBlPUEodC5kdHlwZSx5KHQuc2hhcGUpKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6ZX0sdC5kdHlwZSl9LHQucHJvdG90eXBlLmxpbnNwYWNlPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdHIodCxlLG4pfSx0LnByb3RvdHlwZS5zY2F0dGVyPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkscyx1LGwpe3ZhciBjPVtyL28sb10saD10LmRhdGFTeW5jKCkscD1lLmRhdGFTeW5jKCk7aWYoMD09PXIpcmV0dXJuIEZuKFtdLG4sZS5kdHlwZSk7dmFyIGY9bmV3IGx0KGMsZS5kdHlwZSk7Zi52YWx1ZXMuZmlsbCh1LmRhdGFTeW5jKClbMF0pO2Zvcih2YXIgZD0wO2Q8YTtkKyspe2Zvcih2YXIgdj1bXSxtPTAsZz0wO2c8aTtnKyspe3ZhciB5PWhbZCppK2ddO3YucHVzaCh5KSxtKz15KnNbZ119aWYobTwwfHxtPj1yL28pdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbmRpY2VzOiBcIit2K1wiIGRvZXMgbm90IGluZGV4IGludG8gXCIrbik7Zm9yKHZhciB4PTA7eDxvO3grKylsP2YudmFsdWVzW20qbyt4XSs9cFtkKm8reF06Zi52YWx1ZXNbbSpvK3hdPTA9PT1lLnJhbms/cFswXTpwW2Qqbyt4XX1yZXR1cm4gZi50b1RlbnNvcigpLnJlc2hhcGUobil9LHR9KCk7RHQucmVnaXN0ZXJCYWNrZW5kKFwiY3B1XCIsZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGdjfSwxKTt2YXIgeWM9e2Zsb2F0MzI6NCxpbnQzMjo0LHVpbnQxNjoyLHVpbnQ4OjEsYm9vbDoxfTtmdW5jdGlvbiB4Yyh0LGUpe2Zvcih2YXIgbj17fSxyPTAsbz1mdW5jdGlvbihlKXt2YXIgbz1lLm5hbWUsYT1lLmR0eXBlLGk9ZS5zaGFwZSxzPXkoaSksdT12b2lkIDA7aWYoXCJxdWFudGl6YXRpb25cImluIGUpe3ZhciBsPWUucXVhbnRpemF0aW9uO2lmKFwidWludDhcIiE9PWwuZHR5cGUmJlwidWludDE2XCIhPT1sLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIldlaWdodCBcIitlLm5hbWUrXCIgaGFzIHVua25vd24gcXVhbnRpemF0aW9uIGR0eXBlIFwiK2wuZHR5cGUrXCIuIFN1cHBvcnRlZCBxdWFudGl6YXRpb24gZHR5cGVzIGFyZTogJ3VpbnQ4JyBhbmQgJ3VpbnQxNicuXCIpO3ZhciBjPXljW2wuZHR5cGVdLGg9dC5zbGljZShyLHIrcypjKSxwPVwidWludDhcIj09PWwuZHR5cGU/bmV3IFVpbnQ4QXJyYXkoaCk6bmV3IFVpbnQxNkFycmF5KGgpO2lmKFwiZmxvYXQzMlwiPT09YSl1PUZsb2F0MzJBcnJheS5mcm9tKHAsZnVuY3Rpb24odCl7cmV0dXJuIHQqbC5zY2FsZStsLm1pbn0pO2Vsc2V7aWYoXCJpbnQzMlwiIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkdHlwZSBpbiB3ZWlnaHQgJ1wiK28rXCInOiBcIithKTt1PUludDMyQXJyYXkuZnJvbShwLGZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnJvdW5kKHQqbC5zY2FsZStsLm1pbil9KX1yKz1zKmN9ZWxzZXt2YXIgZj15Y1thXTtoPXQuc2xpY2UocixyK3MqZik7aWYoXCJmbG9hdDMyXCI9PT1hKXU9bmV3IEZsb2F0MzJBcnJheShoKTtlbHNlIGlmKFwiaW50MzJcIj09PWEpdT1uZXcgSW50MzJBcnJheShoKTtlbHNle2lmKFwiYm9vbFwiIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkdHlwZSBpbiB3ZWlnaHQgJ1wiK28rXCInOiBcIithKTt1PW5ldyBVaW50OEFycmF5KGgpfXIrPXMqZn12YXIgZD12b2lkIDA7aWYoXCJmbG9hdDMyXCI9PT1hKWQ9Rm4odSxpLFwiZmxvYXQzMlwiKTtlbHNlIGlmKFwiaW50MzJcIj09PWEpZD1Gbih1LGksXCJpbnQzMlwiKTtlbHNle2lmKFwiYm9vbFwiIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkdHlwZSBpbiB3ZWlnaHQgJ1wiK28rXCInOiBcIithKTtkPUZuKHUsaSxcImJvb2xcIil9bltvXT1kfSxhPTAsaT1lO2E8aS5sZW5ndGg7YSsrKXtvKGlbYV0pfXJldHVybiBufWZ1bmN0aW9uIHdjKHQpe2lmKG51bGw9PT10KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdmFsdWU6IFwiK0pTT04uc3RyaW5naWZ5KHQpKTt2YXIgZT0wLG49W107dC5mb3JFYWNoKGZ1bmN0aW9uKHQpe2lmKGUrPXQuYnl0ZUxlbmd0aCxuLnB1c2godC5ieXRlTGVuZ3RoPT09dC5idWZmZXIuYnl0ZUxlbmd0aD90Om5ldyB0LmNvbnN0cnVjdG9yKHQpKSwhKHQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXl8fHQgaW5zdGFuY2VvZiBJbnQzMkFycmF5fHx0IGluc3RhbmNlb2YgVWludDhBcnJheSkpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgVHlwZWRBcnJheSBzdWJ0eXBlOiBcIit0LmNvbnN0cnVjdG9yLm5hbWUpfSk7dmFyIHI9bmV3IFVpbnQ4QXJyYXkoZSksbz0wO3JldHVybiBuLmZvckVhY2goZnVuY3Rpb24odCl7ci5zZXQobmV3IFVpbnQ4QXJyYXkodC5idWZmZXIpLG8pLG8rPXQuYnl0ZUxlbmd0aH0pLHIuYnVmZmVyfXZhciBiYz1cInVuZGVmaW5lZFwiIT10eXBlb2YgQnVmZmVyJiYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIEJsb2J8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBhdG9ifHxcInVuZGVmaW5lZFwiPT10eXBlb2YgYnRvYSk7ZnVuY3Rpb24gQ2ModCl7cmV0dXJuIGJjP0J1ZmZlci5ieXRlTGVuZ3RoKHQpOm5ldyBCbG9iKFt0XSkuc2l6ZX1mdW5jdGlvbiBFYyh0KXt2YXIgZT0wO3QuZm9yRWFjaChmdW5jdGlvbih0KXtlKz10LmJ5dGVMZW5ndGh9KTt2YXIgbj1uZXcgVWludDhBcnJheShlKSxyPTA7cmV0dXJuIHQuZm9yRWFjaChmdW5jdGlvbih0KXtuLnNldChuZXcgVWludDhBcnJheSh0KSxyKSxyKz10LmJ5dGVMZW5ndGh9KSxuLmJ1ZmZlcn1mdW5jdGlvbiBSYyh0KXtmb3IodD10LnRyaW0oKTt0LmVuZHNXaXRoKFwiL1wiKTspdD10LnNsaWNlKDAsdC5sZW5ndGgtMSk7dmFyIGU9dC5zcGxpdChcIi9cIik7cmV0dXJuIGVbZS5sZW5ndGgtMV19ZnVuY3Rpb24gU2ModCl7aWYodC5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgSlNPTiBtb2RlbCB0b3BvbG9neSwgcmVjZWl2ZWQgQXJyYXlCdWZmZXIuXCIpO3JldHVybntkYXRlU2F2ZWQ6bmV3IERhdGUsbW9kZWxUb3BvbG9neVR5cGU6XCJKU09OXCIsbW9kZWxUb3BvbG9neUJ5dGVzOm51bGw9PXQubW9kZWxUb3BvbG9neT8wOkNjKEpTT04uc3RyaW5naWZ5KHQubW9kZWxUb3BvbG9neSkpLHdlaWdodFNwZWNzQnl0ZXM6bnVsbD09dC53ZWlnaHRTcGVjcz8wOkNjKEpTT04uc3RyaW5naWZ5KHQud2VpZ2h0U3BlY3MpKSx3ZWlnaHREYXRhQnl0ZXM6bnVsbD09dC53ZWlnaHREYXRhPzA6dC53ZWlnaHREYXRhLmJ5dGVMZW5ndGh9fXZhciBOYz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt0aGlzLnNhdmVSb3V0ZXJzPVtdLHRoaXMubG9hZFJvdXRlcnM9W119cmV0dXJuIHQuZ2V0SW5zdGFuY2U9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09dC5pbnN0YW5jZSYmKHQuaW5zdGFuY2U9bmV3IHQpLHQuaW5zdGFuY2V9LHQucmVnaXN0ZXJTYXZlUm91dGVyPWZ1bmN0aW9uKGUpe3QuZ2V0SW5zdGFuY2UoKS5zYXZlUm91dGVycy5wdXNoKGUpfSx0LnJlZ2lzdGVyTG9hZFJvdXRlcj1mdW5jdGlvbihlKXt0LmdldEluc3RhbmNlKCkubG9hZFJvdXRlcnMucHVzaChlKX0sdC5nZXRTYXZlSGFuZGxlcnM9ZnVuY3Rpb24oZSl7cmV0dXJuIHQuZ2V0SGFuZGxlcnMoZSxcInNhdmVcIil9LHQuZ2V0TG9hZEhhbmRsZXJzPWZ1bmN0aW9uKGUsbil7cmV0dXJuIHQuZ2V0SGFuZGxlcnMoZSxcImxvYWRcIixuKX0sdC5nZXRIYW5kbGVycz1mdW5jdGlvbihlLG4scil7dmFyIG89W107cmV0dXJuKFwibG9hZFwiPT09bj90LmdldEluc3RhbmNlKCkubG9hZFJvdXRlcnM6dC5nZXRJbnN0YW5jZSgpLnNhdmVSb3V0ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBuPXQoZSxyKTtudWxsIT09biYmby5wdXNoKG4pfSksb30sdH0oKSxrYz1cIjovL1wiLEljPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMubWFuYWdlcnM9e319cmV0dXJuIHQuZ2V0SW5zdGFuY2U9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09dC5pbnN0YW5jZSYmKHQuaW5zdGFuY2U9bmV3IHQpLHQuaW5zdGFuY2V9LHQucmVnaXN0ZXJNYW5hZ2VyPWZ1bmN0aW9uKGUsbil7ZChudWxsIT1lLGZ1bmN0aW9uKCl7cmV0dXJuXCJzY2hlbWUgbXVzdCBub3QgYmUgdW5kZWZpbmVkIG9yIG51bGwuXCJ9KSxlLmVuZHNXaXRoKGtjKSYmKGU9ZS5zbGljZSgwLGUuaW5kZXhPZihrYykpKSxkKGUubGVuZ3RoPjAsZnVuY3Rpb24oKXtyZXR1cm5cInNjaGVtZSBtdXN0IG5vdCBiZSBhbiBlbXB0eSBzdHJpbmcuXCJ9KTt2YXIgcj10LmdldEluc3RhbmNlKCk7ZChudWxsPT1yLm1hbmFnZXJzW2VdLGZ1bmN0aW9uKCl7cmV0dXJuXCJBIG1vZGVsIHN0b3JlIG1hbmFnZXIgaXMgYWxyZWFkeSByZWdpc3RlcmVkIGZvciBzY2hlbWUgJ1wiK2UrXCInLlwifSksci5tYW5hZ2Vyc1tlXT1ufSx0LmdldE1hbmFnZXI9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRJbnN0YW5jZSgpLm1hbmFnZXJzW3RdO2lmKG51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kZWwgbWFuYWdlciBmb3Igc2NoZW1lICdcIit0K1wiJ1wiKTtyZXR1cm4gZX0sdC5nZXRTY2hlbWVzPWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZ2V0SW5zdGFuY2UoKS5tYW5hZ2Vycyl9LHR9KCk7ZnVuY3Rpb24gQWModCl7aWYoLTE9PT10LmluZGV4T2Yoa2MpKXRocm93IG5ldyBFcnJvcihcIlRoZSB1cmwgc3RyaW5nIHByb3ZpZGVkIGRvZXMgbm90IGNvbnRhaW4gYSBzY2hlbWUuIFN1cHBvcnRlZCBzY2hlbWVzIGFyZTogXCIrSWMuZ2V0U2NoZW1lcygpLmpvaW4oXCIsXCIpKTtyZXR1cm57c2NoZW1lOnQuc3BsaXQoa2MpWzBdLHBhdGg6dC5zcGxpdChrYylbMV19fWZ1bmN0aW9uIFRjKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49ITEpLHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHIsYSxpLHMsdSxsLGMsaCxwO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obyl7c3dpdGNoKG8ubGFiZWwpe2Nhc2UgMDpyZXR1cm4gZCh0IT09ZSxmdW5jdGlvbigpe3JldHVyblwiT2xkIHBhdGggYW5kIG5ldyBwYXRoIGFyZSB0aGUgc2FtZTogJ1wiK3QrXCInXCJ9KSxkKChyPU5jLmdldExvYWRIYW5kbGVycyh0KSkubGVuZ3RoPjAsZnVuY3Rpb24oKXtyZXR1cm5cIkNvcHlpbmcgZmFpbGVkIGJlY2F1c2Ugbm8gbG9hZCBoYW5kbGVyIGlzIGZvdW5kIGZvciBzb3VyY2UgVVJMIFwiK3QrXCIuXCJ9KSxkKHIubGVuZ3RoPDIsZnVuY3Rpb24oKXtyZXR1cm5cIkNvcHlpbmcgZmFpbGVkIGJlY2F1c2UgbW9yZSB0aGFuIG9uZSAoXCIrci5sZW5ndGgrXCIpIGxvYWQgaGFuZGxlcnMgZm9yIHNvdXJjZSBVUkwgXCIrdCtcIi5cIn0pLGE9clswXSxkKChpPU5jLmdldFNhdmVIYW5kbGVycyhlKSkubGVuZ3RoPjAsZnVuY3Rpb24oKXtyZXR1cm5cIkNvcHlpbmcgZmFpbGVkIGJlY2F1c2Ugbm8gc2F2ZSBoYW5kbGVyIGlzIGZvdW5kIGZvciBkZXN0aW5hdGlvbiBVUkwgXCIrZStcIi5cIn0pLGQoaS5sZW5ndGg8MixmdW5jdGlvbigpe3JldHVyblwiQ29weWluZyBmYWlsZWQgYmVjYXVzZSBtb3JlIHRoYW4gb25lIChcIityLmxlbmd0aCtcIikgc2F2ZSBoYW5kbGVycyBmb3IgZGVzdGluYXRpb24gVVJMIFwiK2UrXCIuXCJ9KSxzPWlbMF0sdT1BYyh0KS5zY2hlbWUsbD1BYyh0KS5wYXRoLGM9dT09PUFjKHQpLnNjaGVtZSxbNCxhLmxvYWQoKV07Y2FzZSAxOnJldHVybiBoPW8uc2VudCgpLG4mJmM/WzQsSWMuZ2V0TWFuYWdlcih1KS5yZW1vdmVNb2RlbChsKV06WzMsM107Y2FzZSAyOm8uc2VudCgpLG8ubGFiZWw9MztjYXNlIDM6cmV0dXJuWzQscy5zYXZlKGgpXTtjYXNlIDQ6cmV0dXJuIHA9by5zZW50KCksIW58fGM/WzMsNl06WzQsSWMuZ2V0TWFuYWdlcih1KS5yZW1vdmVNb2RlbChsKV07Y2FzZSA1Om8uc2VudCgpLG8ubGFiZWw9NjtjYXNlIDY6cmV0dXJuWzIscC5tb2RlbEFydGlmYWN0c0luZm9dfX0pfSl9dmFyIERjPVwibW9kZWxzX3N0b3JlXCIsT2M9XCJtb2RlbF9pbmZvX3N0b3JlXCI7ZnVuY3Rpb24gX2MoKXtpZighYS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSl0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gb2J0YWluIEluZGV4ZWREQiBmYWN0b3J5IGJlY2F1c2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnRpcyBub3QgYSB3ZWIgYnJvd3Nlci5cIik7dmFyIHQ9d2luZG93LGU9dC5pbmRleGVkREJ8fHQubW96SW5kZXhlZERCfHx0LndlYmtpdEluZGV4ZWREQnx8dC5tc0luZGV4ZWREQnx8dC5zaGltSW5kZXhlZERCO2lmKG51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgYnJvd3NlciBkb2VzIG5vdCBhcHBlYXIgdG8gc3VwcG9ydCBJbmRleGVkREIuXCIpO3JldHVybiBlfWZ1bmN0aW9uIE1jKHQpe3ZhciBlPXQucmVzdWx0O2UuY3JlYXRlT2JqZWN0U3RvcmUoRGMse2tleVBhdGg6XCJtb2RlbFBhdGhcIn0pLGUuY3JlYXRlT2JqZWN0U3RvcmUoT2Mse2tleVBhdGg6XCJtb2RlbFBhdGhcIn0pfXZhciBGYz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodGhpcy5pbmRleGVkREI9X2MoKSxudWxsPT10fHwhdCl0aHJvdyBuZXcgRXJyb3IoXCJGb3IgSW5kZXhlZERCLCBtb2RlbFBhdGggbXVzdCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkIG9yIGVtcHR5LlwiKTt0aGlzLm1vZGVsUGF0aD10fXJldHVybiB0LnByb3RvdHlwZS5zYXZlPWZ1bmN0aW9uKHQpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBvKHRoaXMsZnVuY3Rpb24oZSl7aWYodC5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckxvY2FsU3RvcmFnZS5zYXZlKCkgZG9lcyBub3Qgc3VwcG9ydCBzYXZpbmcgbW9kZWwgdG9wb2xvZ3kgaW4gYmluYXJ5IGZvcm1hdHMgeWV0LlwiKTtyZXR1cm5bMix0aGlzLmRhdGFiYXNlQWN0aW9uKHRoaXMubW9kZWxQYXRoLHQpXX0pfSl9LHQucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKHQpe3JldHVyblsyLHRoaXMuZGF0YWJhc2VBY3Rpb24odGhpcy5tb2RlbFBhdGgpXX0pfSl9LHQucHJvdG90eXBlLmRhdGFiYXNlQWN0aW9uPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcztyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24odCxyKXt2YXIgbz1uLmluZGV4ZWREQi5vcGVuKFwidGVuc29yZmxvd2pzXCIsMSk7by5vbnVwZ3JhZGVuZWVkZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gTWMobyl9LG8ub25zdWNjZXNzPWZ1bmN0aW9uKCl7dmFyIGE9by5yZXN1bHQ7aWYobnVsbD09ZSl7dmFyIGk9YS50cmFuc2FjdGlvbihEYyxcInJlYWRvbmx5XCIpLHM9aS5vYmplY3RTdG9yZShEYykuZ2V0KG4ubW9kZWxQYXRoKTtzLm9uc3VjY2Vzcz1mdW5jdGlvbigpe2lmKG51bGw9PXMucmVzdWx0KXJldHVybiBhLmNsb3NlKCkscihuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2RlbCB3aXRoIHBhdGggJ1wiK24ubW9kZWxQYXRoK1wiJyBpbiBJbmRleGVkREIuXCIpKTt0KHMucmVzdWx0Lm1vZGVsQXJ0aWZhY3RzKX0scy5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiBhLmNsb3NlKCkscihzLmVycm9yKX0saS5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7cmV0dXJuIGEuY2xvc2UoKX19ZWxzZXt2YXIgdSxsPVNjKGUpLGM9YS50cmFuc2FjdGlvbihPYyxcInJlYWR3cml0ZVwiKSxoPWMub2JqZWN0U3RvcmUoT2MpLHA9aC5wdXQoe21vZGVsUGF0aDpuLm1vZGVsUGF0aCxtb2RlbEFydGlmYWN0c0luZm86bH0pO3Aub25zdWNjZXNzPWZ1bmN0aW9uKCl7dmFyIG89KHU9YS50cmFuc2FjdGlvbihEYyxcInJlYWR3cml0ZVwiKSkub2JqZWN0U3RvcmUoRGMpLnB1dCh7bW9kZWxQYXRoOm4ubW9kZWxQYXRoLG1vZGVsQXJ0aWZhY3RzOmUsbW9kZWxBcnRpZmFjdHNJbmZvOmx9KTtvLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3JldHVybiB0KHttb2RlbEFydGlmYWN0c0luZm86bH0pfSxvLm9uZXJyb3I9ZnVuY3Rpb24odCl7dmFyIGU9KGg9Yy5vYmplY3RTdG9yZShPYykpLmRlbGV0ZShuLm1vZGVsUGF0aCk7ZS5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXtyZXR1cm4gYS5jbG9zZSgpLHIoby5lcnJvcil9LGUub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gYS5jbG9zZSgpLHIoby5lcnJvcil9fX0scC5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiBhLmNsb3NlKCkscihwLmVycm9yKX0sYy5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7bnVsbD09dT9hLmNsb3NlKCk6dS5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7cmV0dXJuIGEuY2xvc2UoKX19fX0sby5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiByKG8uZXJyb3IpfX0pfSx0LlVSTF9TQ0hFTUU9XCJpbmRleGVkZGI6Ly9cIix0fSgpLEJjPWZ1bmN0aW9uKHQpe3JldHVybiBhLmdldEJvb2woXCJJU19CUk9XU0VSXCIpJiYhQXJyYXkuaXNBcnJheSh0KSYmdC5zdGFydHNXaXRoKEZjLlVSTF9TQ0hFTUUpPyhlPXQuc2xpY2UoRmMuVVJMX1NDSEVNRS5sZW5ndGgpLG5ldyBGYyhlKSk6bnVsbDt2YXIgZX07TmMucmVnaXN0ZXJTYXZlUm91dGVyKEJjKSxOYy5yZWdpc3RlckxvYWRSb3V0ZXIoQmMpO3ZhciBQYz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt0aGlzLmluZGV4ZWREQj1fYygpfXJldHVybiB0LnByb3RvdHlwZS5saXN0TW9kZWxzPWZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKGUpe3JldHVyblsyLG5ldyBQcm9taXNlKGZ1bmN0aW9uKGUsbil7dmFyIHI9dC5pbmRleGVkREIub3BlbihcInRlbnNvcmZsb3dqc1wiLDEpO3Iub251cGdyYWRlbmVlZGVkPWZ1bmN0aW9uKCl7cmV0dXJuIE1jKHIpfSxyLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3ZhciB0PXIucmVzdWx0LG89dC50cmFuc2FjdGlvbihPYyxcInJlYWRvbmx5XCIpLGE9by5vYmplY3RTdG9yZShPYykuZ2V0QWxsKCk7YS5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9e30sbj0wLHI9YS5yZXN1bHQ7bjxyLmxlbmd0aDtuKyspe3ZhciBvPXJbbl07dFtvLm1vZGVsUGF0aF09by5tb2RlbEFydGlmYWN0c0luZm99ZSh0KX0sYS5vbmVycm9yPWZ1bmN0aW9uKGUpe3JldHVybiB0LmNsb3NlKCksbihhLmVycm9yKX0sby5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHQuY2xvc2UoKX19LHIub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gbihyLmVycm9yKX19KV19KX0pfSx0LnByb3RvdHlwZS5yZW1vdmVNb2RlbD1mdW5jdGlvbih0KXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIHQ9KHI9dCkuc3RhcnRzV2l0aChGYy5VUkxfU0NIRU1FKT9yLnNsaWNlKEZjLlVSTF9TQ0hFTUUubGVuZ3RoKTpyLFsyLG5ldyBQcm9taXNlKGZ1bmN0aW9uKG4scil7dmFyIG89ZS5pbmRleGVkREIub3BlbihcInRlbnNvcmZsb3dqc1wiLDEpO28ub251cGdyYWRlbmVlZGVkPWZ1bmN0aW9uKCl7cmV0dXJuIE1jKG8pfSxvLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3ZhciBlLGE9by5yZXN1bHQsaT1hLnRyYW5zYWN0aW9uKE9jLFwicmVhZHdyaXRlXCIpLHM9aS5vYmplY3RTdG9yZShPYyksdT1zLmdldCh0KTt1Lm9uc3VjY2Vzcz1mdW5jdGlvbigpe2lmKG51bGw9PXUucmVzdWx0KXJldHVybiBhLmNsb3NlKCkscihuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2RlbCB3aXRoIHBhdGggJ1wiK3QrXCInIGluIEluZGV4ZWREQi5cIikpO3ZhciBvPXMuZGVsZXRlKHQpLGk9ZnVuY3Rpb24oKXt2YXIgbz0oZT1hLnRyYW5zYWN0aW9uKERjLFwicmVhZHdyaXRlXCIpKS5vYmplY3RTdG9yZShEYykuZGVsZXRlKHQpO28ub25zdWNjZXNzPWZ1bmN0aW9uKCl7cmV0dXJuIG4odS5yZXN1bHQubW9kZWxBcnRpZmFjdHNJbmZvKX0sby5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiByKHUuZXJyb3IpfX07by5vbnN1Y2Nlc3M9aSxvLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIGkoKSxhLmNsb3NlKCkscih1LmVycm9yKX19LHUub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gYS5jbG9zZSgpLHIodS5lcnJvcil9LGkub25jb21wbGV0ZT1mdW5jdGlvbigpe251bGw9PWU/YS5jbG9zZSgpOmUub25jb21wbGV0ZT1mdW5jdGlvbigpe3JldHVybiBhLmNsb3NlKCl9fX0sby5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiByKG8uZXJyb3IpfX0pXX0pfSl9LHR9KCk7aWYoYS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSl0cnl7SWMucmVnaXN0ZXJNYW5hZ2VyKEZjLlVSTF9TQ0hFTUUsbmV3IFBjKX1jYXRjaCh0KXt9dmFyIExjPVwiL1wiLFdjPVwidGVuc29yZmxvd2pzX21vZGVsc1wiLFVjPVwiaW5mb1wiLHpjPVwibW9kZWxfdG9wb2xvZ3lcIixWYz1cIndlaWdodF9zcGVjc1wiLEdjPVwid2VpZ2h0X2RhdGFcIixxYz1cIm1vZGVsX21ldGFkYXRhXCI7ZnVuY3Rpb24gSGModCl7cmV0dXJue2luZm86W1djLHQsVWNdLmpvaW4oTGMpLHRvcG9sb2d5OltXYyx0LHpjXS5qb2luKExjKSx3ZWlnaHRTcGVjczpbV2MsdCxWY10uam9pbihMYyksd2VpZ2h0RGF0YTpbV2MsdCxHY10uam9pbihMYyksbW9kZWxNZXRhZGF0YTpbV2MsdCxxY10uam9pbihMYyl9fWZ1bmN0aW9uICRjKHQpe3ZhciBlPXQuc3BsaXQoTGMpO2lmKGUubGVuZ3RoPDMpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXkgZm9ybWF0OiBcIit0KTtyZXR1cm4gZS5zbGljZSgxLGUubGVuZ3RoLTEpLmpvaW4oTGMpfXZhciBqYz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYoIWEuZ2V0Qm9vbChcIklTX0JST1dTRVJcIil8fHZvaWQgMD09PXdpbmRvdy5sb2NhbFN0b3JhZ2UpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBsb2NhbCBzdG9yYWdlLlwiKTtpZih0aGlzLkxTPXdpbmRvdy5sb2NhbFN0b3JhZ2UsbnVsbD09dHx8IXQpdGhyb3cgbmV3IEVycm9yKFwiRm9yIGxvY2FsIHN0b3JhZ2UsIG1vZGVsUGF0aCBtdXN0IG5vdCBiZSBudWxsLCB1bmRlZmluZWQgb3IgZW1wdHkuXCIpO3RoaXMubW9kZWxQYXRoPXQsdGhpcy5rZXlzPUhjKHRoaXMubW9kZWxQYXRoKX1yZXR1cm4gdC5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbih0KXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxuLHI7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihvKXtpZih0Lm1vZGVsVG9wb2xvZ3kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyTG9jYWxTdG9yYWdlLnNhdmUoKSBkb2VzIG5vdCBzdXBwb3J0IHNhdmluZyBtb2RlbCB0b3BvbG9neSBpbiBiaW5hcnkgZm9ybWF0cyB5ZXQuXCIpO2U9SlNPTi5zdHJpbmdpZnkodC5tb2RlbFRvcG9sb2d5KSxuPUpTT04uc3RyaW5naWZ5KHQud2VpZ2h0U3BlY3MpLHI9U2ModCk7dHJ5e3JldHVybiB0aGlzLkxTLnNldEl0ZW0odGhpcy5rZXlzLmluZm8sSlNPTi5zdHJpbmdpZnkocikpLHRoaXMuTFMuc2V0SXRlbSh0aGlzLmtleXMudG9wb2xvZ3ksZSksdGhpcy5MUy5zZXRJdGVtKHRoaXMua2V5cy53ZWlnaHRTcGVjcyxuKSx0aGlzLkxTLnNldEl0ZW0odGhpcy5rZXlzLndlaWdodERhdGEsKGE9dC53ZWlnaHREYXRhLGJjP0J1ZmZlci5mcm9tKGEpLnRvU3RyaW5nKFwiYmFzZTY0XCIpOmJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLG5ldyBVaW50OEFycmF5KGEpKSkpKSx0aGlzLkxTLnNldEl0ZW0odGhpcy5rZXlzLm1vZGVsTWV0YWRhdGEsSlNPTi5zdHJpbmdpZnkoe2Zvcm1hdDp0LmZvcm1hdCxnZW5lcmF0ZWRCeTp0LmdlbmVyYXRlZEJ5LGNvbnZlcnRlZEJ5OnQuY29udmVydGVkQnl9KSksWzIse21vZGVsQXJ0aWZhY3RzSW5mbzpyfV19Y2F0Y2godCl7dGhyb3cgdGhpcy5MUy5yZW1vdmVJdGVtKHRoaXMua2V5cy5pbmZvKSx0aGlzLkxTLnJlbW92ZUl0ZW0odGhpcy5rZXlzLnRvcG9sb2d5KSx0aGlzLkxTLnJlbW92ZUl0ZW0odGhpcy5rZXlzLndlaWdodFNwZWNzKSx0aGlzLkxTLnJlbW92ZUl0ZW0odGhpcy5rZXlzLndlaWdodERhdGEpLHRoaXMuTFMucmVtb3ZlSXRlbSh0aGlzLmtleXMubW9kZWxNZXRhZGF0YSksbmV3IEVycm9yKFwiRmFpbGVkIHRvIHNhdmUgbW9kZWwgJ1wiK3RoaXMubW9kZWxQYXRoK1wiJyB0byBsb2NhbCBzdG9yYWdlOiBzaXplIHF1b3RhIGJlaW5nIGV4Y2VlZGVkIGlzIGEgcG9zc2libGUgY2F1c2Ugb2YgdGhpcyBmYWlsdXJlOiBtb2RlbFRvcG9sb2d5Qnl0ZXM9XCIrci5tb2RlbFRvcG9sb2d5Qnl0ZXMrXCIsIHdlaWdodFNwZWNzQnl0ZXM9XCIrci53ZWlnaHRTcGVjc0J5dGVzK1wiLCB3ZWlnaHREYXRhQnl0ZXM9XCIrci53ZWlnaHREYXRhQnl0ZXMrXCIuXCIpfXZhciBhO3JldHVyblsyXX0pfSl9LHQucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlLG4scixhLGkscztyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG8pe2lmKG51bGw9PSh0PUpTT04ucGFyc2UodGhpcy5MUy5nZXRJdGVtKHRoaXMua2V5cy5pbmZvKSkpKXRocm93IG5ldyBFcnJvcihcIkluIGxvY2FsIHN0b3JhZ2UsIHRoZXJlIGlzIG5vIG1vZGVsIHdpdGggbmFtZSAnXCIrdGhpcy5tb2RlbFBhdGgrXCInXCIpO2lmKFwiSlNPTlwiIT09dC5tb2RlbFRvcG9sb2d5VHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyTG9jYWxTdG9yYWdlIGRvZXMgbm90IHN1cHBvcnQgbG9hZGluZyBub24tSlNPTiBtb2RlbCB0b3BvbG9neSB5ZXQuXCIpO2lmKGU9e30sbnVsbD09KG49SlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLnRvcG9sb2d5KSkpKXRocm93IG5ldyBFcnJvcihcIkluIGxvY2FsIHN0b3JhZ2UsIHRoZSB0b3BvbG9neSBvZiBtb2RlbCAnXCIrdGhpcy5tb2RlbFBhdGgrXCInIGlzIG1pc3NpbmcuXCIpO2lmKGUubW9kZWxUb3BvbG9neT1uLG51bGw9PShyPUpTT04ucGFyc2UodGhpcy5MUy5nZXRJdGVtKHRoaXMua2V5cy53ZWlnaHRTcGVjcykpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbiBsb2NhbCBzdG9yYWdlLCB0aGUgd2VpZ2h0IHNwZWNzIG9mIG1vZGVsICdcIit0aGlzLm1vZGVsUGF0aCtcIicgYXJlIG1pc3NpbmcuXCIpO2lmKGUud2VpZ2h0U3BlY3M9cixudWxsIT0oYT10aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLm1vZGVsTWV0YWRhdGEpKSYmKGk9SlNPTi5wYXJzZShhKSxlLmZvcm1hdD1pLmZvcm1hdCxlLmdlbmVyYXRlZEJ5PWkuZ2VuZXJhdGVkQnksZS5jb252ZXJ0ZWRCeT1pLmNvbnZlcnRlZEJ5KSxudWxsPT0ocz10aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLndlaWdodERhdGEpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbiBsb2NhbCBzdG9yYWdlLCB0aGUgYmluYXJ5IHdlaWdodCB2YWx1ZXMgb2YgbW9kZWwgJ1wiK3RoaXMubW9kZWxQYXRoK1wiJyBhcmUgbWlzc2luZy5cIik7cmV0dXJuIGUud2VpZ2h0RGF0YT1mdW5jdGlvbih0KXtpZihiYyl7dmFyIGU9QnVmZmVyLmZyb20odCxcImJhc2U2NFwiKTtyZXR1cm4gZS5idWZmZXIuc2xpY2UoZS5ieXRlT2Zmc2V0LGUuYnl0ZU9mZnNldCtlLmJ5dGVMZW5ndGgpfWZvcih2YXIgbj1hdG9iKHQpLHI9bmV3IFVpbnQ4QXJyYXkobi5sZW5ndGgpLG89MDtvPG4ubGVuZ3RoOysrbylyLnNldChbbi5jaGFyQ29kZUF0KG8pXSxvKTtyZXR1cm4gci5idWZmZXJ9KHMpLFsyLGVdfSl9KX0sdC5VUkxfU0NIRU1FPVwibG9jYWxzdG9yYWdlOi8vXCIsdH0oKSxLYz1mdW5jdGlvbih0KXtyZXR1cm4gYS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSYmIUFycmF5LmlzQXJyYXkodCkmJnQuc3RhcnRzV2l0aChqYy5VUkxfU0NIRU1FKT8oZT10LnNsaWNlKGpjLlVSTF9TQ0hFTUUubGVuZ3RoKSxuZXcgamMoZSkpOm51bGw7dmFyIGV9O05jLnJlZ2lzdGVyU2F2ZVJvdXRlcihLYyksTmMucmVnaXN0ZXJMb2FkUm91dGVyKEtjKTt2YXIgWGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7ZChhLmdldEJvb2woXCJJU19CUk9XU0VSXCIpLGZ1bmN0aW9uKCl7cmV0dXJuXCJDdXJyZW50IGVudmlyb25tZW50IGlzIG5vdCBhIHdlYiBicm93c2VyXCJ9KSxkKHZvaWQgMCE9PXdpbmRvdy5sb2NhbFN0b3JhZ2UsZnVuY3Rpb24oKXtyZXR1cm5cIkN1cnJlbnQgYnJvd3NlciBkb2VzIG5vdCBhcHBlYXIgdG8gc3VwcG9ydCBsb2NhbFN0b3JhZ2VcIn0pLHRoaXMuTFM9d2luZG93LmxvY2FsU3RvcmFnZX1yZXR1cm4gdC5wcm90b3R5cGUubGlzdE1vZGVscz1mdW5jdGlvbigpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGUsbixyLGEsaTtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG8pe2Zvcih0PXt9LGU9V2MrTGMsbj1MYytVYyxyPTA7cjx0aGlzLkxTLmxlbmd0aDsrK3IpKGE9dGhpcy5MUy5rZXkocikpLnN0YXJ0c1dpdGgoZSkmJmEuZW5kc1dpdGgobikmJihpPSRjKGEpLHRbaV09SlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0oYSkpKTtyZXR1cm5bMix0XX0pfSl9LHQucHJvdG90eXBlLnJlbW92ZU1vZGVsPWZ1bmN0aW9uKHQpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLG47cmV0dXJuIG8odGhpcyxmdW5jdGlvbihyKXt2YXIgbztpZih0PShvPXQpLnN0YXJ0c1dpdGgoamMuVVJMX1NDSEVNRSk/by5zbGljZShqYy5VUkxfU0NIRU1FLmxlbmd0aCk6byxlPUhjKHQpLG51bGw9PXRoaXMuTFMuZ2V0SXRlbShlLmluZm8pKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZGVsIGF0IHBhdGggJ1wiK3QrXCInXCIpO3JldHVybiBuPUpTT04ucGFyc2UodGhpcy5MUy5nZXRJdGVtKGUuaW5mbykpLHRoaXMuTFMucmVtb3ZlSXRlbShlLmluZm8pLHRoaXMuTFMucmVtb3ZlSXRlbShlLnRvcG9sb2d5KSx0aGlzLkxTLnJlbW92ZUl0ZW0oZS53ZWlnaHRTcGVjcyksdGhpcy5MUy5yZW1vdmVJdGVtKGUud2VpZ2h0RGF0YSksWzIsbl19KX0pfSx0fSgpO2lmKGEuZ2V0Qm9vbChcIklTX0JST1dTRVJcIikpdHJ5e0ljLnJlZ2lzdGVyTWFuYWdlcihqYy5VUkxfU0NIRU1FLG5ldyBYYyl9Y2F0Y2godCl7fXZhciBZYz1cIm1vZGVsXCIsUWM9XCIuanNvblwiLEpjPVwiLndlaWdodHMuYmluXCI7ZnVuY3Rpb24gWmModCl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHQpe3JldHVybiBzZXRUaW1lb3V0KHQpfSkudGhlbih0KX12YXIgdGg9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe2lmKCFhLmdldEJvb2woXCJJU19CUk9XU0VSXCIpKXRocm93IG5ldyBFcnJvcihcImJyb3dzZXJEb3dubG9hZHMoKSBjYW5ub3QgcHJvY2VlZCBiZWNhdXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGlzIG5vdCBhIGJyb3dzZXIuXCIpO2Uuc3RhcnRzV2l0aCh0LlVSTF9TQ0hFTUUpJiYoZT1lLnNsaWNlKHQuVVJMX1NDSEVNRS5sZW5ndGgpKSxudWxsIT1lJiYwIT09ZS5sZW5ndGh8fChlPVljKSx0aGlzLm1vZGVsVG9wb2xvZ3lGaWxlTmFtZT1lK1FjLHRoaXMud2VpZ2h0RGF0YUZpbGVOYW1lPWUrSmN9cmV0dXJuIHQucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24odCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsbixyLGEsaSxzO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obyl7c3dpdGNoKG8ubGFiZWwpe2Nhc2UgMDppZihlPXdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFt0LndlaWdodERhdGFdLHt0eXBlOlwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJ9KSksISh0Lm1vZGVsVG9wb2xvZ3kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpcmV0dXJuWzMsMV07dGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckRvd25sb2Fkcy5zYXZlKCkgZG9lcyBub3Qgc3VwcG9ydCBzYXZpbmcgbW9kZWwgdG9wb2xvZ3kgaW4gYmluYXJ5IGZvcm1hdHMgeWV0LlwiKTtjYXNlIDE6cmV0dXJuIG49W3twYXRoczpbXCIuL1wiK3RoaXMud2VpZ2h0RGF0YUZpbGVOYW1lXSx3ZWlnaHRzOnQud2VpZ2h0U3BlY3N9XSxyPXttb2RlbFRvcG9sb2d5OnQubW9kZWxUb3BvbG9neSxmb3JtYXQ6dC5mb3JtYXQsZ2VuZXJhdGVkQnk6dC5nZW5lcmF0ZWRCeSxjb252ZXJ0ZWRCeTp0LmNvbnZlcnRlZEJ5LHdlaWdodHNNYW5pZmVzdDpufSxhPXdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtKU09OLnN0cmluZ2lmeShyKV0se3R5cGU6XCJhcHBsaWNhdGlvbi9qc29uXCJ9KSksKGk9bnVsbD09dGhpcy5qc29uQW5jaG9yP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpOnRoaXMuanNvbkFuY2hvcikuZG93bmxvYWQ9dGhpcy5tb2RlbFRvcG9sb2d5RmlsZU5hbWUsaS5ocmVmPWEsWzQsWmMoZnVuY3Rpb24oKXtyZXR1cm4gaS5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIikpfSldO2Nhc2UgMjpyZXR1cm4gby5zZW50KCksbnVsbD09dC53ZWlnaHREYXRhP1szLDRdOigocz1udWxsPT10aGlzLndlaWdodERhdGFBbmNob3I/ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik6dGhpcy53ZWlnaHREYXRhQW5jaG9yKS5kb3dubG9hZD10aGlzLndlaWdodERhdGFGaWxlTmFtZSxzLmhyZWY9ZSxbNCxaYyhmdW5jdGlvbigpe3JldHVybiBzLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiKSl9KV0pO2Nhc2UgMzpvLnNlbnQoKSxvLmxhYmVsPTQ7Y2FzZSA0OnJldHVyblsyLHttb2RlbEFydGlmYWN0c0luZm86U2ModCl9XX19KX0pfSx0LlVSTF9TQ0hFTUU9XCJkb3dubG9hZHM6Ly9cIix0fSgpLGVoPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZihudWxsPT10fHx0Lmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcIldoZW4gY2FsbGluZyBicm93c2VyRmlsZXMsIGF0IGxlYXN0IDEgZmlsZSBpcyByZXF1aXJlZCwgYnV0IHJlY2VpdmVkIFwiK3QpO3RoaXMuZmlsZXM9dH1yZXR1cm4gdC5wcm90b3R5cGUubG9hZD1mdW5jdGlvbigpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGUsbj10aGlzO3JldHVybiBvKHRoaXMsZnVuY3Rpb24ocil7cmV0dXJuIHQ9dGhpcy5maWxlc1swXSxlPXRoaXMuZmlsZXMuc2xpY2UoMSksWzIsbmV3IFByb21pc2UoZnVuY3Rpb24ocixvKXt2YXIgYT1uZXcgRmlsZVJlYWRlcjthLm9ubG9hZD1mdW5jdGlvbihhKXt2YXIgaT1KU09OLnBhcnNlKGEudGFyZ2V0LnJlc3VsdCkscz1pLm1vZGVsVG9wb2xvZ3k7aWYobnVsbCE9cyl7MD09PWUubGVuZ3RoJiZyKHttb2RlbFRvcG9sb2d5OnN9KTt2YXIgdT1pLndlaWdodHNNYW5pZmVzdDtpZihudWxsIT11KXt2YXIgbDt0cnl7bD1uLmNoZWNrTWFuaWZlc3RBbmRXZWlnaHRGaWxlcyh1LGUpfWNhdGNoKHQpe3JldHVybiB2b2lkIG8odCl9dmFyIGM9W10saD1bXSxwPVtdO3UuZm9yRWFjaChmdW5jdGlvbih0KXt0LnBhdGhzLmZvckVhY2goZnVuY3Rpb24odCl7aC5wdXNoKHQpLHAucHVzaChudWxsKX0pLGMucHVzaC5hcHBseShjLHQud2VpZ2h0cyl9KSx1LmZvckVhY2goZnVuY3Rpb24odCl7dC5wYXRocy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBGaWxlUmVhZGVyO2Uub25sb2FkPWZ1bmN0aW9uKGUpe3ZhciBuPWUudGFyZ2V0LnJlc3VsdCxvPWguaW5kZXhPZih0KTtwW29dPW4sLTE9PT1wLmluZGV4T2YobnVsbCkmJnIoe21vZGVsVG9wb2xvZ3k6cyx3ZWlnaHRTcGVjczpjLHdlaWdodERhdGE6RWMocCl9KX0sZS5vbmVycm9yPWZ1bmN0aW9uKGUpe3JldHVybiBvKFwiRmFpbGVkIHRvIHdlaWdodHMgZGF0YSBmcm9tIGZpbGUgb2YgcGF0aCAnXCIrdCtcIicuXCIpfSxlLnJlYWRBc0FycmF5QnVmZmVyKGxbdF0pfSl9KX1lbHNlIG8obmV3IEVycm9yKFwid2VpZ2h0TWFuaWZlc3QgZmllbGQgaXMgbWlzc2luZyBmcm9tIGZpbGUgXCIrdC5uYW1lKSl9ZWxzZSBvKG5ldyBFcnJvcihcIm1vZGVsVG9wb2xvZ3kgZmllbGQgaXMgbWlzc2luZyBmcm9tIGZpbGUgXCIrdC5uYW1lKSl9LGEub25lcnJvcj1mdW5jdGlvbihlKXtyZXR1cm4gbyhcIkZhaWxlZCB0byByZWFkIG1vZGVsIHRvcG9sb2d5IGFuZCB3ZWlnaHRzIG1hbmlmZXN0IEpTT04gZnJvbSBmaWxlICdcIit0Lm5hbWUrXCInLiBCcm93c2VyRmlsZXMgc3VwcG9ydHMgbG9hZGluZyBLZXJhcy1zdHlsZSB0Zi5Nb2RlbCBhcnRpZmFjdHMgb25seS5cIil9LGEucmVhZEFzVGV4dCh0KX0pXX0pfSl9LHQucHJvdG90eXBlLmNoZWNrTWFuaWZlc3RBbmRXZWlnaHRGaWxlcz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1bXSxyPWUubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBSYyh0Lm5hbWUpfSksbz17fSxhPTAsaT10O2E8aS5sZW5ndGg7YSsrKXtpW2FdLnBhdGhzLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIGE9UmModCk7aWYoLTEhPT1uLmluZGV4T2YoYSkpdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGZpbGUgYmFzZW5hbWUgZm91bmQgaW4gd2VpZ2h0cyBtYW5pZmVzdDogJ1wiK2ErXCInXCIpO2lmKG4ucHVzaChhKSwtMT09PXIuaW5kZXhPZihhKSl0aHJvdyBuZXcgRXJyb3IoXCJXZWlnaHQgZmlsZSB3aXRoIGJhc2VuYW1lICdcIithK1wiJyBpcyBub3QgcHJvdmlkZWQuXCIpO29bdF09ZVtyLmluZGV4T2YoYSldfSl9aWYobi5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaCBpbiB0aGUgbnVtYmVyIG9mIGZpbGVzIGluIHdlaWdodHMgbWFuaWZlc3QgKFwiK24ubGVuZ3RoK1wiKSBhbmQgdGhlIG51bWJlciBvZiB3ZWlnaHQgZmlsZXMgcHJvdmlkZWQgKFwiK2UubGVuZ3RoK1wiKS5cIik7cmV0dXJuIG99LHR9KCk7ZnVuY3Rpb24gbmgodCxlLG4scil7IWZ1bmN0aW9uKHQpe2QobnVsbCE9dCYmQXJyYXkuaXNBcnJheSh0KSYmdC5sZW5ndGg+MCxmdW5jdGlvbigpe3JldHVyblwicHJvbWlzZXMgbXVzdCBiZSBhIG5vbmUgZW1wdHkgYXJyYXlcIn0pfSh0KSxmdW5jdGlvbih0LGUpe2QodD49MCYmdDw9MSxmdW5jdGlvbigpe3JldHVyblwiUHJvZ3Jlc3MgZnJhY3Rpb24gbXVzdCBiZSBpbiByYW5nZSBbMCwgMV0sIGJ1dCBnb3Qgc3RhcnRGcmFjdGlvbiBcIit0fSksZChlPj0wJiZlPD0xLGZ1bmN0aW9uKCl7cmV0dXJuXCJQcm9ncmVzcyBmcmFjdGlvbiBtdXN0IGJlIGluIHJhbmdlIFswLCAxXSwgYnV0IGdvdCBlbmRGcmFjdGlvbiBcIitlfSksZChlPj10LGZ1bmN0aW9uKCl7cmV0dXJuXCJzdGFydEZyYWN0aW9uIG11c3QgYmUgbm8gbW9yZSB0aGFuIGVuZEZyYWN0aW9uLCBidXQgZ290IHN0YXJ0RnJhY3Rpb24gXCIrdCtcIiBhbmQgZW5kRnJhY3Rpb24gXCIrZX0pfShuPW51bGw9PW4/MDpuLHI9bnVsbD09cj8xOnIpO3ZhciBvPTA7cmV0dXJuIFByb21pc2UuYWxsKHQubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBhLnRoZW4oZnVuY3Rpb24oYSl7dmFyIGk9bisgKytvL3QubGVuZ3RoKihyLW4pO3JldHVybiBlKGkpLGF9KSxhfSkpfWZ1bmN0aW9uIHJoKHQsZSl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIG4scixhLGkscyx1LGwsYyxoO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obyl7c3dpdGNoKG8ubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbnVsbD09ZSYmKGU9e30pLG49bnVsbD09ZS5mZXRjaEZ1bmM/SjplLmZldGNoRnVuYyxyPXQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBuKHQsZS5yZXF1ZXN0SW5pdCl9KSxhPTAsaT0uNSxudWxsIT1lLm9uUHJvZ3Jlc3M/WzMsMl06WzQsUHJvbWlzZS5hbGwocildO2Nhc2UgMTpyZXR1cm4gcz1vLnNlbnQoKSxbMyw0XTtjYXNlIDI6cmV0dXJuWzQsbmgocixlLm9uUHJvZ3Jlc3MsYSxpKV07Y2FzZSAzOnM9by5zZW50KCksby5sYWJlbD00O2Nhc2UgNDpyZXR1cm4gdT1zLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5hcnJheUJ1ZmZlcigpfSksbD0uNSxjPTEsbnVsbCE9ZS5vblByb2dyZXNzP1szLDZdOls0LFByb21pc2UuYWxsKHUpXTtjYXNlIDU6cmV0dXJuIGg9by5zZW50KCksWzMsOF07Y2FzZSA2OnJldHVybls0LG5oKHUsZS5vblByb2dyZXNzLGwsYyldO2Nhc2UgNzpoPW8uc2VudCgpLG8ubGFiZWw9ODtjYXNlIDg6cmV0dXJuWzIsaF19fSl9KX1mdW5jdGlvbiBvaCh0KXt2YXIgZT10aGlzO3JldHVybiBmdW5jdGlvbihuLGEsaSl7cmV0dXJuIHZvaWQgMD09PWEmJihhPVwiXCIpLHIoZSx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUscixzLHUsbCxjLGgscCxmLGQ7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOmlmKGU9bi5tYXAoZnVuY3Rpb24oKXtyZXR1cm4hMX0pLHI9e30scz1udWxsIT1pP2kubWFwKGZ1bmN0aW9uKCl7cmV0dXJuITF9KTpbXSx1PVtdLG4uZm9yRWFjaChmdW5jdGlvbih0LG4pe3ZhciBvPTA7dC53ZWlnaHRzLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIGE9XCJxdWFudGl6YXRpb25cImluIHQ/dC5xdWFudGl6YXRpb24uZHR5cGU6dC5kdHlwZSxsPXljW2FdKnkodC5zaGFwZSksYz1mdW5jdGlvbigpe2Vbbl09ITAsbnVsbD09cltuXSYmKHJbbl09W10pLHJbbl0ucHVzaCh7bWFuaWZlc3RFbnRyeTp0LGdyb3VwT2Zmc2V0Om8sc2l6ZUJ5dGVzOmx9KX07bnVsbCE9aT9pLmZvckVhY2goZnVuY3Rpb24oZSxuKXtlPT09dC5uYW1lJiYoYygpLHNbbl09ITApfSk6YygpLHUucHVzaCh0Lm5hbWUpLG8rPWx9KX0pLCFzLmV2ZXJ5KGZ1bmN0aW9uKHQpe3JldHVybiB0fSkpdGhyb3cgbD1pLmZpbHRlcihmdW5jdGlvbih0LGUpe3JldHVybiFzW2VdfSksbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgd2VpZ2h0cyBpbiBtYW5pZmVzdCB3aXRoIG5hbWVzOiBcIitsLmpvaW4oXCIsIFwiKStcIi4gXFxuTWFuaWZlc3QgSlNPTiBoYXMgd2VpZ2h0cyB3aXRoIG5hbWVzOiBcIit1LmpvaW4oXCIsIFwiKStcIi5cIik7cmV0dXJuIGM9ZS5yZWR1Y2UoZnVuY3Rpb24odCxlLG4pe3JldHVybiBlJiZ0LnB1c2gobiksdH0sW10pLGg9W10sYy5mb3JFYWNoKGZ1bmN0aW9uKHQpe25bdF0ucGF0aHMuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgZT1hKyhhLmVuZHNXaXRoKFwiL1wiKT9cIlwiOlwiL1wiKSt0O2gucHVzaChlKX0pfSksWzQsdChoKV07Y2FzZSAxOnJldHVybiBwPW8uc2VudCgpLGY9e30sZD0wLGMuZm9yRWFjaChmdW5jdGlvbih0KXtmb3IodmFyIGU9blt0XS5wYXRocy5sZW5ndGgsbz0wLGE9MDthPGU7YSsrKW8rPXBbZCthXS5ieXRlTGVuZ3RoO2Zvcih2YXIgaT1uZXcgQXJyYXlCdWZmZXIobykscz1uZXcgVWludDhBcnJheShpKSx1PTAsbD0wO2w8ZTtsKyspe3ZhciBjPW5ldyBVaW50OEFycmF5KHBbZCtsXSk7cy5zZXQoYyx1KSx1Kz1jLmJ5dGVMZW5ndGh9clt0XS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBlPXhjKGkuc2xpY2UodC5ncm91cE9mZnNldCx0Lmdyb3VwT2Zmc2V0K3Quc2l6ZUJ5dGVzKSxbdC5tYW5pZmVzdEVudHJ5XSk7Zm9yKHZhciBuIGluIGUpZltuXT1lW25dfSksZCs9ZX0pLFsyLGZdfX0pfSl9fU5jLnJlZ2lzdGVyU2F2ZVJvdXRlcihmdW5jdGlvbih0KXtyZXR1cm4gYS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSYmIUFycmF5LmlzQXJyYXkodCkmJnQuc3RhcnRzV2l0aCh0aC5VUkxfU0NIRU1FKT8oZT10LnNsaWNlKHRoLlVSTF9TQ0hFTUUubGVuZ3RoKSx2b2lkIDA9PT1lJiYoZT1cIm1vZGVsXCIpLG5ldyB0aChlKSk6bnVsbDt2YXIgZX0pO3ZhciBhaD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtpZih0aGlzLkRFRkFVTFRfTUVUSE9EPVwiUE9TVFwiLG51bGw9PWUmJihlPXt9KSx0aGlzLndlaWdodFBhdGhQcmVmaXg9ZS53ZWlnaHRQYXRoUHJlZml4LHRoaXMub25Qcm9ncmVzcz1lLm9uUHJvZ3Jlc3MsbnVsbCE9ZS5mZXRjaEZ1bmM/KGQoXCJmdW5jdGlvblwiPT10eXBlb2YgZS5mZXRjaEZ1bmMsZnVuY3Rpb24oKXtyZXR1cm5cIk11c3QgcGFzcyBhIGZ1bmN0aW9uIHRoYXQgbWF0Y2hlcyB0aGUgc2lnbmF0dXJlIG9mIGBmZXRjaGAgKHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmV0Y2hfQVBJKVwifSksdGhpcy5mZXRjaD1lLmZldGNoRnVuYyk6dGhpcy5mZXRjaD1KLGQobnVsbCE9dCYmdC5sZW5ndGg+MCxmdW5jdGlvbigpe3JldHVyblwiVVJMIHBhdGggZm9yIGh0dHAgbXVzdCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkIG9yIGVtcHR5LlwifSksQXJyYXkuaXNBcnJheSh0KSYmZCgyPT09dC5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIlVSTCBwYXRocyBmb3IgaHR0cCBtdXN0IGhhdmUgYSBsZW5ndGggb2YgMiwgKGFjdHVhbCBsZW5ndGggaXMgXCIrdC5sZW5ndGgrXCIpLlwifSksdGhpcy5wYXRoPXQsbnVsbCE9ZS5yZXF1ZXN0SW5pdCYmbnVsbCE9ZS5yZXF1ZXN0SW5pdC5ib2R5KXRocm93IG5ldyBFcnJvcihcInJlcXVlc3RJbml0IGlzIGV4cGVjdGVkIHRvIGhhdmUgbm8gcHJlLWV4aXN0aW5nIGJvZHksIGJ1dCBoYXMgb25lLlwiKTt0aGlzLnJlcXVlc3RJbml0PWUucmVxdWVzdEluaXR8fHt9fXJldHVybiB0LnByb3RvdHlwZS5zYXZlPWZ1bmN0aW9uKHQpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLG4scixhO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obyl7c3dpdGNoKG8ubGFiZWwpe2Nhc2UgMDppZih0Lm1vZGVsVG9wb2xvZ3kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VySFRUUFJlcXVlc3Quc2F2ZSgpIGRvZXMgbm90IHN1cHBvcnQgc2F2aW5nIG1vZGVsIHRvcG9sb2d5IGluIGJpbmFyeSBmb3JtYXRzIHlldC5cIik7cmV0dXJuKGU9T2JqZWN0LmFzc2lnbih7bWV0aG9kOnRoaXMuREVGQVVMVF9NRVRIT0R9LHRoaXMucmVxdWVzdEluaXQpKS5ib2R5PW5ldyBGb3JtRGF0YSxuPVt7cGF0aHM6W1wiLi9tb2RlbC53ZWlnaHRzLmJpblwiXSx3ZWlnaHRzOnQud2VpZ2h0U3BlY3N9XSxyPXttb2RlbFRvcG9sb2d5OnQubW9kZWxUb3BvbG9neSxmb3JtYXQ6dC5mb3JtYXQsZ2VuZXJhdGVkQnk6dC5nZW5lcmF0ZWRCeSxjb252ZXJ0ZWRCeTp0LmNvbnZlcnRlZEJ5LHdlaWdodHNNYW5pZmVzdDpufSxlLmJvZHkuYXBwZW5kKFwibW9kZWwuanNvblwiLG5ldyBCbG9iKFtKU09OLnN0cmluZ2lmeShyKV0se3R5cGU6XCJhcHBsaWNhdGlvbi9qc29uXCJ9KSxcIm1vZGVsLmpzb25cIiksbnVsbCE9dC53ZWlnaHREYXRhJiZlLmJvZHkuYXBwZW5kKFwibW9kZWwud2VpZ2h0cy5iaW5cIixuZXcgQmxvYihbdC53ZWlnaHREYXRhXSx7dHlwZTpcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwifSksXCJtb2RlbC53ZWlnaHRzLmJpblwiKSxbNCx0aGlzLmZldGNoKHRoaXMucGF0aCxlKV07Y2FzZSAxOmlmKChhPW8uc2VudCgpKS5vaylyZXR1cm5bMix7bW9kZWxBcnRpZmFjdHNJbmZvOlNjKHQpLHJlc3BvbnNlczpbYV19XTt0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VySFRUUFJlcXVlc3Quc2F2ZSgpIGZhaWxlZCBkdWUgdG8gSFRUUCByZXNwb25zZSBzdGF0dXMgXCIrYS5zdGF0dXMrXCIuXCIpfX0pfSl9LHQucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlLG4scixhLGkscyx1O3JldHVybiBvKHRoaXMsZnVuY3Rpb24obyl7c3dpdGNoKG8ubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLmZldGNoKHRoaXMucGF0aCx0aGlzLnJlcXVlc3RJbml0KV07Y2FzZSAxOmlmKCEodD1vLnNlbnQoKSkub2spdGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdCB0byBcIit0aGlzLnBhdGgrXCIgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgXCIrdC5zdGF0dXMrXCIuIFBsZWFzZSB2ZXJpZnkgdGhpcyBVUkwgcG9pbnRzIHRvIHRoZSBtb2RlbCBKU09OIG9mIHRoZSBtb2RlbCB0byBsb2FkLlwiKTtvLmxhYmVsPTI7Y2FzZSAyOnJldHVybiBvLnRyeXMucHVzaChbMiw0LCw1XSksWzQsdC5qc29uKCldO2Nhc2UgMzpyZXR1cm4gZT1vLnNlbnQoKSxbMyw1XTtjYXNlIDQ6dGhyb3cgby5zZW50KCksbj1cIkZhaWxlZCB0byBwYXJzZSBtb2RlbCBKU09OIG9mIHJlc3BvbnNlIGZyb20gXCIrdGhpcy5wYXRoK1wiLlwiLHRoaXMucGF0aC5lbmRzV2l0aChcIi5wYlwiKT9uKz1cIiBZb3VyIHBhdGggY29udGFpbnMgYSAucGIgZmlsZSBleHRlbnNpb24uIFN1cHBvcnQgZm9yIC5wYiBtb2RlbHMgaGF2ZSBiZWVuIHJlbW92ZWQgaW4gVGVuc29yRmxvdy5qcyAxLjAgaW4gZmF2b3Igb2YgLmpzb24gbW9kZWxzLiBZb3UgY2FuIHJlLWNvbnZlcnQgeW91ciBQeXRob24gVGVuc29yRmxvdyBtb2RlbCB1c2luZyB0aGUgVGVuc29yRmxvdy5qcyAxLjAgY29udmVyc2lvbiBzY3JpcHRzIG9yIHlvdSBjYW4gY29udmVydCB5b3VyLnBiIG1vZGVscyB3aXRoIHRoZSAncGIyanNvbidOUE0gc2NyaXB0IGluIHRoZSB0ZW5zb3JmbG93L3RmanMtY29udmVydGVyIHJlcG9zaXRvcnkuXCI6bis9XCIgUGxlYXNlIG1ha2Ugc3VyZSB0aGUgc2VydmVyIGlzIHNlcnZpbmcgdmFsaWQgSlNPTiBmb3IgdGhpcyByZXF1ZXN0LlwiLG5ldyBFcnJvcihuKTtjYXNlIDU6aWYocj1lLm1vZGVsVG9wb2xvZ3ksYT1lLndlaWdodHNNYW5pZmVzdCxudWxsPT1yJiZudWxsPT1hKXRocm93IG5ldyBFcnJvcihcIlRoZSBKU09OIGZyb20gSFRUUCBwYXRoIFwiK3RoaXMucGF0aCtcIiBjb250YWlucyBuZWl0aGVyIG1vZGVsIHRvcG9sb2d5IG9yIG1hbmlmZXN0IGZvciB3ZWlnaHRzLlwiKTtyZXR1cm4gbnVsbD09YT9bMyw3XTpbNCx0aGlzLmxvYWRXZWlnaHRzKGEpXTtjYXNlIDY6dT1vLnNlbnQoKSxpPXVbMF0scz11WzFdLG8ubGFiZWw9NztjYXNlIDc6cmV0dXJuWzIse21vZGVsVG9wb2xvZ3k6cix3ZWlnaHRTcGVjczppLHdlaWdodERhdGE6c31dfX0pfSl9LHQucHJvdG90eXBlLmxvYWRXZWlnaHRzPWZ1bmN0aW9uKHQpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLG4scixhLGkscyx1LGwsYyxoLHA7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOmZvcihlPUFycmF5LmlzQXJyYXkodGhpcy5wYXRoKT90aGlzLnBhdGhbMV06dGhpcy5wYXRoLG49ZnVuY3Rpb24odCl7dmFyIGU9dC5sYXN0SW5kZXhPZihcIi9cIiksbj10Lmxhc3RJbmRleE9mKFwiP1wiKSxyPXQuc3Vic3RyaW5nKDAsZSksbz1uPmU/dC5zdWJzdHJpbmcobik6XCJcIjtyZXR1cm5bcitcIi9cIixvXX0oZSkscj1uWzBdLGE9blsxXSxpPXRoaXMud2VpZ2h0UGF0aFByZWZpeHx8cixzPVtdLHU9MCxsPXQ7dTxsLmxlbmd0aDt1KyspYz1sW3VdLHMucHVzaC5hcHBseShzLGMud2VpZ2h0cyk7cmV0dXJuIGg9W10sdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QucGF0aHMuZm9yRWFjaChmdW5jdGlvbih0KXtoLnB1c2goaSt0K2EpfSl9KSxbNCxyaChoLHtyZXF1ZXN0SW5pdDp0aGlzLnJlcXVlc3RJbml0LGZldGNoRnVuYzp0aGlzLmZldGNoLG9uUHJvZ3Jlc3M6dGhpcy5vblByb2dyZXNzfSldO2Nhc2UgMTpyZXR1cm4gcD1vLnNlbnQoKSxbMixbcyxFYyhwKV1dfX0pfSl9LHQuVVJMX1NDSEVNRV9SRUdFWD0vXmh0dHBzPzpcXC9cXC8vLHR9KCk7ZnVuY3Rpb24gaWgodCl7cmV0dXJuIG51bGwhPXQubWF0Y2goYWguVVJMX1NDSEVNRV9SRUdFWCl9dmFyIHNoPWZ1bmN0aW9uKHQsZSl7cmV0dXJuKEFycmF5LmlzQXJyYXkodCk/dC5ldmVyeShmdW5jdGlvbih0KXtyZXR1cm4gaWgodCl9KTppaCh0KSk/dWgodCx7b25Qcm9ncmVzczplfSk6bnVsbH07ZnVuY3Rpb24gdWgodCxlKXtyZXR1cm4gbmV3IGFoKHQsZSl9TmMucmVnaXN0ZXJTYXZlUm91dGVyKHNoKSxOYy5yZWdpc3RlckxvYWRSb3V0ZXIoc2gpO3ZhciBsaD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLG4pe3RoaXMubW9kZWxUb3BvbG9neT10LHRoaXMud2VpZ2h0U3BlY3M9ZSx0aGlzLndlaWdodERhdGE9bn1yZXR1cm4gdC5wcm90b3R5cGUubG9hZD1mdW5jdGlvbigpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0O3JldHVybiBvKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuIHQ9e30sbnVsbCE9dGhpcy5tb2RlbFRvcG9sb2d5JiYodD1uKHttb2RlbFRvcG9sb2d5OnRoaXMubW9kZWxUb3BvbG9neX0sdCkpLG51bGwhPXRoaXMud2VpZ2h0U3BlY3MmJnRoaXMud2VpZ2h0U3BlY3MubGVuZ3RoPjAmJih0PW4oe3dlaWdodFNwZWNzOnRoaXMud2VpZ2h0U3BlY3N9LHQpKSxudWxsIT10aGlzLndlaWdodERhdGEmJnRoaXMud2VpZ2h0RGF0YS5ieXRlTGVuZ3RoPjAmJih0PW4oe3dlaWdodERhdGE6dGhpcy53ZWlnaHREYXRhfSx0KSksWzIsdF19KX0pfSx0fSgpLGNoPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLnNhdmVIYW5kbGVyPXR9cmV0dXJuIHQucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24odCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihlKXtyZXR1cm5bMix0aGlzLnNhdmVIYW5kbGVyKHQpXX0pfSl9LHR9KCk7dmFyIGhoPU9iamVjdC5mcmVlemUoe2Jyb3dzZXJGaWxlczpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGVoKHQpfSxicm93c2VySFRUUFJlcXVlc3Q6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdWgodCxlKX0sY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnM6RWMsZGVjb2RlV2VpZ2h0czp4YyxlbmNvZGVXZWlnaHRzOmZ1bmN0aW9uKHQpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLG4scixhO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obyl7c3dpdGNoKG8ubGFiZWwpe2Nhc2UgMDpmb3IociBpbiBlPVtdLG49W10sdCl7aWYoXCJmbG9hdDMyXCIhPT0oYT10W3JdKS5kdHlwZSYmXCJpbnQzMlwiIT09YS5kdHlwZSYmXCJib29sXCIhPT1hLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGR0eXBlIGluIHdlaWdodCAnXCIrcitcIic6IFwiK2EuZHR5cGUpO2UucHVzaCh7bmFtZTpyLHNoYXBlOmEuc2hhcGUsZHR5cGU6YS5kdHlwZX0pLG4ucHVzaChhLmRhdGEoKSl9cmV0dXJuWzQsUHJvbWlzZS5hbGwobildO2Nhc2UgMTpyZXR1cm5bMix7ZGF0YTp3YyhvLnNlbnQoKSksc3BlY3M6ZX1dfX0pfSl9LGZyb21NZW1vcnk6ZnVuY3Rpb24odCxlLG4pe3JldHVybiBuZXcgbGgodCxlLG4pfSxnZXRMb2FkSGFuZGxlcnM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gTmMuZ2V0TG9hZEhhbmRsZXJzKHQpfSxnZXRNb2RlbEFydGlmYWN0c0luZm9Gb3JKU09OOlNjLGdldFNhdmVIYW5kbGVyczpmdW5jdGlvbih0KXtyZXR1cm4gTmMuZ2V0U2F2ZUhhbmRsZXJzKHQpfSxodHRwOnVoLGlzSFRUUFNjaGVtZTppaCxsb2FkV2VpZ2h0czpmdW5jdGlvbih0LGUsbixhKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9XCJcIikscih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKHIpe3JldHVyblsyLG9oKGZ1bmN0aW9uKHQpe3JldHVybiByaCh0LHtyZXF1ZXN0SW5pdDphfSl9KSh0LGUsbildfSl9KX0scmVnaXN0ZXJMb2FkUm91dGVyOmZ1bmN0aW9uKHQpe3JldHVybiBOYy5yZWdpc3RlckxvYWRSb3V0ZXIodCl9LHJlZ2lzdGVyU2F2ZVJvdXRlcjpmdW5jdGlvbih0KXtyZXR1cm4gTmMucmVnaXN0ZXJTYXZlUm91dGVyKHQpfSx3ZWlnaHRzTG9hZGVyRmFjdG9yeTpvaCx3aXRoU2F2ZUhhbmRsZXI6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBjaCh0KX0sY29weU1vZGVsOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihuKXtyZXR1cm5bMixUYyh0LGUsITEpXX0pfSl9LGxpc3RNb2RlbHM6ZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlLG4scixhLGkscztyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6dD1JYy5nZXRTY2hlbWVzKCksZT17fSxuPTAscj10LG8ubGFiZWw9MTtjYXNlIDE6cmV0dXJuIG48ci5sZW5ndGg/KGE9cltuXSxbNCxJYy5nZXRNYW5hZ2VyKGEpLmxpc3RNb2RlbHMoKV0pOlszLDRdO2Nhc2UgMjpmb3IocyBpbiBpPW8uc2VudCgpKWVbYStrYytzXT1pW3NdO28ubGFiZWw9MztjYXNlIDM6cmV0dXJuIG4rKyxbMywxXTtjYXNlIDQ6cmV0dXJuWzIsZV19fSl9KX0sbW92ZU1vZGVsOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihuKXtyZXR1cm5bMixUYyh0LGUsITApXX0pfSl9LHJlbW92ZU1vZGVsOmZ1bmN0aW9uKHQpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obil7cmV0dXJuIGU9QWModCksWzIsSWMuZ2V0TWFuYWdlcihlLnNjaGVtZSkucmVtb3ZlTW9kZWwoZS5wYXRoKV19KX0pfX0pO3ZhciBwaD1Bbih7Y29uZnVzaW9uTWF0cml4XzpmdW5jdGlvbih0LGUsbil7dmFyIHI9d24odCxcImxhYmVsc1wiLFwiY29uZnVzaW9uTWF0cml4XCIpLG89d24oZSxcInByZWRpY3Rpb25zXCIsXCJjb25mdXNpb25NYXRyaXhcIik7ZChudWxsPT1ufHxuPjAmJk51bWJlci5pc0ludGVnZXIobiksZnVuY3Rpb24oKXtyZXR1cm5cIklmIHByb3ZpZGVkLCBudW1DbGFzc2VzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBidXQgZ290IFwiK259KSxkKDE9PT1yLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkV4cGVjdGVkIHRoZSByYW5rIG9mIGxhYmVscyB0byBiZSAxLCBidXQgZ290IFwiK3IucmFua30pLGQoMT09PW8ucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXhwZWN0ZWQgdGhlIHJhbmsgb2YgcHJlZGljdGlvbnMgdG8gYmUgMSwgYnV0IGdvdCBcIitvLnJhbmt9KSxkKHIuc2hhcGVbMF09PT1vLnNoYXBlWzBdLGZ1bmN0aW9uKCl7cmV0dXJuXCJNaXNtYXRjaCBpbiB0aGUgbnVtYmVyIG9mIGV4YW1wbGVzOiBcIityLnNoYXBlWzBdK1wiIHZzLiBcIitvLnNoYXBlWzBdK1wiLiBMYWJlbHMgYW5kIHByZWRpY3Rpb25zIHNob3VsZCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy5cIn0pLGQobj4wJiZOdW1iZXIuaXNJbnRlZ2VyKG4pLGZ1bmN0aW9uKCl7cmV0dXJuXCJudW1DbGFzc2VzIGlzIHJlcXVpcmVkIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCBcIitufSk7dmFyIGE9QnIoci5hc1R5cGUoXCJpbnQzMlwiKSxuKSxpPUJyKG8uYXNUeXBlKFwiaW50MzJcIiksbik7cmV0dXJuIGEudHJhbnNwb3NlKCkubWF0TXVsKGkpLmFzVHlwZShcImludDMyXCIpfX0pLGZoPU9iamVjdC5mcmVlemUoe2NvbmZ1c2lvbk1hdHJpeDpwaH0pO3ZhciBkaD1Bbih7ZnJvbVBpeGVsc186ZnVuY3Rpb24odCxlKXtpZih2b2lkIDA9PT1lJiYoZT0zKSxlPjQpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnN0cnVjdCBUZW5zb3Igd2l0aCBtb3JlIHRoYW4gNCBjaGFubmVscyBmcm9tIHBpeGVscy5cIik7cmV0dXJuIER0LmZyb21QaXhlbHModCxlKX19KSx2aD1PYmplY3QuZnJlZXplKHt0b1BpeGVsczpmdW5jdGlvbih0LGUpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBuLHIsYSxpLHMsdSxsLGMsaCxwLGYsZCx2LG0sZyx5LHgsdyxiLEMsRSxSLFM7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOmlmKG49d24odCxcImltZ1wiLFwidG9QaXhlbHNcIiksdCBpbnN0YW5jZW9mIGZ0fHwobj1uLnRvSW50KCkpLDIhPT1uLnJhbmsmJjMhPT1uLnJhbmspdGhyb3cgbmV3IEVycm9yKFwidG9QaXhlbHMgb25seSBzdXBwb3J0cyByYW5rIDIgb3IgMyB0ZW5zb3JzLCBnb3QgcmFuayBcIituLnJhbmsrXCIuXCIpO2lmKHI9bi5zaGFwZS5zbGljZSgwLDIpLGE9clswXSxpPXJbMV0sKHM9Mj09PW4ucmFuaz8xOm4uc2hhcGVbMl0pPjR8fDI9PT1zKXRocm93IG5ldyBFcnJvcihcInRvUGl4ZWxzIG9ubHkgc3VwcG9ydHMgZGVwdGggb2Ygc2l6ZSAxLCAzIG9yIDQgYnV0IGdvdCBcIitzKTtyZXR1cm5bNCxuLmRhdGEoKV07Y2FzZSAxOnJldHVybiB1PW8uc2VudCgpLGw9bi5taW4oKSxjPW4ubWF4KCksWzQsUHJvbWlzZS5hbGwoW2wuZGF0YSgpLGMuZGF0YSgpXSldO2Nhc2UgMjppZihoPW8uc2VudCgpLHA9aFswXSxmPWhbMV0sZD1wWzBdLHY9ZlswXSxsLmRpc3Bvc2UoKSxjLmRpc3Bvc2UoKSxcImZsb2F0MzJcIj09PW4uZHR5cGUpe2lmKGQ8MHx8dj4xKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciB2YWx1ZXMgZm9yIGEgZmxvYXQzMiBUZW5zb3IgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzAgLSAxXSBidXQgZ290IHJhbmdlIFtcIitkK1wiIC0gXCIrditcIl0uXCIpfWVsc2V7aWYoXCJpbnQzMlwiIT09bi5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCB0eXBlIGZvciB0b1BpeGVsczogXCIrbi5kdHlwZStcIi4gUGxlYXNlIHVzZSBmbG9hdDMyIG9yIGludDMyIHRlbnNvcnMuXCIpO2lmKGQ8MHx8dj4yNTUpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIHZhbHVlcyBmb3IgYSBpbnQzMiBUZW5zb3IgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzAgLSAyNTVdIGJ1dCBnb3QgcmFuZ2UgW1wiK2QrXCIgLSBcIit2K1wiXS5cIil9Zm9yKG09XCJmbG9hdDMyXCI9PT1uLmR0eXBlPzI1NToxLGc9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGkqYSo0KSx5PTA7eTxhKmk7Kyt5KXg9dm9pZCAwLHc9dm9pZCAwLGI9dm9pZCAwLEM9dm9pZCAwLDE9PT1zPyh4PXVbeV0qbSx3PXVbeV0qbSxiPXVbeV0qbSxDPTI1NSk6Mz09PXM/KHg9dVszKnldKm0sdz11WzMqeSsxXSptLGI9dVszKnkrMl0qbSxDPTI1NSk6ND09PXMmJih4PXVbNCp5XSptLHc9dVs0KnkrMV0qbSxiPXVbNCp5KzJdKm0sQz11WzQqeSszXSptKSxnWzArKEU9NCp5KV09TWF0aC5yb3VuZCh4KSxnW0UrMV09TWF0aC5yb3VuZCh3KSxnW0UrMl09TWF0aC5yb3VuZChiKSxnW0UrM109TWF0aC5yb3VuZChDKTtyZXR1cm4gbnVsbCE9ZSYmKGUud2lkdGg9aSxlLmhlaWdodD1hLFI9ZS5nZXRDb250ZXh0KFwiMmRcIiksUz1uZXcgSW1hZ2VEYXRhKGcsaSxhKSxSLnB1dEltYWdlRGF0YShTLDAsMCkpLG4hPT10JiZuLmRpc3Bvc2UoKSxbMixnXX19KX0pfSxmcm9tUGl4ZWxzOmRofSksbWg9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5nZXRDbGFzc05hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jbGFzc05hbWV9LHQuZnJvbUNvbmZpZz1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgdChlKX0sdH0oKSxnaD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt0aGlzLmNsYXNzTmFtZU1hcD17fX1yZXR1cm4gdC5nZXRNYXA9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09dC5pbnN0YW5jZSYmKHQuaW5zdGFuY2U9bmV3IHQpLHQuaW5zdGFuY2V9LHQucmVnaXN0ZXI9ZnVuY3Rpb24oZSl7dC5nZXRNYXAoKS5jbGFzc05hbWVNYXBbZS5jbGFzc05hbWVdPVtlLGUuZnJvbUNvbmZpZ119LHR9KCk7ZnVuY3Rpb24geWgodCl7ZChudWxsIT10LmNsYXNzTmFtZSxmdW5jdGlvbigpe3JldHVyblwiQ2xhc3MgYmVpbmcgcmVnaXN0ZXJlZCBkb2VzIG5vdCBoYXZlIHRoZSBzdGF0aWMgY2xhc3NOYW1lIHByb3BlcnR5IGRlZmluZWQuXCJ9KSxkKFwic3RyaW5nXCI9PXR5cGVvZiB0LmNsYXNzTmFtZSxmdW5jdGlvbigpe3JldHVyblwiY2xhc3NOYW1lIGlzIHJlcXVpcmVkIHRvIGJlIGEgc3RyaW5nLCBidXQgZ290IHR5cGUgXCIrdHlwZW9mIHQuY2xhc3NOYW1lfSksZCh0LmNsYXNzTmFtZS5sZW5ndGg+MCxmdW5jdGlvbigpe3JldHVyblwiQ2xhc3MgYmVpbmcgcmVnaXN0ZXJlZCBoYXMgYW4gZW1wdHktc3RyaW5nIGFzIGl0cyBjbGFzc05hbWUsIHdoaWNoIGlzIGRpc2FsbG93ZWQuXCJ9KSxnaC5yZWdpc3Rlcih0KX12YXIgeGg9T2JqZWN0LmZyZWV6ZSh7U2VyaWFsaXphYmxlOm1oLFNlcmlhbGl6YXRpb25NYXA6Z2gscmVnaXN0ZXJDbGFzczp5aH0pLHdoPS4wMDEsYmg9LjE7ZnVuY3Rpb24gQ2goKXtyZXR1cm4gMzI9PT1EdC5iYWNrZW5kLmZsb2F0UHJlY2lzaW9uKCk/d2g6Ymh9ZnVuY3Rpb24gRWgodCxlLG4pe3ZhciByPSEwO2lmKChfKHQpfHxfKGUpKSYmKHI9ITEpLF8odCkmJl8oZSkmJihyPSEwKSxyKXt2YXIgbz10LmNvbnN0cnVjdG9yLm5hbWUsYT1lLmNvbnN0cnVjdG9yLm5hbWU7aWYobyE9PWEpdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlzIGFyZSBvZiBkaWZmZXJlbnQgdHlwZS4gQWN0dWFsOiBcIitvK1wiLiBFeHBlY3RlZDogXCIrYSl9aWYoQXJyYXkuaXNBcnJheSh0KSYmQXJyYXkuaXNBcnJheShlKSl7dmFyIGk9eW4odCkscz15bihlKTtpZigheChpLHMpKXRocm93IG5ldyBFcnJvcihcIkFycmF5cyBoYXZlIGRpZmZlcmVudCBzaGFwZXMuIEFjdHVhbDogW1wiK2krXCJdLiBFeHBlY3RlZDogW1wiK3MrXCJdXCIpfXZhciB1PV8odCk/dDpnKHQpLGw9XyhlKT9lOmcoZSk7aWYodS5sZW5ndGghPT1sLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgaGF2ZSBkaWZmZXJlbnQgbGVuZ3RocyBhY3R1YWw6IFwiK3UubGVuZ3RoK1wiIHZzIGV4cGVjdGVkOiBcIitsLmxlbmd0aCtcIi5cXG5BY3R1YWw6ICAgXCIrdStcIi5cXG5FeHBlY3RlZDogXCIrbCtcIi5cIik7Zm9yKHZhciBjPTA7YzxsLmxlbmd0aDsrK2Mpe3ZhciBoPXVbY10scD1sW2NdO2lmKCFuKGgscCkpdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlzIGRpZmZlcjogYWN0dWFsW1wiK2MrXCJdID0gXCIraCtcIiwgZXhwZWN0ZWRbXCIrYytcIl0gPSBcIitwK1wiLlxcbkFjdHVhbDogICBcIit1K1wiLlxcbkV4cGVjdGVkOiBcIitsK1wiLlwiKX19ZnVuY3Rpb24gUmgodCxlLG4pe3JldHVybiFpc0Zpbml0ZSh0KSYmIWlzRmluaXRlKGUpfHwhKGlzTmFOKHQpfHxpc05hTihlKXx8TWF0aC5hYnModC1lKT5uKX12YXIgU2g9T2JqZWN0LmZyZWV6ZSh7VEVTVF9FUFNJTE9OX0ZMT0FUMTY6YmgsZXhwZWN0QXJyYXlzQ2xvc2U6ZnVuY3Rpb24odCxlLG4pe3JldHVybiBudWxsPT1uJiYobj1DaCgpKSxFaCh0LGUsZnVuY3Rpb24odCxlKXtyZXR1cm4gUmgodCxlLG4pfSl9LHRlc3RFcHNpbG9uOkNoLGV4cGVjdFByb21pc2VUb0ZhaWw6ZnVuY3Rpb24odCxlKXt0KCkudGhlbihmdW5jdGlvbigpe3JldHVybiBlLmZhaWwoKX0sZnVuY3Rpb24oKXtyZXR1cm4gZSgpfSl9LGV4cGVjdEFycmF5c0VxdWFsOmZ1bmN0aW9uKHQsZSl7dmFyIG49XCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlfHxcImJvb2xlYW5cIj09dHlwZW9mIGU/W2VdOmU7cmV0dXJuIEIodCl8fEIodFswXSl8fEIoZSl8fEIoZVswXSk/RWgodCxuLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ9PWV9KTpFaCh0LGUsZnVuY3Rpb24odCxlKXtyZXR1cm4gUmgodCxlLDApfSl9LGV4cGVjdE51bWJlcnNDbG9zZTpmdW5jdGlvbih0LGUsbil7aWYobnVsbD09biYmKG49Q2goKSksIVJoKHQsZSxuKSl0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXJzIGRpZmZlcjogYWN0dWFsID09PSBcIit0K1wiLCBleHBlY3RlZCA9PT0gXCIrZSl9LGV4cGVjdFZhbHVlc0luUmFuZ2U6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKWlmKHRbcl08ZXx8dFtyXT5uKXRocm93IG5ldyBFcnJvcihcIlZhbHVlIG91dCBvZiByYW5nZTpcIit0W3JdK1wiIGxvdzogXCIrZStcIiwgaGlnaDogXCIrbil9LGV4cGVjdEFycmF5QnVmZmVyc0VxdWFsOmZ1bmN0aW9uKHQsZSl7ZXhwZWN0KG5ldyBGbG9hdDMyQXJyYXkodCkpLnRvRXF1YWwobmV3IEZsb2F0MzJBcnJheShlKSl9fSksTmg9XCIxLjEuMlwiLGtoPU9iamVjdC5mcmVlemUoe2dwZ3B1X3V0aWw6TGEsd2ViZ2xfdXRpbDprZSxNYXRoQmFja2VuZFdlYkdMOlVpLEdQR1BVQ29udGV4dDpXYX0pLEloPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oKXtyZXR1cm4gbnVsbCE9PXQmJnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBlKG4sdCksbi5wcm90b3R5cGUubWluaW1pemU9ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPSExKTt2YXIgcj10aGlzLmNvbXB1dGVHcmFkaWVudHModCxuKSxvPXIudmFsdWUsYT1yLmdyYWRzO3JldHVybiB0aGlzLmFwcGx5R3JhZGllbnRzKGEpLE9iamVjdC5rZXlzKGEpLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIGFbdF0uZGlzcG9zZSgpfSksZT9vOihvLmRpc3Bvc2UoKSxudWxsKX0sbi5wcm90b3R5cGUuY29tcHV0ZUdyYWRpZW50cz1mdW5jdGlvbih0LGUpe3JldHVybiBObih0LGUpfSxuLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7fSxufShtaCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEloLFN5bWJvbC5oYXNJbnN0YW5jZSx7dmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPXQubWluaW1pemUmJm51bGwhPXQuY29tcHV0ZUdyYWRpZW50cyYmbnVsbCE9dC5hcHBseUdyYWRpZW50c319KTt2YXIgQWg9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbihlLG4scil7dm9pZCAwPT09ciYmKHI9bnVsbCk7dmFyIG89dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBvLmxlYXJuaW5nUmF0ZT1lLG8ucmhvPW4sby5lcHNpbG9uPXIsby5hY2N1bXVsYXRlZEdyYWRzPXt9LG8uYWNjdW11bGF0ZWRVcGRhdGVzPXt9LG51bGw9PXImJihvLmVwc2lsb249RHQuYmFja2VuZC5lcHNpbG9uKCkpLG99cmV0dXJuIGUobix0KSxuLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLG49ZnVuY3Rpb24obil7dmFyIG89RHQucmVnaXN0ZXJlZFZhcmlhYmxlc1tuXTtpZihudWxsPT1yLmFjY3VtdWxhdGVkR3JhZHNbbl0pe0ZlKGZ1bmN0aW9uKCl7ZS5hY2N1bXVsYXRlZEdyYWRzW25dPVhuKG8pLnZhcmlhYmxlKCExKX0pfWlmKG51bGw9PXIuYWNjdW11bGF0ZWRVcGRhdGVzW25dKXtGZShmdW5jdGlvbigpe2UuYWNjdW11bGF0ZWRVcGRhdGVzW25dPVhuKG8pLnZhcmlhYmxlKCExKX0pfXZhciBhPXRbbl0saT1yLmFjY3VtdWxhdGVkR3JhZHNbbl0scz1yLmFjY3VtdWxhdGVkVXBkYXRlc1tuXTtGZShmdW5jdGlvbigpe3ZhciB0PWkubXVsKGUucmhvKS5hZGQoYS5zcXVhcmUoKS5tdWwoMS1lLnJobykpLHI9cy5hZGQoZS5lcHNpbG9uKS5zcXJ0KCkuZGl2KGkuYWRkKGUuZXBzaWxvbikuc3FydCgpKS5tdWwoYSksdT1zLm11bChlLnJobykuYWRkKHIuc3F1YXJlKCkubXVsKDEtZS5yaG8pKTtlLmFjY3VtdWxhdGVkR3JhZHNbbl0uYXNzaWduKHQpLGUuYWNjdW11bGF0ZWRVcGRhdGVzW25dLmFzc2lnbih1KTt2YXIgbD1yLm11bCgtZS5sZWFybmluZ1JhdGUpLmFkZChvKTtvLmFzc2lnbihsKX0pfSxyPXRoaXM7Zm9yKHZhciBvIGluIHQpbihvKX0sbi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3ZhciB0PXRoaXM7bnVsbCE9dGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMmJihPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkVXBkYXRlcykuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdC5hY2N1bXVsYXRlZFVwZGF0ZXNbZV0uZGlzcG9zZSgpfSksT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZEdyYWRzKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0LmFjY3VtdWxhdGVkR3JhZHNbZV0uZGlzcG9zZSgpfSkpfSxuLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLHJobzp0aGlzLnJobyxlcHNpbG9uOnRoaXMuZXBzaWxvbn19LG4uZnJvbUNvbmZpZz1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgdChlLmxlYXJuaW5nUmF0ZSxlLnJobyxlLmVwc2lsb24pfSxuLmNsYXNzTmFtZT1cIkFkYWRlbHRhT3B0aW1pemVyXCIsbn0oSWgpO3loKEFoKTt2YXIgVGg9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbihlLG4pe3ZvaWQgMD09PW4mJihuPS4xKTt2YXIgcj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIHIubGVhcm5pbmdSYXRlPWUsci5pbml0aWFsQWNjdW11bGF0b3JWYWx1ZT1uLHIuYWNjdW11bGF0ZWRHcmFkcz17fSxyfXJldHVybiBlKG4sdCksbi5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPWZ1bmN0aW9uKG4pe3ZhciBvPUR0LnJlZ2lzdGVyZWRWYXJpYWJsZXNbbl07aWYobnVsbD09ci5hY2N1bXVsYXRlZEdyYWRzW25dKXtGZShmdW5jdGlvbigpe2UuYWNjdW11bGF0ZWRHcmFkc1tuXT1IbihvLnNoYXBlLGUuaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWUpLnZhcmlhYmxlKCExKX0pfXZhciBhPXRbbl0saT1yLmFjY3VtdWxhdGVkR3JhZHNbbl07RmUoZnVuY3Rpb24oKXt2YXIgdD1pLmFkZChhLnNxdWFyZSgpKTtlLmFjY3VtdWxhdGVkR3JhZHNbbl0uYXNzaWduKHQpO3ZhciByPWEuZGl2KHQuYWRkKER0LmJhY2tlbmQuZXBzaWxvbigpKS5zcXJ0KCkpLm11bCgtZS5sZWFybmluZ1JhdGUpLmFkZChvKTtvLmFzc2lnbihyKX0pfSxyPXRoaXM7Zm9yKHZhciBvIGluIHQpbihvKX0sbi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3ZhciB0PXRoaXM7bnVsbCE9dGhpcy5hY2N1bXVsYXRlZEdyYWRzJiZPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkR3JhZHMpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQuYWNjdW11bGF0ZWRHcmFkc1tlXS5kaXNwb3NlKCl9KX0sbi5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxpbml0aWFsQWNjdW11bGF0b3JWYWx1ZTp0aGlzLmluaXRpYWxBY2N1bXVsYXRvclZhbHVlfX0sbi5mcm9tQ29uZmlnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyB0KGUubGVhcm5pbmdSYXRlLGUuaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWUpfSxuLmNsYXNzTmFtZT1cIkFkYWdyYWRPcHRpbWl6ZXJcIixufShJaCk7eWgoVGgpO3ZhciBEaD1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKGUsbixyLG8pe3ZvaWQgMD09PW8mJihvPW51bGwpO3ZhciBhPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gYS5sZWFybmluZ1JhdGU9ZSxhLmJldGExPW4sYS5iZXRhMj1yLGEuZXBzaWxvbj1vLGEuYWNjdW11bGF0ZWRGaXJzdE1vbWVudD17fSxhLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50PXt9LEZlKGZ1bmN0aW9uKCl7YS5hY2NCZXRhMT1CbihuKS52YXJpYWJsZSgpLGEuYWNjQmV0YTI9Qm4ocikudmFyaWFibGUoKX0pLG51bGw9PW8mJihhLmVwc2lsb249RHQuYmFja2VuZC5lcHNpbG9uKCkpLGF9cmV0dXJuIGUobix0KSxuLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO0ZlKGZ1bmN0aW9uKCl7dmFyIG49bGwoMSxlLmFjY0JldGExKSxyPWxsKDEsZS5hY2NCZXRhMik7Zm9yKHZhciBvIGluIHQpe3ZhciBhPUR0LnJlZ2lzdGVyZWRWYXJpYWJsZXNbb107aWYobnVsbD09ZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W29dKXt2YXIgaT0hMTtlLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbb109WG4oYSkudmFyaWFibGUoaSl9aWYobnVsbD09ZS5hY2N1bXVsYXRlZFNlY29uZE1vbWVudFtvXSl7aT0hMTtlLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50W29dPVhuKGEpLnZhcmlhYmxlKGkpfXZhciBzPXRbb10sdT1lLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbb10sbD1lLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50W29dLGM9dS5tdWwoZS5iZXRhMSkuYWRkKHMubXVsKDEtZS5iZXRhMSkpLGg9bC5tdWwoZS5iZXRhMikuYWRkKHMuc3F1YXJlKCkubXVsKDEtZS5iZXRhMikpLHA9Yy5kaXYobiksZj1oLmRpdihyKTtlLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbb10uYXNzaWduKGMpLGUuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRbb10uYXNzaWduKGgpO3ZhciBkPXAuZGl2KGYuc3FydCgpLmFkZChlLmVwc2lsb24pKS5tdWwoLWUubGVhcm5pbmdSYXRlKS5hZGQoYSk7YS5hc3NpZ24oZCl9ZS5hY2NCZXRhMS5hc3NpZ24oZS5hY2NCZXRhMS5tdWwoZS5iZXRhMSkpLGUuYWNjQmV0YTIuYXNzaWduKGUuYWNjQmV0YTIubXVsKGUuYmV0YTIpKX0pfSxuLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLmFjY0JldGExLmRpc3Bvc2UoKSx0aGlzLmFjY0JldGEyLmRpc3Bvc2UoKSxudWxsIT10aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQmJk9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudCkuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdC5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W2VdLmRpc3Bvc2UoKX0pLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnQmJk9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnQpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRbZV0uZGlzcG9zZSgpfSl9LG4ucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGUsYmV0YTE6dGhpcy5iZXRhMSxiZXRhMjp0aGlzLmJldGEyLGVwc2lsb246dGhpcy5lcHNpbG9ufX0sbi5mcm9tQ29uZmlnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyB0KGUubGVhcm5pbmdSYXRlLGUuYmV0YTEsZS5iZXRhMixlLmVwc2lsb24pfSxuLmNsYXNzTmFtZT1cIkFkYW1PcHRpbWl6ZXJcIixufShJaCk7eWgoRGgpO3ZhciBPaD1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKGUsbixyLG8sYSl7dm9pZCAwPT09byYmKG89bnVsbCksdm9pZCAwPT09YSYmKGE9MCk7dmFyIGk9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBpLmxlYXJuaW5nUmF0ZT1lLGkuYmV0YTE9bixpLmJldGEyPXIsaS5lcHNpbG9uPW8saS5kZWNheT1hLGkuYWNjdW11bGF0ZWRGaXJzdE1vbWVudD17fSxpLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtPXt9LEZlKGZ1bmN0aW9uKCl7aS5pdGVyYXRpb249Qm4oMCkudmFyaWFibGUoKSxpLmFjY0JldGExPUJuKG4pLnZhcmlhYmxlKCl9KSxudWxsPT1vJiYoaS5lcHNpbG9uPUR0LmJhY2tlbmQuZXBzaWxvbigpKSxpfXJldHVybiBlKG4sdCksbi5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztGZShmdW5jdGlvbigpe3ZhciBuPWxsKDEsZS5hY2NCZXRhMSkscj1LdSgtZS5sZWFybmluZ1JhdGUsZS5pdGVyYXRpb24ubXVsKGUuZGVjYXkpLmFkZCgxKSk7Zm9yKHZhciBvIGluIHQpe3ZhciBhPUR0LnJlZ2lzdGVyZWRWYXJpYWJsZXNbb107aWYobnVsbD09ZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W29dKXt2YXIgaT0hMTtlLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbb109WG4oYSkudmFyaWFibGUoaSl9aWYobnVsbD09ZS5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybVtvXSl7aT0hMTtlLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtW29dPVhuKGEpLnZhcmlhYmxlKGkpfXZhciBzPXRbb10sdT1lLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbb10sbD1lLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtW29dLGM9dS5tdWwoZS5iZXRhMSkuYWRkKHMubXVsKDEtZS5iZXRhMSkpLGg9bC5tdWwoZS5iZXRhMikscD1zLmFicygpLGY9aC5tYXhpbXVtKHApO2UuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFtvXS5hc3NpZ24oYyksZS5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybVtvXS5hc3NpZ24oZik7dmFyIGQ9ci5kaXYobikubXVsKGMuZGl2KGYuYWRkKGUuZXBzaWxvbikpKS5hZGQoYSk7YS5hc3NpZ24oZCl9ZS5pdGVyYXRpb24uYXNzaWduKGUuaXRlcmF0aW9uLmFkZCgxKSksZS5hY2NCZXRhMS5hc3NpZ24oZS5hY2NCZXRhMS5tdWwoZS5iZXRhMSkpfSl9LG4ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuYWNjQmV0YTEuZGlzcG9zZSgpLHRoaXMuaXRlcmF0aW9uLmRpc3Bvc2UoKSxudWxsIT10aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQmJk9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudCkuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdC5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W2VdLmRpc3Bvc2UoKX0pLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm0mJk9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm0pLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bZV0uZGlzcG9zZSgpfSl9LG4ucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGUsYmV0YTE6dGhpcy5iZXRhMSxiZXRhMjp0aGlzLmJldGEyLGVwc2lsb246dGhpcy5lcHNpbG9uLGRlY2F5OnRoaXMuZGVjYXl9fSxuLmZyb21Db25maWc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IHQoZS5sZWFybmluZ1JhdGUsZS5iZXRhMSxlLmJldGEyLGUuZXBzaWxvbixlLmRlY2F5KX0sbi5jbGFzc05hbWU9XCJBZGFtYXhPcHRpbWl6ZXJcIixufShJaCk7eWgoT2gpO3ZhciBfaD1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKGUpe3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5sZWFybmluZ1JhdGU9ZSxuLnNldExlYXJuaW5nUmF0ZShlKSxufXJldHVybiBlKG4sdCksbi5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztPYmplY3Qua2V5cyh0KS5mb3JFYWNoKGZ1bmN0aW9uKG4pe3ZhciByPXRbbl0sbz1EdC5yZWdpc3RlcmVkVmFyaWFibGVzW25dO0ZlKGZ1bmN0aW9uKCl7dmFyIHQ9ZS5jLm11bChyKS5hZGQobyk7by5hc3NpZ24odCl9KX0pfSxuLnByb3RvdHlwZS5zZXRMZWFybmluZ1JhdGU9ZnVuY3Rpb24odCl7dGhpcy5sZWFybmluZ1JhdGU9dCxudWxsIT10aGlzLmMmJnRoaXMuYy5kaXNwb3NlKCksdGhpcy5jPVBlKEJuKC10KSl9LG4ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLmMuZGlzcG9zZSgpfSxuLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlfX0sbi5mcm9tQ29uZmlnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyB0KGUubGVhcm5pbmdSYXRlKX0sbi5jbGFzc05hbWU9XCJTR0RPcHRpbWl6ZXJcIixufShJaCk7eWgoX2gpO3ZhciBNaD1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKGUsbixyKXt2b2lkIDA9PT1yJiYocj0hMSk7dmFyIG89dC5jYWxsKHRoaXMsZSl8fHRoaXM7cmV0dXJuIG8ubGVhcm5pbmdSYXRlPWUsby5tb21lbnR1bT1uLG8udXNlTmVzdGVyb3Y9cixvLm09Qm4oby5tb21lbnR1bSksby5hY2N1bXVsYXRpb25zPXt9LG99cmV0dXJuIGUobix0KSxuLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLG49ZnVuY3Rpb24obil7dmFyIG89RHQucmVnaXN0ZXJlZFZhcmlhYmxlc1tuXTtpZihudWxsPT1yLmFjY3VtdWxhdGlvbnNbbl0pe0ZlKGZ1bmN0aW9uKCl7ZS5hY2N1bXVsYXRpb25zW25dPVhuKG8pLnZhcmlhYmxlKCExKX0pfXZhciBhPXIuYWNjdW11bGF0aW9uc1tuXSxpPXRbbl07RmUoZnVuY3Rpb24oKXt2YXIgdCxyPWUubS5tdWwoYSkuYWRkKGkpO3Q9ZS51c2VOZXN0ZXJvdj9lLmMubXVsKGkuYWRkKHIubXVsKGUubSkpKS5hZGQobyk6ZS5jLm11bChyKS5hZGQobyksZS5hY2N1bXVsYXRpb25zW25dLmFzc2lnbihyKSxvLmFzc2lnbih0KX0pfSxyPXRoaXM7Zm9yKHZhciBvIGluIHQpbihvKX0sbi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe2lmKHQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKSx0aGlzLm0uZGlzcG9zZSgpLG51bGwhPXRoaXMuYWNjdW11bGF0aW9ucylmb3IodmFyIGUgaW4gdGhpcy5hY2N1bXVsYXRpb25zKXRoaXMuYWNjdW11bGF0aW9uc1tlXS5kaXNwb3NlKCl9LG4ucHJvdG90eXBlLnNldE1vbWVudHVtPWZ1bmN0aW9uKHQpe3RoaXMubW9tZW50dW09dH0sbi5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxtb21lbnR1bTp0aGlzLm1vbWVudHVtLHVzZU5lc3Rlcm92OnRoaXMudXNlTmVzdGVyb3Z9fSxuLmZyb21Db25maWc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IHQoZS5sZWFybmluZ1JhdGUsZS5tb21lbnR1bSxlLnVzZU5lc3Rlcm92KX0sbi5jbGFzc05hbWU9XCJNb21lbnR1bU9wdGltaXplclwiLG59KF9oKTt5aChNaCk7dmFyIEZoPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oZSxuLHIsbyxhKXt2b2lkIDA9PT1uJiYobj0uOSksdm9pZCAwPT09ciYmKHI9MCksdm9pZCAwPT09byYmKG89bnVsbCksdm9pZCAwPT09YSYmKGE9ITEpO3ZhciBpPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gaS5sZWFybmluZ1JhdGU9ZSxpLmRlY2F5PW4saS5tb21lbnR1bT1yLGkuZXBzaWxvbj1vLGkuYWNjdW11bGF0ZWRNZWFuU3F1YXJlcz17fSxpLmFjY3VtdWxhdGVkTWVhbkdyYWRzPXt9LGkuYWNjdW11bGF0ZWRNb21lbnRzPXt9LGkuY2VudGVyZWQ9YSxudWxsPT1vJiYoaS5lcHNpbG9uPUR0LmJhY2tlbmQuZXBzaWxvbigpKSxpfXJldHVybiBlKG4sdCksbi5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPWZ1bmN0aW9uKG4pe3ZhciBvPUR0LnJlZ2lzdGVyZWRWYXJpYWJsZXNbbl07aWYobnVsbD09ci5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW25dKXtGZShmdW5jdGlvbigpe2UuYWNjdW11bGF0ZWRNZWFuU3F1YXJlc1tuXT1YbihvKS52YXJpYWJsZSghMSl9KX1pZihudWxsPT1yLmFjY3VtdWxhdGVkTWVhbkdyYWRzW25dJiZyLmNlbnRlcmVkKXtGZShmdW5jdGlvbigpe2UuYWNjdW11bGF0ZWRNZWFuR3JhZHNbbl09WG4obykudmFyaWFibGUoITEpfSl9aWYobnVsbD09ci5hY2N1bXVsYXRlZE1vbWVudHNbbl0pe0ZlKGZ1bmN0aW9uKCl7ZS5hY2N1bXVsYXRlZE1vbWVudHNbbl09WG4obykudmFyaWFibGUoITEpfSl9dmFyIGE9ci5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW25dLGk9ci5hY2N1bXVsYXRlZE1lYW5HcmFkc1tuXSxzPXIuYWNjdW11bGF0ZWRNb21lbnRzW25dLHU9dFtuXTtGZShmdW5jdGlvbigpe3ZhciB0PWEubXVsKGUuZGVjYXkpLmFkZCh1LnNxdWFyZSgpLm11bCgxLWUuZGVjYXkpKTtpZihlLmNlbnRlcmVkKXt2YXIgcj1pLm11bChlLmRlY2F5KS5hZGQodS5tdWwoMS1lLmRlY2F5KSksbD1zLm11bChlLm1vbWVudHVtKS5hZGQodS5tdWwoZS5sZWFybmluZ1JhdGUpLmRpdih0LnN1YihyLnNxdWFyZSgpLmFkZChlLmVwc2lsb24pKS5zcXJ0KCkpKTtlLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbbl0uYXNzaWduKHQpLGUuYWNjdW11bGF0ZWRNZWFuR3JhZHNbbl0uYXNzaWduKHIpLGUuYWNjdW11bGF0ZWRNb21lbnRzW25dLmFzc2lnbihsKTt2YXIgYz1vLnN1YihsKTtvLmFzc2lnbihjKX1lbHNle3ZhciBoPWEubXVsKGUuZGVjYXkpLmFkZCh1LnNxdWFyZSgpLm11bCgxLWUuZGVjYXkpKTtsPXMubXVsKGUubW9tZW50dW0pLmFkZCh1Lm11bChlLmxlYXJuaW5nUmF0ZSkuZGl2KGguYWRkKGUuZXBzaWxvbikuc3FydCgpKSk7ZS5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW25dLmFzc2lnbihoKSxlLmFjY3VtdWxhdGVkTW9tZW50c1tuXS5hc3NpZ24obCk7Yz1vLnN1YihsKTtvLmFzc2lnbihjKX19KX0scj10aGlzO2Zvcih2YXIgbyBpbiB0KW4obyl9LG4ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO251bGwhPXRoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlcyYmT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0LmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbZV0uZGlzcG9zZSgpfSksbnVsbCE9dGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkcyYmdGhpcy5jZW50ZXJlZCYmT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkcykuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdC5hY2N1bXVsYXRlZE1lYW5HcmFkc1tlXS5kaXNwb3NlKCl9KSxudWxsIT10aGlzLmFjY3VtdWxhdGVkTW9tZW50cyYmT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZE1vbWVudHMpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQuYWNjdW11bGF0ZWRNb21lbnRzW2VdLmRpc3Bvc2UoKX0pfSxuLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLGRlY2F5OnRoaXMuZGVjYXksbW9tZW50dW06dGhpcy5tb21lbnR1bSxlcHNpbG9uOnRoaXMuZXBzaWxvbixjZW50ZXJlZDp0aGlzLmNlbnRlcmVkfX0sbi5mcm9tQ29uZmlnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyB0KGUubGVhcm5pbmdSYXRlLGUuZGVjYXksZS5tb21lbnR1bSxlLmVwc2lsb24sZS5jZW50ZXJlZCl9LG4uY2xhc3NOYW1lPVwiUk1TUHJvcE9wdGltaXplclwiLG59KEloKTt5aChGaCk7dmFyIEJoPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5zZ2Q9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBfaCh0KX0sdC5tb21lbnR1bT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPSExKSxuZXcgTWgodCxlLG4pfSx0LnJtc3Byb3A9ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9LjkpLHZvaWQgMD09PW4mJihuPTApLHZvaWQgMD09PXImJihyPW51bGwpLHZvaWQgMD09PW8mJihvPSExKSxuZXcgRmgodCxlLG4scixvKX0sdC5hZGFtPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB2b2lkIDA9PT10JiYodD0uMDAxKSx2b2lkIDA9PT1lJiYoZT0uOSksdm9pZCAwPT09biYmKG49Ljk5OSksdm9pZCAwPT09ciYmKHI9bnVsbCksbmV3IERoKHQsZSxuLHIpfSx0LmFkYWRlbHRhPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9LjAwMSksdm9pZCAwPT09ZSYmKGU9Ljk1KSx2b2lkIDA9PT1uJiYobj1udWxsKSxuZXcgQWgodCxlLG4pfSx0LmFkYW1heD1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB2b2lkIDA9PT10JiYodD0uMDAyKSx2b2lkIDA9PT1lJiYoZT0uOSksdm9pZCAwPT09biYmKG49Ljk5OSksdm9pZCAwPT09ciYmKHI9bnVsbCksdm9pZCAwPT09byYmKG89MCksbmV3IE9oKHQsZSxuLHIsbyl9LHQuYWRhZ3JhZD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0uMSksbmV3IFRoKHQsZSl9LHR9KCksUGg9e3NnZDpCaC5zZ2QsbW9tZW50dW06QmgubW9tZW50dW0sYWRhZGVsdGE6QmguYWRhZGVsdGEsYWRhZ3JhZDpCaC5hZGFncmFkLHJtc3Byb3A6Qmgucm1zcHJvcCxhZGFtYXg6QmguYWRhbWF4LGFkYW06QmguYWRhbX0sTGg9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZT9yZXF1ZXN0QW5pbWF0aW9uRnJhbWU6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNldEltbWVkaWF0ZT9zZXRJbW1lZGlhdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHQoKX07ZnVuY3Rpb24gV2goKXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24odCl7cmV0dXJuIExoKGZ1bmN0aW9uKCl7cmV0dXJuIHQoKX0pfSl9aHQ9bWM7ZXhwb3J0e0FoIGFzIEFkYWRlbHRhT3B0aW1pemVyLFRoIGFzIEFkYWdyYWRPcHRpbWl6ZXIsRGggYXMgQWRhbU9wdGltaXplcixPaCBhcyBBZGFtYXhPcHRpbWl6ZXIsWW4gYXMgRGF0YVN0b3JhZ2UsYSBhcyBFTlYsaSBhcyBFbnZpcm9ubWVudCxRbiBhcyBLZXJuZWxCYWNrZW5kLE1oIGFzIE1vbWVudHVtT3B0aW1pemVyLEloIGFzIE9wdGltaXplcixGaCBhcyBSTVNQcm9wT3B0aW1pemVyLHZ0IGFzIFJhbmsscWwgYXMgUmVkdWN0aW9uLF9oIGFzIFNHRE9wdGltaXplcixmdCBhcyBUZW5zb3IsbHQgYXMgVGVuc29yQnVmZmVyLGR0IGFzIFZhcmlhYmxlLFZpIGFzIGFicyxHaSBhcyBhY29zLHFpIGFzIGFjb3NoLHF1IGFzIGFkZCxIdSBhcyBhZGROLCR1IGFzIGFkZFN0cmljdCxidSBhcyBhbGwsQ3UgYXMgYW55LEV1IGFzIGFyZ01heCxSdSBhcyBhcmdNaW4sSGkgYXMgYXNpbiwkaSBhcyBhc2luaCxqaSBhcyBhdGFuLGp1IGFzIGF0YW4yLEtpIGFzIGF0YW5oLGZ1IGFzIGF2Z1Bvb2wsJGUgYXMgYmFja2VuZCxBbCBhcyBiYXNpY0xTVE1DZWxsLF9zIGFzIGJhdGNoTm9ybSxNcyBhcyBiYXRjaE5vcm0yZCxGcyBhcyBiYXRjaE5vcm0zZCxCcyBhcyBiYXRjaE5vcm00ZCxPcyBhcyBiYXRjaE5vcm1hbGl6YXRpb24sQXMgYXMgYmF0Y2hOb3JtYWxpemF0aW9uMmQsVHMgYXMgYmF0Y2hOb3JtYWxpemF0aW9uM2QsRHMgYXMgYmF0Y2hOb3JtYWxpemF0aW9uNGQsSXIgYXMgYmF0Y2hUb1NwYWNlTkQsdmggYXMgYnJvd3NlcixOciBhcyBidWZmZXIsQXIgYXMgY2FzdCxYaSBhcyBjZWlsLFlpIGFzIGNsaXBCeVZhbHVlLFRyIGFzIGNsb25lLE9uIGFzIGNvbXBsZXgsbHIgYXMgY29uY2F0LGNyIGFzIGNvbmNhdDFkLGhyIGFzIGNvbmNhdDJkLHByIGFzIGNvbmNhdDNkLGZyIGFzIGNvbmNhdDRkLFhzIGFzIGNvbnYxZCxZcyBhcyBjb252MmQsSnMgYXMgY29udjJkRGVyRmlsdGVyLGV1IGFzIGNvbnYyZFRyYW5zcG9zZSxRcyBhcyBjb252M2QsUWkgYXMgY29zLEppIGFzIGNvc2gsRHIgYXMgY3Vtc3VtLGtuIGFzIGN1c3RvbUdyYWQsRGUgYXMgZGVwcmVjYXRpb25XYXJuLE9yIGFzIGRlcHRoVG9TcGFjZSxacyBhcyBkZXB0aHdpc2VDb252MmQsVGUgYXMgZGlzYWJsZURlcHJlY2F0aW9uV2FybmluZ3MsQmUgYXMgZGlzcG9zZSxPZSBhcyBkaXNwb3NlVmFyaWFibGVzLEt1IGFzIGRpdixYdSBhcyBkaXZTdHJpY3QscnUgYXMgZG90LFZsIGFzIGRyb3BvdXQsZ2wgYXMgZWx1LEFlIGFzIGVuYWJsZURlYnVnTW9kZSxJZSBhcyBlbmFibGVQcm9kTW9kZSxsIGFzIGVudmlyb25tZW50LE91IGFzIGVxdWFsLF91IGFzIGVxdWFsU3RyaWN0LFppIGFzIGVyZix0cyBhcyBleHAsX3IgYXMgZXhwYW5kRGltcyxlcyBhcyBleHBtMSxNciBhcyBleWUsRmwgYXMgZmZ0LEhuIGFzIGZpbGwsR2UgYXMgZmluZEJhY2tlbmQscWUgYXMgZmluZEJhY2tlbmRGYWN0b3J5LG5zIGFzIGZsb29yLFl1IGFzIGZsb29yRGl2LHZjIGFzIGZ1c2VkLGtsIGFzIGdhdGhlcix6bCBhcyBnYXRoZXJORCx6ZSBhcyBnZXRCYWNrZW5kLENuIGFzIGdyYWQsRW4gYXMgZ3JhZHMsTXUgYXMgZ3JlYXRlcixGdSBhcyBncmVhdGVyRXF1YWwsQnUgYXMgZ3JlYXRlckVxdWFsU3RyaWN0LFB1IGFzIGdyZWF0ZXJTdHJpY3QsJGwgYXMgaGFtbWluZ1dpbmRvdyxIbCBhcyBoYW5uV2luZG93LEJsIGFzIGlmZnQsTW4gYXMgaW1hZyxmYyBhcyBpbWFnZSxoaCBhcyBpbyxMbCBhcyBpcmZmdCxkcyBhcyBpc0Zpbml0ZSxmcyBhcyBpc0luZixwcyBhcyBpc05hTixQZSBhcyBrZWVwLHlsIGFzIGxlYWt5UmVsdSxMdSBhcyBsZXNzLFd1IGFzIGxlc3NFcXVhbCxVdSBhcyBsZXNzRXF1YWxTdHJpY3QsenUgYXMgbGVzc1N0cmljdCxpYyBhcyBsaW5hbGcsJG4gYXMgbGluc3BhY2UsRWwgYXMgbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb24scnMgYXMgbG9nLG9zIGFzIGxvZzFwLGFzIGFzIGxvZ1NpZ21vaWQsRG4gYXMgbG9nU29mdG1heCxTdSBhcyBsb2dTdW1FeHAsaGwgYXMgbG9naWNhbEFuZCxwbCBhcyBsb2dpY2FsTm90LGZsIGFzIGxvZ2ljYWxPcixkbCBhcyBsb2dpY2FsWG9yLG5jIGFzIGxvc3NlcyxudSBhcyBtYXRNdWwsZmggYXMgbWF0aCxOdSBhcyBtYXgscHUgYXMgbWF4UG9vbCxRdSBhcyBtYXhpbXVtLEp1IGFzIG1heGltdW1TdHJpY3Qsa3UgYXMgbWVhbixfZSBhcyBtZW1vcnksSXUgYXMgbWluLFp1IGFzIG1pbmltdW0sdGwgYXMgbWluaW11bVN0cmljdCxlbCBhcyBtb2QsbmwgYXMgbW9kU3RyaWN0LEF1IGFzIG1vbWVudHMsRGwgYXMgbW92aW5nQXZlcmFnZSxybCBhcyBtdWwsb2wgYXMgbXVsU3RyaWN0LFRsIGFzIG11bHRpUk5OQ2VsbCxGciBhcyBtdWx0aW5vbWlhbCxpcyBhcyBuZWcsV2ggYXMgbmV4dEZyYW1lLFJsIGFzIG5vcm0sVnUgYXMgbm90RXF1YWwsR3UgYXMgbm90RXF1YWxTdHJpY3QsQnIgYXMgb25lSG90LEduIGFzIG9uZXMsS24gYXMgb25lc0xpa2UsQW4gYXMgb3Asb3UgYXMgb3V0ZXJQcm9kdWN0LFByIGFzIHBhZCxMciBhcyBwYWQxZCxXciBhcyBwYWQyZCxVciBhcyBwYWQzZCx6ciBhcyBwYWQ0ZCxkdSBhcyBwb29sLGFsIGFzIHBvdyxpbCBhcyBwb3dTdHJpY3QseGwgYXMgcHJlbHUsa3IgYXMgcHJpbnQsRHUgYXMgcHJvZCxNZSBhcyBwcm9maWxlLFZyIGFzIHJhbmQsR3IgYXMgcmFuZG9tTm9ybWFsLHFyIGFzIHJhbmRvbVVuaWZvcm0sam4gYXMgcmFuZ2UsVWUgYXMgcmVhZHksX24gYXMgcmVhbCxzcyBhcyByZWNpcHJvY2FsLEhlIGFzIHJlZ2lzdGVyQmFja2VuZCx3bCBhcyByZWx1LFZlIGFzIHJlbW92ZUJhY2tlbmQsSHIgYXMgcmVzaGFwZSxhdSBhcyByZXZlcnNlLGl1IGFzIHJldmVyc2UxZCxzdSBhcyByZXZlcnNlMmQsdXUgYXMgcmV2ZXJzZTNkLGx1IGFzIHJldmVyc2U0ZCxQbCBhcyByZmZ0LHVzIGFzIHJvdW5kLGxzIGFzIHJzcXJ0LEJuIGFzIHNjYWxhcixNbCBhcyBzY2F0dGVyTkQsYmwgYXMgc2VsdSx0dSBhcyBzZXBhcmFibGVDb252MmQseGggYXMgc2VyaWFsaXphdGlvbixXZSBhcyBzZXRCYWNrZW5kLEpyIGFzIHNldGRpZmYxZEFzeW5jLGNzIGFzIHNpZ21vaWQsaHMgYXMgc2lnbix2cyBhcyBzaW4sbXMgYXMgc2luaCx2dSBhcyBzbGljZSxtdSBhcyBzbGljZTFkLGd1IGFzIHNsaWNlMmQseXUgYXMgc2xpY2UzZCx4dSBhcyBzbGljZTRkLFRuIGFzIHNvZnRtYXgsZ3MgYXMgc29mdHBsdXMsJHIgYXMgc3BhY2VUb0JhdGNoTkQsVWwgYXMgc3BhcnNlVG9EZW5zZSxXbCBhcyBzcGVjdHJhbCxkciBhcyBzcGxpdCx5cyBhcyBzcXJ0LHhzIGFzIHNxdWFyZSxzbCBhcyBzcXVhcmVkRGlmZmVyZW5jZSx1bCBhcyBzcXVhcmVkRGlmZmVyZW5jZVN0cmljdCxqciBhcyBzcXVlZXplLEtyIGFzIHN0YWNrLHdzIGFzIHN0ZXAsT2wgYXMgc3RyaWRlZFNsaWNlLGxsIGFzIHN1YixjbCBhcyBzdWJTdHJpY3QsVHUgYXMgc3VtLGJzIGFzIHRhbixDcyBhcyB0YW5oLEZuIGFzIHRlbnNvcixQbiBhcyB0ZW5zb3IxZCxMbiBhcyB0ZW5zb3IyZCxXbiBhcyB0ZW5zb3IzZCxVbiBhcyB0ZW5zb3I0ZCx6biBhcyB0ZW5zb3I1ZCxWbiBhcyB0ZW5zb3I2ZCxJdCBhcyB0ZW5zb3JfdXRpbCxTaCBhcyB0ZXN0X3V0aWwsRmUgYXMgdGlkeSxYciBhcyB0aWxlLExlIGFzIHRpbWUsX2wgYXMgdG9wayxQaCBhcyB0cmFpbixDbCBhcyB0cmFuc3Bvc2UsWXIgYXMgdHJ1bmNhdGVkTm9ybWFsLElsIGFzIHVuc29ydGVkU2VnbWVudFN1bSxRciBhcyB1bnN0YWNrLFogYXMgdXRpbCxSbiBhcyB2YWx1ZUFuZEdyYWQsU24gYXMgdmFsdWVBbmRHcmFkcyx3dCBhcyB2YXJpYWJsZSxObiBhcyB2YXJpYWJsZUdyYWRzLE5oIGFzIHZlcnNpb25fY29yZSxraCBhcyB3ZWJnbCx2bCBhcyB3aGVyZSxtbCBhcyB3aGVyZUFzeW5jLHFuIGFzIHplcm9zLFhuIGFzIHplcm9zTGlrZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10Zi1jb3JlLmVzbS5qcy5tYXBcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmltcG9ydHt1dGlsLHRpZHksZGVwcmVjYXRpb25XYXJuLFRlbnNvcixzdGFjayx0ZW5zb3IsRU5WLGNsb25lLGRpc3Bvc2UsdGVuc29yX3V0aWwsdGVuc29yMWQsdGVuc29yMmQsYnJvd3NlcixpbWFnZX1mcm9tXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIjt2YXIgZXh0ZW5kU3RhdGljcz1mdW5jdGlvbih0LGUpe3JldHVybihleHRlbmRTdGF0aWNzPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWV9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgciBpbiBlKWUuaGFzT3duUHJvcGVydHkocikmJih0W3JdPWVbcl0pfSkodCxlKX07ZnVuY3Rpb24gX19leHRlbmRzKHQsZSl7ZnVuY3Rpb24gcigpe3RoaXMuY29uc3RydWN0b3I9dH1leHRlbmRTdGF0aWNzKHQsZSksdC5wcm90b3R5cGU9bnVsbD09PWU/T2JqZWN0LmNyZWF0ZShlKTooci5wcm90b3R5cGU9ZS5wcm90b3R5cGUsbmV3IHIpfWZ1bmN0aW9uIF9fYXdhaXRlcih0LGUscixuKXtyZXR1cm4gbmV3KHJ8fChyPVByb21pc2UpKShmdW5jdGlvbihpLG8pe2Z1bmN0aW9uIGEodCl7dHJ5e3Mobi5uZXh0KHQpKX1jYXRjaCh0KXtvKHQpfX1mdW5jdGlvbiB1KHQpe3RyeXtzKG4udGhyb3codCkpfWNhdGNoKHQpe28odCl9fWZ1bmN0aW9uIHModCl7dC5kb25lP2kodC52YWx1ZSk6bmV3IHIoZnVuY3Rpb24oZSl7ZSh0LnZhbHVlKX0pLnRoZW4oYSx1KX1zKChuPW4uYXBwbHkodCxlfHxbXSkpLm5leHQoKSl9KX1mdW5jdGlvbiBfX2dlbmVyYXRvcih0LGUpe3ZhciByLG4saSxvLGE9e2xhYmVsOjAsc2VudDpmdW5jdGlvbigpe2lmKDEmaVswXSl0aHJvdyBpWzFdO3JldHVybiBpWzFdfSx0cnlzOltdLG9wczpbXX07cmV0dXJuIG89e25leHQ6dSgwKSx0aHJvdzp1KDEpLHJldHVybjp1KDIpfSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihvW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLG87ZnVuY3Rpb24gdShvKXtyZXR1cm4gZnVuY3Rpb24odSl7cmV0dXJuIGZ1bmN0aW9uKG8pe2lmKHIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7Zm9yKDthOyl0cnl7aWYocj0xLG4mJihpPTImb1swXT9uLnJldHVybjpvWzBdP24udGhyb3d8fCgoaT1uLnJldHVybikmJmkuY2FsbChuKSwwKTpuLm5leHQpJiYhKGk9aS5jYWxsKG4sb1sxXSkpLmRvbmUpcmV0dXJuIGk7c3dpdGNoKG49MCxpJiYobz1bMiZvWzBdLGkudmFsdWVdKSxvWzBdKXtjYXNlIDA6Y2FzZSAxOmk9bzticmVhaztjYXNlIDQ6cmV0dXJuIGEubGFiZWwrKyx7dmFsdWU6b1sxXSxkb25lOiExfTtjYXNlIDU6YS5sYWJlbCsrLG49b1sxXSxvPVswXTtjb250aW51ZTtjYXNlIDc6bz1hLm9wcy5wb3AoKSxhLnRyeXMucG9wKCk7Y29udGludWU7ZGVmYXVsdDppZighKGk9KGk9YS50cnlzKS5sZW5ndGg+MCYmaVtpLmxlbmd0aC0xXSkmJig2PT09b1swXXx8Mj09PW9bMF0pKXthPTA7Y29udGludWV9aWYoMz09PW9bMF0mJighaXx8b1sxXT5pWzBdJiZvWzFdPGlbM10pKXthLmxhYmVsPW9bMV07YnJlYWt9aWYoNj09PW9bMF0mJmEubGFiZWw8aVsxXSl7YS5sYWJlbD1pWzFdLGk9bzticmVha31pZihpJiZhLmxhYmVsPGlbMl0pe2EubGFiZWw9aVsyXSxhLm9wcy5wdXNoKG8pO2JyZWFrfWlbMl0mJmEub3BzLnBvcCgpLGEudHJ5cy5wb3AoKTtjb250aW51ZX1vPWUuY2FsbCh0LGEpfWNhdGNoKHQpe289WzYsdF0sbj0wfWZpbmFsbHl7cj1pPTB9aWYoNSZvWzBdKXRocm93IG9bMV07cmV0dXJue3ZhbHVlOm9bMF0/b1sxXTp2b2lkIDAsZG9uZTohMH19KFtvLHVdKX19fXZhciBjb21tb25qc0dsb2JhbD1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnt9O2Z1bmN0aW9uIHVud3JhcEV4cG9ydHModCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZSYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsXCJkZWZhdWx0XCIpP3QuZGVmYXVsdDp0fWZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKHQsZSl7cmV0dXJuIHQoZT17ZXhwb3J0czp7fX0sZS5leHBvcnRzKSxlLmV4cG9ydHN9dmFyIGFsZWE9Y3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxyKXtmdW5jdGlvbiBuKHQsZSl7cmV0dXJuIGUuYz10LmMsZS5zMD10LnMwLGUuczE9dC5zMSxlLnMyPXQuczIsZX1mdW5jdGlvbiBpKHQsZSl7dmFyIHI9bmV3IGZ1bmN0aW9uKHQpe3ZhciBlLHI9dGhpcyxuPShlPTQwMjI4NzExOTcsZnVuY3Rpb24odCl7dD10LnRvU3RyaW5nKCk7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPS4wMjUxOTYwMzI4MjQxNjkzOCooZSs9dC5jaGFyQ29kZUF0KHIpKTtuLT1lPW4+Pj4wLGU9KG4qPWUpPj4+MCxlKz00Mjk0OTY3Mjk2KihuLT1lKX1yZXR1cm4gMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMCooZT4+PjApfSk7ci5uZXh0PWZ1bmN0aW9uKCl7dmFyIHQ9MjA5MTYzOSpyLnMwKzIuMzI4MzA2NDM2NTM4Njk2M2UtMTAqci5jO3JldHVybiByLnMwPXIuczEsci5zMT1yLnMyLHIuczI9dC0oci5jPTB8dCl9LHIuYz0xLHIuczA9bihcIiBcIiksci5zMT1uKFwiIFwiKSxyLnMyPW4oXCIgXCIpLHIuczAtPW4odCksci5zMDwwJiYoci5zMCs9MSksci5zMS09bih0KSxyLnMxPDAmJihyLnMxKz0xKSxyLnMyLT1uKHQpLHIuczI8MCYmKHIuczIrPTEpLG49bnVsbH0odCksaT1lJiZlLnN0YXRlLG89ci5uZXh0O3JldHVybiBvLmludDMyPWZ1bmN0aW9uKCl7cmV0dXJuIDQyOTQ5NjcyOTYqci5uZXh0KCl8MH0sby5kb3VibGU9ZnVuY3Rpb24oKXtyZXR1cm4gbygpKzEuMTEwMjIzMDI0NjI1MTU2NWUtMTYqKDIwOTcxNTIqbygpfDApfSxvLnF1aWNrPW8saSYmKFwib2JqZWN0XCI9PXR5cGVvZiBpJiZuKGksciksby5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBuKHIse30pfSksb31lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPWk6ciYmci5hbWQ/cihmdW5jdGlvbigpe3JldHVybiBpfSk6dGhpcy5hbGVhPWl9KDAsdCwhMSl9KSx4b3IxMjg9Y3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxyKXtmdW5jdGlvbiBuKHQsZSl7cmV0dXJuIGUueD10LngsZS55PXQueSxlLno9dC56LGUudz10LncsZX1mdW5jdGlvbiBpKHQsZSl7dmFyIHI9bmV3IGZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMscj1cIlwiO2UueD0wLGUueT0wLGUuej0wLGUudz0wLGUubmV4dD1mdW5jdGlvbigpe3ZhciB0PWUueF5lLng8PDExO3JldHVybiBlLng9ZS55LGUueT1lLnosZS56PWUudyxlLndePWUudz4+PjE5XnRedD4+Pjh9LHQ9PT0oMHx0KT9lLng9dDpyKz10O2Zvcih2YXIgbj0wO248ci5sZW5ndGgrNjQ7bisrKWUueF49MHxyLmNoYXJDb2RlQXQobiksZS5uZXh0KCl9KHQpLGk9ZSYmZS5zdGF0ZSxvPWZ1bmN0aW9uKCl7cmV0dXJuKHIubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIG8uZG91YmxlPWZ1bmN0aW9uKCl7ZG97dmFyIHQ9KChyLm5leHQoKT4+PjExKSsoci5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2KS8oMTw8MjEpfXdoaWxlKDA9PT10KTtyZXR1cm4gdH0sby5pbnQzMj1yLm5leHQsby5xdWljaz1vLGkmJihcIm9iamVjdFwiPT10eXBlb2YgaSYmbihpLHIpLG8uc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbihyLHt9KX0pLG99ZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1pOnImJnIuYW1kP3IoZnVuY3Rpb24oKXtyZXR1cm4gaX0pOnRoaXMueG9yMTI4PWl9KDAsdCwhMSl9KSx4b3J3b3c9Y3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxyKXtmdW5jdGlvbiBuKHQsZSl7cmV0dXJuIGUueD10LngsZS55PXQueSxlLno9dC56LGUudz10LncsZS52PXQudixlLmQ9dC5kLGV9ZnVuY3Rpb24gaSh0LGUpe3ZhciByPW5ldyBmdW5jdGlvbih0KXt2YXIgZT10aGlzLHI9XCJcIjtlLm5leHQ9ZnVuY3Rpb24oKXt2YXIgdD1lLnheZS54Pj4+MjtyZXR1cm4gZS54PWUueSxlLnk9ZS56LGUuej1lLncsZS53PWUudiwoZS5kPWUuZCszNjI0Mzd8MCkrKGUudj1lLnZeZS52PDw0XnRedDw8MSl8MH0sZS54PTAsZS55PTAsZS56PTAsZS53PTAsZS52PTAsdD09PSgwfHQpP2UueD10OnIrPXQ7Zm9yKHZhciBuPTA7bjxyLmxlbmd0aCs2NDtuKyspZS54Xj0wfHIuY2hhckNvZGVBdChuKSxuPT1yLmxlbmd0aCYmKGUuZD1lLng8PDEwXmUueD4+PjQpLGUubmV4dCgpfSh0KSxpPWUmJmUuc3RhdGUsbz1mdW5jdGlvbigpe3JldHVybihyLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBvLmRvdWJsZT1mdW5jdGlvbigpe2Rve3ZhciB0PSgoci5uZXh0KCk+Pj4xMSkrKHIubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvKDE8PDIxKX13aGlsZSgwPT09dCk7cmV0dXJuIHR9LG8uaW50MzI9ci5uZXh0LG8ucXVpY2s9byxpJiYoXCJvYmplY3RcIj09dHlwZW9mIGkmJm4oaSxyKSxvLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG4ocix7fSl9KSxvfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9aTpyJiZyLmFtZD9yKGZ1bmN0aW9uKCl7cmV0dXJuIGl9KTp0aGlzLnhvcndvdz1pfSgwLHQsITEpfSkseG9yc2hpZnQ3PWNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0LGUscil7ZnVuY3Rpb24gbih0LGUpe3JldHVybiBlLng9dC54LnNsaWNlKCksZS5pPXQuaSxlfWZ1bmN0aW9uIGkodCxlKXtudWxsPT10JiYodD0rbmV3IERhdGUpO3ZhciByPW5ldyBmdW5jdGlvbih0KXt2YXIgZT10aGlzO2UubmV4dD1mdW5jdGlvbigpe3ZhciB0LHIsbj1lLngsaT1lLmk7cmV0dXJuIHQ9bltpXSxyPSh0Xj10Pj4+NyledDw8MjQscl49KHQ9bltpKzEmN10pXnQ+Pj4xMCxyXj0odD1uW2krMyY3XSledD4+PjMscl49KHQ9bltpKzQmN10pXnQ8PDcsdD1uW2krNyY3XSxyXj0odF49dDw8MTMpXnQ8PDksbltpXT1yLGUuaT1pKzEmNyxyfSxmdW5jdGlvbih0LGUpe3ZhciByLG49W107aWYoZT09PSgwfGUpKW5bMF09ZTtlbHNlIGZvcihlPVwiXCIrZSxyPTA7cjxlLmxlbmd0aDsrK3Ipbls3JnJdPW5bNyZyXTw8MTVeZS5jaGFyQ29kZUF0KHIpK25bcisxJjddPDwxMztmb3IoO24ubGVuZ3RoPDg7KW4ucHVzaCgwKTtmb3Iocj0wO3I8OCYmMD09PW5bcl07KytyKTtmb3IoOD09cj9uWzddPS0xOm5bcl0sdC54PW4sdC5pPTAscj0yNTY7cj4wOy0tcil0Lm5leHQoKX0oZSx0KX0odCksaT1lJiZlLnN0YXRlLG89ZnVuY3Rpb24oKXtyZXR1cm4oci5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2fTtyZXR1cm4gby5kb3VibGU9ZnVuY3Rpb24oKXtkb3t2YXIgdD0oKHIubmV4dCgpPj4+MTEpKyhyLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYpLygxPDwyMSl9d2hpbGUoMD09PXQpO3JldHVybiB0fSxvLmludDMyPXIubmV4dCxvLnF1aWNrPW8saSYmKGkueCYmbihpLHIpLG8uc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbihyLHt9KX0pLG99ZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1pOnImJnIuYW1kP3IoZnVuY3Rpb24oKXtyZXR1cm4gaX0pOnRoaXMueG9yc2hpZnQ3PWl9KDAsdCwhMSl9KSx4b3I0MDk2PWNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0LGUscil7ZnVuY3Rpb24gbih0LGUpe3JldHVybiBlLmk9dC5pLGUudz10LncsZS5YPXQuWC5zbGljZSgpLGV9ZnVuY3Rpb24gaSh0LGUpe251bGw9PXQmJih0PStuZXcgRGF0ZSk7dmFyIHI9bmV3IGZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7ZS5uZXh0PWZ1bmN0aW9uKCl7dmFyIHQscixuPWUudyxpPWUuWCxvPWUuaTtyZXR1cm4gZS53PW49bisxNjQwNTMxNTI3fDAscj1pW28rMzQmMTI3XSx0PWlbbz1vKzEmMTI3XSxyXj1yPDwxMyx0Xj10PDwxNyxyXj1yPj4+MTUsdF49dD4+PjEyLHI9aVtvXT1yXnQsZS5pPW8scisobl5uPj4+MTYpfDB9LGZ1bmN0aW9uKHQsZSl7dmFyIHIsbixpLG8sYSx1PVtdLHM9MTI4O2ZvcihlPT09KDB8ZSk/KG49ZSxlPW51bGwpOihlKz1cIlxcMFwiLG49MCxzPU1hdGgubWF4KHMsZS5sZW5ndGgpKSxpPTAsbz0tMzI7bzxzOysrbyllJiYobl49ZS5jaGFyQ29kZUF0KChvKzMyKSVlLmxlbmd0aCkpLDA9PT1vJiYoYT1uKSxuXj1uPDwxMCxuXj1uPj4+MTUsbl49bjw8NCxuXj1uPj4+MTMsbz49MCYmKGE9YSsxNjQwNTMxNTI3fDAsaT0wPT0ocj11WzEyNyZvXV49bithKT9pKzE6MCk7Zm9yKGk+PTEyOCYmKHVbMTI3JihlJiZlLmxlbmd0aHx8MCldPS0xKSxpPTEyNyxvPTUxMjtvPjA7LS1vKW49dVtpKzM0JjEyN10scj11W2k9aSsxJjEyN10sbl49bjw8MTMscl49cjw8MTcsbl49bj4+PjE1LHJePXI+Pj4xMix1W2ldPW5ecjt0Lnc9YSx0Llg9dSx0Lmk9aX0oZSx0KX0odCksaT1lJiZlLnN0YXRlLG89ZnVuY3Rpb24oKXtyZXR1cm4oci5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2fTtyZXR1cm4gby5kb3VibGU9ZnVuY3Rpb24oKXtkb3t2YXIgdD0oKHIubmV4dCgpPj4+MTEpKyhyLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYpLygxPDwyMSl9d2hpbGUoMD09PXQpO3JldHVybiB0fSxvLmludDMyPXIubmV4dCxvLnF1aWNrPW8saSYmKGkuWCYmbihpLHIpLG8uc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbihyLHt9KX0pLG99ZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1pOnImJnIuYW1kP3IoZnVuY3Rpb24oKXtyZXR1cm4gaX0pOnRoaXMueG9yNDA5Nj1pfSgwLHQsITEpfSksdHljaGVpPWNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0LGUscil7ZnVuY3Rpb24gbih0LGUpe3JldHVybiBlLmE9dC5hLGUuYj10LmIsZS5jPXQuYyxlLmQ9dC5kLGV9ZnVuY3Rpb24gaSh0LGUpe3ZhciByPW5ldyBmdW5jdGlvbih0KXt2YXIgZT10aGlzLHI9XCJcIjtlLm5leHQ9ZnVuY3Rpb24oKXt2YXIgdD1lLmIscj1lLmMsbj1lLmQsaT1lLmE7cmV0dXJuIHQ9dDw8MjVedD4+PjdecixyPXItbnwwLG49bjw8MjRebj4+PjheaSxpPWktdHwwLGUuYj10PXQ8PDIwXnQ+Pj4xMl5yLGUuYz1yPXItbnwwLGUuZD1uPDwxNl5yPj4+MTZeaSxlLmE9aS10fDB9LGUuYT0wLGUuYj0wLGUuYz0tMTY0MDUzMTUyNyxlLmQ9MTM2NzEzMDU1MSx0PT09TWF0aC5mbG9vcih0KT8oZS5hPXQvNDI5NDk2NzI5NnwwLGUuYj0wfHQpOnIrPXQ7Zm9yKHZhciBuPTA7bjxyLmxlbmd0aCsyMDtuKyspZS5iXj0wfHIuY2hhckNvZGVBdChuKSxlLm5leHQoKX0odCksaT1lJiZlLnN0YXRlLG89ZnVuY3Rpb24oKXtyZXR1cm4oci5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2fTtyZXR1cm4gby5kb3VibGU9ZnVuY3Rpb24oKXtkb3t2YXIgdD0oKHIubmV4dCgpPj4+MTEpKyhyLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYpLygxPDwyMSl9d2hpbGUoMD09PXQpO3JldHVybiB0fSxvLmludDMyPXIubmV4dCxvLnF1aWNrPW8saSYmKFwib2JqZWN0XCI9PXR5cGVvZiBpJiZuKGksciksby5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBuKHIse30pfSksb31lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPWk6ciYmci5hbWQ/cihmdW5jdGlvbigpe3JldHVybiBpfSk6dGhpcy50eWNoZWk9aX0oMCx0LCExKX0pLHNlZWRyYW5kb209Y3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKGUscil7dmFyIG4saT10aGlzLG89MjU2LGE9Nix1PVwicmFuZG9tXCIscz1yLnBvdyhvLGEpLGM9ci5wb3coMiw1MiksbD0yKmMsZj1vLTE7ZnVuY3Rpb24gaCh0LGgsdil7dmFyIHk9W10sXz1kKGZ1bmN0aW9uIHQoZSxyKXt2YXIgbixpPVtdLG89dHlwZW9mIGU7aWYociYmXCJvYmplY3RcIj09bylmb3IobiBpbiBlKXRyeXtpLnB1c2godChlW25dLHItMSkpfWNhdGNoKHQpe31yZXR1cm4gaS5sZW5ndGg/aTpcInN0cmluZ1wiPT1vP2U6ZStcIlxcMFwifSgoaD0xPT1oP3tlbnRyb3B5OiEwfTpofHx7fSkuZW50cm9weT9bdCxtKGUpXTpudWxsPT10P2Z1bmN0aW9uKCl7dHJ5e3ZhciB0O3JldHVybiBuJiYodD1uLnJhbmRvbUJ5dGVzKT90PXQobyk6KHQ9bmV3IFVpbnQ4QXJyYXkobyksKGkuY3J5cHRvfHxpLm1zQ3J5cHRvKS5nZXRSYW5kb21WYWx1ZXModCkpLG0odCl9Y2F0Y2godCl7dmFyIHI9aS5uYXZpZ2F0b3IsYT1yJiZyLnBsdWdpbnM7cmV0dXJuWytuZXcgRGF0ZSxpLGEsaS5zY3JlZW4sbShlKV19fSgpOnQsMykseSksdz1uZXcgZnVuY3Rpb24odCl7dmFyIGUscj10Lmxlbmd0aCxuPXRoaXMsaT0wLGE9bi5pPW4uaj0wLHU9bi5TPVtdO3J8fCh0PVtyKytdKTtmb3IoO2k8bzspdVtpXT1pKys7Zm9yKGk9MDtpPG87aSsrKXVbaV09dVthPWYmYSt0W2klcl0rKGU9dVtpXSldLHVbYV09ZTsobi5nPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxyPTAsaT1uLmksYT1uLmosdT1uLlM7dC0tOyllPXVbaT1mJmkrMV0scj1yKm8rdVtmJih1W2ldPXVbYT1mJmErZV0pKyh1W2FdPWUpXTtyZXR1cm4gbi5pPWksbi5qPWEscn0pKG8pfSh5KSxnPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXcuZyhhKSxlPXMscj0wO3Q8YzspdD0odCtyKSpvLGUqPW8scj13LmcoMSk7Zm9yKDt0Pj1sOyl0Lz0yLGUvPTIscj4+Pj0xO3JldHVybih0K3IpL2V9O3JldHVybiBnLmludDMyPWZ1bmN0aW9uKCl7cmV0dXJuIDB8dy5nKDQpfSxnLnF1aWNrPWZ1bmN0aW9uKCl7cmV0dXJuIHcuZyg0KS80Mjk0OTY3Mjk2fSxnLmRvdWJsZT1nLGQobSh3LlMpLGUpLChoLnBhc3N8fHZ8fGZ1bmN0aW9uKHQsZSxuLGkpe3JldHVybiBpJiYoaS5TJiZwKGksdyksdC5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBwKHcse30pfSksbj8oclt1XT10LGUpOnR9KShnLF8sXCJnbG9iYWxcImluIGg/aC5nbG9iYWw6dGhpcz09cixoLnN0YXRlKX1mdW5jdGlvbiBwKHQsZSl7cmV0dXJuIGUuaT10LmksZS5qPXQuaixlLlM9dC5TLnNsaWNlKCksZX1mdW5jdGlvbiBkKHQsZSl7Zm9yKHZhciByLG49dCtcIlwiLGk9MDtpPG4ubGVuZ3RoOyllW2YmaV09ZiYocl49MTkqZVtmJmldKStuLmNoYXJDb2RlQXQoaSsrKTtyZXR1cm4gbShlKX1mdW5jdGlvbiBtKHQpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KDAsdCl9aWYocltcInNlZWRcIit1XT1oLGQoci5yYW5kb20oKSxlKSx0LmV4cG9ydHMpe3QuZXhwb3J0cz1oO3RyeXtuPXJlcXVpcmUoXCJjcnlwdG9cIil9Y2F0Y2godCl7fX1lbHNlIDB9KFtdLE1hdGgpfSk7c2VlZHJhbmRvbS5hbGVhPWFsZWEsc2VlZHJhbmRvbS54b3IxMjg9eG9yMTI4LHNlZWRyYW5kb20ueG9yd293PXhvcndvdyxzZWVkcmFuZG9tLnhvcnNoaWZ0Nz14b3JzaGlmdDcsc2VlZHJhbmRvbS54b3I0MDk2PXhvcjQwOTYsc2VlZHJhbmRvbS50eWNoZWk9dHljaGVpO3ZhciBzZWVkcmFuZG9tJDE9c2VlZHJhbmRvbSxzZWVkcmFuZG9tXzE9c2VlZHJhbmRvbSQxLmFsZWE7ZnVuY3Rpb24gZGVlcE1hcEludGVybmFsKHQsZSxyLG4pe2lmKHZvaWQgMD09PXImJihyPW5ldyBNYXApLHZvaWQgMD09PW4mJihuPW5ldyBTZXQpLG51bGw9PXQpcmV0dXJuIG51bGw7aWYobi5oYXModCkpdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VsYXIgcmVmZXJlbmNlcyBhcmUgbm90IHN1cHBvcnRlZC5cIik7aWYoci5oYXModCkpcmV0dXJuIHIuZ2V0KHQpO3ZhciBpPWUodCk7aWYoaS5yZWN1cnNlJiZudWxsIT09aS52YWx1ZSl0aHJvdyBuZXcgRXJyb3IoXCJBIGRlZXAgbWFwIGZ1bmN0aW9uIG1heSBub3QgcmV0dXJuIGJvdGggYSB2YWx1ZSBhbmQgcmVjdXJzZT10cnVlLlwiKTtpZihpLnJlY3Vyc2Upe2lmKGlzSXRlcmFibGUodCkpe3ZhciBvPUFycmF5LmlzQXJyYXkodCk/W106e307Zm9yKHZhciBhIGluIG4uYWRkKHQpLHQpe3ZhciB1PWRlZXBNYXBJbnRlcm5hbCh0W2FdLGUscixuKTtvW2FdPXV9cmV0dXJuIG4uZGVsZXRlKHQpLG99dGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcmVjdXJzZSBpbnRvIG5vbi1pdGVyYWJsZSB0eXBlOiBcIit0KX1yZXR1cm4gci5zZXQodCxpLnZhbHVlKSxpLnZhbHVlfWZ1bmN0aW9uIGRlZXBaaXAodCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9emlwVG9MaXN0KSxkZWVwWmlwSW50ZXJuYWwodCxlKX1mdW5jdGlvbiBkZWVwWmlwSW50ZXJuYWwodCxlLHIpe3ZvaWQgMD09PXImJihyPW5ldyBTZXQpO3ZhciBuPXRbMF07aWYoci5oYXMobikpdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VsYXIgcmVmZXJlbmNlcyBhcmUgbm90IHN1cHBvcnRlZC5cIik7dmFyIGk9ZSh0KTtpZihpLnJlY3Vyc2UmJm51bGwhPT1pLnZhbHVlKXRocm93IG5ldyBFcnJvcihcIkEgZGVlcCB6aXAgZnVuY3Rpb24gbWF5IG5vdCByZXR1cm4gYm90aCBhIHZhbHVlIGFuZCByZWN1cnNlPXRydWUuXCIpO2lmKGkucmVjdXJzZSl7aWYoaXNJdGVyYWJsZShuKSl7dmFyIG89QXJyYXkuaXNBcnJheShuKT9bXTp7fTtyLmFkZChuKTt2YXIgYT1mdW5jdGlvbihuKXt2YXIgaT1kZWVwWmlwSW50ZXJuYWwodC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHRbbl19KSxlLHIpO29bbl09aX07Zm9yKHZhciB1IGluIG4pYSh1KTtyZXR1cm4gci5kZWxldGUobiksb310aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCByZWN1cnNlIGludG8gbm9uLWl0ZXJhYmxlIHR5cGU6IFwiK24pfXJldHVybiBpLnZhbHVlfWZ1bmN0aW9uIHppcFRvTGlzdCh0KXtyZXR1cm4gbnVsbD09PXQ/bnVsbDppc0l0ZXJhYmxlKHRbMF0pP3t2YWx1ZTpudWxsLHJlY3Vyc2U6ITB9Ont2YWx1ZTp0LHJlY3Vyc2U6ITF9fWZ1bmN0aW9uIGRlZXBNYXBBbmRBd2FpdEFsbCh0LGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHIsbixpLG8sYSx1O3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHMpe3N3aXRjaChzLmxhYmVsKXtjYXNlIDA6cj1uZXcgTWFwLGRlZXBNYXBJbnRlcm5hbCh0LGUsciksbj0wLGk9QXJyYXkuZnJvbShyLmtleXMoKSkscy5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gbjxpLmxlbmd0aD8obz1pW25dLChhPXIuZ2V0KG8pKWluc3RhbmNlb2YgUHJvbWlzZT9bNCxhXTpbMywzXSk6WzMsNF07Y2FzZSAyOnU9cy5zZW50KCksci5zZXQobyx1KSxzLmxhYmVsPTM7Y2FzZSAzOnJldHVybiBuKyssWzMsMV07Y2FzZSA0OnJldHVyblsyLGRlZXBNYXBJbnRlcm5hbCh0LGUscildfX0pfSl9ZnVuY3Rpb24gaXNJdGVyYWJsZSh0KXtyZXR1cm4gbnVsbCE9dCYmKEFycmF5LmlzQXJyYXkodCl8fFwib2JqZWN0XCI9PXR5cGVvZiB0JiYhKHQgaW5zdGFuY2VvZiBUZW5zb3IpKX1mdW5jdGlvbiBjYW5UZW5zb3JpZnkodCl7cmV0dXJuIG51bGw9PXR8fGlzUHJpbWl0aXZlKHQpfHxBcnJheS5pc0FycmF5KHQpfHxcIm9iamVjdFwiPT10eXBlb2YgdCYmdCBpbnN0YW5jZW9mIFRlbnNvcnx8dXRpbC5pc1R5cGVkQXJyYXkodCl9ZnVuY3Rpb24gaXNQcmltaXRpdmUodCl7cmV0dXJuIG51bGw9PT10fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdH12YXIgUmluZ0J1ZmZlcj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodGhpcy5jYXBhY2l0eT10LHRoaXMuYmVnaW49MCx0aGlzLmVuZD0wLG51bGw9PXQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBjcmVhdGUgYSByaW5nIGJ1ZmZlciBvZiB1bmtub3duIGNhcGFjaXR5LlwiKTtpZih0PDEpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBjcmVhdGUgcmluZyBidWZmZXIgb2YgY2FwYWNpdHkgPCAxLlwiKTt0aGlzLmRhdGE9bmV3IEFycmF5KHQpLHRoaXMuZG91YmxlZENhcGFjaXR5PTIqdH1yZXR1cm4gdC5wcm90b3R5cGUud3JhcD1mdW5jdGlvbih0KXtmb3IoO3Q8MDspdCs9dGhpcy5kb3VibGVkQ2FwYWNpdHk7cmV0dXJuIHQldGhpcy5kb3VibGVkQ2FwYWNpdHl9LHQucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXtpZih0PDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBnZXQgaXRlbSBhdCBhIG5lZ2F0aXZlIGluZGV4LlwiKTtyZXR1cm4gdGhpcy5kYXRhW3QldGhpcy5jYXBhY2l0eV19LHQucHJvdG90eXBlLnNldD1mdW5jdGlvbih0LGUpe2lmKHQ8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IHNldCBpdGVtIGF0IGEgbmVnYXRpdmUgaW5kZXguXCIpO3RoaXMuZGF0YVt0JXRoaXMuY2FwYWNpdHldPWV9LHQucHJvdG90eXBlLmxlbmd0aD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuZW5kLXRoaXMuYmVnaW47cmV0dXJuIHQ8MCYmKHQ9dGhpcy5kb3VibGVkQ2FwYWNpdHkrdCksdH0sdC5wcm90b3R5cGUuaXNGdWxsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGVuZ3RoKCk9PT10aGlzLmNhcGFjaXR5fSx0LnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLmxlbmd0aCgpfSx0LnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHQpe2lmKHRoaXMuaXNGdWxsKCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSaW5nIGJ1ZmZlciBpcyBmdWxsLlwiKTt0aGlzLnNldCh0aGlzLmVuZCx0KSx0aGlzLmVuZD10aGlzLndyYXAodGhpcy5lbmQrMSl9LHQucHJvdG90eXBlLnB1c2hBbGw9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAscj10O2U8ci5sZW5ndGg7ZSsrKXt2YXIgbj1yW2VdO3RoaXMucHVzaChuKX19LHQucHJvdG90eXBlLnBvcD1mdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiUmluZyBidWZmZXIgaXMgZW1wdHkuXCIpO3RoaXMuZW5kPXRoaXMud3JhcCh0aGlzLmVuZC0xKTt2YXIgdD10aGlzLmdldCh0aGlzLmVuZCk7cmV0dXJuIHRoaXMuc2V0KHRoaXMuZW5kLHZvaWQgMCksdH0sdC5wcm90b3R5cGUudW5zaGlmdD1mdW5jdGlvbih0KXtpZih0aGlzLmlzRnVsbCgpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiUmluZyBidWZmZXIgaXMgZnVsbC5cIik7dGhpcy5iZWdpbj10aGlzLndyYXAodGhpcy5iZWdpbi0xKSx0aGlzLnNldCh0aGlzLmJlZ2luLHQpfSx0LnByb3RvdHlwZS5zaGlmdD1mdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiUmluZyBidWZmZXIgaXMgZW1wdHkuXCIpO3ZhciB0PXRoaXMuZ2V0KHRoaXMuYmVnaW4pO3JldHVybiB0aGlzLnNldCh0aGlzLmJlZ2luLHZvaWQgMCksdGhpcy5iZWdpbj10aGlzLndyYXAodGhpcy5iZWdpbisxKSx0fSx0LnByb3RvdHlwZS5zaHVmZmxlRXhjaXNlPWZ1bmN0aW9uKHQpe2lmKHRoaXMuaXNFbXB0eSgpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiUmluZyBidWZmZXIgaXMgZW1wdHkuXCIpO3ZhciBlPXRoaXMud3JhcCh0aGlzLmJlZ2luK3QpLHI9dGhpcy5nZXQoZSk7cmV0dXJuIHRoaXMuc2V0KGUsdGhpcy5wb3AoKSkscn0sdH0oKSxHcm93aW5nUmluZ0J1ZmZlcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIHQuY2FsbCh0aGlzLGUuSU5JVElBTF9DQVBBQ0lUWSl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLmlzRnVsbD1mdW5jdGlvbigpe3JldHVybiExfSxlLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGUpe3QucHJvdG90eXBlLmlzRnVsbC5jYWxsKHRoaXMpJiZ0aGlzLmV4cGFuZCgpLHQucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLGUpfSxlLnByb3RvdHlwZS51bnNoaWZ0PWZ1bmN0aW9uKGUpe3QucHJvdG90eXBlLmlzRnVsbC5jYWxsKHRoaXMpJiZ0aGlzLmV4cGFuZCgpLHQucHJvdG90eXBlLnVuc2hpZnQuY2FsbCh0aGlzLGUpfSxlLnByb3RvdHlwZS5leHBhbmQ9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9Mip0aGlzLmNhcGFjaXR5LGU9bmV3IEFycmF5KHQpLHI9dGhpcy5sZW5ndGgoKSxuPTA7bjxyO24rKyllW25dPXRoaXMuZ2V0KHRoaXMud3JhcCh0aGlzLmJlZ2luK24pKTt0aGlzLmRhdGE9ZSx0aGlzLmNhcGFjaXR5PXQsdGhpcy5kb3VibGVkQ2FwYWNpdHk9Mip0aGlzLmNhcGFjaXR5LHRoaXMuYmVnaW49MCx0aGlzLmVuZD1yfSxlLklOSVRJQUxfQ0FQQUNJVFk9MzIsZX0oUmluZ0J1ZmZlcik7ZnVuY3Rpb24gaXRlcmF0b3JGcm9tSXRlbXModCl7cmV0dXJuIG5ldyBBcnJheUl0ZXJhdG9yKHQpfWZ1bmN0aW9uIGl0ZXJhdG9yRnJvbUZ1bmN0aW9uKHQpe3JldHVybiBuZXcgRnVuY3Rpb25DYWxsSXRlcmF0b3IodCl9ZnVuY3Rpb24gaXRlcmF0b3JGcm9tQ29uY2F0ZW5hdGVkKHQsZSl7cmV0dXJuIG5ldyBDaGFpbmVkSXRlcmF0b3IodCxlKX1mdW5jdGlvbiBpdGVyYXRvckZyb21aaXBwZWQodCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9WmlwTWlzbWF0Y2hNb2RlLkZBSUwpLG5ldyBaaXBJdGVyYXRvcih0LGUpfXZhciBaaXBNaXNtYXRjaE1vZGUsTGF6eUl0ZXJhdG9yPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybiB0PVtdLFs0LHRoaXMubmV4dCgpXTtjYXNlIDE6ZT1yLnNlbnQoKSxyLmxhYmVsPTI7Y2FzZSAyOnJldHVybiBlLmRvbmU/WzMsNF06KHQucHVzaChlLnZhbHVlKSxbNCx0aGlzLm5leHQoKV0pO2Nhc2UgMzpyZXR1cm4gZT1yLnNlbnQoKSxbMywyXTtjYXNlIDQ6cmV0dXJuWzIsdF19fSl9KX0sdC5wcm90b3R5cGUudG9BcnJheUZvclRlc3Q9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGUscjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOnJldHVybiB0PXRoaXMucHJlZmV0Y2goMTAwKSxlPVtdLFs0LHQubmV4dCgpXTtjYXNlIDE6cj1uLnNlbnQoKSxuLmxhYmVsPTI7Y2FzZSAyOnJldHVybiByLmRvbmU/WzMsNF06KGUucHVzaChyLnZhbHVlKSxbNCx0Lm5leHQoKV0pO2Nhc2UgMzpyZXR1cm4gcj1uLnNlbnQoKSxbMywyXTtjYXNlIDQ6cmV0dXJuWzIsZV19fSl9KX0sdC5wcm90b3R5cGUucmVzb2x2ZUZ1bGx5PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMubmV4dCgpXTtjYXNlIDE6dD1lLnNlbnQoKSxlLmxhYmVsPTI7Y2FzZSAyOnJldHVybiB0LmRvbmU/WzMsNF06WzQsdGhpcy5uZXh0KCldO2Nhc2UgMzpyZXR1cm4gdD1lLnNlbnQoKSxbMywyXTtjYXNlIDQ6cmV0dXJuWzJdfX0pfSl9LHQucHJvdG90eXBlLnJlc29sdmVXaGlsZT1mdW5jdGlvbih0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLHI7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLm5leHQoKV07Y2FzZSAxOmU9bi5zZW50KCkscj10KGUudmFsdWUpLG4ubGFiZWw9MjtjYXNlIDI6cmV0dXJuIGUuZG9uZXx8IXI/WzMsNF06WzQsdGhpcy5uZXh0KCldO2Nhc2UgMzpyZXR1cm4gZT1uLnNlbnQoKSxyPXQoZS52YWx1ZSksWzMsMl07Y2FzZSA0OnJldHVyblsyXX19KX0pfSx0LnByb3RvdHlwZS5oYW5kbGVFcnJvcnM9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBFcnJvckhhbmRsaW5nTGF6eUl0ZXJhdG9yKHRoaXMsdCl9LHQucHJvdG90eXBlLmZpbHRlcj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IEZpbHRlckl0ZXJhdG9yKHRoaXMsdCl9LHQucHJvdG90eXBlLm1hcD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKHRoaXMsdCl9LHQucHJvdG90eXBlLm1hcEFzeW5jPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgQXN5bmNNYXBJdGVyYXRvcih0aGlzLHQpfSx0LnByb3RvdHlwZS5zZXJpYWxNYXBBc3luYz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IEFzeW5jTWFwSXRlcmF0b3IodGhpcyx0KS5zZXJpYWwoKX0sdC5wcm90b3R5cGUuZmxhdG1hcD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IEZsYXRtYXBJdGVyYXRvcih0aGlzLHQpfSx0LnByb3RvdHlwZS5mb3JFYWNoQXN5bmM9ZnVuY3Rpb24odCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm5bMix0aGlzLm1hcCh0KS5yZXNvbHZlRnVsbHkoKV19KX0pfSx0LnByb3RvdHlwZS5zZXJpYWxGb3JFYWNoPWZ1bmN0aW9uKHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuWzIsdGhpcy5zZXJpYWxNYXBBc3luYyh0KS5yZXNvbHZlV2hpbGUoZnVuY3Rpb24odCl7cmV0dXJuITA9PT10fSldfSl9KX0sdC5wcm90b3R5cGUucm93TWFqb3JCYXRjaD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMCksbmV3IFJvd01ham9yQmF0Y2hJdGVyYXRvcih0aGlzLHQsZSl9LHQucHJvdG90eXBlLmNvbHVtbk1ham9yQmF0Y2g9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMCksdm9pZCAwPT09ciYmKHI9emlwVG9MaXN0KSx0aGlzLnJvd01ham9yQmF0Y2godCxlKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGRlZXBaaXAodCxyKX0pfSx0LnByb3RvdHlwZS5jb25jYXRlbmF0ZT1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgQ2hhaW5lZEl0ZXJhdG9yKGl0ZXJhdG9yRnJvbUl0ZW1zKFt0aGlzLHRdKSxlKX0sdC5wcm90b3R5cGUudGFrZT1mdW5jdGlvbih0KXtyZXR1cm4gdDwwfHxudWxsPT10P3RoaXM6bmV3IFRha2VJdGVyYXRvcih0aGlzLHQpfSx0LnByb3RvdHlwZS5za2lwPWZ1bmN0aW9uKHQpe3JldHVybiB0PDB8fG51bGw9PXQ/dGhpczpuZXcgU2tpcEl0ZXJhdG9yKHRoaXMsdCl9LHQucHJvdG90eXBlLnByZWZldGNoPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgUHJlZmV0Y2hJdGVyYXRvcih0aGlzLHQpfSx0LnByb3RvdHlwZS5zaHVmZmxlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyBTaHVmZmxlSXRlcmF0b3IodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5zZXJpYWw9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNlcmlhbEl0ZXJhdG9yKHRoaXMpfSx0fSgpLEFycmF5SXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXt2YXIgcj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIHIuaXRlbXM9ZSxyLnRyYXY9MCxyfXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuXCJBcnJheSBvZiBcIit0aGlzLml0ZW1zLmxlbmd0aCtcIiBpdGVtc1wifSxlLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLnRyYXY+PXRoaXMuaXRlbXMubGVuZ3RoP1syLHt2YWx1ZTpudWxsLGRvbmU6ITB9XToodD10aGlzLml0ZW1zW3RoaXMudHJhdl0sZT10IGluc3RhbmNlb2YgVGVuc29yP2Nsb25lKHQpOnQsdGhpcy50cmF2KyssWzIse3ZhbHVlOmUsZG9uZTohMX1dKX0pfSl9LGV9KExhenlJdGVyYXRvciksRnVuY3Rpb25DYWxsSXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXt2YXIgcj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIHIubmV4dEZuPWUscn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbigpe3JldHVyblwiRnVuY3Rpb24gY2FsbFwifSxlLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXt0cnl7cmV0dXJuWzIsdGhpcy5uZXh0Rm4oKV19Y2F0Y2godCl7dGhyb3cgdC5tZXNzYWdlPVwiRXJyb3IgdGhyb3duIHdoaWxlIGl0ZXJhdGluZyB0aHJvdWdoIGEgZGF0YXNldDogXCIrdC5tZXNzYWdlLHR9cmV0dXJuWzJdfSl9KX0sZX0oTGF6eUl0ZXJhdG9yKSxTZXJpYWxJdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciByPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gci51cHN0cmVhbT1lLHIubGFzdFJlYWQ9UHJvbWlzZS5yZXNvbHZlKHt2YWx1ZTpudWxsLGRvbmU6ITF9KSxyfXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudXBzdHJlYW0uc3VtbWFyeSgpK1wiIC0+IFNlcmlhbFwifSxlLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmxhc3RSZWFkPXRoaXMubGFzdFJlYWQudGhlbihmdW5jdGlvbigpe3JldHVybiB0LnNlcmlhbE5leHQoKX0pLFsyLHRoaXMubGFzdFJlYWRdfSl9KX0sZS5wcm90b3R5cGUuc2VyaWFsTmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuWzIsdGhpcy51cHN0cmVhbS5uZXh0KCldfSl9KX0sZX0oTGF6eUl0ZXJhdG9yKSxTa2lwSXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLHIpe3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi51cHN0cmVhbT1lLG4ubWF4Q291bnQ9cixuLmNvdW50PTAsbi5sYXN0UmVhZD1Qcm9taXNlLnJlc29sdmUoe3ZhbHVlOm51bGwsZG9uZTohMX0pLG59cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51cHN0cmVhbS5zdW1tYXJ5KCkrXCIgLT4gU2tpcFwifSxlLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmxhc3RSZWFkPXRoaXMubGFzdFJlYWQudGhlbihmdW5jdGlvbigpe3JldHVybiB0LnNlcmlhbE5leHQoKX0pLFsyLHRoaXMubGFzdFJlYWRdfSl9KX0sZS5wcm90b3R5cGUuc2VyaWFsTmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm4gdGhpcy5jb3VudCsrPHRoaXMubWF4Q291bnQ/WzQsdGhpcy51cHN0cmVhbS5uZXh0KCldOlszLDJdO2Nhc2UgMTpyZXR1cm4odD1lLnNlbnQoKSkuZG9uZT9bMix0XTooZGlzcG9zZSh0LnZhbHVlKSxbMywwXSk7Y2FzZSAyOnJldHVyblsyLHRoaXMudXBzdHJlYW0ubmV4dCgpXX19KX0pfSxlfShMYXp5SXRlcmF0b3IpLFRha2VJdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscil7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLnVwc3RyZWFtPWUsbi5tYXhDb3VudD1yLG4uY291bnQ9MCxufXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudXBzdHJlYW0uc3VtbWFyeSgpK1wiIC0+IFRha2VcIn0sZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY291bnQrKz49dGhpcy5tYXhDb3VudD9bMix7dmFsdWU6bnVsbCxkb25lOiEwfV06WzIsdGhpcy51cHN0cmVhbS5uZXh0KCldfSl9KX0sZX0oTGF6eUl0ZXJhdG9yKSxSb3dNYWpvckJhdGNoSXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLHIsbil7dm9pZCAwPT09biYmKG49ITApO3ZhciBpPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gaS51cHN0cmVhbT1lLGkuYmF0Y2hTaXplPXIsaS5lbmFibGVTbWFsbExhc3RCYXRjaD1uLGkubGFzdFJlYWQ9UHJvbWlzZS5yZXNvbHZlKHt2YWx1ZTpudWxsLGRvbmU6ITF9KSxpfXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudXBzdHJlYW0uc3VtbWFyeSgpK1wiIC0+IFJvd01ham9yQmF0Y2hcIn0sZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5sYXN0UmVhZD10aGlzLmxhc3RSZWFkLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gdC5zZXJpYWxOZXh0KCl9KSxbMix0aGlzLmxhc3RSZWFkXX0pfSl9LGUucHJvdG90eXBlLnNlcmlhbE5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGU7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDp0PVtdLHIubGFiZWw9MTtjYXNlIDE6cmV0dXJuIHQubGVuZ3RoPHRoaXMuYmF0Y2hTaXplP1s0LHRoaXMudXBzdHJlYW0ubmV4dCgpXTpbMywzXTtjYXNlIDI6cmV0dXJuKGU9ci5zZW50KCkpLmRvbmU/dGhpcy5lbmFibGVTbWFsbExhc3RCYXRjaCYmdC5sZW5ndGg+MD9bMix7dmFsdWU6dCxkb25lOiExfV06WzIse3ZhbHVlOm51bGwsZG9uZTohMH1dOih0LnB1c2goZS52YWx1ZSksWzMsMV0pO2Nhc2UgMzpyZXR1cm5bMix7dmFsdWU6dCxkb25lOiExfV19fSl9KX0sZX0oTGF6eUl0ZXJhdG9yKSxGaWx0ZXJJdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscil7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLnVwc3RyZWFtPWUsbi5wcmVkaWNhdGU9cixuLmxhc3RSZWFkPVByb21pc2UucmVzb2x2ZSh7dmFsdWU6bnVsbCxkb25lOiExfSksbn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVwc3RyZWFtLnN1bW1hcnkoKStcIiAtPiBGaWx0ZXJcIn0sZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5sYXN0UmVhZD10aGlzLmxhc3RSZWFkLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gdC5zZXJpYWxOZXh0KCl9KSxbMix0aGlzLmxhc3RSZWFkXX0pfSl9LGUucHJvdG90eXBlLnNlcmlhbE5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0O3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy51cHN0cmVhbS5uZXh0KCldO2Nhc2UgMTpyZXR1cm4odD1lLnNlbnQoKSkuZG9uZXx8dGhpcy5wcmVkaWNhdGUodC52YWx1ZSk/WzIsdF06KGRpc3Bvc2UodC52YWx1ZSksWzMsMF0pO2Nhc2UgMjpyZXR1cm5bMl19fSl9KX0sZX0oTGF6eUl0ZXJhdG9yKSxNYXBJdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscil7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLnVwc3RyZWFtPWUsbi50cmFuc2Zvcm09cixufXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudXBzdHJlYW0uc3VtbWFyeSgpK1wiIC0+IE1hcFwifSxlLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlLHIsbixpLG8sYTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih1KXtzd2l0Y2godS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMudXBzdHJlYW0ubmV4dCgpXTtjYXNlIDE6aWYoKHQ9dS5zZW50KCkpLmRvbmUpcmV0dXJuWzIse3ZhbHVlOm51bGwsZG9uZTohMH1dO2ZvcihlPXRlbnNvcl91dGlsLmdldFRlbnNvcnNJbkNvbnRhaW5lcih0LnZhbHVlKSxyPXRoaXMudHJhbnNmb3JtKHQudmFsdWUpLG49dGVuc29yX3V0aWwuZ2V0VGVuc29yc0luQ29udGFpbmVyKHIpLGk9MCxvPWU7aTxvLmxlbmd0aDtpKyspYT1vW2ldLHRlbnNvcl91dGlsLmlzVGVuc29ySW5MaXN0KGEsbil8fGEuZGlzcG9zZSgpO3JldHVyblsyLHt2YWx1ZTpyLGRvbmU6ITF9XX19KX0pfSxlfShMYXp5SXRlcmF0b3IpLEVycm9ySGFuZGxpbmdMYXp5SXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLHIpe3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi51cHN0cmVhbT1lLG4uaGFuZGxlcj1yLG4uY291bnQ9MCxuLmxhc3RSZWFkPVByb21pc2UucmVzb2x2ZSh7dmFsdWU6bnVsbCxkb25lOiExfSksbn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVwc3RyZWFtLnN1bW1hcnkoKStcIiAtPiBoYW5kbGVFcnJvcnNcIn0sZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5sYXN0UmVhZD10aGlzLmxhc3RSZWFkLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gdC5zZXJpYWxOZXh0KCl9KSxbMix0aGlzLmxhc3RSZWFkXX0pfSl9LGUucHJvdG90eXBlLnNlcmlhbE5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0O3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6ZS5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gZS50cnlzLnB1c2goWzEsMywsNF0pLFs0LHRoaXMudXBzdHJlYW0ubmV4dCgpXTtjYXNlIDI6cmV0dXJuWzIsZS5zZW50KCldO2Nhc2UgMzpyZXR1cm4gdD1lLnNlbnQoKSx0aGlzLmhhbmRsZXIodCk/WzMsNF06WzIse3ZhbHVlOm51bGwsZG9uZTohMH1dO2Nhc2UgNDpyZXR1cm5bMywwXTtjYXNlIDU6cmV0dXJuWzJdfX0pfSl9LGV9KExhenlJdGVyYXRvciksQXN5bmNNYXBJdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscil7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLnVwc3RyZWFtPWUsbi50cmFuc2Zvcm09cixufXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudXBzdHJlYW0uc3VtbWFyeSgpK1wiIC0+IEFzeW5jTWFwXCJ9LGUucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGUscixuLGksbyxhO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHUpe3N3aXRjaCh1LmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy51cHN0cmVhbS5uZXh0KCldO2Nhc2UgMTpyZXR1cm4odD11LnNlbnQoKSkuZG9uZT9bMix7dmFsdWU6bnVsbCxkb25lOiEwfV06KGU9dGVuc29yX3V0aWwuZ2V0VGVuc29yc0luQ29udGFpbmVyKHQudmFsdWUpLFs0LHRoaXMudHJhbnNmb3JtKHQudmFsdWUpXSk7Y2FzZSAyOmZvcihyPXUuc2VudCgpLG49dGVuc29yX3V0aWwuZ2V0VGVuc29yc0luQ29udGFpbmVyKHIpLGk9MCxvPWU7aTxvLmxlbmd0aDtpKyspYT1vW2ldLHRlbnNvcl91dGlsLmlzVGVuc29ySW5MaXN0KGEsbil8fGEuZGlzcG9zZSgpO3JldHVyblsyLHt2YWx1ZTpyLGRvbmU6ITF9XX19KX0pfSxlfShMYXp5SXRlcmF0b3IpLE9uZVRvTWFueUl0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgZT10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIGUub3V0cHV0UXVldWU9bmV3IEdyb3dpbmdSaW5nQnVmZmVyLGUubGFzdFJlYWQ9UHJvbWlzZS5yZXNvbHZlKHt2YWx1ZTpudWxsLGRvbmU6ITF9KSxlfXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmxhc3RSZWFkPXRoaXMubGFzdFJlYWQudGhlbihmdW5jdGlvbigpe3JldHVybiB0LnNlcmlhbE5leHQoKX0pLFsyLHRoaXMubGFzdFJlYWRdfSl9KX0sZS5wcm90b3R5cGUuc2VyaWFsTmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm4gMCE9PXRoaXMub3V0cHV0UXVldWUubGVuZ3RoKCk/WzMsMl06WzQsdGhpcy5wdW1wKCldO2Nhc2UgMTpyZXR1cm4gdC5zZW50KCk/WzMsMF06WzIse3ZhbHVlOm51bGwsZG9uZTohMH1dO2Nhc2UgMjpyZXR1cm5bMix7dmFsdWU6dGhpcy5vdXRwdXRRdWV1ZS5zaGlmdCgpLGRvbmU6ITF9XX19KX0pfSxlfShMYXp5SXRlcmF0b3IpLEZsYXRtYXBJdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscil7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLnVwc3RyZWFtPWUsbi50cmFuc2Zvcm09cixufXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudXBzdHJlYW0uc3VtbWFyeSgpK1wiIC0+IEZsYXRtYXBcIn0sZS5wcm90b3R5cGUucHVtcD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZSxyLG4saSxvLGE7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odSl7c3dpdGNoKHUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLnVwc3RyZWFtLm5leHQoKV07Y2FzZSAxOmlmKCh0PXUuc2VudCgpKS5kb25lKXJldHVyblsyLCExXTtmb3IoZT10ZW5zb3JfdXRpbC5nZXRUZW5zb3JzSW5Db250YWluZXIodC52YWx1ZSkscj10aGlzLnRyYW5zZm9ybSh0LnZhbHVlKSxuPXRlbnNvcl91dGlsLmdldFRlbnNvcnNJbkNvbnRhaW5lcihyKSx0aGlzLm91dHB1dFF1ZXVlLnB1c2hBbGwociksaT0wLG89ZTtpPG8ubGVuZ3RoO2krKylhPW9baV0sdGVuc29yX3V0aWwuaXNUZW5zb3JJbkxpc3QoYSxuKXx8YS5kaXNwb3NlKCk7cmV0dXJuWzIsITBdfX0pfSl9LGV9KE9uZVRvTWFueUl0ZXJhdG9yKSxDaGFpbmVkSXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLHIpe3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5iYXNlRXJyb3JIYW5kbGVyPXIsbi5sYXN0UmVhZD1udWxsLG4uaXRlcmF0b3I9bnVsbCxuLm1vcmVJdGVyYXRvcnM9ZSxufXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuXCJUT0RPOiBmaWxsIGluIHVwc3RyZWFtIG9mIGNoYWluZWQgc3VtbWFyaWVzIC0+IENoYWluZWRcIn0sZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubGFzdFJlYWQ9dGhpcy5yZWFkRnJvbUNoYWluKHRoaXMubGFzdFJlYWQpLFsyLHRoaXMubGFzdFJlYWRdfSl9KX0sZS5wcm90b3R5cGUucmVhZEZyb21DaGFpbj1mdW5jdGlvbih0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLHI7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0XTtjYXNlIDE6cmV0dXJuIG4uc2VudCgpLG51bGwhPXRoaXMuaXRlcmF0b3I/WzMsM106WzQsdGhpcy5tb3JlSXRlcmF0b3JzLm5leHQoKV07Y2FzZSAyOmlmKChlPW4uc2VudCgpKS5kb25lKXJldHVyblsyLHt2YWx1ZTpudWxsLGRvbmU6ITB9XTt0aGlzLml0ZXJhdG9yPWUudmFsdWUsbnVsbCE9dGhpcy5iYXNlRXJyb3JIYW5kbGVyJiYodGhpcy5pdGVyYXRvcj10aGlzLml0ZXJhdG9yLmhhbmRsZUVycm9ycyh0aGlzLmJhc2VFcnJvckhhbmRsZXIpKSxuLmxhYmVsPTM7Y2FzZSAzOnJldHVybls0LHRoaXMuaXRlcmF0b3IubmV4dCgpXTtjYXNlIDQ6cmV0dXJuKHI9bi5zZW50KCkpLmRvbmU/KHRoaXMuaXRlcmF0b3I9bnVsbCxbMix0aGlzLnJlYWRGcm9tQ2hhaW4odCldKTpbMixyXX19KX0pfSxlfShMYXp5SXRlcmF0b3IpOyFmdW5jdGlvbih0KXt0W3QuRkFJTD0wXT1cIkZBSUxcIix0W3QuU0hPUlRFU1Q9MV09XCJTSE9SVEVTVFwiLHRbdC5MT05HRVNUPTJdPVwiTE9OR0VTVFwifShaaXBNaXNtYXRjaE1vZGV8fChaaXBNaXNtYXRjaE1vZGU9e30pKTt2YXIgWmlwSXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLHIpe3ZvaWQgMD09PXImJihyPVppcE1pc21hdGNoTW9kZS5GQUlMKTt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4uaXRlcmF0b3JzPWUsbi5taXNtYXRjaE1vZGU9cixuLmNvdW50PTAsbi5jdXJyZW50UHJvbWlzZT1udWxsLG59cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oKXtyZXR1cm5cIntUT0RPOiBmaWxsIGluIHVwc3RyZWFtIG9mIHppcCBzdW1tYXJpZXN9IC0+IFppcFwifSxlLnByb3RvdHlwZS5uZXh0U3RhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpe3JldHVybiB0IGluc3RhbmNlb2YgTGF6eUl0ZXJhdG9yP3t2YWx1ZTp0Lm5leHQoKS50aGVuKGZ1bmN0aW9uKHQpe3JldHVybiByKyssdC5kb25lJiZuKyssdC52YWx1ZX0pLHJlY3Vyc2U6ITF9Ont2YWx1ZTpudWxsLHJlY3Vyc2U6ITB9fXZhciByLG4saTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRdO2Nhc2UgMTpyZXR1cm4gby5zZW50KCkscj0wLG49MCxbNCxkZWVwTWFwQW5kQXdhaXRBbGwodGhpcy5pdGVyYXRvcnMsZSldO2Nhc2UgMjppZihpPW8uc2VudCgpLHI9PT1uKXJldHVyblsyLHt2YWx1ZTpudWxsLGRvbmU6ITB9XTtpZihuPjApc3dpdGNoKHRoaXMubWlzbWF0Y2hNb2RlKXtjYXNlIFppcE1pc21hdGNoTW9kZS5GQUlMOnRocm93IG5ldyBFcnJvcihcIlppcHBlZCBzdHJlYW1zIHNob3VsZCBoYXZlIHRoZSBzYW1lIGxlbmd0aC4gTWlzbWF0Y2hlZCBhdCBlbGVtZW50IFwiK3RoaXMuY291bnQrXCIuXCIpO2Nhc2UgWmlwTWlzbWF0Y2hNb2RlLlNIT1JURVNUOnJldHVyblsyLHt2YWx1ZTpudWxsLGRvbmU6ITB9XTtjYXNlIFppcE1pc21hdGNoTW9kZS5MT05HRVNUOn1yZXR1cm4gdGhpcy5jb3VudCsrLFsyLHt2YWx1ZTppLGRvbmU6ITF9XX19KX0pfSxlLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOnJldHVybiB0aGlzLmN1cnJlbnRQcm9taXNlPXRoaXMubmV4dFN0YXRlKHRoaXMuY3VycmVudFByb21pc2UpLFs0LHRoaXMuY3VycmVudFByb21pc2VdO2Nhc2UgMTpyZXR1cm5bMix0LnNlbnQoKV19fSl9KX0sZX0oTGF6eUl0ZXJhdG9yKSxQcmVmZXRjaEl0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyKXt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4udXBzdHJlYW09ZSxuLmJ1ZmZlclNpemU9cixuLmJ1ZmZlcj1uZXcgUmluZ0J1ZmZlcihyKSxufXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudXBzdHJlYW0uc3VtbWFyeSgpK1wiIC0+IFByZWZldGNoXCJ9LGUucHJvdG90eXBlLnJlZmlsbD1mdW5jdGlvbigpe2Zvcig7IXRoaXMuYnVmZmVyLmlzRnVsbCgpOyl7dmFyIHQ9dGhpcy51cHN0cmVhbS5uZXh0KCk7dGhpcy5idWZmZXIucHVzaCh0KX19LGUucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZWZpbGwoKSx0aGlzLmJ1ZmZlci5zaGlmdCgpfSxlfShMYXp5SXRlcmF0b3IpLFNodWZmbGVJdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscixuKXt2YXIgaT10LmNhbGwodGhpcyxlLHIpfHx0aGlzO3JldHVybiBpLnVwc3RyZWFtPWUsaS53aW5kb3dTaXplPXIsaS51cHN0cmVhbUV4aGF1c3RlZD0hMSxpLnJhbmRvbT1zZWVkcmFuZG9tXzEobnx8dXRpbC5ub3coKS50b1N0cmluZygpKSxpLmxhc3RSZWFkPVByb21pc2UucmVzb2x2ZSh7dmFsdWU6bnVsbCxkb25lOiExfSksaX1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5sYXN0UmVhZD10aGlzLmxhc3RSZWFkLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gdC5zZXJpYWxOZXh0KCl9KSxbMix0aGlzLmxhc3RSZWFkXX0pfSl9LGUucHJvdG90eXBlLnJhbmRvbUludD1mdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5mbG9vcih0aGlzLnJhbmRvbSgpKnQpfSxlLnByb3RvdHlwZS5jaG9vc2VJbmRleD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJhbmRvbUludCh0aGlzLmJ1ZmZlci5sZW5ndGgoKSl9LGUucHJvdG90eXBlLnNlcmlhbE5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGU7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDp0aGlzLnVwc3RyZWFtRXhoYXVzdGVkfHx0aGlzLnJlZmlsbCgpLHIubGFiZWw9MTtjYXNlIDE6cmV0dXJuIHRoaXMuYnVmZmVyLmlzRW1wdHkoKT9bMywzXToodD10aGlzLmNob29zZUluZGV4KCksWzQsdGhpcy5idWZmZXIuc2h1ZmZsZUV4Y2lzZSh0KV0pO2Nhc2UgMjpyZXR1cm4oZT1yLnNlbnQoKSkuZG9uZT8odGhpcy51cHN0cmVhbUV4aGF1c3RlZD0hMCxbMywxXSk6KHRoaXMucmVmaWxsKCksWzIsZV0pO2Nhc2UgMzpyZXR1cm5bMix7dmFsdWU6bnVsbCxkb25lOiEwfV19fSl9KX0sZX0oUHJlZmV0Y2hJdGVyYXRvciksRGF0YXNldD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt0aGlzLnNpemU9bnVsbH1yZXR1cm4gdC5wcm90b3R5cGUuYmF0Y2g9ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzO3ZvaWQgMD09PWUmJihlPSEwKTt2YXIgbj10aGlzO3JldHVybiB1dGlsLmFzc2VydCh0PjAsZnVuY3Rpb24oKXtyZXR1cm5cImJhdGNoU2l6ZSBuZWVkcyB0byBiZSBwb3NpdGl2ZSwgYnV0IGl0IGlzXFxuICAgICAgXCIrdH0pLGRhdGFzZXRGcm9tSXRlcmF0b3JGbihmdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIocix2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxuLml0ZXJhdG9yKCldO2Nhc2UgMTpyZXR1cm5bMixyLnNlbnQoKS5jb2x1bW5NYWpvckJhdGNoKHQsZSxkZWVwQmF0Y2hDb25jYXQpXX19KX0pfSx0aGlzLnNpemU9PT0xLzB8fG51bGw9PXRoaXMuc2l6ZT90aGlzLnNpemU6ZT9NYXRoLmNlaWwodGhpcy5zaXplL3QpOk1hdGguZmxvb3IodGhpcy5zaXplL3QpKX0sdC5wcm90b3R5cGUuY29uY2F0ZW5hdGU9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPXRoaXM7cmV0dXJuIGRhdGFzZXRGcm9tSXRlcmF0b3JGbihmdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIoZSx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsbjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihpKXtzd2l0Y2goaS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHIuaXRlcmF0b3IoKV07Y2FzZSAxOnJldHVybiBuPShlPWkuc2VudCgpKS5jb25jYXRlbmF0ZSxbNCx0Lml0ZXJhdG9yKCldO2Nhc2UgMjpyZXR1cm5bMixuLmFwcGx5KGUsW2kuc2VudCgpXSldfX0pfSl9LHRoaXMuc2l6ZT09PTEvMHx8dC5zaXplPT09MS8wPzEvMDpudWxsIT10aGlzLnNpemUmJm51bGwhPXQuc2l6ZT90aGlzLnNpemUrdC5zaXplOm51bGwpfSx0LnByb3RvdHlwZS5maWx0ZXI9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPXRoaXM7cmV0dXJuIGRhdGFzZXRGcm9tSXRlcmF0b3JGbihmdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIoZSx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxyLml0ZXJhdG9yKCldO2Nhc2UgMTpyZXR1cm5bMixlLnNlbnQoKS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gdChlKX0pfSldfX0pfSl9LHRoaXMuc2l6ZT09PTEvMD8xLzA6bnVsbCl9LHQucHJvdG90eXBlLmZvckVhY2hBc3luYz1mdW5jdGlvbih0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5pdGVyYXRvcigpXTtjYXNlIDE6cmV0dXJuWzIsZS5zZW50KCkuZm9yRWFjaEFzeW5jKHQpXX19KX0pfSx0LnByb3RvdHlwZS5mb3JFYWNoPWZ1bmN0aW9uKHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuIGRlcHJlY2F0aW9uV2FybihcImRhdGFzZXQuZm9yRWFjaCgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZC4gUGxlYXNlIHVzZSBkYXRhc2V0LmZvckVhY2hBc3luYygpIGluc3RlYWRcIiksWzIsdGhpcy5mb3JFYWNoQXN5bmModCldfSl9KX0sdC5wcm90b3R5cGUubWFwPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMscj10aGlzO3JldHVybiBkYXRhc2V0RnJvbUl0ZXJhdG9yRm4oZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKGUsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsci5pdGVyYXRvcigpXTtjYXNlIDE6cmV0dXJuWzIsZS5zZW50KCkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIHQoZSl9KX0pXX19KX0pfSx0aGlzLnNpemUpfSx0LnByb3RvdHlwZS5tYXBBc3luYz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLHI9dGhpcztyZXR1cm4gZGF0YXNldEZyb21JdGVyYXRvckZuKGZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcihlLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHIuaXRlcmF0b3IoKV07Y2FzZSAxOnJldHVyblsyLGUuc2VudCgpLm1hcEFzeW5jKHQpXX19KX0pfSx0aGlzLnNpemUpfSx0LnByb3RvdHlwZS5wcmVmZXRjaD1mdW5jdGlvbih0KXt2YXIgZT10aGlzO2lmKG51bGw9PXQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJgRGF0YXNldC5wcmVmZXRjaCgpYCByZXF1aXJlcyBidWZmZXJTaXplIHRvIGJlIHNwZWNpZmllZC5cIik7dmFyIHI9dGhpcztyZXR1cm4gZGF0YXNldEZyb21JdGVyYXRvckZuKGZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcihlLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHIuaXRlcmF0b3IoKV07Y2FzZSAxOnJldHVyblsyLGUuc2VudCgpLnByZWZldGNoKHQpXX19KX0pfSx0aGlzLnNpemUpfSx0LnByb3RvdHlwZS5yZXBlYXQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPXRoaXM7cmV0dXJuIGRhdGFzZXRGcm9tSXRlcmF0b3JGbihmdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIoZSx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGU9dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihuKXtyZXR1cm5bMixpdGVyYXRvckZyb21Db25jYXRlbmF0ZWQoaXRlcmF0b3JGcm9tRnVuY3Rpb24oZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKGUsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0O3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHQ9e30sWzQsci5pdGVyYXRvcigpXTtjYXNlIDE6cmV0dXJuWzIsKHQudmFsdWU9ZS5zZW50KCksdC5kb25lPSExLHQpXX19KX0pfSkudGFrZSh0KSldfSl9KX0sbnVsbCE9dGhpcy5zaXplJiZ0PjA/dGhpcy5zaXplKnQ6MD09PXQ/MDpudWxsIT10aGlzLnNpemUmJih2b2lkIDA9PT10fHx0PDApPzEvMDpudWxsKX0sdC5wcm90b3R5cGUuc2tpcD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLHI9dGhpcztyZXR1cm4gZGF0YXNldEZyb21JdGVyYXRvckZuKGZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcihlLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHIuaXRlcmF0b3IoKV07Y2FzZSAxOnJldHVyblsyLGUuc2VudCgpLnNraXAodCldfX0pfSl9LG51bGwhPXRoaXMuc2l6ZSYmdD49MCYmdGhpcy5zaXplPj10P3RoaXMuc2l6ZS10Om51bGwhPXRoaXMuc2l6ZSYmKHRoaXMuc2l6ZTx0fHx2b2lkIDA9PT10fHx0PDApPzA6bnVsbCl9LHQucHJvdG90eXBlLnNodWZmbGU9ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXRoaXM7aWYodm9pZCAwPT09ciYmKHI9ITApLG51bGw9PXR8fHQ8MCl0aHJvdyBudWxsPT10aGlzLnNpemU/bmV3IFJhbmdlRXJyb3IoXCJgRGF0YXNldC5zaHVmZmxlKClgIHJlcXVpcmVzIGJ1ZmZlclNpemUgdG8gYmUgc3BlY2lmaWVkLlwiKTpuZXcgUmFuZ2VFcnJvcihcImBEYXRhc2V0LnNodWZmbGUoKWAgcmVxdWlyZXMgYnVmZmVyU2l6ZSB0byBiZSBzcGVjaWZpZWQuICBJZiB5b3VyIGRhdGEgZml0cyBpbiBtYWluIG1lbW9yeSAoZm9yIHJlZ3VsYXIgSlMgb2JqZWN0cyksIGFuZC9vciBHUFUgbWVtb3J5IChmb3IgYHRmLlRlbnNvcmBzKSwgY29uc2lkZXIgc2V0dGluZyBidWZmZXJTaXplIHRvIHRoZSBkYXRhc2V0IHNpemUgKFwiK3RoaXMuc2l6ZStcIiBlbGVtZW50cylcIik7dmFyIGk9dGhpcyxvPXNlZWRyYW5kb21fMShlfHx1dGlsLm5vdygpLnRvU3RyaW5nKCkpO3JldHVybiBkYXRhc2V0RnJvbUl0ZXJhdG9yRm4oZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKG4sdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuIGU9by5pbnQzMigpLHImJihlKz1vLmludDMyKCkpLFs0LGkuaXRlcmF0b3IoKV07Y2FzZSAxOnJldHVyblsyLG4uc2VudCgpLnNodWZmbGUodCxlLnRvU3RyaW5nKCkpXX19KX0pfSx0aGlzLnNpemUpfSx0LnByb3RvdHlwZS50YWtlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMscj10aGlzO3JldHVybiBkYXRhc2V0RnJvbUl0ZXJhdG9yRm4oZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKGUsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsci5pdGVyYXRvcigpXTtjYXNlIDE6cmV0dXJuWzIsZS5zZW50KCkudGFrZSh0KV19fSl9KX0sbnVsbCE9dGhpcy5zaXplJiZ0aGlzLnNpemU+dD90Om51bGwhPXRoaXMuc2l6ZSYmdGhpcy5zaXplPD10P3RoaXMuc2l6ZTpudWxsKX0sdC5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDppZih0aGlzLnNpemU9PT0xLzApdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBjb252ZXJ0IGluZmluaXRlIGRhdGEgc3RyZWFtIHRvIGFycmF5LlwiKTtyZXR1cm5bNCx0aGlzLml0ZXJhdG9yKCldO2Nhc2UgMTpyZXR1cm5bMix0LnNlbnQoKS50b0FycmF5KCldfX0pfSl9LHQucHJvdG90eXBlLnRvQXJyYXlGb3JUZXN0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOmlmKHRoaXMuc2l6ZT09PTEvMCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGNvbnZlcnQgaW5maW5pdGUgZGF0YSBzdHJlYW0gdG8gYXJyYXkuXCIpO3JldHVybls0LHRoaXMuaXRlcmF0b3IoKV07Y2FzZSAxOnJldHVyblsyLHQuc2VudCgpLnRvQXJyYXlGb3JUZXN0KCldfX0pfSl9LHQuTUFYX0JVRkZFUl9TSVpFPTFlNCx0fSgpO2Z1bmN0aW9uIGRhdGFzZXRGcm9tSXRlcmF0b3JGbih0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1udWxsKSxuZXcoZnVuY3Rpb24ocil7ZnVuY3Rpb24gbigpe3ZhciB0PW51bGwhPT1yJiZyLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpcztyZXR1cm4gdC5zaXplPWUsdH1yZXR1cm4gX19leHRlbmRzKG4sciksbi5wcm90b3R5cGUuaXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVyblsyLHQoKV19KX0pfSxufShEYXRhc2V0KSl9ZnVuY3Rpb24gYXJyYXkodCl7dmFyIGU9dGhpcztyZXR1cm4gZGF0YXNldEZyb21JdGVyYXRvckZuKGZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcihlLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm5bMixpdGVyYXRvckZyb21JdGVtcyh0KV19KX0pfSx0Lmxlbmd0aCl9ZnVuY3Rpb24gemlwKHQpe3ZhciBlLHI9dGhpcztpZighaXNJdGVyYWJsZSh0KSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYXJndW1lbnQgdG8gemlwKCkgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYXJyYXkuXCIpO2lmKEFycmF5LmlzQXJyYXkodCkpZm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspZT1udWxsPT1lP3Rbbl0uc2l6ZTpNYXRoLm1pbihlLHRbbl0uc2l6ZSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgT2JqZWN0KWZvcih2YXIgaSBpbiB0KWU9bnVsbD09ZT90W2ldLnNpemU6TWF0aC5taW4oZSx0W2ldLnNpemUpO3JldHVybiBkYXRhc2V0RnJvbUl0ZXJhdG9yRm4oZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHIsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsZGVlcE1hcEFuZEF3YWl0QWxsKHQsZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIERhdGFzZXQpcmV0dXJue3ZhbHVlOnQuaXRlcmF0b3IoKSxyZWN1cnNlOiExfTtpZihpc0l0ZXJhYmxlKHQpKXJldHVybnt2YWx1ZTpudWxsLHJlY3Vyc2U6ITB9O3Rocm93IG5ldyBFcnJvcihcIkxlYXZlcyBvZiB0aGUgc3RydWN0dXJlIHBhc3NlZCB0byB6aXAoKSBtdXN0IGJlIERhdGFzZXRzLCBub3QgcHJpbWl0aXZlcy5cIil9KV07Y2FzZSAxOnJldHVyblsyLGl0ZXJhdG9yRnJvbVppcHBlZChlLnNlbnQoKSxaaXBNaXNtYXRjaE1vZGUuU0hPUlRFU1QpXX19KX0pfSxlKX1mdW5jdGlvbiBkZWVwQmF0Y2hDb25jYXQodCl7cmV0dXJuIG51bGw9PT10P251bGw6Y2FuVGVuc29yaWZ5KHRbMF0pP3t2YWx1ZTpiYXRjaENvbmNhdCh0KSxyZWN1cnNlOiExfTp7dmFsdWU6bnVsbCxyZWN1cnNlOiEwfX1mdW5jdGlvbiBiYXRjaENvbmNhdCh0KXtpZigwPT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgbWFrZSBhIGJhdGNoIG9mIHplcm8gZWxlbWVudHMuXCIpO3JldHVybiB0WzBdaW5zdGFuY2VvZiBUZW5zb3I/c3RhY2sodCk6dGVuc29yKHQpfXZhciBUZXh0TGluZURhdGFzZXQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXt2YXIgcj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIHIuaW5wdXQ9ZSxyfXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5pdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMuaW5wdXQuaXRlcmF0b3IoKV07Y2FzZSAxOnJldHVybiB0PXIuc2VudCgpLGU9dC5kZWNvZGVVVEY4KCksWzIsZS5zcGxpdChcIlxcblwiKV19fSl9KX0sZX0oRGF0YXNldCksQ09ERV9RVU9URT0nXCInLFNUQVRFX09VVD1TeW1ib2woXCJvdXRcIiksU1RBVEVfRklFTEQ9U3ltYm9sKFwiZmllbGRcIiksU1RBVEVfUVVPVEU9U3ltYm9sKFwicXVvdGVcIiksU1RBVEVfUVVPVEVfQUZURVJfUVVPVEU9U3ltYm9sKFwicXVvdGVhZnRlcnF1b3RlXCIpLFNUQVRFX1dJVEhJTl9RVU9URV9JTl9RVU9URT1TeW1ib2woXCJxdW90ZWlucXVvdGVcIiksQ1NWRGF0YXNldD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscil7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLmlucHV0PWUsbi5oYXNIZWFkZXI9ITAsbi5mdWxsQ29sdW1uTmFtZXM9bnVsbCxuLmNvbHVtbk5hbWVzVmFsaWRhdGVkPSExLG4uY29sdW1uQ29uZmlncz1udWxsLG4uY29uZmlndXJlZENvbHVtbnNPbmx5PSExLG4uZGVsaW1pdGVyPVwiLFwiLG4uZGVsaW1XaGl0ZXNwYWNlPSExLG4uYmFzZT1uZXcgVGV4dExpbmVEYXRhc2V0KGUpLHJ8fChyPXt9KSxuLmhhc0hlYWRlcj0hMSE9PXIuaGFzSGVhZGVyLG4uZnVsbENvbHVtbk5hbWVzPXIuY29sdW1uTmFtZXMsbi5jb2x1bW5Db25maWdzPXIuY29sdW1uQ29uZmlncyxuLmNvbmZpZ3VyZWRDb2x1bW5zT25seT1yLmNvbmZpZ3VyZWRDb2x1bW5zT25seSxyLmRlbGltV2hpdGVzcGFjZT8odXRpbC5hc3NlcnQobnVsbD09ci5kZWxpbWl0ZXIsZnVuY3Rpb24oKXtyZXR1cm5cIkRlbGltaXRlciBzaG91bGQgbm90IGJlIHByb3ZpZGVkIHdoZW4gZGVsaW1XaGl0ZXNwYWNlIGlzIHRydWUuXCJ9KSxuLmRlbGltV2hpdGVzcGFjZT0hMCxuLmRlbGltaXRlcj1cIiBcIik6bi5kZWxpbWl0ZXI9ci5kZWxpbWl0ZXI/ci5kZWxpbWl0ZXI6XCIsXCIsbn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuY29sdW1uTmFtZXM9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6cmV0dXJuIHRoaXMuY29sdW1uTmFtZXNWYWxpZGF0ZWQ/WzMsMl06WzQsdGhpcy5zZXRDb2x1bW5OYW1lcygpXTtjYXNlIDE6dC5zZW50KCksdC5sYWJlbD0yO2Nhc2UgMjpyZXR1cm5bMix0aGlzLmNvbmZpZ3VyZWRDb2x1bW5zT25seT9PYmplY3Qua2V5cyh0aGlzLmNvbHVtbkNvbmZpZ3MpOnRoaXMuZnVsbENvbHVtbk5hbWVzXX19KX0pfSxlLnByb3RvdHlwZS5zZXRDb2x1bW5OYW1lcz1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZSxyLG4saSxvLGE9dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih1KXtzd2l0Y2godS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMubWF5YmVSZWFkSGVhZGVyTGluZSgpXTtjYXNlIDE6aWYodD11LnNlbnQoKSwhdGhpcy5mdWxsQ29sdW1uTmFtZXMmJiF0KXRocm93IG5ldyBFcnJvcihcIkNvbHVtbiBuYW1lcyBtdXN0IGJlIHByb3ZpZGVkIGlmIHRoZXJlIGlzIG5vIGhlYWRlciBsaW5lLlwiKTtpZih0aGlzLmZ1bGxDb2x1bW5OYW1lcyYmdCYmdXRpbC5hc3NlcnQodC5sZW5ndGg9PT10aGlzLmZ1bGxDb2x1bW5OYW1lcy5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBsZW5ndGggb2YgcHJvdmlkZWQgY29sdW1uTmFtZXMgKFwiK2EuZnVsbENvbHVtbk5hbWVzLmxlbmd0aC50b1N0cmluZygpK1wiKSBkb2VzIG5vdCBtYXRjaCB0aGUgbGVuZ3RoIG9mIHRoZSBoZWFkZXIgbGluZSByZWFkIGZyb20gZmlsZSAoXCIrdC5sZW5ndGgudG9TdHJpbmcoKStcIikuXCJ9KSx0aGlzLmZ1bGxDb2x1bW5OYW1lc3x8KHRoaXMuZnVsbENvbHVtbk5hbWVzPXQpLGU9dGhpcy5mdWxsQ29sdW1uTmFtZXMucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbZV09dFtlXSsxfHwxLHR9LHt9KSxyPU9iamVjdC5rZXlzKGUpLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gZVt0XT4xfSksdXRpbC5hc3NlcnQoMD09PXIubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJEdXBsaWNhdGUgY29sdW1uIG5hbWVzIGZvdW5kOiBcIityLnRvU3RyaW5nKCl9KSx0aGlzLmNvbHVtbkNvbmZpZ3MpZm9yKG49MCxpPU9iamVjdC5rZXlzKHRoaXMuY29sdW1uQ29uZmlncyk7bjxpLmxlbmd0aDtuKyspaWYobz1pW25dLC0xPT09dGhpcy5mdWxsQ29sdW1uTmFtZXMuaW5kZXhPZihvKSl0aHJvdyBuZXcgRXJyb3IoJ1RoZSBrZXkgXCInK28rJ1wiIHByb3ZpZGVkIGluIGNvbHVtbkNvbmZpZ3MgZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSBjb2x1bW4gbmFtZXMgKCcrdGhpcy5mdWxsQ29sdW1uTmFtZXMudG9TdHJpbmcoKStcIikuXCIpO3JldHVybiB0aGlzLmNvbHVtbk5hbWVzVmFsaWRhdGVkPSEwLFsyXX19KX0pfSxlLnByb3RvdHlwZS5tYXliZVJlYWRIZWFkZXJMaW5lPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHRoaXMuaGFzSGVhZGVyP1s0LHRoaXMuYmFzZS5pdGVyYXRvcigpXTpbMywzXTtjYXNlIDE6cmV0dXJuWzQsci5zZW50KCkubmV4dCgpXTtjYXNlIDI6aWYoKHQ9ci5zZW50KCkpLmRvbmUpdGhyb3cgbmV3IEVycm9yKFwiTm8gZGF0YSB3YXMgZm91bmQgZm9yIENTViBwYXJzaW5nLlwiKTtyZXR1cm4gZT10LnZhbHVlLFsyLHRoaXMucGFyc2VSb3coZSwhMSldO2Nhc2UgMzpyZXR1cm5bMixudWxsXX19KX0pfSxlLnByb3RvdHlwZS5pdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZT10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHRoaXMuY29sdW1uTmFtZXNWYWxpZGF0ZWQ/WzMsMl06WzQsdGhpcy5zZXRDb2x1bW5OYW1lcygpXTtjYXNlIDE6ci5zZW50KCksci5sYWJlbD0yO2Nhc2UgMjpyZXR1cm5bNCx0aGlzLmJhc2UuaXRlcmF0b3IoKV07Y2FzZSAzOnJldHVybiB0PXIuc2VudCgpLHRoaXMuaGFzSGVhZGVyJiYodD10LnNraXAoMSkpLFsyLHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlLm1ha2VEYXRhRWxlbWVudCh0KX0pXX19KX0pfSxlLnByb3RvdHlwZS5tYWtlRGF0YUVsZW1lbnQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMucGFyc2VSb3codCkscj17fSxuPXt9LGk9MDtpPHRoaXMuZnVsbENvbHVtbk5hbWVzLmxlbmd0aDtpKyspe3ZhciBvPXRoaXMuZnVsbENvbHVtbk5hbWVzW2ldLGE9dGhpcy5jb2x1bW5Db25maWdzP3RoaXMuY29sdW1uQ29uZmlnc1tvXTpudWxsO2lmKCF0aGlzLmNvbmZpZ3VyZWRDb2x1bW5zT25seXx8YSl7dmFyIHU9ZVtpXSxzPW51bGw7aWYoXCJcIj09PXUpaWYoYSYmdm9pZCAwIT09YS5kZWZhdWx0KXM9YS5kZWZhdWx0O2Vsc2V7aWYoYSYmKGEucmVxdWlyZWR8fGEuaXNMYWJlbCkpdGhyb3cgbmV3IEVycm9yKFwiUmVxdWlyZWQgY29sdW1uIFwiK28rXCIgaXMgZW1wdHkgaW4gdGhpcyBsaW5lOiBcIit0KTtzPXZvaWQgMH1lbHNle3ZhciBjPU51bWJlcih1KTtpZihpc05hTihjKSlzPWEmJlwiYm9vbFwiPT09YS5kdHlwZT90aGlzLmdldEJvb2xlYW4odSk6dTtlbHNlIGlmKGEmJmEuZHR5cGUpc3dpdGNoKGEuZHR5cGUpe2Nhc2VcImZsb2F0MzJcIjpzPWM7YnJlYWs7Y2FzZVwiaW50MzJcIjpzPU1hdGguZmxvb3IoYyk7YnJlYWs7Y2FzZVwiYm9vbFwiOnM9dGhpcy5nZXRCb29sZWFuKHUpO2JyZWFrO2RlZmF1bHQ6cz1jfWVsc2Ugcz1jfWEmJmEuaXNMYWJlbD9uW29dPXM6cltvXT1zfX1yZXR1cm4gMD09PU9iamVjdC5rZXlzKG4pLmxlbmd0aD9yOnt4czpyLHlzOm59fSxlLnByb3RvdHlwZS5nZXRCb29sZWFuPWZ1bmN0aW9uKHQpe3JldHVyblwiMVwiPT09dHx8XCJ0cnVlXCI9PT10LnRvTG93ZXJDYXNlKCk/MTowfSxlLnByb3RvdHlwZS5wYXJzZVJvdz1mdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPSEwKTtmb3IodmFyIHI9W10sbj0wLGk9dC5sZW5ndGgsbz1TVEFURV9PVVQsYT0wO2E8aTthKyspc3dpdGNoKG8pe2Nhc2UgU1RBVEVfT1VUOnN3aXRjaCh0LmNoYXJBdChhKSl7Y2FzZSBDT0RFX1FVT1RFOm49YSsxLG89U1RBVEVfUVVPVEU7YnJlYWs7Y2FzZSB0aGlzLmRlbGltaXRlcjppZihuPWErMSxcIiBcIj09PXRoaXMuZGVsaW1pdGVyJiZ0aGlzLmRlbGltV2hpdGVzcGFjZSlicmVhaztyLnB1c2goXCJcIiksbz1TVEFURV9PVVQ7YnJlYWs7ZGVmYXVsdDpvPVNUQVRFX0ZJRUxELG49YX1icmVhaztjYXNlIFNUQVRFX0ZJRUxEOnN3aXRjaCh0LmNoYXJBdChhKSl7Y2FzZSB0aGlzLmRlbGltaXRlcjpyLnB1c2godC5zdWJzdHJpbmcobixhKSksbz1TVEFURV9PVVQsbj1hKzF9YnJlYWs7Y2FzZSBTVEFURV9RVU9URTpzd2l0Y2godC5jaGFyQXQoYSkpe2Nhc2UgQ09ERV9RVU9URTpvPVNUQVRFX1FVT1RFX0FGVEVSX1FVT1RFfWJyZWFrO2Nhc2UgU1RBVEVfUVVPVEVfQUZURVJfUVVPVEU6c3dpdGNoKHQuY2hhckF0KGEpKXtjYXNlIHRoaXMuZGVsaW1pdGVyOnIucHVzaCh0LnN1YnN0cmluZyhuLGEtMSkpLG89U1RBVEVfT1VULG49YSsxO2JyZWFrO2Nhc2UgQ09ERV9RVU9URTpvPVNUQVRFX1FVT1RFO2JyZWFrO2RlZmF1bHQ6bz1TVEFURV9XSVRISU5fUVVPVEVfSU5fUVVPVEV9YnJlYWs7Y2FzZSBTVEFURV9XSVRISU5fUVVPVEVfSU5fUVVPVEU6c3dpdGNoKHQuY2hhckF0KGEpKXtjYXNlIENPREVfUVVPVEU6bz1TVEFURV9RVU9URX19aWYobz09PVNUQVRFX1FVT1RFX0FGVEVSX1FVT1RFP3IucHVzaCh0LnN1YnN0cmluZyhuLGktMSkpOnIucHVzaCh0LnN1YnN0cmluZyhuKSksZSYmci5sZW5ndGghPT10aGlzLmZ1bGxDb2x1bW5OYW1lcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3cgaW4gY3N2IGZpbGUuIFNob3VsZCBoYXZlIFwiK3RoaXMuZnVsbENvbHVtbk5hbWVzLmxlbmd0aCtcIiBlbGVtZW50cyBpbiBhIHJvdywgYnV0IGdvdCBcIityKTtyZXR1cm4gcn0sZX0oRGF0YXNldCksZW52aXJvbm1lbnQ9Y3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24odCxlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5nbG9iYWw9dCx0aGlzLmZsYWdzPXt9LHRoaXMuZmxhZ1JlZ2lzdHJ5PXt9LHRoaXMudXJsRmxhZ3M9e30sdGhpcy5wb3B1bGF0ZVVSTEZsYWdzKCl9cmV0dXJuIHQucHJvdG90eXBlLnJlZ2lzdGVyRmxhZz1mdW5jdGlvbih0LGUscil7aWYodGhpcy5mbGFnUmVnaXN0cnlbdF09e2V2YWx1YXRpb25GbjplLHNldEhvb2s6cn0sbnVsbCE9dGhpcy51cmxGbGFnc1t0XSl7dmFyIG49dGhpcy51cmxGbGFnc1t0XTtjb25zb2xlLndhcm4oXCJTZXR0aW5nIGZlYXR1cmUgb3ZlcnJpZGUgZnJvbSBVUkwgXCIrdCtcIjogXCIrbitcIi5cIiksdGhpcy5zZXQodCxuKX19LHQucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbiB0aGlzLmZsYWdzP3RoaXMuZmxhZ3NbdF06KHRoaXMuZmxhZ3NbdF09dGhpcy5ldmFsdWF0ZUZsYWcodCksdGhpcy5mbGFnc1t0XSl9LHQucHJvdG90eXBlLmdldE51bWJlcj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZXQodCl9LHQucHJvdG90eXBlLmdldEJvb2w9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2V0KHQpfSx0LnByb3RvdHlwZS5nZXRGbGFncz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmZsYWdzfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJmZWF0dXJlc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mbGFnc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24odCxlKXtpZihudWxsPT10aGlzLmZsYWdSZWdpc3RyeVt0XSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IGZsYWcgXCIrdCtcIiBhcyBpdCBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZC5cIik7dGhpcy5mbGFnc1t0XT1lLG51bGwhPXRoaXMuZmxhZ1JlZ2lzdHJ5W3RdLnNldEhvb2smJnRoaXMuZmxhZ1JlZ2lzdHJ5W3RdLnNldEhvb2soZSl9LHQucHJvdG90eXBlLmV2YWx1YXRlRmxhZz1mdW5jdGlvbih0KXtpZihudWxsPT10aGlzLmZsYWdSZWdpc3RyeVt0XSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZXZhbHVhdGUgZmxhZyAnXCIrdCtcIic6IG5vIGV2YWx1YXRpb24gZnVuY3Rpb24gZm91bmQuXCIpO3JldHVybiB0aGlzLmZsYWdSZWdpc3RyeVt0XS5ldmFsdWF0aW9uRm4oKX0sdC5wcm90b3R5cGUuc2V0RmxhZ3M9ZnVuY3Rpb24odCl7dGhpcy5mbGFncz1PYmplY3QuYXNzaWduKHt9LHQpfSx0LnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMuZmxhZ3M9e30sdGhpcy51cmxGbGFncz17fSx0aGlzLnBvcHVsYXRlVVJMRmxhZ3MoKX0sdC5wcm90b3R5cGUucG9wdWxhdGVVUkxGbGFncz1mdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYodm9pZCAwIT09dGhpcy5nbG9iYWwmJnZvaWQgMCE9PXRoaXMuZ2xvYmFsLmxvY2F0aW9uJiZ2b2lkIDAhPT10aGlzLmdsb2JhbC5sb2NhdGlvbi5zZWFyY2gpe3ZhciBlPW4odGhpcy5nbG9iYWwubG9jYXRpb24uc2VhcmNoKTtpZihcInRmanNmbGFnc1wiaW4gZSllLnRmanNmbGFncy5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgcj1lLnNwbGl0KFwiOlwiKSxuPXJbMF0saT1yWzFdO3QudXJsRmxhZ3Nbbl09ZnVuY3Rpb24odCxlKXtpZihcInRydWVcIj09PShlPWUudG9Mb3dlckNhc2UoKSl8fFwiZmFsc2VcIj09PWUpcmV0dXJuXCJ0cnVlXCI9PT1lO2lmKFwiXCIrICtlPT09ZSlyZXR1cm4rZTt0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcGFyc2UgdmFsdWUgZmxhZyB2YWx1ZSBcIitlK1wiIGZvciBmbGFnIFwiK3QrXCIuXCIpfShuLGkpfSl9fSx0fSgpO2Z1bmN0aW9uIG4odCl7dmFyIGU9e307cmV0dXJuIHQucmVwbGFjZSgvWz8mXShbXj0/Jl0rKSg/Oj0oW14mXSopKT8vZyxmdW5jdGlvbih0KXtmb3IodmFyIHI9W10sbj0xO248YXJndW1lbnRzLmxlbmd0aDtuKyspcltuLTFdPWFyZ3VtZW50c1tuXTtyZXR1cm4gZnVuY3Rpb24odCxlLHIpe3RbZGVjb2RlVVJJQ29tcG9uZW50KGUpXT1kZWNvZGVVUklDb21wb25lbnQocnx8XCJcIil9KGUsclswXSxyWzFdKSxyLmpvaW4oXCI9XCIpfSksZX1lLkVudmlyb25tZW50PXIsZS5nZXRRdWVyeVBhcmFtcz1uLGUuc2V0RW52aXJvbm1lbnRHbG9iYWw9ZnVuY3Rpb24odCl7ZS5FTlY9dH19KTt1bndyYXBFeHBvcnRzKGVudmlyb25tZW50KTt2YXIgZW52aXJvbm1lbnRfMT1lbnZpcm9ubWVudC5FbnZpcm9ubWVudCxlbnZpcm9ubWVudF8yPWVudmlyb25tZW50LmdldFF1ZXJ5UGFyYW1zLGVudmlyb25tZW50XzM9ZW52aXJvbm1lbnQuRU5WLGVudmlyb25tZW50XzQ9ZW52aXJvbm1lbnQuc2V0RW52aXJvbm1lbnRHbG9iYWwsdXRpbCQxPWNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gcih0KXtmb3IodmFyIGU9dC5sZW5ndGgscj0wLG49MDtlPjA7KW49TWF0aC5yYW5kb20oKSplfDAscj10Wy0tZV0sdFtlXT10W25dLHRbbl09cn1mdW5jdGlvbiBuKHQsZSl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nXCI9PXR5cGVvZiBlP2U6ZSgpKX1mdW5jdGlvbiBpKHQsZSl7aWYodm9pZCAwPT09ZSYmKGU9W10pLG51bGw9PWUmJihlPVtdKSxBcnJheS5pc0FycmF5KHQpfHxjKHQpKWZvcih2YXIgcj0wO3I8dC5sZW5ndGg7KytyKWkodFtyXSxlKTtlbHNlIGUucHVzaCh0KTtyZXR1cm4gZX1mdW5jdGlvbiBvKHQsZSl7aWYodD09PWUpcmV0dXJuITA7aWYobnVsbD09dHx8bnVsbD09ZSlyZXR1cm4hMTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKWlmKHRbcl0hPT1lW3JdKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIGEodCl7cmV0dXJuIHQlMT09MH1mdW5jdGlvbiB1KHQsZSl7dmFyIHI9ZS5sZW5ndGg7cmV0dXJuIG4oKHQ9bnVsbD09dD9lLm1hcChmdW5jdGlvbih0LGUpe3JldHVybiBlfSk6W10uY29uY2F0KHQpKS5ldmVyeShmdW5jdGlvbih0KXtyZXR1cm4gdD49LXImJnQ8cn0pLGZ1bmN0aW9uKCl7cmV0dXJuXCJBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbiByYW5nZSBbLVwiK3IrXCIsIFwiK3IrXCIpIGJ1dCBnb3QgYXhpcyBcIit0fSksbih0LmV2ZXJ5KGZ1bmN0aW9uKHQpe3JldHVybiBhKHQpfSksZnVuY3Rpb24oKXtyZXR1cm5cIkFsbCB2YWx1ZXMgaW4gYXhpcyBwYXJhbSBtdXN0IGJlIGludGVnZXJzIGJ1dCBnb3QgYXhpcyBcIit0fSksdC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQ8MD9yK3Q6dH0pfWZ1bmN0aW9uIHModCxlKXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG49dFtyXTtpZihpc05hTihuKXx8IWlzRmluaXRlKG4pKXRocm93IEVycm9yKFwiQSB0ZW5zb3Igb2YgdHlwZSBcIitlK1wiIGJlaW5nIHVwbG9hZGVkIGNvbnRhaW5zIFwiK24rXCIuXCIpfX1mdW5jdGlvbiBjKHQpe3JldHVybiB0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5fHx0IGluc3RhbmNlb2YgSW50MzJBcnJheXx8dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl9ZnVuY3Rpb24gbCh0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdHx8dCBpbnN0YW5jZW9mIFN0cmluZ31mdW5jdGlvbiBmKHQpe3JldHVyblwiYm9vbGVhblwiPT10eXBlb2YgdH1mdW5jdGlvbiBoKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0fWZ1bmN0aW9uIHAodCxlKXtpZihudWxsPT1lfHxcImZsb2F0MzJcIj09PWV8fFwiY29tcGxleDY0XCI9PT1lKXJldHVybiBuZXcgRmxvYXQzMkFycmF5KHQpO2lmKFwiaW50MzJcIj09PWUpcmV0dXJuIG5ldyBJbnQzMkFycmF5KHQpO2lmKFwiYm9vbFwiPT09ZSlyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodCk7dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIrZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5zaHVmZmxlPXIsZS5jbGFtcD1mdW5jdGlvbih0LGUscil7cmV0dXJuIE1hdGgubWF4KHQsTWF0aC5taW4oZSxyKSl9LGUubmVhcmVzdExhcmdlckV2ZW49ZnVuY3Rpb24odCl7cmV0dXJuIHQlMj09MD90OnQrMX0sZS5zdW09ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAscj0wO3I8dC5sZW5ndGg7cisrKWUrPXRbcl07cmV0dXJuIGV9LGUucmFuZFVuaWZvcm09ZnVuY3Rpb24odCxlKXt2YXIgcj1NYXRoLnJhbmRvbSgpO3JldHVybiBlKnIrKDEtcikqdH0sZS5kaXN0U3F1YXJlZD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgcj0wLG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIGk9TnVtYmVyKHRbbl0pLU51bWJlcihlW25dKTtyKz1pKml9cmV0dXJuIHJ9LGUuYXNzZXJ0PW4sZS5hc3NlcnRTaGFwZXNNYXRjaD1mdW5jdGlvbih0LGUscil7dm9pZCAwPT09ciYmKHI9XCJcIiksbihvKHQsZSksZnVuY3Rpb24oKXtyZXR1cm4gcitcIiBTaGFwZXMgXCIrdCtcIiBhbmQgXCIrZStcIiBtdXN0IG1hdGNoXCJ9KX0sZS5hc3NlcnROb25OdWxsPWZ1bmN0aW9uKHQpe24obnVsbCE9dCxmdW5jdGlvbigpe3JldHVyblwiVGhlIGlucHV0IHRvIHRoZSB0ZW5zb3IgY29uc3RydWN0b3IgbXVzdCBiZSBhIG5vbi1udWxsIHZhbHVlLlwifSl9LGUuZmxhdHRlbj1pLGUuc2l6ZUZyb21TaGFwZT1mdW5jdGlvbih0KXtpZigwPT09dC5sZW5ndGgpcmV0dXJuIDE7Zm9yKHZhciBlPXRbMF0scj0xO3I8dC5sZW5ndGg7cisrKWUqPXRbcl07cmV0dXJuIGV9LGUuaXNTY2FsYXJTaGFwZT1mdW5jdGlvbih0KXtyZXR1cm4gMD09PXQubGVuZ3RofSxlLmFycmF5c0VxdWFsPW8sZS5pc0ludD1hLGUudGFuaD1mdW5jdGlvbih0KXtpZihudWxsIT1NYXRoLnRhbmgpcmV0dXJuIE1hdGgudGFuaCh0KTtpZih0PT09MS8wKXJldHVybiAxO2lmKHQ9PT0tMS8wKXJldHVybi0xO3ZhciBlPU1hdGguZXhwKDIqdCk7cmV0dXJuKGUtMSkvKGUrMSl9LGUuc2l6ZVRvU3F1YXJpc2hTaGFwZT1mdW5jdGlvbih0KXt2YXIgZT1NYXRoLmNlaWwoTWF0aC5zcXJ0KHQpKTtyZXR1cm5bZSxNYXRoLmNlaWwodC9lKV19LGUuY3JlYXRlU2h1ZmZsZWRJbmRpY2VzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgVWludDMyQXJyYXkodCksbj0wO248dDsrK24pZVtuXT1uO3JldHVybiByKGUpLGV9LGUucmlnaHRQYWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZTw9dC5sZW5ndGg/dDp0K1wiIFwiLnJlcGVhdChlLXQubGVuZ3RoKX0sZS5yZXBlYXRlZFRyeT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHZvaWQgMD09PWUmJihlPWZ1bmN0aW9uKHQpe3JldHVybiAwfSksbmV3IFByb21pc2UoZnVuY3Rpb24obixpKXt2YXIgbz0wLGE9ZnVuY3Rpb24oKXtpZih0KCkpbigpO2Vsc2V7dmFyIHU9ZSgrK28pO251bGwhPXImJm8+PXI/aSgpOnNldFRpbWVvdXQoYSx1KX19O2EoKX0pfSxlLmluZmVyRnJvbUltcGxpY2l0U2hhcGU9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9MSxuPS0xLGk9MDtpPHQubGVuZ3RoOysraSlpZih0W2ldPj0wKXIqPXRbaV07ZWxzZSBpZigtMT09PXRbaV0pe2lmKC0xIT09bil0aHJvdyBFcnJvcihcIlNoYXBlcyBjYW4gb25seSBoYXZlIDEgaW1wbGljaXQgc2l6ZS4gRm91bmQgLTEgYXQgZGltIFwiK24rXCIgYW5kIGRpbSBcIitpKTtuPWl9ZWxzZSBpZih0W2ldPDApdGhyb3cgRXJyb3IoXCJTaGFwZXMgY2FuIG5vdCBiZSA8IDAuIEZvdW5kIFwiK3RbaV0rXCIgYXQgZGltIFwiK2kpO2lmKC0xPT09bil7aWYoZT4wJiZlIT09cil0aHJvdyBFcnJvcihcIlNpemUoXCIrZStcIikgbXVzdCBtYXRjaCB0aGUgcHJvZHVjdCBvZiBzaGFwZSBcIit0KTtyZXR1cm4gdH1pZigwPT09cil0aHJvdyBFcnJvcihcIkNhbm5vdCBpbmZlciB0aGUgbWlzc2luZyBzaXplIGluIFtcIit0K1wiXSB3aGVuIHRoZXJlIGFyZSAwIGVsZW1lbnRzXCIpO2lmKGUlciE9MCl0aHJvdyBFcnJvcihcIlRoZSBpbXBsaWNpdCBzaGFwZSBjYW4ndCBiZSBhIGZyYWN0aW9uYWwgbnVtYmVyLiBHb3QgXCIrZStcIiAvIFwiK3IpO3ZhciBvPXQuc2xpY2UoKTtyZXR1cm4gb1tuXT1lL3Isb30sZS5wYXJzZUF4aXNQYXJhbT11LGUuc3F1ZWV6ZVNoYXBlPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPVtdLG49W10saT1udWxsPT1lP251bGw6dShlLHQpLnNvcnQoKSxvPTAsYT0wO2E8dC5sZW5ndGg7KythKXtpZihudWxsIT1pKXtpZihpW29dPT09YSYmMSE9PXRbYV0pdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc3F1ZWV6ZSBheGlzIFwiK2ErXCIgc2luY2UgaXRzIGRpbSAnXCIrdFthXStcIicgaXMgbm90IDFcIik7KG51bGw9PWlbb118fGlbb10+YSkmJjE9PT10W2FdJiYoci5wdXNoKHRbYV0pLG4ucHVzaChhKSksaVtvXTw9YSYmbysrfTEhPT10W2FdJiYoci5wdXNoKHRbYV0pLG4ucHVzaChhKSl9cmV0dXJue25ld1NoYXBlOnIsa2VwdERpbXM6bn19LGUuZ2V0VHlwZWRBcnJheUZyb21EVHlwZT1mdW5jdGlvbih0LGUpe3ZhciByPW51bGw7aWYobnVsbD09dHx8XCJmbG9hdDMyXCI9PT10KXI9bmV3IEZsb2F0MzJBcnJheShlKTtlbHNlIGlmKFwiaW50MzJcIj09PXQpcj1uZXcgSW50MzJBcnJheShlKTtlbHNle2lmKFwiYm9vbFwiIT09dCl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBcIit0KTtyPW5ldyBVaW50OEFycmF5KGUpfXJldHVybiByfSxlLmdldEFycmF5RnJvbURUeXBlPWZ1bmN0aW9uKHQsZSl7dmFyIHI9bnVsbDtpZihudWxsPT10fHxcImZsb2F0MzJcIj09PXQpcj1uZXcgRmxvYXQzMkFycmF5KGUpO2Vsc2UgaWYoXCJpbnQzMlwiPT09dClyPW5ldyBJbnQzMkFycmF5KGUpO2Vsc2UgaWYoXCJib29sXCI9PT10KXI9bmV3IFVpbnQ4QXJyYXkoZSk7ZWxzZXtpZihcInN0cmluZ1wiIT09dCl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBcIit0KTtyPW5ldyBBcnJheShlKX1yZXR1cm4gcn0sZS5jaGVja0NvbXB1dGF0aW9uRm9yRXJyb3JzPWZ1bmN0aW9uKHQsZSxyKXtpZihcImZsb2F0MzJcIj09PWUpZm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBpPXRbbl07aWYoaXNOYU4oaSl8fCFpc0Zpbml0ZShpKSl0aHJvdyBFcnJvcihcIlRoZSByZXN1bHQgb2YgdGhlICdcIityK1wiJyBpcyBcIitpK1wiLlwiKX19LGUuY2hlY2tDb252ZXJzaW9uRm9yRXJyb3JzPXMsZS5oYXNFbmNvZGluZ0xvc3M9ZnVuY3Rpb24odCxlKXtyZXR1cm4hKFwiY29tcGxleDY0XCI9PT1lfHxcImZsb2F0MzJcIj09PWUmJlwiY29tcGxleDY0XCIhPT10fHxcImludDMyXCI9PT1lJiZcImZsb2F0MzJcIiE9PXQmJlwiY29tcGxleDY0XCIhPT10fHxcImJvb2xcIj09PWUmJlwiYm9vbFwiPT09dCl9LGUuaXNUeXBlZEFycmF5PWMsZS5ieXRlc1BlckVsZW1lbnQ9ZnVuY3Rpb24odCl7aWYoXCJmbG9hdDMyXCI9PT10fHxcImludDMyXCI9PT10KXJldHVybiA0O2lmKFwiY29tcGxleDY0XCI9PT10KXJldHVybiA4O2lmKFwiYm9vbFwiPT09dClyZXR1cm4gMTt0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGR0eXBlIFwiK3QpfSxlLmJ5dGVzRnJvbVN0cmluZ0FycmF5PWZ1bmN0aW9uKHQpe2lmKG51bGw9PXQpcmV0dXJuIDA7dmFyIGU9MDtyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiBlKz0yKnQubGVuZ3RofSksZX0sZS5pc1N0cmluZz1sLGUuaXNCb29sZWFuPWYsZS5pc051bWJlcj1oLGUuaW5mZXJEdHlwZT1mdW5jdGlvbiB0KGUpe3JldHVybiBBcnJheS5pc0FycmF5KGUpP3QoZVswXSk6ZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheT9cImZsb2F0MzJcIjplIGluc3RhbmNlb2YgSW50MzJBcnJheXx8ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk/XCJpbnQzMlwiOmgoZSk/XCJmbG9hdDMyXCI6bChlKT9cInN0cmluZ1wiOmYoZSk/XCJib29sXCI6XCJmbG9hdDMyXCJ9LGUuaXNGdW5jdGlvbj1mdW5jdGlvbih0KXtyZXR1cm4hISh0JiZ0LmNvbnN0cnVjdG9yJiZ0LmNhbGwmJnQuYXBwbHkpfSxlLm5lYXJlc3REaXZpc29yPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPWU7cjx0OysrcilpZih0JXI9PTApcmV0dXJuIHI7cmV0dXJuIHR9LGUuY29tcHV0ZVN0cmlkZXM9ZnVuY3Rpb24odCl7dmFyIGU9dC5sZW5ndGg7aWYoZTwyKXJldHVybltdO3ZhciByPW5ldyBBcnJheShlLTEpO3JbZS0yXT10W2UtMV07Zm9yKHZhciBuPWUtMztuPj0wOy0tbilyW25dPXJbbisxXSp0W24rMV07cmV0dXJuIHJ9LGUudG9UeXBlZEFycmF5PWZ1bmN0aW9uKHQsZSxyKXtpZihcInN0cmluZ1wiPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBhIHN0cmluZ1tdIHRvIGEgVHlwZWRBcnJheVwiKTtpZihBcnJheS5pc0FycmF5KHQpJiYodD1pKHQpKSxyJiZzKHQsZSksZnVuY3Rpb24odCxlKXtyZXR1cm4gdCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSYmXCJmbG9hdDMyXCI9PT1lfHx0IGluc3RhbmNlb2YgSW50MzJBcnJheSYmXCJpbnQzMlwiPT09ZXx8dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkmJlwiYm9vbFwiPT09ZX0odCxlKSlyZXR1cm4gdDtpZihudWxsPT1lfHxcImZsb2F0MzJcIj09PWV8fFwiY29tcGxleDY0XCI9PT1lKXJldHVybiBuZXcgRmxvYXQzMkFycmF5KHQpO2lmKFwiaW50MzJcIj09PWUpcmV0dXJuIG5ldyBJbnQzMkFycmF5KHQpO2lmKFwiYm9vbFwiPT09ZSl7Zm9yKHZhciBuPW5ldyBVaW50OEFycmF5KHQubGVuZ3RoKSxvPTA7bzxuLmxlbmd0aDsrK28pMCE9PU1hdGgucm91bmQodFtvXSkmJihuW29dPTEpO3JldHVybiBufXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiK2UpfSxlLnRvTmVzdGVkQXJyYXk9ZnVuY3Rpb24odCxlKXtpZigwPT09dC5sZW5ndGgpcmV0dXJuIGVbMF07dmFyIHI9dC5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSk7aWYoMD09PXIpcmV0dXJuW107aWYociE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIltcIit0K1wiXSBkb2VzIG5vdCBtYXRjaCB0aGUgaW5wdXQgc2l6ZS5cIik7cmV0dXJuIGZ1bmN0aW9uIHQoZSxyLG4pe3ZhciBpPW5ldyBBcnJheTtpZigxPT09ci5sZW5ndGgpZm9yKHZhciBvPXJbMF0sYT0wO2E8bzthKyspaVthXT1uW2UrYV07ZWxzZXtvPXJbMF07dmFyIHU9ci5zbGljZSgxKSxzPXUucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0pO2ZvcihhPTA7YTxvO2ErKylpW2FdPXQoZSthKnMsdSxuKX1yZXR1cm4gaX0oMCx0LGUpfSxlLm1ha2VPbmVzVHlwZWRBcnJheT1mdW5jdGlvbih0LGUpe2Zvcih2YXIgcj1wKHQsZSksbj0wO248ci5sZW5ndGg7bisrKXJbbl09MTtyZXR1cm4gcn0sZS5tYWtlWmVyb3NUeXBlZEFycmF5PXAsZS5ub3c9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgcGVyZm9ybWFuY2UpcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBwcm9jZXNzKXt2YXIgdD1wcm9jZXNzLmhydGltZSgpO3JldHVybiAxZTMqdFswXSt0WzFdLzFlNn10aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbWVhc3VyZSB0aW1lIGluIHRoaXMgZW52aXJvbm1lbnQuIFlvdSBzaG91bGQgcnVuIHRmLmpzIGluIHRoZSBicm93c2VyIG9yIGluIE5vZGUuanNcIil9LGUuYXNzZXJ0Tm9uTmVnYXRpdmVJbnRlZ2VyRGltZW5zaW9ucz1mdW5jdGlvbih0KXt0LmZvckVhY2goZnVuY3Rpb24oZSl7bihOdW1iZXIuaXNJbnRlZ2VyKGUpJiZlPj0wLGZ1bmN0aW9uKCl7cmV0dXJuXCJUZW5zb3IgbXVzdCBoYXZlIGEgc2hhcGUgY29tcHJpc2VkIG9mIHBvc2l0aXZlIGludGVnZXJzIGJ1dCBnb3Qgc2hhcGUgW1wiK3QrXCJdLlwifSl9KX07dmFyIGQ9ZnVuY3Rpb24oKXtpZihudWxsIT1lbnZpcm9ubWVudC5FTlYuZ2xvYmFsLmZldGNoKXJldHVybiBlbnZpcm9ubWVudC5FTlYuZ2xvYmFsLmZldGNoO2lmKGVudmlyb25tZW50LkVOVi5nZXQoXCJJU19OT0RFXCIpKXJldHVybiBlLmdldE5vZGVGZXRjaC5mZXRjaEltcG9ydCgpO3Rocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHRoZSBmZXRjaCgpIG1ldGhvZC4gUGxlYXNlIGFkZCB5b3VyIG93biBmZXRjaCgpIGZ1bmN0aW9uIHRvIHRoZSBnbG9iYWwgbmFtZXNwYWNlLlwiKX07ZS5nZXROb2RlRmV0Y2g9e2ZldGNoSW1wb3J0OmZ1bmN0aW9uKCl7cmV0dXJuIHJlcXVpcmUoXCJub2RlLWZldGNoXCIpfX0sZS5mZXRjaD1mdW5jdGlvbih0LHIpe3JldHVybiBudWxsPT1lLnN5c3RlbUZldGNoJiYoZS5zeXN0ZW1GZXRjaD1kKCkpLGUuc3lzdGVtRmV0Y2godCxyKX19KTt1bndyYXBFeHBvcnRzKHV0aWwkMSk7dmFyIHV0aWxfMT11dGlsJDEuc2h1ZmZsZSx1dGlsXzI9dXRpbCQxLmNsYW1wLHV0aWxfMz11dGlsJDEubmVhcmVzdExhcmdlckV2ZW4sdXRpbF80PXV0aWwkMS5zdW0sdXRpbF81PXV0aWwkMS5yYW5kVW5pZm9ybSx1dGlsXzY9dXRpbCQxLmRpc3RTcXVhcmVkLHV0aWxfNz11dGlsJDEuYXNzZXJ0LHV0aWxfOD11dGlsJDEuYXNzZXJ0U2hhcGVzTWF0Y2gsdXRpbF85PXV0aWwkMS5hc3NlcnROb25OdWxsLHV0aWxfMTA9dXRpbCQxLmZsYXR0ZW4sdXRpbF8xMT11dGlsJDEuc2l6ZUZyb21TaGFwZSx1dGlsXzEyPXV0aWwkMS5pc1NjYWxhclNoYXBlLHV0aWxfMTM9dXRpbCQxLmFycmF5c0VxdWFsLHV0aWxfMTQ9dXRpbCQxLmlzSW50LHV0aWxfMTU9dXRpbCQxLnRhbmgsdXRpbF8xNj11dGlsJDEuc2l6ZVRvU3F1YXJpc2hTaGFwZSx1dGlsXzE3PXV0aWwkMS5jcmVhdGVTaHVmZmxlZEluZGljZXMsdXRpbF8xOD11dGlsJDEucmlnaHRQYWQsdXRpbF8xOT11dGlsJDEucmVwZWF0ZWRUcnksdXRpbF8yMD11dGlsJDEuaW5mZXJGcm9tSW1wbGljaXRTaGFwZSx1dGlsXzIxPXV0aWwkMS5wYXJzZUF4aXNQYXJhbSx1dGlsXzIyPXV0aWwkMS5zcXVlZXplU2hhcGUsdXRpbF8yMz11dGlsJDEuZ2V0VHlwZWRBcnJheUZyb21EVHlwZSx1dGlsXzI0PXV0aWwkMS5nZXRBcnJheUZyb21EVHlwZSx1dGlsXzI1PXV0aWwkMS5jaGVja0NvbXB1dGF0aW9uRm9yRXJyb3JzLHV0aWxfMjY9dXRpbCQxLmNoZWNrQ29udmVyc2lvbkZvckVycm9ycyx1dGlsXzI3PXV0aWwkMS5oYXNFbmNvZGluZ0xvc3MsdXRpbF8yOD11dGlsJDEuaXNUeXBlZEFycmF5LHV0aWxfMjk9dXRpbCQxLmJ5dGVzUGVyRWxlbWVudCx1dGlsXzMwPXV0aWwkMS5ieXRlc0Zyb21TdHJpbmdBcnJheSx1dGlsXzMxPXV0aWwkMS5pc1N0cmluZyx1dGlsXzMyPXV0aWwkMS5pc0Jvb2xlYW4sdXRpbF8zMz11dGlsJDEuaXNOdW1iZXIsdXRpbF8zND11dGlsJDEuaW5mZXJEdHlwZSx1dGlsXzM1PXV0aWwkMS5pc0Z1bmN0aW9uLHV0aWxfMzY9dXRpbCQxLm5lYXJlc3REaXZpc29yLHV0aWxfMzc9dXRpbCQxLmNvbXB1dGVTdHJpZGVzLHV0aWxfMzg9dXRpbCQxLnRvVHlwZWRBcnJheSx1dGlsXzM5PXV0aWwkMS50b05lc3RlZEFycmF5LHV0aWxfNDA9dXRpbCQxLm1ha2VPbmVzVHlwZWRBcnJheSx1dGlsXzQxPXV0aWwkMS5tYWtlWmVyb3NUeXBlZEFycmF5LHV0aWxfNDI9dXRpbCQxLm5vdyx1dGlsXzQzPXV0aWwkMS5hc3NlcnROb25OZWdhdGl2ZUludGVnZXJEaW1lbnNpb25zLHV0aWxfNDQ9dXRpbCQxLmdldE5vZGVGZXRjaCx1dGlsXzQ1PXV0aWwkMS5zeXN0ZW1GZXRjaCx1dGlsXzQ2PXV0aWwkMS5mZXRjaCxXZWJjYW1JdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscil7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO2lmKG4ud2ViY2FtVmlkZW9FbGVtZW50PWUsbi53ZWJjYW1Db25maWc9cixuLmlzQ2xvc2VkPSEwLG4ucmVzaXplPSExLG4ubmVlZFRvUmVzaXplKCkpaWYobi5yZXNpemU9ITAsbi5jcm9wU2l6ZT1bbi53ZWJjYW1Db25maWcucmVzaXplSGVpZ2h0LG4ud2ViY2FtQ29uZmlnLnJlc2l6ZVdpZHRoXSxuLmNyb3BCb3hJbmQ9dGVuc29yMWQoWzBdLFwiaW50MzJcIiksbi53ZWJjYW1Db25maWcuY2VudGVyQ3JvcCl7dmFyIGk9MSpuLndlYmNhbUNvbmZpZy5yZXNpemVXaWR0aC9uLndlYmNhbVZpZGVvRWxlbWVudC53aWR0aCxvPTEqbi53ZWJjYW1Db25maWcucmVzaXplSGVpZ2h0L24ud2ViY2FtVmlkZW9FbGVtZW50LmhlaWdodCxhPSgxLWkpLzIsdT0oMS1vKS8yLHM9YStpLGM9byt1O24uY3JvcEJveD10ZW5zb3IyZChbdSxhLGMsc10sWzEsNF0pfWVsc2Ugbi5jcm9wQm94PXRlbnNvcjJkKFswLDAsMSwxXSxbMSw0XSk7cmV0dXJuIG59cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oKXtyZXR1cm5cIndlYmNhbVwifSxlLmNyZWF0ZT1mdW5jdGlvbih0LHIpe3JldHVybiB2b2lkIDA9PT1yJiYocj17fSksX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBuO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGkpe3N3aXRjaChpLmxhYmVsKXtjYXNlIDA6aWYoRU5WLmdldChcIklTX05PREVcIikpdGhyb3cgbmV3IEVycm9yKFwidGYuZGF0YS53ZWJjYW0gaXMgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlciBlbnZpcm9ubWVudC5cIik7aWYoIXQpe2lmKHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpLCFyLnJlc2l6ZVdpZHRofHwhci5yZXNpemVIZWlnaHQpdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgd2ViY2FtIHZpZGVvIGVsZW1lbnQsIG9yIHJlc2l6ZVdpZHRoIGFuZCByZXNpemVIZWlnaHQgdG8gY3JlYXRlIGEgaGlkZGVuIHZpZGVvIGVsZW1lbnQuXCIpO3Qud2lkdGg9ci5yZXNpemVXaWR0aCx0LmhlaWdodD1yLnJlc2l6ZUhlaWdodH1yZXR1cm5bNCwobj1uZXcgZSh0LHIpKS5zdGFydCgpXTtjYXNlIDE6cmV0dXJuIGkuc2VudCgpLFsyLG5dfX0pfSl9LGUucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlLHI9dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOnRoaXMud2ViY2FtQ29uZmlnLmZhY2luZ01vZGUmJnV0aWxfNyhcInVzZXJcIj09PXRoaXMud2ViY2FtQ29uZmlnLmZhY2luZ01vZGV8fFwiZW52aXJvbm1lbnRcIj09PXRoaXMud2ViY2FtQ29uZmlnLmZhY2luZ01vZGUsZnVuY3Rpb24oKXtyZXR1cm5cIkludmFsaWQgd2ViY2FtIGZhY2luZyBtb2RlOiBcIityLndlYmNhbUNvbmZpZy5mYWNpbmdNb2RlK1wiLiBQbGVhc2UgcHJvdmlkZSAndXNlcicgb3IgJ2Vudmlyb25tZW50J1wifSksbi5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gbi50cnlzLnB1c2goWzEsMywsNF0pLHQ9dGhpcyxbNCxuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7dmlkZW86e2RldmljZUlkOnRoaXMud2ViY2FtQ29uZmlnLmRldmljZUlkLGZhY2luZ01vZGU6dGhpcy53ZWJjYW1Db25maWcuZmFjaW5nTW9kZT90aGlzLndlYmNhbUNvbmZpZy5mYWNpbmdNb2RlOlwidXNlclwiLHdpZHRoOnRoaXMud2ViY2FtVmlkZW9FbGVtZW50LndpZHRoLGhlaWdodDp0aGlzLndlYmNhbVZpZGVvRWxlbWVudC5oZWlnaHR9fSldO2Nhc2UgMjpyZXR1cm4gdC5zdHJlYW09bi5zZW50KCksWzMsNF07Y2FzZSAzOnRocm93KGU9bi5zZW50KCkpLm1lc3NhZ2U9XCJFcnJvciB0aHJvd24gd2hpbGUgaW5pdGlhbGl6aW5nIHZpZGVvIHN0cmVhbTogXCIrZS5tZXNzYWdlLGU7Y2FzZSA0OmlmKCF0aGlzLnN0cmVhbSl0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3Qgb2J0YWluIHZpZGVvIGZyb20gd2ViY2FtLlwiKTt0cnl7dGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQuc3JjT2JqZWN0PXRoaXMuc3RyZWFtfWNhdGNoKHQpe2NvbnNvbGUubG9nKHQpLHRoaXMud2ViY2FtVmlkZW9FbGVtZW50LnNyYz13aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTCh0aGlzLnN0cmVhbSl9cmV0dXJuIHRoaXMud2ViY2FtVmlkZW9FbGVtZW50LnBsYXkoKSx0aGlzLmlzQ2xvc2VkPSExLFsyLG5ldyBQcm9taXNlKGZ1bmN0aW9uKHQpe3Iud2ViY2FtVmlkZW9FbGVtZW50Lm9ubG9hZGVkbWV0YWRhdGE9ZnVuY3Rpb24oKXt0KCl9fSldfX0pfSl9LGUucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0O3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe2lmKHRoaXMuaXNDbG9zZWQpcmV0dXJuWzIse3ZhbHVlOm51bGwsZG9uZTohMH1dO3RyeXt0PWJyb3dzZXIuZnJvbVBpeGVscyh0aGlzLndlYmNhbVZpZGVvRWxlbWVudCl9Y2F0Y2godCl7dGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdGhyb3duIGNvbnZlcnRpbmcgdmlkZW8gdG8gcGl4ZWxzOiBcIitKU09OLnN0cmluZ2lmeSh0KSl9aWYoIXRoaXMucmVzaXplKXJldHVyblsyLHt2YWx1ZTp0LGRvbmU6ITF9XTt0cnl7cmV0dXJuWzIse3ZhbHVlOnRoaXMuY3JvcEFuZFJlc2l6ZUZyYW1lKHQpLGRvbmU6ITF9XX1jYXRjaCh0KXt0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB0aHJvd24gY3JvcHBpbmcgdGhlIHZpZGVvOiBcIit0Lm1lc3NhZ2UpfXJldHVyblsyXX0pfSl9LGUucHJvdG90eXBlLm5lZWRUb1Jlc2l6ZT1mdW5jdGlvbigpe3JldHVybiEoIXRoaXMud2ViY2FtQ29uZmlnLnJlc2l6ZVdpZHRofHwhdGhpcy53ZWJjYW1Db25maWcucmVzaXplSGVpZ2h0fHx0aGlzLndlYmNhbVZpZGVvRWxlbWVudC53aWR0aD09PXRoaXMud2ViY2FtQ29uZmlnLnJlc2l6ZVdpZHRoJiZ0aGlzLndlYmNhbVZpZGVvRWxlbWVudC5oZWlnaHQ9PT10aGlzLndlYmNhbUNvbmZpZy5yZXNpemVIZWlnaHQpfSxlLnByb3RvdHlwZS5jcm9wQW5kUmVzaXplRnJhbWU9ZnVuY3Rpb24odCl7dmFyIGUscj10LnRvRmxvYXQoKS5leHBhbmREaW1zKDApLG49KGU9aW1hZ2UuY3JvcEFuZFJlc2l6ZShyLHRoaXMuY3JvcEJveCx0aGlzLmNyb3BCb3hJbmQsdGhpcy5jcm9wU2l6ZSxcImJpbGluZWFyXCIpKS5zaGFwZTtyZXR1cm4gZS5yZXNoYXBlKG4uc2xpY2UoMSkpfSxlLnByb3RvdHlwZS5jYXB0dXJlPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMubmV4dCgpXTtjYXNlIDE6cmV0dXJuWzIsdC5zZW50KCkudmFsdWVdfX0pfSl9LGUucHJvdG90eXBlLnN0b3A9ZnVuY3Rpb24oKXt0aGlzLnN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnN0b3AoKX0pO3RyeXt0aGlzLndlYmNhbVZpZGVvRWxlbWVudC5zcmNPYmplY3Q9bnVsbH1jYXRjaCh0KXtjb25zb2xlLmxvZyh0KSx0aGlzLndlYmNhbVZpZGVvRWxlbWVudC5zcmM9bnVsbH10aGlzLmlzQ2xvc2VkPSEwfSxlLnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBjb252ZXJ0IGluZmluaXRlIHZpZGVvIHN0cmVhbSB0byBhcnJheS5cIil9LGV9KExhenlJdGVyYXRvciksRGF0YVNvdXJjZT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbigpe319KCksU3RyaW5nSXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3JldHVybiBudWxsIT09dCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLnNwbGl0PWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgU3BsaXRJdGVyYXRvcih0aGlzLHQpfSxlfShMYXp5SXRlcmF0b3IpLFNwbGl0SXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLHIpe3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi51cHN0cmVhbT1lLG4uaW1wbD1uZXcgU3BsaXRJdGVyYXRvckltcGwoZSxyKSxufXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW1wbC5zdW1tYXJ5KCl9LGUucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHQpe3JldHVyblsyLHRoaXMuaW1wbC5uZXh0KCldfSl9KX0sZX0oU3RyaW5nSXRlcmF0b3IpLFNwbGl0SXRlcmF0b3JJbXBsPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyKXt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4udXBzdHJlYW09ZSxuLnNlcGFyYXRvcj1yLG4uY2FycnlvdmVyPVwiXCIsbn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVwc3RyZWFtLnN1bW1hcnkoKStcIiAtPiBTcGxpdCgnXCIrdGhpcy5zZXBhcmF0b3IrXCInKVwifSxlLnByb3RvdHlwZS5wdW1wPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlLHIsbixpO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy51cHN0cmVhbS5uZXh0KCldO2Nhc2UgMTppZigodD1vLnNlbnQoKSkuZG9uZSlyZXR1cm5cIlwiPT09dGhpcy5jYXJyeW92ZXI/WzIsITFdOih0aGlzLm91dHB1dFF1ZXVlLnB1c2godGhpcy5jYXJyeW92ZXIpLHRoaXMuY2FycnlvdmVyPVwiXCIsWzIsITBdKTtmb3IoKGU9dC52YWx1ZS5zcGxpdCh0aGlzLnNlcGFyYXRvcikpWzBdPXRoaXMuY2FycnlvdmVyK2VbMF0scj0wLG49ZS5zbGljZSgwLC0xKTtyPG4ubGVuZ3RoO3IrKylpPW5bcl0sdGhpcy5vdXRwdXRRdWV1ZS5wdXNoKGkpO3JldHVybiB0aGlzLmNhcnJ5b3Zlcj1lW2UubGVuZ3RoLTFdLFsyLCEwXX19KX0pfSxlfShPbmVUb01hbnlJdGVyYXRvciksQnl0ZUNodW5rSXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3JldHVybiBudWxsIT09dCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLmRlY29kZVVURjg9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFV0ZjhJdGVyYXRvcih0aGlzKX0sZX0oTGF6eUl0ZXJhdG9yKSxVdGY4SXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXt2YXIgcj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIHIudXBzdHJlYW09ZSxyLmltcGw9bmV3IFV0ZjhJdGVyYXRvckltcGwoZSkscn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmltcGwuc3VtbWFyeSgpfSxlLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtyZXR1cm5bMix0aGlzLmltcGwubmV4dCgpXX0pfSl9LGV9KFN0cmluZ0l0ZXJhdG9yKSxVdGY4SXRlcmF0b3JJbXBsPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIHI9dC5jYWxsKHRoaXMpfHx0aGlzO2lmKHIudXBzdHJlYW09ZSxFTlYuZ2V0KFwiSVNfQlJPV1NFUlwiKSlyLmRlY29kZXI9bmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7ZWxzZXt2YXIgbj1yZXF1aXJlKFwic3RyaW5nX2RlY29kZXJcIikuU3RyaW5nRGVjb2RlcjtyLmRlY29kZXI9bmV3IG4oXCJ1dGY4XCIpfXJldHVybiByfXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudXBzdHJlYW0uc3VtbWFyeSgpK1wiIC0+IFV0ZjhcIn0sZS5wcm90b3R5cGUucHVtcD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZSxyO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy51cHN0cmVhbS5uZXh0KCldO2Nhc2UgMTpyZXR1cm4odD1uLnNlbnQoKSkuZG9uZT9bMiwhMV06KGU9dC52YWx1ZSxyPUVOVi5nZXQoXCJJU19CUk9XU0VSXCIpP3RoaXMuZGVjb2Rlci5kZWNvZGUoZSx7c3RyZWFtOiEwfSk6dGhpcy5kZWNvZGVyLndyaXRlKEJ1ZmZlci5mcm9tKGUuYnVmZmVyKSksdGhpcy5vdXRwdXRRdWV1ZS5wdXNoKHIpLFsyLCEwXSl9fSl9KX0sZX0oT25lVG9NYW55SXRlcmF0b3IpLEZpbGVDaHVua0l0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyKXt2b2lkIDA9PT1yJiYocj17fSk7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLmZpbGU9ZSxuLm9wdGlvbnM9cix1dGlsLmFzc2VydChlIGluc3RhbmNlb2YgVWludDhBcnJheXx8ISFFTlYuZ2V0KFwiSVNfQlJPV1NFUlwiKSYmKGUgaW5zdGFuY2VvZiBGaWxlfHxlIGluc3RhbmNlb2YgQmxvYiksZnVuY3Rpb24oKXtyZXR1cm5cIkZpbGVDaHVua0l0ZXJhdG9yIG9ubHkgc3VwcG9ydHMgRmlsZSwgQmxvYiBhbmQgVWludDhBcnJheSByaWdodCBub3cuXCJ9KSxuLm9mZnNldD1yLm9mZnNldHx8MCxuLmNodW5rU2l6ZT1yLmNodW5rU2l6ZXx8MTA0ODU3NixufXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuXCJGaWxlQ2h1bmtzIFwiK3RoaXMuZmlsZX0sZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZSxyPXRoaXM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm4gdGhpcy5vZmZzZXQ+PSh0aGlzLmZpbGUgaW5zdGFuY2VvZiBVaW50OEFycmF5P3RoaXMuZmlsZS5ieXRlTGVuZ3RoOnRoaXMuZmlsZS5zaXplKT9bMix7dmFsdWU6bnVsbCxkb25lOiEwfV06KHQ9bmV3IFByb21pc2UoZnVuY3Rpb24odCxlKXt2YXIgbj1yLm9mZnNldCtyLmNodW5rU2l6ZTtpZihyLmZpbGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KXQobmV3IFVpbnQ4QXJyYXkoci5maWxlLnNsaWNlKHIub2Zmc2V0LG4pKSk7ZWxzZXt2YXIgaT1uZXcgRmlsZVJlYWRlcjtpLm9ubG9hZD1mdW5jdGlvbihyKXt2YXIgbj1pLnJlc3VsdDtpZihuIGluc3RhbmNlb2YgQXJyYXlCdWZmZXImJihuPW5ldyBVaW50OEFycmF5KG4pKSwhKG4gaW5zdGFuY2VvZiBVaW50OEFycmF5KSlyZXR1cm4gZShuZXcgVHlwZUVycm9yKFwiRmlsZVJlYWRlciByZXR1cm5lZCB1bmtub3duIHR5cGUuXCIpKTt0KG4pfSxpLm9uYWJvcnQ9ZnVuY3Rpb24odCl7cmV0dXJuIGUobmV3IEVycm9yKFwiQWJvcnRlZFwiKSl9LGkub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gZShuZXcgRXJyb3IodC50eXBlKSl9O3ZhciBvPXIuZmlsZS5zbGljZShyLm9mZnNldCxuKTtpLnJlYWRBc0FycmF5QnVmZmVyKG8pfXIub2Zmc2V0PW59KSxlPXt9LFs0LHRdKTtjYXNlIDE6cmV0dXJuWzIsKGUudmFsdWU9bi5zZW50KCksZS5kb25lPSExLGUpXX19KX0pfSxlfShCeXRlQ2h1bmtJdGVyYXRvcik7ZnVuY3Rpb24gdXJsQ2h1bmtJdGVyYXRvcih0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT17fSksX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciByLG4saSxvO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGEpe3N3aXRjaChhLmxhYmVsKXtjYXNlIDA6cmV0dXJuIEVOVi5nZXQoXCJJU19CUk9XU0VSXCIpP1s0LGZldGNoKHQpXTpbMyw1XTtjYXNlIDE6cmV0dXJuKHI9YS5zZW50KCkpLm9rP1s0LHIuYmxvYigpXTpbMywzXTtjYXNlIDI6cmV0dXJuIG49YS5zZW50KCksWzIsbmV3IEZpbGVDaHVua0l0ZXJhdG9yKG4sZSldO2Nhc2UgMzp0aHJvdyBuZXcgRXJyb3Ioci5zdGF0dXNUZXh0KTtjYXNlIDQ6cmV0dXJuWzMsOV07Y2FzZSA1OmlmKGk9cmVxdWlyZShcIm5vZGUtZmV0Y2hcIiksXCJzdHJpbmdcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKFwiVVJMIG11c3QgYmUgYSBzdHJpbmcuIFJlcXVlc3Qgb2JqZWN0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGUgbm9kZS5qcyBlbnZpcm9ubWVudCB5ZXQuXCIpO3JldHVybls0LGkodCldO2Nhc2UgNjpyZXR1cm4ocj1hLnNlbnQoKSkub2s/WzQsci5idWZmZXIoKV06WzMsOF07Y2FzZSA3OnJldHVybiBvPWEuc2VudCgpLFsyLG5ldyBGaWxlQ2h1bmtJdGVyYXRvcihvLGUpXTtjYXNlIDg6dGhyb3cgbmV3IEVycm9yKHIuc3RhdHVzVGV4dCk7Y2FzZSA5OnJldHVyblsyXX19KX0pfWZ1bmN0aW9uIGlzTG9jYWxQYXRoKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0JiZcImZpbGU6Ly9cIj09PXQuc3Vic3RyKDAsNyl9dmFyIEZpbGVEYXRhU291cmNlPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyKXt2b2lkIDA9PT1yJiYocj17fSk7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLmlucHV0PWUsbi5vcHRpb25zPXIsbn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuaXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0O3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiBpc0xvY2FsUGF0aCh0aGlzLmlucHV0KSYmRU5WLmdldChcIklTX05PREVcIikmJih0PXJlcXVpcmUoXCJmc1wiKSx0aGlzLmlucHV0PXQucmVhZEZpbGVTeW5jKHRoaXMuaW5wdXQuc3Vic3RyKDcpKSksWzIsbmV3IEZpbGVDaHVua0l0ZXJhdG9yKHRoaXMuaW5wdXQsdGhpcy5vcHRpb25zKV19KX0pfSxlfShEYXRhU291cmNlKSxVUkxEYXRhU291cmNlPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyKXt2b2lkIDA9PT1yJiYocj17fSk7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLnVybD1lLG4uZmlsZU9wdGlvbnM9cixufXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5pdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIGlzTG9jYWxQYXRoKHRoaXMudXJsKT9bMixuZXcgRmlsZURhdGFTb3VyY2UodGhpcy51cmwsdGhpcy5maWxlT3B0aW9ucykuaXRlcmF0b3IoKV06WzIsdXJsQ2h1bmtJdGVyYXRvcih0aGlzLnVybCx0aGlzLmZpbGVPcHRpb25zKV19KX0pfSxlfShEYXRhU291cmNlKTtmdW5jdGlvbiBjc3YodCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9e30pLG5ldyBDU1ZEYXRhc2V0KG5ldyBVUkxEYXRhU291cmNlKHQpLGUpfWZ1bmN0aW9uIGZ1bmModCl7dmFyIGU9dGhpcyxyPWl0ZXJhdG9yRnJvbUZ1bmN0aW9uKHQpO3JldHVybiBkYXRhc2V0RnJvbUl0ZXJhdG9yRm4oZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKGUsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHQpe3JldHVyblsyLHJdfSl9KX0pfWZ1bmN0aW9uIGdlbmVyYXRvcih0KXt2YXIgZT10aGlzO3JldHVybiBkYXRhc2V0RnJvbUl0ZXJhdG9yRm4oZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKGUsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdCgpXTtjYXNlIDE6cmV0dXJuIGU9ci5zZW50KCksWzIsaXRlcmF0b3JGcm9tRnVuY3Rpb24oZnVuY3Rpb24oKXtyZXR1cm4gZS5uZXh0KCl9KV19fSl9KX0pfWZ1bmN0aW9uIHdlYmNhbSh0LGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7cmV0dXJuWzIsV2ViY2FtSXRlcmF0b3IuY3JlYXRlKHQsZSldfSl9KX12YXIgdmVyc2lvbj1cIjEuMS4yXCI7ZXhwb3J0e2FycmF5LERhdGFzZXQsemlwLENTVkRhdGFzZXQsVGV4dExpbmVEYXRhc2V0LGNzdixmdW5jLGdlbmVyYXRvcix3ZWJjYW0sRmlsZURhdGFTb3VyY2UsVVJMRGF0YVNvdXJjZSx2ZXJzaW9uIGFzIHZlcnNpb25fZGF0YX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10Zi1kYXRhLmVzbS5qcy5tYXBcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmltcG9ydHtiYWNrZW5kLHV0aWwsdGlkeSxvbmVzTGlrZSxzY2FsYXIsdGVuc29yMWQsd2hlcmUsemVyb3NMaWtlLHRyYWluLGNhc3QsZGlzcG9zZSxtZW1vcnksc2VyaWFsaXphdGlvbixhZGQsbXVsLGRpdixrZWVwLG5leHRGcmFtZSxUZW5zb3IsT3B0aW1pemVyLGNvbmNhdCxtZWFuLGlvLHRyYW5zcG9zZSxleHBhbmREaW1zLHJldmVyc2UsdW5zdGFjayxzdGFjayx6ZXJvcyxzdW0sc3BsaXQsbmVnLHZhcmlhYmxlLG9uZXMsZXllLHJhbmRvbVVuaWZvcm0sdHJ1bmNhdGVkTm9ybWFsLHJhbmRvbU5vcm1hbCxzdWIsc3FydCxtdWxTdHJpY3QsY2xpcEJ5VmFsdWUscmVsdSxsaW5hbGcsbGVha3lSZWx1LHByZWx1LGVsdSxjb252MWQsY29udjJkLGNvbnYzZCxjb252MmRUcmFuc3Bvc2Usc2VwYXJhYmxlQ29udjJkLGRlcHRod2lzZUNvbnYyZCxhbnksbm90RXF1YWwsbG9naWNhbEFuZCxtYXhpbXVtLG1pbmltdW0sYWxsLGJhdGNoTm9ybTJkLGJhdGNoTm9ybTNkLGJhdGNoTm9ybTRkLG1vbWVudHMscGFkLG1heFBvb2wsYXZnUG9vbCxzcXVlZXplLG1heCxncmVhdGVyRXF1YWwsZmlsbCxhYnMsbG9nLHNvZnRwbHVzLHNvZnRtYXgsZmxvb3Isb25lSG90LGdyZWF0ZXIsZXF1YWwsYXJnTWF4LHNsaWNlMWQsc2xpY2UyZCxzbGljZTNkLHNsaWNlNGQsY29uY2F0MWQsY29uY2F0MmQsY29uY2F0M2QsY29uY2F0NGQsdGlsZSxmdXNlZCxnYXRoZXIsc3RlcCxtaW4sc2VsdSxzaWdtb2lkLHRhbmh9ZnJvbVwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCI7dmFyIGV4dGVuZFN0YXRpY3M9ZnVuY3Rpb24oZSx0KXtyZXR1cm4oZXh0ZW5kU3RhdGljcz1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24oZSx0KXtlLl9fcHJvdG9fXz10fXx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG4gaW4gdCl0Lmhhc093blByb3BlcnR5KG4pJiYoZVtuXT10W25dKX0pKGUsdCl9O2Z1bmN0aW9uIF9fZXh0ZW5kcyhlLHQpe2Z1bmN0aW9uIG4oKXt0aGlzLmNvbnN0cnVjdG9yPWV9ZXh0ZW5kU3RhdGljcyhlLHQpLGUucHJvdG90eXBlPW51bGw9PT10P09iamVjdC5jcmVhdGUodCk6KG4ucHJvdG90eXBlPXQucHJvdG90eXBlLG5ldyBuKX12YXIgX2Vwc2lsb24sX19hc3NpZ249ZnVuY3Rpb24oKXtyZXR1cm4oX19hc3NpZ249T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciB0LG49MSxyPWFyZ3VtZW50cy5sZW5ndGg7bjxyO24rKylmb3IodmFyIGkgaW4gdD1hcmd1bWVudHNbbl0pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsaSkmJihlW2ldPXRbaV0pO3JldHVybiBlfSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtmdW5jdGlvbiBfX2F3YWl0ZXIoZSx0LG4scil7cmV0dXJuIG5ldyhufHwobj1Qcm9taXNlKSkoZnVuY3Rpb24oaSxhKXtmdW5jdGlvbiBvKGUpe3RyeXtsKHIubmV4dChlKSl9Y2F0Y2goZSl7YShlKX19ZnVuY3Rpb24gcyhlKXt0cnl7bChyLnRocm93KGUpKX1jYXRjaChlKXthKGUpfX1mdW5jdGlvbiBsKGUpe2UuZG9uZT9pKGUudmFsdWUpOm5ldyBuKGZ1bmN0aW9uKHQpe3QoZS52YWx1ZSl9KS50aGVuKG8scyl9bCgocj1yLmFwcGx5KGUsdHx8W10pKS5uZXh0KCkpfSl9ZnVuY3Rpb24gX19nZW5lcmF0b3IoZSx0KXt2YXIgbixyLGksYSxvPXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZigxJmlbMF0pdGhyb3cgaVsxXTtyZXR1cm4gaVsxXX0sdHJ5czpbXSxvcHM6W119O3JldHVybiBhPXtuZXh0OnMoMCksdGhyb3c6cygxKSxyZXR1cm46cygyKX0sXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYoYVtTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxhO2Z1bmN0aW9uIHMoYSl7cmV0dXJuIGZ1bmN0aW9uKHMpe3JldHVybiBmdW5jdGlvbihhKXtpZihuKXRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO2Zvcig7bzspdHJ5e2lmKG49MSxyJiYoaT0yJmFbMF0/ci5yZXR1cm46YVswXT9yLnRocm93fHwoKGk9ci5yZXR1cm4pJiZpLmNhbGwociksMCk6ci5uZXh0KSYmIShpPWkuY2FsbChyLGFbMV0pKS5kb25lKXJldHVybiBpO3N3aXRjaChyPTAsaSYmKGE9WzImYVswXSxpLnZhbHVlXSksYVswXSl7Y2FzZSAwOmNhc2UgMTppPWE7YnJlYWs7Y2FzZSA0OnJldHVybiBvLmxhYmVsKysse3ZhbHVlOmFbMV0sZG9uZTohMX07Y2FzZSA1Om8ubGFiZWwrKyxyPWFbMV0sYT1bMF07Y29udGludWU7Y2FzZSA3OmE9by5vcHMucG9wKCksby50cnlzLnBvcCgpO2NvbnRpbnVlO2RlZmF1bHQ6aWYoIShpPShpPW8udHJ5cykubGVuZ3RoPjAmJmlbaS5sZW5ndGgtMV0pJiYoNj09PWFbMF18fDI9PT1hWzBdKSl7bz0wO2NvbnRpbnVlfWlmKDM9PT1hWzBdJiYoIWl8fGFbMV0+aVswXSYmYVsxXTxpWzNdKSl7by5sYWJlbD1hWzFdO2JyZWFrfWlmKDY9PT1hWzBdJiZvLmxhYmVsPGlbMV0pe28ubGFiZWw9aVsxXSxpPWE7YnJlYWt9aWYoaSYmby5sYWJlbDxpWzJdKXtvLmxhYmVsPWlbMl0sby5vcHMucHVzaChhKTticmVha31pWzJdJiZvLm9wcy5wb3AoKSxvLnRyeXMucG9wKCk7Y29udGludWV9YT10LmNhbGwoZSxvKX1jYXRjaChlKXthPVs2LGVdLHI9MH1maW5hbGx5e249aT0wfWlmKDUmYVswXSl0aHJvdyBhWzFdO3JldHVybnt2YWx1ZTphWzBdP2FbMV06dm9pZCAwLGRvbmU6ITB9fShbYSxzXSl9fX1mdW5jdGlvbiBlcHNpbG9uKCl7cmV0dXJuIG51bGw9PV9lcHNpbG9uJiYoX2Vwc2lsb249YmFja2VuZCgpLmVwc2lsb24oKSksX2Vwc2lsb259ZnVuY3Rpb24gaW1hZ2VEYXRhRm9ybWF0KCl7cmV0dXJuXCJjaGFubmVsc0xhc3RcIn12YXIgQXR0cmlidXRlRXJyb3I9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuKXt2YXIgcj1lLmNhbGwodGhpcyxuKXx8dGhpcztyZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKHIsdC5wcm90b3R5cGUpLHJ9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHR9KEVycm9yKSxSdW50aW1lRXJyb3I9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuKXt2YXIgcj1lLmNhbGwodGhpcyxuKXx8dGhpcztyZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKHIsdC5wcm90b3R5cGUpLHJ9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHR9KEVycm9yKSxWYWx1ZUVycm9yPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobil7dmFyIHI9ZS5jYWxsKHRoaXMsbil8fHRoaXM7cmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihyLHQucHJvdG90eXBlKSxyfXJldHVybiBfX2V4dGVuZHModCxlKSx0fShFcnJvciksTm90SW1wbGVtZW50ZWRFcnJvcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KG4pe3ZhciByPWUuY2FsbCh0aGlzLG4pfHx0aGlzO3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2Yocix0LnByb3RvdHlwZSkscn1yZXR1cm4gX19leHRlbmRzKHQsZSksdH0oRXJyb3IpLEFzc2VydGlvbkVycm9yPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobil7dmFyIHI9ZS5jYWxsKHRoaXMsbil8fHRoaXM7cmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihyLHQucHJvdG90eXBlKSxyfXJldHVybiBfX2V4dGVuZHModCxlKSx0fShFcnJvciksSW5kZXhFcnJvcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KG4pe3ZhciByPWUuY2FsbCh0aGlzLG4pfHx0aGlzO3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2Yocix0LnByb3RvdHlwZSkscn1yZXR1cm4gX19leHRlbmRzKHQsZSksdH0oRXJyb3IpO2Z1bmN0aW9uIHB5TGlzdFJlcGVhdChlLHQpe2lmKEFycmF5LmlzQXJyYXkoZSkpe2Zvcih2YXIgbj1bXSxyPTA7cjx0O3IrKyluPW4uY29uY2F0KGUpO3JldHVybiBufXJldHVybihuPW5ldyBBcnJheSh0KSkuZmlsbChlKSxufWZ1bmN0aW9uIGFzc2VydChlLHQpe2lmKCFlKXRocm93IG5ldyBBc3NlcnRpb25FcnJvcih0KX1mdW5jdGlvbiBjb3VudChlLHQpe2Zvcih2YXIgbj0wLHI9MCxpPWU7cjxpLmxlbmd0aDtyKyspe2lbcl09PT10JiZuKyt9cmV0dXJuIG59ZnVuY3Rpb24gc2luZ2xldG9uT3JBcnJheShlKXtyZXR1cm4gMT09PWUubGVuZ3RoP2VbMF06ZX1mdW5jdGlvbiB0b0xpc3QoZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/ZTpbZV19ZnVuY3Rpb24gdG9TbmFrZUNhc2UoZSl7dmFyIHQ9ZS5yZXBsYWNlKC8oLikoW0EtWl1bYS16MC05XSspL2csXCIkMV8kMlwiKS5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLFwiJDFfJDJcIikudG9Mb3dlckNhc2UoKTtyZXR1cm5cIl9cIiE9PXRbMF0/dDpcInByaXZhdGVcIit0fWZ1bmN0aW9uIHRvQ2FtZWxDYXNlKGUpe3JldHVybiBlLmxlbmd0aDw9MT9lOi0xPT09ZS5pbmRleE9mKFwiX1wiKT9lOmUucmVwbGFjZSgvW19dKyhcXHd8JCkvZyxmdW5jdGlvbihlLHQpe3JldHVybiB0LnRvVXBwZXJDYXNlKCl9KX12YXIgX0dMT0JBTF9DVVNUT01fT0JKRUNUUz17fTtmdW5jdGlvbiBzZXJpYWxpemVLZXJhc09iamVjdChlKXtpZihudWxsPT09ZXx8dm9pZCAwPT09ZSlyZXR1cm4gbnVsbDt2YXIgdD17fTtyZXR1cm4gdC5jbGFzc05hbWU9ZS5nZXRDbGFzc05hbWUoKSx0LmNvbmZpZz1lLmdldENvbmZpZygpLHR9ZnVuY3Rpb24gY29udmVydE5EQXJyYXlTY2FsYXJzSW5Db25maWcoZSl7aWYobnVsbCE9ZSYmXCJvYmplY3RcIj09dHlwZW9mIGUpaWYoQXJyYXkuaXNBcnJheShlKSllLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGNvbnZlcnROREFycmF5U2NhbGFyc0luQ29uZmlnKGUpfSk7ZWxzZSBmb3IodmFyIHQ9MCxuPU9iamVjdC5rZXlzKGUpO3Q8bi5sZW5ndGg7dCsrKXt2YXIgcj1uW3RdLGk9ZVtyXTtudWxsIT1pJiZcIm9iamVjdFwiPT10eXBlb2YgaSYmKEFycmF5LmlzQXJyYXkoaSl8fFwibmRhcnJheVwiIT09aS50eXBlfHxcIm51bWJlclwiIT10eXBlb2YgaS52YWx1ZT9jb252ZXJ0TkRBcnJheVNjYWxhcnNJbkNvbmZpZyhpKTplW3JdPWkudmFsdWUpfX1mdW5jdGlvbiBkZXNlcmlhbGl6ZUtlcmFzT2JqZWN0KGUsdCxuLHIsaSl7dmFyIGEsbyxzO2lmKHZvaWQgMD09PXQmJih0PXt9KSx2b2lkIDA9PT1uJiYobj17fSksdm9pZCAwPT09ciYmKHI9XCJvYmplY3RcIiksdm9pZCAwPT09aSYmKGk9ITEpLFwic3RyaW5nXCI9PXR5cGVvZiBlKXt2YXIgbD1lLHU9dm9pZCAwO2lmKGwgaW4gbil1PW5bbF07ZWxzZSBpZihsIGluIF9HTE9CQUxfQ1VTVE9NX09CSkVDVFMpdT1fR0xPQkFMX0NVU1RPTV9PQkpFQ1RTW2xdO2Vsc2UgaWYobnVsbD09KHU9dFtsXSkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJVbmtub3duIFwiK3IrXCI6IFwiK2UrXCIuIFRoaXMgbWF5IGJlIGR1ZSB0byBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFRoZSBcIityK1wiIGlzIGRlZmluZWQgaW4gUHl0aG9uLCBpbiB3aGljaCBjYXNlIGl0IG5lZWRzIHRvIGJlIHBvcnRlZCB0byBUZW5zb3JGbG93LmpzIG9yIHlvdXIgSmF2YVNjcmlwdCBjb2RlLlxcbjIuIFRoZSBjdXN0b20gXCIrcitcIiBpcyBkZWZpbmVkIGluIEphdmFTY3JpcHQsIGJ1dCBpcyBub3QgcmVnaXN0ZXJlZCBwcm9wZXJseSB3aXRoIHRmLnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcygpLlwiKTtyZXR1cm4gdX12YXIgYz1lO2lmKG51bGw9PWMuY2xhc3NOYW1lfHxudWxsPT1jLmNvbmZpZyl0aHJvdyBuZXcgVmFsdWVFcnJvcihyK1wiOiBJbXByb3BlciBjb25maWcgZm9ybWF0OiBcIitKU09OLnN0cmluZ2lmeShjKStcIi5cXG4nY2xhc3NOYW1lJyBhbmQgJ2NvbmZpZycgbXVzdCBzZXQuXCIpO3ZhciBwPWMuY2xhc3NOYW1lLGg9dm9pZCAwLGQ9dm9pZCAwO2lmKHAgaW4gbj8oaD0oYT1uW3BdKVswXSxkPWFbMV0pOnAgaW4gX0dMT0JBTF9DVVNUT01fT0JKRUNUUz8oaD0obz1fR0xPQkFMX0NVU1RPTV9PQkpFQ1RTLmNsYXNzTmFtZSlbMF0sZD1vWzFdKTpwIGluIHQmJihoPShzPXRbcF0pWzBdLGQ9c1sxXSksbnVsbD09aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlVua25vd24gXCIrcitcIjogXCIrcCtcIi4gVGhpcyBtYXkgYmUgZHVlIHRvIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gVGhlIFwiK3IrXCIgaXMgZGVmaW5lZCBpbiBQeXRob24sIGluIHdoaWNoIGNhc2UgaXQgbmVlZHMgdG8gYmUgcG9ydGVkIHRvIFRlbnNvckZsb3cuanMgb3IgeW91ciBKYXZhU2NyaXB0IGNvZGUuXFxuMi4gVGhlIGN1c3RvbSBcIityK1wiIGlzIGRlZmluZWQgaW4gSmF2YVNjcmlwdCwgYnV0IGlzIG5vdCByZWdpc3RlcmVkIHByb3Blcmx5IHdpdGggdGYuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKCkuXCIpO2lmKG51bGwhPWQpe2Zvcih2YXIgZj17fSxnPTAsbT1PYmplY3Qua2V5cyhfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTKTtnPG0ubGVuZ3RoO2crKyl7ZltTPW1bZ11dPV9HTE9CQUxfQ1VTVE9NX09CSkVDVFNbU119Zm9yKHZhciB5PTAsdj1PYmplY3Qua2V5cyhuKTt5PHYubGVuZ3RoO3krKyl7ZltTPXZbeV1dPW5bU119Yy5jb25maWcuY3VzdG9tT2JqZWN0cz1mO2Zvcih2YXIgYj1fX2Fzc2lnbih7fSxfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTKSx3PTAsej1PYmplY3Qua2V5cyhuKTt3PHoubGVuZ3RoO3crKyl7dmFyIFM9elt3XTtfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTW1NdPW5bU119Y29udmVydE5EQXJyYXlTY2FsYXJzSW5Db25maWcoYy5jb25maWcpO3ZhciBJPWQoaCxjLmNvbmZpZyxuLGkpO3JldHVybiBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTPV9fYXNzaWduKHt9LGIpLEl9Yj1fX2Fzc2lnbih7fSxfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTKTtmb3IodmFyIEE9MCxfPU9iamVjdC5rZXlzKG4pO0E8Xy5sZW5ndGg7QSsrKXtTPV9bQV07X0dMT0JBTF9DVVNUT01fT0JKRUNUU1tTXT1uW1NdfUk9bmV3IGgoYy5jb25maWcpO3JldHVybiBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTPV9fYXNzaWduKHt9LGIpLEl9ZnVuY3Rpb24gbnVtYmVyQ29tcGFyZShlLHQpe3JldHVybiBlPHQ/LTE6ZT50PzE6MH1mdW5jdGlvbiByZXZlcnNlTnVtYmVyQ29tcGFyZShlLHQpe3JldHVybi0xKm51bWJlckNvbXBhcmUoZSx0KX1mdW5jdGlvbiB1bmlxdWUoZSl7aWYobnVsbD09ZSlyZXR1cm4gZTtmb3IodmFyIHQ9W10sbj0wLHI9ZTtuPHIubGVuZ3RoO24rKyl7dmFyIGk9cltuXTstMT09PXQuaW5kZXhPZihpKSYmdC5wdXNoKGkpfXJldHVybiB0fWZ1bmN0aW9uIGlzT2JqZWN0RW1wdHkoZSl7aWYobnVsbD09ZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkludmFsaWQgdmFsdWUgaW4gb2JqOiBcIitKU09OLnN0cmluZ2lmeShlKSk7Zm9yKHZhciB0IGluIGUpaWYoZS5oYXNPd25Qcm9wZXJ0eSh0KSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBjaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKGUsdCxuKXtpZihudWxsIT1uJiZlLmluZGV4T2Yobik8MCl0aHJvdyBuZXcgVmFsdWVFcnJvcihuK1wiIGlzIG5vdCBhIHZhbGlkIFwiK3QrXCIuICBWYWxpZCB2YWx1ZXMgYXJlIFwiK2UrXCIgb3IgbnVsbC91bmRlZmluZWQuXCIpfWZ1bmN0aW9uIGNoZWNrQXJyYXlUeXBlQW5kTGVuZ3RoKGUsdCxuLHIpe3JldHVybiB2b2lkIDA9PT1uJiYobj0wKSx2b2lkIDA9PT1yJiYocj0xLzApLGFzc2VydChuPj0wKSxhc3NlcnQocj49biksQXJyYXkuaXNBcnJheShlKSYmZS5sZW5ndGg+PW4mJmUubGVuZ3RoPD1yJiZlLmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZT09PXR9KX1mdW5jdGlvbiBhc3NlcnRQb3NpdGl2ZUludGVnZXIoZSx0KXtBcnJheS5pc0FycmF5KGUpPyh1dGlsLmFzc2VydChlLmxlbmd0aD4wLGZ1bmN0aW9uKCl7cmV0dXJuIHQrXCIgaXMgdW5leHBlY3RlZGx5IGFuIGVtcHR5IGFycmF5LlwifSksZS5mb3JFYWNoKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGFzc2VydFBvc2l0aXZlSW50ZWdlcihlLFwiZWxlbWVudCBcIisobisxKStcIiBvZiBcIit0KX0pKTp1dGlsLmFzc2VydChOdW1iZXIuaXNJbnRlZ2VyKGUpJiZlPjAsZnVuY3Rpb24oKXtyZXR1cm5cIkV4cGVjdGVkIFwiK3QrXCIgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBidXQgZ290IFwiK2Zvcm1hdEFzRnJpZW5kbHlTdHJpbmcoZSkrXCIuXCJ9KX1mdW5jdGlvbiBmb3JtYXRBc0ZyaWVuZGx5U3RyaW5nKGUpe3JldHVybiBudWxsPT09ZT9cIm51bGxcIjpBcnJheS5pc0FycmF5KGUpP1wiW1wiK2UubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBmb3JtYXRBc0ZyaWVuZGx5U3RyaW5nKGUpfSkuam9pbihcIixcIikrXCJdXCI6XCJzdHJpbmdcIj09dHlwZW9mIGU/J1wiJytlKydcIic6XCJcIitlfWZ1bmN0aW9uIGRlYm91bmNlKGUsdCl7dmFyIG4scj11dGlsLm5vdygpO3JldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgaT1bXSxhPTA7YTxhcmd1bWVudHMubGVuZ3RoO2ErKylpW2FdPWFyZ3VtZW50c1thXTt2YXIgbz11dGlsLm5vdygpO3JldHVybiBvLXI8dD9uOihyPW8sbj1lLmFwcGx5KHZvaWQgMCxpKSl9fWZ1bmN0aW9uIGNhbGNMMk5vcm1zKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gc3FydChzdW0obXVsU3RyaWN0KGUsZSksdCwhMCkpfSl9dmFyIENvbnN0cmFpbnQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybnt9fSx0fShzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZSksTWF4Tm9ybT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5kZWZhdWx0TWF4VmFsdWU9MixuLmRlZmF1bHRBeGlzPTAsbi5tYXhWYWx1ZT1udWxsIT10Lm1heFZhbHVlP3QubWF4VmFsdWU6bi5kZWZhdWx0TWF4VmFsdWUsbi5heGlzPW51bGwhPXQuYXhpcz90LmF4aXM6bi5kZWZhdWx0QXhpcyxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49Y2FsY0wyTm9ybXMoZSx0LmF4aXMpLHI9Y2xpcEJ5VmFsdWUobiwwLHQubWF4VmFsdWUpO3JldHVybiBtdWwoZSxkaXYocixhZGQoZXBzaWxvbigpLG4pKSl9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue21heFZhbHVlOnRoaXMubWF4VmFsdWUsYXhpczp0aGlzLmF4aXN9fSx0LmNsYXNzTmFtZT1cIk1heE5vcm1cIix0fShDb25zdHJhaW50KTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTWF4Tm9ybSk7dmFyIFVuaXROb3JtPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLmRlZmF1bHRBeGlzPTAsbi5heGlzPW51bGwhPXQuYXhpcz90LmF4aXM6bi5kZWZhdWx0QXhpcyxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGRpdihlLGFkZChlcHNpbG9uKCksY2FsY0wyTm9ybXMoZSx0LmF4aXMpKSl9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2F4aXM6dGhpcy5heGlzfX0sdC5jbGFzc05hbWU9XCJVbml0Tm9ybVwiLHR9KENvbnN0cmFpbnQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhVbml0Tm9ybSk7dmFyIE5vbk5lZz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSl7cmV0dXJuIHJlbHUoZSl9LHQuY2xhc3NOYW1lPVwiTm9uTmVnXCIsdH0oQ29uc3RyYWludCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE5vbk5lZyk7dmFyIE1pbk1heE5vcm09ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4uZGVmYXVsdE1pblZhbHVlPTAsbi5kZWZhdWx0TWF4VmFsdWU9MSxuLmRlZmF1bHRSYXRlPTEsbi5kZWZhdWx0QXhpcz0wLG4ubWluVmFsdWU9bnVsbCE9dC5taW5WYWx1ZT90Lm1pblZhbHVlOm4uZGVmYXVsdE1pblZhbHVlLG4ubWF4VmFsdWU9bnVsbCE9dC5tYXhWYWx1ZT90Lm1heFZhbHVlOm4uZGVmYXVsdE1heFZhbHVlLG4ucmF0ZT1udWxsIT10LnJhdGU/dC5yYXRlOm4uZGVmYXVsdFJhdGUsbi5heGlzPW51bGwhPXQuYXhpcz90LmF4aXM6bi5kZWZhdWx0QXhpcyxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49Y2FsY0wyTm9ybXMoZSx0LmF4aXMpLHI9YWRkKG11bCh0LnJhdGUsY2xpcEJ5VmFsdWUobix0Lm1pblZhbHVlLHQubWF4VmFsdWUpKSxtdWwoMS10LnJhdGUsbikpO3JldHVybiBtdWwoZSxkaXYocixhZGQoZXBzaWxvbigpLG4pKSl9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue21pblZhbHVlOnRoaXMubWluVmFsdWUsbWF4VmFsdWU6dGhpcy5tYXhWYWx1ZSxyYXRlOnRoaXMucmF0ZSxheGlzOnRoaXMuYXhpc319LHQuY2xhc3NOYW1lPVwiTWluTWF4Tm9ybVwiLHR9KENvbnN0cmFpbnQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhNaW5NYXhOb3JtKTt2YXIgQ09OU1RSQUlOVF9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVA9e21heE5vcm06XCJNYXhOb3JtXCIsbWluTWF4Tm9ybTpcIk1pbk1heE5vcm1cIixub25OZWc6XCJOb25OZWdcIix1bml0Tm9ybTpcIlVuaXROb3JtXCJ9O2Z1bmN0aW9uIHNlcmlhbGl6ZUNvbnN0cmFpbnQoZSl7cmV0dXJuIHNlcmlhbGl6ZUtlcmFzT2JqZWN0KGUpfWZ1bmN0aW9uIGRlc2VyaWFsaXplQ29uc3RyYWludChlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD17fSksZGVzZXJpYWxpemVLZXJhc09iamVjdChlLHNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5nZXRNYXAoKS5jbGFzc05hbWVNYXAsdCxcImNvbnN0cmFpbnRcIil9ZnVuY3Rpb24gZ2V0Q29uc3RyYWludChlKXtyZXR1cm4gbnVsbD09ZT9udWxsOlwic3RyaW5nXCI9PXR5cGVvZiBlP2Rlc2VyaWFsaXplQ29uc3RyYWludCh7Y2xhc3NOYW1lOmUgaW4gQ09OU1RSQUlOVF9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVA/Q09OU1RSQUlOVF9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVBbZV06ZSxjb25maWc6e319KTplIGluc3RhbmNlb2YgQ29uc3RyYWludD9lOmRlc2VyaWFsaXplQ29uc3RyYWludChlKX1mdW5jdGlvbiBtYXhOb3JtKGUpe3JldHVybiBuZXcgTWF4Tm9ybShlKX1mdW5jdGlvbiB1bml0Tm9ybShlKXtyZXR1cm4gbmV3IFVuaXROb3JtKGUpfWZ1bmN0aW9uIG5vbk5lZygpe3JldHVybiBuZXcgTm9uTmVnfWZ1bmN0aW9uIG1pbk1heE5vcm0oZSl7cmV0dXJuIG5ldyBNaW5NYXhOb3JtKGUpfXZhciBleHBvcnRzX2NvbnN0cmFpbnRzPU9iamVjdC5mcmVlemUoe21heE5vcm06bWF4Tm9ybSx1bml0Tm9ybTp1bml0Tm9ybSxub25OZWc6bm9uTmVnLG1pbk1heE5vcm06bWluTWF4Tm9ybX0pLFZBTElEX0RBVEFfRk9STUFUX1ZBTFVFUz1bXCJjaGFubmVsc0ZpcnN0XCIsXCJjaGFubmVsc0xhc3RcIl0sVkFMSURfUEFERElOR19NT0RFX1ZBTFVFUz1bXCJ2YWxpZFwiLFwic2FtZVwiLFwiY2F1c2FsXCJdLFZBTElEX1BPT0xfTU9ERV9WQUxVRVM9W1wibWF4XCIsXCJhdmdcIl0sVkFMSURfQklESVJFQ1RJT05BTF9NRVJHRV9NT0RFUz1bXCJzdW1cIixcIm11bFwiLFwiY29uY2F0XCIsXCJhdmVcIl0sbmFtZU1hcD1uZXcgTWFwO2Z1bmN0aW9uIGNoZWNrRGF0YUZvcm1hdChlKXtjaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKFZBTElEX0RBVEFfRk9STUFUX1ZBTFVFUyxcIkRhdGFGb3JtYXRcIixlKX1mdW5jdGlvbiBjaGVja1BhZGRpbmdNb2RlKGUpe2NoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWUoVkFMSURfUEFERElOR19NT0RFX1ZBTFVFUyxcIlBhZGRpbmdNb2RlXCIsZSl9ZnVuY3Rpb24gY2hlY2tQb29sTW9kZShlKXtjaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKFZBTElEX1BPT0xfTU9ERV9WQUxVRVMsXCJQb29sTW9kZVwiLGUpfXZhciBfbmFtZVNjb3BlU3RhY2s9W10sX25hbWVTY29wZURpdmlkZXI9XCIvXCI7ZnVuY3Rpb24gbmFtZVNjb3BlKGUsdCl7X25hbWVTY29wZVN0YWNrLnB1c2goZSk7dHJ5e3ZhciBuPXQoKTtyZXR1cm4gX25hbWVTY29wZVN0YWNrLnBvcCgpLG59Y2F0Y2goZSl7dGhyb3cgX25hbWVTY29wZVN0YWNrLnBvcCgpLGV9fWZ1bmN0aW9uIGN1cnJlbnROYW1lU2NvcGVQcmVmaXgoKXtyZXR1cm4gMD09PV9uYW1lU2NvcGVTdGFjay5sZW5ndGg/XCJcIjpfbmFtZVNjb3BlU3RhY2suam9pbihfbmFtZVNjb3BlRGl2aWRlcikrX25hbWVTY29wZURpdmlkZXJ9ZnVuY3Rpb24gZ2V0U2NvcGVkVGVuc29yTmFtZShlKXtpZighaXNWYWxpZFRlbnNvck5hbWUoZSkpdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgdmFsaWQgdGVuc29yIG5hbWU6ICdcIitlK1wiJ1wiKTtyZXR1cm4gY3VycmVudE5hbWVTY29wZVByZWZpeCgpK2V9ZnVuY3Rpb24gZ2V0VW5pcXVlVGVuc29yTmFtZShlKXtpZighaXNWYWxpZFRlbnNvck5hbWUoZSkpdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgdmFsaWQgdGVuc29yIG5hbWU6ICdcIitlK1wiJ1wiKTtuYW1lTWFwLmhhcyhlKXx8bmFtZU1hcC5zZXQoZSwwKTt2YXIgdD1uYW1lTWFwLmdldChlKTtpZihuYW1lTWFwLnNldChlLG5hbWVNYXAuZ2V0KGUpKzEpLHQ+MCl7dmFyIG49ZStcIl9cIit0O3JldHVybiBuYW1lTWFwLnNldChuLDEpLG59cmV0dXJuIGV9dmFyIHRlbnNvck5hbWVSZWdleD1uZXcgUmVnRXhwKC9eW0EtWmEtel1bLUEtWmEtejAtOVxcLl9cXC9dKiQvKTtmdW5jdGlvbiBpc1ZhbGlkVGVuc29yTmFtZShlKXtyZXR1cm4hIWUubWF0Y2godGVuc29yTmFtZVJlZ2V4KX1mdW5jdGlvbiBpc0ludGVnZXIoZSl7cmV0dXJuIGU9PT1wYXJzZUludChlLnRvU3RyaW5nKCksMTApfWZ1bmN0aW9uIGFycmF5UHJvZChlLHQsbil7bnVsbD09dCYmKHQ9MCksbnVsbD09biYmKG49ZS5sZW5ndGgpO2Zvcih2YXIgcj0xLGk9dDtpPG47KytpKXIqPWVbaV07cmV0dXJuIHJ9ZnVuY3Rpb24gdG9BcnJheTFEKGUpe3JldHVybiBlPUFycmF5LmlzQXJyYXkoZSk/bmV3IEZsb2F0MzJBcnJheShlKTplLHRlbnNvcjFkKGUpfWZ1bmN0aW9uIG1pbiQxKGUpe3JldHVybiBtaW4odG9BcnJheTFEKGUpKS5kYXRhU3luYygpWzBdfWZ1bmN0aW9uIG1heCQxKGUpe3JldHVybiBtYXgodG9BcnJheTFEKGUpKS5kYXRhU3luYygpWzBdfWZ1bmN0aW9uIHJhbmdlKGUsdCl7aWYodDxlKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiZW5kIChcIit0K1wiKSA8IGJlZ2luIChcIitlK1wiKSBpcyBmb3JiaWRkZW4uXCIpO2Zvcih2YXIgbj1bXSxyPWU7cjx0OysrciluLnB1c2gocik7cmV0dXJuIG59ZnVuY3Rpb24gY2FzdCQxKGUsdCl7cmV0dXJuIGUuYXNUeXBlKHQpfWZ1bmN0aW9uIGV4cGFuZERpbXMkMShlLHQpe3ZvaWQgMD09PXQmJih0PS0xKTt2YXIgbj1lLnNoYXBlLnNsaWNlKCk7cmV0dXJuIHQ8MCYmKHQ9bi5sZW5ndGgrdCsxKSxuLnNwbGljZSh0LDAsMSksZS5yZXNoYXBlKG4pfWZ1bmN0aW9uIHJlcGVhdChlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7aWYoMiE9PWUuc2hhcGUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwicmVwZWF0KCkgZXhwZWN0cyBhIHJhbmstMiB0ZW5zb3IsIGJ1dCByZWNlaXZlZCBhIHJhbmstXCIrZS5zaGFwZS5sZW5ndGgrXCIgdGVuc29yLlwiKTtyZXR1cm4gdGlsZSQxKGV4cGFuZERpbXMkMShlLDEpLFsxLHQsMV0pfSl9ZnVuY3Rpb24gZmxhdHRlbihlKXt2YXIgdD1bYXJyYXlQcm9kKGUuc2hhcGUpXTtyZXR1cm4gZS5yZXNoYXBlKHQpfWZ1bmN0aW9uIGJhdGNoRmxhdHRlbihlKXtpZihlLnJhbms8PTEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJiYXRjaEZsYXR0ZW4gcmVxdWlyZXMgYSBtaW5pbXVtIHJhbmsgb2YgMi4gR290IHJhbms6IFwiK2UucmFuaytcIi5cIik7dmFyIHQ9W2Uuc2hhcGVbMF0sYXJyYXlQcm9kKGUuc2hhcGUsMSldO3JldHVybiBlLnJlc2hhcGUodCl9ZnVuY3Rpb24gc2xpY2VBbG9uZ0ZpcnN0QXhpcyhlLHQsbil7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtzd2l0Y2goZS5yYW5rKXtjYXNlIDE6cmV0dXJuIHNsaWNlMWQoZSx0LG4pO2Nhc2UgMjpyZXR1cm4gc2xpY2UyZChlLFt0LDBdLFtuLGUuc2hhcGVbMV1dKTtjYXNlIDM6cmV0dXJuIHNsaWNlM2QoZSxbdCwwLDBdLFtuLGUuc2hhcGVbMV0sZS5zaGFwZVsyXV0pO2Nhc2UgNDpyZXR1cm4gc2xpY2U0ZChlLFt0LDAsMCwwXSxbbixlLnNoYXBlWzFdLGUuc2hhcGVbMl0sZS5zaGFwZVszXV0pO2RlZmF1bHQ6dGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJzbGljZUFsb25nRmlyc3RBeGlzKCkgcmVjZWl2ZWQgYW4gdW5zdXBwb3J0ZWQgdGVuc29yIHJhbms6IFwiK2UucmFuayl9fSl9ZnVuY3Rpb24gc2xpY2VBbG9uZ0xhc3RBeGlzKGUsdCxuKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3N3aXRjaChlLnJhbmspe2Nhc2UgMTpyZXR1cm4gc2xpY2UxZChlLHQsbik7Y2FzZSAyOnJldHVybiBzbGljZTJkKGUsWzAsdF0sW2Uuc2hhcGVbMF0sbl0pO2Nhc2UgMzpyZXR1cm4gc2xpY2UzZChlLFswLDAsdF0sW2Uuc2hhcGVbMF0sZS5zaGFwZVsxXSxuXSk7Y2FzZSA0OnJldHVybiBzbGljZTRkKGUsWzAsMCwwLHRdLFtlLnNoYXBlWzBdLGUuc2hhcGVbMV0sZS5zaGFwZVsyXSxuXSk7ZGVmYXVsdDp0aHJvdyBuZXcgVmFsdWVFcnJvcihcInNsaWNlQWxvbmdMYXN0QXhpcygpIHJlY2VpdmVkIGFuIHVuc3VwcG9ydGVkIHRlbnNvciByYW5rOiBcIitlLnJhbmspfX0pfWZ1bmN0aW9uIHNsaWNlQWxvbmdBeGlzKGUsdCxuLHIpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7c3dpdGNoKGUucmFuayl7Y2FzZSAxOnJldHVybiBzbGljZTFkKGUsdCxuKTtjYXNlIDI6c3dpdGNoKHIpe2Nhc2UgMTpyZXR1cm4gc2xpY2VBbG9uZ0ZpcnN0QXhpcyhlLHQsbik7Y2FzZSAyOnJldHVybiBzbGljZUFsb25nTGFzdEF4aXMoZSx0LG4pO2RlZmF1bHQ6dGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgYXhpcyBpcyBub3Qgd2l0aGluIHRoZSByYW5rIG9mIHRoZSB0ZW5zb3IgXCIrcil9Y2FzZSAzOnN3aXRjaChyKXtjYXNlIDE6cmV0dXJuIHNsaWNlQWxvbmdGaXJzdEF4aXMoZSx0LG4pO2Nhc2UgMjpyZXR1cm4gc2xpY2UzZChlLFswLHQsMF0sW2Uuc2hhcGVbMF0sbixlLnNoYXBlWzJdXSk7Y2FzZSAzOnJldHVybiBzbGljZUFsb25nTGFzdEF4aXMoZSx0LG4pO2RlZmF1bHQ6dGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgYXhpcyBpcyBub3Qgd2l0aGluIHRoZSByYW5rIG9mIHRoZSB0ZW5zb3IgXCIrcil9Y2FzZSA0OnN3aXRjaChyKXtjYXNlIDE6cmV0dXJuIHNsaWNlQWxvbmdGaXJzdEF4aXMoZSx0LG4pO2Nhc2UgMjpyZXR1cm4gc2xpY2U0ZChlLFswLHQsMCwwXSxbZS5zaGFwZVswXSxuLGUuc2hhcGVbMl0sZS5zaGFwZVszXV0pO2Nhc2UgMzpyZXR1cm4gc2xpY2U0ZChlLFswLDAsdCwwXSxbZS5zaGFwZVswXSxlLnNoYXBlWzFdLG4sZS5zaGFwZVszXV0pO2Nhc2UgNDpyZXR1cm4gc2xpY2VBbG9uZ0xhc3RBeGlzKGUsdCxuKTtkZWZhdWx0OnRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGF4aXMgaXMgbm90IHdpdGhpbiB0aGUgcmFuayBvZiB0aGUgdGVuc29yIFwiK3IpfWRlZmF1bHQ6dGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJzbGljZUFsb25nTGFzdEF4aXMoKSByZWNlaXZlZCBhbiB1bnN1cHBvcnRlZCB0ZW5zb3IgcmFuazogXCIrZS5yYW5rKX19KX1mdW5jdGlvbiBjb25jYXRlbmF0ZShlLHQpe3ZhciBuO3JldHVybiB2b2lkIDA9PT10JiYodD0tMSksdDwwJiYodD0wIT09KG49ZVswXS5yYW5rKT9uOjApLHQ9PT1lWzBdLnJhbmsmJih0PS0xKSxjb25jYXQoZSx0KX1mdW5jdGlvbiBjb25jYXRBbG9uZ0ZpcnN0QXhpcyhlLHQpe3N3aXRjaChlLnJhbmspe2Nhc2UgMTpyZXR1cm4gY29uY2F0MWQoW2UsdF0pO2Nhc2UgMjpyZXR1cm4gY29uY2F0MmQoW2UsdF0sMCk7Y2FzZSAzOnJldHVybiBjb25jYXQzZChbZSx0XSwwKTtjYXNlIDQ6cmV0dXJuIGNvbmNhdDRkKFtlLHRdLDApO2RlZmF1bHQ6dGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJjb25jYXRBbG9uZ0ZpcnN0QXhpcygpIHJlY2VpdmVkIGFuIHVuc3VwcG9ydGVkIHRlbnNvciByYW5rOiBcIitlLnJhbmspfX1mdW5jdGlvbiB0aWxlJDEoZSx0KXtpZihBcnJheS5pc0FycmF5KHQpfHwodD1bdF0pLGUucmFuayE9PXQubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGxlbmd0aCBvZiBpbnB1dCBuIChcIit0Lmxlbmd0aCtcIikgZG9lcyBub3QgbWF0Y2ggdGhlIG51bWJlciBvZiBkaW1lbnNpb25zIGluIGlucHV0IHggKFwiK2UucmFuaytcIilcIik7cmV0dXJuIHRpbGUoZSx0KX1mdW5jdGlvbiByYW5kb21Ob3JtYWwkMShlLHQsbixyLGkpe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1uJiYobj0xKSxyYW5kb21Ob3JtYWwoZSx0LG4scixpKX1mdW5jdGlvbiBkb3QoZSx0LG4scil7aWYoZS5yYW5rPDJ8fHQucmFuazwyKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiZG90IHJlcXVpcmVzIGJvdGggaW5wdXRzIHRvIGJlIHJhbmsgPj0gMiBidXQgZ290IHggc2hhcGUgPSBcIitlLnNoYXBlK1wiIGFuZCB5IHNoYXBlID0gXCIrdC5zaGFwZSk7aWYodC5yYW5rPj0zJiYocz1lLnNoYXBlLnNsaWNlKC0xKVswXSkhPT0oYz10LnNoYXBlLnNsaWNlKC0yKVswXSkpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJJZiByYW5rIHkgPj0gMywgdGhlbiB0aGUgc2Vjb25kIGxhc3QgZGltIG9mIHkgbXVzdCBlcXVhbCB0aGUgbGFzdCBkaW0gb2YgeCBidXQgZ290IHggc2hhcGUgPSBcIitlLnNoYXBlK1wiIGFuZCAgeSBzaGFwZSA9IFwiK3Quc2hhcGUpO2lmKDI9PT1lLnJhbmsmJjI9PT10LnJhbmspe3ZhciBpPSExLGE9ITE7cmV0dXJuIGZ1c2VkLm1hdE11bChlLHQsaSxhLHI/cmVzaGFwZUJpYXMoZS5yYW5rLHIsaW1hZ2VEYXRhRm9ybWF0KCkpOm51bGwsbil9dmFyIG89ZS5zaGFwZS5zbGljZSgpLHM9by5wb3AoKTtlPWUucmVzaGFwZShbLTEsc10pO3ZhciBsPXQuc2hhcGUuc2xpY2UoKSx1PWwucG9wKCksYz1sLnBvcCgpLHA9bC5jb25jYXQoW3VdKSxoPUFycmF5LmZyb20oe2xlbmd0aDp0LnJhbmt9LGZ1bmN0aW9uKGUsbil7cmV0dXJuIDA9PT1uP3QucmFuay0yOm48PXQucmFuay0yP24tMTpufSk7dD10LnRyYW5zcG9zZShoKS5yZXNoYXBlKFtjLC0xXSk7dmFyIGQ9by5jb25jYXQocCk7aT0hMSxhPSExO3JldHVybiBmdXNlZC5tYXRNdWwoZSx0LGksYSxyP3Jlc2hhcGVCaWFzKGUucmFuayxyLGltYWdlRGF0YUZvcm1hdCgpKTpudWxsLG4pLnJlc2hhcGUoZCl9ZnVuY3Rpb24gZ2F0aGVyJDEoZSx0LG4pe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIHQ9QXJyYXkuaXNBcnJheSh0KT90ZW5zb3IxZCh0LFwiaW50MzJcIik6dC50b0ludCgpLGdhdGhlcihlLHQsbil9KX1mdW5jdGlvbiBzcXVhcmUoZSl7cmV0dXJuIG11bFN0cmljdChlLGUpfWZ1bmN0aW9uIHJlc2hhcGVCaWFzKGUsdCxuKXt2YXIgcj10LnNoYXBlO2lmKDEhPT10LnJhbmsmJnQucmFuayE9PWUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJVbmV4cGVjdGVkIGJpYXMgZGltZW5zaW9uczogXCIrdC5yYW5rK1wiOyBleHBlY3RlZCBpdCB0byBiZSAxIG9yIFwiK2UpO2lmKDU9PT1lKXtpZihcImNoYW5uZWxzRmlyc3RcIj09PW4pcmV0dXJuIDE9PT1yLmxlbmd0aD90LnJlc2hhcGUoWzEsclswXSwxLDEsMV0pOnQucmVzaGFwZShbMSxyWzNdLHJbMF0sclsxXSxyWzJdXSk7aWYoXCJjaGFubmVsc0xhc3RcIj09PW4pcmV0dXJuIDE9PT1yLmxlbmd0aD90LnJlc2hhcGUoWzEsMSwxLDEsclswXV0pOnQucmVzaGFwZShbMV0uY29uY2F0KHIpKX1lbHNlIGlmKDQ9PT1lKXtpZihcImNoYW5uZWxzRmlyc3RcIj09PW4pcmV0dXJuIDE9PT1yLmxlbmd0aD90LnJlc2hhcGUoWzEsclswXSwxLDFdKTp0LnJlc2hhcGUoWzEsclsyXSxyWzBdLHJbMV1dKTtpZihcImNoYW5uZWxzTGFzdFwiPT09bilyZXR1cm4gMT09PXIubGVuZ3RoP3QucmVzaGFwZShbMSwxLDEsclswXV0pOnQucmVzaGFwZShbMV0uY29uY2F0KHIpKX1lbHNlIGlmKDM9PT1lKXtpZihcImNoYW5uZWxzRmlyc3RcIj09PW4pcmV0dXJuIDE9PT1yLmxlbmd0aD90LnJlc2hhcGUoWzEsclswXSwxXSk6dC5yZXNoYXBlKFsxLHJbMV0sclswXV0pO2lmKFwiY2hhbm5lbHNMYXN0XCI9PT1uKXJldHVybiAxPT09ci5sZW5ndGg/dC5yZXNoYXBlKFsxLDEsclswXV0pOnQucmVzaGFwZShbMV0uY29uY2F0KHIpKX1lbHNlIGlmKGU8MylyZXR1cm4gdDt0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlVuc3VwcG9ydGVkIGlucHV0IHJhbmsgYnkgYmlhc0FkZDogXCIrdC5yYW5rKX1mdW5jdGlvbiBiaWFzQWRkKGUsdCxuKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBudWxsPT1uJiYobj1pbWFnZURhdGFGb3JtYXQoKSksY2hlY2tEYXRhRm9ybWF0KG4pLGUuYWRkKHJlc2hhcGVCaWFzKGUucmFuayx0LG4pKX0pfWZ1bmN0aW9uIGVsdSQxKGUsdCl7aWYodm9pZCAwPT09dCYmKHQ9MSksMSE9PXQpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJTdXBwb3J0IGZvciBhbHBoYSB2YWx1ZXMgb3RoZXIgdGhhbiAxIChcIit0K1wiKSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtyZXR1cm4gZWx1KGUpfWZ1bmN0aW9uIHNvZnRzaWduKGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGRpdihlLGFicyhlKS5hZGQoMSkpfSl9ZnVuY3Rpb24gZHJvcG91dChlLHQsbixyKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe2lmKG51bGwhPW4mJiF1dGlsLmFycmF5c0VxdWFsKGUuc2hhcGUsbikpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJOb24tZGVmYXVsdCBub2lzZSBzaGFwZSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0OiBcIitKU09OLnN0cmluZ2lmeShuKSk7aWYobnVsbCE9cil0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcInNlZWQgaXMgbm90IGltcGxlbWVudGVkIGZvciBkcm9wb3V0IHlldC5cIik7dmFyIGk9c3RlcChhZGQoLXQscmFuZG9tVW5pZm9ybShlLnNoYXBlLDAsMSxcImZsb2F0MzJcIikpKTtyZXR1cm4gaT1tdWwoMS8oMS10KSxpKSxtdWwoZSxpKX0pfWZ1bmN0aW9uIGhhcmRTaWdtb2lkKGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9YWRkKC41LG11bCguMixlKSk7cmV0dXJuIGNsaXBCeVZhbHVlKHQsMCwxKX0pfWZ1bmN0aW9uIGluVHJhaW5QaGFzZShlLHQsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPSExKSxuP2UoKTp0KCl9dmFyIFZBTElEX0ZBTl9NT0RFX1ZBTFVFUz1bXCJmYW5JblwiLFwiZmFuT3V0XCIsXCJmYW5BdmdcIl0sVkFMSURfRElTVFJJQlVUSU9OX1ZBTFVFUz1bXCJub3JtYWxcIixcInVuaWZvcm1cIixcInRydW5jYXRlZE5vcm1hbFwiXTtmdW5jdGlvbiBjaGVja0Zhbk1vZGUoZSl7Y2hlY2tTdHJpbmdUeXBlVW5pb25WYWx1ZShWQUxJRF9GQU5fTU9ERV9WQUxVRVMsXCJGYW5Nb2RlXCIsZSl9ZnVuY3Rpb24gY2hlY2tEaXN0cmlidXRpb24oZSl7Y2hlY2tTdHJpbmdUeXBlVW5pb25WYWx1ZShWQUxJRF9ESVNUUklCVVRJT05fVkFMVUVTLFwiRGlzdHJpYnV0aW9uXCIsZSl9dmFyIEluaXRpYWxpemVyPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5mcm9tQ29uZmlnVXNlc0N1c3RvbU9iamVjdHM9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue319LHR9KHNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlKSxaZXJvcz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gemVyb3MoZSx0KX0sdC5jbGFzc05hbWU9XCJaZXJvc1wiLHR9KEluaXRpYWxpemVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoWmVyb3MpO3ZhciBPbmVzPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLHQpe3JldHVybiBvbmVzKGUsdCl9LHQuY2xhc3NOYW1lPVwiT25lc1wiLHR9KEluaXRpYWxpemVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoT25lcyk7dmFyIENvbnN0YW50PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMpfHx0aGlzO2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0KXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRXhwZWN0ZWQgYXJndW1lbnQgb2YgdHlwZSBDb25zdGFudENvbmZpZyBidXQgZ290IFwiK3QpO2lmKHZvaWQgMD09PXQudmFsdWUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJjb25maWcgbXVzdCBoYXZlIHZhbHVlIHNldCBidXQgZ290IFwiK3QpO3JldHVybiBuLnZhbHVlPXQudmFsdWUsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIG11bChzY2FsYXIobi52YWx1ZSksb25lcyhlLHQpKX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57dmFsdWU6dGhpcy52YWx1ZX19LHQuY2xhc3NOYW1lPVwiQ29uc3RhbnRcIix0fShJbml0aWFsaXplcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKENvbnN0YW50KTt2YXIgUmFuZG9tVW5pZm9ybT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5ERUZBVUxUX01JTlZBTD0tLjA1LG4uREVGQVVMVF9NQVhWQUw9LjA1LG4ubWludmFsPXQubWludmFsfHxuLkRFRkFVTFRfTUlOVkFMLG4ubWF4dmFsPXQubWF4dmFsfHxuLkRFRkFVTFRfTUFYVkFMLG4uc2VlZD10LnNlZWQsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gcmFuZG9tVW5pZm9ybShlLHRoaXMubWludmFsLHRoaXMubWF4dmFsLHQpfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bWludmFsOnRoaXMubWludmFsLG1heHZhbDp0aGlzLm1heHZhbCxzZWVkOnRoaXMuc2VlZH19LHQuY2xhc3NOYW1lPVwiUmFuZG9tVW5pZm9ybVwiLHR9KEluaXRpYWxpemVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoUmFuZG9tVW5pZm9ybSk7dmFyIFJhbmRvbU5vcm1hbD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5ERUZBVUxUX01FQU49MCxuLkRFRkFVTFRfU1REREVWPS4wNSxuLm1lYW49dC5tZWFufHxuLkRFRkFVTFRfTUVBTixuLnN0ZGRldj10LnN0ZGRldnx8bi5ERUZBVUxUX1NURERFVixuLnNlZWQ9dC5zZWVkLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCl7aWYoXCJmbG9hdDMyXCIhPT0odD10fHxcImZsb2F0MzJcIikmJlwiaW50MzJcIiE9PXQpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJyYW5kb21Ob3JtYWwgZG9lcyBub3Qgc3VwcG9ydCBkVHlwZSBcIit0K1wiLlwiKTtyZXR1cm4gcmFuZG9tTm9ybWFsJDEoZSx0aGlzLm1lYW4sdGhpcy5zdGRkZXYsdCx0aGlzLnNlZWQpfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bWVhbjp0aGlzLm1lYW4sc3RkZGV2OnRoaXMuc3RkZGV2LHNlZWQ6dGhpcy5zZWVkfX0sdC5jbGFzc05hbWU9XCJSYW5kb21Ob3JtYWxcIix0fShJbml0aWFsaXplcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFJhbmRvbU5vcm1hbCk7dmFyIFRydW5jYXRlZE5vcm1hbD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5ERUZBVUxUX01FQU49MCxuLkRFRkFVTFRfU1REREVWPS4wNSxuLm1lYW49dC5tZWFufHxuLkRFRkFVTFRfTUVBTixuLnN0ZGRldj10LnN0ZGRldnx8bi5ERUZBVUxUX1NURERFVixuLnNlZWQ9dC5zZWVkLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCl7aWYoXCJmbG9hdDMyXCIhPT0odD10fHxcImZsb2F0MzJcIikmJlwiaW50MzJcIiE9PXQpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJ0cnVuY2F0ZWROb3JtYWwgZG9lcyBub3Qgc3VwcG9ydCBkVHlwZSBcIit0K1wiLlwiKTtyZXR1cm4gdHJ1bmNhdGVkTm9ybWFsKGUsdGhpcy5tZWFuLHRoaXMuc3RkZGV2LHQsdGhpcy5zZWVkKX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue21lYW46dGhpcy5tZWFuLHN0ZGRldjp0aGlzLnN0ZGRldixzZWVkOnRoaXMuc2VlZH19LHQuY2xhc3NOYW1lPVwiVHJ1bmNhdGVkTm9ybWFsXCIsdH0oSW5pdGlhbGl6ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhUcnVuY2F0ZWROb3JtYWwpO3ZhciBJZGVudGl0eT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5nYWluPW51bGwhPXQuZ2Fpbj90LmdhaW46MSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtpZigyIT09ZS5sZW5ndGh8fGVbMF0hPT1lWzFdKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSWRlbnRpdHkgbWF0cml4IGluaXRpYWxpemVyIGNhbiBvbmx5IGJlIHVzZWQgZm9yIDJEIHNxdWFyZSBtYXRyaWNlcy5cIik7cmV0dXJuIG11bChuLmdhaW4sZXllKGVbMF0pKX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57Z2Fpbjp0aGlzLmdhaW59fSx0LmNsYXNzTmFtZT1cIklkZW50aXR5XCIsdH0oSW5pdGlhbGl6ZXIpO2Z1bmN0aW9uIGNvbXB1dGVGYW5zKGUsdCl7dmFyIG4scjtpZih2b2lkIDA9PT10JiYodD1cImNoYW5uZWxzTGFzdFwiKSxjaGVja0RhdGFGb3JtYXQodCksMj09PWUubGVuZ3RoKW49ZVswXSxyPWVbMV07ZWxzZSBpZigtMSE9PVszLDQsNV0uaW5kZXhPZihlLmxlbmd0aCkpe2lmKFwiY2hhbm5lbHNGaXJzdFwiPT09dCl7dmFyIGk9YXJyYXlQcm9kKGUsMik7bj1lWzFdKmkscj1lWzBdKml9ZWxzZSBpZihcImNoYW5uZWxzTGFzdFwiPT09dCl7aT1hcnJheVByb2QoZSwwLGUubGVuZ3RoLTIpO249ZVtlLmxlbmd0aC0yXSppLHI9ZVtlLmxlbmd0aC0xXSppfX1lbHNle3ZhciBhPWFycmF5UHJvZChlKTtuPU1hdGguc3FydChhKSxyPU1hdGguc3FydChhKX1yZXR1cm5bbixyXX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoSWRlbnRpdHkpO3ZhciBWYXJpYW5jZVNjYWxpbmc9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyl8fHRoaXM7aWYodC5zY2FsZTwwKXRocm93IG5ldyBWYWx1ZUVycm9yKFwic2NhbGUgbXVzdCBiZSBhIHBvc2l0aXZlIGZsb2F0LiBHb3Q6IFwiK3Quc2NhbGUpO3JldHVybiBuLnNjYWxlPW51bGw9PXQuc2NhbGU/MTp0LnNjYWxlLG4ubW9kZT1udWxsPT10Lm1vZGU/XCJmYW5JblwiOnQubW9kZSxjaGVja0Zhbk1vZGUobi5tb2RlKSxuLmRpc3RyaWJ1dGlvbj1udWxsPT10LmRpc3RyaWJ1dGlvbj9cIm5vcm1hbFwiOnQuZGlzdHJpYnV0aW9uLGNoZWNrRGlzdHJpYnV0aW9uKG4uZGlzdHJpYnV0aW9uKSxuLnNlZWQ9dC5zZWVkLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCl7dmFyIG49Y29tcHV0ZUZhbnMoZSkscj1uWzBdLGk9blsxXSxhPXRoaXMuc2NhbGU7aWYoXCJmYW5JblwiPT09dGhpcy5tb2RlP2EvPU1hdGgubWF4KDEscik6XCJmYW5PdXRcIj09PXRoaXMubW9kZT9hLz1NYXRoLm1heCgxLGkpOmEvPU1hdGgubWF4KDEsKHIraSkvMiksXCJub3JtYWxcIj09PXRoaXMuZGlzdHJpYnV0aW9uKXt2YXIgbz1NYXRoLnNxcnQoYSk7aWYoXCJmbG9hdDMyXCIhPT0odD10fHxcImZsb2F0MzJcIikmJlwiaW50MzJcIiE9PXQpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IodGhpcy5nZXRDbGFzc05hbWUoKStcIiBkb2VzIG5vdCBzdXBwb3J0IGRUeXBlIFwiK3QrXCIuXCIpO3JldHVybiB0cnVuY2F0ZWROb3JtYWwoZSwwLG8sdCx0aGlzLnNlZWQpfXZhciBzPU1hdGguc3FydCgzKmEpO3JldHVybiByYW5kb21Vbmlmb3JtKGUsLXMscyx0KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue3NjYWxlOnRoaXMuc2NhbGUsbW9kZTp0aGlzLm1vZGUsZGlzdHJpYnV0aW9uOnRoaXMuZGlzdHJpYnV0aW9uLHNlZWQ6dGhpcy5zZWVkfX0sdC5jbGFzc05hbWU9XCJWYXJpYW5jZVNjYWxpbmdcIix0fShJbml0aWFsaXplcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFZhcmlhbmNlU2NhbGluZyk7dmFyIEdsb3JvdFVuaWZvcm09ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMse3NjYWxlOjEsbW9kZTpcImZhbkF2Z1wiLGRpc3RyaWJ1dGlvbjpcInVuaWZvcm1cIixzZWVkOm51bGw9PXQ/bnVsbDp0LnNlZWR9KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIFZhcmlhbmNlU2NhbGluZy5jbGFzc05hbWV9LHQuY2xhc3NOYW1lPVwiR2xvcm90VW5pZm9ybVwiLHR9KFZhcmlhbmNlU2NhbGluZyk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEdsb3JvdFVuaWZvcm0pO3ZhciBHbG9yb3ROb3JtYWw9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMse3NjYWxlOjEsbW9kZTpcImZhbkF2Z1wiLGRpc3RyaWJ1dGlvbjpcIm5vcm1hbFwiLHNlZWQ6bnVsbD09dD9udWxsOnQuc2VlZH0pfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5nZXRDbGFzc05hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gVmFyaWFuY2VTY2FsaW5nLmNsYXNzTmFtZX0sdC5jbGFzc05hbWU9XCJHbG9yb3ROb3JtYWxcIix0fShWYXJpYW5jZVNjYWxpbmcpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhHbG9yb3ROb3JtYWwpO3ZhciBIZU5vcm1hbD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcyx7c2NhbGU6Mixtb2RlOlwiZmFuSW5cIixkaXN0cmlidXRpb246XCJub3JtYWxcIixzZWVkOm51bGw9PXQ/bnVsbDp0LnNlZWR9KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIFZhcmlhbmNlU2NhbGluZy5jbGFzc05hbWV9LHQuY2xhc3NOYW1lPVwiSGVOb3JtYWxcIix0fShWYXJpYW5jZVNjYWxpbmcpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhIZU5vcm1hbCk7dmFyIEhlVW5pZm9ybT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcyx7c2NhbGU6Mixtb2RlOlwiZmFuSW5cIixkaXN0cmlidXRpb246XCJ1bmlmb3JtXCIsc2VlZDpudWxsPT10P251bGw6dC5zZWVkfSl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmdldENsYXNzTmFtZT1mdW5jdGlvbigpe3JldHVybiBWYXJpYW5jZVNjYWxpbmcuY2xhc3NOYW1lfSx0LmNsYXNzTmFtZT1cIkhlVW5pZm9ybVwiLHR9KFZhcmlhbmNlU2NhbGluZyk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEhlVW5pZm9ybSk7dmFyIExlQ3VuTm9ybWFsPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLHtzY2FsZToxLG1vZGU6XCJmYW5JblwiLGRpc3RyaWJ1dGlvbjpcIm5vcm1hbFwiLHNlZWQ6bnVsbD09dD9udWxsOnQuc2VlZH0pfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5nZXRDbGFzc05hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gVmFyaWFuY2VTY2FsaW5nLmNsYXNzTmFtZX0sdC5jbGFzc05hbWU9XCJMZUN1bk5vcm1hbFwiLHR9KFZhcmlhbmNlU2NhbGluZyk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKExlQ3VuTm9ybWFsKTt2YXIgTGVDdW5Vbmlmb3JtPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLHtzY2FsZToxLG1vZGU6XCJmYW5JblwiLGRpc3RyaWJ1dGlvbjpcInVuaWZvcm1cIixzZWVkOm51bGw9PXQ/bnVsbDp0LnNlZWR9KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIFZhcmlhbmNlU2NhbGluZy5jbGFzc05hbWV9LHQuY2xhc3NOYW1lPVwiTGVDdW5Ob3JtYWxcIix0fShWYXJpYW5jZVNjYWxpbmcpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhMZUN1blVuaWZvcm0pO3ZhciBPcnRob2dvbmFsPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMpfHx0aGlzO2lmKG4uREVGQVVMVF9HQUlOPTEsbi5nYWluPW51bGw9PXQuZ2Fpbj9uLkRFRkFVTFRfR0FJTjp0LmdhaW4sbi5zZWVkPXQuc2VlZCxudWxsIT1uLnNlZWQpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJSYW5kb20gc2VlZCBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIE9ydGhvZ29uYWwgSW5pdGlhbGl6ZXIgeWV0LlwiKTtyZXR1cm4gbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7aWYoMiE9PWUubGVuZ3RoKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiVGhlIE9ydGhvZ29uYWwgSW5pdGlhbGl6ZXIgZG9lcyBub3Qgc3VwcG9ydCBub24tMkQgc2hhcGVzIHlldC5cIik7ZVswXSplWzFdPjJlMyYmY29uc29sZS53YXJuKFwiT3J0aG9nb25hbCBpbml0aWFsaXplciBpcyBiZWluZyBjYWxsZWQgb24gYSBtYXRyaXggd2l0aCBtb3JlIHRoYW4gMjAwMCAoXCIrZVswXSplWzFdK1wiKSBlbGVtZW50czogU2xvd25lc3MgbWF5IHJlc3VsdC5cIik7dmFyIHQ9cmFuZG9tTm9ybWFsJDEoZVswXT5lWzFdP1tlWzFdLGVbMF1dOmUsMCwxLFwiZmxvYXQzMlwiKSxyPWxpbmFsZy5ncmFtU2NobWlkdCh0KTtyZXR1cm4gZVswXT5lWzFdJiYocj1yLnRyYW5zcG9zZSgpKSxtdWwobi5nYWluLHIpfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntnYWluOnRoaXMuZ2FpbixzZWVkOnRoaXMuc2VlZH19LHQuY2xhc3NOYW1lPVwiT3J0aG9nb25hbFwiLHR9KEluaXRpYWxpemVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoT3J0aG9nb25hbCk7dmFyIElOSVRJQUxJWkVSX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUD17Y29uc3RhbnQ6XCJDb25zdGFudFwiLGdsb3JvdE5vcm1hbDpcIkdsb3JvdE5vcm1hbFwiLGdsb3JvdFVuaWZvcm06XCJHbG9yb3RVbmlmb3JtXCIsaGVOb3JtYWw6XCJIZU5vcm1hbFwiLGhlVW5pZm9ybTpcIkhlVW5pZm9ybVwiLGlkZW50aXR5OlwiSWRlbnRpdHlcIixsZUN1bk5vcm1hbDpcIkxlQ3VuTm9ybWFsXCIsbGVDdW5Vbmlmb3JtOlwiTGVDdW5Vbmlmb3JtXCIsb25lczpcIk9uZXNcIixvcnRob2dvbmFsOlwiT3J0aG9nb25hbFwiLHJhbmRvbU5vcm1hbDpcIlJhbmRvbU5vcm1hbFwiLHJhbmRvbVVuaWZvcm06XCJSYW5kb21Vbmlmb3JtXCIsdHJ1bmNhdGVkTm9ybWFsOlwiVHJ1bmNhdGVkTm9ybWFsXCIsdmFyaWFuY2VTY2FsaW5nOlwiVmFyaWFuY2VTY2FsaW5nXCIsemVyb3M6XCJaZXJvc1wifTtmdW5jdGlvbiBkZXNlcmlhbGl6ZUluaXRpYWxpemVyKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PXt9KSxkZXNlcmlhbGl6ZUtlcmFzT2JqZWN0KGUsc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLmdldE1hcCgpLmNsYXNzTmFtZU1hcCx0LFwiaW5pdGlhbGl6ZXJcIil9ZnVuY3Rpb24gc2VyaWFsaXplSW5pdGlhbGl6ZXIoZSl7cmV0dXJuIHNlcmlhbGl6ZUtlcmFzT2JqZWN0KGUpfWZ1bmN0aW9uIGdldEluaXRpYWxpemVyKGUpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXt2YXIgdD1lIGluIElOSVRJQUxJWkVSX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUD9JTklUSUFMSVpFUl9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVBbZV06ZTtpZihcIkdsb3JvdE5vcm1hbFwiPT09dClyZXR1cm4gbmV3IEdsb3JvdE5vcm1hbDtpZihcIkdsb3JvdFVuaWZvcm1cIj09PXQpcmV0dXJuIG5ldyBHbG9yb3RVbmlmb3JtO2lmKFwiSGVOb3JtYWxcIj09PXQpcmV0dXJuIG5ldyBIZU5vcm1hbDtpZihcIkhlVW5pZm9ybVwiPT09dClyZXR1cm4gbmV3IEhlVW5pZm9ybTtpZihcIkxlQ3VuTm9ybWFsXCI9PT10KXJldHVybiBuZXcgTGVDdW5Ob3JtYWw7aWYoXCJMZUN1blVuaWZvcm1cIj09PXQpcmV0dXJuIG5ldyBMZUN1blVuaWZvcm07dmFyIG49e307cmV0dXJuIG4uY2xhc3NOYW1lPXQsbi5jb25maWc9e30sZGVzZXJpYWxpemVJbml0aWFsaXplcihuKX1yZXR1cm4gZSBpbnN0YW5jZW9mIEluaXRpYWxpemVyP2U6ZGVzZXJpYWxpemVJbml0aWFsaXplcihlKX1mdW5jdGlvbiB6ZXJvcyQxKCl7cmV0dXJuIG5ldyBaZXJvc31mdW5jdGlvbiBvbmVzJDEoKXtyZXR1cm4gbmV3IE9uZXN9ZnVuY3Rpb24gY29uc3RhbnQoZSl7cmV0dXJuIG5ldyBDb25zdGFudChlKX1mdW5jdGlvbiByYW5kb21Vbmlmb3JtJDEoZSl7cmV0dXJuIG5ldyBSYW5kb21Vbmlmb3JtKGUpfWZ1bmN0aW9uIHJhbmRvbU5vcm1hbCQyKGUpe3JldHVybiBuZXcgUmFuZG9tTm9ybWFsKGUpfWZ1bmN0aW9uIHRydW5jYXRlZE5vcm1hbCQxKGUpe3JldHVybiBuZXcgVHJ1bmNhdGVkTm9ybWFsKGUpfWZ1bmN0aW9uIGlkZW50aXR5KGUpe3JldHVybiBuZXcgSWRlbnRpdHkoZSl9ZnVuY3Rpb24gdmFyaWFuY2VTY2FsaW5nKGUpe3JldHVybiBuZXcgVmFyaWFuY2VTY2FsaW5nKGUpfWZ1bmN0aW9uIGdsb3JvdFVuaWZvcm0oZSl7cmV0dXJuIG5ldyBHbG9yb3RVbmlmb3JtKGUpfWZ1bmN0aW9uIGdsb3JvdE5vcm1hbChlKXtyZXR1cm4gbmV3IEdsb3JvdE5vcm1hbChlKX1mdW5jdGlvbiBoZU5vcm1hbChlKXtyZXR1cm4gbmV3IEhlTm9ybWFsKGUpfWZ1bmN0aW9uIGhlVW5pZm9ybShlKXtyZXR1cm4gbmV3IEhlVW5pZm9ybShlKX1mdW5jdGlvbiBsZUN1bk5vcm1hbChlKXtyZXR1cm4gbmV3IExlQ3VuTm9ybWFsKGUpfWZ1bmN0aW9uIGxlQ3VuVW5pZm9ybShlKXtyZXR1cm4gbmV3IExlQ3VuVW5pZm9ybShlKX1mdW5jdGlvbiBvcnRob2dvbmFsKGUpe3JldHVybiBuZXcgT3J0aG9nb25hbChlKX12YXIgZXhwb3J0c19pbml0aWFsaXplcnM9T2JqZWN0LmZyZWV6ZSh7emVyb3M6emVyb3MkMSxvbmVzOm9uZXMkMSxjb25zdGFudDpjb25zdGFudCxyYW5kb21Vbmlmb3JtOnJhbmRvbVVuaWZvcm0kMSxyYW5kb21Ob3JtYWw6cmFuZG9tTm9ybWFsJDIsdHJ1bmNhdGVkTm9ybWFsOnRydW5jYXRlZE5vcm1hbCQxLGlkZW50aXR5OmlkZW50aXR5LHZhcmlhbmNlU2NhbGluZzp2YXJpYW5jZVNjYWxpbmcsZ2xvcm90VW5pZm9ybTpnbG9yb3RVbmlmb3JtLGdsb3JvdE5vcm1hbDpnbG9yb3ROb3JtYWwsaGVOb3JtYWw6aGVOb3JtYWwsaGVVbmlmb3JtOmhlVW5pZm9ybSxsZUN1bk5vcm1hbDpsZUN1bk5vcm1hbCxsZUN1blVuaWZvcm06bGVDdW5Vbmlmb3JtLG9ydGhvZ29uYWw6b3J0aG9nb25hbH0pLF9uZXh0VW5pcXVlVGVuc29ySWQ9MDtmdW5jdGlvbiBnZXROZXh0VW5pcXVlVGVuc29ySWQoKXtyZXR1cm4gX25leHRVbmlxdWVUZW5zb3JJZCsrfXZhciBfdWlkUHJlZml4ZXM9e307ZnVuY3Rpb24gZ2V0VWlkKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1cIlwiKSxlIGluIF91aWRQcmVmaXhlc3x8KF91aWRQcmVmaXhlc1tlXT0wKSxfdWlkUHJlZml4ZXNbZV0rPTEsZStfdWlkUHJlZml4ZXNbZV0udG9TdHJpbmcoKX1mdW5jdGlvbiBpc0FycmF5T2ZTaGFwZXMoZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSkmJkFycmF5LmlzQXJyYXkoZVswXSl9ZnVuY3Rpb24gbm9ybWFsaXplU2hhcGVMaXN0KGUpe3JldHVybiAwPT09ZS5sZW5ndGg/W106QXJyYXkuaXNBcnJheShlWzBdKT9lOltlXX1mdW5jdGlvbiBnZXRFeGFjdGx5T25lVGVuc29yKGUpe3ZhciB0O2lmKEFycmF5LmlzQXJyYXkoZSkpe2lmKDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkV4cGVjdGVkIFRlbnNvciBsZW5ndGggdG8gYmUgMTsgZ290IFwiK2UubGVuZ3RoKTt0PWVbMF19ZWxzZSB0PWU7cmV0dXJuIHR9ZnVuY3Rpb24gZ2V0RXhhY3RseU9uZVNoYXBlKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkmJkFycmF5LmlzQXJyYXkoZVswXSkpe2lmKDE9PT1lLmxlbmd0aClyZXR1cm4oZT1lKVswXTt0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkV4cGVjdGVkIGV4YWN0bHkgMSBTaGFwZTsgZ290IFwiK2UubGVuZ3RoKX1yZXR1cm4gZX1mdW5jdGlvbiBjb3VudFBhcmFtc0luV2VpZ2h0cyhlKXtmb3IodmFyIHQ9MCxuPTAscj1lO248ci5sZW5ndGg7bisrKXt2YXIgaT1yW25dOzA9PT1pLnNoYXBlLmxlbmd0aD90Kz0xOnQrPWkuc2hhcGUucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUqdH0pfXJldHVybiB0fXZhciBERUZBVUxUX1ZBUklBQkxFX05BTUVfUFJFRklYPVwiVmFyaWFibGVcIixMYXllclZhcmlhYmxlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQsbixyLGkpe3ZvaWQgMD09PXQmJih0PVwiZmxvYXQzMlwiKSx2b2lkIDA9PT1uJiYobj1ERUZBVUxUX1ZBUklBQkxFX05BTUVfUFJFRklYKSx2b2lkIDA9PT1yJiYocj0hMCksdm9pZCAwPT09aSYmKGk9bnVsbCksdGhpcy5kdHlwZT1udWxsPT10P1wiZmxvYXQzMlwiOnQsdGhpcy5zaGFwZT1lLnNoYXBlLHRoaXMuaWQ9Z2V0TmV4dFVuaXF1ZVRlbnNvcklkKCksbj1udWxsPT1uP0RFRkFVTFRfVkFSSUFCTEVfTkFNRV9QUkVGSVg6bix0aGlzLm9yaWdpbmFsTmFtZT1nZXRTY29wZWRUZW5zb3JOYW1lKG4pLHRoaXMubmFtZT1nZXRVbmlxdWVUZW5zb3JOYW1lKHRoaXMub3JpZ2luYWxOYW1lKSx0aGlzLnRyYWluYWJsZV89cix0aGlzLmNvbnN0cmFpbnQ9aSx0aGlzLnZhbD12YXJpYWJsZShlLHRoaXMudHJhaW5hYmxlXyx0aGlzLm5hbWUsdGhpcy5kdHlwZSl9cmV0dXJuIGUucHJvdG90eXBlLnJlYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hc3NlcnROb3REaXNwb3NlZCgpLHRoaXMudmFsfSxlLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3REaXNwb3NlZCgpLGNoZWNrU2hhcGVzTWF0Y2godGhpcy52YWwsZSksdGhpcy52YWwuaWQhPT1lLmlkJiYodGhpcy52YWwuYXNzaWduKGUpLG51bGwhPXRoaXMuY29uc3RyYWludCYmdGhpcy52YWwuYXNzaWduKHRoaXMuY29uc3RyYWludC5hcHBseSh0aGlzLnZhbCkpKSx0aGlzfSxlLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5hc3NlcnROb3REaXNwb3NlZCgpLHRoaXMudmFsLmRpc3Bvc2UoKX0sZS5wcm90b3R5cGUuYXNzZXJ0Tm90RGlzcG9zZWQ9ZnVuY3Rpb24oKXtpZih0aGlzLnZhbC5pc0Rpc3Bvc2VkKXRocm93IG5ldyBFcnJvcihcIkxheWVyc1ZhcmlhYmxlIFwiK3RoaXMubmFtZStcIiBpcyBhbHJlYWR5IGRpc3Bvc2VkLlwiKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwidHJhaW5hYmxlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYWluYWJsZV99LHNldDpmdW5jdGlvbihlKXt0aGlzLnRyYWluYWJsZV89ZSx0aGlzLnZhbC50cmFpbmFibGU9ZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxlfSgpO2Z1bmN0aW9uIGNoZWNrU2hhcGVzTWF0Y2goZSx0KXtpZihlLnNoYXBlLnRvU3RyaW5nKCkhPT10LnNoYXBlLnRvU3RyaW5nKCkpdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgbWlzbWF0Y2g6IFwiK0pTT04uc3RyaW5naWZ5KGUuc2hhcGUpK1wiIHZzLiBcIitKU09OLnN0cmluZ2lmeSh0LnNoYXBlKSl9ZnVuY3Rpb24gYmF0Y2hHZXRWYWx1ZShlKXtyZXR1cm4gZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVhZCgpfSl9ZnVuY3Rpb24gYmF0Y2hTZXRWYWx1ZShlKXtlLmZvckVhY2goZnVuY3Rpb24oZSl7ZVswXS53cml0ZShlWzFdKX0pfXZhciBJbnB1dFNwZWM9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7dGhpcy5kdHlwZT1lLmR0eXBlLHRoaXMuc2hhcGU9ZS5zaGFwZSxudWxsIT1lLnNoYXBlP3RoaXMubmRpbT1lLnNoYXBlLmxlbmd0aDp0aGlzLm5kaW09ZS5uZGltLHRoaXMubWF4TkRpbT1lLm1heE5EaW0sdGhpcy5taW5ORGltPWUubWluTkRpbSx0aGlzLmF4ZXM9ZS5heGVzfHx7fX19KCksU3ltYm9saWNUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSx0LG4scixpLGEsbyl7dGhpcy5kdHlwZT1lLHRoaXMuc2hhcGU9dCx0aGlzLnNvdXJjZUxheWVyPW4sdGhpcy5pbnB1dHM9cix0aGlzLmNhbGxBcmdzPWksdGhpcy5vdXRwdXRUZW5zb3JJbmRleD1vLHRoaXMuaWQ9Z2V0TmV4dFVuaXF1ZVRlbnNvcklkKCksbnVsbCE9YSYmKHRoaXMub3JpZ2luYWxOYW1lPWdldFNjb3BlZFRlbnNvck5hbWUoYSksdGhpcy5uYW1lPWdldFVuaXF1ZVRlbnNvck5hbWUodGhpcy5vcmlnaW5hbE5hbWUpKSx0aGlzLnJhbms9dC5sZW5ndGh9fSgpLF9uZXh0Tm9kZUlEPTAsTm9kZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXt0aGlzLmNhbGxBcmdzPXQsdGhpcy5pZD1fbmV4dE5vZGVJRCsrLHRoaXMub3V0Ym91bmRMYXllcj1lLm91dGJvdW5kTGF5ZXIsdGhpcy5pbmJvdW5kTGF5ZXJzPWUuaW5ib3VuZExheWVycyx0aGlzLm5vZGVJbmRpY2VzPWUubm9kZUluZGljZXMsdGhpcy50ZW5zb3JJbmRpY2VzPWUudGVuc29ySW5kaWNlcyx0aGlzLmlucHV0VGVuc29ycz1lLmlucHV0VGVuc29ycyx0aGlzLm91dHB1dFRlbnNvcnM9ZS5vdXRwdXRUZW5zb3JzLHRoaXMuaW5wdXRNYXNrcz1lLmlucHV0TWFza3MsdGhpcy5vdXRwdXRNYXNrcz1lLm91dHB1dE1hc2tzLHRoaXMuaW5wdXRTaGFwZXM9ZS5pbnB1dFNoYXBlcyx0aGlzLm91dHB1dFNoYXBlcz1lLm91dHB1dFNoYXBlcztmb3IodmFyIG49MCxyPWUuaW5ib3VuZExheWVycztuPHIubGVuZ3RoO24rKyl7dmFyIGk9cltuXTtudWxsIT1pJiZpLm91dGJvdW5kTm9kZXMucHVzaCh0aGlzKX1lLm91dGJvdW5kTGF5ZXIuaW5ib3VuZE5vZGVzLnB1c2godGhpcyl9cmV0dXJuIGUucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe2Zvcih2YXIgZT1bXSx0PTAsbj10aGlzLmluYm91bmRMYXllcnM7dDxuLmxlbmd0aDt0Kyspe3ZhciByPW5bdF07bnVsbCE9cj9lLnB1c2goci5uYW1lKTplLnB1c2gobnVsbCl9cmV0dXJue291dGJvdW5kTGF5ZXI6dGhpcy5vdXRib3VuZExheWVyP3RoaXMub3V0Ym91bmRMYXllci5uYW1lOm51bGwsaW5ib3VuZExheWVyczplLG5vZGVJbmRpY2VzOnRoaXMubm9kZUluZGljZXMsdGVuc29ySW5kaWNlczp0aGlzLnRlbnNvckluZGljZXN9fSxlfSgpLF9uZXh0TGF5ZXJJRD0wLExheWVyPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMpfHx0aGlzO24uX2NhbGxIb29rPW51bGwsbi5fYWRkZWRXZWlnaHROYW1lcz1bXSxuLl9zdGF0ZWZ1bD0hMSxuLmlkPV9uZXh0TGF5ZXJJRCsrLG4uYWN0aXZpdHlSZWd1bGFyaXplcj1udWxsLG4uaW5wdXRTcGVjPW51bGwsbi5zdXBwb3J0c01hc2tpbmc9ITEsbi5fdHJhaW5hYmxlV2VpZ2h0cz1bXSxuLl9ub25UcmFpbmFibGVXZWlnaHRzPVtdLG4uX2xvc3Nlcz1bXSxuLl91cGRhdGVzPVtdLG4uX2J1aWx0PSExLG4uaW5ib3VuZE5vZGVzPVtdLG4ub3V0Ym91bmROb2Rlcz1bXTt2YXIgcj10Lm5hbWU7aWYoIXIpe3ZhciBpPW4uZ2V0Q2xhc3NOYW1lKCk7cj10b1NuYWtlQ2FzZShpKStcIl9cIitnZXRVaWQoaSl9aWYobi5uYW1lPXIsbi50cmFpbmFibGVfPW51bGw9PXQudHJhaW5hYmxlfHx0LnRyYWluYWJsZSxuLnVwZGF0YWJsZT1udWxsPT10LnVwZGF0YWJsZXx8dC51cGRhdGFibGUsbnVsbCE9dC5pbnB1dFNoYXBlfHxudWxsIT10LmJhdGNoSW5wdXRTaGFwZSl7dmFyIGE9dm9pZCAwO2lmKG51bGwhPXQuYmF0Y2hJbnB1dFNoYXBlKWE9dC5iYXRjaElucHV0U2hhcGU7ZWxzZSBpZihudWxsIT10LmlucHV0U2hhcGUpe3ZhciBvPW51bGw7bnVsbCE9dC5iYXRjaFNpemUmJihvPXQuYmF0Y2hTaXplKSxhPVtvXS5jb25jYXQodC5pbnB1dFNoYXBlKX1uLmJhdGNoSW5wdXRTaGFwZT1hO3ZhciBzPXQuZHR5cGU7bnVsbD09cyYmKHM9dC5pbnB1dERUeXBlKSxudWxsPT1zJiYocz1cImZsb2F0MzJcIiksbi5kdHlwZT1zfXJldHVybiBudWxsIT10LndlaWdodHM/bi5pbml0aWFsV2VpZ2h0cz10LndlaWdodHM6bi5pbml0aWFsV2VpZ2h0cz1udWxsLG4uX3JlZkNvdW50PW51bGwsbi5mYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkPSExLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQubm9kZUtleT1mdW5jdGlvbihlLHQpe3JldHVybiBlLm5hbWUrXCJfaWItXCIrdC50b1N0cmluZygpfSx0LnByb3RvdHlwZS5nZXROb2RlQXRJbmRleD1mdW5jdGlvbihlLHQpe2lmKDA9PT10aGlzLmluYm91bmROb2Rlcy5sZW5ndGgpdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcIlRoZSBsYXllciBoYXMgbmV2ZXIgYmVlbiBjYWxsZWQgYW5kIHRodXMgaGFzIG5vIGRlZmluZWQgXCIrdCtcIi5cIik7aWYodGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoPD1lKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQXNrZWQgdG8gZ2V0IFwiK3QrXCIgYXQgbm9kZSBcIitlK1wiLCBidXQgdGhlIGxheWVyIGhhcyBvbmx5IFwiK3RoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aCtcIiBpbmJvdW5kIG5vZGVzLlwiKTtyZXR1cm4gdGhpcy5pbmJvdW5kTm9kZXNbZV19LHQucHJvdG90eXBlLmdldElucHV0QXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHNpbmdsZXRvbk9yQXJyYXkodGhpcy5nZXROb2RlQXRJbmRleChlLFwiaW5wdXRcIikuaW5wdXRUZW5zb3JzKX0sdC5wcm90b3R5cGUuZ2V0T3V0cHV0QXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHNpbmdsZXRvbk9yQXJyYXkodGhpcy5nZXROb2RlQXRJbmRleChlLFwib3V0cHV0XCIpLm91dHB1dFRlbnNvcnMpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJpbnB1dFwiLHtnZXQ6ZnVuY3Rpb24oKXtpZih0aGlzLmluYm91bmROb2Rlcy5sZW5ndGg+MSl0aHJvdyBuZXcgQXR0cmlidXRlRXJyb3IoXCJMYXllciBcIit0aGlzLm5hbWUrJyBoYXMgbXVsdGlwbGUgaW5ib3VuZCBub2RlcywgaGVuY2UgdGhlIG5vdGlvbiBvZiBcImxheWVyIGlucHV0XCIgaXMgaWxsLWRlZmluZWQuIFVzZSBgZ2V0SW5wdXRBdChub2RlSW5kZXgpYCBpbnN0ZWFkLicpO2lmKDA9PT10aGlzLmluYm91bmROb2Rlcy5sZW5ndGgpdGhyb3cgbmV3IEF0dHJpYnV0ZUVycm9yKFwiTGF5ZXIgXCIrdGhpcy5uYW1lK1wiIGlzIG5vdCBjb25uZWN0ZWQsIG5vIGlucHV0IHRvIHJldHVybi5cIik7cmV0dXJuIHNpbmdsZXRvbk9yQXJyYXkodGhpcy5nZXROb2RlQXRJbmRleCgwLFwiaW5wdXRcIikuaW5wdXRUZW5zb3JzKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJvdXRwdXRcIix7Z2V0OmZ1bmN0aW9uKCl7aWYoMD09PXRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aCl0aHJvdyBuZXcgQXR0cmlidXRlRXJyb3IoXCJMYXllciBcIit0aGlzLm5hbWUrXCIgaGFzIG5vIGluYm91bmQgbm9kZXMuXCIpO2lmKHRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aD4xKXRocm93IG5ldyBBdHRyaWJ1dGVFcnJvcihcIkxheWVyIFwiK3RoaXMubmFtZSsnIGhhcyBtdWx0aXBsZSBpbmJvdW5kIG5vZGVzLCBoZW5jZSB0aGUgbm90aW9uIG9mIFwibGF5ZXIgb3V0cHV0XCIgaXMgaWxsLWRlZmluZWQuIFVzZSBgZ2V0T3V0cHV0QXQobm9kZUluZGV4KWAgaW5zdGVhZC4nKTtyZXR1cm4gc2luZ2xldG9uT3JBcnJheSh0aGlzLmdldE5vZGVBdEluZGV4KDAsXCJvdXRwdXRcIikub3V0cHV0VGVuc29ycyl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwibG9zc2VzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9sb3NzZXN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuY2FsY3VsYXRlTG9zc2VzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubG9zc2VzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZSgpfSl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInVwZGF0ZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3VwZGF0ZXN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiYnVpbHRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2J1aWx0fSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fYnVpbHQ9ZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ0cmFpbmFibGVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhaW5hYmxlX30sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX3RyYWluYWJsZVdlaWdodHMuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gdC50cmFpbmFibGU9ZX0pLHRoaXMudHJhaW5hYmxlXz1lfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhaW5hYmxlXz90aGlzLl90cmFpbmFibGVXZWlnaHRzLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZS50cmFpbmFibGV9KTpbXX0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX3RyYWluYWJsZVdlaWdodHM9ZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJub25UcmFpbmFibGVXZWlnaHRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYWluYWJsZT90aGlzLl90cmFpbmFibGVXZWlnaHRzLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4hZS50cmFpbmFibGV9KS5jb25jYXQodGhpcy5fbm9uVHJhaW5hYmxlV2VpZ2h0cyk6dGhpcy5fdHJhaW5hYmxlV2VpZ2h0cy5jb25jYXQodGhpcy5fbm9uVHJhaW5hYmxlV2VpZ2h0cyl9LHNldDpmdW5jdGlvbihlKXt0aGlzLl9ub25UcmFpbmFibGVXZWlnaHRzPWV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwid2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFpbmFibGVXZWlnaHRzLmNvbmNhdCh0aGlzLm5vblRyYWluYWJsZVdlaWdodHMpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInN0YXRlZnVsXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zdGF0ZWZ1bH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5yZXNldFN0YXRlcz1mdW5jdGlvbigpe2lmKCF0aGlzLnN0YXRlZnVsKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIHRoZSByZXNldFN0YXRlcygpIG1ldGhvZCBvZiBhIG5vbi1zdGF0ZWZ1bCBMYXllciBvYmplY3QuXCIpfSx0LnByb3RvdHlwZS5hc3NlcnRJbnB1dENvbXBhdGliaWxpdHk9ZnVuY3Rpb24oZSl7aWYoZT10b0xpc3QoZSksbnVsbCE9dGhpcy5pbnB1dFNwZWMmJjAhPT10aGlzLmlucHV0U3BlYy5sZW5ndGgpe3ZhciB0PXRvTGlzdCh0aGlzLmlucHV0U3BlYyk7aWYoZS5sZW5ndGghPT10Lmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkxheWVyIFwiK3RoaXMubmFtZStcIiBleHBlY3RzIFwiK3QubGVuZ3RoK1wiIGlucHV0cywgYnV0IGl0IHJlY2VpdmVkIFwiK2UubGVuZ3RoK1wiIGlucHV0IHRlbnNvcnMuIElucHV0IHJlY2VpdmVkOiBcIitlKTtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXSxpPXRbbl07aWYobnVsbCE9aSl7dmFyIGE9ci5yYW5rO2lmKG51bGwhPWkubmRpbSYmYSE9PWkubmRpbSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0IFwiK24rXCIgaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgXCIrdGhpcy5uYW1lK1wiOiBleHBlY3RlZCBuZGltPVwiK2kubmRpbStcIiwgZm91bmQgbmRpbT1cIithKTtpZihudWxsIT1pLm1heE5EaW0mJmE+aS5tYXhORGltKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW5wdXQgXCIrbitcIiBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciBcIit0aGlzLm5hbWUrXCI6IGV4cGVjdGVkIG1heF9uZGltPVwiK2kubWF4TkRpbStcIiwgZm91bmQgbmRpbT1cIithKTtpZihudWxsIT1pLm1pbk5EaW0mJmE8aS5taW5ORGltKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW5wdXQgXCIrbitcIiBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciBcIit0aGlzLm5hbWUrXCI6IGV4cGVjdGVkIG1pbl9uZGltPVwiK2kubWluTkRpbStcIiwgZm91bmQgbmRpbT1cIithK1wiLlwiKTtpZihudWxsIT1pLmR0eXBlJiZyLmR0eXBlIT09aS5kdHlwZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0IFwiK24rXCIgaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgXCIrdGhpcy5uYW1lK1wiIDogZXhwZWN0ZWQgZHR5cGU9XCIraS5kdHlwZStcIiwgZm91bmQgZHR5cGU9XCIrci5kdHlwZStcIi5cIik7aWYoaS5heGVzKXt2YXIgbz1yLnNoYXBlO2Zvcih2YXIgcyBpbiBpLmF4ZXMpe3ZhciBsPU51bWJlcihzKSx1PWkuYXhlc1tzXSxjPWw+PTA/b1tsXTpvW28ubGVuZ3RoK2xdO2lmKG51bGwhPXUmJi0xPT09W3UsbnVsbF0uaW5kZXhPZihjKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0IFwiK24rXCIgaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgXCIrdGhpcy5uYW1lK1wiOiBleHBlY3RlZCBheGlzIFwiK2wrXCIgb2YgaW5wdXQgc2hhcGUgdG8gaGF2ZSB2YWx1ZSBcIit1K1wiIGJ1dCBnb3Qgc2hhcGUgXCIrbytcIi5cIil9fWlmKG51bGwhPWkuc2hhcGUpZm9yKHZhciBwPTA7cDxpLnNoYXBlLmxlbmd0aDsrK3Ape3ZhciBoPWkuc2hhcGVbcF0sZD1yLnNoYXBlW3BdO2lmKG51bGwhPWgmJm51bGwhPWQmJmghPT1kKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW5wdXQgXCIrbitcIiBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciBcIit0aGlzLm5hbWUrXCI6IGV4cGVjdGVkIHNoYXBlPVwiK2kuc2hhcGUrXCIsIGZvdW5kIHNoYXBlPVwiK3Iuc2hhcGUrXCIuXCIpfX19fX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3JldHVybiBlfSx0LnByb3RvdHlwZS5pbnZva2VDYWxsSG9vaz1mdW5jdGlvbihlLHQpe251bGwhPXRoaXMuX2NhbGxIb29rJiZ0aGlzLl9jYWxsSG9vayhlLHQpfSx0LnByb3RvdHlwZS5zZXRDYWxsSG9vaz1mdW5jdGlvbihlKXt0aGlzLl9jYWxsSG9vaz1lfSx0LnByb3RvdHlwZS5jbGVhckNhbGxIb29rPWZ1bmN0aW9uKCl7dGhpcy5fY2FsbEhvb2s9bnVsbH0sdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3Q9dHx8e30sdGhpcy5hc3NlcnROb3REaXNwb3NlZCgpO2Zvcih2YXIgcj10b0xpc3QoZSksaT0hMCxhPTAsbz1yO2E8by5sZW5ndGg7YSsrKXtpZighKG9bYV1pbnN0YW5jZW9mIFN5bWJvbGljVGVuc29yKSl7aT0hMTticmVha319Zm9yKHZhciBzPSEwLGw9MCx1PXI7bDx1Lmxlbmd0aDtsKyspe2lmKHVbbF1pbnN0YW5jZW9mIFN5bWJvbGljVGVuc29yKXtzPSExO2JyZWFrfX1pZihpPT09cyl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkFyZ3VtZW50cyB0byBhcHBseSgpIG11c3QgYmUgYWxsIFN5bWJvbGljVGVuc29ycyBvciBhbGwgVGVuc29yc1wiKTtyZXR1cm4gbmFtZVNjb3BlKHRoaXMubmFtZSxmdW5jdGlvbigpe2lmKCFuLmJ1aWx0KXtuLmFzc2VydElucHV0Q29tcGF0aWJpbGl0eShlKTtmb3IodmFyIGk9W10sYT0wLG89dG9MaXN0KGUpO2E8by5sZW5ndGg7YSsrKXt2YXIgbD1vW2FdO2kucHVzaChsLnNoYXBlKX1uLmJ1aWxkKHNpbmdsZXRvbk9yQXJyYXkoaSkpLG4uYnVpbHQ9ITAsbi5pbml0aWFsV2VpZ2h0cyYmbi5zZXRXZWlnaHRzKG4uaW5pdGlhbFdlaWdodHMpLG51bGw9PT1uLl9yZWZDb3VudCYmcyYmKG4uX3JlZkNvdW50PTEpfWlmKG4uYXNzZXJ0SW5wdXRDb21wYXRpYmlsaXR5KGUpLHMpe2Zvcih2YXIgdT1bXSxjPTAscD10b0xpc3QoZz1uLmNhbGwoZSx0KSk7YzxwLmxlbmd0aDtjKyspe3ZhciBoPXBbY107LTEhPT1yLmluZGV4T2YoaCkmJihoPWguY2xvbmUoKSksdS5wdXNoKGgpfWlmKGc9c2luZ2xldG9uT3JBcnJheSh1KSxudWxsIT1uLmFjdGl2aXR5UmVndWxhcml6ZXIpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJMYXllciBpbnZvY2F0aW9uIGluIHRoZSBwcmVzZW5jZSBvZiBhY3Rpdml0eSByZWd1bGFyaXplcihzKSBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik7cmV0dXJuIGd9dmFyIGQ9Y29sbGVjdElucHV0U2hhcGUoZSksZj1uLmNvbXB1dGVPdXRwdXRTaGFwZShkKSxnPXZvaWQgMCxtPWd1ZXNzT3V0cHV0RFR5cGUoZSk7aWYobi53YXJuT25JbmNvbXBhdGlibGVJbnB1dFNoYXBlKEFycmF5LmlzQXJyYXkoZSk/ZFswXTpkKSxnPW51bGwhPWYmJmYubGVuZ3RoPjAmJkFycmF5LmlzQXJyYXkoZlswXSk/Zi5tYXAoZnVuY3Rpb24ocixpKXtyZXR1cm4gbmV3IFN5bWJvbGljVGVuc29yKG0scixuLHRvTGlzdChlKSx0LG4ubmFtZSxpKX0pOm5ldyBTeW1ib2xpY1RlbnNvcihtLGYsbix0b0xpc3QoZSksdCxuLm5hbWUpLG4uYWRkSW5ib3VuZE5vZGUoZSxnLG51bGwsbnVsbCxkLGYsdCksbi5fcmVmQ291bnQrKyxudWxsIT1uLmFjdGl2aXR5UmVndWxhcml6ZXIpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJMYXllciBpbnZvY2F0aW9uIGluIHRoZSBwcmVzZW5jZSBvZiBhY3Rpdml0eSByZWd1bGFyaXplcihzKSBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik7cmV0dXJuIGd9KX0sdC5wcm90b3R5cGUud2Fybk9uSW5jb21wYXRpYmxlSW5wdXRTaGFwZT1mdW5jdGlvbihlKXtpZihudWxsIT10aGlzLmJhdGNoSW5wdXRTaGFwZSlpZihlLmxlbmd0aCE9PXRoaXMuYmF0Y2hJbnB1dFNoYXBlLmxlbmd0aCljb25zb2xlLndhcm4oXCJUaGUgcmFuayBvZiB0aGUgaW5wdXQgdGVuc29yIHByb3ZpZGVkIChzaGFwZTogXCIrSlNPTi5zdHJpbmdpZnkoZSkrXCIpIGRvZXMgbm90IG1hdGNoIHRoYXQgb2YgdGhlIGJhdGNoSW5wdXRTaGFwZSAoXCIrSlNPTi5zdHJpbmdpZnkodGhpcy5iYXRjaElucHV0U2hhcGUpK1wiKSBvZiB0aGUgbGF5ZXIgXCIrdGhpcy5uYW1lKTtlbHNle3ZhciB0PSExO3RoaXMuYmF0Y2hJbnB1dFNoYXBlLmZvckVhY2goZnVuY3Rpb24obixyKXtudWxsIT1uJiZudWxsIT1lW3JdJiZlW3JdIT09biYmKHQ9ITApfSksdCYmY29uc29sZS53YXJuKFwiVGhlIHNoYXBlIG9mIHRoZSBpbnB1dCB0ZW5zb3IgKFwiK0pTT04uc3RyaW5naWZ5KGUpK1wiKSBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0YXRpb24gb2YgbGF5ZXIgXCIrdGhpcy5uYW1lK1wiOiBcIitKU09OLnN0cmluZ2lmeSh0aGlzLmJhdGNoSW5wdXRTaGFwZSkpfX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwib3V0cHV0U2hhcGVcIix7Z2V0OmZ1bmN0aW9uKCl7aWYobnVsbD09dGhpcy5pbmJvdW5kTm9kZXN8fDA9PT10aGlzLmluYm91bmROb2Rlcy5sZW5ndGgpdGhyb3cgbmV3IEF0dHJpYnV0ZUVycm9yKFwiVGhlIGxheWVyIFwiK3RoaXMubmFtZStcIiBoYXMgbmV2ZXIgYmVlbiBjYWxsZWQgYW5kIHRodXMgaGFzIG5vIGRlZmluZWQgb3V0cHV0IHNoYXBlLlwiKTtmb3IodmFyIGU9W10sdD0wLG49dGhpcy5pbmJvdW5kTm9kZXM7dDxuLmxlbmd0aDt0Kyspe3ZhciByPW5bdF0saT1KU09OLnN0cmluZ2lmeShyLm91dHB1dFNoYXBlcyk7LTE9PT1lLmluZGV4T2YoaSkmJmUucHVzaChpKX1pZigxPT09ZS5sZW5ndGgpe3ZhciBhPXRoaXMuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFNoYXBlcztyZXR1cm4gQXJyYXkuaXNBcnJheShhKSYmQXJyYXkuaXNBcnJheShhWzBdKSYmMT09PWEubGVuZ3RoP2FbMF06YX10aHJvdyBuZXcgQXR0cmlidXRlRXJyb3IoXCJUaGUgbGF5ZXIgXCIrdGhpcy5uYW1lKycgaGFzIG11bHRpcGxlIGluYm91bmQgbm9kZXMgd2l0aCBkaWZmZXJlbnQgb3V0cHV0IHNoYXBlcy4gSGVuY2UgdGhlIG5vdGlvbiBvZiBcIm91dHV0IHNoYXBlXCIgaXMgaWxsLWRlZmluZWQgZm9yIHRoZSBsYXllci4nKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5jb3VudFBhcmFtcz1mdW5jdGlvbigpe2lmKCF0aGlzLmJ1aWx0KXRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJZb3UgdHJpZWQgdG8gY2FsbCBjb3VudFBhcmFtcygpIG9uIFwiK3RoaXMubmFtZStcIiwgYnV0IHRoZSBsYXllciBpcyBub3QgYnVpbHQgeWV0LiBCdWlsZCBpdCBmaXJzdCBieSBjYWxsaW5nIGJ1aWxkKGJhdGNoSW5wdXRTaGFwZSkuXCIpO3JldHVybiBjb3VudFBhcmFtc0luV2VpZ2h0cyh0aGlzLndlaWdodHMpfSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXt0aGlzLmJ1aWx0PSEwfSx0LnByb3RvdHlwZS5nZXRXZWlnaHRzPWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMSksYmF0Y2hHZXRWYWx1ZShlP3RoaXMudHJhaW5hYmxlV2VpZ2h0czp0aGlzLndlaWdodHMpfSx0LnByb3RvdHlwZS5zZXRXZWlnaHRzPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7dGlkeShmdW5jdGlvbigpe3ZhciBuPXQud2VpZ2h0cztpZihuLmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKCdZb3UgY2FsbGVkIHNldFdlaWdodHMod2VpZ2h0cykgb24gbGF5ZXIgXCInK3QubmFtZSsnXCIgd2l0aCBhIHdlaWdodCBsaXN0IG9mIGxlbmd0aCAnK2UubGVuZ3RoK1wiLCBidXQgdGhlIGxheWVyIHdhcyBleHBlY3RpbmcgXCIrbi5sZW5ndGgrXCIgd2VpZ2h0cy4gUHJvdmlkZWQgd2VpZ2h0czogXCIrZStcIi4uLlwiKTtpZigwIT09bi5sZW5ndGgpe2Zvcih2YXIgcj1bXSxpPWJhdGNoR2V0VmFsdWUobiksYT0wO2E8aS5sZW5ndGg7KythKXt2YXIgbz1pW2FdLHM9blthXSxsPWVbYV07aWYoIXV0aWwuYXJyYXlzRXF1YWwoby5zaGFwZSxsLnNoYXBlKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkxheWVyIHdlaWdodCBzaGFwZSBcIitvLnNoYXBlK1wiIG5vdCBjb21wYXRpYmxlIHdpdGggcHJvdmlkZWQgd2VpZ2h0IHNoYXBlIFwiK2wuc2hhcGUpO3IucHVzaChbcyxsXSl9YmF0Y2hTZXRWYWx1ZShyKX19KX0sdC5wcm90b3R5cGUuYWRkV2VpZ2h0PWZ1bmN0aW9uKGUsdCxuLHIsaSxhLG8pe2lmKC0xIT09dGhpcy5fYWRkZWRXZWlnaHROYW1lcy5pbmRleE9mKGUpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRHVwbGljYXRlIHdlaWdodCBuYW1lIFwiK2UrXCIgZm9yIGxheWVyIFwiK3RoaXMubmFtZSk7dGhpcy5fYWRkZWRXZWlnaHROYW1lcy5wdXNoKGUpLG51bGw9PW4mJihuPVwiZmxvYXQzMlwiKSx0aGlzLmZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQmJihyPWdldEluaXRpYWxpemVyKFwiemVyb3NcIikpO3ZhciBzPXIuYXBwbHkodCxuKSxsPW5ldyBMYXllclZhcmlhYmxlKHMsbixlLGEsbyk7cmV0dXJuIHMuZGlzcG9zZSgpLG51bGwhPWkmJnRoaXMuYWRkTG9zcyhmdW5jdGlvbigpe3JldHVybiBpLmFwcGx5KGwucmVhZCgpKX0pLG51bGw9PWEmJihhPSEwKSxhP3RoaXMuX3RyYWluYWJsZVdlaWdodHMucHVzaChsKTp0aGlzLl9ub25UcmFpbmFibGVXZWlnaHRzLnB1c2gobCksbH0sdC5wcm90b3R5cGUuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZD1mdW5jdGlvbihlKXt0aGlzLmZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQ9ZX0sdC5wcm90b3R5cGUuYWRkTG9zcz1mdW5jdGlvbihlKXt2YXIgdDtudWxsPT1lfHxBcnJheS5pc0FycmF5KGUpJiYwPT09ZS5sZW5ndGh8fChlPXRvTGlzdChlKSx2b2lkIDAhPT10aGlzLl9sb3NzZXMmJm51bGwhPT10aGlzLl9sb3NzZXMmJih0PXRoaXMubG9zc2VzKS5wdXNoLmFwcGx5KHQsZSkpfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LHQucHJvdG90eXBlLmNvbXB1dGVNYXNrPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztpZighdGhpcy5zdXBwb3J0c01hc2tpbmcpe2lmKG51bGwhPXQpe2lmKCFBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJMYXllciBcIit0aGlzLm5hbWUrXCIgZG9lcyBub3Qgc3VwcG9ydCBtYXNraW5nLCBidXQgd2FzIHBhc3NlZCBhbiBpbnB1dE1hc2suXCIpO3QuZm9yRWFjaChmdW5jdGlvbihlKXtpZihudWxsIT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJMYXllciBcIituLm5hbWUrXCIgZG9lcyBub3Qgc3VwcG9ydCBtYXNraW5nLCBidXQgd2FzIHBhc3NlZCBhbiBpbnB1dE1hc2suXCIpfSl9cmV0dXJuIG51bGx9cmV0dXJuIHR9LHQucHJvdG90eXBlLmFkZEluYm91bmROb2RlPWZ1bmN0aW9uKGUsdCxuLHIsaSxhLG8pe3ZvaWQgMD09PW8mJihvPW51bGwpO3ZhciBzPXRvTGlzdChlKTt0PXRvTGlzdCh0KSxuPXRvTGlzdChuKSxyPXRvTGlzdChyKSxpPW5vcm1hbGl6ZVNoYXBlTGlzdChpKSxhPW5vcm1hbGl6ZVNoYXBlTGlzdChhKTtmb3IodmFyIGw9W10sdT1bXSxjPVtdLHA9MCxoPXM7cDxoLmxlbmd0aDtwKyspe3ZhciBkPWhbcF07bC5wdXNoKGQuc291cmNlTGF5ZXIpLHUucHVzaChkLm5vZGVJbmRleCksYy5wdXNoKGQudGVuc29ySW5kZXgpfW5ldyBOb2RlKHtvdXRib3VuZExheWVyOnRoaXMsaW5ib3VuZExheWVyczpsLG5vZGVJbmRpY2VzOnUsdGVuc29ySW5kaWNlczpjLGlucHV0VGVuc29yczpzLG91dHB1dFRlbnNvcnM6dCxpbnB1dE1hc2tzOm4sb3V0cHV0TWFza3M6cixpbnB1dFNoYXBlczppLG91dHB1dFNoYXBlczphfSxvKTtmb3IodmFyIGY9MDtmPHQubGVuZ3RoO2YrKyl0W2ZdLnNvdXJjZUxheWVyPXRoaXMsdFtmXS5ub2RlSW5kZXg9dGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoLTEsdFtmXS50ZW5zb3JJbmRleD1mfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgZT17bmFtZTp0aGlzLm5hbWUsdHJhaW5hYmxlOnRoaXMudHJhaW5hYmxlfTtyZXR1cm4gbnVsbCE9dGhpcy5iYXRjaElucHV0U2hhcGUmJihlLmJhdGNoSW5wdXRTaGFwZT10aGlzLmJhdGNoSW5wdXRTaGFwZSksbnVsbCE9dGhpcy5kdHlwZSYmKGUuZHR5cGU9dGhpcy5kdHlwZSksZX0sdC5wcm90b3R5cGUuZGlzcG9zZVdlaWdodHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53ZWlnaHRzLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGUuZGlzcG9zZSgpfSksdGhpcy53ZWlnaHRzLmxlbmd0aH0sdC5wcm90b3R5cGUuYXNzZXJ0Tm90RGlzcG9zZWQ9ZnVuY3Rpb24oKXtpZigwPT09dGhpcy5fcmVmQ291bnQpdGhyb3cgbmV3IEVycm9yKFwiTGF5ZXIgJ1wiK3RoaXMubmFtZStcIicgaXMgYWxyZWFkeSBkaXNwb3NlZC5cIil9LHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtpZighdGhpcy5idWlsdCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZGlzcG9zZSBMYXllciBcIit0aGlzLm5hbWUrXCIgYmVjYXVzZSBpdCBoYXMgbm90IGJlZW4gYnVpbHQgeWV0LlwiKTtpZihudWxsPT09dGhpcy5fcmVmQ291bnQpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRpc3Bvc2UgTGF5ZXIgXCIrdGhpcy5uYW1lK1wiIGJlY2F1c2UgaXQgaGFzIG5vdCBiZWVuIHVzZWQgeWV0LlwiKTt0aGlzLmFzc2VydE5vdERpc3Bvc2VkKCk7dmFyIGU9MDtyZXR1cm4gMD09LS10aGlzLl9yZWZDb3VudCYmKGU9dGhpcy5kaXNwb3NlV2VpZ2h0cygpKSx7cmVmQ291bnRBZnRlckRpc3Bvc2U6dGhpcy5fcmVmQ291bnQsbnVtRGlzcG9zZWRWYXJpYWJsZXM6ZX19LHR9KHNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlKTtmdW5jdGlvbiBjb2xsZWN0SW5wdXRTaGFwZShlKXtmb3IodmFyIHQ9W10sbj0wLHI9ZT10b0xpc3QoZSk7bjxyLmxlbmd0aDtuKyspe3ZhciBpPXJbbl07dC5wdXNoKGkuc2hhcGUpfXJldHVybiBzaW5nbGV0b25PckFycmF5KHQpfWZ1bmN0aW9uIGd1ZXNzT3V0cHV0RFR5cGUoZSl7cmV0dXJuXCJmbG9hdDMyXCJ9ZnVuY3Rpb24gZ2V0U291cmNlSW5wdXRzKGUsdCxuKXtpZigobnVsbD09dHx8bnVsbCE9biYmbj4wKSYmKHQ9ZS5zb3VyY2VMYXllcixuPWUubm9kZUluZGV4KSwwPT09dC5pbmJvdW5kTm9kZXMubGVuZ3RoKXJldHVybltlXTt2YXIgcj10LmluYm91bmROb2Rlc1tuXTtpZigwPT09ci5pbmJvdW5kTGF5ZXJzLmxlbmd0aClyZXR1cm4gci5pbnB1dFRlbnNvcnM7Zm9yKHZhciBpPVtdLGE9MDthPHIuaW5ib3VuZExheWVycy5sZW5ndGg7YSsrKWZvcih2YXIgbz0wLHM9Z2V0U291cmNlSW5wdXRzKHIuaW5wdXRUZW5zb3JzW2FdLHIuaW5ib3VuZExheWVyc1thXSxyLm5vZGVJbmRpY2VzW2FdKTtvPHMubGVuZ3RoO28rKyl7dmFyIGw9c1tvXTstMT09PWkuaW5kZXhPZihsKSYmaS5wdXNoKGwpfXJldHVybiBpfXZhciBNb2RlbExvZ2dpbmdWZXJib3NpdHksSW5wdXRMYXllcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHtkdHlwZTp0LmR0eXBlLG5hbWU6bnVsbCE9dC5uYW1lP3QubmFtZTpnZXRVaWQoXCJpbnB1dFwiKS50b1N0cmluZygpfSl8fHRoaXM7aWYobnVsbD09dC5iYXRjaFNpemUmJih0LmJhdGNoU2l6ZT1udWxsKSxudWxsPT10LnNwYXJzZSYmKHQuc3BhcnNlPSExKSxuLnRyYWluYWJsZT0hMSxuLmJ1aWx0PSEwLG4uc3BhcnNlPXQuc3BhcnNlLG51bGwhPXQuaW5wdXRTaGFwZSYmbnVsbCE9dC5iYXRjaElucHV0U2hhcGUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJPbmx5IHByb3ZpZGUgdGhlIGlucHV0U2hhcGUgT1IgYmF0Y2hJbnB1dFNoYXBlIGFyZ3VtZW50IHRvIGlucHV0TGF5ZXIsIG5vdCBib3RoIGF0IHRoZSBzYW1lIHRpbWUuXCIpO3ZhciByPXQuYmF0Y2hJbnB1dFNoYXBlO2lmKG51bGw9PXIpe2lmKG51bGw9PXQuaW5wdXRTaGFwZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkFuIElucHV0TGF5ZXIgc2hvdWxkIGJlIHBhc3NlZCBlaXRoZXIgYSBgYmF0Y2hJbnB1dFNoYXBlYCBvciBhbiBgaW5wdXRTaGFwZWAuXCIpO3I9W3QuYmF0Y2hTaXplXS5jb25jYXQodC5pbnB1dFNoYXBlKX1lbHNlIGlmKG51bGwhPXQuYmF0Y2hTaXplKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ2Fubm90IHNwZWNpZnkgYmF0Y2hTaXplIGlmIGJhdGNoSW5wdXRTaGFwZSBpcyBzcGVjaWZpZWQgd2hlbiBjcmVhdGluZyBhbiBJbnB1dExheWVyLlwiKTt2YXIgaT10LmR0eXBlfHxcImZsb2F0MzJcIjtuLmJhdGNoSW5wdXRTaGFwZT1yLG4uZHR5cGU9aSxuLmlucHV0U3BlYz1be3NoYXBlOnJ9XTt2YXIgYT1uZXcgU3ltYm9saWNUZW5zb3Iobi5kdHlwZSxuLmJhdGNoSW5wdXRTaGFwZSxuLFtdLHt9LG4ubmFtZSk7cmV0dXJuIGEubm9kZUluZGV4PTAsYS50ZW5zb3JJbmRleD0wLG5ldyBOb2RlKHtvdXRib3VuZExheWVyOm4saW5ib3VuZExheWVyczpbXSxub2RlSW5kaWNlczpbXSx0ZW5zb3JJbmRpY2VzOltdLGlucHV0VGVuc29yczpbYV0sb3V0cHV0VGVuc29yczpbYV0saW5wdXRNYXNrczpbbnVsbF0sb3V0cHV0TWFza3M6W251bGxdLGlucHV0U2hhcGVzOltyXSxvdXRwdXRTaGFwZXM6W3JdfSksbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0KXt0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNhbm5vdCBwYXNzIGFueSBpbnB1dCB0byBhbiBJbnB1dExheWVyJ3MgYXBwbHkoKSBtZXRob2QuIElucHV0TGF5ZXIgbmFtZTogXCIrdGhpcy5uYW1lKX0sdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3JldHVybntyZWZDb3VudEFmdGVyRGlzcG9zZTp0aGlzLl9yZWZDb3VudCxudW1EaXNwb3NlZFZhcmlhYmxlczowfX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2JhdGNoSW5wdXRTaGFwZTp0aGlzLmJhdGNoSW5wdXRTaGFwZSxkdHlwZTp0aGlzLmR0eXBlLHNwYXJzZTp0aGlzLnNwYXJzZSxuYW1lOnRoaXMubmFtZX19LHQuY2xhc3NOYW1lPVwiSW5wdXRMYXllclwiLHR9KExheWVyKTtmdW5jdGlvbiBJbnB1dChlKXtpZihudWxsPT1lLmJhdGNoU2hhcGUmJm51bGw9PWUuc2hhcGUpdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgdG8gSW5wdXQgZWl0aGVyIGEgYHNoYXBlYCBvciBhIGBiYXRjaFNoYXBlYCBhcmd1bWVudC4gTm90ZSB0aGF0IGBzaGFwZWAgZG9lcyBub3QgaW5jbHVkZSB0aGUgYmF0Y2ggZGltZW5zaW9uLlwiKTtpZihudWxsIT1lLmJhdGNoU2hhcGUmJm51bGwhPWUuc2hhcGUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBlaXRoZXIgYSBgc2hhcGVgIG9yIGBiYXRjaFNoYXBlYCBhcmd1bWVudCB0byBJbnB1dCwgYnV0IG5vdCBib3RoLlwiKTt2YXIgdD1lLmJhdGNoU2hhcGU7bnVsbCE9ZS5zaGFwZSYmbnVsbD09dCYmKHQ9W251bGxdLmNvbmNhdChlLnNoYXBlKSk7dmFyIG49ZS5kdHlwZTtyZXR1cm4gbnVsbD09biYmKG49XCJmbG9hdDMyXCIpLG5ldyBJbnB1dExheWVyKHtiYXRjaElucHV0U2hhcGU6dCxuYW1lOmUubmFtZSxkdHlwZTpuLHNwYXJzZTplLnNwYXJzZX0pLmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzWzBdfWZ1bmN0aW9uIHJlc29sdmVTY2FsYXJzSW5Mb2dzKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsbixyLGksYSxvLHMsbDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih1KXtzd2l0Y2godS5sYWJlbCl7Y2FzZSAwOmlmKG51bGw9PWUpcmV0dXJuWzJdO2ZvcihpIGluIHQ9W10sbj1bXSxyPVtdLGUpXCJudW1iZXJcIiE9dHlwZW9mKGE9ZVtpXSkmJihvPWEsdC5wdXNoKG8uZGF0YSgpKSxuLnB1c2goaSksci5wdXNoKG8pKTtyZXR1cm4gdC5sZW5ndGg+MD9bNCxQcm9taXNlLmFsbCh0KV06WzMsMl07Y2FzZSAxOmZvcihzPXUuc2VudCgpLGw9MDtsPHMubGVuZ3RoOysrbCllW25bbF1dPXNbbF1bMF07ZGlzcG9zZShyKSx1LmxhYmVsPTI7Y2FzZSAyOnJldHVyblsyXX19KX0pfWZ1bmN0aW9uIGRpc3Bvc2VUZW5zb3JzSW5Mb2dzKGUpe2lmKG51bGwhPWUpZm9yKHZhciB0IGluIGUpe3ZhciBuPWVbdF07XCJudW1iZXJcIiE9dHlwZW9mIG4mJm4uZGlzcG9zZSgpfX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoSW5wdXRMYXllciksZnVuY3Rpb24oZSl7ZVtlLlNJTEVOVD0wXT1cIlNJTEVOVFwiLGVbZS5WRVJCT1NFPTFdPVwiVkVSQk9TRVwifShNb2RlbExvZ2dpbmdWZXJib3NpdHl8fChNb2RlbExvZ2dpbmdWZXJib3NpdHk9e30pKTt2YXIgREVGQVVMVF9ZSUVMRF9FVkVSWV9NUz0xMjUsQmFzZUNhbGxiYWNrPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3RoaXMudmFsaWRhdGlvbkRhdGE9bnVsbH1yZXR1cm4gZS5wcm90b3R5cGUuc2V0UGFyYW1zPWZ1bmN0aW9uKGUpe3RoaXMucGFyYW1zPWV9LGUucHJvdG90eXBlLm9uRXBvY2hCZWdpbj1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuWzJdfSl9KX0sZS5wcm90b3R5cGUub25FcG9jaEVuZD1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuWzJdfSl9KX0sZS5wcm90b3R5cGUub25CYXRjaEJlZ2luPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm5bMl19KX0pfSxlLnByb3RvdHlwZS5vbkJhdGNoRW5kPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm5bMl19KX0pfSxlLnByb3RvdHlwZS5vblRyYWluQmVnaW49ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm5bMl19KX0pfSxlLnByb3RvdHlwZS5vblRyYWluRW5kPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuWzJdfSl9KX0sZS5wcm90b3R5cGUuc2V0TW9kZWw9ZnVuY3Rpb24oZSl7fSxlfSgpLENhbGxiYWNrTGlzdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXt2b2lkIDA9PT10JiYodD0xMCksbnVsbD09ZSYmKGU9W10pLHRoaXMuY2FsbGJhY2tzPWUsdGhpcy5xdWV1ZUxlbmd0aD10fXJldHVybiBlLnByb3RvdHlwZS5hcHBlbmQ9ZnVuY3Rpb24oZSl7dGhpcy5jYWxsYmFja3MucHVzaChlKX0sZS5wcm90b3R5cGUuc2V0UGFyYW1zPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wLG49dGhpcy5jYWxsYmFja3M7dDxuLmxlbmd0aDt0Kyspe25bdF0uc2V0UGFyYW1zKGUpfX0sZS5wcm90b3R5cGUuc2V0TW9kZWw9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTAsbj10aGlzLmNhbGxiYWNrczt0PG4ubGVuZ3RoO3QrKyl7blt0XS5zZXRNb2RlbChlKX19LGUucHJvdG90eXBlLm9uRXBvY2hCZWdpbj1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIG4scjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihpKXtzd2l0Y2goaS5sYWJlbCl7Y2FzZSAwOm51bGw9PXQmJih0PXt9KSxuPTAscj10aGlzLmNhbGxiYWNrcyxpLmxhYmVsPTE7Y2FzZSAxOnJldHVybiBuPHIubGVuZ3RoP1s0LHJbbl0ub25FcG9jaEJlZ2luKGUsdCldOlszLDRdO2Nhc2UgMjppLnNlbnQoKSxpLmxhYmVsPTM7Y2FzZSAzOnJldHVybiBuKyssWzMsMV07Y2FzZSA0OnJldHVyblsyXX19KX0pfSxlLnByb3RvdHlwZS5vbkVwb2NoRW5kPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbixyO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGkpe3N3aXRjaChpLmxhYmVsKXtjYXNlIDA6bnVsbD09dCYmKHQ9e30pLG49MCxyPXRoaXMuY2FsbGJhY2tzLGkubGFiZWw9MTtjYXNlIDE6cmV0dXJuIG48ci5sZW5ndGg/WzQscltuXS5vbkVwb2NoRW5kKGUsdCldOlszLDRdO2Nhc2UgMjppLnNlbnQoKSxpLmxhYmVsPTM7Y2FzZSAzOnJldHVybiBuKyssWzMsMV07Y2FzZSA0OnJldHVyblsyXX19KX0pfSxlLnByb3RvdHlwZS5vbkJhdGNoQmVnaW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBuLHI7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oaSl7c3dpdGNoKGkubGFiZWwpe2Nhc2UgMDpudWxsPT10JiYodD17fSksbj0wLHI9dGhpcy5jYWxsYmFja3MsaS5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gbjxyLmxlbmd0aD9bNCxyW25dLm9uQmF0Y2hCZWdpbihlLHQpXTpbMyw0XTtjYXNlIDI6aS5zZW50KCksaS5sYWJlbD0zO2Nhc2UgMzpyZXR1cm4gbisrLFszLDFdO2Nhc2UgNDpyZXR1cm5bMl19fSl9KX0sZS5wcm90b3R5cGUub25CYXRjaEVuZD1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIG4scjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihpKXtzd2l0Y2goaS5sYWJlbCl7Y2FzZSAwOm51bGw9PXQmJih0PXt9KSxuPTAscj10aGlzLmNhbGxiYWNrcyxpLmxhYmVsPTE7Y2FzZSAxOnJldHVybiBuPHIubGVuZ3RoP1s0LHJbbl0ub25CYXRjaEVuZChlLHQpXTpbMyw0XTtjYXNlIDI6aS5zZW50KCksaS5sYWJlbD0zO2Nhc2UgMzpyZXR1cm4gbisrLFszLDFdO2Nhc2UgNDpyZXR1cm5bMl19fSl9KX0sZS5wcm90b3R5cGUub25UcmFpbkJlZ2luPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsbjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOm51bGw9PWUmJihlPXt9KSx0PTAsbj10aGlzLmNhbGxiYWNrcyxyLmxhYmVsPTE7Y2FzZSAxOnJldHVybiB0PG4ubGVuZ3RoP1s0LG5bdF0ub25UcmFpbkJlZ2luKGUpXTpbMyw0XTtjYXNlIDI6ci5zZW50KCksci5sYWJlbD0zO2Nhc2UgMzpyZXR1cm4gdCsrLFszLDFdO2Nhc2UgNDpyZXR1cm5bMl19fSl9KX0sZS5wcm90b3R5cGUub25UcmFpbkVuZD1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LG47cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpudWxsPT1lJiYoZT17fSksdD0wLG49dGhpcy5jYWxsYmFja3Msci5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gdDxuLmxlbmd0aD9bNCxuW3RdLm9uVHJhaW5FbmQoZSldOlszLDRdO2Nhc2UgMjpyLnNlbnQoKSxyLmxhYmVsPTM7Y2FzZSAzOnJldHVybiB0KyssWzMsMV07Y2FzZSA0OnJldHVyblsyXX19KX0pfSxlfSgpLEJhc2VMb2dnZXI9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBlLmNhbGwodGhpcyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLm9uRXBvY2hCZWdpbj1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnNlZW49MCx0aGlzLnRvdGFscz17fSxbMl19KX0pfSx0LnByb3RvdHlwZS5vbkJhdGNoRW5kPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxuLHIsaSxhPXRoaXM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obyl7Zm9yKGkgaW4gbnVsbD09dCYmKHQ9e30pLGU9bnVsbD09dC5zaXplPzA6dC5zaXplLHRoaXMuc2Vlbis9ZSxuPWZ1bmN0aW9uKG4pe3ZhciBpPXRbbl07aWYoXCJudW1iZXJcIj09dHlwZW9mIGkpci50b3RhbHMuaGFzT3duUHJvcGVydHkobil8fChyLnRvdGFsc1tuXT0wKSxyLnRvdGFsc1tuXT1yLnRvdGFsc1tuXStpKmU7ZWxzZXt2YXIgbz12b2lkIDA7biBpbiByLnRvdGFscz9vPXIudG90YWxzW25dOnIudG90YWxzW25dPTAsci50b3RhbHNbbl09dGlkeShmdW5jdGlvbigpe3JldHVybiBhZGQoYS50b3RhbHNbbl0sbXVsKGksZSkpfSksbnVsbCE9byYmby5kaXNwb3NlKCl9fSxyPXRoaXMsdCluKGkpO3JldHVyblsyXX0pfSl9LHQucHJvdG90eXBlLm9uRXBvY2hFbmQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLG4scixpLGEsbz10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHMpe2lmKG51bGwhPXQpZm9yKGU9ZnVuY3Rpb24oZSl7aWYobnVsbD09bi50b3RhbHNbZV0pcmV0dXJuXCJjb250aW51ZVwiO1wibnVtYmVyXCI9PXR5cGVvZiBuLnRvdGFsc1tlXT90W2VdPW4udG90YWxzW2VdL24uc2Vlbjp0aWR5KGZ1bmN0aW9uKCl7dFtlXT1tdWwoZGl2KDEsby5zZWVuKSxvLnRvdGFsc1tlXSksby50b3RhbHNbZV0uZGlzcG9zZSgpLGtlZXAodFtlXSl9KX0sbj10aGlzLHI9MCxpPXRoaXMucGFyYW1zLm1ldHJpY3M7cjxpLmxlbmd0aDtyKyspYT1pW3JdLGUoYSk7cmV0dXJuWzJdfSl9KX0sdH0oQmFzZUNhbGxiYWNrKSxIaXN0b3J5PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5vblRyYWluQmVnaW49ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5lcG9jaD1bXSx0aGlzLmhpc3Rvcnk9e30sWzJdfSl9KX0sdC5wcm90b3R5cGUub25FcG9jaEVuZD1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7Zm9yKG4gaW4gbnVsbD09dCYmKHQ9e30pLHRoaXMuZXBvY2gucHVzaChlKSx0KW51bGw9PXRoaXMuaGlzdG9yeVtuXSYmKHRoaXMuaGlzdG9yeVtuXT1bXSksdGhpcy5oaXN0b3J5W25dLnB1c2godFtuXSk7cmV0dXJuWzJdfSl9KX0sdC5wcm90b3R5cGUuc3luY0RhdGE9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLHQsbixyLGksYSxvLHMsbDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih1KXtzd2l0Y2godS5sYWJlbCl7Y2FzZSAwOmZvcihyIGluIGU9W10sdD1bXSxuPVtdLHRoaXMuaGlzdG9yeSlmb3IoaT10aGlzLmhpc3Rvcnlbcl0sYT0wO2E8aS5sZW5ndGg7KythKVwibnVtYmVyXCIhPXR5cGVvZiBpW2FdJiYobz1pW2FdLGUucHVzaChvLmRhdGEoKSksdC5wdXNoKHIpLG4ucHVzaChhKSk7cmV0dXJuWzQsUHJvbWlzZS5hbGwoZSldO2Nhc2UgMTpmb3Iocz11LnNlbnQoKSxsPTA7bDxzLmxlbmd0aDsrK2wpdGhpcy5oaXN0b3J5W3RbbF1dW25bbF1dLmRpc3Bvc2UoKSx0aGlzLmhpc3RvcnlbdFtsXV1bbltsXV09c1tsXVswXTtyZXR1cm5bMl19fSl9KX0sdH0oQmFzZUNhbGxiYWNrKSxDdXN0b21DYWxsYmFjaz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQsbil7dmFyIHI9ZS5jYWxsKHRoaXMpfHx0aGlzO2lmKHIuY3VycmVudEVwb2NoPTAsci55aWVsZEV2ZXJ5PW58fFwiYXV0b1wiLFwiYXV0b1wiPT09ci55aWVsZEV2ZXJ5JiYoci55aWVsZEV2ZXJ5PURFRkFVTFRfWUlFTERfRVZFUllfTVMpLFwibmV2ZXJcIj09PXIueWllbGRFdmVyeSYmbnVsbCE9dC5vbllpZWxkKXRocm93IG5ldyBFcnJvcihcInlpZWxkRXZlcnkgaXMgYG5ldmVyYCBidXQgeW91IHByb3ZpZGVkIGFuIGBvbllpZWxkYCBjYWxsYmFjay4gRWl0aGVyIGNoYW5nZSBgeWllbGRFdmVyeWAgb3IgcmVtb3ZlIHRoZSBjYWxsYmFja1wiKTtyZXR1cm4gdXRpbC5pc051bWJlcihyLnlpZWxkRXZlcnkpJiYoci5tYXliZVdhaXQ9ZGVib3VuY2Uoci5tYXliZVdhaXQuYmluZChyKSxyLnlpZWxkRXZlcnkpKSxyLnRyYWluQmVnaW49dC5vblRyYWluQmVnaW4sci50cmFpbkVuZD10Lm9uVHJhaW5FbmQsci5lcG9jaEJlZ2luPXQub25FcG9jaEJlZ2luLHIuZXBvY2hFbmQ9dC5vbkVwb2NoRW5kLHIuYmF0Y2hCZWdpbj10Lm9uQmF0Y2hCZWdpbixyLmJhdGNoRW5kPXQub25CYXRjaEVuZCxyLnlpZWxkPXQub25ZaWVsZCxyfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5tYXliZVdhaXQ9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHI7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oaSl7c3dpdGNoKGkubGFiZWwpe2Nhc2UgMDpyZXR1cm4gcj1bXSxudWxsPT10aGlzLnlpZWxkP1szLDJdOls0LHJlc29sdmVTY2FsYXJzSW5Mb2dzKG4pXTtjYXNlIDE6aS5zZW50KCksci5wdXNoKHRoaXMueWllbGQoZSx0LG4pKSxpLmxhYmVsPTI7Y2FzZSAyOnJldHVybiByLnB1c2gobmV4dEZyYW1lKCkpLFs0LFByb21pc2UuYWxsKHIpXTtjYXNlIDM6cmV0dXJuIGkuc2VudCgpLFsyXX19KX0pfSx0LnByb3RvdHlwZS5vbkVwb2NoQmVnaW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHRoaXMuY3VycmVudEVwb2NoPWUsbnVsbD09dGhpcy5lcG9jaEJlZ2luP1szLDNdOls0LHJlc29sdmVTY2FsYXJzSW5Mb2dzKHQpXTtjYXNlIDE6cmV0dXJuIG4uc2VudCgpLFs0LHRoaXMuZXBvY2hCZWdpbihlLHQpXTtjYXNlIDI6bi5zZW50KCksbi5sYWJlbD0zO2Nhc2UgMzpyZXR1cm5bMl19fSl9KX0sdC5wcm90b3R5cGUub25FcG9jaEVuZD1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbj1bXSxudWxsPT10aGlzLmVwb2NoRW5kP1szLDJdOls0LHJlc29sdmVTY2FsYXJzSW5Mb2dzKHQpXTtjYXNlIDE6ci5zZW50KCksbi5wdXNoKHRoaXMuZXBvY2hFbmQoZSx0KSksci5sYWJlbD0yO2Nhc2UgMjpyZXR1cm5cImVwb2NoXCI9PT10aGlzLnlpZWxkRXZlcnkmJm4ucHVzaChuZXh0RnJhbWUoKSksWzQsUHJvbWlzZS5hbGwobildO2Nhc2UgMzpyZXR1cm4gci5zZW50KCksWzJdfX0pfSl9LHQucHJvdG90eXBlLm9uQmF0Y2hCZWdpbj1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbnVsbD09dGhpcy5iYXRjaEJlZ2luP1szLDNdOls0LHJlc29sdmVTY2FsYXJzSW5Mb2dzKHQpXTtjYXNlIDE6cmV0dXJuIG4uc2VudCgpLFs0LHRoaXMuYmF0Y2hCZWdpbihlLHQpXTtjYXNlIDI6bi5zZW50KCksbi5sYWJlbD0zO2Nhc2UgMzpyZXR1cm5bMl19fSl9KX0sdC5wcm90b3R5cGUub25CYXRjaEVuZD1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbj1bXSxudWxsPT10aGlzLmJhdGNoRW5kP1szLDJdOls0LHJlc29sdmVTY2FsYXJzSW5Mb2dzKHQpXTtjYXNlIDE6ci5zZW50KCksbi5wdXNoKHRoaXMuYmF0Y2hFbmQoZSx0KSksci5sYWJlbD0yO2Nhc2UgMjpyZXR1cm5cImJhdGNoXCI9PT10aGlzLnlpZWxkRXZlcnk/bi5wdXNoKG5leHRGcmFtZSgpKTp1dGlsLmlzTnVtYmVyKHRoaXMueWllbGRFdmVyeSkmJm4ucHVzaCh0aGlzLm1heWJlV2FpdCh0aGlzLmN1cnJlbnRFcG9jaCxlLHQpKSxbNCxQcm9taXNlLmFsbChuKV07Y2FzZSAzOnJldHVybiByLnNlbnQoKSxbMl19fSl9KX0sdC5wcm90b3R5cGUub25UcmFpbkJlZ2luPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbnVsbD09dGhpcy50cmFpbkJlZ2luP1szLDNdOls0LHJlc29sdmVTY2FsYXJzSW5Mb2dzKGUpXTtjYXNlIDE6cmV0dXJuIHQuc2VudCgpLFs0LHRoaXMudHJhaW5CZWdpbihlKV07Y2FzZSAyOnQuc2VudCgpLHQubGFiZWw9MztjYXNlIDM6cmV0dXJuWzJdfX0pfSl9LHQucHJvdG90eXBlLm9uVHJhaW5FbmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOnJldHVybiBudWxsPT10aGlzLnRyYWluRW5kP1szLDNdOls0LHJlc29sdmVTY2FsYXJzSW5Mb2dzKGUpXTtjYXNlIDE6cmV0dXJuIHQuc2VudCgpLFs0LHRoaXMudHJhaW5FbmQoZSldO2Nhc2UgMjp0LnNlbnQoKSx0LmxhYmVsPTM7Y2FzZSAzOnJldHVyblsyXX19KX0pfSx0fShCYXNlQ2FsbGJhY2spO2Z1bmN0aW9uIHN0YW5kYXJkaXplQ2FsbGJhY2tzKGUsdCl7cmV0dXJuIG51bGw9PWUmJihlPXt9KSxlIGluc3RhbmNlb2YgQmFzZUNhbGxiYWNrP1tlXTpBcnJheS5pc0FycmF5KGUpJiZlWzBdaW5zdGFuY2VvZiBCYXNlQ2FsbGJhY2s/ZTp0b0xpc3QoZSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgQ3VzdG9tQ2FsbGJhY2soZSx0KX0pfXZhciBDYWxsYmFja0NvbnN0cnVjdG9yUmVnaXN0cnk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7fXJldHVybiBlLnJlZ2lzdGVyQ2FsbGJhY2tDb25zdHJ1Y3Rvcj1mdW5jdGlvbih0LG4pe3V0aWwuYXNzZXJ0KHQ+PTAmJk51bWJlci5pc0ludGVnZXIodCksZnVuY3Rpb24oKXtyZXR1cm5cIlZlcmJvc2l0eSBsZXZlbCBpcyBleHBlY3RlZCB0byBiZSBhbiBpbnRlZ2VyID49IDAsIGJ1dCBnb3QgXCIrdH0pLGUuY2hlY2tGb3JEdXBsaWNhdGUobiksbnVsbD09ZS5jb25zdHJ1Y3RvcnNbdF0mJihlLmNvbnN0cnVjdG9yc1t0XT1bXSksZS5jb25zdHJ1Y3RvcnNbdF0ucHVzaChuKX0sZS5jaGVja0ZvckR1cGxpY2F0ZT1mdW5jdGlvbih0KXtmb3IodmFyIG4gaW4gZS5jb25zdHJ1Y3RvcnMpe2UuY29uc3RydWN0b3JzWytuXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2lmKGU9PT10KXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRHVwbGljYXRlIGNhbGxiYWNrIGNvbnN0cnVjdG9yLlwiKX0pfX0sZS5jbGVhcj1mdW5jdGlvbigpe2UuY29uc3RydWN0b3JzPXt9fSxlLmNyZWF0ZUNhbGxiYWNrcz1mdW5jdGlvbih0KXt2YXIgbj1bXTtmb3IodmFyIHIgaW4gZS5jb25zdHJ1Y3RvcnMpe3ZhciBpPStyO3Q+PWkmJm4ucHVzaC5hcHBseShuLGUuY29uc3RydWN0b3JzW2ldKX1yZXR1cm4gbi5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBlfSl9LGUuY29uc3RydWN0b3JzPXt9LGV9KCk7ZnVuY3Rpb24gY29uZmlndXJlQ2FsbGJhY2tzKGUsdCxuLHIsaSxhLG8scyxsKXt2YXIgdT1uZXcgSGlzdG9yeSxjPVtuZXcgQmFzZUxvZ2dlcl0uY29uY2F0KENhbGxiYWNrQ29uc3RydWN0b3JSZWdpc3RyeS5jcmVhdGVDYWxsYmFja3ModCkpO251bGwhPWUmJmMucHVzaC5hcHBseShjLGUpLGMucHVzaCh1KTt2YXIgcD1uZXcgQ2FsbGJhY2tMaXN0KGMpO3JldHVybiBwLnNldFBhcmFtcyh7ZXBvY2hzOm4saW5pdGlhbEVwb2NoOnIsc2FtcGxlczppLHN0ZXBzOmEsYmF0Y2hTaXplOm8sdmVyYm9zZTp0LGRvVmFsaWRhdGlvbjpzLG1ldHJpY3M6bH0pLHtjYWxsYmFja0xpc3Q6cCxoaXN0b3J5OnV9fWZ1bmN0aW9uIGwyTm9ybWFsaXplKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtcImZsb2F0MzJcIiE9PWUuZHR5cGUmJihlPWUuYXNUeXBlKFwiZmxvYXQzMlwiKSk7dmFyIG49c3VtKHNxdWFyZShlKSx0LCEwKSxyPWZpbGwobi5zaGFwZSxlcHNpbG9uKCkpLGk9c3FydChtYXhpbXVtKG4scikpO3JldHVybiBkaXYoZSxpKX0pfWZ1bmN0aW9uIG1lYW5TcXVhcmVkRXJyb3IoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBtZWFuKHNxdWFyZShzdWIodCxlKSksLTEpfSl9ZnVuY3Rpb24gbWVhbkFic29sdXRlRXJyb3IoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBtZWFuKGFicyhzdWIodCxlKSksLTEpfSl9ZnVuY3Rpb24gbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj1zdWIoZSx0KSxyPWNsaXBCeVZhbHVlKGFicyhlKSxlcHNpbG9uKCksTnVtYmVyLk1BWF9WQUxVRSksaT1hYnMoZGl2KG4scikpO3JldHVybiBtdWwoMTAwLG1lYW4oaSwtMSkpfSl9ZnVuY3Rpb24gbWVhblNxdWFyZWRMb2dhcml0aG1pY0Vycm9yKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj1jbGlwQnlWYWx1ZSh0LGVwc2lsb24oKSxOdW1iZXIuTUFYX1ZBTFVFKSxyPWxvZyhhZGQoMSxuKSksaT1jbGlwQnlWYWx1ZShlLGVwc2lsb24oKSxOdW1iZXIuTUFYX1ZBTFVFKSxhPWxvZyhhZGQoMSxpKSk7cmV0dXJuIG1lYW4oc3F1YXJlKHN1YihyLGEpKSwtMSl9KX1mdW5jdGlvbiBzcXVhcmVkSGluZ2UoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPW1heGltdW0oMCxzdWIoMSxtdWwoZSx0KSkpO3JldHVybiBtZWFuKHNxdWFyZShuKSwtMSl9KX1mdW5jdGlvbiBoaW5nZShlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49bWF4aW11bSgwLHN1YigxLG11bChlLHQpKSk7cmV0dXJuIG1lYW4obiwtMSl9KX1mdW5jdGlvbiBjYXRlZ29yaWNhbEhpbmdlKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj1zdW0obXVsKGUsdCksLTEpLHI9bWF4KG11bChzdWIoMSxlKSx0KSwtMSk7cmV0dXJuIG1heGltdW0oMCxhZGQoMSxzdWIocixuKSkpfSl9ZnVuY3Rpb24gbG9nY29zaChlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49TWF0aC5sb2coMikscj1zdWIodCxlKSxpPXN1YihhZGQocixzb2Z0cGx1cyhtdWwoLTIscikpKSxuKTtyZXR1cm4gbWVhbihpLC0xKX0pfWZ1bmN0aW9uIGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5KGUsdCxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49ITEpLHRpZHkoZnVuY3Rpb24oKXtpZihuKXQ9c29mdG1heCh0KTtlbHNle3ZhciByPXN1bSh0LHQuc2hhcGUubGVuZ3RoLTEsITApO3Q9ZGl2KHQscil9cmV0dXJuIHQ9Y2xpcEJ5VmFsdWUodCxlcHNpbG9uKCksMS1lcHNpbG9uKCkpLG5lZyhzdW0obXVsKGUudG9GbG9hdCgpLGxvZyh0KSksdC5zaGFwZS5sZW5ndGgtMSkpfSl9ZnVuY3Rpb24gc3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHkoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPWZsb29yKGZsYXR0ZW4oZSkpLnRvSW50KCkscj0odD1jbGlwQnlWYWx1ZSh0LGVwc2lsb24oKSwxLWVwc2lsb24oKSkpLnNoYXBlO3JldHVybiBjYXRlZ29yaWNhbENyb3NzZW50cm9weShvbmVIb3QobixyW3IubGVuZ3RoLTFdKS5yZXNoYXBlKHIpLHQsITEpfSl9ZnVuY3Rpb24gc2lnbW9pZENyb3NzRW50cm9weVdpdGhMb2dpdHMoZSx0KXtpZighdXRpbC5hcnJheXNFcXVhbChlLnNoYXBlLHQuc2hhcGUpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwibG9naXRzIGFuZCBsYWJlbHMgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlLCBidXQgZ290IHNoYXBlcyBcIitKU09OLnN0cmluZ2lmeShlLnNoYXBlKStcIiBhbmQgXCIrSlNPTi5zdHJpbmdpZnkodC5zaGFwZSkpO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49dC5yZWx1KCkscj10LmFicygpLm5lZygpO3JldHVybiBuLnN1Yih0Lm11bChlKSkuYWRkKHIuZXhwKCkubG9nMXAoKSl9KX1mdW5jdGlvbiBiaW5hcnlDcm9zc2VudHJvcHkoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPWNsaXBCeVZhbHVlKHQsZXBzaWxvbigpLDEtZXBzaWxvbigpKSxuPWxvZyhkaXYobixzdWIoMSxuKSkpLG1lYW4oc2lnbW9pZENyb3NzRW50cm9weVdpdGhMb2dpdHMoZSxuKSwtMSl9KX1mdW5jdGlvbiBrdWxsYmFja0xlaWJsZXJEaXZlcmdlbmNlKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj1jbGlwQnlWYWx1ZShlLGVwc2lsb24oKSwxKSxyPWNsaXBCeVZhbHVlKHQsZXBzaWxvbigpLDEpO3JldHVybiBzdW0obXVsKGUsbG9nKGRpdihuLHIpKSksLTEpfSl9ZnVuY3Rpb24gcG9pc3NvbihlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49bG9nKGFkZChlcHNpbG9uKCksdCkpO3JldHVybiBtZWFuKHN1Yih0LG11bChlLG4pKSwtMSl9KX1mdW5jdGlvbiBjb3NpbmVQcm94aW1pdHkoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPWwyTm9ybWFsaXplKGUsLTEpLHI9bDJOb3JtYWxpemUodCwtMSksaT1tdWwobixyKTtyZXR1cm4gbmVnKHN1bShpLC0xKSl9KX1mdW5jdGlvbiBnZXQoZSl7dmFyIHQ9e21lYW5TcXVhcmVkRXJyb3I6bWVhblNxdWFyZWRFcnJvcixtZWFuQWJzb2x1dGVFcnJvcjptZWFuQWJzb2x1dGVFcnJvcixtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3I6bWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yLG1lYW5TcXVhcmVkTG9nYXJpdGhtaWNFcnJvcjptZWFuU3F1YXJlZExvZ2FyaXRobWljRXJyb3Isc3F1YXJlZEhpbmdlOnNxdWFyZWRIaW5nZSxoaW5nZTpoaW5nZSxjYXRlZ29yaWNhbEhpbmdlOmNhdGVnb3JpY2FsSGluZ2UsbG9nY29zaDpsb2djb3NoLGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5OmNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5LHNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5OnNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5LGJpbmFyeUNyb3NzZW50cm9weTpiaW5hcnlDcm9zc2VudHJvcHksa3VsbGJhY2tMZWlibGVyRGl2ZXJnZW5jZTprdWxsYmFja0xlaWJsZXJEaXZlcmdlbmNlLHBvaXNzb246cG9pc3Nvbixjb3NpbmVQcm94aW1pdHk6Y29zaW5lUHJveGltaXR5fTtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7aWYoZSBpbiB0KXJldHVybiB0W2VdO3ZhciBuPVwiVW5rbm93biBsb3NzIFwiK2U7dGhyb3cgZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwic29mdG1heGNyb3NzZW50cm9weVwiKSYmKG49XCJVbmtub3duIGxvc3MgXCIrZSsnLiBVc2UgXCJjYXRlZ29yaWNhbENyb3NzZW50cm9weVwiIGFzIHRoZSBzdHJpbmcgbmFtZSBmb3IgdGYubG9zc2VzLnNvZnRtYXhDcm9zc0VudHJvcHknKSxuZXcgVmFsdWVFcnJvcihuKX1yZXR1cm4gZX1mdW5jdGlvbiBiaW5hcnlBY2N1cmFjeShlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49bXVsKC41LG9uZXNMaWtlKHQpKSxyPWNhc3QkMShncmVhdGVyKHQsbiksZS5kdHlwZSk7cmV0dXJuIG1lYW4oZXF1YWwoZSxyKSwtMSl9KX1mdW5jdGlvbiBjYXRlZ29yaWNhbEFjY3VyYWN5KGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gY2FzdCQxKGVxdWFsKGFyZ01heChlLC0xKSxhcmdNYXgodCwtMSkpLFwiZmxvYXQzMlwiKX0pfWZ1bmN0aW9uIHRydWVQb3NpdGl2ZXMoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBsb2dpY2FsQW5kKGUuZXF1YWwoMSksdC5lcXVhbCgxKSkuc3VtKCkuY2FzdChcImZsb2F0MzJcIil9KX1mdW5jdGlvbiBmYWxzZU5lZ2F0aXZlcyhlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGxvZ2ljYWxBbmQoZS5lcXVhbCgxKSx0LmVxdWFsKDApKS5zdW0oKS5jYXN0KFwiZmxvYXQzMlwiKX0pfWZ1bmN0aW9uIGZhbHNlUG9zaXRpdmVzKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gbG9naWNhbEFuZChlLmVxdWFsKDApLHQuZXF1YWwoMSkpLnN1bSgpLmNhc3QoXCJmbG9hdDMyXCIpfSl9ZnVuY3Rpb24gcHJlY2lzaW9uKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj10cnVlUG9zaXRpdmVzKGUsdCkscj1mYWxzZVBvc2l0aXZlcyhlLHQpLGk9bi5hZGQocik7cmV0dXJuIHdoZXJlKGdyZWF0ZXIoaSwwKSxuLmRpdihpKSwwKS5jYXN0KFwiZmxvYXQzMlwiKX0pfWZ1bmN0aW9uIHJlY2FsbChlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49dHJ1ZVBvc2l0aXZlcyhlLHQpLHI9ZmFsc2VOZWdhdGl2ZXMoZSx0KSxpPW4uYWRkKHIpO3JldHVybiB3aGVyZShncmVhdGVyKGksMCksbi5kaXYoaSksMCkuY2FzdChcImZsb2F0MzJcIil9KX1mdW5jdGlvbiBiaW5hcnlDcm9zc2VudHJvcHkkMShlLHQpe3JldHVybiBiaW5hcnlDcm9zc2VudHJvcHkoZSx0KX1mdW5jdGlvbiBzcGFyc2VDYXRlZ29yaWNhbEFjY3VyYWN5KGUsdCl7cmV0dXJuIGUucmFuaz09PXQucmFuayYmKGU9ZS5zcXVlZXplKFtlLnJhbmstMV0pKSwodD10LmFyZ01heCgtMSkpLmR0eXBlIT09ZS5kdHlwZSYmKHQ9dC5hc1R5cGUoZS5kdHlwZSkpLGVxdWFsKGUsdCkuYXNUeXBlKFwiZmxvYXQzMlwiKX12YXIgbXNlJDE9bWVhblNxdWFyZWRFcnJvcixNU0UkMT1tZWFuU3F1YXJlZEVycm9yLG1hZSQxPW1lYW5BYnNvbHV0ZUVycm9yLE1BRSQxPW1lYW5BYnNvbHV0ZUVycm9yLG1hcGUkMT1tZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3IsTUFQRSQxPW1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcixjYXRlZ29yaWNhbENyb3NzZW50cm9weSQxPWNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5LGNvc2luZSQxPWNvc2luZVByb3hpbWl0eSxzcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weSQxPXNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5O2Z1bmN0aW9uIGdldCQxKGUpe3ZhciB0PXtiaW5hcnlBY2N1cmFjeTpiaW5hcnlBY2N1cmFjeSxjYXRlZ29yaWNhbEFjY3VyYWN5OmNhdGVnb3JpY2FsQWNjdXJhY3kscHJlY2lzaW9uOnByZWNpc2lvbixjYXRlZ29yaWNhbENyb3NzZW50cm9weTpjYXRlZ29yaWNhbENyb3NzZW50cm9weSQxLHNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5OnNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5JDEsbXNlOm1zZSQxLE1TRTpNU0UkMSxtYWU6bWFlJDEsTUFFOk1BRSQxLG1hcGU6bWFwZSQxLE1BUEU6TUFQRSQxLGNvc2luZTpjb3NpbmUkMX07aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUmJmUgaW4gdClyZXR1cm4gdFtlXTtpZihcInN0cmluZ1wiIT10eXBlb2YgZSYmbnVsbCE9ZSlyZXR1cm4gZTt0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlVua25vd24gbWV0cmljIFwiK2UpfWZ1bmN0aW9uIGdldE9wdGltaXplcihlKXt2YXIgdD17QWRhZ3JhZDpmdW5jdGlvbigpe3JldHVybiB0cmFpbi5hZGFncmFkKC4wMSl9LEFkYWRlbHRhOmZ1bmN0aW9uKCl7cmV0dXJuIHRyYWluLmFkYWRlbHRhKDEsLjk1LGVwc2lsb24oKSl9LEFkYW06ZnVuY3Rpb24oKXtyZXR1cm4gdHJhaW4uYWRhbSguMDAxLC45LC45OTksZXBzaWxvbigpKX0sQWRhbWF4OmZ1bmN0aW9uKCl7cmV0dXJuIHRyYWluLmFkYW1heCguMDAyLC45LC45OTksZXBzaWxvbigpLDApfSxSTVNQcm9wOmZ1bmN0aW9uKCl7cmV0dXJuIHRyYWluLnJtc3Byb3AoLjAwMSwuOSwwLGVwc2lsb24oKSl9LFNHRDpmdW5jdGlvbigpe3JldHVybiB0cmFpbi5zZ2QoLjAxKX19O2lmKHQuYWRhZ3JhZD10LkFkYWdyYWQsdC5hZGFkZWx0YT10LkFkYWRlbHRhLHQuYWRhbT10LkFkYW0sdC5hZGFtYXg9dC5BZGFtYXgsdC5ybXNwcm9wPXQuUk1TUHJvcCx0LnNnZD10LlNHRCxlIGluIHQpcmV0dXJuIHRbZV0oKTt0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlVua25vd24gT3B0aW1pemVyIFwiK2UpfWZ1bmN0aW9uIHByaW50U3VtbWFyeShlLHQsbixyKXt2b2lkIDA9PT1yJiYocj1jb25zb2xlLmxvZyk7dmFyIGksYT1pc01vZGVsU2VxdWVudGlhbExpa2UoZSksbz1bXCJMYXllciAodHlwZSlcIixcIk91dHB1dCBzaGFwZVwiLFwiUGFyYW0gI1wiXTtpZihhPyh0PXR8fDY1LG49bnx8Wy40NSwuODUsMV0pOih0PXR8fDk4LG49bnx8Wy4zMywuNTUsLjY3LDFdKSxuW24ubGVuZ3RoLTFdPD0xJiYobj1uLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gTWF0aC5mbG9vcih0KmUpfSkpLCFhKWZvcih2YXIgcyBpbiBvLnB1c2goXCJSZWNlaXZlcyBpbnB1dHNcIiksaT1bXSxlLm5vZGVzQnlEZXB0aClpLnB1c2guYXBwbHkoaSxlLm5vZGVzQnlEZXB0aFtzXSk7cihcIl9cIi5yZXBlYXQodCkpLHByaW50Um93KG8sbixyKSxyKFwiPVwiLnJlcGVhdCh0KSk7Zm9yKHZhciBsPWUubGF5ZXJzLHU9MDt1PGwubGVuZ3RoOysrdSlhP3ByaW50TGF5ZXJTdW1tYXJ5KGxbdV0sbixyKTpwcmludExheWVyU3VtbWFyeVdpdGhDb25uZWN0aW9ucyhsW3VdLG4saSxyKSxyKCh1PT09bC5sZW5ndGgtMT9cIj1cIjpcIl9cIikucmVwZWF0KHQpKTtlLmNoZWNrVHJhaW5hYmxlV2VpZ2h0c0NvbnNpc3RlbmN5KCk7dmFyIGM9Y291bnRUcmFpbmFibGVQYXJhbXMoZSkscD1jb3VudFBhcmFtc0luV2VpZ2h0cyhlLm5vblRyYWluYWJsZVdlaWdodHMpO3IoXCJUb3RhbCBwYXJhbXM6IFwiKyhjK3ApKSxyKFwiVHJhaW5hYmxlIHBhcmFtczogXCIrYykscihcIk5vbi10cmFpbmFibGUgcGFyYW1zOiBcIitwKSxyKFwiX1wiLnJlcGVhdCh0KSl9ZnVuY3Rpb24gY291bnRUcmFpbmFibGVQYXJhbXMoZSl7cmV0dXJuIG51bGwhPWUuY29sbGVjdGVkVHJhaW5hYmxlV2VpZ2h0cz9jb3VudFBhcmFtc0luV2VpZ2h0cyhlLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHMpOmNvdW50UGFyYW1zSW5XZWlnaHRzKGUudHJhaW5hYmxlV2VpZ2h0cyl9ZnVuY3Rpb24gaXNNb2RlbFNlcXVlbnRpYWxMaWtlKGUpe3ZhciB0PSEwLG49W10scj1bXTtmb3IodmFyIGkgaW4gZS5ub2Rlc0J5RGVwdGgpbi5wdXNoKGUubm9kZXNCeURlcHRoW2ldKTtmb3IodmFyIGE9MCxvPW47YTxvLmxlbmd0aDthKyspe3ZhciBzPW9bYV07aWYocy5sZW5ndGg+MXx8MT09PXMubGVuZ3RoJiZzWzBdLmluYm91bmRMYXllcnMubGVuZ3RoPjEpe3Q9ITE7YnJlYWt9ci5wdXNoLmFwcGx5KHIscyl9aWYodClmb3IodmFyIGw9MCx1PWUubGF5ZXJzO2w8dS5sZW5ndGg7bCsrKXtmb3IodmFyIGM9ITEscD0wLGg9dVtsXS5pbmJvdW5kTm9kZXM7cDxoLmxlbmd0aDtwKyspe3ZhciBkPWhbcF07aWYoLTEhPT1yLmluZGV4T2YoZCkpe2lmKGMpe3Q9ITE7YnJlYWt9Yz0hMH19aWYoIXQpYnJlYWt9cmV0dXJuIHR9ZnVuY3Rpb24gcHJpbnRSb3coZSx0LG4pe3ZvaWQgMD09PW4mJihuPWNvbnNvbGUubG9nKTtmb3IodmFyIHI9XCJcIixpPTA7aTxlLmxlbmd0aDsrK2kpaT4wJiYocj1yLnNsaWNlKDAsci5sZW5ndGgtMSkrXCIgXCIpLHI9KHIrPWVbaV0pLnNsaWNlKDAsdFtpXSkscis9XCIgXCIucmVwZWF0KHRbaV0tci5sZW5ndGgpO24ocil9ZnVuY3Rpb24gcHJpbnRMYXllclN1bW1hcnkoZSx0LG4pe3ZhciByO3RyeXtyPUpTT04uc3RyaW5naWZ5KGUub3V0cHV0U2hhcGUpfWNhdGNoKGUpe3I9XCJtdWx0aXBsZVwifXByaW50Um93KFtlLm5hbWUrXCIgKFwiK2UuZ2V0Q2xhc3NOYW1lKCkrXCIpXCIscixlLmNvdW50UGFyYW1zKCkudG9TdHJpbmcoKV0sdCxuKX1mdW5jdGlvbiBwcmludExheWVyU3VtbWFyeVdpdGhDb25uZWN0aW9ucyhlLHQsbixyKXt2YXIgaTt0cnl7aT1KU09OLnN0cmluZ2lmeShlLm91dHB1dFNoYXBlKX1jYXRjaChlKXtpPVwibXVsdGlwbGVcIn1mb3IodmFyIGE9W10sbz0wLHM9ZS5pbmJvdW5kTm9kZXM7bzxzLmxlbmd0aDtvKyspe3ZhciBsPXNbb107aWYoIShudWxsIT1uJiZuLmxlbmd0aD4wJiYtMT09PW4uaW5kZXhPZihsKSkpZm9yKHZhciB1PTA7dTxsLmluYm91bmRMYXllcnMubGVuZ3RoOysrdSl7dmFyIGM9bC5pbmJvdW5kTGF5ZXJzW3VdLm5hbWUscD1sLm5vZGVJbmRpY2VzW3VdLGg9bC50ZW5zb3JJbmRpY2VzW3VdO2EucHVzaChjK1wiW1wiK3ArXCJdW1wiK2grXCJdXCIpfX12YXIgZD1lLm5hbWUsZj1lLmdldENsYXNzTmFtZSgpLGc9MD09PWEubGVuZ3RoP1wiXCI6YVswXTtwcmludFJvdyhbZCtcIiAoXCIrZitcIilcIixpLGUuY291bnRQYXJhbXMoKS50b1N0cmluZygpLGddLHQscik7Zm9yKHU9MTt1PGEubGVuZ3RoOysrdSlwcmludFJvdyhbXCJcIixcIlwiLFwiXCIsYVt1XV0sdCxyKX12YXIgdmVyc2lvbj1cIjEuMS4yXCI7ZnVuY3Rpb24gZGVzZXJpYWxpemUoZSx0LG4pe3JldHVybiB2b2lkIDA9PT10JiYodD17fSksdm9pZCAwPT09biYmKG49ITEpLGRlc2VyaWFsaXplS2VyYXNPYmplY3QoZSxzZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAuZ2V0TWFwKCkuY2xhc3NOYW1lTWFwLHQsXCJsYXllclwiLG4pfWZ1bmN0aW9uIGlzQXJyYXlJdGVtSW5wdXRPck91dHB1dE5hbWUoZSx0LG4pe3JldHVybihcImluYm91bmROb2Rlc1wiPT09ZXx8XCJvdXRwdXRMYXllcnNcIj09PWV8fFwiaW5wdXRMYXllcnNcIj09PWUpJiYwPT09dCYmXCJzdHJpbmdcIj09dHlwZW9mIG59ZnVuY3Rpb24gY29udmVydFB5dGhvbmljVG9UcyhlLHQpe2lmKG51bGw9PT1lKXJldHVybiBudWxsO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiB0b0NhbWVsQ2FzZShlKTtpZihcIm51bWJlclwiPT10eXBlb2YgZXx8XCJib29sZWFuXCI9PXR5cGVvZiBlKXJldHVybiBlO2lmKGUgaW5zdGFuY2VvZiBBcnJheSl7Zm9yKHZhciBuPVtdLHI9ZS5sZW5ndGgsaT0wO2k8cjsrK2kpe3ZhciBhPWVbaV07aXNBcnJheUl0ZW1JbnB1dE9yT3V0cHV0TmFtZSh0LGksYSk/bi5wdXNoKGEpOm4ucHVzaChjb252ZXJ0UHl0aG9uaWNUb1RzKGEsdCkpfXJldHVybiBufWZvcih2YXIgbz17fSxzPTAsbD1PYmplY3Qua2V5cyhlKTtzPGwubGVuZ3RoO3MrKyl7dmFyIHU9bFtzXSxjPWVbdV07aWYoXCJuYW1lXCI9PT11JiZcInN0cmluZ1wiPT10eXBlb2YgYylvW3VdPWM7ZWxzZXt2YXIgcD10b0NhbWVsQ2FzZSh1KTtvW3BdPWNvbnZlcnRQeXRob25pY1RvVHMoYyxwKX19cmV0dXJuIG99ZnVuY3Rpb24gY29udmVydFRzVG9QeXRob25pYyhlLHQpe2lmKG51bGw9PT1lfHx2b2lkIDA9PT1lKXJldHVybiBudWxsO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiB0b1NuYWtlQ2FzZShlKTtpZihcIm51bWJlclwiPT10eXBlb2YgZXx8XCJib29sZWFuXCI9PXR5cGVvZiBlKXJldHVybiBlO2lmKGUgaW5zdGFuY2VvZiBBcnJheSl7Zm9yKHZhciBuPVtdLHI9ZS5sZW5ndGgsaT0wO2k8cjsrK2kpe3ZhciBhPWVbaV07aXNBcnJheUl0ZW1JbnB1dE9yT3V0cHV0TmFtZSh0LGksYSk/bi5wdXNoKGEpOm4ucHVzaChjb252ZXJ0VHNUb1B5dGhvbmljKGEsdCkpfXJldHVybiBufWZvcih2YXIgbz17fSxzPTAsbD1PYmplY3Qua2V5cyhlKTtzPGwubGVuZ3RoO3MrKyl7dmFyIHU9bFtzXSxjPWVbdV0scD10b1NuYWtlQ2FzZSh1KTtvW3BdPVwibmFtZVwiIT09dSYmXCJjbGFzc05hbWVcIiE9PXV8fFwic3RyaW5nXCIhPXR5cGVvZiBjP2NvbnZlcnRUc1RvUHl0aG9uaWMoYyx1KTpjfXJldHVybiBvfWZ1bmN0aW9uIGFzc2VydEZlZWRDb21wYXRpYmlsaXR5KGUsdCl7aWYobnVsbD09ZS5kdHlwZXx8ZS5kdHlwZT09PXQuZHR5cGUpcmV0dXJuIHQ7dHJ5e3JldHVybiBjYXN0KHQsZS5kdHlwZSl9Y2F0Y2gobil7dGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgZHR5cGUgb2YgdGhlIGZlZWQgKFwiK3QuZHR5cGUrXCIpIGNhbiBub3QgYmUgY2FzdCB0byB0aGUgZHR5cGUgb2YgdGhlIGtleSAnXCIrZS5uYW1lK1wiJyAoXCIrZS5kdHlwZStcIikuXCIpfX12YXIgRmVlZERpY3Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpe2lmKHRoaXMuaWQyVmFsdWU9e30sdGhpcy5pZDJNYXNrPXt9LHRoaXMubmFtZTJJZD17fSx0IGluc3RhbmNlb2YgZSlmb3IodmFyIG4gaW4gdC5pZDJWYWx1ZSl0aGlzLmlkMlZhbHVlW25dPXQuaWQyVmFsdWVbbl0sbiBpbiB0LmlkMk1hc2smJih0aGlzLmlkMk1hc2tbbl09dC5pZDJNYXNrW25dKTtlbHNle2lmKG51bGw9PXQpcmV0dXJuO2Zvcih2YXIgcj0wLGk9dDtyPGkubGVuZ3RoO3IrKyl7dmFyIGE9aVtyXTt0aGlzLmFkZChhLmtleSxhLnZhbHVlKX19fXJldHVybiBlLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oZSx0LG4pe2lmKG51bGwhPXRoaXMuaWQyVmFsdWVbZS5pZF0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJEdXBsaWNhdGUga2V5OiBuYW1lPVwiK2UubmFtZStcIiwgaWQ9XCIrZS5pZCk7cmV0dXJuIHRoaXMuaWQyVmFsdWVbZS5pZF09YXNzZXJ0RmVlZENvbXBhdGliaWxpdHkoZSx0KSx0aGlzLm5hbWUySWRbZS5uYW1lXT1lLmlkLG51bGwhPW4mJih0aGlzLmlkMk1hc2tbZS5pZF09biksdGhpc30sZS5wcm90b3R5cGUuYWRkRmVlZD1mdW5jdGlvbihlKXt0aGlzLmFkZChlLmtleSxlLnZhbHVlKX0sZS5wcm90b3R5cGUuaGFzS2V5PWZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT10aGlzLmlkMlZhbHVlW2UuaWRdfSxlLnByb3RvdHlwZS5uYW1lcz1mdW5jdGlvbigpe3JldHVybiBPYmplY3Qua2V5cyh0aGlzLm5hbWUySWQpfSxlLnByb3RvdHlwZS5nZXRWYWx1ZT1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgU3ltYm9saWNUZW5zb3Ipe2lmKG51bGw9PXRoaXMuaWQyVmFsdWVbZS5pZF0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJOb25leGlzdGVudCBrZXk6IFwiK2UubmFtZSk7cmV0dXJuIHRoaXMuaWQyVmFsdWVbZS5pZF19dmFyIHQ9dGhpcy5uYW1lMklkW2VdO2lmKG51bGw9PXQpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJGZWVkIGRpY3QgaGFzIG5vIFN5bWJvbGljVGVuc29yIG5hbWU6IFwiK2UpO3JldHVybiB0aGlzLmlkMlZhbHVlW3RdfSxlLnByb3RvdHlwZS5nZXRNYXNrPWZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBTeW1ib2xpY1RlbnNvcil7aWYobnVsbD09dGhpcy5pZDJWYWx1ZVtlLmlkXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIk5vbmV4aXN0ZW50IGtleTogXCIrZS5uYW1lKTtyZXR1cm4gdGhpcy5pZDJNYXNrW2UuaWRdfXZhciB0PXRoaXMubmFtZTJJZFtlXTtpZihudWxsPT10KXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRmVlZCBkaWN0IGhhcyBubyBTeW1ib2xpY1RlbnNvciBuYW1lOiBcIitlKTtyZXR1cm4gdGhpcy5pZDJNYXNrW3RdfSxlLnByb3RvdHlwZS5kaXNwb3NlTWFza3M9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmlkMk1hc2smJmRpc3Bvc2UodGhpcy5pZDJNYXNrKX0sZX0oKSxjYWNoZWRTb3J0ZWQ9e30sY2FjaGVkUmVjaXBpZW50Q291bnRzPXt9O2Z1bmN0aW9uIGV4ZWN1dGUoZSx0LG4scil7Zm9yKHZhciBpPW51bGwhPW4mJm4udHJhaW5pbmcsYT1BcnJheS5pc0FycmF5KGUpLG89YT9lOltlXSxzPW8ubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLm5hbWV9KSxsPVtdLHU9dC5uYW1lcygpLGM9MCxwPXM7YzxwLmxlbmd0aDtjKyspe3ZhciBoPXBbY107LTEhPT11LmluZGV4T2YoaCk/bC5wdXNoKHQuZ2V0VmFsdWUoaCkpOmwucHVzaChudWxsKX1udWxsIT1yJiYoci5tYXhOdW1UZW5zb3JzPS0xLzAsci5taW5OdW1UZW5zb3JzPTEvMCk7dmFyIGQsZixnPXMuam9pbihcIixcIikrXCJ8XCIrdC5uYW1lcygpLmpvaW4oXCIsXCIpO2lmKG51bGw9PWNhY2hlZFNvcnRlZFtnXSl7dmFyIG09Z2V0VG9wb2xvZ2ljYWxTb3J0QW5kUmVjaXBpZW50Q291bnRzKG8sdCk7ZD1tLnNvcnRlZCxmPW0ucmVjaXBpZW50Q291bnRzLGNhY2hlZFNvcnRlZFtnXT1kLGNhY2hlZFJlY2lwaWVudENvdW50c1tnXT1mfWQ9Y2FjaGVkU29ydGVkW2ddLGY9e30saXx8T2JqZWN0LmFzc2lnbihmLGNhY2hlZFJlY2lwaWVudENvdW50c1tnXSk7Zm9yKHZhciB5PW5ldyBGZWVkRGljdCh0KSx2PTA7djxkLmxlbmd0aDsrK3Ype2lmKG51bGwhPXIpe3ZhciBiPW1lbW9yeSgpLm51bVRlbnNvcnM7Yj5yLm1heE51bVRlbnNvcnMmJihyLm1heE51bVRlbnNvcnM9YiksYjxyLm1pbk51bVRlbnNvcnMmJihyLm1pbk51bVRlbnNvcnM9Yil9dmFyIHc9ZFt2XSx6PXcuc291cmNlTGF5ZXI7aWYoISh6IGluc3RhbmNlb2YgSW5wdXRMYXllcikpe2Zvcih2YXIgUz1bXSxJPVtdLEE9W10sXz0hMSxDPTAsTj13LmlucHV0cztDPE4ubGVuZ3RoO0MrKyl7dmFyIEU9TltDXSxrPXkuZ2V0VmFsdWUoRSksTD15LmdldE1hc2soRSk7Uy5wdXNoKGspLEkucHVzaChMKSxudWxsIT1MJiYoXz0hMCksaXx8KGZbRS5uYW1lXS0tLDAhPT1mW0UubmFtZV18fHQuaGFzS2V5KEUpfHwtMSE9PXMuaW5kZXhPZihFLm5hbWUpfHxrLmlzRGlzcG9zZWR8fCEwPT09RS5zb3VyY2VMYXllci5zdGF0ZWZ1bHx8QS5wdXNoKGspKX1fJiYoKG49bnx8e30pLm1hc2s9SVswXSk7dmFyIHg9dG9MaXN0KHouYXBwbHkoUyxuKSksVD1udWxsO3ouc3VwcG9ydHNNYXNraW5nJiYoVD16LmNvbXB1dGVNYXNrKFMsSSkpO2Zvcih2YXIgRD1nZXROb2RlT3V0cHV0cyh3KSxPPUFycmF5LmlzQXJyYXkoRCk/RDpbRF0sUj0wO1I8Ty5sZW5ndGg7KytSKXt5Lmhhc0tleShPW1JdKXx8eS5hZGQoT1tSXSx4W1JdLEFycmF5LmlzQXJyYXkoVCk/VFswXTpUKTt2YXIgTT1zLmluZGV4T2YoT1tSXS5uYW1lKTstMSE9PU0mJihsW01dPXhbUl0pfWl8fGRpc3Bvc2UoQSl9fXJldHVybiB5LmRpc3Bvc2VNYXNrcygpLGE/bDpsWzBdfWZ1bmN0aW9uIGdldFRvcG9sb2dpY2FsU29ydEFuZFJlY2lwaWVudENvdW50cyhlLHQpe3V0aWwuYXNzZXJ0KG51bGwhPWUmJmUubGVuZ3RoPjAsZnVuY3Rpb24oKXtyZXR1cm5cIkV4cGVjdGVkIGF0IGxlYXN0IG9uZSBmZXRjaCwgZ290IG5vbmVcIn0pO3ZhciBuPVtdLHI9e307aWYoMT09PWUubGVuZ3RoKXt2YXIgaT1nZXRUb3BvbG9naWNhbFNvcnRBbmRSZWNpcGllbnRDb3VudHNGb3JPbmVGZXRjaChlWzBdLHQpO249aS5zb3J0ZWQscj1pLnJlY2lwaWVudE1hcH1lbHNlIGZvcih2YXIgYT1uZXcgU2V0LG89MCxzPWU7bzxzLmxlbmd0aDtvKyspe2Zvcih2YXIgbD1nZXRUb3BvbG9naWNhbFNvcnRBbmRSZWNpcGllbnRDb3VudHNGb3JPbmVGZXRjaChzW29dLHQpLHU9bC5zb3J0ZWQsYz1sLnJlY2lwaWVudE1hcCxwPTAsaD11O3A8aC5sZW5ndGg7cCsrKXt2YXIgZD1oW3BdO2EuaGFzKGQubmFtZSl8fChuLnB1c2goZCksYS5hZGQoZC5uYW1lKSl9dmFyIGY9ZnVuY3Rpb24oZSl7bnVsbD09cltlXSYmKHJbZV09bmV3IFNldCksY1tlXS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiByW2VdLmFkZCh0KX0pfTtmb3IodmFyIGcgaW4gYylmKGcpfXJldHVybntzb3J0ZWQ6bixyZWNpcGllbnRDb3VudHM6cmVjaXBpZW50TWFwMkNvdW50cyhyKX19ZnVuY3Rpb24gcmVjaXBpZW50TWFwMkNvdW50cyhlKXt2YXIgdD17fTtmb3IodmFyIG4gaW4gZSl0W25dPWVbbl0uc2l6ZTtyZXR1cm4gdH1mdW5jdGlvbiBnZXRUb3BvbG9naWNhbFNvcnRBbmRSZWNpcGllbnRDb3VudHNGb3JPbmVGZXRjaChlLHQpe2Zvcih2YXIgbj1uZXcgU2V0LHI9W10saT17fSxhPTAsbz10Lm5hbWVzKCk7YTxvLmxlbmd0aDthKyspe3ZhciBzPW9bYV07bi5hZGQocyl9dmFyIGw9W10sdT1bXTtmb3IobC5wdXNoKGUpO2wubGVuZ3RoPjA7KXt2YXIgYz1sW2wubGVuZ3RoLTFdO2lmKG4uaGFzKGMubmFtZSkpbC5wb3AoKTtlbHNle3ZhciBwPXVbdS5sZW5ndGgtMV09PT1sLmxlbmd0aC0xO2lmKDA9PT1jLmlucHV0cy5sZW5ndGh8fHApbC5wb3AoKSxyLnB1c2goYyksbi5hZGQoYy5uYW1lKSxwJiZ1LnBvcCgpO2Vsc2V7dS5wdXNoKGwubGVuZ3RoLTEpO2Zvcih2YXIgaD0wLGQ9Yy5pbnB1dHM7aDxkLmxlbmd0aDtoKyspe3ZhciBmPWRbaF07bnVsbD09aVtmLm5hbWVdJiYoaVtmLm5hbWVdPW5ldyBTZXQpLGlbZi5uYW1lXS5hZGQoYy5uYW1lKSxuLmhhcyhmLm5hbWUpfHxsLnB1c2goZil9fX19cmV0dXJue3NvcnRlZDpyLHJlY2lwaWVudE1hcDppfX1mdW5jdGlvbiBnZXROb2RlT3V0cHV0cyhlKXt2YXIgdDtpZigxPT09ZS5zb3VyY2VMYXllci5pbmJvdW5kTm9kZXMubGVuZ3RoKXQ9ZS5zb3VyY2VMYXllci5vdXRwdXQ7ZWxzZXtmb3IodmFyIG49bnVsbCxyPTA7cjxlLnNvdXJjZUxheWVyLmluYm91bmROb2Rlcy5sZW5ndGg7KytyKWZvcih2YXIgaT0wLGE9ZS5zb3VyY2VMYXllci5pbmJvdW5kTm9kZXNbcl0ub3V0cHV0VGVuc29ycztpPGEubGVuZ3RoO2krKyl7aWYoYVtpXS5pZD09PWUuaWQpe249cjticmVha319dD1lLnNvdXJjZUxheWVyLmdldE91dHB1dEF0KG4pfXJldHVybiB0fXZhciBDb250YWluZXI9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuKXt2YXIgcj1lLmNhbGwodGhpcyx7fSl8fHRoaXM7aWYoci5jb250YWluZXJOb2Rlcz1uZXcgU2V0LHIubmFtZT1uLm5hbWUsbnVsbD09ci5uYW1lKXt2YXIgaT1yLmdldENsYXNzTmFtZSgpLnRvTG93ZXJDYXNlKCk7ci5uYW1lPWdldFVpZChpKX1pZihyLnN1cHBvcnRzTWFza2luZz0hMSxyLnRyYWluYWJsZV89ITAsci51cGRhdGFibGU9ITAsQXJyYXkuaXNBcnJheShuLmlucHV0cyk/ci5pbnB1dHM9bi5pbnB1dHMuc2xpY2UoKTpyLmlucHV0cz1bbi5pbnB1dHNdLEFycmF5LmlzQXJyYXkobi5vdXRwdXRzKT9yLm91dHB1dHM9bi5vdXRwdXRzLnNsaWNlKCk6ci5vdXRwdXRzPVtuLm91dHB1dHNdLHVuaXF1ZShyLmlucHV0cykubGVuZ3RoIT09ci5pbnB1dHMubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGxpc3Qgb2YgaW5wdXRzIHBhc3NlZCB0byB0aGUgbW9kZWwgaXMgcmVkdW5kYW50LiBBbGwgaW5wdXRzIHNob3VsZCBvbmx5IGFwcGVhciBvbmNlLiBGb3VuZDogXCIrci5pbnB1dHMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLm5hbWV9KSk7dW5pcXVlKHIub3V0cHV0cykubGVuZ3RoIT09ci5vdXRwdXRzLmxlbmd0aCYmY29uc29sZS53YXJuKFwiVGhlIGxpc3Qgb2Ygb3V0cHV0cyBwYXNzZWQgdG8gdGhlIG1vZGVsIGlzIHJlZHVuZGFudC4gQWxsIG91dHB1dHMgc2hvdWxkIG9ubHkgYXBwZWFyIG9uY2UuIEZvdW5kOiBcIityLm91dHB1dHMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLm5hbWV9KSksci5pbnB1dExheWVycz1bXSxyLmlucHV0TGF5ZXJzTm9kZUluZGljZXM9W10sci5pbnB1dExheWVyc1RlbnNvckluZGljZXM9W10sci5vdXRwdXRMYXllcnM9W10sci5vdXRwdXRMYXllcnNOb2RlSW5kaWNlcz1bXSxyLm91dHB1dExheWVyc1RlbnNvckluZGljZXM9W10sci5sYXllcnM9W107Zm9yKHZhciBhPTAsbz1yLm91dHB1dHM7YTxvLmxlbmd0aDthKyspe3ZhciBzPShDPW9bYV0pLnNvdXJjZUxheWVyLGw9Qy5ub2RlSW5kZXgsdT1DLnRlbnNvckluZGV4O3Iub3V0cHV0TGF5ZXJzLnB1c2gocyksci5vdXRwdXRMYXllcnNOb2RlSW5kaWNlcy5wdXNoKGwpLHIub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlcy5wdXNoKHUpfWZvcih2YXIgYz0wLHA9ci5pbnB1dHM7YzxwLmxlbmd0aDtjKyspe3M9KEM9cFtjXSkuc291cmNlTGF5ZXIsbD1DLm5vZGVJbmRleCx1PUMudGVuc29ySW5kZXg7YXNzZXJ0KDA9PT1sLFwiaW5wdXQgbGF5ZXIgaGFzID4xIG5vZGVzXCIpLGFzc2VydCgwPT09dSxcImlucHV0IGxheWVyIGhhcyA+MSB0ZW5zb3JzXCIpLHIuaW5wdXRMYXllcnMucHVzaChzKSxyLmlucHV0TGF5ZXJzTm9kZUluZGljZXMucHVzaChsKSxyLmlucHV0TGF5ZXJzVGVuc29ySW5kaWNlcy5wdXNoKHUpfXIuaW5wdXROYW1lcz1bXSxyLm91dHB1dE5hbWVzPVtdLHIuZmVlZElucHV0U2hhcGVzPVtdLHIuZmVlZElucHV0TmFtZXM9W10sci5mZWVkT3V0cHV0TmFtZXM9W107Zm9yKHZhciBoPTA7aDxyLmlucHV0TGF5ZXJzLmxlbmd0aDtoKyspe2lmKCEoKHM9ci5pbnB1dExheWVyc1toXSlpbnN0YW5jZW9mIElucHV0TGF5ZXIpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnB1dCBsYXllcnMgdG8gYSBMYXllcnNNb2RlbCBtdXN0IGJlIElucHV0TGF5ZXIgb2JqZWN0cy4gUmVjZWl2ZWQgaW5wdXRzOiBcIituLmlucHV0cytcIi4gSW5wdXQgXCIraCtcIiAoMC1iYXNlZCkgb3JpZ2luYXRlcyBmcm9tIGxheWVyIHR5cGUgXCIrcy5nZXRDbGFzc05hbWUoKStcIi5cIik7ci5pbnB1dE5hbWVzLnB1c2gocy5uYW1lKSxyLmZlZWRJbnB1dFNoYXBlcy5wdXNoKHMuYmF0Y2hJbnB1dFNoYXBlKSxyLmZlZWRJbnB1dE5hbWVzLnB1c2gocy5uYW1lKX1mb3IodmFyIGQ9MCxmPXIub3V0cHV0TGF5ZXJzO2Q8Zi5sZW5ndGg7ZCsrKXtzPWZbZF07ci5vdXRwdXROYW1lcy5wdXNoKHMubmFtZSl9ci5pbnRlcm5hbElucHV0U2hhcGVzPXIuaW5wdXRzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5zaGFwZX0pLHIuaW50ZXJuYWxPdXRwdXRTaGFwZXM9ci5vdXRwdXRzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5zaGFwZX0pO2Zvcih2YXIgZz17fSxtPXt9LHk9e30sdj17fSxiPXt9LHc9W10sej1mdW5jdGlvbihlLG4saSxhLG8scyl7bnVsbCE9YSYmbnVsbCE9byYmbnVsbCE9c3x8KGE9ZS5zb3VyY2VMYXllcixvPWUubm9kZUluZGV4LHM9ZS50ZW5zb3JJbmRleCk7dmFyIGw9YS5pbmJvdW5kTm9kZXNbb107aWYoLTEhPT1pLmluZGV4T2YobCkpdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcIlRoZSB0ZW5zb3IgXCIrZS5uYW1lKycgYXQgbGF5ZXIgXCInK2EubmFtZSsnXCIgaXMgcGFydCBvZiBhIGN5Y2xlLicpO2lmKC0xPT09bi5pbmRleE9mKGwpKXtyLmNvbnRhaW5lck5vZGVzLmFkZCh0Lm5vZGVLZXkoYSxvKSksYS5pZCBpbiBifHwoYlthLmlkXT1PYmplY3Qua2V5cyhiKS5sZW5ndGgpLC0xPT09aS5pbmRleE9mKGwpJiZpLnB1c2gobCk7Zm9yKHZhciB1PWwuaW5ib3VuZExheWVycy5sZW5ndGgsYz0wO2M8dTtjKyspe3ZhciBwPWwuaW5wdXRUZW5zb3JzW2NdLGg9bC5pbmJvdW5kTGF5ZXJzW2NdLGQ9bC5ub2RlSW5kaWNlc1tjXSxmPWwudGVuc29ySW5kaWNlc1tjXTt6KHAsbixpLGgsZCxmKX1mb3Iobi5wdXNoKGwpO2kuaW5kZXhPZihsKT49MDspaS5zcGxpY2UoaS5pbmRleE9mKGwpLDEpO3cucHVzaChsKX19LFM9W10sST1bXSxBPTAsXz1yLm91dHB1dHM7QTxfLmxlbmd0aDtBKyspe3ZhciBDPV9bQV07eihDLFMsSSl9Zm9yKHZhciBOPTAsRT13LnNsaWNlKCkucmV2ZXJzZSgpO048RS5sZW5ndGg7TisrKXttWyhLPUVbTl0pLmlkXT1LLEsuaWQgaW4gZ3x8KGdbSy5pZF09MCk7dmFyIGs9Z1tLLmlkXSxMPW51bGw9PXlbSy5vdXRib3VuZExheWVyLmlkXT8wOnlbSy5vdXRib3VuZExheWVyLmlkXTtrPU1hdGgubWF4KGssTCkseVtLLm91dGJvdW5kTGF5ZXIuaWRdPWssdltLLm91dGJvdW5kTGF5ZXIuaWRdPUsub3V0Ym91bmRMYXllcixnW0suaWRdPWs7Zm9yKGg9MDtoPEsuaW5ib3VuZExheWVycy5sZW5ndGg7aCsrKXt2YXIgeD1LLmluYm91bmRMYXllcnNbaF0sVD0obD1LLm5vZGVJbmRpY2VzW2hdLHguaW5ib3VuZE5vZGVzW2xdKSxEPW51bGw9PWdbVC5pZF0/MDpnW1QuaWRdO2dbVC5pZF09TWF0aC5tYXgoaysxLEQpLG1bVC5pZF09VH19dmFyIE89e307Zm9yKHZhciBSIGluIGcpeyhrPWdbUl0paW4gT3x8KE9ba109W10pLE9ba10ucHVzaChtW1JdKX12YXIgTT17fTtmb3IodmFyIFAgaW4geSl7KGs9eVtQXSlpbiBNfHwoTVtrXT1bXSksTVtrXS5wdXNoKHZbUF0pfXZhciBGPU9iamVjdC5rZXlzKE0pLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gcGFyc2VJbnQoZSwxMCl9KS5zb3J0KHJldmVyc2VOdW1iZXJDb21wYXJlKTtyLmxheWVycz1bXTtmb3IodmFyIFY9MCxCPUY7VjxCLmxlbmd0aDtWKyspe3ZhciBVPU1baz1CW1ZdXTtVLnNvcnQoZnVuY3Rpb24oZSx0KXt2YXIgbj1iW2UuaWRdLHI9Ylt0LmlkXTtyZXR1cm4gbjxyPy0xOm4+cj8xOjB9KTtmb3IodmFyIGo9MCxXPVU7ajxXLmxlbmd0aDtqKyspe3M9V1tqXTtyLmxheWVycy5wdXNoKHMpfX1yLmxheWVyc0J5RGVwdGg9TSxGPU9iamVjdC5rZXlzKE8pLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gcGFyc2VJbnQoZSwxMCl9KS5zb3J0KHJldmVyc2VOdW1iZXJDb21wYXJlKTtmb3IodmFyICQ9ci5pbnB1dHMuc2xpY2UoKSxxPVtdLEc9MCxIPUY7RzxILmxlbmd0aDtHKyspZm9yKHZhciBKPTAsWj1PW2s9SFtHXV07SjxaLmxlbmd0aDtKKyspe3ZhciBLO2lmKG51bGwhPShzPShLPVpbSl0pLm91dGJvdW5kTGF5ZXIpKXtmb3IodmFyIFk9MCxYPUsuaW5wdXRUZW5zb3JzO1k8WC5sZW5ndGg7WSsrKXtDPVhbWV07aWYoLTE9PT0kLmluZGV4T2YoQykpdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcIkdyYXBoIGRpc2Nvbm5lY3RlZDogY2Fubm90IG9idGFpbiB2YWx1ZSBmb3IgdGVuc29yIFwiK0MrJyBhdCBsYXllciBcIicrcy5uYW1lKydcIi4gVGhlIGZvbGxvd2luZyBwcmV2aW91cyBsYXllcnMgd2VyZSBhY2Nlc3NlZCB3aXRob3V0IGlzc3VlOiAnK3EpfWZvcih2YXIgUT0wLGVlPUsub3V0cHV0VGVuc29ycztRPGVlLmxlbmd0aDtRKyspe0M9ZWVbUV07JC5wdXNoKEMpfXEucHVzaChzLm5hbWUpfX1yLm5vZGVzQnlEZXB0aD1PO2Zvcih2YXIgdGU9ci5sYXllcnMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLm5hbWV9KSxuZT1mdW5jdGlvbihlKXt2YXIgdD10ZS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT1lfSkubGVuZ3RoO2lmKDEhPT10KXRocm93IG5ldyBSdW50aW1lRXJyb3IoJ1RoZSBuYW1lIFwiJytlKydcIiBpcyB1c2VkICcrdCtcIiB0aW1lcyBpbiB0aGUgbW9kZWwuIEFsbCBsYXllciBuYW1lcyBzaG91bGQgYmUgdW5pcXVlLiBMYXllciBuYW1lczogXCIrSlNPTi5zdHJpbmdpZnkodGUpKX0scmU9MCxpZT10ZTtyZTxpZS5sZW5ndGg7cmUrKyl7bmUoaWVbcmVdKX1yZXR1cm4gci5vdXRib3VuZE5vZGVzPVtdLHIuaW5ib3VuZE5vZGVzPVtdLG5ldyBOb2RlKHtvdXRib3VuZExheWVyOnIsaW5ib3VuZExheWVyczpbXSxub2RlSW5kaWNlczpbXSx0ZW5zb3JJbmRpY2VzOltdLGlucHV0VGVuc29yczpyLmlucHV0cyxvdXRwdXRUZW5zb3JzOnIub3V0cHV0cyxpbnB1dE1hc2tzOnIuaW5wdXRzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gbnVsbH0pLG91dHB1dE1hc2tzOnIub3V0cHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG51bGx9KSxpbnB1dFNoYXBlczpyLmlucHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hhcGV9KSxvdXRwdXRTaGFwZXM6ci5vdXRwdXRzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5zaGFwZX0pfSksci5idWlsdD0hMCxyLl9yZWZDb3VudD0xLHJ9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFzc2VydE5vdERpc3Bvc2VkPWZ1bmN0aW9uKCl7aWYoMD09PXRoaXMuX3JlZkNvdW50KXRocm93IG5ldyBFcnJvcihcIkNvbnRhaW5lciAnXCIrdGhpcy5uYW1lK1wiJyBpcyBhbHJlYWR5IGRpc3Bvc2VkLlwiKX0sdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMuYXNzZXJ0Tm90RGlzcG9zZWQoKTt2YXIgZT17cmVmQ291bnRBZnRlckRpc3Bvc2U6bnVsbCxudW1EaXNwb3NlZFZhcmlhYmxlczowfTtpZigwPT0tLXRoaXMuX3JlZkNvdW50KWZvcih2YXIgdD0wLG49dGhpcy5sYXllcnM7dDxuLmxlbmd0aDt0Kyspe3ZhciByPW5bdF07ZS5udW1EaXNwb3NlZFZhcmlhYmxlcys9ci5kaXNwb3NlKCkubnVtRGlzcG9zZWRWYXJpYWJsZXN9cmV0dXJuIGUucmVmQ291bnRBZnRlckRpc3Bvc2U9dGhpcy5fcmVmQ291bnQsZX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidHJhaW5hYmxlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYWluYWJsZV99LHNldDpmdW5jdGlvbihlKXt0aGlzLmxheWVycy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QuX3RyYWluYWJsZVdlaWdodHMuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gdC50cmFpbmFibGU9ZX0pfSksdGhpcy50cmFpbmFibGVfPWV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidHJhaW5hYmxlV2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtpZih0aGlzLl90cmFpbmFibGVXZWlnaHRzLmxlbmd0aD4wKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ29udGFpbmVyIGluc3RhbmNlIHVuZXhwZWN0ZWRseSBjb250YWlucyBfdHJhaW5hYmxlV2VpZ2h0cy5UaGUgdHJhaW5hYmxlIHdlaWdodHMgb2YgYSBDb250YWluZXIgYXJlIGEgdW5pb24gb2YgdGhlIHRyYWluYWJsZSB3ZWlnaHRzIG9mIGl0cyBjb25zaXR1ZW50IExheWVycy4gSXRzIG93biBfdHJhaW5hYmxlV2VpZ2h0cyBtdXN0IHJlbWFpbiBhbiBlbXB0eSBBcnJheS5cIik7aWYoIXRoaXMudHJhaW5hYmxlKXJldHVybltdO2Zvcih2YXIgZT1bXSx0PTAsbj10aGlzLmxheWVyczt0PG4ubGVuZ3RoO3QrKyl7dmFyIHI9blt0XTtlPWUuY29uY2F0KHIudHJhaW5hYmxlV2VpZ2h0cyl9cmV0dXJuIGV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwibm9uVHJhaW5hYmxlV2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wLG49dGhpcy5sYXllcnM7dDxuLmxlbmd0aDt0Kyspe3ZhciByPW5bdF07ZS5wdXNoLmFwcGx5KGUsci5ub25UcmFpbmFibGVXZWlnaHRzKX1pZighdGhpcy50cmFpbmFibGUpe2Zvcih2YXIgaT1bXSxhPTAsbz10aGlzLmxheWVyczthPG8ubGVuZ3RoO2ErKyl7cj1vW2FdO2kucHVzaC5hcHBseShpLHIudHJhaW5hYmxlV2VpZ2h0cyl9cmV0dXJuIGkuY29uY2F0KGUpfXJldHVybiBlfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIndlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhaW5hYmxlV2VpZ2h0cy5jb25jYXQodGhpcy5ub25UcmFpbmFibGVXZWlnaHRzKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5sb2FkV2VpZ2h0cz1mdW5jdGlvbihlLHQpe3ZvaWQgMD09PXQmJih0PSEwKTtmb3IodmFyIG49e30scj0wLGk9MCxhPXRoaXMubGF5ZXJzO2k8YS5sZW5ndGg7aSsrKWZvcih2YXIgbz0wLHM9YVtpXS53ZWlnaHRzO288cy5sZW5ndGg7bysrKXt2YXIgbD1zW29dO2lmKG51bGwhPW5bbC5vcmlnaW5hbE5hbWVdKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRHVwbGljYXRlIHdlaWdodCBuYW1lOiBcIitsLm9yaWdpbmFsTmFtZSk7bltsLm9yaWdpbmFsTmFtZV09bCxyKyt9dmFyIHU9W107Zm9yKHZhciBjIGluIGUpe2lmKG51bGwhPW5bY10pdS5wdXNoKFtuW2NdLGVbY11dKTtlbHNlIGlmKHQpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJQcm92aWRlZCB3ZWlnaHQgZGF0YSBoYXMgbm8gdGFyZ2V0IHZhcmlhYmxlOiBcIitjKTtkZWxldGUgbltjXX1pZih0KXt2YXIgcD1bXTtmb3IodmFyIGggaW4gbilwLnB1c2goaCk7aWYocC5sZW5ndGg+MCl0aHJvdyBuZXcgVmFsdWVFcnJvcihwLmxlbmd0aCtcIiBvZiBcIityK1wiIHdlaWdodHMgYXJlIG5vdCBzZXQ6IFwiK3ApfWJhdGNoU2V0VmFsdWUodSl9LHQucHJvdG90eXBlLnVwZGF0ZWRDb25maWc9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmdldENvbmZpZygpLHQ9e307cmV0dXJuIHQuY2xhc3NOYW1lPXRoaXMuZ2V0Q2xhc3NOYW1lKCksdC5jb25maWc9ZSx0LmtlcmFzVmVyc2lvbj1cInRmanMtbGF5ZXJzIFwiK3ZlcnNpb24sdC5iYWNrZW5kPVwiVGVuc29yRmxvdy5qc1wiLHR9LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbihlLHQpe3ZvaWQgMD09PXQmJih0PSEwKTt2YXIgbj1jb252ZXJ0VHNUb1B5dGhvbmljKHRoaXMudXBkYXRlZENvbmZpZygpKTtyZXR1cm4gdD9KU09OLnN0cmluZ2lmeShuKTpufSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe2U9dG9MaXN0KGUpO2Zvcih2YXIgcj1uZXcgRmVlZERpY3QsaT0wO2k8bi5pbnB1dHMubGVuZ3RoOysraSlyLmFkZChuLmlucHV0c1tpXSxlW2ldKTtyZXR1cm4gZXhlY3V0ZShuLm91dHB1dHMscix0KX0pfSx0LnByb3RvdHlwZS5jb21wdXRlTWFzaz1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgcjtyZXR1cm4gZT10b0xpc3QoZSkscj1udWxsPT10P3B5TGlzdFJlcGVhdChudWxsLGUubGVuZ3RoKTp0b0xpc3QodCksbi5ydW5JbnRlcm5hbEdyYXBoKGUscilbMV19KX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3ZhciB0PW5vcm1hbGl6ZVNoYXBlTGlzdChlKTtpZih0Lmxlbmd0aCE9PXRoaXMuaW5wdXRMYXllcnMubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW52YWxpZCBpbnB1dFNoYXBlIGFyZ3VtZW50IFwiK2UrXCI6IG1vZGVsIGhhcyBcIit0aGlzLmlucHV0TGF5ZXJzLmxlbmd0aCtcIiB0ZW5zb3IgaW5wdXRzLlwiKTtmb3IodmFyIG49e30scj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgaT10aGlzLmlucHV0TGF5ZXJzW3JdLGE9dFtyXTtuW0k9aS5uYW1lK1wiXzBfMFwiXT1hfXZhciBvPU9iamVjdC5rZXlzKHRoaXMubm9kZXNCeURlcHRoKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHBhcnNlSW50KGUsMTApfSkuc29ydChyZXZlcnNlTnVtYmVyQ29tcGFyZSk7aWYoby5sZW5ndGg+MSlmb3IodmFyIHM9MCxsPW87czxsLmxlbmd0aDtzKyspZm9yKHZhciB1PWxbc10sYz0wLHA9dGhpcy5ub2Rlc0J5RGVwdGhbdV07YzxwLmxlbmd0aDtjKyspe3ZhciBoPXBbY107aT1oLm91dGJvdW5kTGF5ZXI7aWYoLTE9PT10aGlzLmlucHV0TGF5ZXJzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5pZH0pLmluZGV4T2YoaS5pZCkpe2Zvcih2YXIgZD1bXSxmPTA7ZjxoLmluYm91bmRMYXllcnMubGVuZ3RoO2YrKyl7dmFyIGc9aC5pbmJvdW5kTGF5ZXJzW2ZdLG09aC5ub2RlSW5kaWNlc1tmXSx5PWgudGVuc29ySW5kaWNlc1tmXSx2PW5bST1nLm5hbWUrXCJfXCIrbStcIl9cIit5XTtkLnB1c2godil9dmFyIGI9bm9ybWFsaXplU2hhcGVMaXN0KGkuY29tcHV0ZU91dHB1dFNoYXBlKHNpbmdsZXRvbk9yQXJyYXkoZCkpKSx3PWkuaW5ib3VuZE5vZGVzLmluZGV4T2YoaCk7Zm9yKGY9MDtmPGIubGVuZ3RoO2YrKyl7bltJPWkubmFtZStcIl9cIit3K1wiX1wiK2ZdPWJbZl19fX12YXIgej1bXSxTPVtdO2ZvcihyPTA7cjx0aGlzLm91dHB1dExheWVycy5sZW5ndGg7cisrKXtpPXRoaXMub3V0cHV0TGF5ZXJzW3JdLHc9dGhpcy5vdXRwdXRMYXllcnNOb2RlSW5kaWNlc1tyXSx5PXRoaXMub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlc1tyXTt2YXIgST1pLm5hbWUrXCJfXCIrdytcIl9cIit5O1MucHVzaChJKX1mb3Iocj0wO3I8Uy5sZW5ndGg7cisrKXt2YXIgQT1TW3JdO2Fzc2VydChBIGluIG4pLHoucHVzaChuW0FdKX1yZXR1cm4gc2luZ2xldG9uT3JBcnJheSh6KX0sdC5wcm90b3R5cGUucnVuSW50ZXJuYWxHcmFwaD1mdW5jdGlvbihlLHQpe251bGw9PXQmJih0PXB5TGlzdFJlcGVhdChudWxsLGUubGVuZ3RoKSk7Zm9yKHZhciBuPXt9LHI9MDtyPHRoaXMuaW5wdXRzLmxlbmd0aDsrK3Ipe3ZhciBpPXRoaXMuaW5wdXRzW3JdLGE9ZVtyXSxvPXRbcl07bltpLmlkXT1bYSxvXX1mb3IodmFyIHM9MCxsPU9iamVjdC5rZXlzKHRoaXMubm9kZXNCeURlcHRoKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHBhcnNlSW50KGUsMTApfSkuc29ydChyZXZlcnNlTnVtYmVyQ29tcGFyZSk7czxsLmxlbmd0aDtzKyspZm9yKHZhciB1PWxbc10sYz0wLHA9dGhpcy5ub2Rlc0J5RGVwdGhbdV07YzxwLmxlbmd0aDtjKyspe2Zvcih2YXIgaD1wW2NdLGQ9aC5vdXRib3VuZExheWVyLGY9aC5pbnB1dFRlbnNvcnMsZz1oLm91dHB1dFRlbnNvcnMsbT1uZXcgQXJyYXkseT0wLHY9Zjt5PHYubGVuZ3RoO3krKyl7KGk9dlt5XSkuaWQgaW4gbiYmbS5wdXNoKG5baS5pZF0pfWlmKG0ubGVuZ3RoPT09Zi5sZW5ndGgpe3ZhciBiPXt9LHc9dm9pZCAwLHo9dm9pZCAwLFM9dm9pZCAwLEk9dm9pZCAwO2lmKG51bGwhPWguY2FsbEFyZ3MmJihiPWguY2FsbEFyZ3MpLDE9PT1tLmxlbmd0aCl7dmFyIEE9bVswXSxfPUFbMF0sQz1BWzFdO251bGw9PWIubWFzayYmKGIubWFzaz1DKSxTPXRvTGlzdChkLmNhbGwoXyxiKSksST10b0xpc3QoZC5jb21wdXRlTWFzayhfLEMpKSx3PVtfXSx6PVtDXX1lbHNlIHc9bS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGVbMF19KSx6PW0ubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlWzFdfSksbnVsbD09Yi5tYXNrJiYoYi5tYXNrPXopLFM9dG9MaXN0KGQuY2FsbCh3LGIpKSxJPXRvTGlzdChkLmNvbXB1dGVNYXNrKHcseikpO2lmKGQuYWN0aXZpdHlSZWd1bGFyaXplcil0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIkxheWVyc01vZGVsIGludm9jYXRpb24gd2l0aCBjb25jcmV0ZSBUZW5zb3IgdmFsdWUocykgaW4gdGhlIHByZXNlbmNlIG9mIGFjdGl2aXR5IHJlZ3VsYXJpemVyKHMpIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtmb3Iocj0wO3I8Zy5sZW5ndGg7KytyKXtpPWdbcl0sYT1TW3JdLG89SVtyXTtuW2kuaWRdPVthLG9dfX19Zm9yKHZhciBOPVtdLEU9W10saz1bXSxMPTAseD10aGlzLm91dHB1dHM7TDx4Lmxlbmd0aDtMKyspe2Fzc2VydCgoaT14W0xdKS5pZCBpbiBuLFwiQ291bGQgbm90IGNvbXB1dGUgb3V0cHV0IFwiK2kubmFtZStcIiA6IFwiK2kuaWQpO3ZhciBUPW5baS5pZF0sRD1UWzBdO289VFsxXTtrLnB1c2goRC5zaGFwZSksTi5wdXNoKEQpLEUucHVzaChvKX1yZXR1cm5bTixFLGtdfSx0LnByb3RvdHlwZS5idWlsZE5vZGVDb252ZXJzaW9uTWFwPWZ1bmN0aW9uKGUpe2Zvcih2YXIgbixyPXt9LGk9MCxhPXRoaXMubGF5ZXJzO2k8YS5sZW5ndGg7aSsrKXt2YXIgbz1hW2ldO249byBpbnN0YW5jZW9mIHQ/MTowO2Zvcih2YXIgcz0wO3M8by5pbmJvdW5kTm9kZXMubGVuZ3RoO3MrKyl7dmFyIGw9dC5ub2RlS2V5KG8scyk7dGhpcy5jb250YWluZXJOb2Rlcy5oYXMobCkmJihyW2xdPW4sbis9MSl9fXJldHVybiByfSx0LnByb3RvdHlwZS5nZXRMYXllcj1mdW5jdGlvbihlLHQpe2lmKG51bGwhPXQpe2lmKHRoaXMubGF5ZXJzLmxlbmd0aDw9dCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIldhcyBhc2tlZCB0byByZXRyaWV2ZSBsYXllciBhdCBpbmRleCBcIit0K1wiLCBidXQgbW9kZWwgb25seSBoYXMgXCIrdGhpcy5sYXllcnMubGVuZ3RoK1wiIGxheWVyKHMpLlwiKTtyZXR1cm4gdGhpcy5sYXllcnNbdF19aWYobnVsbD09ZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlByb3ZpZGUgZWl0aGVyIGEgbGF5ZXIgbmFtZSBvciBsYXllciBpbmRleFwiKTtmb3IodmFyIG49MCxyPXRoaXMubGF5ZXJzO248ci5sZW5ndGg7bisrKXt2YXIgaT1yW25dO2lmKGkubmFtZT09PWUpcmV0dXJuIGl9dGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJObyBzdWNoIGxheWVyOiBcIitlKX0sdC5wcm90b3R5cGUuY2FsY3VsYXRlTG9zc2VzPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe2Zvcih2YXIgbj1bXSxyPTAsaT1lLmxheWVycztyPGkubGVuZ3RoO3IrKylmb3IodmFyIGE9aVtyXSxvPTA7bzxhLmluYm91bmROb2Rlcy5sZW5ndGg7KytvKXt2YXIgcz10Lm5vZGVLZXkoYSxvKTtlLmNvbnRhaW5lck5vZGVzLmhhcyhzKSYmbi5wdXNoLmFwcGx5KG4sYS5jYWxjdWxhdGVMb3NzZXMoKSl9cmV0dXJuIG59KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPXtuYW1lOnRoaXMubmFtZX0sbj10aGlzLmJ1aWxkTm9kZUNvbnZlcnNpb25NYXAodGhpcy5sYXllcnMpLHI9W10saT0wLGE9dGhpcy5sYXllcnM7aTxhLmxlbmd0aDtpKyspe2Zvcih2YXIgbz0odz1hW2ldKS5nZXRDbGFzc05hbWUoKSxzPXcuZ2V0Q29uZmlnKCksbD1bXSx1PTA7dTx3LmluYm91bmROb2Rlcy5sZW5ndGg7dSsrKXt2YXIgYz13LmluYm91bmROb2Rlc1t1XSxwPXQubm9kZUtleSh3LHUpLGg9e307aWYodGhpcy5jb250YWluZXJOb2Rlcy5oYXMocCkpe2lmKGMuY2FsbEFyZ3MpdHJ5e0pTT04uc3RyaW5naWZ5KGMuY2FsbEFyZ3MpLGg9Yy5jYWxsQXJnc31jYXRjaChlKXtjb25zb2xlLndhcm4oXCJMYXllciBcIit3Lm5hbWUrXCIgd2FzIHBhc3NlZCBub24tc2VyaWFsaXphYmxlIGtleXdvcmQgYXJndW1lbnRzOiBcIitjLmNhbGxBcmdzK1wiLiBUaGV5IHdpbGwgbm90IGJlIGluY2x1ZGVkIGluIHRoZSBzZXJpYWxpemVkIG1vZGVsIChhbmQgdGh1cyB3aWxsIGJlIG1pc3NpbmcgYXQgZGVzZXJpYWxpemF0aW9uIHRpbWUpLlwiKSxoPXt9fWlmKGMuaW5ib3VuZExheWVycy5sZW5ndGg+MCl7Zm9yKHZhciBkPVtdLGY9MDtmPGMuaW5ib3VuZExheWVycy5sZW5ndGg7ZisrKXt2YXIgZz1jLmluYm91bmRMYXllcnNbZl0sbT1jLm5vZGVJbmRpY2VzW2ZdLHk9Yy50ZW5zb3JJbmRpY2VzW2ZdO251bGw9PShTPW5bdC5ub2RlS2V5KGcsbSldKSYmKFM9MCksZC5wdXNoKFtnLm5hbWUsUyx5LGhdKX1sLnB1c2goZCl9fX12YXIgdj17fTt2Lm5hbWU9dy5uYW1lLHYuY2xhc3NOYW1lPW8sdi5jb25maWc9cyx2LmluYm91bmROb2Rlcz1sLHIucHVzaCh2KX1lLmxheWVycz1yO3ZhciBiPVtdO2ZvcihmPTA7Zjx0aGlzLmlucHV0TGF5ZXJzLmxlbmd0aDtmKyspe3ZhciB3PXRoaXMuaW5wdXRMYXllcnNbZl07bT10aGlzLmlucHV0TGF5ZXJzTm9kZUluZGljZXNbZl0scD10Lm5vZGVLZXkodyxtKTtpZih0aGlzLmNvbnRhaW5lck5vZGVzLmhhcyhwKSl7bnVsbCE9PShTPW5bcF0pJiZ2b2lkIDAhPT1TfHwoUz0wKTt5PXRoaXMuaW5wdXRMYXllcnNUZW5zb3JJbmRpY2VzW2ZdO2IucHVzaChbdy5uYW1lLFMseV0pfX1lLmlucHV0TGF5ZXJzPWI7dmFyIHo9W107Zm9yKGY9MDtmPHRoaXMub3V0cHV0TGF5ZXJzLmxlbmd0aDtmKyspe3c9dGhpcy5vdXRwdXRMYXllcnNbZl0sbT10aGlzLm91dHB1dExheWVyc05vZGVJbmRpY2VzW2ZdLHA9dC5ub2RlS2V5KHcsbSk7aWYodGhpcy5jb250YWluZXJOb2Rlcy5oYXMocCkpe3ZhciBTO251bGwhPT0oUz1uW3BdKSYmdm9pZCAwIT09U3x8KFM9MCk7eT10aGlzLm91dHB1dExheWVyc1RlbnNvckluZGljZXNbZl07ei5wdXNoKFt3Lm5hbWUsUyx5XSl9fXJldHVybiBlLm91dHB1dExheWVycz16LGV9LHQuZnJvbUNvbmZpZz1mdW5jdGlvbihlLHQsbixyKXt2b2lkIDA9PT1uJiYobj17fSksdm9pZCAwPT09ciYmKHI9ITEpO3ZhciBpPXt9LGE9e307ZnVuY3Rpb24gbyhlLHQpe2UubmFtZSBpbiBhP2FbZS5uYW1lXS5wdXNoKHQpOmFbZS5uYW1lXT1bdF19ZnVuY3Rpb24gcyhlLHQpe2Zvcih2YXIgbixyPVtdLGE9MCxzPXQ7YTxzLmxlbmd0aDthKyspe3ZhciBsPXNbYV0sdT1sWzBdLGM9bFsxXSxwPWxbMl07aWYobj1udWxsPT1sWzNdP3t9OmxbM10sISh1IGluIGkpKXJldHVybiB2b2lkIG8oZSx0KTt2YXIgaD1pW3VdO2lmKGguaW5ib3VuZE5vZGVzLmxlbmd0aDw9YylyZXR1cm4gdm9pZCBvKGUsdCk7dmFyIGQ9aC5pbmJvdW5kTm9kZXNbY107ci5wdXNoKGQub3V0cHV0VGVuc29yc1twXSl9ci5sZW5ndGg+MCYmZS5hcHBseShzaW5nbGV0b25PckFycmF5KHIpLG4pfWZ1bmN0aW9uIGwoZSl7dmFyIG49ZS5uYW1lLGE9ZGVzZXJpYWxpemUoZSxudWxsIT10LmN1c3RvbU9iamVjdHM/dC5jdXN0b21PYmplY3RzOnt9KTthLnNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQociksaVtuXT1hLGUuaW5ib3VuZE5vZGVzLmZvckVhY2goZnVuY3Rpb24oZSl7aWYoIShlIGluc3RhbmNlb2YgQXJyYXkpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ29ycnVwdGVkIGNvbmZpZ3VyYXRpb24sIGV4cGVjdGVkIGFycmF5IGZvciBub2RlRGF0YTogXCIrZSk7byhhLGUpfSl9Zm9yKHZhciB1PXQubmFtZSxjPXQubGF5ZXJzLHA9MCxoPWM7cDxoLmxlbmd0aDtwKyspe2woZz1oW3BdKX1mb3IoOyFpc09iamVjdEVtcHR5KGEpOylmb3IodmFyIGQ9MCxmPWM7ZDxmLmxlbmd0aDtkKyspe3ZhciBnPWZbZF07aWYoKGs9aVtnLm5hbWVdKS5uYW1lIGluIGEpe3ZhciBtPWFbay5uYW1lXTtkZWxldGUgYVtrLm5hbWVdO2Zvcih2YXIgeT0wLHY9bTt5PHYubGVuZ3RoO3krKyl7cyhrLHZbeV0pfX19Zm9yKHZhciBiPVtdLHc9W10sej0wLFM9dC5pbnB1dExheWVyczt6PFMubGVuZ3RoO3orKyl7dmFyIEk9KGc9U1t6XSlbMF0sQT1nWzFdLF89Z1syXTthc3NlcnQoSSBpbiBpKTt2YXIgQz0oaz1pW0ldKS5pbmJvdW5kTm9kZXNbQV0ub3V0cHV0VGVuc29ycztiLnB1c2goQ1tfXSl9Zm9yKHZhciBOPTAsRT10Lm91dHB1dExheWVycztOPEUubGVuZ3RoO04rKyl7ST0oZz1FW05dKVswXSxBPWdbMV0sXz1nWzJdO2Fzc2VydChJIGluIGkpO3ZhciBrO0M9KGs9aVtJXSkuaW5ib3VuZE5vZGVzW0FdLm91dHB1dFRlbnNvcnM7dy5wdXNoKENbX10pfXJldHVybiBuZXcgZSh7aW5wdXRzOmIsb3V0cHV0czp3LG5hbWU6dX0pfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJzdGF0ZWZ1bFwiLHtnZXQ6ZnVuY3Rpb24oKXtpZih0aGlzLl9zdGF0ZWZ1bCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNvbnRhaW5lciBpbnN0YW5jZSB1bmV4cGVjdGVkbHkgaGFzIF9zdGF0ZWZ1bCA9IHRydWUuIFRoZSBzdGF0ZWZ1bG5lc3Mgb2YgYSBDb250YWluZXIgaXMgZGV0ZXJtaW5lZCBieSB0aGUgTGF5ZXJzIGl0IGNvbnRhaW5zLiBJdHMgX3N0YXRlZnVsIHByb3BlcnR5IG11c3QgcmVtYWluIHRoZSBkZWZhdWx0IGZhbHNlLlwiKTtmb3IodmFyIGU9MCx0PXRoaXMubGF5ZXJzO2U8dC5sZW5ndGg7ZSsrKXtpZih0W2VdLnN0YXRlZnVsKXJldHVybiEwfXJldHVybiExfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLnJlc2V0U3RhdGVzPWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aWR5KGZ1bmN0aW9uKCl7ZS5sYXllcnMuZm9yRWFjaChmdW5jdGlvbihlKXtlLnN0YXRlZnVsJiZlLnJlc2V0U3RhdGVzKCl9KX0pfSx0fShMYXllciksREVGQVVMVF9WQUxJREFUSU9OX0JBVENIX1NJWkU9MzI7ZnVuY3Rpb24gc3RhbmRhcmRpemVEYXRhSXRlcmF0b3JPdXRwdXQoZSx0KXt2YXIgbixyLGk9dDtuPWkueHMscj1pLnlzLHV0aWwuYXNzZXJ0KG51bGwhPW4mJm51bGwhPXIsZnVuY3Rpb24oKXtyZXR1cm5cIkEgRGF0YXNldCBpdGVyYXRvciBmb3IgZml0RGF0YXNldCgpIGlzIGV4cGVjdGVkIHRvIGdlbmVyYXRlIG9iamVjdHMgb2YgdGhlIGZvcm0gYHt4czogeFZhbCwgeXM6IHlWYWx9YCwgd2hlcmUgdGhlIHR3byB2YWx1ZXMgbWF5IGJlIGB0Zi5UZW5zb3JgLCBhbiBhcnJheSBvZiBUZW5zb3JzLCBvciBhIG1hcCBvZiBzdHJpbmcgdG8gVGVuc29yLiAgVGhlIHByb3ZpZGVkIERhdGFzZXQgaW5zdGVhZCBnZW5lcmF0ZXMgXCIrdH0pO3ZhciBhPWZsYXR0ZW5UZW5zb3JPckFycmF5T3JNYXAoXCJpbnB1dFwiLGUuaW5wdXROYW1lcyxuKSxvPWZsYXR0ZW5UZW5zb3JPckFycmF5T3JNYXAoXCJvdXRwdXRcIixlLm91dHB1dE5hbWVzLHIpLHM9YVswXS5zaGFwZVswXTt1dGlsLmFzc2VydChhLmxlbmd0aD09PWUuaW5wdXRzLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiTGF5ZXJzTW9kZWwgaGFzIFwiK2UuaW5wdXRzLmxlbmd0aCtcIiBpbnB1dHMsIGJ1dCB0aGUgZGF0YXNldCBwcm92aWRlcyBcIithLmxlbmd0aCtcIiBpbnB1dHMuICAoRXhwZWN0ZWQgaW5wdXQga2V5czogXCIrSlNPTi5zdHJpbmdpZnkoZS5pbnB1dE5hbWVzKStcIilcIn0pLHV0aWwuYXNzZXJ0KG8ubGVuZ3RoPT09ZS5vdXRwdXRzLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiTGF5ZXJzTW9kZWwgaGFzIFwiK2Uub3V0cHV0cy5sZW5ndGgrXCIgb3V0cHV0cywgYnV0IHRoZSBkYXRhc2V0IHByb3ZpZGVzIFwiK28ubGVuZ3RoK1wiIG91dHB1dHMuICAoRXhwZWN0ZWQgb3V0cHV0IGtleXM6IFwiK0pTT04uc3RyaW5naWZ5KGUub3V0cHV0TmFtZXMpK1wiKVwifSk7dmFyIGw9ZnVuY3Rpb24odCl7dXRpbC5hc3NlcnQoYVt0XS5zaGFwZVswXT09PXMsZnVuY3Rpb24oKXtyZXR1cm5cIkJhdGNoIHNpemUgbWlzbWF0Y2g6IGlucHV0IFwiK2UuaW5wdXROYW1lc1t0XStcIiBoYXMgXCIrYVt0XS5zaGFwZVswXStcIjsgZXhwZWN0ZWQgIFwiK3MrXCIgYmFzZWQgb24gaW5wdXQgXCIrZS5pbnB1dE5hbWVzWzBdK1wiLlwifSl9O2Zvcih2YXIgdSBpbiBhKWwodSk7dmFyIGM9ZnVuY3Rpb24odCl7dXRpbC5hc3NlcnQob1t0XS5zaGFwZVswXT09PXMsZnVuY3Rpb24oKXtyZXR1cm5cIkJhdGNoIHNpemUgbWlzbWF0Y2g6IG91dHB1dCBcIitlLm91dHB1dE5hbWVzW3RdK1wiIGhhcyBcIitvW3RdLnNoYXBlWzBdK1wiOyBleHBlY3RlZCAgXCIrcytcIiBiYXNlZCBvbiBpbnB1dCBcIitlLmlucHV0TmFtZXNbMF0rXCIuXCJ9KX07Zm9yKHZhciBwIGluIG8pYyhwKTtyZXR1cm4gYS5jb25jYXQobyl9ZnVuY3Rpb24gZmxhdHRlblRlbnNvck9yQXJyYXlPck1hcChlLHQsbil7aWYobiBpbnN0YW5jZW9mIFRlbnNvcilyZXR1cm5bbl07aWYoQXJyYXkuaXNBcnJheShuKSlyZXR1cm4gdXRpbC5hc3NlcnQobi5sZW5ndGg9PT10Lmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiUmVjZWl2ZWQgYW4gYXJyYXkgb2YgXCIrbi5sZW5ndGgrXCIgVGVuc29ycywgYnV0IGV4cGVjdGVkIFwiK3QubGVuZ3RoK1wiIHRvIG1hdGNoIHRoZSBcIitlK1wiIGtleXMgXCIrdCtcIi5cIn0pLG47Zm9yKHZhciByPVtdLGk9MCxhPXQ7aTxhLmxlbmd0aDtpKyspe3ZhciBvPWFbaV07aWYobnVsbD09bltvXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBmZWF0dXJlIGRhdGEgZ2VuZXJhdGVkIGJ5IHRoZSBkYXRhc2V0IGxhY2tzIHRoZSByZXF1aXJlZCBcIitlK1wiIGtleSAnXCIrbytcIicuXCIpO3IucHVzaChuW29dKX1yZXR1cm4gcn1mdW5jdGlvbiBzdGFuZGFyZGl6ZVRlbnNvclZhbGlkYXRpb25EYXRhKGUpe2lmKDM9PT1lLmxlbmd0aCl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlZhbGlkYXRpb24gd2l0aCBzYW1wbGUgd2VpZ2h0cyBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtyZXR1cm57eHM6ZVswXSx5czplWzFdfX1mdW5jdGlvbiBmaXREYXRhc2V0KGUsdCxuKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciByLGksYSxvLHMsbCx1LGMscCxoLGQsZixnLG0seSx2LGIsdyx6LFMsSSxBLF8sQyxOLEUsaztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihMKXtzd2l0Y2goTC5sYWJlbCl7Y2FzZSAwOmlmKHI9bnVsbCE9bi5iYXRjaGVzUGVyRXBvY2gsdXRpbC5hc3NlcnQobnVsbCE9ZS5vcHRpbWl6ZXIsZnVuY3Rpb24oKXtyZXR1cm5cIllvdSBtdXN0IGNvbXBpbGUgYSBtb2RlbCBiZWZvcmUgdHJhaW5pbmcvdGVzdGluZy4gVXNlIExheWVyc01vZGVsLmNvbXBpbGUobW9kZWxDb21waWxlQ29uZmlnKS5cIn0pLHV0aWwuYXNzZXJ0KG51bGwhPW4sZnVuY3Rpb24oKXtyZXR1cm5cIkZvciBmaXREYXRhc2V0KCksIHRoZSAybmQgYXJndW1lbnQgKGNvbmZpZykgaXMgcmVxdWlyZWQsIGJ1dCBpdCBpcyBub3QgcHJvdmlkZWQgaW4gdGhpcyBjYWxsLlwifSksdXRpbC5hc3NlcnQobnVsbCE9bi5lcG9jaHMmJm4uZXBvY2hzPjAmJk51bWJlci5pc0ludGVnZXIobi5lcG9jaHMpLGZ1bmN0aW9uKCl7cmV0dXJuXCJGb3IgZml0RGF0YXNldCgpLCBjb25maWcuZXBvY2hzIGlzIGV4cGVjdGVkIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCBcIituLmVwb2Noc30pLHV0aWwuYXNzZXJ0KCFyfHxuLmJhdGNoZXNQZXJFcG9jaD4wJiZOdW1iZXIuaXNJbnRlZ2VyKG4uYmF0Y2hlc1BlckVwb2NoKSxmdW5jdGlvbigpe3JldHVyblwiRm9yIGZpdERhdGFzZXQoKSwgY29uZmlnLmJhdGNoZXNQZXJFcG9jaCBpcyBleHBlY3RlZCB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIgaWYgc3BlY2lmaWVkLCBidXQgZ290IFwiK24uYmF0Y2hlc1BlckVwb2NofSksdXRpbC5hc3NlcnQobnVsbD09bi52YWxpZGF0aW9uU3BsaXQsZnVuY3Rpb24oKXtyZXR1cm5cImB2YWxpZGF0aW9uU3BsaXRgIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYGZpdERhdGFzZXQoKWAuIFVzZSB2YWxpZGF0aW9uRGF0YSBpbnN0ZWFkLlwifSksZS5pc1RyYWluaW5nKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzdGFydCB0cmFpbmluZyBiZWNhdXNlIGFub3RoZXIgZml0KCkgY2FsbCBpcyBvbmdvaW5nLlwiKTtlLmlzVHJhaW5pbmc9ITAsTC5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gTC50cnlzLnB1c2goWzEsLDIyLDIzXSksaT1udWxsIT1uLnZhbGlkYXRpb25EYXRhLGE9dm9pZCAwLG89dm9pZCAwLGkmJihpc0RhdGFzZXRPYmplY3Qobi52YWxpZGF0aW9uRGF0YSk/dXRpbC5hc3NlcnQobnVsbD09bi52YWxpZGF0aW9uQmF0Y2hlc3x8bi52YWxpZGF0aW9uQmF0Y2hlcz4wJiZOdW1iZXIuaXNJbnRlZ2VyKG4udmFsaWRhdGlvbkJhdGNoZXMpLGZ1bmN0aW9uKCl7cmV0dXJuXCJGb3IgZml0RGF0YXNldCgpIHdpdGggZGF0YXNldC1iYXNlZCB2YWxpZGF0aW9uLCBjb25maWcudmFsaWRhdGlvbkJhdGNoZXMgaXMgZXhwZWN0ZWQgbm90IHRvIGJlIHByb3ZpZGVkLCBvciB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCBnb3QgXCIrbi52YWxpZGF0aW9uQmF0Y2hlc30pOihzPXN0YW5kYXJkaXplVGVuc29yVmFsaWRhdGlvbkRhdGEobi52YWxpZGF0aW9uRGF0YSksYT1zLnhzLG89cy55cykpLGw9ZS5tYWtlVHJhaW5GdW5jdGlvbigpLHU9ZS5nZXREZWR1cGVkTWV0cmljc05hbWVzKCksYz12b2lkIDAsYz1pP3Uuc2xpY2UoKS5jb25jYXQodS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuXCJ2YWxfXCIrZX0pKTp1LnNsaWNlKCkscD1zdGFuZGFyZGl6ZUNhbGxiYWNrcyhuLmNhbGxiYWNrcyxuLnlpZWxkRXZlcnkpLGg9bnVsbD09bi52ZXJib3NlPzE6bi52ZXJib3NlLGQ9Y29uZmlndXJlQ2FsbGJhY2tzKHAsaCxuLmVwb2NocyxudWxsLG51bGwsZ2V0U3RlcHNQZXJFcG9jaCh0LG4pLG51bGwsaSxjKSxmPWQuY2FsbGJhY2tMaXN0LGc9ZC5oaXN0b3J5LGYuc2V0TW9kZWwoZSksZS5oaXN0b3J5PWcsWzQsZi5vblRyYWluQmVnaW4oKV07Y2FzZSAyOnJldHVybiBMLnNlbnQoKSxlLnN0b3BUcmFpbmluZ189ITEsbT1udWxsPT1uLmluaXRpYWxFcG9jaD8wOm4uaW5pdGlhbEVwb2NoLFs0LHQuaXRlcmF0b3IoKV07Y2FzZSAzOnk9TC5zZW50KCksTC5sYWJlbD00O2Nhc2UgNDpyZXR1cm4gbTxuLmVwb2Nocz8odj17fSxbNCxmLm9uRXBvY2hCZWdpbihtKV0pOlszLDE5XTtjYXNlIDU6cmV0dXJuIEwuc2VudCgpLGI9MCx3PTAscj9bMyw3XTpbNCx0Lml0ZXJhdG9yKCldO2Nhc2UgNjp5PUwuc2VudCgpLEwubGFiZWw9NztjYXNlIDc6cmV0dXJuIXJ8fGI8bi5iYXRjaGVzUGVyRXBvY2g/WzQseS5uZXh0KCldOlszLDE3XTtjYXNlIDg6cmV0dXJuIHo9TC5zZW50KCksciYmei5kb25lPyhjb25zb2xlLndhcm4oXCJZb3UgcHJvdmlkZWQgYGJhdGNoZXNQZXJFcG9jaGAgYXMgXCIrbi5iYXRjaGVzUGVyRXBvY2grXCIsIGJ1dCB5b3VyIGRhdGFzZXQgaXRlcmF0b3IgcmFuIG91dCBvZiBkYXRhIGFmdGVyIFwiK2IrXCIgYmF0Y2hlczsgaW50ZXJydXB0aW5nIHRyYWluaW5nLiBNYWtlIHN1cmUgdGhhdCB5b3VyIGRhdGFzZXQgY2FuIGdlbmVyYXRlIGF0IGxlYXN0IGBiYXRjaGVzUGVyRXBvY2ggKiBlcG9jaHNgIGJhdGNoZXMgKGluIHRoaXMgY2FzZSwgXCIrbi5iYXRjaGVzUGVyRXBvY2gqbi5lcG9jaHMrXCIgYmF0Y2hlcykuIFlvdSBtYXkgbmVlZCB0byB1c2UgdGhlIHJlcGVhdCgpIGZ1bmN0aW9uIHdoZW4gYnVpbGRpbmcgeW91ciBkYXRhc2V0LlwiKSxbMywxN10pOm51bGw9PXoudmFsdWU/WzMsMTFdOihTPXN0YW5kYXJkaXplRGF0YUl0ZXJhdG9yT3V0cHV0KGUsei52YWx1ZSksKEk9e30pLmJhdGNoPXcsSS5zaXplPVNbMF0uc2hhcGVbMF0sWzQsZi5vbkJhdGNoQmVnaW4odyxJKV0pO2Nhc2UgOTpmb3IoTC5zZW50KCksQT1sKFMpLGRpc3Bvc2UoUyksaz0wO2s8dS5sZW5ndGg7KytrKV89dVtrXSxDPUFba10sSVtfXT1DLGtlZXAoQyk7cmV0dXJuWzQsZi5vbkJhdGNoRW5kKHcsSSldO2Nhc2UgMTA6TC5zZW50KCksZGlzcG9zZVRlbnNvcnNJbkxvZ3MoSSksdysrLGIrKyxMLmxhYmVsPTExO2Nhc2UgMTE6cmV0dXJuKHI/Yj49bi5iYXRjaGVzUGVyRXBvY2g6ei5kb25lKT9pPyhOPXZvaWQgMCxpc0RhdGFzZXRPYmplY3Qobi52YWxpZGF0aW9uRGF0YSk/KEU9dG9MaXN0LFs0LGUuZXZhbHVhdGVEYXRhc2V0KG4udmFsaWRhdGlvbkRhdGEse2JhdGNoZXM6bi52YWxpZGF0aW9uQmF0Y2hlc30pXSk6WzMsMTNdKTpbMywxNV06WzMsMTZdO2Nhc2UgMTI6cmV0dXJuIE49RS5hcHBseSh2b2lkIDAsW0wuc2VudCgpXSksWzMsMTRdO2Nhc2UgMTM6Tj10b0xpc3QoZS5ldmFsdWF0ZShhLG8se2JhdGNoU2l6ZTpudWxsPT1uLnZhbGlkYXRpb25CYXRjaFNpemU/REVGQVVMVF9WQUxJREFUSU9OX0JBVENIX1NJWkU6bi52YWxpZGF0aW9uQmF0Y2hTaXplLHZlcmJvc2U6MH0pKSxMLmxhYmVsPTE0O2Nhc2UgMTQ6Zm9yKGs9MDtrPGUubWV0cmljc05hbWVzLmxlbmd0aDsrK2spdltcInZhbF9cIitlLm1ldHJpY3NOYW1lc1trXV09TltrXTtMLmxhYmVsPTE1O2Nhc2UgMTU6cmV0dXJuWzMsMTddO2Nhc2UgMTY6cmV0dXJuIGUuc3RvcFRyYWluaW5nXz9bMywxN106WzMsN107Y2FzZSAxNzpyZXR1cm5bNCxmLm9uRXBvY2hFbmQobSx2KV07Y2FzZSAxODpyZXR1cm4gTC5zZW50KCksbSsrLGUuc3RvcFRyYWluaW5nXz9bMywxOV06WzMsNF07Y2FzZSAxOTpyZXR1cm5bNCxmLm9uVHJhaW5FbmQoKV07Y2FzZSAyMDpyZXR1cm4gTC5zZW50KCksWzQsZS5oaXN0b3J5LnN5bmNEYXRhKCldO2Nhc2UgMjE6cmV0dXJuIEwuc2VudCgpLFsyLGUuaGlzdG9yeV07Y2FzZSAyMjpyZXR1cm4gZS5pc1RyYWluaW5nPSExLFs3XTtjYXNlIDIzOnJldHVyblsyXX19KX0pfWZ1bmN0aW9uIGdldFN0ZXBzUGVyRXBvY2goZSx0KXt2YXIgbj1udWxsO3JldHVybiBudWxsIT10LmJhdGNoZXNQZXJFcG9jaD9uPXQuYmF0Y2hlc1BlckVwb2NoOk51bWJlci5pc0Zpbml0ZShlLnNpemUpJiYobj1lLnNpemUpLG59ZnVuY3Rpb24gaXNEYXRhc2V0T2JqZWN0KGUpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGUuaXRlcmF0b3J9ZnVuY3Rpb24gaXNMYXp5SXRlcmF0b3JPYmplY3QoZSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZS5uZXh0fWZ1bmN0aW9uIGV2YWx1YXRlRGF0YXNldChlLHQsbil7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgcixpLGEsbyxzLGwsdSxjLHAsaDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihkKXtzd2l0Y2goZC5sYWJlbCl7Y2FzZSAwOmlmKHI9bnVsbCE9KG49bnx8e30pLmJhdGNoZXMsaT1lLnRlc3RGdW5jdGlvbixhPVtdLG4udmVyYm9zZT4wKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiVmVyYm9zZSBtb2RlIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO3JldHVybiB1dGlsLmFzc2VydCghcnx8bi5iYXRjaGVzPjAmJk51bWJlci5pc0ludGVnZXIobi5iYXRjaGVzKSxmdW5jdGlvbigpe3JldHVyblwiVGVzdCBsb29wIGV4cGVjdHMgYGJhdGNoZXNgIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IHJlY2VpdmVkIFwiK0pTT04uc3RyaW5naWZ5KG4uYmF0Y2hlcyl9KSxpc0xhenlJdGVyYXRvck9iamVjdCh0KT8ocz10LFszLDNdKTpbMywxXTtjYXNlIDE6cmV0dXJuWzQsdC5pdGVyYXRvcigpXTtjYXNlIDI6cz1kLnNlbnQoKSxkLmxhYmVsPTM7Y2FzZSAzOm89cyxsPTAsdT0wLGM9ZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihzKXtzd2l0Y2gocy5sYWJlbCl7Y2FzZSAwOnJldHVybls0LG8ubmV4dCgpXTtjYXNlIDE6cmV0dXJuIHQ9cy5zZW50KCksYT10aWR5KGZ1bmN0aW9uKCl7aWYodC52YWx1ZSl7dmFyIG49c3RhbmRhcmRpemVEYXRhSXRlcmF0b3JPdXRwdXQoZSx0LnZhbHVlKSxyPXRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gaShuKX0pO2lmKGRpc3Bvc2UobiksMD09PXUpZm9yKHZhciBvPTA7bzxyLmxlbmd0aDsrK28pYS5wdXNoKHNjYWxhcigwKSk7dmFyIHM9blswXS5zaGFwZVswXSxjPWZ1bmN0aW9uKGUpe3ZhciB0PXJbZV0sbj1hW2VdO2FbZV09dGlkeShmdW5jdGlvbigpe3JldHVybiBhZGQoYVtlXSxtdWwocyx0KSl9KSx1PjAmJmRpc3Bvc2Uobil9O2ZvcihvPTA7bzxyLmxlbmd0aDsrK28pYyhvKTtkaXNwb3NlKHIpLGwrPXMsKyt1fXJldHVybiBhfSksdC5kb25lPyhyJiZjb25zb2xlLndhcm4oXCJZb3VyIGRhdGFzZXQgaXRlcmF0b3IgcmFuIG91dCBvZiBkYXRhIGR1cmluZyBldmFsdWF0ZURhdGFzZXQoKS4gSW50ZXJydXB0aW5nIGV2YWx1dGlvbi4gTWFrZSBzdXJlIHRoYXQgeW91ciBkYXRhc2V0IGNhbiBnZW5lcmF0ZSBhdCBsZWFzdCBgYmF0Y2hlc2AgYmF0Y2hlcyAoaW4gdGhpcyBjYXNlLCBcIituLmJhdGNoZXMrXCIgYmF0Y2hlcykuIFlvdSBtYXkgbmVlZCB0byB1c2UgdGhlIHJlcGVhdCgpIGZ1bmN0aW9uIHdoZW4gYnVpbGRpbmcgeW91ciBkYXRhc2V0LlwiKSxbMixcImJyZWFrXCJdKTpbMl19fSl9LGQubGFiZWw9NDtjYXNlIDQ6cmV0dXJuIXJ8fHU8bi5iYXRjaGVzP1s1LGMoKV06WzMsNl07Y2FzZSA1OnJldHVyblwiYnJlYWtcIj09PWQuc2VudCgpP1szLDZdOlszLDRdO2Nhc2UgNjpmb3IocD0wO3A8YS5sZW5ndGg7KytwKWg9YVtwXSxhW3BdPWRpdihhW3BdLGwpLGRpc3Bvc2UoaCk7cmV0dXJuWzIsc2luZ2xldG9uT3JBcnJheShhKV19fSl9KX1mdW5jdGlvbiBjaGVja0JhdGNoU2l6ZShlKXt1dGlsLmFzc2VydChlPjAmJk51bWJlci5pc0ludGVnZXIoZSksZnVuY3Rpb24oKXtyZXR1cm5cImJhdGNoU2l6ZSBpcyByZXF1aXJlZCB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCBnb3QgXCIrZX0pfWZ1bmN0aW9uIHNsaWNlQXJyYXlzKGUsdCxuKXtyZXR1cm4gbnVsbD09ZT9bbnVsbF06QXJyYXkuaXNBcnJheShlKT9lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gc2xpY2VBbG9uZ0ZpcnN0QXhpcyhlLHQsbi10KX0pOnNsaWNlQWxvbmdGaXJzdEF4aXMoZSx0LG4tdCl9ZnVuY3Rpb24gc2xpY2VBcnJheXNCeUluZGljZXMoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBudWxsPT1lP251bGw6QXJyYXkuaXNBcnJheShlKT9lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gc2xpY2VBcnJheXNCeUluZGljZXMoZSx0KX0pOmdhdGhlciQxKGUsXCJpbnQzMlwiPT09dC5kdHlwZT90OnQudG9JbnQoKSl9KX1mdW5jdGlvbiBtYWtlQmF0Y2hlcyhlLHQpe2Zvcih2YXIgbj1bXSxyPTAsaT1udWxsO3I8ZTspKGk9cit0KT49ZSYmKGk9ZSksbi5wdXNoKFtyLGldKSxyPWk7cmV0dXJuIG59ZnVuY3Rpb24gZml0TG9vcChlLHQsbixyLGksYSxvLHMsbCx1LGMscCxoLGQsZil7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZyxtLHksdixiLHcseixTO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKEkpe3N3aXRjaChJLmxhYmVsKXtjYXNlIDA6aWYobnVsbD09aSYmKGk9MzIpLG51bGw9PWEmJihhPTEpLG51bGw9PWMmJihjPSEwKSxudWxsPT1oJiYoaD0wKSxnPSExLG51bGwhPWwmJm51bGwhPXUmJihnPSEwKSxudWxsIT1mJiYoZz0hMCxudWxsPT1kKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNhbiBvbmx5IHVzZSBgdmFsaWRhdGlvblN0ZXBzYCB3aGVuIGRvaW5nIHN0ZXAtd2lzZSB0cmFpbmluZywgaS5lLiwgYHN0ZXBzUGVyRXBvY2hgIG11c3QgYmUgc2V0LlwiKTtyZXR1cm4gbnVsbCE9KG09ZS5jaGVja051bVNhbXBsZXMobixpLGQsXCJzdGVwc19wZXJfZXBvY2hcIikpJiYoeT1yYW5nZSgwLG0pKSxudWxsPT1vJiYobz0xKSx2PWNvbmZpZ3VyZUNhbGxiYWNrcyhzLG8sYSxoLG0sZCxpLGcscCksYj12LmNhbGxiYWNrTGlzdCx3PXYuaGlzdG9yeSxiLnNldE1vZGVsKGUpLGUuaGlzdG9yeT13LFs0LGIub25UcmFpbkJlZ2luKCldO2Nhc2UgMTpJLnNlbnQoKSxlLnN0b3BUcmFpbmluZ189ITEsej1mdW5jdGlvbihhKXt2YXIgbyxzLHAsaCxmO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHYpe3N3aXRjaCh2LmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsYi5vbkVwb2NoQmVnaW4oYSldO2Nhc2UgMTppZih2LnNlbnQoKSxvPXt9LG51bGw9PWQpcmV0dXJuWzMsMl07dGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJzdGVwc1BlckVwb2NoIG1vZGUgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7Y2FzZSAyOmlmKFwiYmF0Y2hcIj09PWMpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJiYXRjaCBzaHVmZmxpbmcgaXMgbm90IGltcGxlbW5ldGVkIHlldFwiKTtjJiZ1dGlsLnNodWZmbGUoeSkscz10ZW5zb3IxZCh5KSxwPW1ha2VCYXRjaGVzKG0saSksaD1mdW5jdGlvbihhKXt2YXIgYztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihoKXtzd2l0Y2goaC5sYWJlbCl7Y2FzZSAwOnJldHVybiBjPXt9LFs0LGIub25CYXRjaEJlZ2luKGEsYyldO2Nhc2UgMTpyZXR1cm4gaC5zZW50KCksdGlkeShmdW5jdGlvbigpe3ZhciBoPXBbYV1bMF0sZD1wW2FdWzFdLGY9c2xpY2VBbG9uZ0ZpcnN0QXhpcyhzLGgsZC1oKTtjLmJhdGNoPWEsYy5zaXplPWQtaDtmb3IodmFyIG09c2xpY2VBcnJheXNCeUluZGljZXMobixmKSx5PXQobSksdj0wO3Y8ci5sZW5ndGg7Kyt2KXt2YXIgYj1yW3ZdLHc9eVt2XTtjW2JdPXcsa2VlcCh3KX1pZihhPT09cC5sZW5ndGgtMSYmZyl7dmFyIHo9ZS50ZXN0TG9vcChsLHUsaSk7Zm9yKHY9MDt2PHIubGVuZ3RoOysrdil7Yj1yW3ZdLHc9elt2XTtrZWVwKHcpLG9bXCJ2YWxfXCIrYl09d319fSksWzQsYi5vbkJhdGNoRW5kKGEsYyldO2Nhc2UgMjpyZXR1cm4gaC5zZW50KCksZGlzcG9zZVRlbnNvcnNJbkxvZ3MoYyksZS5zdG9wVHJhaW5pbmdfP1syLFwiYnJlYWtcIl06WzJdfX0pfSxmPTAsdi5sYWJlbD0zO2Nhc2UgMzpyZXR1cm4gZjxwLmxlbmd0aD9bNSxoKGYpXTpbMyw2XTtjYXNlIDQ6aWYoXCJicmVha1wiPT09di5zZW50KCkpcmV0dXJuWzMsNl07di5sYWJlbD01O2Nhc2UgNTpyZXR1cm4rK2YsWzMsM107Y2FzZSA2OnMuZGlzcG9zZSgpLHYubGFiZWw9NztjYXNlIDc6cmV0dXJuWzQsYi5vbkVwb2NoRW5kKGEsbyldO2Nhc2UgODpyZXR1cm4gdi5zZW50KCksZS5zdG9wVHJhaW5pbmdfP1syLFwiYnJlYWtcIl06WzJdfX0pfSxTPWgsSS5sYWJlbD0yO2Nhc2UgMjpyZXR1cm4gUzxhP1s1LHooUyldOlszLDVdO2Nhc2UgMzppZihcImJyZWFrXCI9PT1JLnNlbnQoKSlyZXR1cm5bMyw1XTtJLmxhYmVsPTQ7Y2FzZSA0OnJldHVybisrUyxbMywyXTtjYXNlIDU6cmV0dXJuWzQsYi5vblRyYWluRW5kKCldO2Nhc2UgNjpyZXR1cm4gSS5zZW50KCksWzQsZS5oaXN0b3J5LnN5bmNEYXRhKCldO2Nhc2UgNzpyZXR1cm4gSS5zZW50KCksWzIsZS5oaXN0b3J5XX19KX0pfWZ1bmN0aW9uIGZpdFRlbnNvcnMoZSx0LG4scil7cmV0dXJuIHZvaWQgMD09PXImJihyPXt9KSxfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGksYSxvLHMsbCx1LGMscCxoLGQsZixnLG0seSx2LGIsdyx6LFM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oSSl7c3dpdGNoKEkubGFiZWwpe2Nhc2UgMDppZihlLmlzVHJhaW5pbmcpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN0YXJ0IHRyYWluaW5nIGJlY2F1c2UgYW5vdGhlciBmaXQoKSBjYWxsIGlzIG9uZ29pbmcuXCIpO2UuaXNUcmFpbmluZz0hMCxJLmxhYmVsPTE7Y2FzZSAxOmlmKEkudHJ5cy5wdXNoKFsxLCwzLDRdKSxjaGVja0JhdGNoU2l6ZShjPW51bGw9PXIuYmF0Y2hTaXplPzMyOnIuYmF0Y2hTaXplKSxwPWUuc3RhbmRhcmRpemVVc2VyRGF0YSh0LG4sITEsYyksaT1wWzBdLGE9cFsxXSxoPSExLGQ9dm9pZCAwLG51bGwhPXIudmFsaWRhdGlvbkRhdGEmJnIudmFsaWRhdGlvbkRhdGEubGVuZ3RoPjApe2lmKGg9ITAsMiE9PXIudmFsaWRhdGlvbkRhdGEubGVuZ3RoKXRocm93IDM9PT1yLnZhbGlkYXRpb25EYXRhLmxlbmd0aD9uZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcInZhbGlkYXRpb25EYXRhIGluY2x1ZGluZyBzYW1wbGUgd2VpZ2h0cyBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik6bmV3IFZhbHVlRXJyb3IoXCJXaGVuIHBhc3NpbmcgdmFsaWRhdGlvbiBkYXRhLCBpdCBtdXN0IGNvbnRhaW4gMiAodmFsWCwgdmFsWSkgb3IgMyAodmFsWCwgdmFsWSwgdmFsU2FtcGxlV2VpZ2h0KSBpdGVtczsgXCIrci52YWxpZGF0aW9uRGF0YStcIiBpcyBpbnZhbGlkLlwiKTtvPXIudmFsaWRhdGlvbkRhdGFbMF0scz1yLnZhbGlkYXRpb25EYXRhWzFdLGY9ZS5zdGFuZGFyZGl6ZVVzZXJEYXRhKG8scywhMCxjKSxsPWZbMF0sdT1mWzFdLGQ9bC5jb25jYXQodSl9ZWxzZSBudWxsIT1yLnZhbGlkYXRpb25TcGxpdCYmci52YWxpZGF0aW9uU3BsaXQ+MCYmci52YWxpZGF0aW9uU3BsaXQ8MT8oaD0hMCxnPU1hdGguZmxvb3IoaVswXS5zaGFwZVswXSooMS1yLnZhbGlkYXRpb25TcGxpdCkpLG09aVswXS5zaGFwZVswXSxsPXNsaWNlQXJyYXlzKGksZyxtKSxpPXNsaWNlQXJyYXlzKGksMCxnKSx1PXNsaWNlQXJyYXlzKGEsZyxtKSxhPXNsaWNlQXJyYXlzKGEsMCxnKSxkPWwuY29uY2F0KHUpKTpudWxsIT1yLnZhbGlkYXRpb25TdGVwcyYmKGg9ITApO3JldHVybiB5PWkuY29uY2F0KGEpLGUuY2hlY2tUcmFpbmFibGVXZWlnaHRzQ29uc2lzdGVuY3koKSx2PWUubWFrZVRyYWluRnVuY3Rpb24oKSxiPWUuZ2V0RGVkdXBlZE1ldHJpY3NOYW1lcygpLHc9dm9pZCAwLHo9dm9pZCAwLGg/KGUubWFrZVRlc3RGdW5jdGlvbigpLHc9ZS50ZXN0RnVuY3Rpb24sej1iLnNsaWNlKCkuY29uY2F0KGIubWFwKGZ1bmN0aW9uKGUpe3JldHVyblwidmFsX1wiK2V9KSkpOih3PW51bGwsZD1bXSx6PWIuc2xpY2UoKSksUz1zdGFuZGFyZGl6ZUNhbGxiYWNrcyhyLmNhbGxiYWNrcyxyLnlpZWxkRXZlcnkpLFs0LGZpdExvb3AoZSx2LHksYixjLHIuZXBvY2hzLHIudmVyYm9zZSxTLHcsZCxyLnNodWZmbGUseixyLmluaXRpYWxFcG9jaCxudWxsLG51bGwpXTtjYXNlIDI6cmV0dXJuWzIsSS5zZW50KCldO2Nhc2UgMzpyZXR1cm4gZS5pc1RyYWluaW5nPSExLGRpc3Bvc2VOZXdUZW5zb3JzKGksdCksZGlzcG9zZU5ld1RlbnNvcnMoYSxuKSxkaXNwb3NlTmV3VGVuc29ycyhsLG8pLGRpc3Bvc2VOZXdUZW5zb3JzKHUscyksWzddO2Nhc2UgNDpyZXR1cm5bMl19fSl9KX1mdW5jdGlvbiBlbnN1cmVUZW5zb3JzUmFuazJPckhpZ2hlcihlKXt2YXIgdD1bXTtlIGluc3RhbmNlb2YgVGVuc29yJiYoZT1bZV0pO2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7KytuKXt2YXIgcj1lW25dO2lmKDE9PT1yLnJhbmspdC5wdXNoKGV4cGFuZERpbXMkMShyLDEpKTtlbHNle2lmKDA9PT1yLnJhbmspdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgdGVuc29yIHRvIGJlIGF0IGxlYXN0IDFELCBidXQgcmVjZWl2ZWQgYSAwRCB0ZW5zb3IgKHNjYWxhcikuXCIpO3QucHVzaChyKX19cmV0dXJuIHR9ZnVuY3Rpb24gZGlzcG9zZU5ld1RlbnNvcnMoZSx0KXtpZihudWxsIT1lKXt2YXIgbj1bXTtpZih0IGluc3RhbmNlb2YgVGVuc29yKW4ucHVzaCh0LmlkKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkodCkpdC5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBuLnB1c2goZS5pZCl9KTtlbHNlIGlmKG51bGwhPXQpZm9yKHZhciByIGluIHQpe3ZhciBpPXRbcl07bi5wdXNoKGkuaWQpfXZhciBhPVtdO2lmKGUgaW5zdGFuY2VvZiBUZW5zb3IpLTE9PT1uLmluZGV4T2YoZS5pZCkmJmEucHVzaChlKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkoZSkpZS5mb3JFYWNoKGZ1bmN0aW9uKGUpey0xPT09bi5pbmRleE9mKGUuaWQpJiZhLnB1c2goZSl9KTtlbHNlIGlmKG51bGwhPWUpZm9yKHZhciBvIGluIGUpe3ZhciBzPWVbb107LTE9PT1uLmluZGV4T2Yocy5pZCkmJmEucHVzaChzKX1hLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5pc0Rpc3Bvc2VkfHxlLmRpc3Bvc2UoKX0pfX1mdW5jdGlvbiBpc0RhdGFUZW5zb3IoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBUZW5zb3J9ZnVuY3Rpb24gaXNEYXRhQXJyYXkoZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSl9ZnVuY3Rpb24gaXNEYXRhRGljdChlKXtyZXR1cm4haXNEYXRhVGVuc29yKGUpJiYhaXNEYXRhQXJyYXkoZSl9ZnVuY3Rpb24gc3RhbmRhcmRpemVJbnB1dERhdGEoZSx0LG4scixpKXtpZih2b2lkIDA9PT1yJiYocj0hMCksdm9pZCAwPT09aSYmKGk9XCJcIiksbnVsbD09dHx8MD09PXQubGVuZ3RoKXtpZihudWxsIT1lKXt2YXIgYT0hMTtpZihpc0RhdGFBcnJheShlKSYmZS5sZW5ndGg+MClhPSEwO2Vsc2UgaWYoaXNEYXRhRGljdChlKSl7Zm9yKHZhciBvIGluIGUpaWYoZS5oYXNPd25Qcm9wZXJ0eShvKSl7YT0hMDticmVha319ZWxzZSBhPSEwO2lmKGEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJFcnJvciB3aGVuIGNoZWNraW5nIG1vZGVsIFwiK2krXCIgZXhwZWN0ZWQgbm8gZGF0YSwgYnV0IGdvdCBcIitlKX1yZXR1cm5bXX1pZihudWxsPT1lKXJldHVybiB0Lm1hcChmdW5jdGlvbihlKXtyZXR1cm4gbnVsbH0pO3ZhciBzO2lmKGlzRGF0YURpY3QoZSkpe2U9ZSxzPVtdO2Zvcih2YXIgbD0wLHU9dDtsPHUubGVuZ3RoO2wrKyl7dmFyIGM9dVtsXTtpZihudWxsPT1lW2NdKXRocm93IG5ldyBWYWx1ZUVycm9yKCdObyBkYXRhIHByb3ZpZGVkIGZvciBcIicrYysnXCIuIE5lZWQgZGF0YSBmb3IgZWFjaCBrZXkgaW46ICcrdCk7cy5wdXNoKGVbY10pfX1lbHNlIGlmKGlzRGF0YUFycmF5KGUpKXtpZigoZT1lKS5sZW5ndGghPT10Lmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkVycm9yIHdoZW4gY2hlY2tpbmcgbW9kZWwgXCIraStcIjogdGhlIEFycmF5IG9mIFRlbnNvcnMgdGhhdCB5b3UgYXJlIHBhc3NpbmcgdG8geW91ciBtb2RlbCBpcyBub3QgdGhlIHNpemUgdGhlIG1vZGVsIGV4cGVjdGVkLiBFeHBlY3RlZCB0byBzZWUgXCIrdC5sZW5ndGgrXCIgVGVuc29yKHMpLCBidXQgaW5zdGVhZCBnb3QgdGhlIGZvbGxvd2luZyBsaXN0IG9mIFRlbnNvcihzKTogXCIrZSk7cz1lfWVsc2V7aWYoZT1lLHQubGVuZ3RoPjEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgbW9kZWwgXCIraStcIiBleHBlY3RzIFwiK3QubGVuZ3RoK1wiIFRlbnNvcihzKSwgYnV0IG9ubHkgcmVjZWl2ZWQgb25lIFRlbnNvci4gRm91bmQ6IFRlbnNvciB3aXRoIHNoYXBlIFwiK2Uuc2hhcGUpO3M9W2VdfWlmKHM9ZW5zdXJlVGVuc29yc1JhbmsyT3JIaWdoZXIocyksbnVsbCE9bilmb3IodmFyIHA9MDtwPHQubGVuZ3RoOysrcClpZihudWxsIT1uW3BdKXt2YXIgaD1zW3BdO2lmKGguc2hhcGUubGVuZ3RoIT09bltwXS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJFcnJvciB3aGVuIGNoZWNraW5nIFwiK2krXCI6IGV4cGVjdGVkIFwiK3RbcF0rXCIgdG8gaGF2ZSBcIituW3BdLmxlbmd0aCtcIiBkaW1lbnNpb24ocykuIGJ1dCBnb3QgYXJyYXkgd2l0aCBzaGFwZSBcIitoLnNoYXBlKTtmb3IodmFyIGQ9MDtkPG5bcF0ubGVuZ3RoOysrZClpZigwIT09ZHx8cil7dmFyIGY9aC5zaGFwZVtkXSxnPW5bcF1bZF07aWYobnVsbCE9ZyYmZz49MCYmZiE9PWcpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJFcnJvciB3aGVuIGNoZWNraW5nIFwiK2krXCI6IGV4cGVjdGVkIFwiK3RbcF0rXCIgdG8gaGF2ZSBzaGFwZSBbXCIrbltwXStcIl0sIGJ1dCBnb3QgYXJyYXkgd2l0aCBzaGFwZSBbXCIraC5zaGFwZStcIl0uXCIpfX1yZXR1cm4gc31mdW5jdGlvbiBjaGVja0FycmF5TGVuZ3RocyhlLHQsbil7dmFyIHI9dW5pcXVlKGUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNoYXBlWzBdfSkpO3Iuc29ydCgpO3ZhciBpPXVuaXF1ZSh0Lm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5zaGFwZVswXX0pKTtpZihpLnNvcnQoKSxyLmxlbmd0aD4xKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQWxsIGlucHV0IFRlbnNvcnMgKHgpIHNob3VsZCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBzYW1wbGVzLiBHb3QgYXJyYXkgc2hhcGVzOiBcIitKU09OLnN0cmluZ2lmeShlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5zaGFwZX0pKSk7aWYoaS5sZW5ndGg+MSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkFsbCB0YXJnZXQgVGVuc29ycyAoeSkgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHNhbXBsZXMuIEdvdCBhcnJheSBzaGFwZXM6IFwiK0pTT04uc3RyaW5naWZ5KHQubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNoYXBlfSkpKTtpZihyLmxlbmd0aD4wJiZpLmxlbmd0aD4wJiYhdXRpbC5hcnJheXNFcXVhbChyLGkpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW5wdXQgVGVuc29ycyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygc2FtcGxlcyBhcyB0YXJnZXQgVGVuc29ycy4gRm91bmQgXCIrclswXStcIiBpbnB1dCBzYW1wbGUocykgYW5kIFwiK2lbMF0rXCIgdGFyZ2V0IHNhbXBsZShzKS5cIil9ZnVuY3Rpb24gY2hlY2tMb3NzQW5kVGFyZ2V0Q29tcGF0aWJpbGl0eShlLHQsbil7Zm9yKHZhciByPVttZWFuU3F1YXJlZEVycm9yLGJpbmFyeUNyb3NzZW50cm9weSxjYXRlZ29yaWNhbENyb3NzZW50cm9weV0saT0wO2k8ZS5sZW5ndGg7KytpKXt2YXIgYT1lW2ldLG89dFtpXSxzPW5baV07aWYobnVsbCE9byl7aWYobz09PWNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5JiYxPT09YS5zaGFwZVthLnNoYXBlLmxlbmd0aC0xXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIllvdSBhcmUgcGFzc2luZyBhIHRhcmdldCBhcnJheSBvZiBzaGFwZSBcIithLnNoYXBlK1wiIHdoaWxlIHVzaW5nIGEgbG9zcyAnY2F0ZWdvcmljYWxfY3Jvc3NlbnRyb3B5Jy4gJ2NhdGVnb3JpY2FsX2Nyb3NzZW50cm9weSdleHBlY3RzIHRhcmdldHMgdG8gYmUgYmluYXJ5IG1hdHJpY2VzICgxcyBhbmQgMHMpIG9mIHNoYXBlIFtzYW1wbGVzLCBjbGFzc2VzXS5cIik7aWYoLTEhPT1yLmluZGV4T2YobykpZm9yKHZhciBsPWEuc2hhcGUuc2xpY2UoMSksdT1zLnNsaWNlKDEpLGM9MDtjPGwubGVuZ3RoOysrYyl7dmFyIHA9bFtjXSxoPXVbY107aWYobnVsbCE9aCYmcCE9PWgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBIHRhcmdldCBUZW5zb3Igd2l0aCBzaGFwZSBcIithLnNoYXBlK1wiIHdhcyBwYXNzZWQgZm9yIGFuIG91dHB1dCBvZiBzaGFwZSBcIitzK1wiLCB3aGlsZSB1c2luZyBhIGxvc3MgZnVuY3Rpb24gdGhhdCBleHBlY3RzIHRhcmdldHMgdG8gaGF2ZSB0aGUgc2FtZSBzaGFwZSBhcyB0aGUgb3V0cHV0LlwiKX19fX1mdW5jdGlvbiBjaGVja0lucHV0RGF0YShlLHQsbixyLGkpe3ZhciBhO2lmKHZvaWQgMD09PXImJihyPSEwKSx2b2lkIDA9PT1pJiYoaT1cIlwiKSxBcnJheS5pc0FycmF5KGUpKXtpZihlLmxlbmd0aCE9PXQubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRXJyb3Igd2hlbiBjaGVja2luZyBtb2RlbCBcIitpK1wiOiB0aGUgQXJyYXkgb2YgVGVuc29ycyB0aGF0IHlvdSBhcmUgcGFzc2luZyB0byB5b3VyIG1vZGVsIGlzIG5vdCB0aGUgc2l6ZSB0aGUgdGhlIG1vZGVsIGV4cGVjdGVkLiBFeHBlY3RlZCB0byBzZWUgXCIrdC5sZW5ndGgrXCIgVGVuc29yKHMpLCBidXQgaW5zdGVhZCBnb3QgXCIrZS5sZW5ndGgrXCIgVGVuc29ycyhzKS5cIik7YT1lfWVsc2V7aWYodC5sZW5ndGg+MSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBtb2RlbCBleHBlY3RzIFwiK3QubGVuZ3RoK1wiIFwiK2krXCIgVGVuc29ycywgYnV0IG9ubHkgcmVjZWl2ZWQgb25lIFRlbnNvci4gRm91bmQ6IGFycmF5IHdpdGggc2hhcGUgXCIrSlNPTi5zdHJpbmdpZnkoZS5zaGFwZSkrXCIuXCIpO2E9W2VdfWlmKG51bGwhPW4pZm9yKHZhciBvPTA7bzx0Lmxlbmd0aDsrK28paWYobnVsbCE9bltvXSl7dmFyIHM9YVtvXTtpZihzLnNoYXBlLmxlbmd0aCE9PW5bb10ubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRXJyb3Igd2hlbiBjaGVja2luZyBcIitpK1wiOiBleHBlY3RlZCBcIit0W29dK1wiIHRvIGhhdmUgXCIrbltvXS5sZW5ndGgrXCIgZGltZW5zaW9uKHMpLCBidXQgZ290IGFycmF5IHdpdGggc2hhcGUgXCIrSlNPTi5zdHJpbmdpZnkocy5zaGFwZSkpO2Zvcih2YXIgbD0wO2w8bltvXS5sZW5ndGg7KytsKWlmKDAhPT1sfHxyKXt2YXIgdT1zLnNoYXBlW2xdLGM9bltvXVtsXTtpZihudWxsIT1jJiZjIT09dSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkVycm9yIHdoZW4gY2hlY2tpbmcgXCIraStcIjogZXhwZWN0ZWQgXCIrdFtvXStcIiB0byBoYXZlIHNoYXBlIFwiK0pTT04uc3RyaW5naWZ5KG5bb10pK1wiIGJ1dCBnb3QgYXJyYXkgd2l0aCBzaGFwZSBcIitKU09OLnN0cmluZ2lmeShzLnNoYXBlKStcIi5cIil9fX1mdW5jdGlvbiBjb2xsZWN0TWV0cmljcyhlLHQpe2lmKG51bGw9PWV8fEFycmF5LmlzQXJyYXkoZSkmJjA9PT1lLmxlbmd0aClyZXR1cm4gdC5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuW119KTtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiB0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZX0pO2lmKG51bGwhPWUpe2Zvcih2YXIgbj1bXSxyPTAsaT10O3I8aS5sZW5ndGg7cisrKXt2YXIgYT1pW3JdLG89ZS5oYXNPd25Qcm9wZXJ0eShhKT9lW2FdOltdO0FycmF5LmlzQXJyYXkobyl8fChvPVtvXSksbi5wdXNoKG8pfXJldHVybiBufXRocm93IG5ldyBUeXBlRXJyb3IoXCJUeXBlIG9mIG1ldHJpY3MgYXJndW1lbnQgbm90IHVuZGVyc3Rvb2QuIEV4cGVjdGVkIGFuIEFycmF5IG9yIE9iamVjdCwgZm91bmQ6IFwiK2UpfXZhciBMQVlFUlNfTU9ERUxfRk9STUFUX05BTUU9XCJsYXllcnMtbW9kZWxcIixMYXllcnNNb2RlbD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLmlzVHJhaW5pbmc9ITEsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbihlLHQsbil7aWYodm9pZCAwPT09biYmKG49Y29uc29sZS5sb2cpLCF0aGlzLmJ1aWx0KXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhpcyBtb2RlbCBoYXMgbmV2ZXIgYmVlbiBjYWxsZWQsIHRodXMgaXRzIHdlaWdodHMgaGF2ZSBub3QgYmVlbiBjcmVhdGVkIHlldC4gU28gbm8gc3VtbWFyeSBjYW4gYmUgZGlzcGxheWVkLiBCdWlsZCB0aGUgbW9kZWwgZmlyc3QgKGUuZy4sIGJ5IGNhbGxpbmcgaXQgb24gc29tZSB0ZXN0IGRhdGEpLlwiKTtwcmludFN1bW1hcnkodGhpcyxlLHQsbil9LHQucHJvdG90eXBlLmNvbXBpbGU9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZihudWxsPT1lLmxvc3MmJihlLmxvc3M9W10pLHRoaXMubG9zcz1lLmxvc3MsXCJzdHJpbmdcIj09dHlwZW9mIGUub3B0aW1pemVyKXRoaXMub3B0aW1pemVyXz1nZXRPcHRpbWl6ZXIoZS5vcHRpbWl6ZXIpLHRoaXMuaXNPcHRpbWl6ZXJPd25lZD0hMDtlbHNle2lmKCEoZS5vcHRpbWl6ZXIgaW5zdGFuY2VvZiBPcHRpbWl6ZXIpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVXNlci1kZWZpbmVkIG9wdGltaXplciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHRmLk9wdGltaXplci5cIik7dGhpcy5vcHRpbWl6ZXJfPWUub3B0aW1pemVyLHRoaXMuaXNPcHRpbWl6ZXJPd25lZD0hMX12YXIgbj1bXTtpZihBcnJheS5pc0FycmF5KGUubG9zcyl8fFwic3RyaW5nXCI9PXR5cGVvZiBlLmxvc3N8fFwiZnVuY3Rpb25cIj09dHlwZW9mIGUubG9zcylpZihBcnJheS5pc0FycmF5KGUubG9zcykpe2lmKGUubG9zcy5sZW5ndGghPT10aGlzLm91dHB1dHMubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiV2hlbiBwYXNzaW5nIGFuIEFycmF5IGFzIGxvc3MsIGl0IHNob3VsZCBoYXZlIG9uZSBlbnRyeSBwZXIgbW9kZWwgb3V0cHV0LiBUaGUgbW9kZWwgaGFzIFwiK3RoaXMub3V0cHV0cy5sZW5ndGgrXCIgb3V0cHV0KHMpLCBidXQgeW91IHBhc3NlZCBsb3NzPVwiK2UubG9zcytcIi5cIik7dmFyIHI9ZS5sb3NzO249ci5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGdldChlKX0pfWVsc2V7dmFyIGk9Z2V0KGUubG9zcyk7dGhpcy5vdXRwdXRzLmZvckVhY2goZnVuY3Rpb24oZSl7bi5wdXNoKGkpfSl9ZWxzZXtmb3IodmFyIGEgaW4gZS5sb3NzPWUubG9zcyxlLmxvc3MpaWYoLTE9PT10aGlzLm91dHB1dE5hbWVzLmluZGV4T2YoYSkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ1Vua25vd24gZW50cnkgaW4gbG9zcyBkaWN0aW9uYXJ5OiBcIicrYSsnXCIuIE9ubHkgZXhwZWN0ZWQgdGhlIGZvbGxvd2luZyBrZXlzOiAnK3RoaXMub3V0cHV0TmFtZXMpO2Zvcih2YXIgbz0wLHM9dGhpcy5vdXRwdXROYW1lcztvPHMubGVuZ3RoO28rKyl7dmFyIGw9c1tvXTtudWxsPT1lLmxvc3NbbF0mJmNvbnNvbGUud2FybignT3V0cHV0IFwiJytsKydcIiBpcyBtaXNzaW5nIGZyb20gbG9zcyBkaWN0aW9uYXJ5LiBXZSBhc3N1bWUgdGhpcyB3YXMgZG9uZSBvbiBwdXJwb3NlLCBhbmQgd2Ugd2lsbCBub3QgYmUgZXhwZWN0aW5nIGRhdGEgdG8gYmUgcGFzc2VkIHRvICcrbCtcIiBkdXJpbmcgdHJhaW5pbmdcIiksbi5wdXNoKGdldChlLmxvc3NbbF0pKX19dGhpcy5sb3NzRnVuY3Rpb25zPW4sdGhpcy5mZWVkT3V0cHV0TmFtZXM9W10sdGhpcy5mZWVkT3V0cHV0U2hhcGVzPVtdLHRoaXMuZmVlZExvc3NGbnM9W107Zm9yKHZhciB1PTA7dTx0aGlzLm91dHB1dHMubGVuZ3RoOysrdSl7dmFyIGM9dGhpcy5pbnRlcm5hbE91dHB1dFNoYXBlc1t1XSxwPXRoaXMub3V0cHV0TmFtZXNbdV07dGhpcy5mZWVkT3V0cHV0TmFtZXMucHVzaChwKSx0aGlzLmZlZWRPdXRwdXRTaGFwZXMucHVzaChjKSx0aGlzLmZlZWRMb3NzRm5zLnB1c2godGhpcy5sb3NzRnVuY3Rpb25zW3VdKX12YXIgaD1bXTt0aGlzLm1ldHJpY3M9ZS5tZXRyaWNzLHRoaXMubWV0cmljc05hbWVzPVtcImxvc3NcIl0sdGhpcy5tZXRyaWNzVGVuc29ycz1bXSxuYW1lU2NvcGUoXCJsb3NzXCIsZnVuY3Rpb24oKXtmb3IodmFyIGU9MDtlPHQub3V0cHV0cy5sZW5ndGg7KytlKWlmKC0xPT09aC5pbmRleE9mKGUpKXt2YXIgbj10Lmxvc3NGdW5jdGlvbnNbZV07dC5vdXRwdXRzLmxlbmd0aD4xJiYodC5tZXRyaWNzVGVuc29ycy5wdXNoKFtuLGVdKSx0Lm1ldHJpY3NOYW1lcy5wdXNoKHQub3V0cHV0TmFtZXNbZV0rXCJfbG9zc1wiKSl9fSk7dmFyIGQ9Y29sbGVjdE1ldHJpY3MoZS5tZXRyaWNzLHRoaXMub3V0cHV0TmFtZXMpO25hbWVTY29wZShcIm1ldHJpY1wiLGZ1bmN0aW9uKCl7Zm9yKHZhciBlPWZ1bmN0aW9uKGUpe2lmKC0xIT09aC5pbmRleE9mKGUpKXJldHVyblwiY29udGludWVcIjshZnVuY3Rpb24obil7Zm9yKHZhciByLGksYSxvPWZ1bmN0aW9uKG4pe2lmKC0xIT09W1wiYWNjdXJhY3lcIixcImFjY1wiLFwiY3Jvc3NlbnRyb3B5XCIsXCJjZVwiXS5pbmRleE9mKG4pKXt2YXIgbz10LmludGVybmFsT3V0cHV0U2hhcGVzW2VdOzE9PT1vW28ubGVuZ3RoLTFdfHx0Lmxvc3NGdW5jdGlvbnNbZV09PT1iaW5hcnlDcm9zc2VudHJvcHk/LTEhPT1bXCJhY2N1cmFjeVwiLFwiYWNjXCJdLmluZGV4T2Yobik/aT1iaW5hcnlBY2N1cmFjeTotMSE9PVtcImNyb3NzZW50cm9weVwiLFwiY2VcIl0uaW5kZXhPZihuKSYmKGk9YmluYXJ5Q3Jvc3NlbnRyb3B5JDEpOnQubG9zc0Z1bmN0aW9uc1tlXT09PXNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5Py0xIT09W1wiYWNjdXJhY3lcIixcImFjY1wiXS5pbmRleE9mKG4pP2k9c3BhcnNlQ2F0ZWdvcmljYWxBY2N1cmFjeTotMSE9PVtcImNyb3NzZW50cm9weVwiLFwiY2VcIl0uaW5kZXhPZihuKSYmKGk9c3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHkkMSk6LTEhPT1bXCJhY2N1cmFjeVwiLFwiYWNjXCJdLmluZGV4T2Yobik/aT1jYXRlZ29yaWNhbEFjY3VyYWN5Oi0xIT09W1wiY3Jvc3NlbnRyb3B5XCIsXCJjZVwiXS5pbmRleE9mKG4pJiYoaT1jYXRlZ29yaWNhbENyb3NzZW50cm9weSQxKTt2YXIgcz12b2lkIDA7LTEhPT1bXCJhY2N1cmFjeVwiLFwiYWNjXCJdLmluZGV4T2Yobik/cz1cImFjY1wiOi0xIT09W1wiY3Jvc3NlbnRyb3B5XCIsXCJjZVwiXS5pbmRleE9mKG4pJiYocz1cImNlXCIpLGE9aSxyPVwiXCIrc31lbHNle3ZhciBsPWdldCQxKG4pO2E9bCxyPVwiXCIrbn12YXIgdTtuYW1lU2NvcGUocixmdW5jdGlvbigpe3U9YX0pLGZ1bmN0aW9uKGUsbixyKXt0Lm91dHB1dE5hbWVzLmxlbmd0aD4xJiYobj10Lm91dHB1dE5hbWVzW2VdK1wiX1wiK24pLHQubWV0cmljc05hbWVzLnB1c2gobiksdC5tZXRyaWNzVGVuc29ycy5wdXNoKFtyLGVdKX0oZSxyLHUpfSxzPTAsbD1uO3M8bC5sZW5ndGg7cysrKW8obFtzXSl9KGRbZV0pfSxuPTA7bjx0Lm91dHB1dHMubGVuZ3RoOysrbillKG4pfSksdGhpcy5jb2xsZWN0ZWRUcmFpbmFibGVXZWlnaHRzPXRoaXMudHJhaW5hYmxlV2VpZ2h0c30sdC5wcm90b3R5cGUuY2hlY2tUcmFpbmFibGVXZWlnaHRzQ29uc2lzdGVuY3k9ZnVuY3Rpb24oKXtudWxsIT10aGlzLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHMmJnRoaXMudHJhaW5hYmxlV2VpZ2h0cy5sZW5ndGghPT10aGlzLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHMubGVuZ3RoJiZjb25zb2xlLndhcm4oXCJEaXNjcmVwYW5jeSBiZXR3ZWVuIHRyYWluYWJsZXdlaWdodHMgYW5kIGNvbGxlY3RlZCB0cmFpbmFibGUgd2VpZ2h0cy4gRGlkIHlvdSBzZXQgYG1vZGVsLnRyYWluYWJsZWAgd2l0aG91dCBjYWxsaW5nIGBtb2RlbC5jb21waWxlKClgIGFmdGVyd2FyZHM/XCIpfSx0LnByb3RvdHlwZS5ldmFsdWF0ZT1mdW5jdGlvbihlLHQsbil7dm9pZCAwPT09biYmKG49e30pO3ZhciByPW51bGw9PW4uYmF0Y2hTaXplPzMyOm4uYmF0Y2hTaXplO2NoZWNrQmF0Y2hTaXplKHIpO3ZhciBpPXRoaXMuc3RhbmRhcmRpemVVc2VyRGF0YShlLHQsITAscik7dHJ5e3ZhciBhPWlbMF0uY29uY2F0KGlbMV0pO3RoaXMubWFrZVRlc3RGdW5jdGlvbigpO3ZhciBvPXRoaXMudGVzdEZ1bmN0aW9uO3JldHVybiBzaW5nbGV0b25PckFycmF5KHRoaXMudGVzdExvb3AobyxhLHIsbi52ZXJib3NlLG4uc3RlcHMpKX1maW5hbGx5e2Rpc3Bvc2VOZXdUZW5zb3JzKGlbMF0sZSksZGlzcG9zZU5ld1RlbnNvcnMoaVsxXSx0KX19LHQucHJvdG90eXBlLmV2YWx1YXRlRGF0YXNldD1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7cmV0dXJuIHRoaXMubWFrZVRlc3RGdW5jdGlvbigpLFsyLGV2YWx1YXRlRGF0YXNldCh0aGlzLGUsdCldfSl9KX0sdC5wcm90b3R5cGUuY2hlY2tOdW1TYW1wbGVzPWZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpO2lmKHZvaWQgMD09PXImJihyPVwic3RlcHNcIiksbnVsbCE9bil7aWYoaT1udWxsLG51bGwhPXQpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJZiBcIityK1wiIGlzIHNldCwgYmF0Y2hTaXplIG11c3QgYmUgbnVsbCBvciB1bmRlZmluZWQuR290IGJhdGNoU2l6ZSA9IFwiK3QpfWVsc2V7aWYobnVsbD09ZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkVpdGhlciB0aGUgaW5wdXQgZGF0YSBzaG91bGQgaGF2ZSBhIGRlZmluZWQgc2hhcGUsIG9yIFwiK3IrXCIgc2hvdWQgYmUgc3BlY2lmaWVkLlwiKTtpPUFycmF5LmlzQXJyYXkoZSk/ZVswXS5zaGFwZVswXTplLnNoYXBlWzBdfXJldHVybiBpfSx0LnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGUsdCl7aWYoQXJyYXkuaXNBcnJheSh0KSYmMD09PXQubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiYG91dHB1dHNgIGlzIGFuIGVtcHR5IEFycmF5LCB3aGljaCBpcyBub3QgYWxsb3dlZC5cIik7dmFyIG49QXJyYXkuaXNBcnJheSh0KSxyPW4/dDpbdF0saT10aGlzLnJldHJpZXZlU3ltYm9saWNUZW5zb3JzKHIpLGE9bmV3IEZlZWREaWN0O2lmKGUgaW5zdGFuY2VvZiBUZW5zb3ImJihlPVtlXSksQXJyYXkuaXNBcnJheShlKSl7aWYoZS5sZW5ndGghPT10aGlzLmlucHV0cy5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgbnVtYmVyIG9mIGlucHV0cyBwcm92aWRlZCAoXCIrZS5sZW5ndGgrXCIpIGRvZXMgbm90IG1hdGNoIHRoZSBudW1iZXIgb2YgaW5wdXRzIG9mIHRoaXMgbW9kZWwgKFwiK3RoaXMuaW5wdXRzLmxlbmd0aCtcIikuXCIpO2Zvcih2YXIgbz0wO288dGhpcy5pbnB1dHMubGVuZ3RoOysrbylhLmFkZCh0aGlzLmlucHV0c1tvXSxlW29dKX1lbHNlIGZvcih2YXIgcz0wLGw9dGhpcy5pbnB1dHM7czxsLmxlbmd0aDtzKyspe3ZhciB1PWxbc10sYz1lW3UubmFtZV07aWYobnVsbD09Yyl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIk5vIHZhbHVlIGlzIHByb3ZpZGVkIGZvciB0aGUgbW9kZWwncyBpbnB1dCBcIit1Lm5hbWUpO2EuYWRkKHUsYyl9dmFyIHA9ZXhlY3V0ZShpLGEpO3JldHVybiBuP3A6cFswXX0sdC5wcm90b3R5cGUucmV0cmlldmVTeW1ib2xpY1RlbnNvcnM9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXB5TGlzdFJlcGVhdChudWxsLGUubGVuZ3RoKSxuPWUubGVuZ3RoLHI9MCxpPXRoaXMubGF5ZXJzO3I8aS5sZW5ndGg7cisrKXtmb3IodmFyIGE9aVtyXSxvPUFycmF5LmlzQXJyYXkoYS5vdXRwdXQpP2Eub3V0cHV0OlthLm91dHB1dF0scz1vLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lfSksbD0wO2w8ZS5sZW5ndGg7KytsKXt2YXIgdT1zLmluZGV4T2YoZVtsXSk7aWYoLTEhPT11JiYodFtsXT1vW3VdLG4tLSksMD09PW4pYnJlYWt9aWYoMD09PW4pYnJlYWt9aWYobj4wKXt2YXIgYz1bXTt0aHJvdyB0LmZvckVhY2goZnVuY3Rpb24odCxuKXtudWxsPT10JiZjLnB1c2goZVtuXSl9KSxuZXcgVmFsdWVFcnJvcihcIkNhbm5vdCBmaW5kIFN5bWJvbGljVGVuc29ycyBmb3Igb3V0cHV0IG5hbWUocyk6IFwiK0pTT04uc3RyaW5naWZ5KGMpKX1yZXR1cm4gdH0sdC5wcm90b3R5cGUucHJlZGljdExvb3A9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRoaXM7cmV0dXJuIHZvaWQgMD09PXQmJih0PTMyKSx2b2lkIDA9PT1uJiYobj0hMSksdGlkeShmdW5jdGlvbigpe3ZhciBpPXIuY2hlY2tOdW1TYW1wbGVzKGUpO2lmKG4pdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJWZXJib3NlIHByZWRpY3RMb29wKCkgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7Zm9yKHZhciBhPW1ha2VCYXRjaGVzKGksdCksbz1yLm91dHB1dHMubWFwKGZ1bmN0aW9uKGUpe3JldHVybltdfSkscz1mdW5jdGlvbih0KXt0aWR5KGZ1bmN0aW9uKCl7dmFyIG49YVt0XVswXSxpPWFbdF1bMV0sbz1zbGljZUFycmF5cyhlLG4saSkscz1bXTtpZihBcnJheS5pc0FycmF5KG8pKWZvcih2YXIgbD0wO2w8by5sZW5ndGg7KytsKXMucHVzaCh7a2V5OnIuaW5wdXRzW2xdLHZhbHVlOm9bbF19KTtlbHNlIHMucHVzaCh7a2V5OnIuaW5wdXRzWzBdLHZhbHVlOm99KTt2YXIgdT1uZXcgRmVlZERpY3Qocyk7cmV0dXJuIGV4ZWN1dGUoci5vdXRwdXRzLHUpfSkuZm9yRWFjaChmdW5jdGlvbihlLHQpe3JldHVybiBvW3RdLnB1c2goZSl9KX0sbD0wO2w8YS5sZW5ndGg7KytsKXMobCk7cmV0dXJuIHNpbmdsZXRvbk9yQXJyYXkoby5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGNvbmNhdChlLDApfSkpfSl9LHQucHJvdG90eXBlLnByZWRpY3Q9ZnVuY3Rpb24oZSx0KXt2b2lkIDA9PT10JiYodD17fSk7dmFyIG49ZW5zdXJlVGVuc29yc1JhbmsyT3JIaWdoZXIoZSk7Y2hlY2tJbnB1dERhdGEobix0aGlzLmlucHV0TmFtZXMsdGhpcy5mZWVkSW5wdXRTaGFwZXMsITEpO3RyeXt2YXIgcj1udWxsPT10LmJhdGNoU2l6ZT8zMjp0LmJhdGNoU2l6ZTtyZXR1cm4gY2hlY2tCYXRjaFNpemUociksdGhpcy5wcmVkaWN0TG9vcChuLHIpfWZpbmFsbHl7ZGlzcG9zZU5ld1RlbnNvcnMobixlKX19LHQucHJvdG90eXBlLnByZWRpY3RPbkJhdGNoPWZ1bmN0aW9uKGUpe3JldHVybiBjaGVja0lucHV0RGF0YShlLHRoaXMuaW5wdXROYW1lcyx0aGlzLmZlZWRJbnB1dFNoYXBlcywhMCksdGhpcy5wcmVkaWN0TG9vcChlLGUuc2hhcGVbMF0pfSx0LnByb3RvdHlwZS5zdGFuZGFyZGl6ZVVzZXJEYXRhPWZ1bmN0aW9uKGUsdCxuLHIpe2lmKHZvaWQgMD09PW4mJihuPSEwKSxudWxsPT10aGlzLm9wdGltaXplcl8pdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcIllvdSBtdXN0IGNvbXBpbGUgYSBtb2RlbCBiZWZvcmUgdHJhaW5pbmcvdGVzdGluZy4gVXNlIExheWVyc01vZGVsLmNvbXBpbGUobW9kZWxDb21waWxlQXJncykuXCIpO2Zvcih2YXIgaT1bXSxhPTA7YTx0aGlzLmZlZWRPdXRwdXRTaGFwZXMubGVuZ3RoOysrYSl7dmFyIG89dGhpcy5mZWVkT3V0cHV0U2hhcGVzW2FdO3RoaXMuZmVlZExvc3NGbnNbYV09PT1zcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weT9pLnB1c2goby5zbGljZSgwLG8ubGVuZ3RoLTEpLmNvbmNhdChbMV0pKTppLnB1c2gobyl9aWYoY2hlY2tBcnJheUxlbmd0aHMoZT1zdGFuZGFyZGl6ZUlucHV0RGF0YShlLHRoaXMuZmVlZElucHV0TmFtZXMsdGhpcy5mZWVkSW5wdXRTaGFwZXMsITEsXCJpbnB1dFwiKSx0PXN0YW5kYXJkaXplSW5wdXREYXRhKHQsdGhpcy5mZWVkT3V0cHV0TmFtZXMsaSwhMSxcInRhcmdldFwiKSxudWxsKSxjaGVja0xvc3NBbmRUYXJnZXRDb21wYXRpYmlsaXR5KHQsdGhpcy5mZWVkTG9zc0Zucyx0aGlzLmZlZWRPdXRwdXRTaGFwZXMpLHRoaXMuc3RhdGVmdWwmJm51bGwhPXImJnI+MCYmZVswXS5zaGFwZVswXSVyIT0wKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW4gYSBzdGF0ZWZ1bCBuZXR3b3JrLCB5b3Ugc2hvdWxkIG9ubHkgcGFzcyBpbnB1dHMgd2l0aCBhIG51bWJlciBvZiBzYW1wbGVzIHRoYXQgaXMgZGl2aXNpYmxlIGJ5IHRoZSBiYXRjaCBzaXplIFwiK3IrXCIuIEZvdW5kOiBcIitlWzBdLnNoYXBlWzBdK1wiIHNhbXBsZShzKS5cIik7cmV0dXJuW2UsdCxudWxsXX0sdC5wcm90b3R5cGUudGVzdExvb3A9ZnVuY3Rpb24oZSx0LG4scixpKXt2YXIgYT10aGlzO3JldHVybiB2b2lkIDA9PT1yJiYocj0wKSx0aWR5KGZ1bmN0aW9uKCl7dmFyIG89YS5jaGVja051bVNhbXBsZXModCxuLGksXCJzdGVwc1wiKSxzPVtdO2lmKHI+MCl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlZlcmJvc2UgbW9kZSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtpZihudWxsIT1pKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwic3RlcHMgbW9kZSBpbiB0ZXN0TG9vcCgpIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7Zm9yKHZhciBsPW1ha2VCYXRjaGVzKG8sbiksdT10ZW5zb3IxZChyYW5nZSgwLG8pKSxjPTA7YzxsLmxlbmd0aDsrK2Mpe3ZhciBwPWxbY11bMF0saD1sW2NdWzFdLGQ9c2xpY2VBbG9uZ0ZpcnN0QXhpcyh1LHAsaC1wKSxmPXNsaWNlQXJyYXlzQnlJbmRpY2VzKHQsZCksZz1lKGYpO2lmKDA9PT1jKWZvcih2YXIgbT0wO208Zy5sZW5ndGg7KyttKXMucHVzaChzY2FsYXIoMCkpO2ZvcihtPTA7bTxnLmxlbmd0aDsrK20pe3ZhciB5PWdbbV07c1ttXT1hZGQoc1ttXSxtdWwoaC1wLHkpKX19Zm9yKG09MDttPHMubGVuZ3RoOysrbSlzW21dPWRpdihzW21dLG8pO3JldHVybiBzfSl9LHQucHJvdG90eXBlLmdldERlZHVwZWRNZXRyaWNzTmFtZXM9ZnVuY3Rpb24oKXtmb3IodmFyIGU9dGhpcy5tZXRyaWNzTmFtZXMsdD1bXSxuPTA7bjxlLmxlbmd0aDsrK24pe3ZhciByPWVbbl0saT1yO2lmKGNvdW50KGUscik+MSlpKz1cIl9cIitjb3VudChlLnNsaWNlKDAsbikscik7dC5wdXNoKGkpfXJldHVybiB0fSx0LnByb3RvdHlwZS5tYWtlVHJhaW5GdW5jdGlvbj1mdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBuPXQuc2xpY2UoMCxlLmlucHV0cy5sZW5ndGgpLHI9dC5zbGljZShlLmlucHV0cy5sZW5ndGgsZS5pbnB1dHMubGVuZ3RoK2Uub3V0cHV0cy5sZW5ndGgpLGk9W10sYT1lLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnJlYWQoKX0pO3JldHVybltlLm9wdGltaXplcl8ubWluaW1pemUoZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sYT0wO2E8ZS5pbnB1dHMubGVuZ3RoOysrYSl0LnB1c2goe2tleTplLmlucHV0c1thXSx2YWx1ZTpuW2FdfSk7dmFyIG8scz1uZXcgRmVlZERpY3QodCksbD1leGVjdXRlKGUub3V0cHV0cyxzLHt0cmFpbmluZzohMH0pO2ZvcihhPTA7YTxlLmxvc3NGdW5jdGlvbnMubGVuZ3RoOysrYSl7dmFyIHU9KDAsZS5sb3NzRnVuY3Rpb25zW2FdKShyW2FdLGxbYV0pO21lYW4odSksbz0wPT09YT91OmFkZChvLHUpfWZvcihhPTA7YTxlLm1ldHJpY3NUZW5zb3JzLmxlbmd0aDsrK2Epe3ZhciBjPWUubWV0cmljc1RlbnNvcnNbYV1bMF0scD1lLm1ldHJpY3NUZW5zb3JzW2FdWzFdLGg9bWVhbihjKHJbcF0sbFtwXSkpO2tlZXAoaCksaS5wdXNoKGgpfXJldHVybiBvPW1lYW4obyksZS5jYWxjdWxhdGVMb3NzZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe289YWRkKG8sZSl9KSxvfSwhMCxhKV0uY29uY2F0KGkpfX0sdC5wcm90b3R5cGUubWFrZVRlc3RGdW5jdGlvbj1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy50ZXN0RnVuY3Rpb249ZnVuY3Rpb24odCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtmb3IodmFyIG4scj1bXSxpPXQuc2xpY2UoMCxlLmlucHV0cy5sZW5ndGgpLGE9dC5zbGljZShlLmlucHV0cy5sZW5ndGgsZS5pbnB1dHMubGVuZ3RoK2Uub3V0cHV0cy5sZW5ndGgpLG89W10scz0wO3M8ZS5pbnB1dHMubGVuZ3RoOysrcylvLnB1c2goe2tleTplLmlucHV0c1tzXSx2YWx1ZTppW3NdfSk7dmFyIGw9bmV3IEZlZWREaWN0KG8pLHU9ZXhlY3V0ZShlLm91dHB1dHMsbCk7Zm9yKHM9MDtzPGUubG9zc0Z1bmN0aW9ucy5sZW5ndGg7KytzKXt2YXIgYz1lLmxvc3NGdW5jdGlvbnNbc10scD1tZWFuKGMoYVtzXSx1W3NdKSk7bj0wPT09cz9wOmFkZChuLHApLHIucHVzaChuKX1mb3Iocz0wO3M8ZS5tZXRyaWNzVGVuc29ycy5sZW5ndGg7KytzKXt2YXIgaD1lLm1ldHJpY3NUZW5zb3JzW3NdWzBdLGQ9ZS5tZXRyaWNzVGVuc29yc1tzXVsxXSxmPW1lYW4oaChhW2RdLHVbZF0pKTtyLnB1c2goZil9cmV0dXJuIHJ9KX19LHQucHJvdG90eXBlLmZpdD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPXt9KSxfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7cmV0dXJuWzIsZml0VGVuc29ycyh0aGlzLGUsdCxuKV19KX0pfSx0LnByb3RvdHlwZS5maXREYXRhc2V0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihuKXtyZXR1cm5bMixmaXREYXRhc2V0KHRoaXMsZSx0KV19KX0pfSx0LnByb3RvdHlwZS50cmFpbk9uQmF0Y2g9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBuLHIsaSxhLG8scyxsLHUsYztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihwKXtzd2l0Y2gocC5sYWJlbCl7Y2FzZSAwOm49dGhpcy5zdGFuZGFyZGl6ZVVzZXJEYXRhKGUsdCkscj1uWzBdLGk9blsxXSxhPXRoaXMubWFrZVRyYWluRnVuY3Rpb24oKSxvPWEoci5jb25jYXQoaSkpLHM9W10sbD0wLHU9byxwLmxhYmVsPTE7Y2FzZSAxOnJldHVybiBsPHUubGVuZ3RoP1s0LHVbbF0uZGF0YSgpXTpbMyw0XTtjYXNlIDI6Yz1wLnNlbnQoKSxzLnB1c2goY1swXSkscC5sYWJlbD0zO2Nhc2UgMzpyZXR1cm4gbCsrLFszLDFdO2Nhc2UgNDpyZXR1cm4gZGlzcG9zZShvKSxbMixzaW5nbGV0b25PckFycmF5KHMpXX19KX0pfSx0LnByb3RvdHlwZS5nZXROYW1lZFdlaWdodHM9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXt9LG49bnVsbCE9ZSYmZS50cmFpbmFibGVPbmx5LHI9bj90aGlzLnRyYWluYWJsZVdlaWdodHM6dGhpcy53ZWlnaHRzLGk9dGhpcy5nZXRXZWlnaHRzKG4pLGE9MDthPHIubGVuZ3RoOysrYSluJiYhclthXS50cmFpbmFibGV8fCh0W3JbYV0ub3JpZ2luYWxOYW1lXT1pW2FdKTtyZXR1cm4gdH0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwic3RvcFRyYWluaW5nXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0b3BUcmFpbmluZ199LHNldDpmdW5jdGlvbihlKXt0aGlzLnN0b3BUcmFpbmluZ189ZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJvcHRpbWl6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW1pemVyX30sc2V0OmZ1bmN0aW9uKGUpe3RoaXMub3B0aW1pemVyXyE9PWUmJih0aGlzLm9wdGltaXplcl89ZSx0aGlzLmlzT3B0aW1pemVyT3duZWQ9ITEpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt2YXIgdD1lLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7aWYoMD09PXQucmVmQ291bnRBZnRlckRpc3Bvc2UmJm51bGwhPXRoaXMub3B0aW1pemVyJiZ0aGlzLmlzT3B0aW1pemVyT3duZWQpe3ZhciBuPW1lbW9yeSgpLm51bVRlbnNvcnM7dGhpcy5vcHRpbWl6ZXJfLmRpc3Bvc2UoKSx0Lm51bURpc3Bvc2VkVmFyaWFibGVzKz1uLW1lbW9yeSgpLm51bVRlbnNvcnN9cmV0dXJuIHR9LHQucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBuLHIsaSxhLG87cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocyl7c3dpdGNoKHMubGFiZWwpe2Nhc2UgMDppZihcInN0cmluZ1wiPT10eXBlb2YgZSl7aWYoMD09PShuPWlvLmdldFNhdmVIYW5kbGVycyhlKSkubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ2Fubm90IGZpbmQgYW55IHNhdmUgaGFuZGxlcnMgZm9yIFVSTCAnXCIrZStcIidcIik7aWYobi5sZW5ndGg+MSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkZvdW5kIG1vcmUgdGhhbiBvbmUgKFwiK24ubGVuZ3RoK1wiKSBzYXZlIGhhbmRsZXJzIGZvciBVUkwgJ1wiK2UrXCInXCIpO2U9blswXX1pZihudWxsPT1lLnNhdmUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJMYXllcnNNb2RlbC5zYXZlKCkgY2Fubm90IHByb2NlZWQgYmVjYXVzZSB0aGUgSU9IYW5kbGVyIHByb3ZpZGVkIGRvZXMgbm90IGhhdmUgdGhlIGBzYXZlYCBhdHRyaWJ1dGUgZGVmaW5lZC5cIik7cmV0dXJuWzQsaW8uZW5jb2RlV2VpZ2h0cyh0aGlzLmdldE5hbWVkV2VpZ2h0cyh0KSldO2Nhc2UgMTpyZXR1cm4gcj1zLnNlbnQoKSxpPSExLGE9bnVsbCxvPXRoaXMudG9KU09OKGEsaSksWzIsZS5zYXZlKHttb2RlbFRvcG9sb2d5Om8sd2VpZ2h0RGF0YTpyLmRhdGEsd2VpZ2h0U3BlY3M6ci5zcGVjcyxmb3JtYXQ6TEFZRVJTX01PREVMX0ZPUk1BVF9OQU1FLGdlbmVyYXRlZEJ5OlwiVGVuc29yRmxvdy5qcyB0ZmpzLWxheWVycyB2XCIrdmVyc2lvbixjb252ZXJ0ZWRCeTpudWxsfSldfX0pfSl9LHQuY2xhc3NOYW1lPVwiTW9kZWxcIix0fShDb250YWluZXIpO2Z1bmN0aW9uIG1vZGVsRnJvbUpTT04oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBuLHIsaSxhLG8scyxsLHU7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oYyl7c3dpdGNoKGMubGFiZWwpe2Nhc2UgMDpyZXR1cm5cIm1vZGVsVG9wb2xvZ3lcImluIGV8fChlPXttb2RlbFRvcG9sb2d5OmV9KSxudWxsIT0obj0oZT1lKS5tb2RlbFRvcG9sb2d5KS5tb2RlbF9jb25maWcmJihuPW4ubW9kZWxfY29uZmlnKSxyPWNvbnZlcnRQeXRob25pY1RvVHMobiksaT1kZXNlcmlhbGl6ZShyLHQpLG51bGw9PWUud2VpZ2h0c01hbmlmZXN0P1szLDJdOls0LGlvLmxvYWRXZWlnaHRzKGUud2VpZ2h0c01hbmlmZXN0LGUucGF0aFByZWZpeCxpLndlaWdodHMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLm9yaWdpbmFsTmFtZX0pKV07Y2FzZSAxOmZvcihhPWMuc2VudCgpLG89e30scz0wLGw9aS53ZWlnaHRzO3M8bC5sZW5ndGg7cysrKXU9bFtzXSxvW3Uub3JpZ2luYWxOYW1lXT1hW3Uub3JpZ2luYWxOYW1lXTtpLmxvYWRXZWlnaHRzKG8pLGRpc3Bvc2UoYSksYy5sYWJlbD0yO2Nhc2UgMjpyZXR1cm5bMixpXX19KX0pfWZ1bmN0aW9uIGxvYWRMYXllcnNNb2RlbEludGVybmFsKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtpZihudWxsPT10JiYodD17fSksXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKDA9PT0obj1pby5nZXRMb2FkSGFuZGxlcnMoZSkpLmxlbmd0aCluLnB1c2goaW8uYnJvd3NlckhUVFBSZXF1ZXN0KGUsdCkpO2Vsc2UgaWYobi5sZW5ndGg+MSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkZvdW5kIG1vcmUgdGhhbiBvbmUgKFwiK24ubGVuZ3RoK1wiKSBsb2FkIGhhbmRsZXJzIGZvciBVUkwgJ1wiK2UrXCInXCIpO2U9blswXX1yZXR1cm5bMixsb2FkTGF5ZXJzTW9kZWxGcm9tSU9IYW5kbGVyKGUsdm9pZCAwLHQpXX0pfSl9ZnVuY3Rpb24gbG9hZExheWVyc01vZGVsRnJvbUlPSGFuZGxlcihlLHQsbil7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgcixpLGEsbyxzLGw7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odSl7c3dpdGNoKHUubGFiZWwpe2Nhc2UgMDppZihudWxsPT1uJiYobj17fSksbnVsbD09ZS5sb2FkKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ2Fubm90IHByb2NlZWQgd2l0aCBtb2RlbCBsb2FkaW5nIGJlY2F1c2UgdGhlIElPSGFuZGxlciBwcm92aWRlZCBkb2VzIG5vdCBoYXZlIHRoZSBgbG9hZGAgbWV0aG9kIGltcGxlbWVudGVkLlwiKTtyZXR1cm5bNCxlLmxvYWQoKV07Y2FzZSAxOmlmKHI9dS5zZW50KCksbnVsbCE9KGk9ci5tb2RlbFRvcG9sb2d5KS5tb2RlbF9jb25maWcmJihpPWkubW9kZWxfY29uZmlnKSxhPW51bGw9PW4uc3RyaWN0fHxuLnN0cmljdCxvPW51bGwhPXIud2VpZ2h0RGF0YSYmbnVsbCE9ci53ZWlnaHRTcGVjcyYmYSxzPWRlc2VyaWFsaXplKGNvbnZlcnRQeXRob25pY1RvVHMoaSksdCxvKSxudWxsIT1yLndlaWdodERhdGEpe2lmKG51bGw9PXIud2VpZ2h0U3BlY3MpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJMYXllcnNNb2RlbCBhcnRpZmFjdHMgY29udGFpbnMgd2VpZ2h0IGRhdGEsIGJ1dCBub3Qgd2VpZ2h0IHNwZWNzLiBUaGVyZWZvcmUgbG9hZGluZyBvZiB3ZWlnaHRzIGNhbm5vdCBwcm9jZWVkLlwiKTtsPWlvLmRlY29kZVdlaWdodHMoci53ZWlnaHREYXRhLHIud2VpZ2h0U3BlY3MpLHMubG9hZFdlaWdodHMobCxhKSxkaXNwb3NlKGwpfXJldHVyblsyLHNdfX0pfSl9c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKExheWVyc01vZGVsKTt2YXIgU2VxdWVudGlhbD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHtpbnB1dHM6W10sb3V0cHV0czpbXX0pfHx0aGlzO2lmKHQ9dHx8e30sbi50cmFpbmFibGU9ITAsbi5fdXBkYXRhYmxlPSEwLG4uYnVpbHQ9ITEsbi5uYW1lPW51bGwhPXQubmFtZT90Lm5hbWU6Z2V0VWlkKFwic2VxdWVudGlhbF9cIiksbnVsbCE9dC5sYXllcnMpZm9yKHZhciByPTAsaT10LmxheWVycztyPGkubGVuZ3RoO3IrKyl7dmFyIGE9aVtyXTtuLmFkZChhKX1yZXR1cm4gbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY2hlY2tTaGFwZT1mdW5jdGlvbihlKXtpZihlLmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzWzBdLnNoYXBlLnNvbWUoZnVuY3Rpb24oZSl7cmV0dXJuIGU8MH0pKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTmVnYXRpdmUgZGltZW5zaW9uIHNpemUgY2F1c2VkIGJ5IGFkZGluZyBsYXllciBcIitlLm5hbWUrXCIgd2l0aCBpbnB1dCBzaGFwZSBbXCIrZS5pbmJvdW5kTm9kZXNbMF0uaW5wdXRUZW5zb3JzWzBdLnNoYXBlK1wiXVwiKX0sdC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGUpe3ZhciBuLHI9ZSBpbnN0YW5jZW9mIHR8fGUgaW5zdGFuY2VvZiBMYXllcnNNb2RlbDtpZihyKXtpZigxIT09KG49ZSkub3V0cHV0cy5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBbGwgbGF5ZXJzIGluIGEgU2VxdWVudGlhbCBtb2RlbCBzaG91bGQgaGF2ZSBhIHNpbmdsZSBvdXRwdXQgdGVuc29yLiBGb3IgbXVsdGktb3V0cHV0IGxheWVycywgdXNlIHRoZSBmdW5jdGlvbmFsIEFQSS5cIik7aWYoMSE9PW4uaW5wdXRzLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkFsbCBsYXllcnMgaW4gYSBTZXF1ZW50aWFsIG1vZGVsIHNob3VsZCBoYXZlIGEgc2luZ2xlIGlucHV0IHRlbnNvci4gRm9yIG11bHRpLWlucHV0IGxheWVycywgdXNlIHRoZSBmdW5jdGlvbmFsIEFQSS5cIil9aWYoMD09PXRoaXMub3V0cHV0cy5sZW5ndGgpe2lmKDA9PT1lLmluYm91bmROb2Rlcy5sZW5ndGgpe2lmKG51bGw9PWUuYmF0Y2hJbnB1dFNoYXBlKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGZpcnN0IGxheWVyIGluIGEgU2VxdWVudGlhbCBtb2RlbCBtdXN0IGdldCBhbiBgaW5wdXRTaGFwZWAgb3IgYGJhdGNoSW5wdXRTaGFwZWAgYXJndW1lbnQuXCIpO3ZhciBpPUlucHV0KHtiYXRjaFNoYXBlOmUuYmF0Y2hJbnB1dFNoYXBlLGR0eXBlOmUuZHR5cGUsbmFtZTplLm5hbWUrXCJfaW5wdXRcIn0pO2UuYXBwbHkoaSl9aWYocil0aGlzLm91dHB1dHM9bi5vdXRwdXRzLHRoaXMuaW5wdXRzPW4uaW5wdXRzO2Vsc2V7aWYoMSE9PWUuaW5ib3VuZE5vZGVzLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkEgbGF5ZXIgYWRkZWQgdG8gYSBTZXF1ZW50aWFsIG1vZGVsIG11c3Qgbm90IGFscmVhZHkgYmUgY29ubmVjdGVkIHNvbWV3aGVyZSBlbHNlLiBMYXllcnNNb2RlbCByZWNlaXZlZCBsYXllciBcIitlLm5hbWUrXCIgd2hpY2ggaGFzIFwiK2UuaW5ib3VuZE5vZGVzLmxlbmd0aCtcIiBwcmUtZXhpc3RpbmcgaW5ib3VuZCBjb25uZWN0aW9ucy5cIik7aWYoMSE9PWUuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFRlbnNvcnMubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQWxsIGxheWVycyBpbiBhIFNlcXVlbnRpYWwgbW9kZWwgc2hvdWxkIGhhdmUgYSBzaW5nbGUgb3V0cHV0IHRlbnNvci4gRm9yIG11bHRpLW91dHB1dCBsYXllcnMsIHVzZSB0aGUgZnVuY3Rpb25hbCBBUEkuXCIpO3RoaXMuY2hlY2tTaGFwZShlKSx0aGlzLm91dHB1dHM9W2UuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFRlbnNvcnNbMF1dLHRoaXMuaW5wdXRzPWdldFNvdXJjZUlucHV0cyh0aGlzLm91dHB1dHNbMF0pfXRoaXMuaW5ib3VuZE5vZGVzPVtdLG5ldyBOb2RlKHtvdXRib3VuZExheWVyOnRoaXMsaW5ib3VuZExheWVyczpbXSxub2RlSW5kaWNlczpbXSx0ZW5zb3JJbmRpY2VzOltdLGlucHV0VGVuc29yczp0aGlzLmlucHV0cyxvdXRwdXRUZW5zb3JzOnRoaXMub3V0cHV0cyxpbnB1dE1hc2tzOnB5TGlzdFJlcGVhdChudWxsLHRoaXMuaW5wdXRzLmxlbmd0aCksb3V0cHV0TWFza3M6W251bGxdLGlucHV0U2hhcGVzOnRoaXMuaW5wdXRzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5zaGFwZX0pLG91dHB1dFNoYXBlczp0aGlzLm91dHB1dHNbMF0uc2hhcGV9KX1lbHNle3ZhciBhPWUuYXBwbHkodGhpcy5vdXRwdXRzWzBdKTtpZihBcnJheS5pc0FycmF5KGEpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBbGwgbGF5ZXJzIGluIGEgU2VxdWVudGlhbCBtb2RlbCBzaG91bGQgaGF2ZSBhIHNpbmdsZSBvdXRwdXQgdGVuc29yLiBGb3IgbXVsdGktb3V0cHV0IGxheWVycywgdXNlIHRoZSBmdW5jdGlvbmFsIEFQSS5cIik7dGhpcy5jaGVja1NoYXBlKGUpLHRoaXMub3V0cHV0cz1bYV0sdGhpcy5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0VGVuc29ycz10aGlzLm91dHB1dHMsdGhpcy5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0U2hhcGVzPVt0aGlzLm91dHB1dHNbMF0uc2hhcGVdfXRoaXMubGF5ZXJzLnB1c2goZSksdGhpcy5idWlsdD0hMX0sdC5wcm90b3R5cGUucG9wPWZ1bmN0aW9uKCl7aWYoMD09PXRoaXMubGF5ZXJzLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlcmUgYXJlIG5vIGxheWVycyBpbiB0aGUgbW9kZWwuXCIpO2lmKHRoaXMubGF5ZXJzLnBvcCgpLDA9PT10aGlzLmxheWVycy5sZW5ndGgpdGhpcy5vdXRwdXRzPVtdLHRoaXMuaW5ib3VuZE5vZGVzPVtdLHRoaXMub3V0Ym91bmROb2Rlcz1bXTtlbHNle3ZhciBlPXRoaXMubGF5ZXJzLmxlbmd0aC0xO3RoaXMubGF5ZXJzW2VdLm91dGJvdW5kTm9kZXM9W10sdGhpcy5vdXRwdXRzPVt0aGlzLmxheWVyc1tlXS5vdXRwdXRdLHRoaXMuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFRlbnNvcnM9dGhpcy5vdXRwdXRzLHRoaXMuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFNoYXBlcz1bdGhpcy5vdXRwdXRzWzBdLnNoYXBlXX19LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbnVsbD09dGhpcy5tb2RlbCYmdGhpcy5idWlsZCgpLHRoaXMubW9kZWwuY2FsbChlLHQpfSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXtpZihnZXRFeGFjdGx5T25lU2hhcGUoZSksMD09PXRoaXMuaW5wdXRzLmxlbmd0aHx8MD09PXRoaXMub3V0cHV0cy5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlNlcXVlbnRpYWwgbW9kZWwgY2Fubm90IGJlIGJ1aWx0OiBtb2RlbCBpcyBlbXB0eS4gQWRkIHNvbWUgbGF5ZXJzIGZpcnN0LlwiKTt0aGlzLm1vZGVsPW5ldyBMYXllcnNNb2RlbCh7aW5wdXRzOnRoaXMuaW5wdXRzLG91dHB1dHM6dGhpcy5vdXRwdXRzWzBdLG5hbWU6dGhpcy5uYW1lK1wiX21vZGVsXCJ9KSx0aGlzLm1vZGVsLnRyYWluYWJsZT10aGlzLnRyYWluYWJsZSx0aGlzLm1vZGVsLnVwZGF0YWJsZT10aGlzLnVwZGF0YWJsZSx0aGlzLnN1cHBvcnRzTWFza2luZz10aGlzLm1vZGVsLnN1cHBvcnRzTWFza2luZyx0aGlzLmlucHV0TGF5ZXJzPXRoaXMubW9kZWwuaW5wdXRMYXllcnMsdGhpcy5pbnB1dExheWVyc05vZGVJbmRpY2VzPXRoaXMubW9kZWwuaW5wdXRMYXllcnNOb2RlSW5kaWNlcyx0aGlzLmlucHV0TGF5ZXJzVGVuc29ySW5kaWNlcz10aGlzLm1vZGVsLmlucHV0TGF5ZXJzVGVuc29ySW5kaWNlcyx0aGlzLm91dHB1dExheWVycz10aGlzLm1vZGVsLm91dHB1dExheWVycyx0aGlzLm91dHB1dExheWVyc05vZGVJbmRpY2VzPXRoaXMubW9kZWwub3V0cHV0TGF5ZXJzTm9kZUluZGljZXMsdGhpcy5vdXRwdXRMYXllcnNUZW5zb3JJbmRpY2VzPXRoaXMubW9kZWwub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlcyx0aGlzLm5vZGVzQnlEZXB0aD10aGlzLm1vZGVsLm5vZGVzQnlEZXB0aCx0aGlzLmNvbnRhaW5lck5vZGVzPXRoaXMubW9kZWwuY29udGFpbmVyTm9kZXMsdGhpcy5vdXRwdXROYW1lcz10aGlzLm1vZGVsLm91dHB1dE5hbWVzLHRoaXMuaW5wdXROYW1lcz10aGlzLm1vZGVsLmlucHV0TmFtZXMsdGhpcy5idWlsdD0hMH0sdC5wcm90b3R5cGUuY291bnRQYXJhbXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5idWlsdHx8dGhpcy5idWlsZCgpLGUucHJvdG90eXBlLmNvdW50UGFyYW1zLmNhbGwodGhpcyl9LHQucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24odCxuLHIpe3ZvaWQgMD09PXImJihyPWNvbnNvbGUubG9nKSx0aGlzLmJ1aWx0fHx0aGlzLmJ1aWxkKCksZS5wcm90b3R5cGUuc3VtbWFyeS5jYWxsKHRoaXMsdCxuLHIpfSx0LnByb3RvdHlwZS5zZXRXZWlnaHRzPWZ1bmN0aW9uKGUpe251bGw9PXRoaXMubW9kZWwmJnRoaXMuYnVpbGQoKSx0aGlzLm1vZGVsLnNldFdlaWdodHMoZSl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInVwZGF0YWJsZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdXBkYXRhYmxlfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5idWlsdCYmKHRoaXMubW9kZWwudXBkYXRhYmxlPWUpLHRoaXMuX3VwZGF0YWJsZT1lfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmV2YWx1YXRlPWZ1bmN0aW9uKGUsdCxuKXtpZih2b2lkIDA9PT1uJiYobj17fSksIXRoaXMuYnVpbHQpdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcIlRoZSBtb2RlbCBuZWVkcyB0byBiZSBjb21waWxlZCBiZWZvcmUgYmVpbmcgdXNlZC5cIik7cmV0dXJuIHRoaXMubW9kZWwuZXZhbHVhdGUoZSx0LG4pfSx0LnByb3RvdHlwZS5ldmFsdWF0ZURhdGFzZXQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe2lmKCF0aGlzLmJ1aWx0KXRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJUaGUgbW9kZWwgbmVlZHMgdG8gYmUgY29tcGlsZWQgYmVmb3JlIGJlaW5nIHVzZWQuXCIpO3JldHVyblsyLHRoaXMubW9kZWwuZXZhbHVhdGVEYXRhc2V0KGUsdCldfSl9KX0sdC5wcm90b3R5cGUucHJlZGljdD1mdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD17fSksbnVsbD09dGhpcy5tb2RlbCYmdGhpcy5idWlsZCgpLHRoaXMubW9kZWwucHJlZGljdChlLHQpfSx0LnByb3RvdHlwZS5wcmVkaWN0T25CYXRjaD1mdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09dGhpcy5tb2RlbCYmdGhpcy5idWlsZCgpLHRoaXMubW9kZWwucHJlZGljdE9uQmF0Y2goZSl9LHQucHJvdG90eXBlLmNvbXBpbGU9ZnVuY3Rpb24oZSl7dGhpcy5idWlsZCgpLHRoaXMubW9kZWwuY29tcGlsZShlKSx0aGlzLm9wdGltaXplcl89dGhpcy5tb2RlbC5vcHRpbWl6ZXIsdGhpcy5pc09wdGltaXplck93bmVkPXRoaXMubW9kZWwuaXNPcHRpbWl6ZXJPd25lZCx0aGlzLmxvc3M9dGhpcy5tb2RlbC5sb3NzLHRoaXMubWV0cmljcz10aGlzLm1vZGVsLm1ldHJpY3MsdGhpcy5tZXRyaWNzVGVuc29ycz10aGlzLm1vZGVsLm1ldHJpY3NUZW5zb3JzLHRoaXMubWV0cmljc05hbWVzPXRoaXMubW9kZWwubWV0cmljc05hbWVzfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJvcHRpbWl6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubW9kZWwub3B0aW1pemVyfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5tb2RlbC5vcHRpbWl6ZXI9ZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5maXQ9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj17fSksX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe2lmKCF0aGlzLmJ1aWx0KXRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJUaGUgbW9kZWwgbmVlZHMgdG8gYmUgY29tcGlsZWQgYmVmb3JlIGJlaW5nIHVzZWQuXCIpO3JldHVyblsyLHRoaXMubW9kZWwuZml0KGUsdCxuKV19KX0pfSx0LnByb3RvdHlwZS5maXREYXRhc2V0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihuKXtpZighdGhpcy5idWlsdCl0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiVGhlIG1vZGVsIG5lZWRzIHRvIGJlIGNvbXBpbGVkIGJlZm9yZSBiZWluZyB1c2VkLlwiKTtyZXR1cm5bMix0aGlzLm1vZGVsLmZpdERhdGFzZXQoZSx0KV19KX0pfSx0LnByb3RvdHlwZS50cmFpbk9uQmF0Y2g9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3JldHVyblsyLHRoaXMubW9kZWwudHJhaW5PbkJhdGNoKGUsdCldfSl9KX0sdC5mcm9tQ29uZmlnPWZ1bmN0aW9uKGUsbixyLGkpe3ZhciBhO3ZvaWQgMD09PXImJihyPXt9KSx2b2lkIDA9PT1pJiYoaT0hMSk7dmFyIG89e307aWYobiBpbnN0YW5jZW9mIEFycmF5KXtpZihudWxsPT1uWzBdLmNsYXNzTmFtZXx8XCJNZXJnZVwiPT09blswXS5jbGFzc05hbWUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJMZWdhY3kgc2VyaWFsaXphdGlvbiBmb3JtYXQgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO2E9bn1lbHNlIHV0aWwuYXNzZXJ0KG51bGwhPW4ubGF5ZXJzLGZ1bmN0aW9uKCl7cmV0dXJuXCJXaGVuIHRoZSBjb25maWcgZGF0YSBmb3IgYSBTZXF1ZW50aWFsIG1vZGVsIGlzIG5vdCBhbiBBcnJheSwgaXQgbXVzdCBiZSBhbiBPYmplY3QgdGhhdCBjb250YWlucyB0aGUgJ2xheWVycycgZmllbGQuXCJ9KSxhPW4ubGF5ZXJzLGRlbGV0ZSBuLmxheWVycyxvPW47dmFyIHM9bmV3IGUobyk7aWYoIShzIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJTZXF1ZW50aWFsLmZyb21Db25maWcgY2FsbGVkIG9uIG5vbi1TZXF1ZW50aWFsIGlucHV0OiBcIitzKTtmb3IodmFyIGw9MCx1PWE7bDx1Lmxlbmd0aDtsKyspe3ZhciBjPWRlc2VyaWFsaXplKHVbbF0sdm9pZCAwLGkpO2kmJmMuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZCghMCkscy5hZGQoYyl9cmV0dXJuIHN9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInN0b3BUcmFpbmluZ1wiLHtnZXQ6ZnVuY3Rpb24oKXtpZihudWxsPT10aGlzLm1vZGVsKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ2Fubm90IGdldCB0aGUgc3RvcFRyYWluaW5nIHByb3BlcnR5IG9mIGEgc2VxdWVudGlhbCBtb2RlbCBiZWZvcmUgaXQgaXMgY29tcGlsZWQuXCIpO3JldHVybiB0aGlzLm1vZGVsLnN0b3BUcmFpbmluZ30sc2V0OmZ1bmN0aW9uKGUpe2lmKG51bGw9PXRoaXMubW9kZWwpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDYW5ub3Qgc2V0IHRoZSBzdG9wVHJhaW5pbmcgcHJvcGVydHkgb2YgYSBzZXF1ZW50aWFsIG1vZGVsIGJlZm9yZSBpdCBpcyBjb21waWxlZC5cIik7dGhpcy5tb2RlbC5zdG9wVHJhaW5pbmc9ZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wLG49dGhpcy5sYXllcnM7dDxuLmxlbmd0aDt0Kyspe3ZhciByPW5bdF0saT17fTtpLmNsYXNzTmFtZT1yLmdldENsYXNzTmFtZSgpLGkuY29uZmlnPXIuZ2V0Q29uZmlnKCksZS5wdXNoKGkpfXJldHVybiBlfSx0LmNsYXNzTmFtZT1cIlNlcXVlbnRpYWxcIix0fShMYXllcnNNb2RlbCk7ZnVuY3Rpb24gbW9kZWwoZSl7cmV0dXJuIG5ldyBMYXllcnNNb2RlbChlKX1mdW5jdGlvbiBzZXF1ZW50aWFsKGUpe3JldHVybiBuZXcgU2VxdWVudGlhbChlKX1mdW5jdGlvbiBsb2FkTGF5ZXJzTW9kZWwoZSx0KXtyZXR1cm4gbnVsbD09dCYmKHQ9e30pLGxvYWRMYXllcnNNb2RlbEludGVybmFsKGUsdCl9ZnVuY3Rpb24gaW5wdXQoZSl7cmV0dXJuIElucHV0KGUpfWZ1bmN0aW9uIHJlZ2lzdGVyQ2FsbGJhY2tDb25zdHJ1Y3RvcihlLHQpe0NhbGxiYWNrQ29uc3RydWN0b3JSZWdpc3RyeS5yZWdpc3RlckNhbGxiYWNrQ29uc3RydWN0b3IoZSx0KX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoU2VxdWVudGlhbCk7dmFyIEFjdGl2YXRpb249ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybnt9fSx0fShzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZSksRWx1PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0xKSxlbHUkMShlLHQpfSx0LmNsYXNzTmFtZT1cImVsdVwiLHR9KEFjdGl2YXRpb24pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhFbHUpO3ZhciBTZWx1PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlKXtyZXR1cm4gc2VsdShlKX0sdC5jbGFzc05hbWU9XCJzZWx1XCIsdH0oQWN0aXZhdGlvbik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFNlbHUpO3ZhciBSZWx1PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlKXtyZXR1cm4gcmVsdShlKX0sdC5jbGFzc05hbWU9XCJyZWx1XCIsdH0oQWN0aXZhdGlvbik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFJlbHUpO3ZhciBSZWx1Nj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gbWluaW11bSg2LHJlbHUoZSkpfSl9LHQuY2xhc3NOYW1lPVwicmVsdTZcIix0fShBY3RpdmF0aW9uKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoUmVsdTYpO3ZhciBMaW5lYXI9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUpe3JldHVybiBlfSx0LmNsYXNzTmFtZT1cImxpbmVhclwiLHR9KEFjdGl2YXRpb24pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhMaW5lYXIpO3ZhciBTaWdtb2lkPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlKXtyZXR1cm4gc2lnbW9pZChlKX0sdC5jbGFzc05hbWU9XCJzaWdtb2lkXCIsdH0oQWN0aXZhdGlvbik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFNpZ21vaWQpO3ZhciBIYXJkU2lnbW9pZD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSl7cmV0dXJuIGhhcmRTaWdtb2lkKGUpfSx0LmNsYXNzTmFtZT1cImhhcmRTaWdtb2lkXCIsdH0oQWN0aXZhdGlvbik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEhhcmRTaWdtb2lkKTt2YXIgU29mdHBsdXM9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUpe3JldHVybiBzb2Z0cGx1cyhlKX0sdC5jbGFzc05hbWU9XCJzb2Z0cGx1c1wiLHR9KEFjdGl2YXRpb24pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTb2Z0cGx1cyk7dmFyIFNvZnRzaWduPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlKXtyZXR1cm4gc29mdHNpZ24oZSl9LHQuY2xhc3NOYW1lPVwic29mdHNpZ25cIix0fShBY3RpdmF0aW9uKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoU29mdHNpZ24pO3ZhciBUYW5oPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlKXtyZXR1cm4gdGFuaChlKX0sdC5jbGFzc05hbWU9XCJ0YW5oXCIsdH0oQWN0aXZhdGlvbik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFRhbmgpO3ZhciBTb2Z0bWF4PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0tMSksc29mdG1heChlLHQpfSx0LmNsYXNzTmFtZT1cInNvZnRtYXhcIix0fShBY3RpdmF0aW9uKTtmdW5jdGlvbiBzZXJpYWxpemVBY3RpdmF0aW9uKGUpe3JldHVybiBlLmdldENsYXNzTmFtZSgpfWZ1bmN0aW9uIGRlc2VyaWFsaXplQWN0aXZhdGlvbihlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD17fSksZGVzZXJpYWxpemVLZXJhc09iamVjdChlLHNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5nZXRNYXAoKS5jbGFzc05hbWVNYXAsdCxcImFjdGl2YXRpb25cIil9ZnVuY3Rpb24gZ2V0QWN0aXZhdGlvbihlKXt2YXIgdDtyZXR1cm4gbnVsbD09ZT9kZXNlcmlhbGl6ZUFjdGl2YXRpb24odD17Y2xhc3NOYW1lOlwibGluZWFyXCIsY29uZmlnOnt9fSk6XCJzdHJpbmdcIj09dHlwZW9mIGU/KCh0PXt9KS5jbGFzc05hbWU9ZSx0LmNvbmZpZz17fSxkZXNlcmlhbGl6ZUFjdGl2YXRpb24odCkpOmUgaW5zdGFuY2VvZiBBY3RpdmF0aW9uP2U6ZGVzZXJpYWxpemVBY3RpdmF0aW9uKGUpfXNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTb2Z0bWF4KTt2YXIgUmVndWxhcml6ZXI9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHR9KHNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlKSxMMUwyPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLmwxPW51bGw9PXR8fG51bGw9PXQubDE/LjAxOnQubDEsbi5sMj1udWxsPT10fHxudWxsPT10LmwyPy4wMTp0LmwyLG4uaGFzTDE9MCE9PW4ubDEsbi5oYXNMMj0wIT09bi5sMixufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49emVyb3MoWzFdKTtyZXR1cm4gdC5oYXNMMSYmKG49YWRkKG4sc3VtKG11bCh0LmwxLGFicyhlKSkpKSksdC5oYXNMMiYmKG49YWRkKG4sc3VtKG11bCh0LmwyLHNxdWFyZShlKSkpKSksbi5hc1NjYWxhcigpfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntsMTp0aGlzLmwxLGwyOnRoaXMubDJ9fSx0LmZyb21Db25maWc9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IGUoe2wxOnQubDEsbDI6dC5sMn0pfSx0LmNsYXNzTmFtZT1cIkwxTDJcIix0fShSZWd1bGFyaXplcik7ZnVuY3Rpb24gbDEoZSl7cmV0dXJuIG5ldyBMMUwyKHtsMTpudWxsIT1lP2UubDE6bnVsbCxsMjowfSl9ZnVuY3Rpb24gbDIoZSl7cmV0dXJuIG5ldyBMMUwyKHtsMjpudWxsIT1lP2UubDI6bnVsbCxsMTowfSl9c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEwxTDIpO3ZhciBSRUdVTEFSSVpFUl9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVA9e2wxbDI6XCJMMUwyXCJ9O2Z1bmN0aW9uIHNlcmlhbGl6ZVJlZ3VsYXJpemVyKGUpe3JldHVybiBzZXJpYWxpemVLZXJhc09iamVjdChlKX1mdW5jdGlvbiBkZXNlcmlhbGl6ZVJlZ3VsYXJpemVyKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PXt9KSxkZXNlcmlhbGl6ZUtlcmFzT2JqZWN0KGUsc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLmdldE1hcCgpLmNsYXNzTmFtZU1hcCx0LFwicmVndWxhcml6ZXJcIil9ZnVuY3Rpb24gZ2V0UmVndWxhcml6ZXIoZSl7cmV0dXJuIG51bGw9PWU/bnVsbDpcInN0cmluZ1wiPT10eXBlb2YgZT9kZXNlcmlhbGl6ZVJlZ3VsYXJpemVyKHtjbGFzc05hbWU6ZSBpbiBSRUdVTEFSSVpFUl9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVA/UkVHVUxBUklaRVJfSURFTlRJRklFUl9SRUdJU1RSWV9TWU1CT0xfTUFQW2VdOmUsY29uZmlnOnt9fSk6ZSBpbnN0YW5jZW9mIFJlZ3VsYXJpemVyP2U6ZGVzZXJpYWxpemVSZWd1bGFyaXplcihlKX12YXIgUmVMVT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLG51bGw9PXQ/e306dCl8fHRoaXM7cmV0dXJuIG4uc3VwcG9ydHNNYXNraW5nPSEwLG51bGwhPXQmJihuLm1heFZhbHVlPXQubWF4VmFsdWUpLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXtlPWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7dmFyIG49cmVsdShlKTtyZXR1cm4gbnVsbCE9dGhpcy5tYXhWYWx1ZSYmKG49Y2xpcEJ5VmFsdWUobiwwLHRoaXMubWF4VmFsdWUpKSxufSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXttYXhWYWx1ZTp0aGlzLm1heFZhbHVlfSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJSZUxVXCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhSZUxVKTt2YXIgTGVha3lSZUxVPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsbnVsbD09dD97fTp0KXx8dGhpcztyZXR1cm4gbi5ERUZBVUxUX0FMUEhBPS4zLG51bGw9PXQmJih0PXt9KSxuLmFscGhhPW51bGw9PXQuYWxwaGE/bi5ERUZBVUxUX0FMUEhBOnQuYWxwaGEsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7cmV0dXJuIGxlYWt5UmVsdShuLHRoaXMuYWxwaGEpfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXthbHBoYTp0aGlzLmFscGhhfSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJMZWFreVJlTFVcIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKExlYWt5UmVMVSk7dmFyIFBSZUxVPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsbnVsbD09dD97fTp0KXx8dGhpcztpZihuLkRFRkFVTFRfQUxQSEFfSU5JVElBTElaRVI9XCJ6ZXJvc1wiLG51bGw9PXQmJih0PXt9KSxuLnN1cHBvcnRzTWFza2luZz0hMCxuLmFscGhhSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5hbHBoYUluaXRpYWxpemVyfHxuLkRFRkFVTFRfQUxQSEFfSU5JVElBTElaRVIpLG4uYWxwaGFSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0LmFscGhhUmVndWxhcml6ZXIpLG4uYWxwaGFDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5hbHBoYUNvbnN0cmFpbnQpLG51bGw9PXQuc2hhcmVkQXhlcyluLnNoYXJlZEF4ZXM9bnVsbDtlbHNlIGlmKEFycmF5LmlzQXJyYXkodC5zaGFyZWRBeGVzKSluLnNoYXJlZEF4ZXM9dC5zaGFyZWRBeGVzO2Vsc2V7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHQuc2hhcmVkQXhlcyl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkV4cGVjdGVkIHNoYXJlZEF4ZXMgdG8gYmUgYSBudW1iZXIgb3IgYW4gYXJyYXkgb2YgbnVtYmVycywgYnV0IGdvdCBcIit0LnNoYXJlZEF4ZXMpO24uc2hhcmVkQXhlcz1bdC5zaGFyZWRBeGVzXX1yZXR1cm4gbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7dmFyIHQ9KGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpKS5zbGljZSgxKTtpZihudWxsIT10aGlzLnNoYXJlZEF4ZXMpZm9yKHZhciBuPTAscj10aGlzLnNoYXJlZEF4ZXM7bjxyLmxlbmd0aDtuKyspe3RbKGE9cltuXSktMV09MX10aGlzLmFscGhhPXRoaXMuYWRkV2VpZ2h0KFwiYWxwaGFcIix0LFwiZmxvYXQzMlwiLHRoaXMuYWxwaGFJbml0aWFsaXplcix0aGlzLmFscGhhUmVndWxhcml6ZXIsITAsdGhpcy5hbHBoYUNvbnN0cmFpbnQpO3ZhciBpPXt9O2lmKG51bGwhPXRoaXMuc2hhcmVkQXhlcylmb3IodmFyIGE9MTthPGUubGVuZ3RoOysrYSlpW2FdPWVbYV07dGhpcy5pbnB1dFNwZWM9W25ldyBJbnB1dFNwZWMoe25kaW06ZS5sZW5ndGgsYXhlczppfSldLHRoaXMuYnVpbHQ9ITB9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT1nZXRFeGFjdGx5T25lVGVuc29yKGUpLHByZWx1KGUsdGhpcy5hbHBoYS5yZWFkKCkpfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17YWxwaGFJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmFscGhhSW5pdGlhbGl6ZXIpLGFscGhhUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5hbHBoYVJlZ3VsYXJpemVyKSxhbHBoYUNvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmFscGhhQ29uc3RyYWludCksc2hhcmVkQXhlczp0aGlzLnNoYXJlZEF4ZXN9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIlBSZUxVXCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhQUmVMVSk7dmFyIEVMVT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLG51bGw9PXQ/e306dCl8fHRoaXM7aWYobi5ERUZBVUxUX0FMUEhBPTEsbnVsbD09dCYmKHQ9e30pLG51bGwhPXQuYWxwaGEmJnQuYWxwaGEhPT1uLkRFRkFVTFRfQUxQSEEpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJOb24tZGVmYXVsdCBhbHBoYSB2YWx1ZSAoXCIrdC5hbHBoYStcIikgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgRUxVIGxheWVyIHlldC5cIik7cmV0dXJuIG4uYWxwaGE9bnVsbD09dC5hbHBoYT9uLkRFRkFVTFRfQUxQSEE6dC5hbHBoYSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49Z2V0RXhhY3RseU9uZVRlbnNvcihlKTtyZXR1cm4gZWx1KG4pfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXthbHBoYTp0aGlzLmFscGhhfSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJFTFVcIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEVMVSk7dmFyIFRocmVzaG9sZGVkUmVMVT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLG51bGw9PXQ/e306dCl8fHRoaXM7cmV0dXJuIG4uREVGQVVMVF9USEVUQT0xLG51bGw9PXQmJih0PXt9KSxuLnRoZXRhPW51bGw9PXQudGhldGE/bi5ERUZBVUxUX1RIRVRBOnQudGhldGEsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7cmV0dXJuIG4ubXVsKGNhc3QkMShuLmdyZWF0ZXIodGhpcy50aGV0YSksXCJmbG9hdDMyXCIpKX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3JldHVybiBlfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17dGhldGE6dGhpcy50aGV0YX0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiVGhyZXNob2xkZWRSZUxVXCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhUaHJlc2hvbGRlZFJlTFUpO3ZhciBTb2Z0bWF4JDE9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyxudWxsPT10P3t9OnQpfHx0aGlzO3JldHVybiBuLkRFRkFVTFRfQVhJUz0xLG51bGw9PXQmJih0PXt9KSxuLnNvZnRtYXg9KG5ldyBTb2Z0bWF4KS5hcHBseSxuLmF4aXM9bnVsbD09dC5heGlzP24uREVGQVVMVF9BWElTOnQuYXhpcyxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49Z2V0RXhhY3RseU9uZVRlbnNvcihlKTtyZXR1cm4gdGhpcy5zb2Z0bWF4KG4sdGhpcy5heGlzKX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3JldHVybiBlfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17YXhpczp0aGlzLmF4aXN9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIlNvZnRtYXhcIix0fShMYXllcik7ZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkoZSx0LG4pe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBlKXJldHVybiBweUxpc3RSZXBlYXQoZSx0KTtpZihlLmxlbmd0aCE9PXQpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgXCIrbitcIiBhcmd1bWVudCBtdXN0IGJlIGFuIGludGVnZXIgb3IgdHVwbGUgb2YgXCIrdCtcIiBpbnRlZ2Vycy4gUmVjZWl2ZWQ6IFwiK2UubGVuZ3RoK1wiIGVsZW1lbnRzLlwiKTtmb3IodmFyIHI9MDtyPHQ7KytyKXt2YXIgaT1lW3JdO2lmKCFpc0ludGVnZXIoaSkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgXCIrbitcIiBhcmd1bWVudCBtdXN0IGJlIGFuIGludGVnZXIgb3IgdHVwbGUgb2YgXCIrdCtcIiBpbnRlZ2Vycy4gUmVjZWl2ZWQ6IFwiK0pTT04uc3RyaW5naWZ5KGUpK1wiIGluY2x1ZGluZyBhIG5vbi1pbnRlZ2VyIG51bWJlciBcIitpKX1yZXR1cm4gZX1mdW5jdGlvbiBjb252T3V0cHV0TGVuZ3RoKGUsdCxuLHIsaSl7cmV0dXJuIHZvaWQgMD09PWkmJihpPTEpLG51bGw9PWU/ZTooYT1cInNhbWVcIj09PW4/ZTplLSh0Kyh0LTEpKihpLTEpKSsxLE1hdGguZmxvb3IoKGErci0xKS9yKSk7dmFyIGF9ZnVuY3Rpb24gZGVjb252TGVuZ3RoKGUsdCxuLHIpe2lmKG51bGw9PWUpcmV0dXJuIG51bGw7aWYoXCJ2YWxpZFwiPT09cillPWUqdCttYXgkMShbbi10LDBdKTtlbHNle2lmKFwic2FtZVwiIT09cil0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlVuc3VwcG9ydCBwYWRkaW5nIG1vZGU6IFwiK3IrXCIuXCIpO2UqPXR9cmV0dXJuIGV9ZnVuY3Rpb24gcHJlcHJvY2Vzc0NvbnYyRElucHV0KGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gY2hlY2tEYXRhRm9ybWF0KHQpLFwiY2hhbm5lbHNGaXJzdFwiPT09dD90cmFuc3Bvc2UoZSxbMCwyLDMsMV0pOmV9KX1mdW5jdGlvbiBwcmVwcm9jZXNzQ29udjNESW5wdXQoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBjaGVja0RhdGFGb3JtYXQodCksXCJjaGFubmVsc0ZpcnN0XCI9PT10P3RyYW5zcG9zZShlLFswLDIsMyw0LDFdKTplfSl9ZnVuY3Rpb24gY29udjFkV2l0aEJpYXMoZSx0LG4scixpLGEsbyl7cmV0dXJuIHZvaWQgMD09PXImJihyPTEpLHZvaWQgMD09PWkmJihpPVwidmFsaWRcIiksdm9pZCAwPT09byYmKG89MSksdGlkeShmdW5jdGlvbigpe2lmKG51bGw9PWEmJihhPWltYWdlRGF0YUZvcm1hdCgpKSxjaGVja0RhdGFGb3JtYXQoYSksMyE9PWUuc2hhcGUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGlucHV0IG9mIGEgY29udjFkV2l0aEJpYXMgb3BlcmF0aW9uIHNob3VsZCBiZSAzLCBidXQgaXMgXCIrZS5zaGFwZS5sZW5ndGgrXCIgaW5zdGVhZC5cIik7aWYoMyE9PXQuc2hhcGUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGtlcm5lbCBmb3IgYSBjb252MWRXaXRoQmlhcyBvcGVyYXRpb24gc2hvdWxkIGJlIDMsIGJ1dCBpcyBcIit0LnNoYXBlLmxlbmd0aCtcIiBpbnN0ZWFkXCIpO2lmKG51bGwhPW4mJjEhPT1uLnNoYXBlLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBiaWFzIGZvciBhIGNvbnYxZFdpdGhCaWFzIG9wZXJhdGlvbiBzaG91bGQgYmUgMSwgYnV0IGlzIFwiK3Quc2hhcGUubGVuZ3RoK1wiIGluc3RlYWRcIik7aWYoXCJjaGFubmVsc0ZpcnN0XCI9PT1hJiYoZT10cmFuc3Bvc2UoZSxbMCwyLDFdKSksXCJjYXVzYWxcIj09PWkpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJUaGUgc3VwcG9ydCBmb3IgQ0FVU0FMIHBhZGRpbmcgbW9kZSBpbiBjb252MWRXaXRoQmlhcyBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTt2YXIgcz1jb252MWQoZSx0LHIsXCJzYW1lXCI9PT1pP1wic2FtZVwiOlwidmFsaWRcIixcIk5XQ1wiLG8pO3JldHVybiBudWxsIT1uJiYocz1iaWFzQWRkKHMsbikpLHN9KX1mdW5jdGlvbiBjb252MmRXaXRoQmlhcyhlLHQsbixyLGksYSxvKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9WzEsMV0pLHZvaWQgMD09PWkmJihpPVwidmFsaWRcIiksdGlkeShmdW5jdGlvbigpe2lmKG51bGw9PWEmJihhPWltYWdlRGF0YUZvcm1hdCgpKSxjaGVja0RhdGFGb3JtYXQoYSksMyE9PWUucmFuayYmNCE9PWUucmFuayl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImNvbnYyZFdpdGhCaWFzIGV4cGVjdHMgaW5wdXQgdG8gYmUgb2YgcmFuayAzIG9yIDQsIGJ1dCByZWNlaXZlZCBcIitlLnJhbmsrXCIuXCIpO2lmKDMhPT10LnJhbmsmJjQhPT10LnJhbmspdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJjb252MmRXaXRoQmlhcyBleHBlY3RzIGtlcm5lbCB0byBiZSBvZiByYW5rIDMgb3IgNCwgYnV0IHJlY2VpdmVkIFwiK2UucmFuaytcIi5cIik7dmFyIHM9cHJlcHJvY2Vzc0NvbnYyRElucHV0KGUsYSk7aWYoXCJjYXVzYWxcIj09PWkpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJUaGUgc3VwcG9ydCBmb3IgQ0FVU0FMIHBhZGRpbmcgbW9kZSBpbiBjb252MWRXaXRoQmlhcyBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtyZXR1cm4gcz1jb252MmQocyx0LHIsXCJzYW1lXCI9PT1pP1wic2FtZVwiOlwidmFsaWRcIixcIk5IV0NcIixvKSxudWxsIT1uJiYocz1iaWFzQWRkKHMsbikpLFwiY2hhbm5lbHNGaXJzdFwiPT09YSYmKHM9dHJhbnNwb3NlKHMsWzAsMywxLDJdKSksc30pfWZ1bmN0aW9uIGNvbnYzZFdpdGhCaWFzKGUsdCxuLHIsaSxhLG8pe3JldHVybiB2b2lkIDA9PT1yJiYocj1bMSwxLDFdKSx2b2lkIDA9PT1pJiYoaT1cInZhbGlkXCIpLHRpZHkoZnVuY3Rpb24oKXtpZihudWxsPT1hJiYoYT1pbWFnZURhdGFGb3JtYXQoKSksY2hlY2tEYXRhRm9ybWF0KGEpLDQhPT1lLnJhbmsmJjUhPT1lLnJhbmspdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJjb252M2RXaXRoQmlhcyBleHBlY3RzIGlucHV0IHRvIGJlIG9mIHJhbmsgNCBvciA1LCBidXQgcmVjZWl2ZWQgXCIrZS5yYW5rK1wiLlwiKTtpZig0IT09dC5yYW5rJiY1IT09dC5yYW5rKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiY29udjNkV2l0aEJpYXMgZXhwZWN0cyBrZXJuZWwgdG8gYmUgb2YgcmFuayA0IG9yIDUsIGJ1dCByZWNlaXZlZCBcIitlLnJhbmsrXCIuXCIpO3ZhciBzPXByZXByb2Nlc3NDb252M0RJbnB1dChlLGEpO2lmKFwiY2F1c2FsXCI9PT1pKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiVGhlIHN1cHBvcnQgZm9yIENBVVNBTCBwYWRkaW5nIG1vZGUgaW4gY29udjNkV2l0aEJpYXMgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7cmV0dXJuIHM9Y29udjNkKHMsdCxyLFwic2FtZVwiPT09aT9cInNhbWVcIjpcInZhbGlkXCIsXCJOREhXQ1wiLG8pLG51bGwhPW4mJihzPWJpYXNBZGQocyxuKSksXCJjaGFubmVsc0ZpcnN0XCI9PT1hJiYocz10cmFuc3Bvc2UocyxbMCw0LDEsMiwzXSkpLHN9KX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoU29mdG1heCQxKTt2YXIgQmFzZUNvbnY9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuLHIpe3ZhciBpPWUuY2FsbCh0aGlzLHIpfHx0aGlzO2lmKGkuYmlhcz1udWxsLGkuREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVI9XCJnbG9yb3ROb3JtYWxcIixpLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUj1cInplcm9zXCIsdC52ZXJpZnlBcmdzKHIpLGkucmFuaz1uLGFzc2VydFBvc2l0aXZlSW50ZWdlcihpLnJhbmssXCJyYW5rXCIpLDEhPT1pLnJhbmsmJjIhPT1pLnJhbmsmJjMhPT1pLnJhbmspdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJDb252b2x1dGlvbiBsYXllciBmb3IgcmFuayBvdGhlciB0aGFuIDEsIDIsIG9yIDMgKFwiK2kucmFuaytcIikgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7aWYoaS5rZXJuZWxTaXplPW5vcm1hbGl6ZUFycmF5KHIua2VybmVsU2l6ZSxuLFwia2VybmVsU2l6ZVwiKSxpLnN0cmlkZXM9bm9ybWFsaXplQXJyYXkobnVsbD09ci5zdHJpZGVzPzE6ci5zdHJpZGVzLG4sXCJzdHJpZGVzXCIpLGkucGFkZGluZz1udWxsPT1yLnBhZGRpbmc/XCJ2YWxpZFwiOnIucGFkZGluZyxjaGVja1BhZGRpbmdNb2RlKGkucGFkZGluZyksaS5kYXRhRm9ybWF0PW51bGw9PXIuZGF0YUZvcm1hdD9cImNoYW5uZWxzTGFzdFwiOnIuZGF0YUZvcm1hdCxjaGVja0RhdGFGb3JtYXQoaS5kYXRhRm9ybWF0KSxpLmFjdGl2YXRpb249Z2V0QWN0aXZhdGlvbihyLmFjdGl2YXRpb24pLGkudXNlQmlhcz1udWxsPT1yLnVzZUJpYXN8fHIudXNlQmlhcyxpLmJpYXNJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcihyLmJpYXNJbml0aWFsaXplcnx8aS5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVIpLGkuYmlhc0NvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludChyLmJpYXNDb25zdHJhaW50KSxpLmJpYXNSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcihyLmJpYXNSZWd1bGFyaXplciksaS5hY3Rpdml0eVJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHIuYWN0aXZpdHlSZWd1bGFyaXplciksaS5kaWxhdGlvblJhdGU9bm9ybWFsaXplQXJyYXkobnVsbD09ci5kaWxhdGlvblJhdGU/MTpyLmRpbGF0aW9uUmF0ZSxuLFwiZGlsYXRpb25SYXRlXCIpLDE9PT1pLnJhbmsmJkFycmF5LmlzQXJyYXkoaS5kaWxhdGlvblJhdGUpJiYxIT09aS5kaWxhdGlvblJhdGUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiZGlsYXRpb25SYXRlIG11c3QgYmUgYSBudW1iZXIgb3IgYW4gYXJyYXkgb2YgYSBzaW5nbGUgbnVtYmVyIGZvciAxRCBjb252b2x1dGlvbiwgYnV0IHJlY2VpdmVkIFwiK0pTT04uc3RyaW5naWZ5KGkuZGlsYXRpb25SYXRlKSk7aWYoMj09PWkucmFuayl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGkuZGlsYXRpb25SYXRlKWkuZGlsYXRpb25SYXRlPVtpLmRpbGF0aW9uUmF0ZSxpLmRpbGF0aW9uUmF0ZV07ZWxzZSBpZigyIT09aS5kaWxhdGlvblJhdGUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiZGlsYXRpb25SYXRlIG11c3QgYmUgYSBudW1iZXIgb3IgYXJyYXkgb2YgdHdvIG51bWJlcnMgZm9yIDJEIGNvbnZvbHV0aW9uLCBidXQgcmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkoaS5kaWxhdGlvblJhdGUpKX1lbHNlIGlmKDM9PT1pLnJhbmspaWYoXCJudW1iZXJcIj09dHlwZW9mIGkuZGlsYXRpb25SYXRlKWkuZGlsYXRpb25SYXRlPVtpLmRpbGF0aW9uUmF0ZSxpLmRpbGF0aW9uUmF0ZSxpLmRpbGF0aW9uUmF0ZV07ZWxzZSBpZigzIT09aS5kaWxhdGlvblJhdGUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiZGlsYXRpb25SYXRlIG11c3QgYmUgYSBudW1iZXIgb3IgYXJyYXkgb2YgdGhyZWUgbnVtYmVycyBmb3IgM0QgY29udm9sdXRpb24sIGJ1dCByZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeShpLmRpbGF0aW9uUmF0ZSkpO3JldHVybiBpfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnZlcmlmeUFyZ3M9ZnVuY3Rpb24oZSl7aWYoYXNzZXJ0KFwia2VybmVsU2l6ZVwiaW4gZSxcInJlcXVpcmVkIGtleSAna2VybmVsU2l6ZScgbm90IGluIGNvbmZpZ1wiKSxcIm51bWJlclwiIT10eXBlb2YgZS5rZXJuZWxTaXplJiYhY2hlY2tBcnJheVR5cGVBbmRMZW5ndGgoZS5rZXJuZWxTaXplLFwibnVtYmVyXCIsMSwzKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkJhc2VDb252IGV4cGVjdHMgY29uZmlnLmtlcm5lbFNpemUgdG8gYmUgbnVtYmVyIG9yIG51bWJlcltdIHdpdGggbGVuZ3RoIDEsIDIsIG9yIDMsIGJ1dCByZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeShlLmtlcm5lbFNpemUpK1wiLlwiKX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2tlcm5lbFNpemU6dGhpcy5rZXJuZWxTaXplLHN0cmlkZXM6dGhpcy5zdHJpZGVzLHBhZGRpbmc6dGhpcy5wYWRkaW5nLGRhdGFGb3JtYXQ6dGhpcy5kYXRhRm9ybWF0LGRpbGF0aW9uUmF0ZTp0aGlzLmRpbGF0aW9uUmF0ZSxhY3RpdmF0aW9uOnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKSx1c2VCaWFzOnRoaXMudXNlQmlhcyxiaWFzSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLGJpYXNSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmJpYXNSZWd1bGFyaXplciksYWN0aXZpdHlSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLGJpYXNDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5iaWFzQ29uc3RyYWludCl9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0fShMYXllciksQ29udj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KG4scil7dmFyIGk9ZS5jYWxsKHRoaXMsbixyKXx8dGhpcztyZXR1cm4gaS5rZXJuZWw9bnVsbCx0LnZlcmlmeUFyZ3MociksaS5maWx0ZXJzPXIuZmlsdGVycyxhc3NlcnRQb3NpdGl2ZUludGVnZXIoaS5maWx0ZXJzLFwiZmlsdGVyc1wiKSxpLmtlcm5lbEluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHIua2VybmVsSW5pdGlhbGl6ZXJ8fGkuREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIpLGkua2VybmVsQ29uc3RyYWludD1nZXRDb25zdHJhaW50KHIua2VybmVsQ29uc3RyYWludCksaS5rZXJuZWxSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcihyLmtlcm5lbFJlZ3VsYXJpemVyKSxpfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXt2YXIgdDtlPWdldEV4YWN0bHlPbmVTaGFwZShlKTt2YXIgbj1cImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdD8xOmUubGVuZ3RoLTE7aWYobnVsbD09ZVtuXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBjaGFubmVsIGRpbWVuc2lvbiBvZiB0aGUgaW5wdXQgc2hvdWxkIGJlIGRlZmluZWQuIEZvdW5kIFwiK2Vbbl0pO3ZhciByPWVbbl0saT10aGlzLmtlcm5lbFNpemUuY29uY2F0KFtyLHRoaXMuZmlsdGVyc10pO3RoaXMua2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwia2VybmVsXCIsaSxudWxsLHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsdGhpcy5rZXJuZWxSZWd1bGFyaXplciwhMCx0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHRoaXMudXNlQmlhcyYmKHRoaXMuYmlhcz10aGlzLmFkZFdlaWdodChcImJpYXNcIixbdGhpcy5maWx0ZXJzXSxudWxsLHRoaXMuYmlhc0luaXRpYWxpemVyLHRoaXMuYmlhc1JlZ3VsYXJpemVyLCEwLHRoaXMuYmlhc0NvbnN0cmFpbnQpKSx0aGlzLmlucHV0U3BlYz1be25kaW06dGhpcy5yYW5rKzIsYXhlczoodD17fSx0W25dPXIsdCl9XSx0aGlzLmJ1aWx0PSEwfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciB0O2U9Z2V0RXhhY3RseU9uZVRlbnNvcihlKTt2YXIgcj1udWxsPT1uLmJpYXM/bnVsbDpuLmJpYXMucmVhZCgpO2lmKDE9PT1uLnJhbmspdD1jb252MWRXaXRoQmlhcyhlLG4ua2VybmVsLnJlYWQoKSxyLG4uc3RyaWRlc1swXSxuLnBhZGRpbmcsbi5kYXRhRm9ybWF0LG4uZGlsYXRpb25SYXRlWzBdKTtlbHNlIGlmKDI9PT1uLnJhbmspdD1jb252MmRXaXRoQmlhcyhlLG4ua2VybmVsLnJlYWQoKSxyLG4uc3RyaWRlcyxuLnBhZGRpbmcsbi5kYXRhRm9ybWF0LG4uZGlsYXRpb25SYXRlKTtlbHNle2lmKDMhPT1uLnJhbmspdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJjb252b2x1dGlvbnMgZ3JlYXRlciB0aGFuIDNEIGFyZSBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTt0PWNvbnYzZFdpdGhCaWFzKGUsbi5rZXJuZWwucmVhZCgpLHIsbi5zdHJpZGVzLG4ucGFkZGluZyxuLmRhdGFGb3JtYXQsbi5kaWxhdGlvblJhdGUpfXJldHVybiBudWxsIT1uLmFjdGl2YXRpb24mJih0PW4uYWN0aXZhdGlvbi5hcHBseSh0KSksdH0pfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7ZT1nZXRFeGFjdGx5T25lU2hhcGUoZSk7Zm9yKHZhciB0PVtdLG49XCJjaGFubmVsc0xhc3RcIj09PXRoaXMuZGF0YUZvcm1hdD9lLnNsaWNlKDEsZS5sZW5ndGgtMSk6ZS5zbGljZSgyKSxyPTA7cjxuLmxlbmd0aDsrK3Ipe3ZhciBpPWNvbnZPdXRwdXRMZW5ndGgobltyXSx0aGlzLmtlcm5lbFNpemVbcl0sdGhpcy5wYWRkaW5nLHRoaXMuc3RyaWRlc1tyXSxcIm51bWJlclwiPT10eXBlb2YgdGhpcy5kaWxhdGlvblJhdGU/dGhpcy5kaWxhdGlvblJhdGU6dGhpcy5kaWxhdGlvblJhdGVbcl0pO3QucHVzaChpKX12YXIgYT1bZVswXV07cmV0dXJuXCJjaGFubmVsc0xhc3RcIj09PXRoaXMuZGF0YUZvcm1hdD8oYT1hLmNvbmNhdCh0KSkucHVzaCh0aGlzLmZpbHRlcnMpOihhLnB1c2godGhpcy5maWx0ZXJzKSxhPWEuY29uY2F0KHQpKSxhfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17ZmlsdGVyczp0aGlzLmZpbHRlcnMsa2VybmVsSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5rZXJuZWxJbml0aWFsaXplciksa2VybmVsUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplciksa2VybmVsQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMua2VybmVsQ29uc3RyYWludCl9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LnZlcmlmeUFyZ3M9ZnVuY3Rpb24oZSl7aWYoIShcImZpbHRlcnNcImluIGUpfHxcIm51bWJlclwiIT10eXBlb2YgZS5maWx0ZXJzfHxlLmZpbHRlcnM8MSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNvbnZvbHV0aW9uIGxheWVyIGV4cGVjdGVkIGNvbmZpZy5maWx0ZXJzIHRvIGJlIGEgJ251bWJlcicgPiAwIGJ1dCBnb3QgXCIrSlNPTi5zdHJpbmdpZnkoZS5maWx0ZXJzKSl9LHR9KEJhc2VDb252KSxDb252MkQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuKXt2YXIgcj1lLmNhbGwodGhpcywyLG4pfHx0aGlzO3JldHVybiB0LnZlcmlmeUFyZ3Mobikscn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIGRlbGV0ZSB0LnJhbmssdH0sdC52ZXJpZnlBcmdzPWZ1bmN0aW9uKGUpe2lmKFwibnVtYmVyXCIhPXR5cGVvZiBlLmtlcm5lbFNpemUmJiFjaGVja0FycmF5VHlwZUFuZExlbmd0aChlLmtlcm5lbFNpemUsXCJudW1iZXJcIiwxLDIpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ29udjJEIGV4cGVjdHMgY29uZmlnLmtlcm5lbFNpemUgdG8gYmUgbnVtYmVyIG9yIG51bWJlcltdIHdpdGggbGVuZ3RoIDEgb3IgMiwgYnV0IHJlY2VpdmVkIFwiK0pTT04uc3RyaW5naWZ5KGUua2VybmVsU2l6ZSkrXCIuXCIpfSx0LmNsYXNzTmFtZT1cIkNvbnYyRFwiLHR9KENvbnYpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhDb252MkQpO3ZhciBDb252M0Q9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuKXt2YXIgcj1lLmNhbGwodGhpcywzLG4pfHx0aGlzO3JldHVybiB0LnZlcmlmeUFyZ3Mobikscn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIGRlbGV0ZSB0LnJhbmssdH0sdC52ZXJpZnlBcmdzPWZ1bmN0aW9uKGUpe2lmKFwibnVtYmVyXCIhPXR5cGVvZiBlLmtlcm5lbFNpemUmJighQXJyYXkuaXNBcnJheShlLmtlcm5lbFNpemUpfHwxIT09ZS5rZXJuZWxTaXplLmxlbmd0aCYmMyE9PWUua2VybmVsU2l6ZS5sZW5ndGgpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ29udjNEIGV4cGVjdHMgY29uZmlnLmtlcm5lbFNpemUgdG8gYmUgbnVtYmVyIG9yIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgYnV0IHJlY2VpdmVkIFwiK0pTT04uc3RyaW5naWZ5KGUua2VybmVsU2l6ZSkrXCIuXCIpfSx0LmNsYXNzTmFtZT1cIkNvbnYzRFwiLHR9KENvbnYpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhDb252M0QpO3ZhciBDb252MkRUcmFuc3Bvc2U9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztpZihuLmlucHV0U3BlYz1bbmV3IElucHV0U3BlYyh7bmRpbTo0fSldLFwic2FtZVwiIT09bi5wYWRkaW5nJiZcInZhbGlkXCIhPT1uLnBhZGRpbmcpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDb252MkRUcmFuc3Bvc2UgY3VycmVudGx5IHN1cHBvcnRzIG9ubHkgcGFkZGluZyBtb2RlcyAnc2FtZScgYW5kICd2YWxpZCcsIGJ1dCByZWNlaXZlZCBwYWRkaW5nIG1vZGUgXCIrbi5wYWRkaW5nKTtyZXR1cm4gbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7dmFyIHQ7aWYoNCE9PShlPWdldEV4YWN0bHlPbmVTaGFwZShlKSkubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW5wdXQgc2hvdWxkIGhhdmUgcmFuayA0OyBSZWNlaXZlZCBpbnB1dCBzaGFwZTogXCIrSlNPTi5zdHJpbmdpZnkoZSkpO3ZhciBuPVwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0PzE6ZS5sZW5ndGgtMTtpZihudWxsPT1lW25dKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGNoYW5uZWwgZGltZW5zaW9uIG9mIHRoZSBpbnB1dHMgc2hvdWxkIGJlIGRlZmluZWQuIEZvdW5kIGBOb25lYC5cIik7dmFyIHI9ZVtuXSxpPXRoaXMua2VybmVsU2l6ZS5jb25jYXQoW3RoaXMuZmlsdGVycyxyXSk7dGhpcy5rZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJrZXJuZWxcIixpLFwiZmxvYXQzMlwiLHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsdGhpcy5rZXJuZWxSZWd1bGFyaXplciwhMCx0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHRoaXMudXNlQmlhcyYmKHRoaXMuYmlhcz10aGlzLmFkZFdlaWdodChcImJpYXNcIixbdGhpcy5maWx0ZXJzXSxcImZsb2F0MzJcIix0aGlzLmJpYXNJbml0aWFsaXplcix0aGlzLmJpYXNSZWd1bGFyaXplciwhMCx0aGlzLmJpYXNDb25zdHJhaW50KSksdGhpcy5pbnB1dFNwZWM9W25ldyBJbnB1dFNwZWMoe25kaW06NCxheGVzOih0PXt9LHRbbl09cix0KX0pXSx0aGlzLmJ1aWx0PSEwfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciB0PWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7aWYoNCE9PXQuc2hhcGUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ29udjJEVHJhbnNwb3NlLmNhbGwoKSBleHBlY3RzIGlucHV0IHRlbnNvciB0byBiZSByYW5rLTQsIGJ1dCByZWNlaXZlZCBhIHRlbnNvciBvZiByYW5rLVwiK3Quc2hhcGUubGVuZ3RoKTt2YXIgcixpLGE9dC5zaGFwZSxvPWFbMF07XCJjaGFubmVsc0ZpcnN0XCI9PT1uLmRhdGFGb3JtYXQ/KHI9MixpPTMpOihyPTEsaT0yKTt2YXIgcz1hW3JdLGw9YVtpXSx1PW4ua2VybmVsU2l6ZVswXSxjPW4ua2VybmVsU2l6ZVsxXSxwPW4uc3RyaWRlc1swXSxoPW4uc3RyaWRlc1sxXSxkPVtvLGRlY29udkxlbmd0aChzLHAsdSxuLnBhZGRpbmcpLGRlY29udkxlbmd0aChsLGgsYyxuLnBhZGRpbmcpLG4uZmlsdGVyc107XCJjaGFubmVsc0xhc3RcIiE9PW4uZGF0YUZvcm1hdCYmKHQ9dHJhbnNwb3NlKHQsWzAsMiwzLDFdKSk7dmFyIGY9Y29udjJkVHJhbnNwb3NlKHQsbi5rZXJuZWwucmVhZCgpLGQsbi5zdHJpZGVzLG4ucGFkZGluZyk7cmV0dXJuXCJjaGFubmVsc0xhc3RcIiE9PW4uZGF0YUZvcm1hdCYmKGY9dHJhbnNwb3NlKGYsWzAsMywxLDJdKSksbnVsbCE9bi5iaWFzJiYoZj1iaWFzQWRkKGYsbi5iaWFzLnJlYWQoKSxuLmRhdGFGb3JtYXQpKSxudWxsIT1uLmFjdGl2YXRpb24mJihmPW4uYWN0aXZhdGlvbi5hcHBseShmKSksZn0pfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7dmFyIHQsbixyLGk9KGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpKS5zbGljZSgpO1wiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0Pyh0PTEsbj0yLHI9Myk6KHQ9MyxuPTEscj0yKTt2YXIgYT10aGlzLmtlcm5lbFNpemVbMF0sbz10aGlzLmtlcm5lbFNpemVbMV0scz10aGlzLnN0cmlkZXNbMF0sbD10aGlzLnN0cmlkZXNbMV07cmV0dXJuIGlbdF09dGhpcy5maWx0ZXJzLGlbbl09ZGVjb252TGVuZ3RoKGlbbl0scyxhLHRoaXMucGFkZGluZyksaVtyXT1kZWNvbnZMZW5ndGgoaVtyXSxsLG8sdGhpcy5wYWRkaW5nKSxpfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gZGVsZXRlIHQuZGlsYXRpb25SYXRlLHR9LHQuY2xhc3NOYW1lPVwiQ29udjJEVHJhbnNwb3NlXCIsdH0oQ29udjJEKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQ29udjJEVHJhbnNwb3NlKTt2YXIgU2VwYXJhYmxlQ29udj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQsbil7dmFyIHI9ZS5jYWxsKHRoaXMsdCxuKXx8dGhpcztpZihyLkRFRkFVTFRfREVQVEhXSVNFX0lOSVRJQUxJWkVSPVwiZ2xvcm90VW5pZm9ybVwiLHIuREVGQVVMVF9QT0lOVFdJU0VfSU5JVElBTElaRVI9XCJnbG9yb3RVbmlmb3JtXCIsci5kZXB0aHdpc2VLZXJuZWw9bnVsbCxyLnBvaW50d2lzZUtlcm5lbD1udWxsLG51bGw9PW4uZmlsdGVycyl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBgZmlsdGVyc2AgY29uZmlndXJhdGlvbiBmaWVsZCBpcyByZXF1aXJlZCBieSBTZXBhcmFibGVDb252LCBidXQgaXMgdW5zcGVjaWZpZWQuXCIpO2lmKG51bGwhPW4ua2VybmVsSW5pdGlhbGl6ZXJ8fG51bGwhPW4ua2VybmVsUmVndWxhcml6ZXJ8fG51bGwhPW4ua2VybmVsQ29uc3RyYWludCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkZpZWxkcyBrZXJuZWxJbml0aWFsaXplciwga2VybmVsUmVndWxhcml6ZXIgYW5kIGtlcm5lbENvbnN0cmFpbnQgYXJlIGludmFsaWQgZm9yIFNlcGFyYWJsZUNvbnYyRC4gVXNlIGRlcHRod2lzZUluaXRpYWxpemVyLCBkZXB0aHdpc2VSZWd1bGFyaXplciwgZGVwdGh3aXNlQ29uc3RyYWludCwgcG9pbnR3aXNlSW5pdGlhbGl6ZXIsIHBvaW50d2lzZVJlZ3VsYXJpemVyIGFuZCBwb2ludHdpc2VDb25zdHJhaW50IGluc3RlYWQuXCIpO2lmKG51bGwhPW4ucGFkZGluZyYmXCJzYW1lXCIhPT1uLnBhZGRpbmcmJlwidmFsaWRcIiE9PW4ucGFkZGluZyl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlNlcGFyYWJsZUNvbnZcIityLnJhbmsrXCJEIHN1cHBvcnRzIG9ubHkgcGFkZGluZyBtb2RlczogJ3NhbWUnIGFuZCAndmFsaWQnLCBidXQgcmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkobi5wYWRkaW5nKSk7cmV0dXJuIHIuZGVwdGhNdWx0aXBsaWVyPW51bGw9PW4uZGVwdGhNdWx0aXBsaWVyPzE6bi5kZXB0aE11bHRpcGxpZXIsci5kZXB0aHdpc2VJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcihuLmRlcHRod2lzZUluaXRpYWxpemVyfHxyLkRFRkFVTFRfREVQVEhXSVNFX0lOSVRJQUxJWkVSKSxyLmRlcHRod2lzZVJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKG4uZGVwdGh3aXNlUmVndWxhcml6ZXIpLHIuZGVwdGh3aXNlQ29uc3RyYWludD1nZXRDb25zdHJhaW50KG4uZGVwdGh3aXNlQ29uc3RyYWludCksci5wb2ludHdpc2VJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcihuLmRlcHRod2lzZUluaXRpYWxpemVyfHxyLkRFRkFVTFRfUE9JTlRXSVNFX0lOSVRJQUxJWkVSKSxyLnBvaW50d2lzZVJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKG4ucG9pbnR3aXNlUmVndWxhcml6ZXIpLHIucG9pbnR3aXNlQ29uc3RyYWludD1nZXRDb25zdHJhaW50KG4ucG9pbnR3aXNlQ29uc3RyYWludCkscn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7dmFyIHQ7aWYoKGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpKS5sZW5ndGg8dGhpcy5yYW5rKzIpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnB1dHMgdG8gU2VwYXJhYmxlQ29udlwiK3RoaXMucmFuaytcIkQgc2hvdWxkIGhhdmUgcmFuayBcIisodGhpcy5yYW5rKzIpK1wiLCBidXQgcmVjZWl2ZWQgaW5wdXQgc2hhcGU6IFwiK0pTT04uc3RyaW5naWZ5KGUpKTt2YXIgbj1cImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdD8xOmUubGVuZ3RoLTE7aWYobnVsbD09ZVtuXXx8ZVtuXTwwKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGNoYW5uZWwgZGltZW5zaW9uIG9mIHRoZSBpbnB1dHMgc2hvdWxkIGJlIGRlZmluZWQsIGJ1dCBmb3VuZCBcIitKU09OLnN0cmluZ2lmeShlW25dKSk7Zm9yKHZhciByPWVbbl0saT10aGlzLmtlcm5lbFNpemUuY29uY2F0KFtyLHRoaXMuZGVwdGhNdWx0aXBsaWVyXSksYT1bXSxvPTA7bzx0aGlzLnJhbms7KytvKWEucHVzaCgxKTthLnB1c2gocip0aGlzLmRlcHRoTXVsdGlwbGllcix0aGlzLmZpbHRlcnMpO3RoaXMuZGVwdGh3aXNlS2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwiZGVwdGh3aXNlX2tlcm5lbFwiLGksXCJmbG9hdDMyXCIsdGhpcy5kZXB0aHdpc2VJbml0aWFsaXplcix0aGlzLmRlcHRod2lzZVJlZ3VsYXJpemVyLCEwLHRoaXMuZGVwdGh3aXNlQ29uc3RyYWludCksdGhpcy5wb2ludHdpc2VLZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJwb2ludHdpc2Vfa2VybmVsXCIsYSxcImZsb2F0MzJcIix0aGlzLnBvaW50d2lzZUluaXRpYWxpemVyLHRoaXMucG9pbnR3aXNlUmVndWxhcml6ZXIsITAsdGhpcy5wb2ludHdpc2VDb25zdHJhaW50KSx0aGlzLnVzZUJpYXM/dGhpcy5iaWFzPXRoaXMuYWRkV2VpZ2h0KFwiYmlhc1wiLFt0aGlzLmZpbHRlcnNdLFwiZmxvYXQzMlwiLHRoaXMuYmlhc0luaXRpYWxpemVyLHRoaXMuYmlhc1JlZ3VsYXJpemVyLCEwLHRoaXMuYmlhc0NvbnN0cmFpbnQpOnRoaXMuYmlhcz1udWxsLHRoaXMuaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOnRoaXMucmFuaysyLGF4ZXM6KHQ9e30sdFtuXT1yLHQpfSldLHRoaXMuYnVpbHQ9ITB9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ7aWYoZT1nZXRFeGFjdGx5T25lVGVuc29yKGUpLDE9PT1uLnJhbmspdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCIxRCBzZXBhcmFibGUgY29udm9sdXRpb24gaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7cmV0dXJuIDI9PT1uLnJhbmsmJihcImNoYW5uZWxzRmlyc3RcIj09PW4uZGF0YUZvcm1hdCYmKGU9dHJhbnNwb3NlKGUsWzAsMiwzLDFdKSksdD1zZXBhcmFibGVDb252MmQoZSxuLmRlcHRod2lzZUtlcm5lbC5yZWFkKCksbi5wb2ludHdpc2VLZXJuZWwucmVhZCgpLG4uc3RyaWRlcyxuLnBhZGRpbmcsbi5kaWxhdGlvblJhdGUsXCJOSFdDXCIpKSxuLnVzZUJpYXMmJih0PWJpYXNBZGQodCxuLmJpYXMucmVhZCgpLG4uZGF0YUZvcm1hdCkpLG51bGwhPW4uYWN0aXZhdGlvbiYmKHQ9bi5hY3RpdmF0aW9uLmFwcGx5KHQpKSxcImNoYW5uZWxzRmlyc3RcIj09PW4uZGF0YUZvcm1hdCYmKHQ9dHJhbnNwb3NlKHQsWzAsMywxLDJdKSksdH0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gZGVsZXRlIHQucmFuayxkZWxldGUgdC5rZXJuZWxJbml0aWFsaXplcixkZWxldGUgdC5rZXJuZWxSZWd1bGFyaXplcixkZWxldGUgdC5rZXJuZWxDb25zdHJhaW50LHQuZGVwdGh3aXNlSW5pdGlhbGl6ZXI9c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5kZXB0aHdpc2VJbml0aWFsaXplciksdC5wb2ludHdpc2VJbml0aWFsaXplcj1zZXJpYWxpemVJbml0aWFsaXplcih0aGlzLnBvaW50d2lzZUluaXRpYWxpemVyKSx0LmRlcHRod2lzZVJlZ3VsYXJpemVyPXNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuZGVwdGh3aXNlUmVndWxhcml6ZXIpLHQucG9pbnR3aXNlUmVndWxhcml6ZXI9c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5wb2ludHdpc2VSZWd1bGFyaXplciksdC5kZXB0aHdpc2VDb25zdHJhaW50PXNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5kZXB0aHdpc2VDb25zdHJhaW50KSx0LnBvaW50d2lzZUNvbnN0cmFpbnQ9c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLnBvaW50d2lzZUNvbnN0cmFpbnQpLHR9LHQuY2xhc3NOYW1lPVwiU2VwYXJhYmxlQ29udlwiLHR9KENvbnYpLFNlcGFyYWJsZUNvbnYyRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcywyLHQpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LmNsYXNzTmFtZT1cIlNlcGFyYWJsZUNvbnYyRFwiLHR9KFNlcGFyYWJsZUNvbnYpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTZXBhcmFibGVDb252MkQpO3ZhciBDb252MUQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuKXt2YXIgcj1lLmNhbGwodGhpcywxLG4pfHx0aGlzO3JldHVybiB0LnZlcmlmeUFyZ3Mobiksci5pbnB1dFNwZWM9W3tuZGltOjN9XSxyfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gZGVsZXRlIHQucmFuayxkZWxldGUgdC5kYXRhRm9ybWF0LHR9LHQudmVyaWZ5QXJncz1mdW5jdGlvbihlKXtpZihcIm51bWJlclwiIT10eXBlb2YgZS5rZXJuZWxTaXplJiYhY2hlY2tBcnJheVR5cGVBbmRMZW5ndGgoZS5rZXJuZWxTaXplLFwibnVtYmVyXCIsMSwxKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNvbnYxRCBleHBlY3RzIGNvbmZpZy5rZXJuZWxTaXplIHRvIGJlIG51bWJlciBvciBudW1iZXJbXSB3aXRoIGxlbmd0aCAxLCBidXQgcmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkoZS5rZXJuZWxTaXplKStcIi5cIil9LHQuY2xhc3NOYW1lPVwiQ29udjFEXCIsdH0oQ29udik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKENvbnYxRCk7dmFyIENyb3BwaW5nMkQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdC5jcm9wcGluZz9uLmNyb3BwaW5nPVtbdC5jcm9wcGluZyx0LmNyb3BwaW5nXSxbdC5jcm9wcGluZyx0LmNyb3BwaW5nXV06XCJudW1iZXJcIj09dHlwZW9mIHQuY3JvcHBpbmdbMF0/bi5jcm9wcGluZz1bW3QuY3JvcHBpbmdbMF0sdC5jcm9wcGluZ1swXV0sW3QuY3JvcHBpbmdbMV0sdC5jcm9wcGluZ1sxXV1dOm4uY3JvcHBpbmc9dC5jcm9wcGluZyxuLmRhdGFGb3JtYXQ9dm9pZCAwPT09dC5kYXRhRm9ybWF0P1wiY2hhbm5lbHNMYXN0XCI6dC5kYXRhRm9ybWF0LG4uaW5wdXRTcGVjPVt7bmRpbTo0fV0sbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3JldHVyblwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0P1tlWzBdLGVbMV0sZVsyXS10aGlzLmNyb3BwaW5nWzBdWzBdLXRoaXMuY3JvcHBpbmdbMF1bMV0sZVszXS10aGlzLmNyb3BwaW5nWzFdWzBdLXRoaXMuY3JvcHBpbmdbMV1bMV1dOltlWzBdLGVbMV0tdGhpcy5jcm9wcGluZ1swXVswXS10aGlzLmNyb3BwaW5nWzBdWzFdLGVbMl0tdGhpcy5jcm9wcGluZ1sxXVswXS10aGlzLmNyb3BwaW5nWzFdWzFdLGVbM11dfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBlPWdldEV4YWN0bHlPbmVUZW5zb3IoZSksXCJjaGFubmVsc0xhc3RcIj09PW4uZGF0YUZvcm1hdD9zbGljZUFsb25nQXhpcyhzbGljZUFsb25nQXhpcyhlLG4uY3JvcHBpbmdbMF1bMF0sZS5zaGFwZVsxXS1uLmNyb3BwaW5nWzBdWzBdLW4uY3JvcHBpbmdbMF1bMV0sMiksbi5jcm9wcGluZ1sxXVswXSxlLnNoYXBlWzJdLW4uY3JvcHBpbmdbMV1bMV0tbi5jcm9wcGluZ1sxXVswXSwzKTpzbGljZUFsb25nQXhpcyhzbGljZUFsb25nQXhpcyhlLG4uY3JvcHBpbmdbMF1bMF0sZS5zaGFwZVsyXS1uLmNyb3BwaW5nWzBdWzBdLW4uY3JvcHBpbmdbMF1bMV0sMyksbi5jcm9wcGluZ1sxXVswXSxlLnNoYXBlWzNdLW4uY3JvcHBpbmdbMV1bMV0tbi5jcm9wcGluZ1sxXVswXSw0KX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17Y3JvcHBpbmc6dGhpcy5jcm9wcGluZyxkYXRhRm9ybWF0OnRoaXMuZGF0YUZvcm1hdH0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiQ3JvcHBpbmcyRFwiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQ3JvcHBpbmcyRCk7dmFyIFVwU2FtcGxpbmcyRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLkRFRkFVTFRfU0laRT1bMiwyXSxuLmlucHV0U3BlYz1be25kaW06NH1dLG4uc2l6ZT1udWxsPT10LnNpemU/bi5ERUZBVUxUX1NJWkU6dC5zaXplLG4uZGF0YUZvcm1hdD1udWxsPT10LmRhdGFGb3JtYXQ/XCJjaGFubmVsc0xhc3RcIjp0LmRhdGFGb3JtYXQsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe2lmKFwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0KXt2YXIgdD1udWxsPT1lWzJdP251bGw6dGhpcy5zaXplWzBdKmVbMl0sbj1udWxsPT1lWzNdP251bGw6dGhpcy5zaXplWzFdKmVbM107cmV0dXJuW2VbMF0sZVsxXSx0LG5dfXQ9bnVsbD09ZVsxXT9udWxsOnRoaXMuc2l6ZVswXSplWzFdLG49bnVsbD09ZVsyXT9udWxsOnRoaXMuc2l6ZVsxXSplWzJdO3JldHVybltlWzBdLHQsbixlWzNdXX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgdD1nZXRFeGFjdGx5T25lVGVuc29yKGUpLHI9dC5zaGFwZTtpZihcImNoYW5uZWxzRmlyc3RcIj09PW4uZGF0YUZvcm1hdCl7dD10cmFuc3Bvc2UodCxbMCwyLDMsMV0pO3ZhciBpPW4uc2l6ZVswXSpyWzJdLGE9bi5zaXplWzFdKnJbM10sbz10LnJlc2l6ZU5lYXJlc3ROZWlnaGJvcihbaSxhXSk7cmV0dXJuIHRyYW5zcG9zZShvLFswLDMsMSwyXSl9aT1uLnNpemVbMF0qclsxXSxhPW4uc2l6ZVsxXSpyWzJdO3JldHVybiB0LnJlc2l6ZU5lYXJlc3ROZWlnaGJvcihbaSxhXSl9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e3NpemU6dGhpcy5zaXplLGRhdGFGb3JtYXQ6dGhpcy5kYXRhRm9ybWF0fSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJVcFNhbXBsaW5nMkRcIix0fShMYXllcik7ZnVuY3Rpb24gZGVwdGh3aXNlQ29udjJkJDEoZSx0LG4scixpLGEpe3JldHVybiB2b2lkIDA9PT1uJiYobj1bMSwxXSksdm9pZCAwPT09ciYmKHI9XCJ2YWxpZFwiKSx0aWR5KGZ1bmN0aW9uKCl7bnVsbD09aSYmKGk9aW1hZ2VEYXRhRm9ybWF0KCkpLGNoZWNrRGF0YUZvcm1hdChpKTt2YXIgbz1wcmVwcm9jZXNzQ29udjJESW5wdXQoZSxpKTtpZig0IT09ZS5yYW5rKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW5wdXQgZm9yIGRlcHRod2lzZUNvbnYyZCBpcyByZXF1aXJlZCB0byBiZSA0LUQsIGJ1dCBpcyBpbnN0ZWFkIFwiK2UucmFuaytcIi1EXCIpO2lmKDQhPT10LnJhbmspdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJkZXB0aHdpc2VLZXJuZWwgaXMgcmVxdWlyZWQgdG8gYmUgNC1ELCBidXQgaXMgaW5zdGVhZCBcIit0LnJhbmsrXCItRFwiKTtyZXR1cm4gbz1kZXB0aHdpc2VDb252MmQobyx0LG4sXCJzYW1lXCI9PT1yP1wic2FtZVwiOlwidmFsaWRcIixcIk5IV0NcIixhKSxcImNoYW5uZWxzRmlyc3RcIj09PWkmJihvPXRyYW5zcG9zZShvLFswLDMsMSwyXSkpLG99KX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoVXBTYW1wbGluZzJEKTt2YXIgRGVwdGh3aXNlQ29udjJEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsMix0KXx8dGhpcztyZXR1cm4gbi5kZXB0aHdpc2VLZXJuZWw9bnVsbCxuLmRlcHRoTXVsdGlwbGllcj1udWxsPT10LmRlcHRoTXVsdGlwbGllcj8xOnQuZGVwdGhNdWx0aXBsaWVyLG4uZGVwdGh3aXNlSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5kZXB0aHdpc2VJbml0aWFsaXplcnx8bi5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUiksbi5kZXB0aHdpc2VDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5kZXB0aHdpc2VDb25zdHJhaW50KSxuLmRlcHRod2lzZVJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQuZGVwdGh3aXNlUmVndWxhcml6ZXIpLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe2lmKChlPWdldEV4YWN0bHlPbmVTaGFwZShlKSkubGVuZ3RoPDQpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnB1dHMgdG8gRGVwdGh3aXNlQ29udjJEIHNob3VsZCBoYXZlIHJhbmsgNC4gUmVjZWl2ZWQgaW5wdXQgc2hhcGU6IFwiK0pTT04uc3RyaW5naWZ5KGUpK1wiLlwiKTt2YXIgdD1cImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdD8xOjM7aWYobnVsbD09ZVt0XXx8ZVt0XTwwKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGNoYW5uZWwgZGltZW5zaW9uIG9mIHRoZSBpbnB1dHMgdG8gRGVwdGh3aXNlQ29udjJEIHNob3VsZCBiZSBkZWZpbmVkLCBidXQgaXMgbm90IChcIitlW3RdK1wiKS5cIik7dmFyIG49ZVt0XSxyPVt0aGlzLmtlcm5lbFNpemVbMF0sdGhpcy5rZXJuZWxTaXplWzFdLG4sdGhpcy5kZXB0aE11bHRpcGxpZXJdO3RoaXMuZGVwdGh3aXNlS2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwiZGVwdGh3aXNlX2tlcm5lbFwiLHIsbnVsbCx0aGlzLmRlcHRod2lzZUluaXRpYWxpemVyLHRoaXMuZGVwdGh3aXNlUmVndWxhcml6ZXIsITAsdGhpcy5kZXB0aHdpc2VDb25zdHJhaW50KSx0aGlzLnVzZUJpYXM/dGhpcy5iaWFzPXRoaXMuYWRkV2VpZ2h0KFwiYmlhc1wiLFtuKnRoaXMuZGVwdGhNdWx0aXBsaWVyXSxudWxsLHRoaXMuYmlhc0luaXRpYWxpemVyLHRoaXMuYmlhc1JlZ3VsYXJpemVyLCEwLHRoaXMuYmlhc0NvbnN0cmFpbnQpOnRoaXMuYmlhcz1udWxsLHRoaXMuYnVpbHQ9ITB9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9ZGVwdGh3aXNlQ29udjJkJDEoZT1nZXRFeGFjdGx5T25lVGVuc29yKGUpLG4uZGVwdGh3aXNlS2VybmVsLnJlYWQoKSxuLnN0cmlkZXMsbi5wYWRkaW5nLG4uZGF0YUZvcm1hdCxudWxsKTtyZXR1cm4gbi51c2VCaWFzJiYodD1iaWFzQWRkKHQsbi5iaWFzLnJlYWQoKSxuLmRhdGFGb3JtYXQpKSxudWxsIT1uLmFjdGl2YXRpb24mJih0PW4uYWN0aXZhdGlvbi5hcHBseSh0KSksdH0pfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7ZT1nZXRFeGFjdGx5T25lU2hhcGUoZSk7dmFyIHQ9XCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/ZVsyXTplWzFdLG49XCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/ZVszXTplWzJdLHI9XCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/ZVsxXSp0aGlzLmRlcHRoTXVsdGlwbGllcjplWzNdKnRoaXMuZGVwdGhNdWx0aXBsaWVyLGk9Y29udk91dHB1dExlbmd0aCh0LHRoaXMua2VybmVsU2l6ZVswXSx0aGlzLnBhZGRpbmcsdGhpcy5zdHJpZGVzWzBdKSxhPWNvbnZPdXRwdXRMZW5ndGgobix0aGlzLmtlcm5lbFNpemVbMV0sdGhpcy5wYWRkaW5nLHRoaXMuc3RyaWRlc1sxXSk7cmV0dXJuXCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/W2VbMF0scixpLGFdOltlWzBdLGksYSxyXX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIHQuZGVwdGhNdWx0aXBsaWVyPXRoaXMuZGVwdGhNdWx0aXBsaWVyLHQuZGVwdGh3aXNlSW5pdGlhbGl6ZXI9c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5kZXB0aHdpc2VJbml0aWFsaXplciksdC5kZXB0aHdpc2VSZWd1bGFyaXplcj1zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmRlcHRod2lzZVJlZ3VsYXJpemVyKSx0LmRlcHRod2lzZUNvbnN0cmFpbnQ9c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmRlcHRod2lzZVJlZ3VsYXJpemVyKSx0fSx0LmNsYXNzTmFtZT1cIkRlcHRod2lzZUNvbnYyRFwiLHR9KEJhc2VDb252KTtmdW5jdGlvbiBtYXBBY3RpdmF0aW9uVG9GdXNlZEtlcm5lbChlKXtyZXR1cm5cInJlbHVcIj09PWU/XCJyZWx1XCI6XCJsaW5lYXJcIj09PWU/XCJsaW5lYXJcIjpudWxsfXNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhEZXB0aHdpc2VDb252MkQpO3ZhciBEcm9wb3V0PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7aWYobi5yYXRlPU1hdGgubWF4KE1hdGgubWluKHQucmF0ZSwxKSwwKSxuLm5vaXNlU2hhcGU9dC5ub2lzZVNoYXBlLG4uc2VlZD10LnNlZWQsbnVsbCE9bi5zZWVkKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiTm9uLWRlZmF1bHQgc2VlZCBpcyBub3QgaW1wbGVtZW50ZWQgaW4gRHJvcG91dCBsYXllciB5ZXQ6IFwiK24uc2VlZCk7cmV0dXJuIG4uc3VwcG9ydHNNYXNraW5nPSEwLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmdldE5vaXNlU2hhcGU9ZnVuY3Rpb24oZSl7aWYobnVsbD09dGhpcy5ub2lzZVNoYXBlKXJldHVybiB0aGlzLm5vaXNlU2hhcGU7Zm9yKHZhciB0PWUuc2hhcGUsbj1bXSxyPTA7cjx0aGlzLm5vaXNlU2hhcGUubGVuZ3RoOysrciluLnB1c2gobnVsbD09dGhpcy5ub2lzZVNoYXBlW3JdP3Rbcl06dGhpcy5ub2lzZVNoYXBlW3JdKTtyZXR1cm4gbn0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtuLmludm9rZUNhbGxIb29rKGUsdCk7dmFyIHI9Z2V0RXhhY3RseU9uZVRlbnNvcihlKTtpZihudWxsIT1uLm5vaXNlU2hhcGUmJiF1dGlsLmFycmF5c0VxdWFsKHIuc2hhcGUsbi5ub2lzZVNoYXBlKSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIk5vbi1kZWZhdWx0IG5vaXNlIHNoYXBlIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBEcm9wb3V0IGxheWVyIHlldDogXCIrSlNPTi5zdHJpbmdpZnkobi5ub2lzZVNoYXBlKSk7aWYoMDxuLnJhdGUmJm4ucmF0ZTwxKXt2YXIgaT1udWxsIT10LnRyYWluaW5nJiZ0LnRyYWluaW5nLGE9bi5nZXROb2lzZVNoYXBlKHIpO3JldHVybiBpblRyYWluUGhhc2UoZnVuY3Rpb24oKXtyZXR1cm4gZHJvcG91dChyLG4ucmF0ZSxhLG4uc2VlZCl9LGZ1bmN0aW9uKCl7cmV0dXJuIHJ9LGkpfXJldHVybiBlfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtyYXRlOnRoaXMucmF0ZSxub2lzZVNoYXBlOnRoaXMubm9pc2VTaGFwZSxzZWVkOnRoaXMuc2VlZH0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtyZXR1cm4gZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpfSx0LmNsYXNzTmFtZT1cIkRyb3BvdXRcIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKERyb3BvdXQpO3ZhciBEZW5zZT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO2lmKG4uYWN0aXZhdGlvbj1udWxsLG4udXNlQmlhcz0hMCxuLmtlcm5lbD1udWxsLG4uYmlhcz1udWxsLG4uREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVI9XCJnbG9yb3ROb3JtYWxcIixuLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUj1cInplcm9zXCIsbnVsbD09dC5iYXRjaElucHV0U2hhcGUmJm51bGw9PXQuaW5wdXRTaGFwZSYmbnVsbCE9dC5pbnB1dERpbSl7dmFyIHI9bnVsbDtudWxsIT10LmJhdGNoU2l6ZSYmKHI9dC5iYXRjaFNpemUpLG4uYmF0Y2hJbnB1dFNoYXBlPVtyLHQuaW5wdXREaW1dfXJldHVybiBuLnVuaXRzPXQudW5pdHMsYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKG4udW5pdHMsXCJ1bml0c1wiKSxuLmFjdGl2YXRpb249Z2V0QWN0aXZhdGlvbih0LmFjdGl2YXRpb24pLG51bGwhPXQudXNlQmlhcyYmKG4udXNlQmlhcz10LnVzZUJpYXMpLG4ua2VybmVsSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5rZXJuZWxJbml0aWFsaXplcnx8bi5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUiksbi5iaWFzSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5iaWFzSW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKSxuLmtlcm5lbENvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludCh0Lmtlcm5lbENvbnN0cmFpbnQpLG4uYmlhc0NvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludCh0LmJpYXNDb25zdHJhaW50KSxuLmtlcm5lbFJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQua2VybmVsUmVndWxhcml6ZXIpLG4uYmlhc1JlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQuYmlhc1JlZ3VsYXJpemVyKSxuLmFjdGl2aXR5UmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5hY3Rpdml0eVJlZ3VsYXJpemVyKSxuLnN1cHBvcnRzTWFza2luZz0hMCxuLmlucHV0U3BlYz1be21pbk5EaW06Mn1dLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe3ZhciB0LG49KGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpKVtlLmxlbmd0aC0xXTtudWxsPT10aGlzLmtlcm5lbCYmKHRoaXMua2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwia2VybmVsXCIsW24sdGhpcy51bml0c10sbnVsbCx0aGlzLmtlcm5lbEluaXRpYWxpemVyLHRoaXMua2VybmVsUmVndWxhcml6ZXIsITAsdGhpcy5rZXJuZWxDb25zdHJhaW50KSx0aGlzLnVzZUJpYXMmJih0aGlzLmJpYXM9dGhpcy5hZGRXZWlnaHQoXCJiaWFzXCIsW3RoaXMudW5pdHNdLG51bGwsdGhpcy5iaWFzSW5pdGlhbGl6ZXIsdGhpcy5iaWFzUmVndWxhcml6ZXIsITAsdGhpcy5iaWFzQ29uc3RyYWludCkpKSx0aGlzLmlucHV0U3BlYz1be21pbk5EaW06MixheGVzOih0PXt9LHRbLTFdPW4sdCl9XSx0aGlzLmJ1aWx0PSEwfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7dmFyIHQ9KGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpKS5zbGljZSgpO3JldHVybiB0W3QubGVuZ3RoLTFdPXRoaXMudW5pdHMsdH0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtuLmludm9rZUNhbGxIb29rKGUsdCk7dmFyIHIsaT1nZXRFeGFjdGx5T25lVGVuc29yKGUpLGE9bWFwQWN0aXZhdGlvblRvRnVzZWRLZXJuZWwobi5hY3RpdmF0aW9uLmdldENsYXNzTmFtZSgpKTtyZXR1cm4gbnVsbCE9YT9yPWRvdChpLG4ua2VybmVsLnJlYWQoKSxhLG4uYmlhcz9uLmJpYXMucmVhZCgpOm51bGwpOihyPWRvdChpLG4ua2VybmVsLnJlYWQoKSksbnVsbCE9bi5iaWFzJiYocj1iaWFzQWRkKHIsbi5iaWFzLnJlYWQoKSkpLG51bGwhPW4uYWN0aXZhdGlvbiYmKHI9bi5hY3RpdmF0aW9uLmFwcGx5KHIpKSkscn0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17dW5pdHM6dGhpcy51bml0cyxhY3RpdmF0aW9uOnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKSx1c2VCaWFzOnRoaXMudXNlQmlhcyxrZXJuZWxJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxiaWFzSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLGtlcm5lbFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMua2VybmVsUmVndWxhcml6ZXIpLGJpYXNSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmJpYXNSZWd1bGFyaXplciksYWN0aXZpdHlSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLGtlcm5lbENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpLGJpYXNDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5iaWFzQ29uc3RyYWludCl9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIkRlbnNlXCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhEZW5zZSk7dmFyIEZsYXR0ZW49ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0fHx7fSl8fHRoaXM7cmV0dXJuIG4uaW5wdXRTcGVjPVt7bWluTkRpbTozfV0sbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wLG49KGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpKS5zbGljZSgxKTt0PG4ubGVuZ3RoO3QrKyl7aWYobnVsbD09blt0XSl0aHJvdyBuZXcgVmFsdWVFcnJvcignVGhlIHNoYXBlIG9mIHRoZSBpbnB1dCB0byBcIkZsYXR0ZW5cIiBpcyBub3QgZnVsbHkgZGVmaW5lZCAoZ290ICcrZS5zbGljZSgxKSsnKS4gTWFrZSBzdXJlIHRvIHBhc3MgYSBjb21wbGV0ZSBcImlucHV0X3NoYXBlXCIgb3IgXCJiYXRjaF9pbnB1dF9zaGFwZVwiIGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBsYXllciBpbiB5b3VyIG1vZGVsLicpfXJldHVybltlWzBdLGFycmF5UHJvZChlLDEpXX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gbi5pbnZva2VDYWxsSG9vayhlLHQpLGJhdGNoRmxhdHRlbihnZXRFeGFjdGx5T25lVGVuc29yKGUpKX0pfSx0LmNsYXNzTmFtZT1cIkZsYXR0ZW5cIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEZsYXR0ZW4pO3ZhciBBY3RpdmF0aW9uJDE9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5zdXBwb3J0c01hc2tpbmc9ITAsbi5hY3RpdmF0aW9uPWdldEFjdGl2YXRpb24odC5hY3RpdmF0aW9uKSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe24uaW52b2tlQ2FsbEhvb2soZSx0KTt2YXIgcj1nZXRFeGFjdGx5T25lVGVuc29yKGUpO3JldHVybiBuLmFjdGl2YXRpb24uYXBwbHkocil9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2FjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pfSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJBY3RpdmF0aW9uXCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhBY3RpdmF0aW9uJDEpO3ZhciBSZXBlYXRWZWN0b3I9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5uPXQubixuLmlucHV0U3BlYz1be25kaW06Mn1dLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtyZXR1cm5bZVswXSx0aGlzLm4sZVsxXV19LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIHJlcGVhdChlPWdldEV4YWN0bHlPbmVUZW5zb3IoZSksbi5uKX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17bjp0aGlzLm59LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIlJlcGVhdFZlY3RvclwiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoUmVwZWF0VmVjdG9yKTt2YXIgUmVzaGFwZT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO24udGFyZ2V0U2hhcGU9dC50YXJnZXRTaGFwZTtmb3IodmFyIHI9MDtyPG4udGFyZ2V0U2hhcGUubGVuZ3RoOysrciluLmlzVW5rbm93bihuLnRhcmdldFNoYXBlW3JdKSYmKG4udGFyZ2V0U2hhcGVbcl09bnVsbCk7cmV0dXJuIG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmlzVW5rbm93bj1mdW5jdGlvbihlKXtyZXR1cm4gZTwwfHxudWxsPT1lfSx0LnByb3RvdHlwZS5maXhVbmtub3duRGltZW5zaW9uPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPVwiVG90YWwgc2l6ZSBvZiBuZXcgYXJyYXkgbXVzdCBiZSB1bmNoYW5nZWQuXCIscj10LnNsaWNlKCksaT0xLGE9bnVsbCxvPTA7bzxyLmxlbmd0aDsrK28pe3ZhciBzPXJbb107aWYodGhpcy5pc1Vua25vd24ocykpe2lmKG51bGwhPT1hKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ2FuIG9ubHkgc3BlY2lmaXkgb25lIHVua25vd24gZGltZW5zaW9uLlwiKTthPW99ZWxzZSBpKj1zfXZhciBsPWFycmF5UHJvZChlKTtpZihudWxsIT09YSl7aWYoMD09PWl8fGwlaSE9MCl0aHJvdyBuZXcgVmFsdWVFcnJvcihuKTtyW2FdPWwvaX1lbHNlIGlmKGwhPT1pKXRocm93IG5ldyBWYWx1ZUVycm9yKG4pO3JldHVybiByfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PSExLG49MDtuPGUubGVuZ3RoOysrbilpZih0aGlzLmlzVW5rbm93bihlW25dKSl7dD0hMDticmVha31yZXR1cm4gdD9lLnNsaWNlKDAsMSkuY29uY2F0KHRoaXMudGFyZ2V0U2hhcGUpOmUuc2xpY2UoMCwxKS5jb25jYXQodGhpcy5maXhVbmtub3duRGltZW5zaW9uKGUuc2xpY2UoMSksdGhpcy50YXJnZXRTaGFwZSkpfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe24uaW52b2tlQ2FsbEhvb2soZSx0KTt2YXIgcj1nZXRFeGFjdGx5T25lVGVuc29yKGUpLGk9ci5zaGFwZSxhPWkuc2xpY2UoMCwxKS5jb25jYXQobi5maXhVbmtub3duRGltZW5zaW9uKGkuc2xpY2UoMSksbi50YXJnZXRTaGFwZSkpO3JldHVybiByLnJlc2hhcGUoYSl9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e3RhcmdldFNoYXBlOnRoaXMudGFyZ2V0U2hhcGV9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIlJlc2hhcGVcIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFJlc2hhcGUpO3ZhciBQZXJtdXRlPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7aWYobnVsbD09dC5kaW1zKXRocm93IG5ldyBFcnJvcihcIlJlcXVpcmVkIGNvbmZpZ3VyYXRpb24gZmllbGQgYGRpbXNgIGlzIG1pc3NpbmcgZHVyaW5nIFBlcm11dGUgY29uc3RydWN0b3IgY2FsbC5cIik7aWYoIUFycmF5LmlzQXJyYXkodC5kaW1zKSl0aHJvdyBuZXcgRXJyb3IoXCJQZXJtdXRlIGNvbnN0cnVjdG9yIHJlcXVpcmVzIGBkaW1zYCB0byBiZSBhbiBBcnJheSwgYnV0IHJlY2VpdmVkIFwiK3QuZGltcytcIiBpbnN0ZWFkLlwiKTt2YXIgcj1yYW5nZSgxLHQuZGltcy5sZW5ndGgrMSk7aWYoIXV0aWwuYXJyYXlzRXF1YWwodC5kaW1zLnNsaWNlKCkuc29ydCgpLHIpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGVybXV0YXRpb24gYGRpbXNgOiBcIitKU09OLnN0cmluZ2lmeSh0LmRpbXMpK1wiIGBkaW1zYCBtdXN0IGNvbnRhaW4gY29uc2VjdXRpdmUgaW50ZWdlcnMgc3RhcnRpbmcgZnJvbSAxLlwiKTtyZXR1cm4gbi5kaW1zPXQuZGltcyxuLmRpbXNJbmNsdWRpbmdCYXRjaD1bMF0uY29uY2F0KG4uZGltcyksbi5pbnB1dFNwZWM9W25ldyBJbnB1dFNwZWMoe25kaW06bi5kaW1zLmxlbmd0aCsxfSldLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXt2YXIgdD0oZT1nZXRFeGFjdGx5T25lU2hhcGUoZSkpLnNsaWNlKCk7cmV0dXJuIHRoaXMuZGltcy5mb3JFYWNoKGZ1bmN0aW9uKG4scil7dFtyKzFdPWVbbl19KSx0fSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRyYW5zcG9zZShnZXRFeGFjdGx5T25lVGVuc29yKGUpLHRoaXMuZGltc0luY2x1ZGluZ0JhdGNoKX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2RpbXM6dGhpcy5kaW1zfSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJQZXJtdXRlXCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhQZXJtdXRlKTt2YXIgTWFza2luZz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLG51bGw9PXQ/e306dCl8fHRoaXM7cmV0dXJuIG4uc3VwcG9ydHNNYXNraW5nPSEwLG4ubWFza1ZhbHVlPW51bGwhPXQ/bnVsbD09dC5tYXNrVmFsdWU/MDp0Lm1hc2tWYWx1ZTowLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtyZXR1cm4gZX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyksbj17bWFza1ZhbHVlOnRoaXMubWFza1ZhbHVlfTtyZXR1cm4gT2JqZWN0LmFzc2lnbihuLHQpLG59LHQucHJvdG90eXBlLmNvbXB1dGVNYXNrPWZ1bmN0aW9uKGUsdCl7dmFyIG49Z2V0RXhhY3RseU9uZVRlbnNvcihlKTtyZXR1cm4gYW55KG5vdEVxdWFsKG4sdGhpcy5tYXNrVmFsdWUpLC0xKX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtuLmludm9rZUNhbGxIb29rKGUsdCk7dmFyIHI9Z2V0RXhhY3RseU9uZVRlbnNvcihlKSxpPWFueShub3RFcXVhbChyLG4ubWFza1ZhbHVlKSwtMSwhMCk7cmV0dXJuIHIubXVsKGkuYXNUeXBlKHIuZHR5cGUpKX0pfSx0LmNsYXNzTmFtZT1cIk1hc2tpbmdcIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE1hc2tpbmcpO3ZhciBFbWJlZGRpbmc9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztpZihuLmVtYmVkZGluZ3M9bnVsbCxuLkRFRkFVTFRfRU1CRURESU5HU19JTklUSUFMSVpFUj1cInJhbmRvbVVuaWZvcm1cIixudWxsPT10LmJhdGNoSW5wdXRTaGFwZSYmbnVsbD09dC5pbnB1dFNoYXBlKXt2YXIgcj1udWxsO251bGwhPXQuYmF0Y2hTaXplJiYocj10LmJhdGNoU2l6ZSksbnVsbD09dC5pbnB1dExlbmd0aD9uLmJhdGNoSW5wdXRTaGFwZT1bcixudWxsXTpuLmJhdGNoSW5wdXRTaGFwZT1bcl0uY29uY2F0KHRvTGlzdCh0LmlucHV0TGVuZ3RoKSl9cmV0dXJuIG4uaW5wdXREaW09dC5pbnB1dERpbSxhc3NlcnRQb3NpdGl2ZUludGVnZXIobi5pbnB1dERpbSxcImlucHV0RGltXCIpLG4ub3V0cHV0RGltPXQub3V0cHV0RGltLGFzc2VydFBvc2l0aXZlSW50ZWdlcihuLm91dHB1dERpbSxcIm91dHB1dERpbVwiKSxuLmVtYmVkZGluZ3NJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcih0LmVtYmVkZGluZ3NJbml0aWFsaXplcnx8bi5ERUZBVUxUX0VNQkVERElOR1NfSU5JVElBTElaRVIpLG4uZW1iZWRkaW5nc1JlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQuZW1iZWRkaW5nc1JlZ3VsYXJpemVyKSxuLmFjdGl2aXR5UmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5hY3Rpdml0eVJlZ3VsYXJpemVyKSxuLmVtYmVkZGluZ3NDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5lbWJlZGRpbmdzQ29uc3RyYWludCksbi5tYXNrWmVybz10Lm1hc2taZXJvLG4uc3VwcG9ydHNNYXNraW5nPXQubWFza1plcm8sbi5pbnB1dExlbmd0aD10LmlucHV0TGVuZ3RoLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe3RoaXMuZW1iZWRkaW5ncz10aGlzLmFkZFdlaWdodChcImVtYmVkZGluZ3NcIixbdGhpcy5pbnB1dERpbSx0aGlzLm91dHB1dERpbV0sdGhpcy5kdHlwZSx0aGlzLmVtYmVkZGluZ3NJbml0aWFsaXplcix0aGlzLmVtYmVkZGluZ3NSZWd1bGFyaXplciwhMCx0aGlzLmVtYmVkZGluZ3NDb25zdHJhaW50KSx0aGlzLmJ1aWx0PSEwfSx0LnByb3RvdHlwZS53YXJuT25JbmNvbXBhdGlibGVJbnB1dFNoYXBlPWZ1bmN0aW9uKGUpe30sdC5wcm90b3R5cGUuY29tcHV0ZU1hc2s9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIG4ubWFza1plcm8/KGU9Z2V0RXhhY3RseU9uZVRlbnNvcihlKSxub3RFcXVhbChlLHplcm9zTGlrZShlKSkpOm51bGx9KX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe2lmKGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpLG51bGw9PXRoaXMuaW5wdXRMZW5ndGgpcmV0dXJuIGUuY29uY2F0KFt0aGlzLm91dHB1dERpbV0pO3ZhciB0PXRvTGlzdCh0aGlzLmlucHV0TGVuZ3RoKTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoLTEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ1wiaW5wdXRMZW5ndGhcIiBpcyAnK3RoaXMuaW5wdXRMZW5ndGgrXCIsIGJ1dCByZWNlaXZlZCBpbnB1dCBzaGFwZSBoYXMgc2hhcGUgXCIrZSk7Zm9yKHZhciBuPTAscj0wO3I8dC5sZW5ndGg7KytyKXt2YXIgaT10W3JdLGE9ZVtyKzFdO2lmKG51bGwhPWkmJm51bGwhPWEmJmkhPT1hKXRocm93IG5ldyBWYWx1ZUVycm9yKCdcImlucHV0TGVuZ3RoXCIgaXMgJyt0aGlzLmlucHV0TGVuZ3RoK1wiLCBidXQgcmVjZWl2ZWQgaW5wdXQgc2hhcGUgaGFzIHNoYXBlIFwiK2UpO251bGw9PWkmJih0W25dPWEpLG4rK31yZXR1cm5bZVswXV0uY29uY2F0KHQsW3RoaXMub3V0cHV0RGltXSl9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7bi5pbnZva2VDYWxsSG9vayhlLHQpO3ZhciByPWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7cmV0dXJuXCJpbnQzMlwiIT09ci5kdHlwZSYmKHI9Y2FzdCQxKHIsXCJpbnQzMlwiKSksZ2F0aGVyJDEobi5lbWJlZGRpbmdzLnJlYWQoKSxyLmFzMUQoKSkucmVzaGFwZShnZXRFeGFjdGx5T25lU2hhcGUobi5jb21wdXRlT3V0cHV0U2hhcGUoci5zaGFwZSkpKX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17aW5wdXREaW06dGhpcy5pbnB1dERpbSxvdXRwdXREaW06dGhpcy5vdXRwdXREaW0sZW1iZWRkaW5nc0luaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuZW1iZWRkaW5nc0luaXRpYWxpemVyKSxlbWJlZGRpbmdzUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5lbWJlZGRpbmdzUmVndWxhcml6ZXIpLGFjdGl2aXR5UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxlbWJlZGRpbmdzQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMuZW1iZWRkaW5nc0NvbnN0cmFpbnQpLG1hc2taZXJvOnRoaXMubWFza1plcm8saW5wdXRMZW5ndGg6dGhpcy5pbnB1dExlbmd0aH0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiRW1iZWRkaW5nXCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhFbWJlZGRpbmcpO3ZhciBNZXJnZT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHR8fHt9KXx8dGhpcztyZXR1cm4gbi5zdXBwb3J0c01hc2tpbmc9ITAsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUubWVyZ2VGdW5jdGlvbj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcn0sdC5wcm90b3R5cGUuY29tcHV0ZUVsZW1lbnR3aXNlT3BPdXRwdXRTaGFwZT1mdW5jdGlvbihlLHQpe2lmKG51bGw9PWV8fG51bGw9PXQpcmV0dXJuIG51bGw7aWYoZS5sZW5ndGg8dC5sZW5ndGgpcmV0dXJuIHRoaXMuY29tcHV0ZUVsZW1lbnR3aXNlT3BPdXRwdXRTaGFwZSh0LGUpO2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gZTtmb3IodmFyIG49ZS5zbGljZSgwLGUubGVuZ3RoLXQubGVuZ3RoKSxyPTA7cjx0Lmxlbmd0aDsrK3Ipe3ZhciBpPWVbZS5sZW5ndGgtdC5sZW5ndGgrcl0sYT10W3JdO2lmKG51bGw9PWl8fG51bGw9PWF8fGk8MHx8YTwwKW4ucHVzaChudWxsKTtlbHNlIGlmKDE9PT1pKW4ucHVzaChhKTtlbHNlIGlmKDE9PT1hKW4ucHVzaChpKTtlbHNle2lmKGkhPT1hKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiT3BlcmFuZHMgY291bGQgbm90IGJlIGJyb2FkY2FzdCB0b2dldGhlciB3aXRoIHNoYXBlcyBcIitKU09OLnN0cmluZ2lmeShlKStcIiBcIitKU09OLnN0cmluZ2lmeSh0KSk7bi5wdXNoKGkpfX1yZXR1cm4gbn0sdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSYmIUFycmF5LmlzQXJyYXkoZVswXSkmJihlPVtnZXRFeGFjdGx5T25lU2hhcGUoZSldKSwoZT1lKS5sZW5ndGg8Mil0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkEgbWVyZ2UgbGF5ZXIgc2hvdWxkIGJlIGNhbGxlZCBvbiBhbiBBcnJheSBvZiBhdCBsZWFzdCAyIGlucHV0cy4gR290IFwiK2UubGVuZ3RoK1wiIGlucHV0KHMpLlwiKTtmb3IodmFyIHQ9W10sbj0wLHI9ZTtuPHIubGVuZ3RoO24rKyl7bnVsbCE9KG89cltuXSkmJm51bGwhPT1vWzBdJiZ0LnB1c2gob1swXSl9aWYoKHQ9dW5pcXVlKHQpKS5sZW5ndGg+MSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNhbiBub3QgbWVyZ2UgdGVuc29ycyB3aXRoIGRpZmZlcmVudCBiYXRjaCBzaXplcy4gR290IHRlbnNvcnMgd2l0aCBzaGFwZXM6IFwiK0pTT04uc3RyaW5naWZ5KGUpK1wiLlwiKTtmb3IodmFyIGk9bnVsbD09ZVswXT9udWxsOmVbMF0uc2xpY2UoMSksYT0xO2E8ZS5sZW5ndGg7KythKXt2YXIgbz1udWxsPT1lW2FdP251bGw6ZVthXS5zbGljZSgxKTtpPXRoaXMuY29tcHV0ZUVsZW1lbnR3aXNlT3BPdXRwdXRTaGFwZShpLG8pfXZhciBzPWUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmxlbmd0aH0pOy0xPT09ZS5pbmRleE9mKG51bGwpJiYxPT09dW5pcXVlKHMpLmxlbmd0aD90aGlzLnJlc2hhcGVSZXF1aXJlZD0hMTp0aGlzLnJlc2hhcGVSZXF1aXJlZD0hMH0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtpZihlPWUsbi5yZXNoYXBlUmVxdWlyZWQpe3ZhciB0PVtdLHI9ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUucmFua30pO2lmKC0xPT09ci5pbmRleE9mKG51bGwpKXtmb3IodmFyIGk9bWF4JDEociksYT0wLG89ZTthPG8ubGVuZ3RoO2ErKyl7Zm9yKHZhciBzPShoPW9bYV0pLnJhbmssbD0wO2w8aS1zOysrbCloPWV4cGFuZERpbXMkMShoLDEpO3QucHVzaChoKX1yZXR1cm4gbi5tZXJnZUZ1bmN0aW9uKHQpfWZvcih2YXIgdT0hMSxjPTAscD1lO2M8cC5sZW5ndGg7YysrKXt2YXIgaDtpZihudWxsPT0ocz0oaD1wW2NdKS5yYW5rKSl7dmFyIGQ9aC5zaGFwZSxmPWRbMF0sZz1kLnNsaWNlKDEpLmNvbmNhdChbZl0pLG09aC5yZXNoYXBlKFtmXS5jb25jYXQoYXJyYXlQcm9kKGQuc2xpY2UoMSkpKSk7bT0obT10cmFuc3Bvc2UobSxbMSwwXSkpLnJlc2hhcGUoZyksdC5wdXNoKG0pLHU9ITB9ZWxzZSBpZihzPjEpe3ZhciB5PXJhbmdlKDEscykuY29uY2F0KFswXSk7dC5wdXNoKHRyYW5zcG9zZShoLHkpKSx1PSEwfWVsc2UgdC5wdXNoKGgpfXZhciB2PW4ubWVyZ2VGdW5jdGlvbih0KSxiPXYucmFuaztpZih1KWlmKG51bGw9PWIpe3ZhciB3PXYuc2hhcGU7Zz1bZj13W3cubGVuZ3RoLTFdXS5jb25jYXQody5zbGljZSgwLHcubGVuZ3RoLTEpKTt2PXRyYW5zcG9zZSh2LnJlc2hhcGUoWy0xLGZdKSxbMSwwXSkucmVzaGFwZShnKX1lbHNlIGlmKGI+MSl7eT1bYi0xXS5jb25jYXQocmFuZ2UoMCxiLTEpKTt2PXRyYW5zcG9zZSh2LHkpfXJldHVybiB2fXJldHVybiBuLm1lcmdlRnVuY3Rpb24oZSl9KX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3ZhciB0O3Q9bnVsbD09KGU9ZSlbMF0/bnVsbDplWzBdLnNsaWNlKDEpO2Zvcih2YXIgbj0xO248ZS5sZW5ndGg7KytuKXt2YXIgcj1udWxsPT1lW25dP251bGw6ZVtuXS5zbGljZSgxKTt0PXRoaXMuY29tcHV0ZUVsZW1lbnR3aXNlT3BPdXRwdXRTaGFwZSh0LHIpfWZvcih2YXIgaT1bXSxhPTAsbz1lO2E8by5sZW5ndGg7YSsrKXtudWxsIT0ocj1vW2FdKSYmbnVsbCE9PXJbMF0mJmkucHVzaChyWzBdKX1yZXR1cm4gdD0xPT09KGk9dW5pcXVlKGkpKS5sZW5ndGg/aS5jb25jYXQodCk6W251bGxdLmNvbmNhdCh0KX0sdC5wcm90b3R5cGUuY29tcHV0ZU1hc2s9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe2lmKG51bGw9PXQpcmV0dXJuIG51bGw7aWYoIUFycmF5LmlzQXJyYXkodCkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJgbWFza2Agc2hvdWxkIGJlIGFuIEFycmF5XCIpO2lmKCFBcnJheS5pc0FycmF5KGUpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiYGlucHV0c2Agc2hvdWxkIGJlIGFuIEFycmF5XCIpO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgQXJyYXkgJ2lucHV0cycgYW5kICdtYXNrJyBhcmUgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgc2FtZSBsZW5ndGgsIGJ1dCBoYXZlIGRpZmZlcmVudCBsZW5ndGhzIChcIitlLmxlbmd0aCtcIiB2cyBcIit0Lmxlbmd0aCtcIilcIik7aWYodC5ldmVyeShmdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09ZX0pKXJldHVybiBudWxsO2Zvcih2YXIgbj0odD10Lm1hcChmdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09ZT9lOmV4cGFuZERpbXMoZSwwKX0pKVswXSxyPTE7cjx0Lmxlbmd0aC0xOysrciluPWxvZ2ljYWxBbmQobix0W3JdKTtyZXR1cm4gbn0pfSx0fShMYXllciksQWRkPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLHQpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5tZXJnZUZ1bmN0aW9uPWZ1bmN0aW9uKGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7Zm9yKHZhciB0PWVbMF0uY2xvbmUoKSxuPTE7bjxlLmxlbmd0aDsrK24pdD1hZGQodCxlW25dKTtyZXR1cm4gdH0pfSx0LmNsYXNzTmFtZT1cIkFkZFwiLHR9KE1lcmdlKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQWRkKTt2YXIgTXVsdGlwbHk9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMsdCl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLm1lcmdlRnVuY3Rpb249ZnVuY3Rpb24oZSl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtmb3IodmFyIHQ9ZVswXS5jbG9uZSgpLG49MTtuPGUubGVuZ3RoOysrbil0PW11bCh0LGVbbl0pO3JldHVybiB0fSl9LHQuY2xhc3NOYW1lPVwiTXVsdGlwbHlcIix0fShNZXJnZSk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE11bHRpcGx5KTt2YXIgQXZlcmFnZT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcyx0KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUubWVyZ2VGdW5jdGlvbj1mdW5jdGlvbihlKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe2Zvcih2YXIgdD1lWzBdLmNsb25lKCksbj0xO248ZS5sZW5ndGg7KytuKXQ9YWRkKHQsZVtuXSk7cmV0dXJuIG11bCgxL2UubGVuZ3RoLHQpfSl9LHQuY2xhc3NOYW1lPVwiQXZlcmFnZVwiLHR9KE1lcmdlKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQXZlcmFnZSk7dmFyIE1heGltdW09ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMsdCl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLm1lcmdlRnVuY3Rpb249ZnVuY3Rpb24oZSl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtmb3IodmFyIHQ9ZVswXSxuPTE7bjxlLmxlbmd0aDsrK24pdD1tYXhpbXVtKHQsZVtuXSk7cmV0dXJuIHR9KX0sdC5jbGFzc05hbWU9XCJNYXhpbXVtXCIsdH0oTWVyZ2UpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhNYXhpbXVtKTt2YXIgTWluaW11bT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcyx0KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUubWVyZ2VGdW5jdGlvbj1mdW5jdGlvbihlKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe2Zvcih2YXIgdD1lWzBdLG49MTtuPGUubGVuZ3RoOysrbil0PW1pbmltdW0odCxlW25dKTtyZXR1cm4gdH0pfSx0LmNsYXNzTmFtZT1cIk1pbmltdW1cIix0fShNZXJnZSk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE1pbmltdW0pO3ZhciBDb25jYXRlbmF0ZT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLkRFRkFVTFRfQVhJUz0tMSxudWxsPT10JiYodD17fSksbi5heGlzPW51bGw9PXQuYXhpcz9uLkRFRkFVTFRfQVhJUzp0LmF4aXMsbi5zdXBwb3J0c01hc2tpbmc9ITAsbi5yZXNoYXBlUmVxdWlyZWQ9ITEsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7aWYoIUFycmF5LmlzQXJyYXkoZSl8fCFBcnJheS5pc0FycmF5KGVbMF0pfHwxPT09ZS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBIGBDb25jYXRlbmF0ZWAgbGF5ZXIgc2hvdWxkIGJlIGNhbGxlZCBvbiBhIGxpc3Qgb2YgYXQgbGVhc3QgMiBpbnB1dHNcIik7Zm9yKHZhciB0PSEwLG49MCxyPWU9ZTtuPHIubGVuZ3RoO24rKyl7aWYobnVsbCE9KGM9cltuXSkpe3Q9ITE7YnJlYWt9fWlmKCF0KXtmb3IodmFyIGk9W10sYT0wO2E8ZS5sZW5ndGg7KythKXt2YXIgbz1lW2FdLnNsaWNlKCk7by5zcGxpY2UodGhpcy5heGlzLDEpO2Zvcih2YXIgcz0hMSxsPTAsdT1pO2w8dS5sZW5ndGg7bCsrKXt2YXIgYz11W2xdO2lmKHV0aWwuYXJyYXlzRXF1YWwoYyxvKSl7cz0hMDticmVha319c3x8aS5wdXNoKG8pfWlmKGkubGVuZ3RoPjEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBIGBDb25jYXRlbmF0ZWAgbGF5ZXIgcmVxdWlyZXMgaW5wdXRzIHdpdGggbWF0Y2hpbmcgc2hhcGVzIGV4Y2VwdCBmb3IgdGhlIGNvbmNhdCBheGlzLiBHb3QgaW5wdXQgc2hhcGVzOiBcIitKU09OLnN0cmluZ2lmeShlKSl9fSx0LnByb3RvdHlwZS5tZXJnZUZ1bmN0aW9uPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gY29uY2F0ZW5hdGUoZSx0LmF4aXMpfSl9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtpZighQXJyYXkuaXNBcnJheShlKXx8IUFycmF5LmlzQXJyYXkoZVswXSkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBIGBDb25jYXRlbmF0ZWAgbGF5ZXIgc2hvdWxkIGJlIGNhbGxlZCBvbiBhIGxpc3Qgb2YgaW5wdXRzLlwiKTtmb3IodmFyIHQ9ZSxuPXRbMF0uc2xpY2UoKSxyPXRoaXMuYXhpczwwP24ubGVuZ3RoK3RoaXMuYXhpczp0aGlzLmF4aXMsaT0wLGE9dC5zbGljZSgxKTtpPGEubGVuZ3RoO2krKyl7dmFyIG89YVtpXTtpZihudWxsPT1uW3JdfHxudWxsPT1vW3JdKXtuW3JdPW51bGw7YnJlYWt9bltyXSs9b1tyXX1yZXR1cm4gbn0sdC5wcm90b3R5cGUuY29tcHV0ZU1hc2s9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO2lmKG51bGw9PXQpcmV0dXJuIG51bGw7aWYoIUFycmF5LmlzQXJyYXkodCkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJgbWFza2Agc2hvdWxkIGJlIGFuIGFycmF5IGZvciBDb25jYXRlbmF0ZVwiKTtpZighQXJyYXkuaXNBcnJheShlKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImBpbnB1dHNgIHNob3VsZCBiZSBhbiBhcnJheSBmb3IgQ29uY2F0ZW5hdGVcIik7aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIk1pc21hdGNoIGluIHRoZSBsZW5ndGggb2YgbWFzayAoXCIrdC5sZW5ndGgrXCIpIGFuZCB0aGUgbGVnbnRoIG9mIGlucHV0cyAoXCIrZS5sZW5ndGgrXCIpXCIpO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHI9ITA7aWYodC5mb3JFYWNoKGZ1bmN0aW9uKGUpe251bGw9PWV8fChyPSExKX0pLHIpcmV0dXJuIG51bGw7Zm9yKHZhciBpPVtdLGE9MDthPGUubGVuZ3RoOysrYSludWxsPT10W2FdP2kucHVzaChvbmVzTGlrZShlW2FdKS5hc1R5cGUoXCJib29sXCIpKTp0W2FdLnJhbms8ZVthXS5yYW5rP2kucHVzaChleHBhbmREaW1zKHRbYV0sLTEpKTppLnB1c2godFthXSk7dmFyIG89Y29uY2F0KGksbi5heGlzKTtyZXR1cm4gYWxsKG8sLTEsITEpfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtheGlzOnRoaXMuYXhpc30sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiQ29uY2F0ZW5hdGVcIix0fShNZXJnZSk7ZnVuY3Rpb24gaW50ZXJwcmV0QXhpcyhlLHQpe2Zvcig7ZTwwOyllKz10O3JldHVybiBlfWZ1bmN0aW9uIGJhdGNoRG90KGUsdCxuKXtpZihlLnNoYXBlLmxlbmd0aD4zfHx0LnNoYXBlLmxlbmd0aD4zKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiYmF0Y2hEb3QgaXMgbm90IGltcGxlbWVudGVkIGZvciB0ZW5zb3JzIG9mIDREIG9yIGhpZ2hlciByYW5rIHlldFwiKTtpZih1dGlsLmFzc2VydChlLnNoYXBlLmxlbmd0aD49MixmdW5jdGlvbigpe3JldHVyblwiYmF0Y2hEb3QgcmVxdWlyZXMgdGhlIHJhbmsgb2YgeCB0byBiZSA+PSAyLCBidXQgZ290IFwiK2Uuc2hhcGUubGVuZ3RofSksdXRpbC5hc3NlcnQoZS5zaGFwZS5sZW5ndGg+PTIsZnVuY3Rpb24oKXtyZXR1cm5cImJhdGNoRG90IHJlcXVpcmVzIHRoZSByYW5rIG9mIHkgdG8gYmUgPj0gMiwgYnV0IGdvdCBcIit0LnNoYXBlLmxlbmd0aH0pLFwibnVtYmVyXCI9PXR5cGVvZiBuJiYobj1bbixuXSksXCJjb21wbGV4NjRcIj09PWUuZHR5cGV8fFwiY29tcGxleDY0XCI9PT10LmR0eXBlKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiYmF0Y2hEb3QgaXMgbm90IGltcGxlbWVudGVkIGZvciBjb21wbGV4NjQtdHlwZSBUZW5zb3JzIHlldC5cIik7dmFyIHI9ZS5zaGFwZS5sZW5ndGgsaT10LnNoYXBlLmxlbmd0aDtudWxsPT1uJiYobj1bci0xLGktMl0pO3ZhciBhPW47cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbixvO2lmKHI+aSl7bj1yLWk7Zm9yKHZhciBzPVtdLGw9MDtsPG47KytsKXMucHVzaCgxKTt0PXQucmVzaGFwZSh0LnNoYXBlLmNvbmNhdChzKSl9ZWxzZSBpZihpPnIpe249aS1yO2ZvcihzPVtdLGw9MDtsPG47KytsKXMucHVzaCgxKTtlPWUucmVzaGFwZShlLnNoYXBlLmNvbmNhdChzKSl9ZWxzZSBuPTA7aWYoMj09PWUuc2hhcGUubGVuZ3RoJiYyPT09dC5zaGFwZS5sZW5ndGgpbz1hWzBdPT09YVsxXT9lLm11bFN0cmljdCh0KS5zdW0oYVswXSk6ZS50cmFuc3Bvc2UoWzEsMF0pLm11bFN0cmljdCh0KS5zdW0oYVsxXSk7ZWxzZXt2YXIgdT1hWzBdIT09ZS5zaGFwZS5sZW5ndGgtMSxjPWFbMV09PT10LnNoYXBlLmxlbmd0aC0xO289ZS5tYXRNdWwodCx1LGMpfWlmKG4+MCl7dmFyIHA9dm9pZCAwLGg9W107Zm9yKGw9cD1yPmk/citpLTM6ci0xO2w8cCtuOysrbCloLnB1c2gobCk7bz1vLnNxdWVlemUoaCl9cmV0dXJuIDE9PT1vLnNoYXBlLmxlbmd0aCYmKG89by5leHBhbmREaW1zKDEpKSxvfSl9c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKENvbmNhdGVuYXRlKTt2YXIgRG90PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIG4uYXhlcz10LmF4ZXMsbi5ub3JtYWxpemU9bnVsbCE9dC5ub3JtYWxpemUmJnQubm9ybWFsaXplLG4uc3VwcG9ydHNNYXNraW5nPSEwLG4ucmVzaGFwZVJlcXVpcmVkPSExLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe3V0aWwuYXNzZXJ0KEFycmF5LmlzQXJyYXkoZSkmJjI9PT1lLmxlbmd0aCYmQXJyYXkuaXNBcnJheShlWzBdKSYmQXJyYXkuaXNBcnJheShlWzFdKSxmdW5jdGlvbigpe3JldHVyblwiQSBgRG90YCBsYXllciBzaG91bGQgYmUgY2FsbGVkIG9uIGEgbGlzdCBvZiBleGFjdGx5IDIgaW5wdXRzLlwifSk7dmFyIHQ9ZVswXSxuPWVbMV07aWYodC5sZW5ndGg+M3x8bi5sZW5ndGg+Myl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIkRvdCBsYXllciBkb2VzIG5vdCBzdXBwb3J0IHRlbnNvcnMgb2YgNEQgb3IgaGlnaGVyIHJhbmsgeWV0LlwiKTt2YXIgcj10aGlzLmludGVycHJldEF4ZXModCxuKTtpZih0W3JbMF1dIT09bltyWzFdXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkRpbWVuc2lvbiBpbmNvbXBhdGliaWxpdHk6IFwiK3RbclswXV0rXCIgIT09IFwiK25bclsxXV0pfSx0LnByb3RvdHlwZS5tZXJnZUZ1bmN0aW9uPWZ1bmN0aW9uKGUpe2lmKDIhPT1lLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkEgYERvdGAgbGF5ZXIgbXVzdCBiZSBjYWxsZWQgb24gZXhhY3RseSAyIGlucHV0cywgYnV0IHJlY2VpdmVkIFwiK2UubGVuZ3RoK1wiIGlucHV0KHMpLlwiKTt2YXIgdCxuPWVbMF0scj1lWzFdO3JldHVybiB0PUFycmF5LmlzQXJyYXkodGhpcy5heGVzKT90aGlzLmF4ZXMubWFwKGZ1bmN0aW9uKHQsbil7cmV0dXJuIGludGVycHJldEF4aXModCxlW25dLnNoYXBlLmxlbmd0aCl9KTpbaW50ZXJwcmV0QXhpcyh0aGlzLmF4ZXMsbi5zaGFwZS5sZW5ndGgpLGludGVycHJldEF4aXModGhpcy5heGVzLHIuc2hhcGUubGVuZ3RoKV0sdGhpcy5ub3JtYWxpemUmJihuPWwyTm9ybWFsaXplKG4sdFswXSkscj1sMk5vcm1hbGl6ZShyLHRbMV0pKSxiYXRjaERvdChuLHIsdCl9LHQucHJvdG90eXBlLmludGVycHJldEF4ZXM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLmF4ZXMpP3RoaXMuYXhlczpbaW50ZXJwcmV0QXhpcyh0aGlzLmF4ZXMsZS5sZW5ndGgpLGludGVycHJldEF4aXModGhpcy5heGVzLHQubGVuZ3RoKV19LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXt1dGlsLmFzc2VydChBcnJheS5pc0FycmF5KGUpJiYyPT09ZS5sZW5ndGgmJkFycmF5LmlzQXJyYXkoZVswXSkmJkFycmF5LmlzQXJyYXkoZVsxXSksZnVuY3Rpb24oKXtyZXR1cm5cIkEgYERvdGAgbGF5ZXIgc2hvdWxkIGJlIGNhbGxlZCBvbiBhIGxpc3Qgb2YgZXhhY3RseSAyIGlucHV0cy5cIn0pO3ZhciB0PWVbMF0uc2xpY2UoKSxuPWVbMV0uc2xpY2UoKTtpZih0Lmxlbmd0aD4zfHxuLmxlbmd0aD4zKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiRG90IGxheWVyIGRvZXMgbm90IHN1cHBvcnQgdGVuc29ycyBvZiA0RCBvciBoaWdoZXIgcmFuayB5ZXQuXCIpO3ZhciByPXRoaXMuaW50ZXJwcmV0QXhlcyh0LG4pO3Quc3BsaWNlKHJbMF0sMSksbi5zcGxpY2UoclsxXSwxKSxuLnNwbGljZSgwLDEpO3ZhciBpPXQuY29uY2F0KG4pO3JldHVybiAxPT09aS5sZW5ndGgmJmkucHVzaCgxKSxpfSx0LnByb3RvdHlwZS5jb21wdXRlTWFzaz1mdW5jdGlvbihlLHQpe3JldHVybiBudWxsfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17YXhlczp0aGlzLmF4ZXMsbm9ybWFsaXplOnRoaXMubm9ybWFsaXplfSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJEb3RcIix0fShNZXJnZSk7ZnVuY3Rpb24gYmF0Y2hOb3JtYWxpemF0aW9uKGUsdCxuLHIsaSxhKXt2YXIgbztpZih2b2lkIDA9PT1hJiYoYT0uMDAxKSwyPT09ZS5yYW5rKW89YmF0Y2hOb3JtMmQoZSx0LG4scixpLGEpO2Vsc2UgaWYoMz09PWUucmFuaylvPWJhdGNoTm9ybTNkKGUsdCxuLHIsaSxhKTtlbHNle2lmKDQhPT1lLnJhbmspdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJiYXRjaE5vcm1hbGl6YXRpb24gaXMgbm90IGltcGxlbWVudGVkIGZvciBhcnJheSBvZiByYW5rIFwiK2UucmFuaytcIiB5ZXRcIik7bz1iYXRjaE5vcm00ZChlLHQsbixyLGksYSl9cmV0dXJuIG99ZnVuY3Rpb24gcmVndWxhck5vcm1hbGl6ZUJhdGNoSW5UcmFpbmluZyhlLHQsbixyLGkpe3JldHVybiB2b2lkIDA9PT1pJiYoaT0uMDAxKSx0aWR5KGZ1bmN0aW9uKCl7dmFyIGE9bW9tZW50cyhlLHIpLG89YS5tZWFuLHM9YS52YXJpYW5jZTtyZXR1cm5bYmF0Y2hOb3JtYWxpemF0aW9uKGUsbyxzLG4sdCxpKSxvLHNdfSl9ZnVuY3Rpb24gYnJvYWRjYXN0Tm9ybWFsaXplQmF0Y2hJblRyYWluaW5nKGUsdCxuLHIsaSl7cmV0dXJuIHZvaWQgMD09PWkmJihpPS4wMDEpLHRpZHkoZnVuY3Rpb24oKXtmb3IodmFyIGE9bW9tZW50cyhlLHIpLG89YS5tZWFuLHM9YS52YXJpYW5jZSxsPVtdLHU9MCxjPXJhbmdlKDAsZS5yYW5rKTt1PGMubGVuZ3RoO3UrKyl7dmFyIHA9Y1t1XTstMSE9PXIuaW5kZXhPZihwKT9sLnB1c2goMSk6bC5wdXNoKGUuc2hhcGVbcF0pfXZhciBoPW8ucmVzaGFwZShsKSxkPXMucmVzaGFwZShsKSxmPW51bGw9PXQ/bnVsbDp0LnJlc2hhcGUobCksZz1udWxsPT1uP251bGw6bi5yZXNoYXBlKGwpO3JldHVybltiYXRjaE5vcm1hbGl6YXRpb24oZSxoLGQsZyxmLGkpLG8sc119KX1mdW5jdGlvbiBub3JtYWxpemVCYXRjaEluVHJhaW5pbmcoZSx0LG4scixpKXtyZXR1cm4gdm9pZCAwPT09aSYmKGk9LjAwMSksdXRpbC5hcnJheXNFcXVhbChyLnNsaWNlKCkuc29ydCgpLHJhbmdlKDAsZS5yYW5rLTEpKT9yZWd1bGFyTm9ybWFsaXplQmF0Y2hJblRyYWluaW5nKGUsdCxuLHIsaSk6YnJvYWRjYXN0Tm9ybWFsaXplQmF0Y2hJblRyYWluaW5nKGUsdCxuLHIsaSl9c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKERvdCk7dmFyIEJhdGNoTm9ybWFsaXphdGlvbj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPXRoaXM7cmV0dXJuIG51bGw9PXQmJih0PXt9KSwobj1lLmNhbGwodGhpcyx0KXx8dGhpcykuc3VwcG9ydHNNYXNraW5nPSEwLG4uYXhpcz1udWxsPT10LmF4aXM/LTE6dC5heGlzLG4ubW9tZW50dW09bnVsbD09dC5tb21lbnR1bT8uOTk6dC5tb21lbnR1bSxuLmVwc2lsb249bnVsbD09dC5lcHNpbG9uPy4wMDE6dC5lcHNpbG9uLG4uY2VudGVyPW51bGw9PXQuY2VudGVyfHx0LmNlbnRlcixuLnNjYWxlPW51bGw9PXQuc2NhbGV8fHQuc2NhbGUsbi5iZXRhSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5iZXRhSW5pdGlhbGl6ZXJ8fFwiemVyb3NcIiksbi5nYW1tYUluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQuZ2FtbWFJbml0aWFsaXplcnx8XCJvbmVzXCIpLG4ubW92aW5nTWVhbkluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQubW92aW5nTWVhbkluaXRpYWxpemVyfHxcInplcm9zXCIpLG4ubW92aW5nVmFyaWFuY2VJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcih0Lm1vdmluZ1ZhcmlhbmNlSW5pdGlhbGl6ZXJ8fFwib25lc1wiKSxuLmJldGFDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5iZXRhQ29uc3RyYWludCksbi5nYW1tYUNvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludCh0LmdhbW1hQ29uc3RyYWludCksbi5iZXRhUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5iZXRhUmVndWxhcml6ZXIpLG4uZ2FtbWFSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0LmdhbW1hUmVndWxhcml6ZXIpLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe3ZhciB0O2U9Z2V0RXhhY3RseU9uZVNoYXBlKGUpO3ZhciBuPXRoaXMuYXhpcz49MD90aGlzLmF4aXM6dGhpcy5heGlzK2UubGVuZ3RoLHI9ZVtuXTtpZihudWxsPT1yKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQXhpcyBcIituK1wiIG9mIGlucHV0IHRlbnNvciBzaG91bGQgaGF2ZSBhIGRlZmluZWQgZGltZW5zaW9uIGJ1dCB0aGUgbGF5ZXIgcmVjZWl2ZWQgYW4gaW5wdXQgd2l0aCBzaGFwZSBcIitKU09OLnN0cmluZ2lmeShlKStcIi5cIik7dGhpcy5pbnB1dFNwZWM9W25ldyBJbnB1dFNwZWMoe25kaW06ZS5sZW5ndGgsYXhlczoodD17fSx0W25dPXIsdCl9KV07dmFyIGk9W3JdO3RoaXMuc2NhbGUmJih0aGlzLmdhbW1hPXRoaXMuYWRkV2VpZ2h0KFwiZ2FtbWFcIixpLG51bGwsdGhpcy5nYW1tYUluaXRpYWxpemVyLHRoaXMuZ2FtbWFSZWd1bGFyaXplciwhMCx0aGlzLmdhbW1hQ29uc3RyYWludCkpLHRoaXMuY2VudGVyJiYodGhpcy5iZXRhPXRoaXMuYWRkV2VpZ2h0KFwiYmV0YVwiLGksbnVsbCx0aGlzLmJldGFJbml0aWFsaXplcix0aGlzLmJldGFSZWd1bGFyaXplciwhMCx0aGlzLmJldGFDb25zdHJhaW50KSksdGhpcy5tb3ZpbmdNZWFuPXRoaXMuYWRkV2VpZ2h0KFwibW92aW5nX21lYW5cIixpLG51bGwsdGhpcy5tb3ZpbmdNZWFuSW5pdGlhbGl6ZXIsbnVsbCwhMSksdGhpcy5tb3ZpbmdWYXJpYW5jZT10aGlzLmFkZFdlaWdodChcIm1vdmluZ192YXJpYW5jZVwiLGksbnVsbCx0aGlzLm1vdmluZ1ZhcmlhbmNlSW5pdGlhbGl6ZXIsbnVsbCwhMSksdGhpcy5idWlsdD0hMH0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgcj1udWxsIT10LnRyYWluaW5nJiZ0LnRyYWluaW5nLGk9Z2V0RXhhY3RseU9uZVRlbnNvcihlKSxhPWkuc2hhcGUsbz1hLmxlbmd0aCxzPXJhbmdlKDAsbyksbD1uLmF4aXM+PTA/bi5heGlzOm4uYXhpcytvO3Muc3BsaWNlKGwsMSk7dmFyIHU9cHlMaXN0UmVwZWF0KDEsbyk7dVtsXT1hW2xdO3ZhciBjPXMuc2xpY2UoKTtjLnNvcnQoKTt2YXIgcD0hdXRpbC5hcnJheXNFcXVhbChjLHJhbmdlKDAsbykuc2xpY2UoMCxvLTEpKTtpZighcilyZXR1cm4gZnVuY3Rpb24oKXtpZihwKXt2YXIgZT1uLm1vdmluZ01lYW4ucmVhZCgpLnJlc2hhcGUodSksdD1uLm1vdmluZ1ZhcmlhbmNlLnJlYWQoKS5yZXNoYXBlKHUpLHI9bi5jZW50ZXI/bi5iZXRhLnJlYWQoKS5yZXNoYXBlKHUpOm51bGwsYT1uLnNjYWxlP24uZ2FtbWEucmVhZCgpLnJlc2hhcGUodSk6bnVsbDtyZXR1cm4gYmF0Y2hOb3JtYWxpemF0aW9uKGksZSx0LHIsYSxuLmVwc2lsb24pfXJldHVybiBiYXRjaE5vcm1hbGl6YXRpb24oaSxuLm1vdmluZ01lYW4ucmVhZCgpLG4ubW92aW5nVmFyaWFuY2UucmVhZCgpLG51bGw9PW4uYmV0YT9udWxsOm4uYmV0YS5yZWFkKCksbnVsbD09bi5nYW1tYT9udWxsOm4uZ2FtbWEucmVhZCgpLG4uZXBzaWxvbil9KCk7dmFyIGg9bm9ybWFsaXplQmF0Y2hJblRyYWluaW5nKGksbi5nYW1tYS5yZWFkKCksbi5iZXRhLnJlYWQoKSxzLG4uZXBzaWxvbiksZD1oWzBdLGY9aFsxXSxnPWhbMl0sbT1mdW5jdGlvbihlLHQsbil7dGlkeShmdW5jdGlvbigpe3ZhciByPTEtbixpPWUucmVhZCgpLGE9aS5zdWIodCkubXVsKHIpO2Uud3JpdGUoaS5zdWIoYSkpfSl9O3JldHVybiBtKG4ubW92aW5nTWVhbixmLG4ubW9tZW50dW0pLG0obi5tb3ZpbmdWYXJpYW5jZSxnLG4ubW9tZW50dW0pLGR9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2F4aXM6dGhpcy5heGlzLG1vbWVudHVtOnRoaXMubW9tZW50dW0sZXBzaWxvbjp0aGlzLmVwc2lsb24sY2VudGVyOnRoaXMuY2VudGVyLHNjYWxlOnRoaXMuc2NhbGUsYmV0YUluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYmV0YUluaXRpYWxpemVyKSxnYW1tYUluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuZ2FtbWFJbml0aWFsaXplciksbW92aW5nTWVhbkluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMubW92aW5nTWVhbkluaXRpYWxpemVyKSxtb3ZpbmdWYXJpYW5jZUluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMubW92aW5nVmFyaWFuY2VJbml0aWFsaXplciksYmV0YVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmV0YVJlZ3VsYXJpemVyKSxnYW1tYVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuZ2FtbWFSZWd1bGFyaXplciksYmV0YUNvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJldGFDb25zdHJhaW50KSxnYW1tYUNvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmdhbW1hQ29uc3RyYWludCl9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIkJhdGNoTm9ybWFsaXphdGlvblwiLHR9KExheWVyKTtmdW5jdGlvbiBzcGF0aWFsMmRQYWRkaW5nKGUsdCxuKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe2lmKDQhPT1lLnJhbmspdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJ0ZW1wb3JhbFBhZGRpbmcgZXhwZWN0cyBpbnB1dCB0ZW5zb3IgdG8gYmUgNC1ELCBidXQgcmVjZWl2ZWQgYSBcIitlLnJhbmsrXCItRCB0ZW5zb3IuXCIpO2lmKG51bGw9PXQmJih0PVtbMSwxXSxbMSwxXV0pLDIhPT10Lmxlbmd0aHx8MiE9PXRbMF0ubGVuZ3RofHwyIT09dFsxXS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJzcGF0aWFsMmRQYWRkaW5nIGV4cGVjdHMgYHBhZGRpbmdgIHRvIGJlIGFuIEFycmF5IG9mIHR3byBBcnJheXMsIGVhY2ggb2Ygd2hpY2ggaXMgYW4gQXJyYXkgb2YgdHdvIGludGVnZXJzLlwiKTtpZihudWxsPT1uJiYobj1pbWFnZURhdGFGb3JtYXQoKSksXCJjaGFubmVsc0xhc3RcIiE9PW4mJlwiY2hhbm5lbHNGaXJzdFwiIT09bil0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlVua25vd24gZGF0YSBmb3JtYXQ6IFwiK24rXCIuIFN1cHBvcnRlZCBkYXRhIGZvcm1hdHMgYXJlICdjaGFubmVsc0xhc3QnIGFuZCAnY2hhbm5lbHNGaXJzdC5cIik7dmFyIHI7cmV0dXJuIHI9XCJjaGFubmVsc0ZpcnN0XCI9PT1uP1tbMCwwXSxbMCwwXSx0WzBdLHRbMV1dOltbMCwwXSx0WzBdLHRbMV0sWzAsMF1dLHBhZChlLHIpfSl9c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEJhdGNoTm9ybWFsaXphdGlvbik7dmFyIFplcm9QYWRkaW5nMkQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj10aGlzO2lmKG51bGw9PXQmJih0PXt9KSwobj1lLmNhbGwodGhpcyx0KXx8dGhpcykuZGF0YUZvcm1hdD1udWxsPT10LmRhdGFGb3JtYXQ/aW1hZ2VEYXRhRm9ybWF0KCk6dC5kYXRhRm9ybWF0LG51bGw9PXQucGFkZGluZyluLnBhZGRpbmc9W1sxLDFdLFsxLDFdXTtlbHNlIGlmKFwibnVtYmVyXCI9PXR5cGVvZiB0LnBhZGRpbmcpbi5wYWRkaW5nPVtbdC5wYWRkaW5nLHQucGFkZGluZ10sW3QucGFkZGluZyx0LnBhZGRpbmddXTtlbHNle2lmKHQucGFkZGluZz10LnBhZGRpbmcsMiE9PXQucGFkZGluZy5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJaZXJvUGFkZGluZzJEIGV4cGVjdHMgcGFkZGluZyB0byBiZSBhIGxlbmd0aC0yIGFycmF5LCBidXQgcmVjZWl2ZWQgYSBsZW5ndGgtXCIrdC5wYWRkaW5nLmxlbmd0aCtcIiBhcnJheS5cIik7dmFyIHI9dm9pZCAwLGk9dm9pZCAwO2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0LnBhZGRpbmdbMF0pcj1bdC5wYWRkaW5nWzBdLHQucGFkZGluZ1swXV0saT1bdC5wYWRkaW5nWzFdLHQucGFkZGluZ1sxXV07ZWxzZXtpZih0LnBhZGRpbmc9dC5wYWRkaW5nLDIhPT10LnBhZGRpbmdbMF0ubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiWmVyb1BhZGRpbmcyRCBleHBlY3RzIGhlaWdodCBwYWRkaW5nIHRvIGJlIGEgbGVuZ3RoLTIgYXJyYXksIGJ1dCByZWNlaXZlZCBhIGxlbmd0aC1cIit0LnBhZGRpbmdbMF0ubGVuZ3RoK1wiIGFycmF5LlwiKTtpZihyPXQucGFkZGluZ1swXSwyIT09dC5wYWRkaW5nWzFdLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlplcm9QYWRkaW5nMkQgZXhwZWN0cyB3aWR0aCBwYWRkaW5nIHRvIGJlIGEgbGVuZ3RoLTIgYXJyYXksIGJ1dCByZWNlaXZlZCBhIGxlbmd0aC1cIit0LnBhZGRpbmdbMV0ubGVuZ3RoK1wiIGFycmF5LlwiKTtpPXQucGFkZGluZ1sxXX1uLnBhZGRpbmc9W3IsaV19cmV0dXJuIG4uaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOjR9KV0sbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3ZhciB0LG47cmV0dXJuIGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpLFwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0Pyh0PW51bGwhPWVbMl0mJmVbMl0+PTA/ZVsyXSt0aGlzLnBhZGRpbmdbMF1bMF0rdGhpcy5wYWRkaW5nWzBdWzFdOm51bGwsbj1udWxsIT1lWzNdJiZlWzNdPj0wP2VbM10rdGhpcy5wYWRkaW5nWzFdWzBdK3RoaXMucGFkZGluZ1sxXVsxXTpudWxsLFtlWzBdLGVbMV0sdCxuXSk6KHQ9bnVsbCE9ZVsxXSYmZVsxXT49MD9lWzFdK3RoaXMucGFkZGluZ1swXVswXSt0aGlzLnBhZGRpbmdbMF1bMV06bnVsbCxuPW51bGwhPWVbMl0mJmVbMl0+PTA/ZVsyXSt0aGlzLnBhZGRpbmdbMV1bMF0rdGhpcy5wYWRkaW5nWzFdWzFdOm51bGwsW2VbMF0sdCxuLGVbM11dKX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gc3BhdGlhbDJkUGFkZGluZyhnZXRFeGFjdGx5T25lVGVuc29yKGUpLG4ucGFkZGluZyxuLmRhdGFGb3JtYXQpfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtwYWRkaW5nOnRoaXMucGFkZGluZyxkYXRhRm9ybWF0OnRoaXMuZGF0YUZvcm1hdH0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiWmVyb1BhZGRpbmcyRFwiLHR9KExheWVyKTtmdW5jdGlvbiBwb29sMmQoZSx0LG4scixpLGEpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG87Y2hlY2tEYXRhRm9ybWF0KGkpLGNoZWNrUG9vbE1vZGUoYSksY2hlY2tQYWRkaW5nTW9kZShyKSxudWxsPT1uJiYobj1bMSwxXSksbnVsbD09ciYmKHI9XCJ2YWxpZFwiKSxudWxsPT1pJiYoaT1pbWFnZURhdGFGb3JtYXQoKSksbnVsbD09YSYmKGE9XCJtYXhcIiksZT1wcmVwcm9jZXNzQ29udjJESW5wdXQoZSxpKTt2YXIgcz1cInNhbWVcIj09PXI/XCJzYW1lXCI6XCJ2YWxpZFwiO3JldHVybiBvPVwibWF4XCI9PT1hP21heFBvb2woZSx0LG4scyk6YXZnUG9vbChlLHQsbixzKSxcImNoYW5uZWxzRmlyc3RcIj09PWkmJihvPXRyYW5zcG9zZShvLFswLDMsMSwyXSkpLG99KX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoWmVyb1BhZGRpbmcyRCk7dmFyIFBvb2xpbmcxRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPXRoaXM7aWYobnVsbD09dC5wb29sU2l6ZSYmKHQucG9vbFNpemU9Miksbj1lLmNhbGwodGhpcyx0KXx8dGhpcyxcIm51bWJlclwiPT10eXBlb2YgdC5wb29sU2l6ZSluLnBvb2xTaXplPVt0LnBvb2xTaXplXTtlbHNle2lmKCFBcnJheS5pc0FycmF5KHQucG9vbFNpemUpfHwxIT09dC5wb29sU2l6ZS5sZW5ndGh8fFwibnVtYmVyXCIhPXR5cGVvZiB0LnBvb2xTaXplWzBdKXRocm93IG5ldyBWYWx1ZUVycm9yKFwicG9vbFNpemUgZm9yIDFEIGNvbnZvbHV0aW9uYWwgbGF5ZXIgbXVzdCBiZSBhIG51bWJlciBvciBhbiBBcnJheSBvZiBhIHNpbmdsZSBudW1iZXIsIGJ1dCByZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeSh0LnBvb2xTaXplKSk7bi5wb29sU2l6ZT10LnBvb2xTaXplfWlmKGFzc2VydFBvc2l0aXZlSW50ZWdlcihuLnBvb2xTaXplLFwicG9vbFNpemVcIiksbnVsbD09dC5zdHJpZGVzKW4uc3RyaWRlcz1uLnBvb2xTaXplO2Vsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIHQuc3RyaWRlcyluLnN0cmlkZXM9W3Quc3RyaWRlc107ZWxzZXtpZighQXJyYXkuaXNBcnJheSh0LnN0cmlkZXMpfHwxIT09dC5zdHJpZGVzLmxlbmd0aHx8XCJudW1iZXJcIiE9dHlwZW9mIHQuc3RyaWRlc1swXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcInN0cmlkZXMgZm9yIDFEIGNvbnZvbHV0aW9uYWwgbGF5ZXIgbXVzdCBiZSBhIG51bWJlciBvciBhbiBBcnJheSBvZiBhIHNpbmdsZSBudW1iZXIsIGJ1dCByZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeSh0LnN0cmlkZXMpKTtuLnN0cmlkZXM9dC5zdHJpZGVzfXJldHVybiBhc3NlcnRQb3NpdGl2ZUludGVnZXIobi5zdHJpZGVzLFwic3RyaWRlc1wiKSxuLnBhZGRpbmc9bnVsbD09dC5wYWRkaW5nP1widmFsaWRcIjp0LnBhZGRpbmcsY2hlY2tQYWRkaW5nTW9kZShuLnBhZGRpbmcpLG4uaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOjN9KV0sbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3ZhciB0PWNvbnZPdXRwdXRMZW5ndGgoKGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpKVsxXSx0aGlzLnBvb2xTaXplWzBdLHRoaXMucGFkZGluZyx0aGlzLnN0cmlkZXNbMF0pO3JldHVybltlWzBdLHQsZVsyXV19LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7bi5pbnZva2VDYWxsSG9vayhlLHQpLGU9ZXhwYW5kRGltcyQxKGdldEV4YWN0bHlPbmVUZW5zb3IoZSksMik7dmFyIHI9bi5wb29saW5nRnVuY3Rpb24oZ2V0RXhhY3RseU9uZVRlbnNvcihlKSxbbi5wb29sU2l6ZVswXSwxXSxbbi5zdHJpZGVzWzBdLDFdLG4ucGFkZGluZyxcImNoYW5uZWxzTGFzdFwiKTtyZXR1cm4gc3F1ZWV6ZShyLFsyXSl9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e3Bvb2xTaXplOnRoaXMucG9vbFNpemUscGFkZGluZzp0aGlzLnBhZGRpbmcsc3RyaWRlczp0aGlzLnN0cmlkZXN9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0fShMYXllciksTWF4UG9vbGluZzFEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLHQpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5wb29saW5nRnVuY3Rpb249ZnVuY3Rpb24oZSx0LG4scixpKXtyZXR1cm4gY2hlY2tEYXRhRm9ybWF0KGkpLGNoZWNrUGFkZGluZ01vZGUocikscG9vbDJkKGUsdCxuLHIsaSxcIm1heFwiKX0sdC5jbGFzc05hbWU9XCJNYXhQb29saW5nMURcIix0fShQb29saW5nMUQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhNYXhQb29saW5nMUQpO3ZhciBBdmVyYWdlUG9vbGluZzFEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLHQpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5wb29saW5nRnVuY3Rpb249ZnVuY3Rpb24oZSx0LG4scixpKXtyZXR1cm4gY2hlY2tEYXRhRm9ybWF0KGkpLGNoZWNrUGFkZGluZ01vZGUocikscG9vbDJkKGUsdCxuLHIsaSxcImF2Z1wiKX0sdC5jbGFzc05hbWU9XCJBdmVyYWdlUG9vbGluZzFEXCIsdH0oUG9vbGluZzFEKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQXZlcmFnZVBvb2xpbmcxRCk7dmFyIFBvb2xpbmcyRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPXRoaXM7aWYobnVsbD09dC5wb29sU2l6ZSYmKHQucG9vbFNpemU9WzIsMl0pLChuPWUuY2FsbCh0aGlzLHQpfHx0aGlzKS5wb29sU2l6ZT1BcnJheS5pc0FycmF5KHQucG9vbFNpemUpP3QucG9vbFNpemU6W3QucG9vbFNpemUsdC5wb29sU2l6ZV0sbnVsbD09dC5zdHJpZGVzKW4uc3RyaWRlcz1uLnBvb2xTaXplO2Vsc2UgaWYoQXJyYXkuaXNBcnJheSh0LnN0cmlkZXMpKXtpZigyIT09dC5zdHJpZGVzLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklmIHRoZSBzdHJpZGVzIHByb3BlcnR5IG9mIGEgMkQgcG9vbGluZyBsYXllciBpcyBhbiBBcnJheSwgaXQgaXMgZXhwZWN0ZWQgdG8gaGF2ZSBhIGxlbmd0aCBvZiAyLCBidXQgcmVjZWl2ZWQgbGVuZ3RoIFwiK3Quc3RyaWRlcy5sZW5ndGgrXCIuXCIpO24uc3RyaWRlcz10LnN0cmlkZXN9ZWxzZSBuLnN0cmlkZXM9W3Quc3RyaWRlcyx0LnN0cmlkZXNdO3JldHVybiBhc3NlcnRQb3NpdGl2ZUludGVnZXIobi5wb29sU2l6ZSxcInBvb2xTaXplXCIpLGFzc2VydFBvc2l0aXZlSW50ZWdlcihuLnN0cmlkZXMsXCJzdHJpZGVzXCIpLG4ucGFkZGluZz1udWxsPT10LnBhZGRpbmc/XCJ2YWxpZFwiOnQucGFkZGluZyxuLmRhdGFGb3JtYXQ9bnVsbD09dC5kYXRhRm9ybWF0P1wiY2hhbm5lbHNMYXN0XCI6dC5kYXRhRm9ybWF0LGNoZWNrRGF0YUZvcm1hdChuLmRhdGFGb3JtYXQpLGNoZWNrUGFkZGluZ01vZGUobi5wYWRkaW5nKSxuLmlucHV0U3BlYz1bbmV3IElucHV0U3BlYyh7bmRpbTo0fSldLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtlPWdldEV4YWN0bHlPbmVTaGFwZShlKTt2YXIgdD1cImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdD9lWzJdOmVbMV0sbj1cImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdD9lWzNdOmVbMl07cmV0dXJuIHQ9Y29udk91dHB1dExlbmd0aCh0LHRoaXMucG9vbFNpemVbMF0sdGhpcy5wYWRkaW5nLHRoaXMuc3RyaWRlc1swXSksbj1jb252T3V0cHV0TGVuZ3RoKG4sdGhpcy5wb29sU2l6ZVsxXSx0aGlzLnBhZGRpbmcsdGhpcy5zdHJpZGVzWzFdKSxcImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdD9bZVswXSxlWzFdLHQsbl06W2VbMF0sdCxuLGVbM11dfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBuLmludm9rZUNhbGxIb29rKGUsdCksbi5wb29saW5nRnVuY3Rpb24oZ2V0RXhhY3RseU9uZVRlbnNvcihlKSxuLnBvb2xTaXplLG4uc3RyaWRlcyxuLnBhZGRpbmcsbi5kYXRhRm9ybWF0KX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17cG9vbFNpemU6dGhpcy5wb29sU2l6ZSxwYWRkaW5nOnRoaXMucGFkZGluZyxzdHJpZGVzOnRoaXMuc3RyaWRlcyxkYXRhRm9ybWF0OnRoaXMuZGF0YUZvcm1hdH0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHR9KExheWVyKSxNYXhQb29saW5nMkQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMsdCl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLnBvb2xpbmdGdW5jdGlvbj1mdW5jdGlvbihlLHQsbixyLGkpe3JldHVybiBjaGVja0RhdGFGb3JtYXQoaSksY2hlY2tQYWRkaW5nTW9kZShyKSxwb29sMmQoZSx0LG4scixpLFwibWF4XCIpfSx0LmNsYXNzTmFtZT1cIk1heFBvb2xpbmcyRFwiLHR9KFBvb2xpbmcyRCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE1heFBvb2xpbmcyRCk7dmFyIEF2ZXJhZ2VQb29saW5nMkQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMsdCl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLnBvb2xpbmdGdW5jdGlvbj1mdW5jdGlvbihlLHQsbixyLGkpe3JldHVybiBjaGVja0RhdGFGb3JtYXQoaSksY2hlY2tQYWRkaW5nTW9kZShyKSxwb29sMmQoZSx0LG4scixpLFwiYXZnXCIpfSx0LmNsYXNzTmFtZT1cIkF2ZXJhZ2VQb29saW5nMkRcIix0fShQb29saW5nMkQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhBdmVyYWdlUG9vbGluZzJEKTt2YXIgR2xvYmFsUG9vbGluZzFEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIG4uaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOjN9KV0sbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3JldHVybltlWzBdLGVbMl1dfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3J9LHR9KExheWVyKSxHbG9iYWxBdmVyYWdlUG9vbGluZzFEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLHR8fHt9KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9Z2V0RXhhY3RseU9uZVRlbnNvcihlKTtyZXR1cm4gbWVhbih0LDEpfSl9LHQuY2xhc3NOYW1lPVwiR2xvYmFsQXZlcmFnZVBvb2xpbmcxRFwiLHR9KEdsb2JhbFBvb2xpbmcxRCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEdsb2JhbEF2ZXJhZ2VQb29saW5nMUQpO3ZhciBHbG9iYWxNYXhQb29saW5nMUQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMsdHx8e30pfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgdD1nZXRFeGFjdGx5T25lVGVuc29yKGUpO3JldHVybiBtYXgodCwxKX0pfSx0LmNsYXNzTmFtZT1cIkdsb2JhbE1heFBvb2xpbmcxRFwiLHR9KEdsb2JhbFBvb2xpbmcxRCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEdsb2JhbE1heFBvb2xpbmcxRCk7dmFyIEdsb2JhbFBvb2xpbmcyRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLmRhdGFGb3JtYXQ9bnVsbD09dC5kYXRhRm9ybWF0P1wiY2hhbm5lbHNMYXN0XCI6dC5kYXRhRm9ybWF0LGNoZWNrRGF0YUZvcm1hdChuLmRhdGFGb3JtYXQpLG4uaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOjR9KV0sbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3JldHVybiBlPWUsXCJjaGFubmVsc0xhc3RcIj09PXRoaXMuZGF0YUZvcm1hdD9bZVswXSxlWzNdXTpbZVswXSxlWzFdXX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17ZGF0YUZvcm1hdDp0aGlzLmRhdGFGb3JtYXR9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0fShMYXllciksR2xvYmFsQXZlcmFnZVBvb2xpbmcyRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgdD1nZXRFeGFjdGx5T25lVGVuc29yKGUpO3JldHVyblwiY2hhbm5lbHNMYXN0XCI9PT1uLmRhdGFGb3JtYXQ/bWVhbih0LFsxLDJdKTptZWFuKHQsWzIsM10pfSl9LHQuY2xhc3NOYW1lPVwiR2xvYmFsQXZlcmFnZVBvb2xpbmcyRFwiLHR9KEdsb2JhbFBvb2xpbmcyRCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEdsb2JhbEF2ZXJhZ2VQb29saW5nMkQpO3ZhciBHbG9iYWxNYXhQb29saW5nMkQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9Z2V0RXhhY3RseU9uZVRlbnNvcihlKTtyZXR1cm5cImNoYW5uZWxzTGFzdFwiPT09bi5kYXRhRm9ybWF0P21heCh0LFsxLDJdKTptYXgodCxbMiwzXSl9KX0sdC5jbGFzc05hbWU9XCJHbG9iYWxNYXhQb29saW5nMkRcIix0fShHbG9iYWxQb29saW5nMkQpO2Z1bmN0aW9uIHN0YW5kYXJkaXplQXJncyhlLHQsbixyKXtpZihBcnJheS5pc0FycmF5KGUpKXtpZihudWxsIT10fHxudWxsIT1uKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiV2hlbiBpbnB1dHMgaXMgYW4gYXJyYXksIG5laXRoZXIgaW5pdGlhbFN0YXRlIG9yIGNvbnN0YW50cyBzaG91bGQgYmUgcHJvdmlkZWRcIik7bnVsbCE9ciYmKG49ZS5zbGljZShlLmxlbmd0aC1yLGUubGVuZ3RoKSxlPWUuc2xpY2UoMCxlLmxlbmd0aC1yKSksZS5sZW5ndGg+MSYmKHQ9ZS5zbGljZSgxLGUubGVuZ3RoKSksZT1lWzBdfWZ1bmN0aW9uIGkoZSl7cmV0dXJuIG51bGw9PWV8fEFycmF5LmlzQXJyYXkoZSk/ZTpbZV19cmV0dXJue2lucHV0czplLGluaXRpYWxTdGF0ZTp0PWkodCksY29uc3RhbnRzOm49aShuKX19ZnVuY3Rpb24gcm5uKGUsdCxuLHIsaSxhLG8scyl7cmV0dXJuIHZvaWQgMD09PXImJihyPSExKSx2b2lkIDA9PT1vJiYobz0hMSksdm9pZCAwPT09cyYmKHM9ITEpLHRpZHkoZnVuY3Rpb24oKXt2YXIgbD10LnNoYXBlLmxlbmd0aDtpZihsPDMpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnB1dCBzaG91bGQgYmUgYXQgbGVhc3QgM0QsIGJ1dCBpcyBcIitsK1wiRC5cIik7dmFyIHU9WzEsMF0uY29uY2F0KHJhbmdlKDIsbCkpO2lmKHQ9dHJhbnNwb3NlKHQsdSksbnVsbCE9YSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlRoZSBybm4oKSBmdW5jdG9pbiBvZiB0aGUgZGVlcGxlYXJuLmpzIGJhY2tlbmQgZG9lcyBub3Qgc3VwcG9ydCBjb25zdGFudHMgeWV0LlwiKTtvJiZjb25zb2xlLndhcm4oXCJCYWNrZW5kIHJubigpOiB0aGUgdW5yb2xsID0gdHJ1ZSBvcHRpb24gaXMgbm90IGFwcGxpY2FibGUgdG8gdGhlIGltcGVyYXRpdmUgZGVlcGxlYXJuLmpzIGJhY2tlbmQuXCIpLG51bGwhPWkmJigoaT1pLmFzVHlwZShcImJvb2xcIikuYXNUeXBlKFwiZmxvYXQzMlwiKSkucmFuaz09PWwtMSYmKGk9ZXhwYW5kRGltcyhpLC0xKSksaT10cmFuc3Bvc2UoaSx1KSksciYmKHQ9cmV2ZXJzZSh0LDApLG51bGwhPWkmJihpPXJldmVyc2UoaSwwKSkpO3ZhciBjLHAsaD1bXSxkPW4sZj10LnNoYXBlWzBdLGc9dW5zdGFjayh0KTtudWxsIT1pJiYocD11bnN0YWNrKGkpKTtmb3IodmFyIG0seT1mdW5jdGlvbih0KXt2YXIgbj1nW3RdLHI9dGlkeShmdW5jdGlvbigpe3JldHVybiBlKG4sZCl9KTtpZihudWxsPT1pKWM9clswXSxkPXJbMV07ZWxzZXt2YXIgYT10aWR5KGZ1bmN0aW9uKCl7dmFyIGU9cFt0XSxuPW9uZXNMaWtlKGUpLnN1YihlKTtyZXR1cm57b3V0cHV0OnJbMF0ubXVsKGUpLmFkZFN0cmljdChkWzBdLm11bChuKSksbmV3U3RhdGVzOmQubWFwKGZ1bmN0aW9uKHQsaSl7cmV0dXJuIHJbMV1baV0ubXVsKGUpLmFkZFN0cmljdCh0Lm11bChuKSl9KX19KTtjPWEub3V0cHV0LGQ9YS5uZXdTdGF0ZXN9cyYmaC5wdXNoKGMpfSx2PTA7djxmOysrdil5KHYpO2lmKHMpe209c3RhY2soaCwxKX1yZXR1cm5bYyxtLGRdfSl9c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEdsb2JhbE1heFBvb2xpbmcyRCk7dmFyIFJOTj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuLHI9ZS5jYWxsKHRoaXMsdCl8fHRoaXM7aWYobnVsbD09dC5jZWxsKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiY2VsbCBwcm9wZXJ0eSBpcyBtaXNzaW5nIGZvciB0aGUgY29uc3RydWN0b3Igb2YgUk5OLlwiKTtpZihudWxsPT0obj1BcnJheS5pc0FycmF5KHQuY2VsbCk/bmV3IFN0YWNrZWRSTk5DZWxscyh7Y2VsbHM6dC5jZWxsfSk6dC5jZWxsKS5zdGF0ZVNpemUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgUk5OIGNlbGwgc2hvdWxkIGhhdmUgYW4gYXR0cmlidXRlIGBzdGF0ZVNpemVgICh0dXBsZSBvZiBpbnRlZ2Vycywgb25lIGludGVnZXIgcGVyIFJOTiBzdGF0ZSkuXCIpO3JldHVybiByLmNlbGw9bixyLnJldHVyblNlcXVlbmNlcz1udWxsIT10LnJldHVyblNlcXVlbmNlcyYmdC5yZXR1cm5TZXF1ZW5jZXMsci5yZXR1cm5TdGF0ZT1udWxsIT10LnJldHVyblN0YXRlJiZ0LnJldHVyblN0YXRlLHIuZ29CYWNrd2FyZHM9bnVsbCE9dC5nb0JhY2t3YXJkcyYmdC5nb0JhY2t3YXJkcyxyLl9zdGF0ZWZ1bD1udWxsIT10LnN0YXRlZnVsJiZ0LnN0YXRlZnVsLHIudW5yb2xsPW51bGwhPXQudW5yb2xsJiZ0LnVucm9sbCxyLnN1cHBvcnRzTWFza2luZz0hMCxyLmlucHV0U3BlYz1bbmV3IElucHV0U3BlYyh7bmRpbTozfSldLHIuc3RhdGVTcGVjPW51bGwsci5zdGF0ZXNfPW51bGwsci5udW1Db25zdGFudHM9bnVsbCxyLmtlcHRTdGF0ZXM9W10scn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuZ2V0U3RhdGVzPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PXRoaXMuc3RhdGVzXz9yYW5nZSgwLEFycmF5LmlzQXJyYXkodGhpcy5jZWxsLnN0YXRlU2l6ZSk/dGhpcy5jZWxsLnN0YXRlU2l6ZS5sZW5ndGg6MSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBudWxsfSk6dGhpcy5zdGF0ZXNffSx0LnByb3RvdHlwZS5zZXRTdGF0ZXM9ZnVuY3Rpb24oZSl7dGhpcy5zdGF0ZXNfPWV9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtpc0FycmF5T2ZTaGFwZXMoZSkmJihlPWVbMF0pLGU9ZTt2YXIgdD10aGlzLmNlbGwuc3RhdGVTaXplO0FycmF5LmlzQXJyYXkodCl8fCh0PVt0XSk7dmFyIG4scj10WzBdO2lmKG49dGhpcy5yZXR1cm5TZXF1ZW5jZXM/W2VbMF0sZVsxXSxyXTpbZVswXSxyXSx0aGlzLnJldHVyblN0YXRlKXtmb3IodmFyIGk9W10sYT0wLG89dDthPG8ubGVuZ3RoO2ErKyl7dmFyIHM9b1thXTtpLnB1c2goW2VbMF0sc10pfXJldHVybltuXS5jb25jYXQoaSl9cmV0dXJuIG59LHQucHJvdG90eXBlLmNvbXB1dGVNYXNrPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe0FycmF5LmlzQXJyYXkodCkmJih0PXRbMF0pO3ZhciBlPW4ucmV0dXJuU2VxdWVuY2VzP3Q6bnVsbDtpZihuLnJldHVyblN0YXRlKXt2YXIgcj1uLnN0YXRlcy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG51bGx9KTtyZXR1cm5bZV0uY29uY2F0KHIpfXJldHVybiBlfSl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInN0YXRlc1wiLHtnZXQ6ZnVuY3Rpb24oKXtpZihudWxsPT10aGlzLnN0YXRlc18pe2Zvcih2YXIgZT1BcnJheS5pc0FycmF5KHRoaXMuY2VsbC5zdGF0ZVNpemUpP3RoaXMuY2VsbC5zdGF0ZVNpemUubGVuZ3RoOjEsdD1bXSxuPTA7bjxlOysrbil0LnB1c2gobnVsbCk7cmV0dXJuIHR9cmV0dXJuIHRoaXMuc3RhdGVzX30sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuc3RhdGVzXz1lfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe2lmKG51bGwhPXRoaXMubnVtQ29uc3RhbnRzKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiQ29uc3RhbnRzIHN1cHBvcnQgaXMgbm90IGltcGxlbWVudGVkIGluIFJOTiB5ZXQuXCIpO2lzQXJyYXlPZlNoYXBlcyhlKSYmKGU9ZVswXSksZT1lO3ZhciB0PXRoaXMuc3RhdGVmdWw/ZVswXTpudWxsLG49ZVtlLmxlbmd0aC0xXTt0aGlzLmlucHV0U3BlY1swXT1uZXcgSW5wdXRTcGVjKHtzaGFwZTpbdCxudWxsLG5dfSk7dmFyIHIsaT1bZVswXV0uY29uY2F0KGUuc2xpY2UoMikpO2lmKHRoaXMuY2VsbC5idWlsZChpKSxyPUFycmF5LmlzQXJyYXkodGhpcy5jZWxsLnN0YXRlU2l6ZSk/dGhpcy5jZWxsLnN0YXRlU2l6ZTpbdGhpcy5jZWxsLnN0YXRlU2l6ZV0sbnVsbCE9dGhpcy5zdGF0ZVNwZWMpe2lmKCF1dGlsLmFycmF5c0VxdWFsKHRoaXMuc3RhdGVTcGVjLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5zaGFwZVtlLnNoYXBlLmxlbmd0aC0xXX0pLHIpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQW4gaW5pdGlhbFN0YXRlIHdhcyBwYXNzZWQgdGhhdCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGNlbGwuc3RhdGVTaXplLiBSZWNlaXZlZCBzdGF0ZVNwZWM9XCIrdGhpcy5zdGF0ZVNwZWMrXCI7IEhvd2V2ZXIgY2VsbC5zdGF0ZVNpemUgaXMgXCIrdGhpcy5jZWxsLnN0YXRlU2l6ZSl9ZWxzZSB0aGlzLnN0YXRlU3BlYz1yLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gbmV3IElucHV0U3BlYyh7c2hhcGU6W251bGwsZV19KX0pO3RoaXMuc3RhdGVmdWwmJnRoaXMucmVzZXRTdGF0ZXMoKX0sdC5wcm90b3R5cGUucmVzZXRTdGF0ZXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3ZvaWQgMD09PXQmJih0PSExKSx0aWR5KGZ1bmN0aW9uKCl7aWYoIW4uc3RhdGVmdWwpdGhyb3cgbmV3IEF0dHJpYnV0ZUVycm9yKFwiQ2Fubm90IGNhbGwgcmVzZXRTdGF0ZXMoKSBvbiBhbiBSTk4gTGF5ZXIgdGhhdCBpcyBub3Qgc3RhdGVmdWwuXCIpO3ZhciByPW4uaW5wdXRTcGVjWzBdLnNoYXBlWzBdO2lmKG51bGw9PXIpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJZiBhbiBSTk4gaXMgc3RhdGVmdWwsIGl0IG5lZWRzIHRvIGtub3cgaXRzIGJhdGNoIHNpemUuIFNwZWNpZnkgdGhlIGJhdGNoIHNpemUgb2YgeW91ciBpbnB1dCB0ZW5zb3JzOiBcXG4tIElmIHVzaW5nIGEgU2VxdWVudGlhbCBtb2RlbCwgc3BlY2lmeSB0aGUgYmF0Y2ggc2l6ZSBieSBwYXNzaW5nIGEgYGJhdGNoSW5wdXRTaGFwZWAgb3B0aW9uIHRvIHlvdXIgZmlyc3QgbGF5ZXIuXFxuLSBJZiB1c2luZyB0aGUgZnVuY3Rpb25hbCBBUEksIHNwZWNpZnkgdGhlIGJhdGNoIHNpemUgYnkgcGFzc2luZyBhIGBiYXRjaFNoYXBlYCBvcHRpb24gdG8geW91ciBJbnB1dCBsYXllci5cIik7aWYobnVsbD09bi5zdGF0ZXNfKUFycmF5LmlzQXJyYXkobi5jZWxsLnN0YXRlU2l6ZSk/bi5zdGF0ZXNfPW4uY2VsbC5zdGF0ZVNpemUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiB6ZXJvcyhbcixlXSl9KTpuLnN0YXRlc189W3plcm9zKFtyLG4uY2VsbC5zdGF0ZVNpemVdKV07ZWxzZSBpZihudWxsPT1lKWRpc3Bvc2Uobi5zdGF0ZXNfKSxudWxsIT1uLmtlcHRTdGF0ZXMmJihkaXNwb3NlKG4ua2VwdFN0YXRlcyksbi5rZXB0U3RhdGVzPVtdKSxBcnJheS5pc0FycmF5KG4uY2VsbC5zdGF0ZVNpemUpP24uc3RhdGVzXz1uLmNlbGwuc3RhdGVTaXplLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gemVyb3MoW3IsZV0pfSk6bi5zdGF0ZXNfWzBdPXplcm9zKFtyLG4uY2VsbC5zdGF0ZVNpemVdKTtlbHNle2lmKEFycmF5LmlzQXJyYXkoZSl8fChlPVtlXSksZS5sZW5ndGghPT1uLnN0YXRlc18ubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTGF5ZXIgXCIrbi5uYW1lK1wiIGV4cGVjdHMgXCIrbi5zdGF0ZXNfLmxlbmd0aCtcIiBzdGF0ZShzKSwgYnV0IGl0IHJlY2VpdmVkIFwiK2UubGVuZ3RoK1wiIHN0YXRlIHZhbHVlKHMpLiBJbnB1dCByZWNlaXZlZDogXCIrZSk7ITA9PT10P24ua2VwdFN0YXRlcy5wdXNoKG4uc3RhdGVzXy5zbGljZSgpKTpkaXNwb3NlKG4uc3RhdGVzXyk7Zm9yKHZhciBpPTA7aTxuLnN0YXRlc18ubGVuZ3RoOysraSl7dmFyIGE9ZVtpXSxvPUFycmF5LmlzQXJyYXkobi5jZWxsLnN0YXRlU2l6ZSk/bi5jZWxsLnN0YXRlU2l6ZVtpXTpuLmNlbGwuc3RhdGVTaXplLHM9W3Isb107aWYoIXV0aWwuYXJyYXlzRXF1YWwoYS5zaGFwZSxzKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlN0YXRlIFwiK2krXCIgaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgXCIrbi5uYW1lK1wiOiBleHBlY3RlZCBzaGFwZT1cIitzK1wiLCByZWNlaXZlZCBzaGFwZT1cIithLnNoYXBlKTtuLnN0YXRlc19baV09YX19bi5zdGF0ZXNfPW4uc3RhdGVzXy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGtlZXAoZS5jbG9uZSgpKX0pfSl9LHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKHQsbil7dmFyIHI9bnVsbD09bj9udWxsOm4uaW5pdGlhbFN0YXRlLGk9bnVsbD09bj9udWxsOm4uY29uc3RhbnRzO251bGw9PW4mJihuPXt9KTt2YXIgYT1zdGFuZGFyZGl6ZUFyZ3ModCxyLGksdGhpcy5udW1Db25zdGFudHMpO3Q9YS5pbnB1dHMscj1hLmluaXRpYWxTdGF0ZSxpPWEuY29uc3RhbnRzO3ZhciBvPVtdLHM9W107aWYobnVsbCE9cil7bi5pbml0aWFsU3RhdGU9cixvPW8uY29uY2F0KHIpLHRoaXMuc3RhdGVTcGVjPVtdO2Zvcih2YXIgbD0wLHU9cjtsPHUubGVuZ3RoO2wrKyl7dmFyIGM9dVtsXTt0aGlzLnN0YXRlU3BlYy5wdXNoKG5ldyBJbnB1dFNwZWMoe3NoYXBlOmMuc2hhcGV9KSl9cz1zLmNvbmNhdCh0aGlzLnN0YXRlU3BlYyl9aWYobnVsbCE9aSYmKG4uY29uc3RhbnRzPWksbz1vLmNvbmNhdChpKSx0aGlzLm51bUNvbnN0YW50cz1pLmxlbmd0aCksb1swXWluc3RhbmNlb2YgU3ltYm9saWNUZW5zb3Ipe3ZhciBwPVt0XS5jb25jYXQobyksaD10aGlzLmlucHV0U3BlYy5jb25jYXQocyksZD10aGlzLmlucHV0U3BlYzt0aGlzLmlucHV0U3BlYz1oO3ZhciBmPWUucHJvdG90eXBlLmFwcGx5LmNhbGwodGhpcyxwLG4pO3JldHVybiB0aGlzLmlucHV0U3BlYz1kLGZ9cmV0dXJuIGUucHJvdG90eXBlLmFwcGx5LmNhbGwodGhpcyx0LG4pfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciByPW51bGw9PXQ/bnVsbDp0Lm1hc2ssaT1udWxsPT10P251bGw6dC50cmFpbmluZyxhPW51bGw9PXQ/bnVsbDp0LmluaXRpYWxTdGF0ZTtlPWdldEV4YWN0bHlPbmVUZW5zb3IoZSksbnVsbD09YSYmKGE9bi5zdGF0ZWZ1bD9uLnN0YXRlc186bi5nZXRJbml0aWFsU3RhdGUoZSkpO3ZhciBvPUFycmF5LmlzQXJyYXkobi5jZWxsLnN0YXRlU2l6ZSk/bi5jZWxsLnN0YXRlU2l6ZS5sZW5ndGg6MTtpZihhLmxlbmd0aCE9PW8pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJSTk4gTGF5ZXIgaGFzIFwiK28rXCIgc3RhdGUocykgYnV0IHdhcyBwYXNzZWQgXCIrYS5sZW5ndGgrXCIgaW5pdGlhbCBzdGF0ZShzKS5cIik7bi51bnJvbGwmJmNvbnNvbGUud2FybihcIklnbm9yaW5nIHVucm9sbCA9IHRydWUgZm9yIFJOTiBsYXllciwgZHVlIHRvIGltcGVyYXRpdmUgYmFja2VuZC5cIik7dmFyIHM9e3RyYWluaW5nOml9LGw9cm5uKGZ1bmN0aW9uKGUsdCl7dmFyIHI9bi5jZWxsLmNhbGwoW2VdLmNvbmNhdCh0KSxzKTtyZXR1cm5bclswXSxyLnNsaWNlKDEpXX0sZSxhLG4uZ29CYWNrd2FyZHMscixudWxsLG4udW5yb2xsLG4ucmV0dXJuU2VxdWVuY2VzKSx1PWxbMF0sYz1sWzFdLHA9bFsyXTtuLnN0YXRlZnVsJiZuLnJlc2V0U3RhdGVzKHAsaSk7dmFyIGg9bi5yZXR1cm5TZXF1ZW5jZXM/Yzp1O3JldHVybiBuLnJldHVyblN0YXRlP1toXS5jb25jYXQocCk6aH0pfSx0LnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGU9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPXplcm9zKGUuc2hhcGUpO3JldHVybiBuPWV4cGFuZERpbXMkMShuPXN1bShuLFsxLDJdKSksQXJyYXkuaXNBcnJheSh0LmNlbGwuc3RhdGVTaXplKT90LmNlbGwuc3RhdGVTaXplLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZT4xP3RpbGUkMShuLFsxLGVdKTpufSk6dC5jZWxsLnN0YXRlU2l6ZT4xP1t0aWxlJDEobixbMSx0LmNlbGwuc3RhdGVTaXplXSldOltuXX0pfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ0cmFpbmFibGVXZWlnaHRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYWluYWJsZT90aGlzLmNlbGwudHJhaW5hYmxlV2VpZ2h0czpbXX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJub25UcmFpbmFibGVXZWlnaHRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYWluYWJsZT90aGlzLmNlbGwubm9uVHJhaW5hYmxlV2VpZ2h0czp0aGlzLmNlbGwud2VpZ2h0c30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkPWZ1bmN0aW9uKHQpe2UucHJvdG90eXBlLnNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQuY2FsbCh0aGlzLHQpLG51bGwhPXRoaXMuY2VsbCYmdGhpcy5jZWxsLnNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQodCl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtyZXR1cm5TZXF1ZW5jZXM6dGhpcy5yZXR1cm5TZXF1ZW5jZXMscmV0dXJuU3RhdGU6dGhpcy5yZXR1cm5TdGF0ZSxnb0JhY2t3YXJkczp0aGlzLmdvQmFja3dhcmRzLHN0YXRlZnVsOnRoaXMuc3RhdGVmdWwsdW5yb2xsOnRoaXMudW5yb2xsfTtudWxsIT10aGlzLm51bUNvbnN0YW50cyYmKHQubnVtQ29uc3RhbnRzPXRoaXMubnVtQ29uc3RhbnRzKTt2YXIgbj10aGlzLmNlbGwuZ2V0Q29uZmlnKCk7dC5jZWxsPXtjbGFzc05hbWU6dGhpcy5jZWxsLmdldENsYXNzTmFtZSgpLGNvbmZpZzpufTt2YXIgcj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LHIpLHR9LHQuY2xhc3NOYW1lPVwiUk5OXCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhSTk4pO3ZhciBSTk5DZWxsPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0fShMYXllciksU2ltcGxlUk5OQ2VsbD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLkRFRkFVTFRfQUNUSVZBVElPTj1cInRhbmhcIixuLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSPVwiZ2xvcm90Tm9ybWFsXCIsbi5ERUZBVUxUX1JFQ1VSUkVOVF9JTklUSUFMSVpFUj1cIm9ydGhvZ29uYWxcIixuLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUj1cInplcm9zXCIsbi51bml0cz10LnVuaXRzLGFzc2VydFBvc2l0aXZlSW50ZWdlcihuLnVuaXRzLFwidW5pdHNcIiksbi5hY3RpdmF0aW9uPWdldEFjdGl2YXRpb24obnVsbD09dC5hY3RpdmF0aW9uP24uREVGQVVMVF9BQ1RJVkFUSU9OOnQuYWN0aXZhdGlvbiksbi51c2VCaWFzPW51bGw9PXQudXNlQmlhc3x8dC51c2VCaWFzLG4ua2VybmVsSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5rZXJuZWxJbml0aWFsaXplcnx8bi5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUiksbi5yZWN1cnJlbnRJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcih0LnJlY3VycmVudEluaXRpYWxpemVyfHxuLkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSKSxuLmJpYXNJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcih0LmJpYXNJbml0aWFsaXplcnx8bi5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVIpLG4ua2VybmVsUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5rZXJuZWxSZWd1bGFyaXplciksbi5yZWN1cnJlbnRSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0LnJlY3VycmVudFJlZ3VsYXJpemVyKSxuLmJpYXNSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0LmJpYXNSZWd1bGFyaXplciksbi5rZXJuZWxDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5rZXJuZWxDb25zdHJhaW50KSxuLnJlY3VycmVudENvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludCh0LnJlY3VycmVudENvbnN0cmFpbnQpLG4uYmlhc0NvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludCh0LmJpYXNDb25zdHJhaW50KSxuLmRyb3BvdXQ9bWluJDEoWzEsbWF4JDEoWzAsbnVsbD09dC5kcm9wb3V0PzA6dC5kcm9wb3V0XSldKSxuLnJlY3VycmVudERyb3BvdXQ9bWluJDEoWzEsbWF4JDEoWzAsbnVsbD09dC5yZWN1cnJlbnREcm9wb3V0PzA6dC5yZWN1cnJlbnREcm9wb3V0XSldKSxuLnN0YXRlU2l6ZT1uLnVuaXRzLG4uZHJvcG91dE1hc2s9bnVsbCxuLnJlY3VycmVudERyb3BvdXRNYXNrPW51bGwsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7ZT1nZXRFeGFjdGx5T25lU2hhcGUoZSksdGhpcy5rZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJrZXJuZWxcIixbZVtlLmxlbmd0aC0xXSx0aGlzLnVuaXRzXSxudWxsLHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsdGhpcy5rZXJuZWxSZWd1bGFyaXplciwhMCx0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHRoaXMucmVjdXJyZW50S2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwicmVjdXJyZW50X2tlcm5lbFwiLFt0aGlzLnVuaXRzLHRoaXMudW5pdHNdLG51bGwsdGhpcy5yZWN1cnJlbnRJbml0aWFsaXplcix0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyLCEwLHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksdGhpcy51c2VCaWFzP3RoaXMuYmlhcz10aGlzLmFkZFdlaWdodChcImJpYXNcIixbdGhpcy51bml0c10sbnVsbCx0aGlzLmJpYXNJbml0aWFsaXplcix0aGlzLmJpYXNSZWd1bGFyaXplciwhMCx0aGlzLmJpYXNDb25zdHJhaW50KTp0aGlzLmJpYXM9bnVsbCx0aGlzLmJ1aWx0PSEwfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe2lmKDIhPT0oZT1lKS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJTaW1wbGVSTk5DZWxsIGV4cGVjdHMgMiBpbnB1dCBUZW5zb3JzLCBnb3QgXCIrZS5sZW5ndGgrXCIuXCIpO3ZhciByPWVbMV07ZT1lWzBdO3ZhciBpLGE9bnVsbCE9dC50cmFpbmluZyYmdC50cmFpbmluZzswPG4uZHJvcG91dCYmbi5kcm9wb3V0PDEmJm51bGw9PW4uZHJvcG91dE1hc2smJihuLmRyb3BvdXRNYXNrPWdlbmVyYXRlRHJvcG91dE1hc2soZnVuY3Rpb24oKXtyZXR1cm4gb25lc0xpa2UoZSl9LG4uZHJvcG91dCxhKSksMDxuLnJlY3VycmVudERyb3BvdXQmJm4ucmVjdXJyZW50RHJvcG91dDwxJiZudWxsPT1uLnJlY3VycmVudERyb3BvdXRNYXNrJiYobi5yZWN1cnJlbnREcm9wb3V0TWFzaz1nZW5lcmF0ZURyb3BvdXRNYXNrKGZ1bmN0aW9uKCl7cmV0dXJuIG9uZXNMaWtlKHIpfSxuLnJlY3VycmVudERyb3BvdXQsYSkpO3ZhciBvPW4uZHJvcG91dE1hc2sscz1uLnJlY3VycmVudERyb3BvdXRNYXNrO2k9ZG90KG51bGwhPW8/bXVsKGUsbyk6ZSxuLmtlcm5lbC5yZWFkKCkpLG51bGwhPW4uYmlhcyYmKGk9Ymlhc0FkZChpLG4uYmlhcy5yZWFkKCkpKSxudWxsIT1zJiYocj1tdWwocixzKSk7dmFyIGw9YWRkKGksZG90KHIsbi5yZWN1cnJlbnRLZXJuZWwucmVhZCgpKSk7cmV0dXJuIG51bGwhPW4uYWN0aXZhdGlvbiYmKGw9bi5hY3RpdmF0aW9uLmFwcGx5KGwpKSxbbCxsXX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17dW5pdHM6dGhpcy51bml0cyxhY3RpdmF0aW9uOnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKSx1c2VCaWFzOnRoaXMudXNlQmlhcyxrZXJuZWxJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxyZWN1cnJlbnRJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLnJlY3VycmVudEluaXRpYWxpemVyKSxiaWFzSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLGtlcm5lbFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMua2VybmVsUmVndWxhcml6ZXIpLHJlY3VycmVudFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIpLGJpYXNSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmJpYXNSZWd1bGFyaXplciksYWN0aXZpdHlSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLGtlcm5lbENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHJlY3VycmVudENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLGJpYXNDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5iaWFzQ29uc3RyYWludCksZHJvcG91dDp0aGlzLmRyb3BvdXQscmVjdXJyZW50RHJvcG91dDp0aGlzLnJlY3VycmVudERyb3BvdXR9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIlNpbXBsZVJOTkNlbGxcIix0fShSTk5DZWxsKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoU2ltcGxlUk5OQ2VsbCk7dmFyIFNpbXBsZVJOTj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiB0LmNlbGw9bmV3IFNpbXBsZVJOTkNlbGwodCksZS5jYWxsKHRoaXMsdCl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24odCxuKXt2YXIgcj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7bnVsbCE9ci5jZWxsLmRyb3BvdXRNYXNrJiYoZGlzcG9zZShyLmNlbGwuZHJvcG91dE1hc2spLHIuY2VsbC5kcm9wb3V0TWFzaz1udWxsKSxudWxsIT1yLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2smJihkaXNwb3NlKHIuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzayksci5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrPW51bGwpO3ZhciBpPW51bGw9PW4/bnVsbDpuLm1hc2ssYT1udWxsPT1uP251bGw6bi50cmFpbmluZyxvPW51bGw9PW4/bnVsbDpuLmluaXRpYWxTdGF0ZTtyZXR1cm4gZS5wcm90b3R5cGUuY2FsbC5jYWxsKHIsdCx7bWFzazppLHRyYWluaW5nOmEsaW5pdGlhbFN0YXRlOm99KX0pfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ1bml0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnVuaXRzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImFjdGl2YXRpb25cIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5hY3RpdmF0aW9ufSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInVzZUJpYXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC51c2VCaWFzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImtlcm5lbEluaXRpYWxpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwua2VybmVsSW5pdGlhbGl6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVjdXJyZW50SW5pdGlhbGl6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRJbml0aWFsaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJiaWFzSW5pdGlhbGl6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5iaWFzSW5pdGlhbGl6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwia2VybmVsUmVndWxhcml6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5rZXJuZWxSZWd1bGFyaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyZWN1cnJlbnRSZWd1bGFyaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudFJlZ3VsYXJpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImJpYXNSZWd1bGFyaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmJpYXNSZWd1bGFyaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJrZXJuZWxDb25zdHJhaW50XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwua2VybmVsQ29uc3RyYWludH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyZWN1cnJlbnRDb25zdHJhaW50XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50Q29uc3RyYWludH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJiaWFzQ29uc3RyYWludFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmJpYXNDb25zdHJhaW50fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImRyb3BvdXRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5kcm9wb3V0fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJlY3VycmVudERyb3BvdXRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnREcm9wb3V0fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXt1bml0czp0aGlzLnVuaXRzLGFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLHVzZUJpYXM6dGhpcy51c2VCaWFzLGtlcm5lbEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLHJlY3VycmVudEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIpLGJpYXNJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksa2VybmVsUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplcikscmVjdXJyZW50UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciksYmlhc1JlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksa2VybmVsQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMua2VybmVsQ29uc3RyYWludCkscmVjdXJyZW50Q29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksYmlhc0NvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KSxkcm9wb3V0OnRoaXMuZHJvcG91dCxyZWN1cnJlbnREcm9wb3V0OnRoaXMucmVjdXJyZW50RHJvcG91dH0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gZGVsZXRlIG4uY2VsbCxPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJTaW1wbGVSTk5cIix0fShSTk4pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTaW1wbGVSTk4pO3ZhciBHUlVDZWxsPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIG4uREVGQVVMVF9BQ1RJVkFUSU9OPVwidGFuaFwiLG4uREVGQVVMVF9SRUNVUlJFTlRfQUNUSVZBVElPTj1cImhhcmRTaWdtb2lkXCIsbi5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUj1cImdsb3JvdE5vcm1hbFwiLG4uREVGQVVMVF9SRUNVUlJFTlRfSU5JVElBTElaRVI9XCJvcnRob2dvbmFsXCIsbi5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVI9XCJ6ZXJvc1wiLG4udW5pdHM9dC51bml0cyxhc3NlcnRQb3NpdGl2ZUludGVnZXIobi51bml0cyxcInVuaXRzXCIpLG4uYWN0aXZhdGlvbj1nZXRBY3RpdmF0aW9uKHZvaWQgMD09PXQuYWN0aXZhdGlvbj9uLkRFRkFVTFRfQUNUSVZBVElPTjp0LmFjdGl2YXRpb24pLG4ucmVjdXJyZW50QWN0aXZhdGlvbj1nZXRBY3RpdmF0aW9uKHZvaWQgMD09PXQucmVjdXJyZW50QWN0aXZhdGlvbj9uLkRFRkFVTFRfUkVDVVJSRU5UX0FDVElWQVRJT046dC5yZWN1cnJlbnRBY3RpdmF0aW9uKSxuLnVzZUJpYXM9bnVsbD09dC51c2VCaWFzfHx0LnVzZUJpYXMsbi5rZXJuZWxJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcih0Lmtlcm5lbEluaXRpYWxpemVyfHxuLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKSxuLnJlY3VycmVudEluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQucmVjdXJyZW50SW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9SRUNVUlJFTlRfSU5JVElBTElaRVIpLG4uYmlhc0luaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQuYmlhc0luaXRpYWxpemVyfHxuLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUiksbi5rZXJuZWxSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0Lmtlcm5lbFJlZ3VsYXJpemVyKSxuLnJlY3VycmVudFJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQucmVjdXJyZW50UmVndWxhcml6ZXIpLG4uYmlhc1JlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQuYmlhc1JlZ3VsYXJpemVyKSxuLmtlcm5lbENvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludCh0Lmtlcm5lbENvbnN0cmFpbnQpLG4ucmVjdXJyZW50Q29uc3RyYWludD1nZXRDb25zdHJhaW50KHQucmVjdXJyZW50Q29uc3RyYWludCksbi5iaWFzQ29uc3RyYWludD1nZXRDb25zdHJhaW50KHQuYmlhc0NvbnN0cmFpbnQpLG4uZHJvcG91dD1taW4kMShbMSxtYXgkMShbMCxudWxsPT10LmRyb3BvdXQ/MDp0LmRyb3BvdXRdKV0pLG4ucmVjdXJyZW50RHJvcG91dD1taW4kMShbMSxtYXgkMShbMCxudWxsPT10LnJlY3VycmVudERyb3BvdXQ/MDp0LnJlY3VycmVudERyb3BvdXRdKV0pLG4uaW1wbGVtZW50YXRpb249dC5pbXBsZW1lbnRhdGlvbixuLnN0YXRlU2l6ZT1uLnVuaXRzLG4uZHJvcG91dE1hc2s9bnVsbCxuLnJlY3VycmVudERyb3BvdXRNYXNrPW51bGwsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7dmFyIHQ9KGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpKVtlLmxlbmd0aC0xXTt0aGlzLmtlcm5lbD10aGlzLmFkZFdlaWdodChcImtlcm5lbFwiLFt0LDMqdGhpcy51bml0c10sbnVsbCx0aGlzLmtlcm5lbEluaXRpYWxpemVyLHRoaXMua2VybmVsUmVndWxhcml6ZXIsITAsdGhpcy5rZXJuZWxDb25zdHJhaW50KSx0aGlzLnJlY3VycmVudEtlcm5lbD10aGlzLmFkZFdlaWdodChcInJlY3VycmVudF9rZXJuZWxcIixbdGhpcy51bml0cywzKnRoaXMudW5pdHNdLG51bGwsdGhpcy5yZWN1cnJlbnRJbml0aWFsaXplcix0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyLCEwLHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksdGhpcy51c2VCaWFzP3RoaXMuYmlhcz10aGlzLmFkZFdlaWdodChcImJpYXNcIixbMyp0aGlzLnVuaXRzXSxudWxsLHRoaXMuYmlhc0luaXRpYWxpemVyLHRoaXMuYmlhc1JlZ3VsYXJpemVyLCEwLHRoaXMuYmlhc0NvbnN0cmFpbnQpOnRoaXMuYmlhcz1udWxsLHRoaXMuYnVpbHQ9ITB9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7aWYoMiE9PShlPWUpLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkdSVUNlbGwgZXhwZWN0cyAyIGlucHV0IFRlbnNvcnMgKGlucHV0cywgaCwgYyksIGdvdCBcIitlLmxlbmd0aCtcIi5cIik7dmFyIHI9bnVsbCE9dC50cmFpbmluZyYmdC50cmFpbmluZyxpPWVbMV07ZT1lWzBdLDA8bi5kcm9wb3V0JiZuLmRyb3BvdXQ8MSYmbnVsbD09bi5kcm9wb3V0TWFzayYmKG4uZHJvcG91dE1hc2s9Z2VuZXJhdGVEcm9wb3V0TWFzayhmdW5jdGlvbigpe3JldHVybiBvbmVzTGlrZShlKX0sbi5kcm9wb3V0LHIsMykpLDA8bi5yZWN1cnJlbnREcm9wb3V0JiZuLnJlY3VycmVudERyb3BvdXQ8MSYmbnVsbD09bi5yZWN1cnJlbnREcm9wb3V0TWFzayYmKG4ucmVjdXJyZW50RHJvcG91dE1hc2s9Z2VuZXJhdGVEcm9wb3V0TWFzayhmdW5jdGlvbigpe3JldHVybiBvbmVzTGlrZShpKX0sbi5yZWN1cnJlbnREcm9wb3V0LHIsMykpO3ZhciBhLG8scyxsPW4uZHJvcG91dE1hc2ssdT1uLnJlY3VycmVudERyb3BvdXRNYXNrOzA8bi5kcm9wb3V0JiZuLmRyb3BvdXQ8MSYmKGU9bXVsKGUsbFswXSkpO3ZhciBjPWRvdChlLG4ua2VybmVsLnJlYWQoKSk7bi51c2VCaWFzJiYoYz1iaWFzQWRkKGMsbi5iaWFzLnJlYWQoKSkpLDA8bi5yZWN1cnJlbnREcm9wb3V0JiZuLnJlY3VycmVudERyb3BvdXQ8MSYmKGk9bXVsKGksdVswXSkpO3ZhciBwPW4ucmVjdXJyZW50S2VybmVsLnJlYWQoKSxoPXNwbGl0KHAsWzIqbi51bml0cyxuLnVuaXRzXSxwLnJhbmstMSksZD1oWzBdLGY9aFsxXSxnPWRvdChpLGQpLG09c3BsaXQoYywzLGMucmFuay0xKSx5PW1bMF0sdj1tWzFdLGI9bVsyXSx3PXNwbGl0KGcsMixnLnJhbmstMSksej13WzBdLFM9d1sxXTthPW4ucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseShhZGQoeSx6KSksbz1uLnJlY3VycmVudEFjdGl2YXRpb24uYXBwbHkoYWRkKHYsUykpO3ZhciBJPWRvdChtdWwobyxpKSxmKTtzPW4uYWN0aXZhdGlvbi5hcHBseShhZGQoYixJKSk7dmFyIEE9YWRkKG11bChhLGkpLG11bChhZGQoMSxuZWcoYSkpLHMpKTtyZXR1cm5bQSxBXX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17dW5pdHM6dGhpcy51bml0cyxhY3RpdmF0aW9uOnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKSxyZWN1cnJlbnRBY3RpdmF0aW9uOnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uKSx1c2VCaWFzOnRoaXMudXNlQmlhcyxrZXJuZWxJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxyZWN1cnJlbnRJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLnJlY3VycmVudEluaXRpYWxpemVyKSxiaWFzSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLGtlcm5lbFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMua2VybmVsUmVndWxhcml6ZXIpLHJlY3VycmVudFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIpLGJpYXNSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmJpYXNSZWd1bGFyaXplciksYWN0aXZpdHlSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLGtlcm5lbENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHJlY3VycmVudENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLGJpYXNDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5iaWFzQ29uc3RyYWludCksZHJvcG91dDp0aGlzLmRyb3BvdXQscmVjdXJyZW50RHJvcG91dDp0aGlzLnJlY3VycmVudERyb3BvdXQsaW1wbGVtZW50YXRpb246dGhpcy5pbXBsZW1lbnRhdGlvbn0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiR1JVQ2VsbFwiLHR9KFJOTkNlbGwpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhHUlVDZWxsKTt2YXIgR1JVPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIDA9PT10LmltcGxlbWVudGF0aW9uJiZjb25zb2xlLndhcm4oXCJgaW1wbGVtZW50YXRpb249MGAgaGFzIGJlZW4gZGVwcmVjYXRlZCwgYW5kIG5vdyBkZWZhdWx0cyB0byBgaW1wbGVtZW50YXRpb249MWAuIFBsZWFzZSB1cGRhdGUgeW91ciBsYXllciBjYWxsLlwiKSx0LmNlbGw9bmV3IEdSVUNlbGwodCksZS5jYWxsKHRoaXMsdCl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24odCxuKXt2YXIgcj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7bnVsbCE9ci5jZWxsLmRyb3BvdXRNYXNrJiYoZGlzcG9zZShyLmNlbGwuZHJvcG91dE1hc2spLHIuY2VsbC5kcm9wb3V0TWFzaz1udWxsKSxudWxsIT1yLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2smJihkaXNwb3NlKHIuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzayksci5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrPW51bGwpO3ZhciBpPW51bGw9PW4/bnVsbDpuLm1hc2ssYT1udWxsPT1uP251bGw6bi50cmFpbmluZyxvPW51bGw9PW4/bnVsbDpuLmluaXRpYWxTdGF0ZTtyZXR1cm4gZS5wcm90b3R5cGUuY2FsbC5jYWxsKHIsdCx7bWFzazppLHRyYWluaW5nOmEsaW5pdGlhbFN0YXRlOm99KX0pfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ1bml0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnVuaXRzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImFjdGl2YXRpb25cIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5hY3RpdmF0aW9ufSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJlY3VycmVudEFjdGl2YXRpb25cIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRBY3RpdmF0aW9ufSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInVzZUJpYXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC51c2VCaWFzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImtlcm5lbEluaXRpYWxpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwua2VybmVsSW5pdGlhbGl6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVjdXJyZW50SW5pdGlhbGl6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRJbml0aWFsaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJiaWFzSW5pdGlhbGl6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5iaWFzSW5pdGlhbGl6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwia2VybmVsUmVndWxhcml6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5rZXJuZWxSZWd1bGFyaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyZWN1cnJlbnRSZWd1bGFyaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudFJlZ3VsYXJpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImJpYXNSZWd1bGFyaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmJpYXNSZWd1bGFyaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJrZXJuZWxDb25zdHJhaW50XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwua2VybmVsQ29uc3RyYWludH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyZWN1cnJlbnRDb25zdHJhaW50XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50Q29uc3RyYWludH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJiaWFzQ29uc3RyYWludFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmJpYXNDb25zdHJhaW50fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImRyb3BvdXRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5kcm9wb3V0fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJlY3VycmVudERyb3BvdXRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnREcm9wb3V0fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImltcGxlbWVudGF0aW9uXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuaW1wbGVtZW50YXRpb259LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e3VuaXRzOnRoaXMudW5pdHMsYWN0aXZhdGlvbjpzZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMuYWN0aXZhdGlvbikscmVjdXJyZW50QWN0aXZhdGlvbjpzZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMucmVjdXJyZW50QWN0aXZhdGlvbiksdXNlQmlhczp0aGlzLnVzZUJpYXMsa2VybmVsSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5rZXJuZWxJbml0aWFsaXplcikscmVjdXJyZW50SW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5yZWN1cnJlbnRJbml0aWFsaXplciksYmlhc0luaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYmlhc0luaXRpYWxpemVyKSxrZXJuZWxSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmtlcm5lbFJlZ3VsYXJpemVyKSxyZWN1cnJlbnRSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyKSxiaWFzUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5iaWFzUmVndWxhcml6ZXIpLGFjdGl2aXR5UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxrZXJuZWxDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5rZXJuZWxDb25zdHJhaW50KSxyZWN1cnJlbnRDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KSxiaWFzQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMuYmlhc0NvbnN0cmFpbnQpLGRyb3BvdXQ6dGhpcy5kcm9wb3V0LHJlY3VycmVudERyb3BvdXQ6dGhpcy5yZWN1cnJlbnREcm9wb3V0LGltcGxlbWVudGF0aW9uOnRoaXMuaW1wbGVtZW50YXRpb259LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIGRlbGV0ZSBuLmNlbGwsT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuZnJvbUNvbmZpZz1mdW5jdGlvbihlLHQpe3JldHVybiAwPT09dC5pbXBsbWVudGF0aW9uJiYodC5pbXBsZW1lbnRhdGlvbj0xKSxuZXcgZSh0KX0sdC5jbGFzc05hbWU9XCJHUlVcIix0fShSTk4pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhHUlUpO3ZhciBMU1RNQ2VsbD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLkRFRkFVTFRfQUNUSVZBVElPTj1cInRhbmhcIixuLkRFRkFVTFRfUkVDVVJSRU5UX0FDVElWQVRJT049XCJoYXJkU2lnbW9pZFwiLG4uREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVI9XCJnbG9yb3ROb3JtYWxcIixuLkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSPVwib3J0aG9nb25hbFwiLG4uREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSPVwiemVyb3NcIixuLnVuaXRzPXQudW5pdHMsYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKG4udW5pdHMsXCJ1bml0c1wiKSxuLmFjdGl2YXRpb249Z2V0QWN0aXZhdGlvbih2b2lkIDA9PT10LmFjdGl2YXRpb24/bi5ERUZBVUxUX0FDVElWQVRJT046dC5hY3RpdmF0aW9uKSxuLnJlY3VycmVudEFjdGl2YXRpb249Z2V0QWN0aXZhdGlvbih2b2lkIDA9PT10LnJlY3VycmVudEFjdGl2YXRpb24/bi5ERUZBVUxUX1JFQ1VSUkVOVF9BQ1RJVkFUSU9OOnQucmVjdXJyZW50QWN0aXZhdGlvbiksbi51c2VCaWFzPW51bGw9PXQudXNlQmlhc3x8dC51c2VCaWFzLG4ua2VybmVsSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5rZXJuZWxJbml0aWFsaXplcnx8bi5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUiksbi5yZWN1cnJlbnRJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcih0LnJlY3VycmVudEluaXRpYWxpemVyfHxuLkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSKSxuLmJpYXNJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcih0LmJpYXNJbml0aWFsaXplcnx8bi5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVIpLG4udW5pdEZvcmdldEJpYXM9dC51bml0Rm9yZ2V0QmlhcyxuLmtlcm5lbFJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQua2VybmVsUmVndWxhcml6ZXIpLG4ucmVjdXJyZW50UmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5yZWN1cnJlbnRSZWd1bGFyaXplciksbi5iaWFzUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5iaWFzUmVndWxhcml6ZXIpLG4ua2VybmVsQ29uc3RyYWludD1nZXRDb25zdHJhaW50KHQua2VybmVsQ29uc3RyYWludCksbi5yZWN1cnJlbnRDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5yZWN1cnJlbnRDb25zdHJhaW50KSxuLmJpYXNDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5iaWFzQ29uc3RyYWludCksbi5kcm9wb3V0PW1pbiQxKFsxLG1heCQxKFswLG51bGw9PXQuZHJvcG91dD8wOnQuZHJvcG91dF0pXSksbi5yZWN1cnJlbnREcm9wb3V0PW1pbiQxKFsxLG1heCQxKFswLG51bGw9PXQucmVjdXJyZW50RHJvcG91dD8wOnQucmVjdXJyZW50RHJvcG91dF0pXSksbi5pbXBsZW1lbnRhdGlvbj10LmltcGxlbWVudGF0aW9uLG4uc3RhdGVTaXplPVtuLnVuaXRzLG4udW5pdHNdLG4uZHJvcG91dE1hc2s9bnVsbCxuLnJlY3VycmVudERyb3BvdXRNYXNrPW51bGwsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7dmFyIHQsbixyPShlPWdldEV4YWN0bHlPbmVTaGFwZShlKSlbZS5sZW5ndGgtMV07aWYodGhpcy5rZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJrZXJuZWxcIixbciw0KnRoaXMudW5pdHNdLG51bGwsdGhpcy5rZXJuZWxJbml0aWFsaXplcix0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCEwLHRoaXMua2VybmVsQ29uc3RyYWludCksdGhpcy5yZWN1cnJlbnRLZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJyZWN1cnJlbnRfa2VybmVsXCIsW3RoaXMudW5pdHMsNCp0aGlzLnVuaXRzXSxudWxsLHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIsdGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciwhMCx0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLHRoaXMudXNlQmlhcyl7aWYodGhpcy51bml0Rm9yZ2V0Qmlhcyl7dmFyIGk9dGhpcy5iaWFzSW5pdGlhbGl6ZXIsYT10aGlzLnVuaXRzO249bmV3KCh0PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLHQpe3ZhciBuPWkuYXBwbHkoW2FdKSxyPShuZXcgT25lcykuYXBwbHkoW2FdKSxvPWkuYXBwbHkoWzIqYV0pO3JldHVybiBjb25jYXRBbG9uZ0ZpcnN0QXhpcyhjb25jYXRBbG9uZ0ZpcnN0QXhpcyhuLHIpLG8pfSx0fShJbml0aWFsaXplcikpLmNsYXNzTmFtZT1cIkN1c3RvbUluaXRcIix0KX1lbHNlIG49dGhpcy5iaWFzSW5pdGlhbGl6ZXI7dGhpcy5iaWFzPXRoaXMuYWRkV2VpZ2h0KFwiYmlhc1wiLFs0KnRoaXMudW5pdHNdLG51bGwsbix0aGlzLmJpYXNSZWd1bGFyaXplciwhMCx0aGlzLmJpYXNDb25zdHJhaW50KX1lbHNlIHRoaXMuYmlhcz1udWxsO3RoaXMuYnVpbHQ9ITB9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHI9bnVsbCE9dC50cmFpbmluZyYmdC50cmFpbmluZztpZigzIT09KGU9ZSkubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTFNUTUNlbGwgZXhwZWN0cyAzIGlucHV0IFRlbnNvcnMgKGlucHV0cywgaCwgYyksIGdvdCBcIitlLmxlbmd0aCtcIi5cIik7dmFyIGk9ZVsxXSxhPWVbMl07ZT1lWzBdLDA8bi5kcm9wb3V0JiZuLmRyb3BvdXQ8MSYmbnVsbD09bi5kcm9wb3V0TWFzayYmKG4uZHJvcG91dE1hc2s9Z2VuZXJhdGVEcm9wb3V0TWFzayhmdW5jdGlvbigpe3JldHVybiBvbmVzTGlrZShlKX0sbi5kcm9wb3V0LHIsNCkpLDA8bi5yZWN1cnJlbnREcm9wb3V0JiZuLnJlY3VycmVudERyb3BvdXQ8MSYmbnVsbD09bi5yZWN1cnJlbnREcm9wb3V0TWFzayYmKG4ucmVjdXJyZW50RHJvcG91dE1hc2s9Z2VuZXJhdGVEcm9wb3V0TWFzayhmdW5jdGlvbigpe3JldHVybiBvbmVzTGlrZShpKX0sbi5yZWN1cnJlbnREcm9wb3V0LHIsNCkpO3ZhciBvLHMsbCx1LGM9bi5kcm9wb3V0TWFzayxwPW4ucmVjdXJyZW50RHJvcG91dE1hc2s7MDxuLmRyb3BvdXQmJm4uZHJvcG91dDwxJiYoZT1tdWwoZSxjWzBdKSk7dmFyIGg9ZG90KGUsbi5rZXJuZWwucmVhZCgpKTswPG4ucmVjdXJyZW50RHJvcG91dCYmbi5yZWN1cnJlbnREcm9wb3V0PDEmJihpPW11bChpLHBbMF0pKSxoPWFkZChoLGRvdChpLG4ucmVjdXJyZW50S2VybmVsLnJlYWQoKSkpLG4udXNlQmlhcyYmKGg9Ymlhc0FkZChoLG4uYmlhcy5yZWFkKCkpKTt2YXIgZD1zcGxpdChoLDQsaC5yYW5rLTEpLGY9ZFswXSxnPWRbMV0sbT1kWzJdLHk9ZFszXTtvPW4ucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseShmKSxzPW4ucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseShnKSxsPWFkZChtdWwocyxhKSxtdWwobyxuLmFjdGl2YXRpb24uYXBwbHkobSkpKSx1PW4ucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseSh5KTt2YXIgdj1tdWwodSxuLmFjdGl2YXRpb24uYXBwbHkobCkpO3JldHVyblt2LHYsbF19KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e3VuaXRzOnRoaXMudW5pdHMsYWN0aXZhdGlvbjpzZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMuYWN0aXZhdGlvbikscmVjdXJyZW50QWN0aXZhdGlvbjpzZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMucmVjdXJyZW50QWN0aXZhdGlvbiksdXNlQmlhczp0aGlzLnVzZUJpYXMsa2VybmVsSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5rZXJuZWxJbml0aWFsaXplcikscmVjdXJyZW50SW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5yZWN1cnJlbnRJbml0aWFsaXplciksYmlhc0luaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYmlhc0luaXRpYWxpemVyKSx1bml0Rm9yZ2V0Qmlhczp0aGlzLnVuaXRGb3JnZXRCaWFzLGtlcm5lbFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMua2VybmVsUmVndWxhcml6ZXIpLHJlY3VycmVudFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIpLGJpYXNSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmJpYXNSZWd1bGFyaXplciksYWN0aXZpdHlSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLGtlcm5lbENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHJlY3VycmVudENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLGJpYXNDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5iaWFzQ29uc3RyYWludCksZHJvcG91dDp0aGlzLmRyb3BvdXQscmVjdXJyZW50RHJvcG91dDp0aGlzLnJlY3VycmVudERyb3BvdXQsaW1wbGVtZW50YXRpb246dGhpcy5pbXBsZW1lbnRhdGlvbn0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiTFNUTUNlbGxcIix0fShSTk5DZWxsKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTFNUTUNlbGwpO3ZhciBMU1RNPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIDA9PT10LmltcGxlbWVudGF0aW9uJiZjb25zb2xlLndhcm4oXCJgaW1wbGVtZW50YXRpb249MGAgaGFzIGJlZW4gZGVwcmVjYXRlZCwgYW5kIG5vdyBkZWZhdWx0cyB0byBgaW1wbGVtZW50YXRpb249MWAuIFBsZWFzZSB1cGRhdGUgeW91ciBsYXllciBjYWxsLlwiKSx0LmNlbGw9bmV3IExTVE1DZWxsKHQpLGUuY2FsbCh0aGlzLHQpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKHQsbil7dmFyIHI9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe251bGwhPXIuY2VsbC5kcm9wb3V0TWFzayYmKGRpc3Bvc2Uoci5jZWxsLmRyb3BvdXRNYXNrKSxyLmNlbGwuZHJvcG91dE1hc2s9bnVsbCksbnVsbCE9ci5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrJiYoZGlzcG9zZShyLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2spLHIuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzaz1udWxsKTt2YXIgaT1udWxsPT1uP251bGw6bi5tYXNrLGE9bnVsbD09bj9udWxsOm4udHJhaW5pbmcsbz1udWxsPT1uP251bGw6bi5pbml0aWFsU3RhdGU7cmV0dXJuIGUucHJvdG90eXBlLmNhbGwuY2FsbChyLHQse21hc2s6aSx0cmFpbmluZzphLGluaXRpYWxTdGF0ZTpvfSl9KX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidW5pdHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC51bml0c30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJhY3RpdmF0aW9uXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYWN0aXZhdGlvbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyZWN1cnJlbnRBY3RpdmF0aW9uXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50QWN0aXZhdGlvbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ1c2VCaWFzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwudXNlQmlhc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJrZXJuZWxJbml0aWFsaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmtlcm5lbEluaXRpYWxpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJlY3VycmVudEluaXRpYWxpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50SW5pdGlhbGl6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiYmlhc0luaXRpYWxpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYmlhc0luaXRpYWxpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInVuaXRGb3JnZXRCaWFzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwudW5pdEZvcmdldEJpYXN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwia2VybmVsUmVndWxhcml6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5rZXJuZWxSZWd1bGFyaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyZWN1cnJlbnRSZWd1bGFyaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudFJlZ3VsYXJpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImJpYXNSZWd1bGFyaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmJpYXNSZWd1bGFyaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJrZXJuZWxDb25zdHJhaW50XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwua2VybmVsQ29uc3RyYWludH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyZWN1cnJlbnRDb25zdHJhaW50XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50Q29uc3RyYWludH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJiaWFzQ29uc3RyYWludFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmJpYXNDb25zdHJhaW50fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImRyb3BvdXRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5kcm9wb3V0fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJlY3VycmVudERyb3BvdXRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnREcm9wb3V0fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImltcGxlbWVudGF0aW9uXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuaW1wbGVtZW50YXRpb259LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e3VuaXRzOnRoaXMudW5pdHMsYWN0aXZhdGlvbjpzZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMuYWN0aXZhdGlvbikscmVjdXJyZW50QWN0aXZhdGlvbjpzZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMucmVjdXJyZW50QWN0aXZhdGlvbiksdXNlQmlhczp0aGlzLnVzZUJpYXMsa2VybmVsSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5rZXJuZWxJbml0aWFsaXplcikscmVjdXJyZW50SW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5yZWN1cnJlbnRJbml0aWFsaXplciksYmlhc0luaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYmlhc0luaXRpYWxpemVyKSx1bml0Rm9yZ2V0Qmlhczp0aGlzLnVuaXRGb3JnZXRCaWFzLGtlcm5lbFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMua2VybmVsUmVndWxhcml6ZXIpLHJlY3VycmVudFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIpLGJpYXNSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmJpYXNSZWd1bGFyaXplciksYWN0aXZpdHlSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLGtlcm5lbENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHJlY3VycmVudENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLGJpYXNDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5iaWFzQ29uc3RyYWludCksZHJvcG91dDp0aGlzLmRyb3BvdXQscmVjdXJyZW50RHJvcG91dDp0aGlzLnJlY3VycmVudERyb3BvdXQsaW1wbGVtZW50YXRpb246dGhpcy5pbXBsZW1lbnRhdGlvbn0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gZGVsZXRlIG4uY2VsbCxPYmplY3QuYXNzaWduKHQsbiksdH0sdC5mcm9tQ29uZmlnPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIDA9PT10LmltcGxtZW50YXRpb24mJih0LmltcGxlbWVudGF0aW9uPTEpLG5ldyBlKHQpfSx0LmNsYXNzTmFtZT1cIkxTVE1cIix0fShSTk4pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhMU1RNKTt2YXIgU3RhY2tlZFJOTkNlbGxzPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIG4uY2VsbHM9dC5jZWxscyxufXJldHVybiBfX2V4dGVuZHModCxlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJzdGF0ZVNpemVcIix7Z2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MCxuPXRoaXMuY2VsbHMuc2xpY2UoKS5yZXZlcnNlKCk7dDxuLmxlbmd0aDt0Kyspe3ZhciByPW5bdF07QXJyYXkuaXNBcnJheShyLnN0YXRlU2l6ZSk/ZS5wdXNoLmFwcGx5KGUsci5zdGF0ZVNpemUpOmUucHVzaChyLnN0YXRlU2l6ZSl9cmV0dXJuIGV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtmb3IodmFyIHI9KGU9ZSkuc2xpY2UoMSksaT1bXSxhPTAsbz1uLmNlbGxzLnNsaWNlKCkucmV2ZXJzZSgpO2E8by5sZW5ndGg7YSsrKXt2YXIgcz1vW2FdO0FycmF5LmlzQXJyYXkocy5zdGF0ZVNpemUpP2kucHVzaChyLnNwbGljZSgwLHMuc3RhdGVTaXplLmxlbmd0aCkpOmkucHVzaChyLnNwbGljZSgwLDEpKX1pLnJldmVyc2UoKTtmb3IodmFyIGwsdT1bXSxjPTA7YzxuLmNlbGxzLmxlbmd0aDsrK2Mpe3M9bi5jZWxsc1tjXTtyPWlbY10sbD0wPT09Yz9bZVswXV0uY29uY2F0KHIpOltsWzBdXS5jb25jYXQociksbD1zLmNhbGwobCx0KSx1LnB1c2gobC5zbGljZSgxKSl9cj1bXTtmb3IodmFyIHA9MCxoPXUuc2xpY2UoKS5yZXZlcnNlKCk7cDxoLmxlbmd0aDtwKyspe3ZhciBkPWhbcF07ci5wdXNoLmFwcGx5KHIsZCl9cmV0dXJuW2xbMF1dLmNvbmNhdChyKX0pfSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXt2YXIgdDtpc0FycmF5T2ZTaGFwZXMoZSkmJihlPWVbMF0pLGU9ZTtmb3IodmFyIG49MCxyPXRoaXMuY2VsbHM7bjxyLmxlbmd0aDtuKyspe3ZhciBpPXJbbl07aS5idWlsZChlKSx0PUFycmF5LmlzQXJyYXkoaS5zdGF0ZVNpemUpP2kuc3RhdGVTaXplWzBdOmkuc3RhdGVTaXplLGU9W2VbMF0sdF19dGhpcy5idWlsdD0hMH0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLG49MCxyPXRoaXMuY2VsbHM7bjxyLmxlbmd0aDtuKyspe3ZhciBpPXJbbl07dC5wdXNoKHtjbGFzc05hbWU6dGhpcy5nZXRDbGFzc05hbWUoKSxjb25maWc6aS5nZXRDb25maWcoKX0pfXZhciBhPXtjZWxsczp0fSxvPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKGEsbyksYX0sdC5mcm9tQ29uZmlnPWZ1bmN0aW9uKGUsdCxuKXt2b2lkIDA9PT1uJiYobj17fSk7Zm9yKHZhciByPVtdLGk9MCxhPXQuY2VsbHM7aTxhLmxlbmd0aDtpKyspe3ZhciBvPWFbaV07ci5wdXNoKGRlc2VyaWFsaXplKG8sbikpfXJldHVybiBuZXcgZSh7Y2VsbHM6cn0pfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ0cmFpbmFibGVXZWlnaHRzXCIse2dldDpmdW5jdGlvbigpe2lmKCF0aGlzLnRyYWluYWJsZSlyZXR1cm5bXTtmb3IodmFyIGU9W10sdD0wLG49dGhpcy5jZWxsczt0PG4ubGVuZ3RoO3QrKyl7dmFyIHI9blt0XTtlLnB1c2guYXBwbHkoZSxyLnRyYWluYWJsZVdlaWdodHMpfXJldHVybiBlfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIm5vblRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MCxuPXRoaXMuY2VsbHM7dDxuLmxlbmd0aDt0Kyspe3ZhciByPW5bdF07ZS5wdXNoLmFwcGx5KGUsci5ub25UcmFpbmFibGVXZWlnaHRzKX1pZighdGhpcy50cmFpbmFibGUpe2Zvcih2YXIgaT1bXSxhPTAsbz10aGlzLmNlbGxzO2E8by5sZW5ndGg7YSsrKXtyPW9bYV07aS5wdXNoLmFwcGx5KGksci50cmFpbmFibGVXZWlnaHRzKX1yZXR1cm4gaS5jb25jYXQoZSl9cmV0dXJuIGV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuZ2V0V2VpZ2h0cz1mdW5jdGlvbigpe2Zvcih2YXIgZT1bXSx0PTAsbj10aGlzLmNlbGxzO3Q8bi5sZW5ndGg7dCsrKXt2YXIgcj1uW3RdO2UucHVzaC5hcHBseShlLHIud2VpZ2h0cyl9cmV0dXJuIGJhdGNoR2V0VmFsdWUoZSl9LHQucHJvdG90eXBlLnNldFdlaWdodHM9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVtdLG49MCxyPXRoaXMuY2VsbHM7bjxyLmxlbmd0aDtuKyspZm9yKHZhciBpPXJbbl0sYT1pLndlaWdodHMubGVuZ3RoLG89ZS5zcGxpY2UoYSkscz0wO3M8aS53ZWlnaHRzLmxlbmd0aDsrK3MpdC5wdXNoKFtpLndlaWdodHNbc10sb1tzXV0pO2JhdGNoU2V0VmFsdWUodCl9LHQuY2xhc3NOYW1lPVwiU3RhY2tlZFJOTkNlbGxzXCIsdH0oUk5OQ2VsbCk7ZnVuY3Rpb24gZ2VuZXJhdGVEcm9wb3V0TWFzayhlLHQsbixyKXtmdW5jdGlvbiBpKCl7cmV0dXJuIGRyb3BvdXQoZSgpLHQpfWlmKHZvaWQgMD09PW4mJihuPW51bGwpLHZvaWQgMD09PXImJihyPTEpLHI+MSl7Zm9yKHZhciBhPVtdLG89MDtvPHI7bysrKWEucHVzaChpblRyYWluUGhhc2UoaSxlLG4pKTtyZXR1cm4gYS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGtlZXAoZS5jbG9uZSgpKX0pfXJldHVybiBrZWVwKGluVHJhaW5QaGFzZShpLGUsbikuY2xvbmUoKSl9c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFN0YWNrZWRSTk5DZWxscyk7dmFyIFdyYXBwZXI9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5sYXllcj10LmxheWVyLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe3RoaXMuYnVpbHQ9ITB9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInRyYWluYWJsZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9dGhpcy5sYXllciYmdGhpcy5sYXllci50cmFpbmFibGV9LHNldDpmdW5jdGlvbihlKXtudWxsIT10aGlzLmxheWVyJiYodGhpcy5sYXllci50cmFpbmFibGU9ZSl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidHJhaW5hYmxlV2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYXllci50cmFpbmFibGVXZWlnaHRzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIm5vblRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGF5ZXIubm9uVHJhaW5hYmxlV2VpZ2h0c30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ1cGRhdGVzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxheWVyLl91cGRhdGVzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImxvc3Nlc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYXllci5sb3NzZXN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuZ2V0V2VpZ2h0cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxheWVyLmdldFdlaWdodHMoKX0sdC5wcm90b3R5cGUuc2V0V2VpZ2h0cz1mdW5jdGlvbihlKXt0aGlzLmxheWVyLnNldFdlaWdodHMoZSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtsYXllcjp7Y2xhc3NOYW1lOnRoaXMubGF5ZXIuZ2V0Q2xhc3NOYW1lKCksY29uZmlnOnRoaXMubGF5ZXIuZ2V0Q29uZmlnKCl9fSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5wcm90b3R5cGUuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZD1mdW5jdGlvbih0KXtlLnByb3RvdHlwZS5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkLmNhbGwodGhpcyx0KSxudWxsIT10aGlzLmxheWVyJiZ0aGlzLmxheWVyLnNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQodCl9LHQuZnJvbUNvbmZpZz1mdW5jdGlvbihlLHQsbil7dm9pZCAwPT09biYmKG49e30pO3ZhciByPWRlc2VyaWFsaXplKHQubGF5ZXIsbik7ZGVsZXRlIHQubGF5ZXI7dmFyIGk9e2xheWVyOnJ9O3JldHVybiBPYmplY3QuYXNzaWduKGksdCksbmV3IGUoaSl9LHR9KExheWVyKSxUaW1lRGlzdHJpYnV0ZWQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5zdXBwb3J0c01hc2tpbmc9ITAsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24odCl7aWYoKHQ9Z2V0RXhhY3RseU9uZVNoYXBlKHQpKS5sZW5ndGg8Myl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRpbWVEaXN0cmlidXRlZCBsYXllciBleHBlY3RzIGFuIGlucHV0IHNoYXBlID49IDNELCBidXQgcmVjZWl2ZWQgaW5wdXQgc2hhcGUgXCIrSlNPTi5zdHJpbmdpZnkodCkpO3RoaXMuaW5wdXRTcGVjPVt7c2hhcGU6dH1dO3ZhciBuPVt0WzBdXS5jb25jYXQodC5zbGljZSgyKSk7dGhpcy5sYXllci5idWlsdHx8KHRoaXMubGF5ZXIuYnVpbGQobiksdGhpcy5sYXllci5idWlsdD0hMCksZS5wcm90b3R5cGUuYnVpbGQuY2FsbCh0aGlzLHQpfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7dmFyIHQ9WyhlPWdldEV4YWN0bHlPbmVTaGFwZShlKSlbMF1dLmNvbmNhdChlLnNsaWNlKDIpKSxuPXRoaXMubGF5ZXIuY29tcHV0ZU91dHB1dFNoYXBlKHQpLHI9ZVsxXTtyZXR1cm5bblswXSxyXS5jb25jYXQobi5zbGljZSgxKSl9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIHJubihmdW5jdGlvbihlLHIpe3JldHVybltnZXRFeGFjdGx5T25lVGVuc29yKG4ubGF5ZXIuY2FsbChlLHQpKSxbXV19LGU9Z2V0RXhhY3RseU9uZVRlbnNvcihlKSxbXSwhMSxudWxsLG51bGwsITEsITApWzFdfSl9LHQuY2xhc3NOYW1lPVwiVGltZURpc3RyaWJ1dGVkXCIsdH0oV3JhcHBlcik7ZnVuY3Rpb24gY2hlY2tCaWRpcmVjdGlvbmFsTWVyZ2VNb2RlKGUpe2NoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWUoVkFMSURfQklESVJFQ1RJT05BTF9NRVJHRV9NT0RFUyxcIkJpZGlyZWN0aW9uYWxNZXJnZU1vZGVcIixlKX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoVGltZURpc3RyaWJ1dGVkKTt2YXIgREVGQVVMVF9CSURJUkVDVElPTkFMX01FUkdFX01PREU9XCJjb25jYXRcIixCaWRpcmVjdGlvbmFsPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXMscj10LmxheWVyLmdldENvbmZpZygpLGk9e307aS5jbGFzc05hbWU9dC5sYXllci5nZXRDbGFzc05hbWUoKSxpLmNvbmZpZz1yLG4uZm9yd2FyZExheWVyPWRlc2VyaWFsaXplKGkpLHIuZ29CYWNrd2FyZHM9ITAhPT1yLmdvQmFja3dhcmRzO3ZhciBhPXt9O2lmKGEuY2xhc3NOYW1lPXQubGF5ZXIuZ2V0Q2xhc3NOYW1lKCksYS5jb25maWc9cixuLmJhY2t3YXJkTGF5ZXI9ZGVzZXJpYWxpemUoYSksbi5mb3J3YXJkTGF5ZXIubmFtZT1cImZvcndhcmRfXCIrbi5mb3J3YXJkTGF5ZXIubmFtZSxuLmJhY2t3YXJkTGF5ZXIubmFtZT1cImJhY2t3YXJkX1wiK24uYmFja3dhcmRMYXllci5uYW1lLG4ubWVyZ2VNb2RlPXZvaWQgMD09PXQubWVyZ2VNb2RlP0RFRkFVTFRfQklESVJFQ1RJT05BTF9NRVJHRV9NT0RFOnQubWVyZ2VNb2RlLGNoZWNrQmlkaXJlY3Rpb25hbE1lcmdlTW9kZShuLm1lcmdlTW9kZSksdC53ZWlnaHRzKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwid2VpZ2h0cyBzdXBwb3J0IGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgQmlkaXJlY3Rpb25hbCBsYXllciB5ZXQuXCIpO3JldHVybiBuLl9zdGF0ZWZ1bD10LmxheWVyLnN0YXRlZnVsLG4ucmV0dXJuU2VxdWVuY2VzPXQubGF5ZXIucmV0dXJuU2VxdWVuY2VzLG4ucmV0dXJuU3RhdGU9dC5sYXllci5yZXR1cm5TdGF0ZSxuLnN1cHBvcnRzTWFza2luZz0hMCxuLl90cmFpbmFibGU9ITAsbi5pbnB1dFNwZWM9dC5sYXllci5pbnB1dFNwZWMsbi5udW1Db25zdGFudHM9bnVsbCxufXJldHVybiBfX2V4dGVuZHModCxlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ0cmFpbmFibGVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RyYWluYWJsZX0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX3RyYWluYWJsZT1lLG51bGwhPXRoaXMuZm9yd2FyZExheWVyJiYodGhpcy5mb3J3YXJkTGF5ZXIudHJhaW5hYmxlPWUpLG51bGwhPXRoaXMuYmFja3dhcmRMYXllciYmKHRoaXMuYmFja3dhcmRMYXllci50cmFpbmFibGU9ZSl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuZ2V0V2VpZ2h0cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmZvcndhcmRMYXllci5nZXRXZWlnaHRzKCkuY29uY2F0KHRoaXMuYmFja3dhcmRMYXllci5nZXRXZWlnaHRzKCkpfSx0LnByb3RvdHlwZS5zZXRXZWlnaHRzPWZ1bmN0aW9uKGUpe3ZhciB0PWUubGVuZ3RoLG49TWF0aC5mbG9vcih0LzIpO3RoaXMuZm9yd2FyZExheWVyLnNldFdlaWdodHMoZS5zbGljZSgwLG4pKSx0aGlzLmJhY2t3YXJkTGF5ZXIuc2V0V2VpZ2h0cyhlLnNsaWNlKG4pKX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3ZhciB0LG4scixpPXRoaXMuZm9yd2FyZExheWVyLmNvbXB1dGVPdXRwdXRTaGFwZShlKTtyZXR1cm4gQXJyYXkuaXNBcnJheShpKSYmQXJyYXkuaXNBcnJheShpWzBdKXx8KGk9W2ldKSxpPWksdGhpcy5yZXR1cm5TdGF0ZT8ocj1pLnNsaWNlKDEpLHQ9aVswXSk6dD1pWzBdLHQ9dCxcImNvbmNhdFwiPT09dGhpcy5tZXJnZU1vZGU/KHRbdC5sZW5ndGgtMV0qPTIsbj1bdF0pOm49bnVsbD09dGhpcy5tZXJnZU1vZGU/W3QsdC5zbGljZSgpXTpbdF0sdGhpcy5yZXR1cm5TdGF0ZT9udWxsPT10aGlzLm1lcmdlTW9kZT9uLmNvbmNhdChyKS5jb25jYXQoci5zbGljZSgpKTpbdF0uY29uY2F0KHIpLmNvbmNhdChyLnNsaWNlKCkpOnNpbmdsZXRvbk9yQXJyYXkobil9LHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKHQsbil7dmFyIHI9bnVsbD09bj9udWxsOm4uaW5pdGlhbFN0YXRlLGk9bnVsbD09bj9udWxsOm4uY29uc3RhbnRzO251bGw9PW4mJihuPXt9KTt2YXIgYT1zdGFuZGFyZGl6ZUFyZ3ModCxyLGksdGhpcy5udW1Db25zdGFudHMpO2lmKHQ9YS5pbnB1dHMscj1hLmluaXRpYWxTdGF0ZSxpPWEuY29uc3RhbnRzLEFycmF5LmlzQXJyYXkodCkmJihyPXQuc2xpY2UoMSksdD10WzBdKSwobnVsbD09cnx8MD09PXIubGVuZ3RoKSYmbnVsbD09aSlyZXR1cm4gZS5wcm90b3R5cGUuYXBwbHkuY2FsbCh0aGlzLHQsbik7dmFyIG89W10scz1bXTtpZihudWxsIT1yKXt2YXIgbD1yLmxlbmd0aDtpZihsJTI+MCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIldoZW4gcGFzc2luZyBgaW5pdGlhbFN0YXRlYCB0byBhIEJpZHJlY3Rpb25hbCBSTk4sIHRoZSBzdGF0ZSBzaG91bGQgYmUgYW4gQXJyYXkgY29udGFpbmluZyB0aGUgc3RhdGVzIG9mIHRoZSB1bmRlcmx5aW5nIFJOTnMuXCIpO24uaW5pdGlhbFN0YXRlPXIsby5wdXNoLmFwcGx5KG8scik7dmFyIHU9ci5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBJbnB1dFNwZWMoe3NoYXBlOmUuc2hhcGV9KX0pO3RoaXMuZm9yd2FyZExheWVyLnN0YXRlU3BlYz11LnNsaWNlKDAsbC8yKSx0aGlzLmJhY2t3YXJkTGF5ZXIuc3RhdGVTcGVjPXUuc2xpY2UobC8yKSxzLnB1c2guYXBwbHkocyx1KX1pZihudWxsIT1pKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiU3VwcG9ydCBmb3IgY29uc3RhbnRzIGluIEJpZGlyZWN0aW9uYWwgbGF5ZXJzIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO2Zvcih2YXIgYz1vWzBdaW5zdGFuY2VvZiBTeW1ib2xpY1RlbnNvcixwPTAsaD1vO3A8aC5sZW5ndGg7cCsrKXtpZihoW3BdaW5zdGFuY2VvZiBTeW1ib2xpY1RlbnNvciE9PWMpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgaW5pdGlhbCBzdGF0ZSBvZiBhIEJpZGlyZWN0aW9uYWwgbGF5ZXIgY2Fubm90IGJlIHNwZWNpZmllZCBhcyBhIG1peCBvZiBzeW1ib2xpYyBhbmQgbm9uLXN5bWJvbGljIHRlbnNvcnNcIil9aWYoYyl7dmFyIGQ9W3RdLmNvbmNhdChvKSxmPXRoaXMuaW5wdXRTcGVjLmNvbmNhdChzKSxnPXRoaXMuaW5wdXRTcGVjO3RoaXMuaW5wdXRTcGVjPWY7dmFyIG09ZS5wcm90b3R5cGUuYXBwbHkuY2FsbCh0aGlzLGQsbik7cmV0dXJuIHRoaXMuaW5wdXRTcGVjPWcsbX1yZXR1cm4gZS5wcm90b3R5cGUuYXBwbHkuY2FsbCh0aGlzLHQsbil9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7aWYobnVsbCE9dC5tYXNrKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiVGhlIHN1cHBvcnQgZm9yIG1hc2tpbmcgaXMgbm90IGltcGxlbWVudGVkIGZvciBCaWRpcmVjdGlvbmFsIGxheWVycyB5ZXQuXCIpO3ZhciByLGksYSxvLHM9dC5pbml0aWFsU3RhdGU7aWYobnVsbD09cylyPW4uZm9yd2FyZExheWVyLmNhbGwoZSx0KSxpPW4uYmFja3dhcmRMYXllci5jYWxsKGUsdCk7ZWxzZXt2YXIgbD1zLnNsaWNlKDAscy5sZW5ndGgvMiksdT1zLnNsaWNlKHMubGVuZ3RoLzIpO3I9bi5mb3J3YXJkTGF5ZXIuY2FsbChlLE9iamVjdC5hc3NpZ24odCx7aW5pdGlhbFN0YXRlOmx9KSksaT1uLmJhY2t3YXJkTGF5ZXIuY2FsbChlLE9iamVjdC5hc3NpZ24odCx7aW5pdGlhbFN0YXRlOnV9KSl9cmV0dXJuIG4ucmV0dXJuU3RhdGUmJihBcnJheS5pc0FycmF5KHIpJiYoYT1yLnNsaWNlKDEpLmNvbmNhdChpLnNsaWNlKDEpKSkscj1yWzBdLGk9aVswXSksbi5yZXR1cm5TZXF1ZW5jZXMmJihpPXJldmVyc2UoaSwxKSksXCJjb25jYXRcIj09PW4ubWVyZ2VNb2RlP289Y29uY2F0ZW5hdGUoW3IsaV0pOlwic3VtXCI9PT1uLm1lcmdlTW9kZT9vPWFkZChyLGkpOlwiYXZlXCI9PT1uLm1lcmdlTW9kZT9vPW11bCguNSxhZGQocixpKSk6XCJtdWxcIj09PW4ubWVyZ2VNb2RlP289bXVsKHIsaSk6bnVsbD09bi5tZXJnZU1vZGUmJihvPVtyLGldKSxuLnJldHVyblN0YXRlP251bGw9PW4ubWVyZ2VNb2RlP28uY29uY2F0KGEpOltvXS5jb25jYXQoYSk6b30pfSx0LnByb3RvdHlwZS5yZXNldFN0YXRlcz1mdW5jdGlvbihlKXt0aGlzLmZvcndhcmRMYXllci5yZXNldFN0YXRlcygpLHRoaXMuYmFja3dhcmRMYXllci5yZXNldFN0YXRlcygpfSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXt2YXIgdD10aGlzO25hbWVTY29wZSh0aGlzLmZvcndhcmRMYXllci5uYW1lLGZ1bmN0aW9uKCl7dC5mb3J3YXJkTGF5ZXIuYnVpbGQoZSl9KSxuYW1lU2NvcGUodGhpcy5iYWNrd2FyZExheWVyLm5hbWUsZnVuY3Rpb24oKXt0LmJhY2t3YXJkTGF5ZXIuYnVpbGQoZSl9KSx0aGlzLmJ1aWx0PSEwfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ0cmFpbmFibGVXZWlnaHRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZvcndhcmRMYXllci50cmFpbmFibGVXZWlnaHRzLmNvbmNhdCh0aGlzLmJhY2t3YXJkTGF5ZXIudHJhaW5hYmxlV2VpZ2h0cyl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwibm9uVHJhaW5hYmxlV2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mb3J3YXJkTGF5ZXIubm9uVHJhaW5hYmxlV2VpZ2h0cy5jb25jYXQodGhpcy5iYWNrd2FyZExheWVyLm5vblRyYWluYWJsZVdlaWdodHMpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLnNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQ9ZnVuY3Rpb24odCl7ZS5wcm90b3R5cGUuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZC5jYWxsKHRoaXMsdCksbnVsbCE9dGhpcy5mb3J3YXJkTGF5ZXImJnRoaXMuZm9yd2FyZExheWVyLnNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQodCksbnVsbCE9dGhpcy5iYWNrd2FyZExheWVyJiZ0aGlzLmJhY2t3YXJkTGF5ZXIuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZCh0KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e21lcmdlTW9kZTp0aGlzLm1lcmdlTW9kZX0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuZnJvbUNvbmZpZz1mdW5jdGlvbihlLHQpe3ZhciBuPWRlc2VyaWFsaXplKHQubGF5ZXIpO2lmKGRlbGV0ZSB0LmxheWVyLG51bGwhPXQubnVtQ29uc3RhbnRzKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiRGVzZXJpYWxpemF0aW9uIG9mIGEgQmlkaXJlY3Rpb25hbCBsYXllciB3aXRoIG51bUNvbnN0YW50cyBwcmVzZW50IGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTt2YXIgcj10O3JldHVybiByLmxheWVyPW4sbmV3IGUocil9LHQuY2xhc3NOYW1lPVwiQmlkaXJlY3Rpb25hbFwiLHR9KFdyYXBwZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhCaWRpcmVjdGlvbmFsKTt2YXIgR2F1c3NpYW5Ob2lzZT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLnN1cHBvcnRzTWFza2luZz0hMCxuLnN0ZGRldj10LnN0ZGRldixufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpLG49e3N0ZGRldjp0aGlzLnN0ZGRldn07cmV0dXJuIE9iamVjdC5hc3NpZ24obix0KSxufSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe24uaW52b2tlQ2FsbEhvb2soZSx0KTt2YXIgcj1nZXRFeGFjdGx5T25lVGVuc29yKGUpO3JldHVybiBpblRyYWluUGhhc2UoZnVuY3Rpb24oKXtyZXR1cm4gcmFuZG9tTm9ybWFsJDEoci5zaGFwZSwwLG4uc3RkZGV2KS5hZGQocil9LGZ1bmN0aW9uKCl7cmV0dXJuIHJ9LHQudHJhaW5pbmd8fCExKX0pfSx0LmNsYXNzTmFtZT1cIkdhdXNzaWFuTm9pc2VcIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEdhdXNzaWFuTm9pc2UpO3ZhciBHYXVzc2lhbkRyb3BvdXQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5zdXBwb3J0c01hc2tpbmc9ITAsbi5yYXRlPXQucmF0ZSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpLG49e3JhdGU6dGhpcy5yYXRlfTtyZXR1cm4gT2JqZWN0LmFzc2lnbihuLHQpLG59LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7bi5pbnZva2VDYWxsSG9vayhlLHQpO3ZhciByPWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7aWYobi5yYXRlPjAmJm4ucmF0ZTwxKXtyZXR1cm4gaW5UcmFpblBoYXNlKGZ1bmN0aW9uKCl7dmFyIGU9TWF0aC5zcXJ0KG4ucmF0ZS8oMS1uLnJhdGUpKTtyZXR1cm4gZG90KHIscmFuZG9tTm9ybWFsJDEoci5zaGFwZSwxLGUpKX0sZnVuY3Rpb24oKXtyZXR1cm4gcn0sdC50cmFpbmluZ3x8ITEpfXJldHVybiByfSl9LHQuY2xhc3NOYW1lPVwiR2F1c3NpYW5Ecm9wb3V0XCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhHYXVzc2lhbkRyb3BvdXQpO3ZhciBBbHBoYURyb3BvdXQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5zdXBwb3J0c01hc2tpbmc9ITAsbi5yYXRlPXQucmF0ZSxuLm5vaXNlU2hhcGU9dC5ub2lzZVNoYXBlLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLl9nZXROb2lzZVNoYXBlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm5vaXNlU2hhcGV8fGdldEV4YWN0bHlPbmVUZW5zb3IoZSkuc2hhcGV9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtyZXR1cm4gZX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyksbj17cmF0ZTp0aGlzLnJhdGV9O3JldHVybiBPYmplY3QuYXNzaWduKG4sdCksbn0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtpZihuLnJhdGU8MSYmbi5yYXRlPjApe3ZhciByPW4uX2dldE5vaXNlU2hhcGUoZSk7cmV0dXJuIGluVHJhaW5QaGFzZShmdW5jdGlvbigpe3ZhciB0PWdldEV4YWN0bHlPbmVUZW5zb3IoZSksaT0tMS43NTgwOTkzNDA4NDczNzY2LGE9Z3JlYXRlckVxdWFsKHJhbmRvbVVuaWZvcm0ociksbi5yYXRlKTthPWNhc3QkMShhLFwiZmxvYXQzMlwiKTt2YXIgbz1NYXRoLnBvdygoMS1uLnJhdGUpKigxK24ucmF0ZSpNYXRoLnBvdyhpLDIpKSwtLjUpLHM9LW8qaSpuLnJhdGU7cmV0dXJuIGRvdCh0LGEpLmFkZChhLmFkZCgtMSkubXVsKGkpKS5tdWwobykuYWRkKHMpfSxmdW5jdGlvbigpe3JldHVybiBnZXRFeGFjdGx5T25lVGVuc29yKGUpfSx0LnRyYWluaW5nfHwhMSl9cmV0dXJuIGV9KX0sdC5jbGFzc05hbWU9XCJBbHBoYURyb3BvdXRcIix0fShMYXllcik7ZnVuY3Rpb24gaW5wdXRMYXllcihlKXtyZXR1cm4gbmV3IElucHV0TGF5ZXIoZSl9ZnVuY3Rpb24gZWx1JDIoZSl7cmV0dXJuIG5ldyBFTFUoZSl9ZnVuY3Rpb24gcmVMVShlKXtyZXR1cm4gbmV3IFJlTFUoZSl9ZnVuY3Rpb24gbGVha3lSZUxVKGUpe3JldHVybiBuZXcgTGVha3lSZUxVKGUpfWZ1bmN0aW9uIHByZWx1JDEoZSl7cmV0dXJuIG5ldyBQUmVMVShlKX1mdW5jdGlvbiBzb2Z0bWF4JDEoZSl7cmV0dXJuIG5ldyBTb2Z0bWF4JDEoZSl9ZnVuY3Rpb24gdGhyZXNob2xkZWRSZUxVKGUpe3JldHVybiBuZXcgVGhyZXNob2xkZWRSZUxVKGUpfWZ1bmN0aW9uIGNvbnYxZCQyKGUpe3JldHVybiBuZXcgQ29udjFEKGUpfWZ1bmN0aW9uIGNvbnYyZCQyKGUpe3JldHVybiBuZXcgQ29udjJEKGUpfWZ1bmN0aW9uIGNvbnYyZFRyYW5zcG9zZSQxKGUpe3JldHVybiBuZXcgQ29udjJEVHJhbnNwb3NlKGUpfWZ1bmN0aW9uIGNvbnYzZCQyKGUpe3JldHVybiBuZXcgQ29udjNEKGUpfWZ1bmN0aW9uIHNlcGFyYWJsZUNvbnYyZCQxKGUpe3JldHVybiBuZXcgU2VwYXJhYmxlQ29udjJEKGUpfWZ1bmN0aW9uIGNyb3BwaW5nMkQoZSl7cmV0dXJuIG5ldyBDcm9wcGluZzJEKGUpfWZ1bmN0aW9uIHVwU2FtcGxpbmcyZChlKXtyZXR1cm4gbmV3IFVwU2FtcGxpbmcyRChlKX1mdW5jdGlvbiBkZXB0aHdpc2VDb252MmQkMihlKXtyZXR1cm4gbmV3IERlcHRod2lzZUNvbnYyRChlKX1mdW5jdGlvbiBhY3RpdmF0aW9uKGUpe3JldHVybiBuZXcgQWN0aXZhdGlvbiQxKGUpfWZ1bmN0aW9uIGRlbnNlKGUpe3JldHVybiBuZXcgRGVuc2UoZSl9ZnVuY3Rpb24gZHJvcG91dCQxKGUpe3JldHVybiBuZXcgRHJvcG91dChlKX1mdW5jdGlvbiBmbGF0dGVuJDEoZSl7cmV0dXJuIG5ldyBGbGF0dGVuKGUpfWZ1bmN0aW9uIHJlcGVhdFZlY3RvcihlKXtyZXR1cm4gbmV3IFJlcGVhdFZlY3RvcihlKX1mdW5jdGlvbiByZXNoYXBlKGUpe3JldHVybiBuZXcgUmVzaGFwZShlKX1mdW5jdGlvbiBwZXJtdXRlKGUpe3JldHVybiBuZXcgUGVybXV0ZShlKX1mdW5jdGlvbiBlbWJlZGRpbmcoZSl7cmV0dXJuIG5ldyBFbWJlZGRpbmcoZSl9ZnVuY3Rpb24gYWRkJDIoZSl7cmV0dXJuIG5ldyBBZGQoZSl9ZnVuY3Rpb24gYXZlcmFnZSQxKGUpe3JldHVybiBuZXcgQXZlcmFnZShlKX1mdW5jdGlvbiBjb25jYXRlbmF0ZSQyKGUpe3JldHVybiBuZXcgQ29uY2F0ZW5hdGUoZSl9ZnVuY3Rpb24gbWF4aW11bSQyKGUpe3JldHVybiBuZXcgTWF4aW11bShlKX1mdW5jdGlvbiBtaW5pbXVtJDIoZSl7cmV0dXJuIG5ldyBNaW5pbXVtKGUpfWZ1bmN0aW9uIG11bHRpcGx5JDEoZSl7cmV0dXJuIG5ldyBNdWx0aXBseShlKX1mdW5jdGlvbiBkb3QkMShlKXtyZXR1cm4gbmV3IERvdChlKX1mdW5jdGlvbiBiYXRjaE5vcm1hbGl6YXRpb24kMShlKXtyZXR1cm4gbmV3IEJhdGNoTm9ybWFsaXphdGlvbihlKX1mdW5jdGlvbiB6ZXJvUGFkZGluZzJkKGUpe3JldHVybiBuZXcgWmVyb1BhZGRpbmcyRChlKX1mdW5jdGlvbiBhdmVyYWdlUG9vbGluZzFkKGUpe3JldHVybiBuZXcgQXZlcmFnZVBvb2xpbmcxRChlKX1mdW5jdGlvbiBhdmdQb29sMWQoZSl7cmV0dXJuIGF2ZXJhZ2VQb29saW5nMWQoZSl9ZnVuY3Rpb24gYXZnUG9vbGluZzFkKGUpe3JldHVybiBhdmVyYWdlUG9vbGluZzFkKGUpfWZ1bmN0aW9uIGF2ZXJhZ2VQb29saW5nMmQoZSl7cmV0dXJuIG5ldyBBdmVyYWdlUG9vbGluZzJEKGUpfWZ1bmN0aW9uIGF2Z1Bvb2wyZChlKXtyZXR1cm4gYXZlcmFnZVBvb2xpbmcyZChlKX1mdW5jdGlvbiBhdmdQb29saW5nMmQoZSl7cmV0dXJuIGF2ZXJhZ2VQb29saW5nMmQoZSl9ZnVuY3Rpb24gZ2xvYmFsQXZlcmFnZVBvb2xpbmcxZChlKXtyZXR1cm4gbmV3IEdsb2JhbEF2ZXJhZ2VQb29saW5nMUQoZSl9ZnVuY3Rpb24gZ2xvYmFsQXZlcmFnZVBvb2xpbmcyZChlKXtyZXR1cm4gbmV3IEdsb2JhbEF2ZXJhZ2VQb29saW5nMkQoZSl9ZnVuY3Rpb24gZ2xvYmFsTWF4UG9vbGluZzFkKGUpe3JldHVybiBuZXcgR2xvYmFsTWF4UG9vbGluZzFEKGUpfWZ1bmN0aW9uIGdsb2JhbE1heFBvb2xpbmcyZChlKXtyZXR1cm4gbmV3IEdsb2JhbE1heFBvb2xpbmcyRChlKX1mdW5jdGlvbiBtYXhQb29saW5nMWQoZSl7cmV0dXJuIG5ldyBNYXhQb29saW5nMUQoZSl9ZnVuY3Rpb24gbWF4UG9vbGluZzJkKGUpe3JldHVybiBuZXcgTWF4UG9vbGluZzJEKGUpfWZ1bmN0aW9uIGdydShlKXtyZXR1cm4gbmV3IEdSVShlKX1mdW5jdGlvbiBncnVDZWxsKGUpe3JldHVybiBuZXcgR1JVQ2VsbChlKX1mdW5jdGlvbiBsc3RtKGUpe3JldHVybiBuZXcgTFNUTShlKX1mdW5jdGlvbiBsc3RtQ2VsbChlKXtyZXR1cm4gbmV3IExTVE1DZWxsKGUpfWZ1bmN0aW9uIHNpbXBsZVJOTihlKXtyZXR1cm4gbmV3IFNpbXBsZVJOTihlKX1mdW5jdGlvbiBzaW1wbGVSTk5DZWxsKGUpe3JldHVybiBuZXcgU2ltcGxlUk5OQ2VsbChlKX1mdW5jdGlvbiBybm4kMShlKXtyZXR1cm4gbmV3IFJOTihlKX1mdW5jdGlvbiBzdGFja2VkUk5OQ2VsbHMoZSl7cmV0dXJuIG5ldyBTdGFja2VkUk5OQ2VsbHMoZSl9ZnVuY3Rpb24gYmlkaXJlY3Rpb25hbChlKXtyZXR1cm4gbmV3IEJpZGlyZWN0aW9uYWwoZSl9ZnVuY3Rpb24gdGltZURpc3RyaWJ1dGVkKGUpe3JldHVybiBuZXcgVGltZURpc3RyaWJ1dGVkKGUpfXNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhBbHBoYURyb3BvdXQpO3ZhciBnbG9iYWxNYXhQb29sMWQ9Z2xvYmFsTWF4UG9vbGluZzFkLGdsb2JhbE1heFBvb2wyZD1nbG9iYWxNYXhQb29saW5nMmQsbWF4UG9vbDFkPW1heFBvb2xpbmcxZCxtYXhQb29sMmQ9bWF4UG9vbGluZzJkO2Z1bmN0aW9uIGdhdXNzaWFuTm9pc2UoZSl7cmV0dXJuIG5ldyBHYXVzc2lhbk5vaXNlKGUpfWZ1bmN0aW9uIGdhdXNzaWFuRHJvcG91dChlKXtyZXR1cm4gbmV3IEdhdXNzaWFuRHJvcG91dChlKX1mdW5jdGlvbiBhbHBoYURyb3BvdXQoZSl7cmV0dXJuIG5ldyBBbHBoYURyb3BvdXQoZSl9ZnVuY3Rpb24gbWFza2luZyhlKXtyZXR1cm4gbmV3IE1hc2tpbmcoZSl9dmFyIGV4cG9ydHNfbGF5ZXJzPU9iamVjdC5mcmVlemUoe2lucHV0TGF5ZXI6aW5wdXRMYXllcixlbHU6ZWx1JDIscmVMVTpyZUxVLGxlYWt5UmVMVTpsZWFreVJlTFUscHJlbHU6cHJlbHUkMSxzb2Z0bWF4OnNvZnRtYXgkMSx0aHJlc2hvbGRlZFJlTFU6dGhyZXNob2xkZWRSZUxVLGNvbnYxZDpjb252MWQkMixjb252MmQ6Y29udjJkJDIsY29udjJkVHJhbnNwb3NlOmNvbnYyZFRyYW5zcG9zZSQxLGNvbnYzZDpjb252M2QkMixzZXBhcmFibGVDb252MmQ6c2VwYXJhYmxlQ29udjJkJDEsY3JvcHBpbmcyRDpjcm9wcGluZzJELHVwU2FtcGxpbmcyZDp1cFNhbXBsaW5nMmQsZGVwdGh3aXNlQ29udjJkOmRlcHRod2lzZUNvbnYyZCQyLGFjdGl2YXRpb246YWN0aXZhdGlvbixkZW5zZTpkZW5zZSxkcm9wb3V0OmRyb3BvdXQkMSxmbGF0dGVuOmZsYXR0ZW4kMSxyZXBlYXRWZWN0b3I6cmVwZWF0VmVjdG9yLHJlc2hhcGU6cmVzaGFwZSxwZXJtdXRlOnBlcm11dGUsZW1iZWRkaW5nOmVtYmVkZGluZyxhZGQ6YWRkJDIsYXZlcmFnZTphdmVyYWdlJDEsY29uY2F0ZW5hdGU6Y29uY2F0ZW5hdGUkMixtYXhpbXVtOm1heGltdW0kMixtaW5pbXVtOm1pbmltdW0kMixtdWx0aXBseTptdWx0aXBseSQxLGRvdDpkb3QkMSxiYXRjaE5vcm1hbGl6YXRpb246YmF0Y2hOb3JtYWxpemF0aW9uJDEsemVyb1BhZGRpbmcyZDp6ZXJvUGFkZGluZzJkLGF2ZXJhZ2VQb29saW5nMWQ6YXZlcmFnZVBvb2xpbmcxZCxhdmdQb29sMWQ6YXZnUG9vbDFkLGF2Z1Bvb2xpbmcxZDphdmdQb29saW5nMWQsYXZlcmFnZVBvb2xpbmcyZDphdmVyYWdlUG9vbGluZzJkLGF2Z1Bvb2wyZDphdmdQb29sMmQsYXZnUG9vbGluZzJkOmF2Z1Bvb2xpbmcyZCxnbG9iYWxBdmVyYWdlUG9vbGluZzFkOmdsb2JhbEF2ZXJhZ2VQb29saW5nMWQsZ2xvYmFsQXZlcmFnZVBvb2xpbmcyZDpnbG9iYWxBdmVyYWdlUG9vbGluZzJkLGdsb2JhbE1heFBvb2xpbmcxZDpnbG9iYWxNYXhQb29saW5nMWQsZ2xvYmFsTWF4UG9vbGluZzJkOmdsb2JhbE1heFBvb2xpbmcyZCxtYXhQb29saW5nMWQ6bWF4UG9vbGluZzFkLG1heFBvb2xpbmcyZDptYXhQb29saW5nMmQsZ3J1OmdydSxncnVDZWxsOmdydUNlbGwsbHN0bTpsc3RtLGxzdG1DZWxsOmxzdG1DZWxsLHNpbXBsZVJOTjpzaW1wbGVSTk4sc2ltcGxlUk5OQ2VsbDpzaW1wbGVSTk5DZWxsLHJubjpybm4kMSxzdGFja2VkUk5OQ2VsbHM6c3RhY2tlZFJOTkNlbGxzLGJpZGlyZWN0aW9uYWw6YmlkaXJlY3Rpb25hbCx0aW1lRGlzdHJpYnV0ZWQ6dGltZURpc3RyaWJ1dGVkLGdsb2JhbE1heFBvb2wxZDpnbG9iYWxNYXhQb29sMWQsZ2xvYmFsTWF4UG9vbDJkOmdsb2JhbE1heFBvb2wyZCxtYXhQb29sMWQ6bWF4UG9vbDFkLG1heFBvb2wyZDptYXhQb29sMmQsTGF5ZXI6TGF5ZXIsUk5OOlJOTixSTk5DZWxsOlJOTkNlbGwsaW5wdXQ6aW5wdXQsZ2F1c3NpYW5Ob2lzZTpnYXVzc2lhbk5vaXNlLGdhdXNzaWFuRHJvcG91dDpnYXVzc2lhbkRyb3BvdXQsYWxwaGFEcm9wb3V0OmFscGhhRHJvcG91dCxtYXNraW5nOm1hc2tpbmd9KTtmdW5jdGlvbiBiaW5hcnlBY2N1cmFjeSQxKGUsdCl7cmV0dXJuIGJpbmFyeUFjY3VyYWN5KGUsdCl9ZnVuY3Rpb24gYmluYXJ5Q3Jvc3NlbnRyb3B5JDIoZSx0KXtyZXR1cm4gYmluYXJ5Q3Jvc3NlbnRyb3B5JDEoZSx0KX1mdW5jdGlvbiBzcGFyc2VDYXRlZ29yaWNhbEFjY3VyYWN5JDEoZSx0KXtyZXR1cm4gc3BhcnNlQ2F0ZWdvcmljYWxBY2N1cmFjeShlLHQpfWZ1bmN0aW9uIGNhdGVnb3JpY2FsQWNjdXJhY3kkMShlLHQpe3JldHVybiBjYXRlZ29yaWNhbEFjY3VyYWN5KGUsdCl9ZnVuY3Rpb24gY2F0ZWdvcmljYWxDcm9zc2VudHJvcHkkMihlLHQpe3JldHVybiBjYXRlZ29yaWNhbENyb3NzZW50cm9weSQxKGUsdCl9ZnVuY3Rpb24gcHJlY2lzaW9uJDEoZSx0KXtyZXR1cm4gcHJlY2lzaW9uKGUsdCl9ZnVuY3Rpb24gcmVjYWxsJDEoZSx0KXtyZXR1cm4gcmVjYWxsKGUsdCl9ZnVuY3Rpb24gY29zaW5lUHJveGltaXR5JDEoZSx0KXtyZXR1cm4gY29zaW5lUHJveGltaXR5KGUsdCl9ZnVuY3Rpb24gbWVhbkFic29sdXRlRXJyb3IkMShlLHQpe3JldHVybiBtZWFuQWJzb2x1dGVFcnJvcihlLHQpfWZ1bmN0aW9uIG1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvciQxKGUsdCl7cmV0dXJuIG1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcihlLHQpfWZ1bmN0aW9uIE1BUEUkMihlLHQpe3JldHVybiBtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3IoZSx0KX1mdW5jdGlvbiBtYXBlJDIoZSx0KXtyZXR1cm4gbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yKGUsdCl9ZnVuY3Rpb24gbWVhblNxdWFyZWRFcnJvciQxKGUsdCl7cmV0dXJuIG1lYW5TcXVhcmVkRXJyb3IoZSx0KX1mdW5jdGlvbiBNU0UkMihlLHQpe3JldHVybiBtZWFuU3F1YXJlZEVycm9yKGUsdCl9ZnVuY3Rpb24gbXNlJDIoZSx0KXtyZXR1cm4gbWVhblNxdWFyZWRFcnJvcihlLHQpfXZhciBleHBvcnRzX21ldHJpY3M9T2JqZWN0LmZyZWV6ZSh7YmluYXJ5QWNjdXJhY3k6YmluYXJ5QWNjdXJhY3kkMSxiaW5hcnlDcm9zc2VudHJvcHk6YmluYXJ5Q3Jvc3NlbnRyb3B5JDIsc3BhcnNlQ2F0ZWdvcmljYWxBY2N1cmFjeTpzcGFyc2VDYXRlZ29yaWNhbEFjY3VyYWN5JDEsY2F0ZWdvcmljYWxBY2N1cmFjeTpjYXRlZ29yaWNhbEFjY3VyYWN5JDEsY2F0ZWdvcmljYWxDcm9zc2VudHJvcHk6Y2F0ZWdvcmljYWxDcm9zc2VudHJvcHkkMixwcmVjaXNpb246cHJlY2lzaW9uJDEscmVjYWxsOnJlY2FsbCQxLGNvc2luZVByb3hpbWl0eTpjb3NpbmVQcm94aW1pdHkkMSxtZWFuQWJzb2x1dGVFcnJvcjptZWFuQWJzb2x1dGVFcnJvciQxLG1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcjptZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3IkMSxNQVBFOk1BUEUkMixtYXBlOm1hcGUkMixtZWFuU3F1YXJlZEVycm9yOm1lYW5TcXVhcmVkRXJyb3IkMSxNU0U6TVNFJDIsbXNlOm1zZSQyfSksZXhwb3J0c19tb2RlbHM9T2JqZWN0LmZyZWV6ZSh7bW9kZWxGcm9tSlNPTjptb2RlbEZyb21KU09OfSk7ZnVuY3Rpb24gbDFsMihlKXtyZXR1cm4gbmV3IEwxTDIoZSl9ZnVuY3Rpb24gbDEkMShlKXtyZXR1cm4gbDEoZSl9ZnVuY3Rpb24gbDIkMShlKXtyZXR1cm4gbDIoZSl9dmFyIGV4cG9ydHNfcmVndWxhcml6ZXJzPU9iamVjdC5mcmVlemUoe2wxbDI6bDFsMixsMTpsMSQxLGwyOmwyJDF9KSxDYWxsYmFjaz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7dmFyIHQ9bnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzO3JldHVybiB0Lm1vZGVsPW51bGwsdH1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuc2V0TW9kZWw9ZnVuY3Rpb24oZSl7aWYoIShlIGluc3RhbmNlb2YgTGF5ZXJzTW9kZWwpKXRocm93IG5ldyBFcnJvcihcIm1vZGVsIG11c3QgYmUgYSBMYXllcnNNb2RlbCwgbm90IHNvbWUgb3RoZXIgQ29udGFpbmVyXCIpO3RoaXMubW9kZWw9ZX0sdH0oQmFzZUNhbGxiYWNrKTtmdW5jdGlvbiBsZXNzKGUsdCl7cmV0dXJuIGU8dH1mdW5jdGlvbiBncmVhdGVyJDEoZSx0KXtyZXR1cm4gZT50fXZhciBFYXJseVN0b3BwaW5nPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMpfHx0aGlzO2lmKG51bGw9PXQmJih0PXt9KSx0LnJlc3RvcmVCZXN0V2VpZ2h0cyl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcInJlc3RvcmVCZXN0V2VpZ2h0cyA9IFRydWUgaXMgbm90IGltcGxlbWVudGVkIGluIEVhcmx5U3RvcHBpbmcgeWV0LlwiKTtyZXR1cm4gbi5tb25pdG9yPXQubW9uaXRvcnx8XCJ2YWxfbG9zc1wiLG4ubWluRGVsdGE9TWF0aC5hYnModC5taW5EZWx0YXx8MCksbi5wYXRpZW5jZT10LnBhdGllbmNlfHwwLG4udmVyYm9zZT10LnZlcmJvc2V8fDAsbi5tb2RlPXQubW9kZXx8XCJhdXRvXCIsbi5iYXNlbGluZT10LmJhc2VsaW5lLC0xPT09W1wiYXV0b1wiLFwibWluXCIsXCJtYXhcIl0uaW5kZXhPZihuLm1vZGUpJiYoY29uc29sZS53YXJuKFwiRWFybHlTdG9wcGluZyBtb2RlICdcIituLm1vZGUrXCInIGlzIGludmFsaWQuIEZhbGxpbmcgYmFjayB0byBtb2RlICdhdXRvJy5cIiksbi5tb2RlPVwiYXV0b1wiKSxcIm1pblwiPT09bi5tb2RlP24ubW9uaXRvckZ1bmM9bGVzczpcIm1heFwiPT09bi5tb2RlP24ubW9uaXRvckZ1bmM9Z3JlYXRlciQxOi0xIT09bi5tb25pdG9yLmluZGV4T2YoXCJhY2NcIik/bi5tb25pdG9yRnVuYz1ncmVhdGVyJDE6bi5tb25pdG9yRnVuYz1sZXNzLG4ubW9uaXRvckZ1bmM9PT1sZXNzJiYobi5taW5EZWx0YSo9LTEpLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLm9uVHJhaW5CZWdpbj1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLndhaXQ9MCx0aGlzLnN0b3BwZWRFcG9jaD0wLG51bGwhPXRoaXMuYmFzZWxpbmU/dGhpcy5iZXN0PXRoaXMuYmFzZWxpbmU6dGhpcy5iZXN0PXRoaXMubW9uaXRvckZ1bmM9PT1sZXNzPzEvMDotMS8wLFsyXX0pfSl9LHQucHJvdG90eXBlLm9uRXBvY2hFbmQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBuO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQscmVzb2x2ZVNjYWxhcnNJbkxvZ3ModCldO2Nhc2UgMTpyZXR1cm4gci5zZW50KCksbnVsbD09KG49dGhpcy5nZXRNb25pdG9yVmFsdWUodCkpP1syXToodGhpcy5tb25pdG9yRnVuYyhuLXRoaXMubWluRGVsdGEsdGhpcy5iZXN0KT8odGhpcy5iZXN0PW4sdGhpcy53YWl0PTApOih0aGlzLndhaXQrKyx0aGlzLndhaXQ+PXRoaXMucGF0aWVuY2UmJih0aGlzLnN0b3BwZWRFcG9jaD1lLHRoaXMubW9kZWwuc3RvcFRyYWluaW5nPSEwKSksWzJdKX19KX0pfSx0LnByb3RvdHlwZS5vblRyYWluRW5kPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuc3RvcHBlZEVwb2NoPjAmJnRoaXMudmVyYm9zZSYmY29uc29sZS5sb2coXCJFcG9jaCBcIit0aGlzLnN0b3BwZWRFcG9jaCtcIjogZWFybHkgc3RvcHBpbmcuXCIpLFsyXX0pfSl9LHQucHJvdG90eXBlLmdldE1vbml0b3JWYWx1ZT1mdW5jdGlvbihlKXtudWxsPT1lJiYoZT17fSk7dmFyIHQ9ZVt0aGlzLm1vbml0b3JdO3JldHVybiBudWxsPT10JiZjb25zb2xlLndhcm4oXCJNZXRyaWMgZm9yIEVhcmx5U3RvcHBpbmcgXCIrdGhpcy5tb25pdG9yK1wiIGlzIG5vdCBhdmFpbGFibGUuIEF2YWlsYWJsZSBtZXRyaWNzIGFyZTogXCIrT2JqZWN0LmtleXMoZSkpLHR9LHR9KENhbGxiYWNrKTtmdW5jdGlvbiBlYXJseVN0b3BwaW5nKGUpe3JldHVybiBuZXcgRWFybHlTdG9wcGluZyhlKX12YXIgY2FsbGJhY2tzPXtlYXJseVN0b3BwaW5nOmVhcmx5U3RvcHBpbmd9O2V4cG9ydHtleHBvcnRzX2NvbnN0cmFpbnRzIGFzIGNvbnN0cmFpbnRzLGV4cG9ydHNfaW5pdGlhbGl6ZXJzIGFzIGluaXRpYWxpemVycyxleHBvcnRzX2xheWVycyBhcyBsYXllcnMsZXhwb3J0c19tZXRyaWNzIGFzIG1ldHJpY3MsZXhwb3J0c19tb2RlbHMgYXMgbW9kZWxzLGV4cG9ydHNfcmVndWxhcml6ZXJzIGFzIHJlZ3VsYXJpemVycyxDYWxsYmFja0xpc3QsQ3VzdG9tQ2FsbGJhY2ssSGlzdG9yeSxDYWxsYmFjayxjYWxsYmFja3MsRWFybHlTdG9wcGluZyxJbnB1dFNwZWMsU3ltYm9saWNUZW5zb3IsTGF5ZXJzTW9kZWwsaW5wdXQsbG9hZExheWVyc01vZGVsLG1vZGVsLHJlZ2lzdGVyQ2FsbGJhY2tDb25zdHJ1Y3RvcixzZXF1ZW50aWFsLFJOTixTZXF1ZW50aWFsLExheWVyVmFyaWFibGUsdmVyc2lvbiBhcyB2ZXJzaW9uX2xheWVyc307XG4vLyMgc291cmNlTWFwcGluZ1VSTD10Zi1sYXllcnMuZXNtLmpzLm1hcFxuIiwiLy8gQHRlbnNvcmZsb3cvdGZqcyBDb3B5cmlnaHQgMjAxOSBHb29nbGVcbmltcG9ydHt2ZXJzaW9uX2NvcmV9ZnJvbVwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCI7ZXhwb3J0KmZyb21cIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiO2ltcG9ydHt2ZXJzaW9uX2xheWVyc31mcm9tXCJAdGVuc29yZmxvdy90ZmpzLWxheWVyc1wiO2V4cG9ydCpmcm9tXCJAdGVuc29yZmxvdy90ZmpzLWxheWVyc1wiO2ltcG9ydHt2ZXJzaW9uX2NvbnZlcnRlcn1mcm9tXCJAdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlclwiO2V4cG9ydCpmcm9tXCJAdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlclwiO2ltcG9ydCphcyB0ZmpzRGF0YSBmcm9tXCJAdGVuc29yZmxvdy90ZmpzLWRhdGFcIjtpbXBvcnR7dmVyc2lvbl9kYXRhfWZyb21cIkB0ZW5zb3JmbG93L3RmanMtZGF0YVwiO2V4cG9ydHt0ZmpzRGF0YSBhcyBkYXRhfTt2YXIgdmVyc2lvbj1cIjEuMS4yXCIsdmVyc2lvbiQxPXtcInRmanMtY29yZVwiOnZlcnNpb25fY29yZSxcInRmanMtZGF0YVwiOnZlcnNpb25fZGF0YSxcInRmanMtbGF5ZXJzXCI6dmVyc2lvbl9sYXllcnMsXCJ0ZmpzLWNvbnZlcnRlclwiOnZlcnNpb25fY29udmVydGVyLHRmanM6dmVyc2lvbn07ZXhwb3J0e3ZlcnNpb24kMSBhcyB2ZXJzaW9ufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRmLmVzbS5qcy5tYXBcbiIsInZhciBhc24xID0gZXhwb3J0cztcblxuYXNuMS5iaWdudW0gPSByZXF1aXJlKCdibi5qcycpO1xuXG5hc24xLmRlZmluZSA9IHJlcXVpcmUoJy4vYXNuMS9hcGknKS5kZWZpbmU7XG5hc24xLmJhc2UgPSByZXF1aXJlKCcuL2FzbjEvYmFzZScpO1xuYXNuMS5jb25zdGFudHMgPSByZXF1aXJlKCcuL2FzbjEvY29uc3RhbnRzJyk7XG5hc24xLmRlY29kZXJzID0gcmVxdWlyZSgnLi9hc24xL2RlY29kZXJzJyk7XG5hc24xLmVuY29kZXJzID0gcmVxdWlyZSgnLi9hc24xL2VuY29kZXJzJyk7XG4iLCJ2YXIgYXNuMSA9IHJlcXVpcmUoJy4uL2FzbjEnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBhcGkgPSBleHBvcnRzO1xuXG5hcGkuZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG5hbWUsIGJvZHkpIHtcbiAgcmV0dXJuIG5ldyBFbnRpdHkobmFtZSwgYm9keSk7XG59O1xuXG5mdW5jdGlvbiBFbnRpdHkobmFtZSwgYm9keSkge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gIHRoaXMuZGVjb2RlcnMgPSB7fTtcbiAgdGhpcy5lbmNvZGVycyA9IHt9O1xufTtcblxuRW50aXR5LnByb3RvdHlwZS5fY3JlYXRlTmFtZWQgPSBmdW5jdGlvbiBjcmVhdGVOYW1lZChiYXNlKSB7XG4gIHZhciBuYW1lZDtcbiAgdHJ5IHtcbiAgICBuYW1lZCA9IHJlcXVpcmUoJ3ZtJykucnVuSW5UaGlzQ29udGV4dChcbiAgICAgICcoZnVuY3Rpb24gJyArIHRoaXMubmFtZSArICcoZW50aXR5KSB7XFxuJyArXG4gICAgICAnICB0aGlzLl9pbml0TmFtZWQoZW50aXR5KTtcXG4nICtcbiAgICAgICd9KSdcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbmFtZWQgPSBmdW5jdGlvbiAoZW50aXR5KSB7XG4gICAgICB0aGlzLl9pbml0TmFtZWQoZW50aXR5KTtcbiAgICB9O1xuICB9XG4gIGluaGVyaXRzKG5hbWVkLCBiYXNlKTtcbiAgbmFtZWQucHJvdG90eXBlLl9pbml0TmFtZWQgPSBmdW5jdGlvbiBpbml0bmFtZWQoZW50aXR5KSB7XG4gICAgYmFzZS5jYWxsKHRoaXMsIGVudGl0eSk7XG4gIH07XG5cbiAgcmV0dXJuIG5ldyBuYW1lZCh0aGlzKTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuX2dldERlY29kZXIgPSBmdW5jdGlvbiBfZ2V0RGVjb2RlcihlbmMpIHtcbiAgZW5jID0gZW5jIHx8ICdkZXInO1xuICAvLyBMYXppbHkgY3JlYXRlIGRlY29kZXJcbiAgaWYgKCF0aGlzLmRlY29kZXJzLmhhc093blByb3BlcnR5KGVuYykpXG4gICAgdGhpcy5kZWNvZGVyc1tlbmNdID0gdGhpcy5fY3JlYXRlTmFtZWQoYXNuMS5kZWNvZGVyc1tlbmNdKTtcbiAgcmV0dXJuIHRoaXMuZGVjb2RlcnNbZW5jXTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIGVuYywgb3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5fZ2V0RGVjb2RlcihlbmMpLmRlY29kZShkYXRhLCBvcHRpb25zKTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuX2dldEVuY29kZXIgPSBmdW5jdGlvbiBfZ2V0RW5jb2RlcihlbmMpIHtcbiAgZW5jID0gZW5jIHx8ICdkZXInO1xuICAvLyBMYXppbHkgY3JlYXRlIGVuY29kZXJcbiAgaWYgKCF0aGlzLmVuY29kZXJzLmhhc093blByb3BlcnR5KGVuYykpXG4gICAgdGhpcy5lbmNvZGVyc1tlbmNdID0gdGhpcy5fY3JlYXRlTmFtZWQoYXNuMS5lbmNvZGVyc1tlbmNdKTtcbiAgcmV0dXJuIHRoaXMuZW5jb2RlcnNbZW5jXTtcbn07XG5cbkVudGl0eS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIGVuYywgLyogaW50ZXJuYWwgKi8gcmVwb3J0ZXIpIHtcbiAgcmV0dXJuIHRoaXMuX2dldEVuY29kZXIoZW5jKS5lbmNvZGUoZGF0YSwgcmVwb3J0ZXIpO1xufTtcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgUmVwb3J0ZXIgPSByZXF1aXJlKCcuLi9iYXNlJykuUmVwb3J0ZXI7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG5mdW5jdGlvbiBEZWNvZGVyQnVmZmVyKGJhc2UsIG9wdGlvbnMpIHtcbiAgUmVwb3J0ZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYmFzZSkpIHtcbiAgICB0aGlzLmVycm9yKCdJbnB1dCBub3QgQnVmZmVyJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5iYXNlID0gYmFzZTtcbiAgdGhpcy5vZmZzZXQgPSAwO1xuICB0aGlzLmxlbmd0aCA9IGJhc2UubGVuZ3RoO1xufVxuaW5oZXJpdHMoRGVjb2RlckJ1ZmZlciwgUmVwb3J0ZXIpO1xuZXhwb3J0cy5EZWNvZGVyQnVmZmVyID0gRGVjb2RlckJ1ZmZlcjtcblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIHNhdmUoKSB7XG4gIHJldHVybiB7IG9mZnNldDogdGhpcy5vZmZzZXQsIHJlcG9ydGVyOiBSZXBvcnRlci5wcm90b3R5cGUuc2F2ZS5jYWxsKHRoaXMpIH07XG59O1xuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gcmVzdG9yZShzYXZlKSB7XG4gIC8vIFJldHVybiBza2lwcGVkIGRhdGFcbiAgdmFyIHJlcyA9IG5ldyBEZWNvZGVyQnVmZmVyKHRoaXMuYmFzZSk7XG4gIHJlcy5vZmZzZXQgPSBzYXZlLm9mZnNldDtcbiAgcmVzLmxlbmd0aCA9IHRoaXMub2Zmc2V0O1xuXG4gIHRoaXMub2Zmc2V0ID0gc2F2ZS5vZmZzZXQ7XG4gIFJlcG9ydGVyLnByb3RvdHlwZS5yZXN0b3JlLmNhbGwodGhpcywgc2F2ZS5yZXBvcnRlcik7XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICByZXR1cm4gdGhpcy5vZmZzZXQgPT09IHRoaXMubGVuZ3RoO1xufTtcblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4KGZhaWwpIHtcbiAgaWYgKHRoaXMub2Zmc2V0ICsgMSA8PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcy5iYXNlLnJlYWRVSW50OCh0aGlzLm9mZnNldCsrLCB0cnVlKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmVycm9yKGZhaWwgfHwgJ0RlY29kZXJCdWZmZXIgb3ZlcnJ1bicpO1xufVxuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gc2tpcChieXRlcywgZmFpbCkge1xuICBpZiAoISh0aGlzLm9mZnNldCArIGJ5dGVzIDw9IHRoaXMubGVuZ3RoKSlcbiAgICByZXR1cm4gdGhpcy5lcnJvcihmYWlsIHx8ICdEZWNvZGVyQnVmZmVyIG92ZXJydW4nKTtcblxuICB2YXIgcmVzID0gbmV3IERlY29kZXJCdWZmZXIodGhpcy5iYXNlKTtcblxuICAvLyBTaGFyZSByZXBvcnRlciBzdGF0ZVxuICByZXMuX3JlcG9ydGVyU3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHJlcy5vZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgcmVzLmxlbmd0aCA9IHRoaXMub2Zmc2V0ICsgYnl0ZXM7XG4gIHRoaXMub2Zmc2V0ICs9IGJ5dGVzO1xuICByZXR1cm4gcmVzO1xufVxuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5yYXcgPSBmdW5jdGlvbiByYXcoc2F2ZSkge1xuICByZXR1cm4gdGhpcy5iYXNlLnNsaWNlKHNhdmUgPyBzYXZlLm9mZnNldCA6IHRoaXMub2Zmc2V0LCB0aGlzLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIEVuY29kZXJCdWZmZXIodmFsdWUsIHJlcG9ydGVyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBFbmNvZGVyQnVmZmVyKSlcbiAgICAgICAgaXRlbSA9IG5ldyBFbmNvZGVyQnVmZmVyKGl0ZW0sIHJlcG9ydGVyKTtcbiAgICAgIHRoaXMubGVuZ3RoICs9IGl0ZW0ubGVuZ3RoO1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSwgdGhpcyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGlmICghKDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMHhmZikpXG4gICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ25vbi1ieXRlIEVuY29kZXJCdWZmZXIgdmFsdWUnKTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5sZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ1Vuc3VwcG9ydGVkIHR5cGU6ICcgKyB0eXBlb2YgdmFsdWUpO1xuICB9XG59XG5leHBvcnRzLkVuY29kZXJCdWZmZXIgPSBFbmNvZGVyQnVmZmVyO1xuXG5FbmNvZGVyQnVmZmVyLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihvdXQsIG9mZnNldCkge1xuICBpZiAoIW91dClcbiAgICBvdXQgPSBuZXcgQnVmZmVyKHRoaXMubGVuZ3RoKTtcbiAgaWYgKCFvZmZzZXQpXG4gICAgb2Zmc2V0ID0gMDtcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG91dDtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnZhbHVlKSkge1xuICAgIHRoaXMudmFsdWUuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpdGVtLmpvaW4ob3V0LCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGl0ZW0ubGVuZ3RoO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICBvdXRbb2Zmc2V0XSA9IHRoaXMudmFsdWU7XG4gICAgZWxzZSBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgb3V0LndyaXRlKHRoaXMudmFsdWUsIG9mZnNldCk7XG4gICAgZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHRoaXMudmFsdWUpKVxuICAgICAgdGhpcy52YWx1ZS5jb3B5KG91dCwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcbiIsInZhciBiYXNlID0gZXhwb3J0cztcblxuYmFzZS5SZXBvcnRlciA9IHJlcXVpcmUoJy4vcmVwb3J0ZXInKS5SZXBvcnRlcjtcbmJhc2UuRGVjb2RlckJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJykuRGVjb2RlckJ1ZmZlcjtcbmJhc2UuRW5jb2RlckJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJykuRW5jb2RlckJ1ZmZlcjtcbmJhc2UuTm9kZSA9IHJlcXVpcmUoJy4vbm9kZScpO1xuIiwidmFyIFJlcG9ydGVyID0gcmVxdWlyZSgnLi4vYmFzZScpLlJlcG9ydGVyO1xudmFyIEVuY29kZXJCdWZmZXIgPSByZXF1aXJlKCcuLi9iYXNlJykuRW5jb2RlckJ1ZmZlcjtcbnZhciBEZWNvZGVyQnVmZmVyID0gcmVxdWlyZSgnLi4vYmFzZScpLkRlY29kZXJCdWZmZXI7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG4vLyBTdXBwb3J0ZWQgdGFnc1xudmFyIHRhZ3MgPSBbXG4gICdzZXEnLCAnc2Vxb2YnLCAnc2V0JywgJ3NldG9mJywgJ29iamlkJywgJ2Jvb2wnLFxuICAnZ2VudGltZScsICd1dGN0aW1lJywgJ251bGxfJywgJ2VudW0nLCAnaW50JywgJ29iakRlc2MnLFxuICAnYml0c3RyJywgJ2JtcHN0cicsICdjaGFyc3RyJywgJ2dlbnN0cicsICdncmFwaHN0cicsICdpYTVzdHInLCAnaXNvNjQ2c3RyJyxcbiAgJ251bXN0cicsICdvY3RzdHInLCAncHJpbnRzdHInLCAndDYxc3RyJywgJ3VuaXN0cicsICd1dGY4c3RyJywgJ3ZpZGVvc3RyJ1xuXTtcblxuLy8gUHVibGljIG1ldGhvZHMgbGlzdFxudmFyIG1ldGhvZHMgPSBbXG4gICdrZXknLCAnb2JqJywgJ3VzZScsICdvcHRpb25hbCcsICdleHBsaWNpdCcsICdpbXBsaWNpdCcsICdkZWYnLCAnY2hvaWNlJyxcbiAgJ2FueScsICdjb250YWlucydcbl0uY29uY2F0KHRhZ3MpO1xuXG4vLyBPdmVycmlkZWQgbWV0aG9kcyBsaXN0XG52YXIgb3ZlcnJpZGVkID0gW1xuICAnX3BlZWtUYWcnLCAnX2RlY29kZVRhZycsICdfdXNlJyxcbiAgJ19kZWNvZGVTdHInLCAnX2RlY29kZU9iamlkJywgJ19kZWNvZGVUaW1lJyxcbiAgJ19kZWNvZGVOdWxsJywgJ19kZWNvZGVJbnQnLCAnX2RlY29kZUJvb2wnLCAnX2RlY29kZUxpc3QnLFxuXG4gICdfZW5jb2RlQ29tcG9zaXRlJywgJ19lbmNvZGVTdHInLCAnX2VuY29kZU9iamlkJywgJ19lbmNvZGVUaW1lJyxcbiAgJ19lbmNvZGVOdWxsJywgJ19lbmNvZGVJbnQnLCAnX2VuY29kZUJvb2wnXG5dO1xuXG5mdW5jdGlvbiBOb2RlKGVuYywgcGFyZW50KSB7XG4gIHZhciBzdGF0ZSA9IHt9O1xuICB0aGlzLl9iYXNlU3RhdGUgPSBzdGF0ZTtcblxuICBzdGF0ZS5lbmMgPSBlbmM7XG5cbiAgc3RhdGUucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gIHN0YXRlLmNoaWxkcmVuID0gbnVsbDtcblxuICAvLyBTdGF0ZVxuICBzdGF0ZS50YWcgPSBudWxsO1xuICBzdGF0ZS5hcmdzID0gbnVsbDtcbiAgc3RhdGUucmV2ZXJzZUFyZ3MgPSBudWxsO1xuICBzdGF0ZS5jaG9pY2UgPSBudWxsO1xuICBzdGF0ZS5vcHRpb25hbCA9IGZhbHNlO1xuICBzdGF0ZS5hbnkgPSBmYWxzZTtcbiAgc3RhdGUub2JqID0gZmFsc2U7XG4gIHN0YXRlLnVzZSA9IG51bGw7XG4gIHN0YXRlLnVzZURlY29kZXIgPSBudWxsO1xuICBzdGF0ZS5rZXkgPSBudWxsO1xuICBzdGF0ZVsnZGVmYXVsdCddID0gbnVsbDtcbiAgc3RhdGUuZXhwbGljaXQgPSBudWxsO1xuICBzdGF0ZS5pbXBsaWNpdCA9IG51bGw7XG4gIHN0YXRlLmNvbnRhaW5zID0gbnVsbDtcblxuICAvLyBTaG91bGQgY3JlYXRlIG5ldyBpbnN0YW5jZSBvbiBlYWNoIG1ldGhvZFxuICBpZiAoIXN0YXRlLnBhcmVudCkge1xuICAgIHN0YXRlLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5fd3JhcCgpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IE5vZGU7XG5cbnZhciBzdGF0ZVByb3BzID0gW1xuICAnZW5jJywgJ3BhcmVudCcsICdjaGlsZHJlbicsICd0YWcnLCAnYXJncycsICdyZXZlcnNlQXJncycsICdjaG9pY2UnLFxuICAnb3B0aW9uYWwnLCAnYW55JywgJ29iaicsICd1c2UnLCAnYWx0ZXJlZFVzZScsICdrZXknLCAnZGVmYXVsdCcsICdleHBsaWNpdCcsXG4gICdpbXBsaWNpdCcsICdjb250YWlucydcbl07XG5cbk5vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgdmFyIGNzdGF0ZSA9IHt9O1xuICBzdGF0ZVByb3BzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgIGNzdGF0ZVtwcm9wXSA9IHN0YXRlW3Byb3BdO1xuICB9KTtcbiAgdmFyIHJlcyA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGNzdGF0ZS5wYXJlbnQpO1xuICByZXMuX2Jhc2VTdGF0ZSA9IGNzdGF0ZTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbk5vZGUucHJvdG90eXBlLl93cmFwID0gZnVuY3Rpb24gd3JhcCgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgdGhpc1ttZXRob2RdID0gZnVuY3Rpb24gX3dyYXBwZWRNZXRob2QoKSB7XG4gICAgICB2YXIgY2xvbmUgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgIHN0YXRlLmNoaWxkcmVuLnB1c2goY2xvbmUpO1xuICAgICAgcmV0dXJuIGNsb25lW21ldGhvZF0uYXBwbHkoY2xvbmUsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSwgdGhpcyk7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoYm9keSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLnBhcmVudCA9PT0gbnVsbCk7XG4gIGJvZHkuY2FsbCh0aGlzKTtcblxuICAvLyBGaWx0ZXIgY2hpbGRyZW5cbiAgc3RhdGUuY2hpbGRyZW4gPSBzdGF0ZS5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQuX2Jhc2VTdGF0ZS5wYXJlbnQgPT09IHRoaXM7XG4gIH0sIHRoaXMpO1xuICBhc3NlcnQuZXF1YWwoc3RhdGUuY2hpbGRyZW4ubGVuZ3RoLCAxLCAnUm9vdCBub2RlIGNhbiBoYXZlIG9ubHkgb25lIGNoaWxkJyk7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fdXNlQXJncyA9IGZ1bmN0aW9uIHVzZUFyZ3MoYXJncykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgLy8gRmlsdGVyIGNoaWxkcmVuIGFuZCBhcmdzXG4gIHZhciBjaGlsZHJlbiA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yO1xuICB9LCB0aGlzKTtcbiAgYXJncyA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiAhKGFyZyBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpO1xuICB9LCB0aGlzKTtcblxuICBpZiAoY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB7XG4gICAgYXNzZXJ0KHN0YXRlLmNoaWxkcmVuID09PSBudWxsKTtcbiAgICBzdGF0ZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgLy8gUmVwbGFjZSBwYXJlbnQgdG8gbWFpbnRhaW4gYmFja3dhcmQgbGlua1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGNoaWxkLl9iYXNlU3RhdGUucGFyZW50ID0gdGhpcztcbiAgICB9LCB0aGlzKTtcbiAgfVxuICBpZiAoYXJncy5sZW5ndGggIT09IDApIHtcbiAgICBhc3NlcnQoc3RhdGUuYXJncyA9PT0gbnVsbCk7XG4gICAgc3RhdGUuYXJncyA9IGFyZ3M7XG4gICAgc3RhdGUucmV2ZXJzZUFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbihhcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAnb2JqZWN0JyB8fCBhcmcuY29uc3RydWN0b3IgIT09IE9iamVjdClcbiAgICAgICAgcmV0dXJuIGFyZztcblxuICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgT2JqZWN0LmtleXMoYXJnKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoa2V5ID09IChrZXkgfCAwKSlcbiAgICAgICAgICBrZXkgfD0gMDtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJnW2tleV07XG4gICAgICAgIHJlc1t2YWx1ZV0gPSBrZXk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vXG4vLyBPdmVycmlkZWQgbWV0aG9kc1xuLy9cblxub3ZlcnJpZGVkLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIE5vZGUucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiBfb3ZlcnJpZGVkKCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJyBub3QgaW1wbGVtZW50ZWQgZm9yIGVuY29kaW5nOiAnICsgc3RhdGUuZW5jKTtcbiAgfTtcbn0pO1xuXG4vL1xuLy8gUHVibGljIG1ldGhvZHNcbi8vXG5cbnRhZ3MuZm9yRWFjaChmdW5jdGlvbih0YWcpIHtcbiAgTm9kZS5wcm90b3R5cGVbdGFnXSA9IGZ1bmN0aW9uIF90YWdNZXRob2QoKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGFzc2VydChzdGF0ZS50YWcgPT09IG51bGwpO1xuICAgIHN0YXRlLnRhZyA9IHRhZztcblxuICAgIHRoaXMuX3VzZUFyZ3MoYXJncyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pO1xuXG5Ob2RlLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoaXRlbSkge1xuICBhc3NlcnQoaXRlbSk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUudXNlID09PSBudWxsKTtcbiAgc3RhdGUudXNlID0gaXRlbTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLm9wdGlvbmFsID0gZnVuY3Rpb24gb3B0aW9uYWwoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBzdGF0ZS5vcHRpb25hbCA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5kZWYgPSBmdW5jdGlvbiBkZWYodmFsKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGVbJ2RlZmF1bHQnXSA9PT0gbnVsbCk7XG4gIHN0YXRlWydkZWZhdWx0J10gPSB2YWw7XG4gIHN0YXRlLm9wdGlvbmFsID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmV4cGxpY2l0ID0gZnVuY3Rpb24gZXhwbGljaXQobnVtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUuZXhwbGljaXQgPT09IG51bGwgJiYgc3RhdGUuaW1wbGljaXQgPT09IG51bGwpO1xuICBzdGF0ZS5leHBsaWNpdCA9IG51bTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmltcGxpY2l0ID0gZnVuY3Rpb24gaW1wbGljaXQobnVtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUuZXhwbGljaXQgPT09IG51bGwgJiYgc3RhdGUuaW1wbGljaXQgPT09IG51bGwpO1xuICBzdGF0ZS5pbXBsaWNpdCA9IG51bTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLm9iaiA9IGZ1bmN0aW9uIG9iaigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgc3RhdGUub2JqID0gdHJ1ZTtcblxuICBpZiAoYXJncy5sZW5ndGggIT09IDApXG4gICAgdGhpcy5fdXNlQXJncyhhcmdzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uIGtleShuZXdLZXkpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS5rZXkgPT09IG51bGwpO1xuICBzdGF0ZS5rZXkgPSBuZXdLZXk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5hbnkgPSBmdW5jdGlvbiBhbnkoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBzdGF0ZS5hbnkgPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuY2hvaWNlID0gZnVuY3Rpb24gY2hvaWNlKG9iaikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLmNob2ljZSA9PT0gbnVsbCk7XG4gIHN0YXRlLmNob2ljZSA9IG9iajtcbiAgdGhpcy5fdXNlQXJncyhPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH0pKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMoaXRlbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLnVzZSA9PT0gbnVsbCk7XG4gIHN0YXRlLmNvbnRhaW5zID0gaXRlbTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBEZWNvZGluZ1xuLy9cblxuTm9kZS5wcm90b3R5cGUuX2RlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgLy8gRGVjb2RlIHJvb3Qgbm9kZVxuICBpZiAoc3RhdGUucGFyZW50ID09PSBudWxsKVxuICAgIHJldHVybiBpbnB1dC53cmFwUmVzdWx0KHN0YXRlLmNoaWxkcmVuWzBdLl9kZWNvZGUoaW5wdXQsIG9wdGlvbnMpKTtcblxuICB2YXIgcmVzdWx0ID0gc3RhdGVbJ2RlZmF1bHQnXTtcbiAgdmFyIHByZXNlbnQgPSB0cnVlO1xuXG4gIHZhciBwcmV2S2V5ID0gbnVsbDtcbiAgaWYgKHN0YXRlLmtleSAhPT0gbnVsbClcbiAgICBwcmV2S2V5ID0gaW5wdXQuZW50ZXJLZXkoc3RhdGUua2V5KTtcblxuICAvLyBDaGVjayBpZiB0YWcgaXMgdGhlcmVcbiAgaWYgKHN0YXRlLm9wdGlvbmFsKSB7XG4gICAgdmFyIHRhZyA9IG51bGw7XG4gICAgaWYgKHN0YXRlLmV4cGxpY2l0ICE9PSBudWxsKVxuICAgICAgdGFnID0gc3RhdGUuZXhwbGljaXQ7XG4gICAgZWxzZSBpZiAoc3RhdGUuaW1wbGljaXQgIT09IG51bGwpXG4gICAgICB0YWcgPSBzdGF0ZS5pbXBsaWNpdDtcbiAgICBlbHNlIGlmIChzdGF0ZS50YWcgIT09IG51bGwpXG4gICAgICB0YWcgPSBzdGF0ZS50YWc7XG5cbiAgICBpZiAodGFnID09PSBudWxsICYmICFzdGF0ZS5hbnkpIHtcbiAgICAgIC8vIFRyaWFsIGFuZCBFcnJvclxuICAgICAgdmFyIHNhdmUgPSBpbnB1dC5zYXZlKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoc3RhdGUuY2hvaWNlID09PSBudWxsKVxuICAgICAgICAgIHRoaXMuX2RlY29kZUdlbmVyaWMoc3RhdGUudGFnLCBpbnB1dCwgb3B0aW9ucyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLl9kZWNvZGVDaG9pY2UoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgICBwcmVzZW50ID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcHJlc2VudCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaW5wdXQucmVzdG9yZShzYXZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlc2VudCA9IHRoaXMuX3BlZWtUYWcoaW5wdXQsIHRhZywgc3RhdGUuYW55KTtcblxuICAgICAgaWYgKGlucHV0LmlzRXJyb3IocHJlc2VudCkpXG4gICAgICAgIHJldHVybiBwcmVzZW50O1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1c2ggb2JqZWN0IG9uIHN0YWNrXG4gIHZhciBwcmV2T2JqO1xuICBpZiAoc3RhdGUub2JqICYmIHByZXNlbnQpXG4gICAgcHJldk9iaiA9IGlucHV0LmVudGVyT2JqZWN0KCk7XG5cbiAgaWYgKHByZXNlbnQpIHtcbiAgICAvLyBVbndyYXAgZXhwbGljaXQgdmFsdWVzXG4gICAgaWYgKHN0YXRlLmV4cGxpY2l0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgZXhwbGljaXQgPSB0aGlzLl9kZWNvZGVUYWcoaW5wdXQsIHN0YXRlLmV4cGxpY2l0KTtcbiAgICAgIGlmIChpbnB1dC5pc0Vycm9yKGV4cGxpY2l0KSlcbiAgICAgICAgcmV0dXJuIGV4cGxpY2l0O1xuICAgICAgaW5wdXQgPSBleHBsaWNpdDtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBpbnB1dC5vZmZzZXQ7XG5cbiAgICAvLyBVbndyYXAgaW1wbGljaXQgYW5kIG5vcm1hbCB2YWx1ZXNcbiAgICBpZiAoc3RhdGUudXNlID09PSBudWxsICYmIHN0YXRlLmNob2ljZSA9PT0gbnVsbCkge1xuICAgICAgaWYgKHN0YXRlLmFueSlcbiAgICAgICAgdmFyIHNhdmUgPSBpbnB1dC5zYXZlKCk7XG4gICAgICB2YXIgYm9keSA9IHRoaXMuX2RlY29kZVRhZyhcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHN0YXRlLmltcGxpY2l0ICE9PSBudWxsID8gc3RhdGUuaW1wbGljaXQgOiBzdGF0ZS50YWcsXG4gICAgICAgIHN0YXRlLmFueVxuICAgICAgKTtcbiAgICAgIGlmIChpbnB1dC5pc0Vycm9yKGJvZHkpKVxuICAgICAgICByZXR1cm4gYm9keTtcblxuICAgICAgaWYgKHN0YXRlLmFueSlcbiAgICAgICAgcmVzdWx0ID0gaW5wdXQucmF3KHNhdmUpO1xuICAgICAgZWxzZVxuICAgICAgICBpbnB1dCA9IGJvZHk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50cmFjayAmJiBzdGF0ZS50YWcgIT09IG51bGwpXG4gICAgICBvcHRpb25zLnRyYWNrKGlucHV0LnBhdGgoKSwgc3RhcnQsIGlucHV0Lmxlbmd0aCwgJ3RhZ2dlZCcpO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50cmFjayAmJiBzdGF0ZS50YWcgIT09IG51bGwpXG4gICAgICBvcHRpb25zLnRyYWNrKGlucHV0LnBhdGgoKSwgaW5wdXQub2Zmc2V0LCBpbnB1dC5sZW5ndGgsICdjb250ZW50Jyk7XG5cbiAgICAvLyBTZWxlY3QgcHJvcGVyIG1ldGhvZCBmb3IgdGFnXG4gICAgaWYgKHN0YXRlLmFueSlcbiAgICAgIHJlc3VsdCA9IHJlc3VsdDtcbiAgICBlbHNlIGlmIChzdGF0ZS5jaG9pY2UgPT09IG51bGwpXG4gICAgICByZXN1bHQgPSB0aGlzLl9kZWNvZGVHZW5lcmljKHN0YXRlLnRhZywgaW5wdXQsIG9wdGlvbnMpO1xuICAgIGVsc2VcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2RlY29kZUNob2ljZShpbnB1dCwgb3B0aW9ucyk7XG5cbiAgICBpZiAoaW5wdXQuaXNFcnJvcihyZXN1bHQpKVxuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIC8vIERlY29kZSBjaGlsZHJlblxuICAgIGlmICghc3RhdGUuYW55ICYmIHN0YXRlLmNob2ljZSA9PT0gbnVsbCAmJiBzdGF0ZS5jaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgc3RhdGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiBkZWNvZGVDaGlsZHJlbihjaGlsZCkge1xuICAgICAgICAvLyBOT1RFOiBXZSBhcmUgaWdub3JpbmcgZXJyb3JzIGhlcmUsIHRvIGxldCBwYXJzZXIgY29udGludWUgd2l0aCBvdGhlclxuICAgICAgICAvLyBwYXJ0cyBvZiBlbmNvZGVkIGRhdGFcbiAgICAgICAgY2hpbGQuX2RlY29kZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBEZWNvZGUgY29udGFpbmVkL2VuY29kZWQgYnkgc2NoZW1hLCBvbmx5IGluIGJpdCBvciBvY3RldCBzdHJpbmdzXG4gICAgaWYgKHN0YXRlLmNvbnRhaW5zICYmIChzdGF0ZS50YWcgPT09ICdvY3RzdHInIHx8IHN0YXRlLnRhZyA9PT0gJ2JpdHN0cicpKSB7XG4gICAgICB2YXIgZGF0YSA9IG5ldyBEZWNvZGVyQnVmZmVyKHJlc3VsdCk7XG4gICAgICByZXN1bHQgPSB0aGlzLl9nZXRVc2Uoc3RhdGUuY29udGFpbnMsIGlucHV0Ll9yZXBvcnRlclN0YXRlLm9iailcbiAgICAgICAgICAuX2RlY29kZShkYXRhLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvLyBQb3Agb2JqZWN0XG4gIGlmIChzdGF0ZS5vYmogJiYgcHJlc2VudClcbiAgICByZXN1bHQgPSBpbnB1dC5sZWF2ZU9iamVjdChwcmV2T2JqKTtcblxuICAvLyBTZXQga2V5XG4gIGlmIChzdGF0ZS5rZXkgIT09IG51bGwgJiYgKHJlc3VsdCAhPT0gbnVsbCB8fCBwcmVzZW50ID09PSB0cnVlKSlcbiAgICBpbnB1dC5sZWF2ZUtleShwcmV2S2V5LCBzdGF0ZS5rZXksIHJlc3VsdCk7XG4gIGVsc2UgaWYgKHByZXZLZXkgIT09IG51bGwpXG4gICAgaW5wdXQuZXhpdEtleShwcmV2S2V5KTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2RlY29kZUdlbmVyaWMgPSBmdW5jdGlvbiBkZWNvZGVHZW5lcmljKHRhZywgaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGlmICh0YWcgPT09ICdzZXEnIHx8IHRhZyA9PT0gJ3NldCcpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmICh0YWcgPT09ICdzZXFvZicgfHwgdGFnID09PSAnc2V0b2YnKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVMaXN0KGlucHV0LCB0YWcsIHN0YXRlLmFyZ3NbMF0sIG9wdGlvbnMpO1xuICBlbHNlIGlmICgvc3RyJC8udGVzdCh0YWcpKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVTdHIoaW5wdXQsIHRhZywgb3B0aW9ucyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJyAmJiBzdGF0ZS5hcmdzKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVPYmppZChpbnB1dCwgc3RhdGUuYXJnc1swXSwgc3RhdGUuYXJnc1sxXSwgb3B0aW9ucyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlT2JqaWQoaW5wdXQsIG51bGwsIG51bGwsIG9wdGlvbnMpO1xuICBlbHNlIGlmICh0YWcgPT09ICdnZW50aW1lJyB8fCB0YWcgPT09ICd1dGN0aW1lJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlVGltZShpbnB1dCwgdGFnLCBvcHRpb25zKTtcbiAgZWxzZSBpZiAodGFnID09PSAnbnVsbF8nKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVOdWxsKGlucHV0LCBvcHRpb25zKTtcbiAgZWxzZSBpZiAodGFnID09PSAnYm9vbCcpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZUJvb2woaW5wdXQsIG9wdGlvbnMpO1xuICBlbHNlIGlmICh0YWcgPT09ICdvYmpEZXNjJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlU3RyKGlucHV0LCB0YWcsIG9wdGlvbnMpO1xuICBlbHNlIGlmICh0YWcgPT09ICdpbnQnIHx8IHRhZyA9PT0gJ2VudW0nKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVJbnQoaW5wdXQsIHN0YXRlLmFyZ3MgJiYgc3RhdGUuYXJnc1swXSwgb3B0aW9ucyk7XG5cbiAgaWYgKHN0YXRlLnVzZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVc2Uoc3RhdGUudXNlLCBpbnB1dC5fcmVwb3J0ZXJTdGF0ZS5vYmopXG4gICAgICAgIC5fZGVjb2RlKGlucHV0LCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW5wdXQuZXJyb3IoJ3Vua25vd24gdGFnOiAnICsgdGFnKTtcbiAgfVxufTtcblxuTm9kZS5wcm90b3R5cGUuX2dldFVzZSA9IGZ1bmN0aW9uIF9nZXRVc2UoZW50aXR5LCBvYmopIHtcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIC8vIENyZWF0ZSBhbHRlcmVkIHVzZSBkZWNvZGVyIGlmIGltcGxpY2l0IGlzIHNldFxuICBzdGF0ZS51c2VEZWNvZGVyID0gdGhpcy5fdXNlKGVudGl0eSwgb2JqKTtcbiAgYXNzZXJ0KHN0YXRlLnVzZURlY29kZXIuX2Jhc2VTdGF0ZS5wYXJlbnQgPT09IG51bGwpO1xuICBzdGF0ZS51c2VEZWNvZGVyID0gc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLmNoaWxkcmVuWzBdO1xuICBpZiAoc3RhdGUuaW1wbGljaXQgIT09IHN0YXRlLnVzZURlY29kZXIuX2Jhc2VTdGF0ZS5pbXBsaWNpdCkge1xuICAgIHN0YXRlLnVzZURlY29kZXIgPSBzdGF0ZS51c2VEZWNvZGVyLmNsb25lKCk7XG4gICAgc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLmltcGxpY2l0ID0gc3RhdGUuaW1wbGljaXQ7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnVzZURlY29kZXI7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZGVjb2RlQ2hvaWNlID0gZnVuY3Rpb24gZGVjb2RlQ2hvaWNlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgdmFyIHJlc3VsdCA9IG51bGw7XG4gIHZhciBtYXRjaCA9IGZhbHNlO1xuXG4gIE9iamVjdC5rZXlzKHN0YXRlLmNob2ljZSkuc29tZShmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgc2F2ZSA9IGlucHV0LnNhdmUoKTtcbiAgICB2YXIgbm9kZSA9IHN0YXRlLmNob2ljZVtrZXldO1xuICAgIHRyeSB7XG4gICAgICB2YXIgdmFsdWUgPSBub2RlLl9kZWNvZGUoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgaWYgKGlucHV0LmlzRXJyb3IodmFsdWUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJlc3VsdCA9IHsgdHlwZToga2V5LCB2YWx1ZTogdmFsdWUgfTtcbiAgICAgIG1hdGNoID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpbnB1dC5yZXN0b3JlKHNhdmUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgdGhpcyk7XG5cbiAgaWYgKCFtYXRjaClcbiAgICByZXR1cm4gaW5wdXQuZXJyb3IoJ0Nob2ljZSBub3QgbWF0Y2hlZCcpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vL1xuLy8gRW5jb2Rpbmdcbi8vXG5cbk5vZGUucHJvdG90eXBlLl9jcmVhdGVFbmNvZGVyQnVmZmVyID0gZnVuY3Rpb24gY3JlYXRlRW5jb2RlckJ1ZmZlcihkYXRhKSB7XG4gIHJldHVybiBuZXcgRW5jb2RlckJ1ZmZlcihkYXRhLCB0aGlzLnJlcG9ydGVyKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZGF0YSwgcmVwb3J0ZXIsIHBhcmVudCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIGlmIChzdGF0ZVsnZGVmYXVsdCddICE9PSBudWxsICYmIHN0YXRlWydkZWZhdWx0J10gPT09IGRhdGEpXG4gICAgcmV0dXJuO1xuXG4gIHZhciByZXN1bHQgPSB0aGlzLl9lbmNvZGVWYWx1ZShkYXRhLCByZXBvcnRlciwgcGFyZW50KTtcbiAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybjtcblxuICBpZiAodGhpcy5fc2tpcERlZmF1bHQocmVzdWx0LCByZXBvcnRlciwgcGFyZW50KSlcbiAgICByZXR1cm47XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9lbmNvZGVWYWx1ZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCByZXBvcnRlciwgcGFyZW50KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICAvLyBEZWNvZGUgcm9vdCBub2RlXG4gIGlmIChzdGF0ZS5wYXJlbnQgPT09IG51bGwpXG4gICAgcmV0dXJuIHN0YXRlLmNoaWxkcmVuWzBdLl9lbmNvZGUoZGF0YSwgcmVwb3J0ZXIgfHwgbmV3IFJlcG9ydGVyKCkpO1xuXG4gIHZhciByZXN1bHQgPSBudWxsO1xuXG4gIC8vIFNldCByZXBvcnRlciB0byBzaGFyZSBpdCB3aXRoIGEgY2hpbGQgY2xhc3NcbiAgdGhpcy5yZXBvcnRlciA9IHJlcG9ydGVyO1xuXG4gIC8vIENoZWNrIGlmIGRhdGEgaXMgdGhlcmVcbiAgaWYgKHN0YXRlLm9wdGlvbmFsICYmIGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChzdGF0ZVsnZGVmYXVsdCddICE9PSBudWxsKVxuICAgICAgZGF0YSA9IHN0YXRlWydkZWZhdWx0J11cbiAgICBlbHNlXG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbmNvZGUgY2hpbGRyZW4gZmlyc3RcbiAgdmFyIGNvbnRlbnQgPSBudWxsO1xuICB2YXIgcHJpbWl0aXZlID0gZmFsc2U7XG4gIGlmIChzdGF0ZS5hbnkpIHtcbiAgICAvLyBBbnl0aGluZyB0aGF0IHdhcyBnaXZlbiBpcyB0cmFuc2xhdGVkIHRvIGJ1ZmZlclxuICAgIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoZGF0YSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUuY2hvaWNlKSB7XG4gICAgcmVzdWx0ID0gdGhpcy5fZW5jb2RlQ2hvaWNlKGRhdGEsIHJlcG9ydGVyKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5jb250YWlucykge1xuICAgIGNvbnRlbnQgPSB0aGlzLl9nZXRVc2Uoc3RhdGUuY29udGFpbnMsIHBhcmVudCkuX2VuY29kZShkYXRhLCByZXBvcnRlcik7XG4gICAgcHJpbWl0aXZlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5jaGlsZHJlbikge1xuICAgIGNvbnRlbnQgPSBzdGF0ZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5fYmFzZVN0YXRlLnRhZyA9PT0gJ251bGxfJylcbiAgICAgICAgcmV0dXJuIGNoaWxkLl9lbmNvZGUobnVsbCwgcmVwb3J0ZXIsIGRhdGEpO1xuXG4gICAgICBpZiAoY2hpbGQuX2Jhc2VTdGF0ZS5rZXkgPT09IG51bGwpXG4gICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignQ2hpbGQgc2hvdWxkIGhhdmUgYSBrZXknKTtcbiAgICAgIHZhciBwcmV2S2V5ID0gcmVwb3J0ZXIuZW50ZXJLZXkoY2hpbGQuX2Jhc2VTdGF0ZS5rZXkpO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ0NoaWxkIGV4cGVjdGVkLCBidXQgaW5wdXQgaXMgbm90IG9iamVjdCcpO1xuXG4gICAgICB2YXIgcmVzID0gY2hpbGQuX2VuY29kZShkYXRhW2NoaWxkLl9iYXNlU3RhdGUua2V5XSwgcmVwb3J0ZXIsIGRhdGEpO1xuICAgICAgcmVwb3J0ZXIubGVhdmVLZXkocHJldktleSk7XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSwgdGhpcykuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSk7XG4gICAgY29udGVudCA9IHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoY29udGVudCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHN0YXRlLnRhZyA9PT0gJ3NlcW9mJyB8fCBzdGF0ZS50YWcgPT09ICdzZXRvZicpIHtcbiAgICAgIC8vIFRPRE8oaW5kdXRueSk6IHRoaXMgc2hvdWxkIGJlIHRocm93biBvbiBEU0wgbGV2ZWxcbiAgICAgIGlmICghKHN0YXRlLmFyZ3MgJiYgc3RhdGUuYXJncy5sZW5ndGggPT09IDEpKVxuICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ1RvbyBtYW55IGFyZ3MgZm9yIDogJyArIHN0YXRlLnRhZyk7XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdzZXFvZi9zZXRvZiwgYnV0IGRhdGEgaXMgbm90IEFycmF5Jyk7XG5cbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGNoaWxkLl9iYXNlU3RhdGUuaW1wbGljaXQgPSBudWxsO1xuICAgICAgY29udGVudCA9IHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoZGF0YS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFVzZShzdGF0ZS5hcmdzWzBdLCBkYXRhKS5fZW5jb2RlKGl0ZW0sIHJlcG9ydGVyKTtcbiAgICAgIH0sIGNoaWxkKSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS51c2UgIT09IG51bGwpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2dldFVzZShzdGF0ZS51c2UsIHBhcmVudCkuX2VuY29kZShkYXRhLCByZXBvcnRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQgPSB0aGlzLl9lbmNvZGVQcmltaXRpdmUoc3RhdGUudGFnLCBkYXRhKTtcbiAgICAgIHByaW1pdGl2ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gRW5jb2RlIGRhdGEgaXRzZWxmXG4gIHZhciByZXN1bHQ7XG4gIGlmICghc3RhdGUuYW55ICYmIHN0YXRlLmNob2ljZSA9PT0gbnVsbCkge1xuICAgIHZhciB0YWcgPSBzdGF0ZS5pbXBsaWNpdCAhPT0gbnVsbCA/IHN0YXRlLmltcGxpY2l0IDogc3RhdGUudGFnO1xuICAgIHZhciBjbHMgPSBzdGF0ZS5pbXBsaWNpdCA9PT0gbnVsbCA/ICd1bml2ZXJzYWwnIDogJ2NvbnRleHQnO1xuXG4gICAgaWYgKHRhZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKHN0YXRlLnVzZSA9PT0gbnVsbClcbiAgICAgICAgcmVwb3J0ZXIuZXJyb3IoJ1RhZyBjb3VsZCBiZSBvbWl0dGVkIG9ubHkgZm9yIC51c2UoKScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUudXNlID09PSBudWxsKVxuICAgICAgICByZXN1bHQgPSB0aGlzLl9lbmNvZGVDb21wb3NpdGUodGFnLCBwcmltaXRpdmUsIGNscywgY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gV3JhcCBpbiBleHBsaWNpdFxuICBpZiAoc3RhdGUuZXhwbGljaXQgIT09IG51bGwpXG4gICAgcmVzdWx0ID0gdGhpcy5fZW5jb2RlQ29tcG9zaXRlKHN0YXRlLmV4cGxpY2l0LCBmYWxzZSwgJ2NvbnRleHQnLCByZXN1bHQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZW5jb2RlQ2hvaWNlID0gZnVuY3Rpb24gZW5jb2RlQ2hvaWNlKGRhdGEsIHJlcG9ydGVyKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICB2YXIgbm9kZSA9IHN0YXRlLmNob2ljZVtkYXRhLnR5cGVdO1xuICBpZiAoIW5vZGUpIHtcbiAgICBhc3NlcnQoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBkYXRhLnR5cGUgKyAnIG5vdCBmb3VuZCBpbiAnICtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHN0YXRlLmNob2ljZSkpKTtcbiAgfVxuICByZXR1cm4gbm9kZS5fZW5jb2RlKGRhdGEudmFsdWUsIHJlcG9ydGVyKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9lbmNvZGVQcmltaXRpdmUgPSBmdW5jdGlvbiBlbmNvZGVQcmltaXRpdmUodGFnLCBkYXRhKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBpZiAoL3N0ciQvLnRlc3QodGFnKSlcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlU3RyKGRhdGEsIHRhZyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJyAmJiBzdGF0ZS5hcmdzKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVPYmppZChkYXRhLCBzdGF0ZS5yZXZlcnNlQXJnc1swXSwgc3RhdGUuYXJnc1sxXSk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iamlkJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlT2JqaWQoZGF0YSwgbnVsbCwgbnVsbCk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2dlbnRpbWUnIHx8IHRhZyA9PT0gJ3V0Y3RpbWUnKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVUaW1lKGRhdGEsIHRhZyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ251bGxfJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlTnVsbCgpO1xuICBlbHNlIGlmICh0YWcgPT09ICdpbnQnIHx8IHRhZyA9PT0gJ2VudW0nKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVJbnQoZGF0YSwgc3RhdGUuYXJncyAmJiBzdGF0ZS5yZXZlcnNlQXJnc1swXSk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2Jvb2wnKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVCb29sKGRhdGEpO1xuICBlbHNlIGlmICh0YWcgPT09ICdvYmpEZXNjJylcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlU3RyKGRhdGEsIHRhZyk7XG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHRhZzogJyArIHRhZyk7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5faXNOdW1zdHIgPSBmdW5jdGlvbiBpc051bXN0cihzdHIpIHtcbiAgcmV0dXJuIC9eWzAtOSBdKiQvLnRlc3Qoc3RyKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9pc1ByaW50c3RyID0gZnVuY3Rpb24gaXNQcmludHN0cihzdHIpIHtcbiAgcmV0dXJuIC9eW0EtWmEtejAtOSAnXFwoXFwpXFwrLFxcLVxcLlxcLzo9XFw/XSokLy50ZXN0KHN0cik7XG59O1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZnVuY3Rpb24gUmVwb3J0ZXIob3B0aW9ucykge1xuICB0aGlzLl9yZXBvcnRlclN0YXRlID0ge1xuICAgIG9iajogbnVsbCxcbiAgICBwYXRoOiBbXSxcbiAgICBvcHRpb25zOiBvcHRpb25zIHx8IHt9LFxuICAgIGVycm9yczogW11cbiAgfTtcbn1cbmV4cG9ydHMuUmVwb3J0ZXIgPSBSZXBvcnRlcjtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmlzRXJyb3IgPSBmdW5jdGlvbiBpc0Vycm9yKG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgUmVwb3J0ZXJFcnJvcjtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gc2F2ZSgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICByZXR1cm4geyBvYmo6IHN0YXRlLm9iaiwgcGF0aExlbjogc3RhdGUucGF0aC5sZW5ndGggfTtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gcmVzdG9yZShkYXRhKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgc3RhdGUub2JqID0gZGF0YS5vYmo7XG4gIHN0YXRlLnBhdGggPSBzdGF0ZS5wYXRoLnNsaWNlKDAsIGRhdGEucGF0aExlbik7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUuZW50ZXJLZXkgPSBmdW5jdGlvbiBlbnRlcktleShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX3JlcG9ydGVyU3RhdGUucGF0aC5wdXNoKGtleSk7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUuZXhpdEtleSA9IGZ1bmN0aW9uIGV4aXRLZXkoaW5kZXgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICBzdGF0ZS5wYXRoID0gc3RhdGUucGF0aC5zbGljZSgwLCBpbmRleCAtIDEpO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmxlYXZlS2V5ID0gZnVuY3Rpb24gbGVhdmVLZXkoaW5kZXgsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICB0aGlzLmV4aXRLZXkoaW5kZXgpO1xuICBpZiAoc3RhdGUub2JqICE9PSBudWxsKVxuICAgIHN0YXRlLm9ialtrZXldID0gdmFsdWU7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uIHBhdGgoKSB7XG4gIHJldHVybiB0aGlzLl9yZXBvcnRlclN0YXRlLnBhdGguam9pbignLycpO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmVudGVyT2JqZWN0ID0gZnVuY3Rpb24gZW50ZXJPYmplY3QoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgdmFyIHByZXYgPSBzdGF0ZS5vYmo7XG4gIHN0YXRlLm9iaiA9IHt9O1xuICByZXR1cm4gcHJldjtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5sZWF2ZU9iamVjdCA9IGZ1bmN0aW9uIGxlYXZlT2JqZWN0KHByZXYpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICB2YXIgbm93ID0gc3RhdGUub2JqO1xuICBzdGF0ZS5vYmogPSBwcmV2O1xuICByZXR1cm4gbm93O1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIHZhciBlcnI7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgdmFyIGluaGVyaXRlZCA9IG1zZyBpbnN0YW5jZW9mIFJlcG9ydGVyRXJyb3I7XG4gIGlmIChpbmhlcml0ZWQpIHtcbiAgICBlcnIgPSBtc2c7XG4gIH0gZWxzZSB7XG4gICAgZXJyID0gbmV3IFJlcG9ydGVyRXJyb3Ioc3RhdGUucGF0aC5tYXAoZnVuY3Rpb24oZWxlbSkge1xuICAgICAgcmV0dXJuICdbJyArIEpTT04uc3RyaW5naWZ5KGVsZW0pICsgJ10nO1xuICAgIH0pLmpvaW4oJycpLCBtc2cubWVzc2FnZSB8fCBtc2csIG1zZy5zdGFjayk7XG4gIH1cblxuICBpZiAoIXN0YXRlLm9wdGlvbnMucGFydGlhbClcbiAgICB0aHJvdyBlcnI7XG5cbiAgaWYgKCFpbmhlcml0ZWQpXG4gICAgc3RhdGUuZXJyb3JzLnB1c2goZXJyKTtcblxuICByZXR1cm4gZXJyO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLndyYXBSZXN1bHQgPSBmdW5jdGlvbiB3cmFwUmVzdWx0KHJlc3VsdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuICBpZiAoIXN0YXRlLm9wdGlvbnMucGFydGlhbClcbiAgICByZXR1cm4gcmVzdWx0O1xuXG4gIHJldHVybiB7XG4gICAgcmVzdWx0OiB0aGlzLmlzRXJyb3IocmVzdWx0KSA/IG51bGwgOiByZXN1bHQsXG4gICAgZXJyb3JzOiBzdGF0ZS5lcnJvcnNcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIFJlcG9ydGVyRXJyb3IocGF0aCwgbXNnKSB7XG4gIHRoaXMucGF0aCA9IHBhdGg7XG4gIHRoaXMucmV0aHJvdyhtc2cpO1xufTtcbmluaGVyaXRzKFJlcG9ydGVyRXJyb3IsIEVycm9yKTtcblxuUmVwb3J0ZXJFcnJvci5wcm90b3R5cGUucmV0aHJvdyA9IGZ1bmN0aW9uIHJldGhyb3cobXNnKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1zZyArICcgYXQ6ICcgKyAodGhpcy5wYXRoIHx8ICcoc2hhbGxvdyknKTtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFJlcG9ydGVyRXJyb3IpO1xuXG4gIGlmICghdGhpcy5zdGFjaykge1xuICAgIHRyeSB7XG4gICAgICAvLyBJRSBvbmx5IGFkZHMgc3RhY2sgd2hlbiB0aHJvd25cbiAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLm1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuc3RhY2sgPSBlLnN0YWNrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG4iLCJ2YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XG5cbmV4cG9ydHMudGFnQ2xhc3MgPSB7XG4gIDA6ICd1bml2ZXJzYWwnLFxuICAxOiAnYXBwbGljYXRpb24nLFxuICAyOiAnY29udGV4dCcsXG4gIDM6ICdwcml2YXRlJ1xufTtcbmV4cG9ydHMudGFnQ2xhc3NCeU5hbWUgPSBjb25zdGFudHMuX3JldmVyc2UoZXhwb3J0cy50YWdDbGFzcyk7XG5cbmV4cG9ydHMudGFnID0ge1xuICAweDAwOiAnZW5kJyxcbiAgMHgwMTogJ2Jvb2wnLFxuICAweDAyOiAnaW50JyxcbiAgMHgwMzogJ2JpdHN0cicsXG4gIDB4MDQ6ICdvY3RzdHInLFxuICAweDA1OiAnbnVsbF8nLFxuICAweDA2OiAnb2JqaWQnLFxuICAweDA3OiAnb2JqRGVzYycsXG4gIDB4MDg6ICdleHRlcm5hbCcsXG4gIDB4MDk6ICdyZWFsJyxcbiAgMHgwYTogJ2VudW0nLFxuICAweDBiOiAnZW1iZWQnLFxuICAweDBjOiAndXRmOHN0cicsXG4gIDB4MGQ6ICdyZWxhdGl2ZU9pZCcsXG4gIDB4MTA6ICdzZXEnLFxuICAweDExOiAnc2V0JyxcbiAgMHgxMjogJ251bXN0cicsXG4gIDB4MTM6ICdwcmludHN0cicsXG4gIDB4MTQ6ICd0NjFzdHInLFxuICAweDE1OiAndmlkZW9zdHInLFxuICAweDE2OiAnaWE1c3RyJyxcbiAgMHgxNzogJ3V0Y3RpbWUnLFxuICAweDE4OiAnZ2VudGltZScsXG4gIDB4MTk6ICdncmFwaHN0cicsXG4gIDB4MWE6ICdpc282NDZzdHInLFxuICAweDFiOiAnZ2Vuc3RyJyxcbiAgMHgxYzogJ3VuaXN0cicsXG4gIDB4MWQ6ICdjaGFyc3RyJyxcbiAgMHgxZTogJ2JtcHN0cidcbn07XG5leHBvcnRzLnRhZ0J5TmFtZSA9IGNvbnN0YW50cy5fcmV2ZXJzZShleHBvcnRzLnRhZyk7XG4iLCJ2YXIgY29uc3RhbnRzID0gZXhwb3J0cztcblxuLy8gSGVscGVyXG5jb25zdGFudHMuX3JldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKG1hcCkge1xuICB2YXIgcmVzID0ge307XG5cbiAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIC8vIENvbnZlcnQga2V5IHRvIGludGVnZXIgaWYgaXQgaXMgc3RyaW5naWZpZWRcbiAgICBpZiAoKGtleSB8IDApID09IGtleSlcbiAgICAgIGtleSA9IGtleSB8IDA7XG5cbiAgICB2YXIgdmFsdWUgPSBtYXBba2V5XTtcbiAgICByZXNbdmFsdWVdID0ga2V5O1xuICB9KTtcblxuICByZXR1cm4gcmVzO1xufTtcblxuY29uc3RhbnRzLmRlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG52YXIgYXNuMSA9IHJlcXVpcmUoJy4uLy4uL2FzbjEnKTtcbnZhciBiYXNlID0gYXNuMS5iYXNlO1xudmFyIGJpZ251bSA9IGFzbjEuYmlnbnVtO1xuXG4vLyBJbXBvcnQgREVSIGNvbnN0YW50c1xudmFyIGRlciA9IGFzbjEuY29uc3RhbnRzLmRlcjtcblxuZnVuY3Rpb24gREVSRGVjb2RlcihlbnRpdHkpIHtcbiAgdGhpcy5lbmMgPSAnZGVyJztcbiAgdGhpcy5uYW1lID0gZW50aXR5Lm5hbWU7XG4gIHRoaXMuZW50aXR5ID0gZW50aXR5O1xuXG4gIC8vIENvbnN0cnVjdCBiYXNlIHRyZWVcbiAgdGhpcy50cmVlID0gbmV3IERFUk5vZGUoKTtcbiAgdGhpcy50cmVlLl9pbml0KGVudGl0eS5ib2R5KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERFUkRlY29kZXI7XG5cbkRFUkRlY29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShkYXRhLCBvcHRpb25zKSB7XG4gIGlmICghKGRhdGEgaW5zdGFuY2VvZiBiYXNlLkRlY29kZXJCdWZmZXIpKVxuICAgIGRhdGEgPSBuZXcgYmFzZS5EZWNvZGVyQnVmZmVyKGRhdGEsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLnRyZWUuX2RlY29kZShkYXRhLCBvcHRpb25zKTtcbn07XG5cbi8vIFRyZWUgbWV0aG9kc1xuXG5mdW5jdGlvbiBERVJOb2RlKHBhcmVudCkge1xuICBiYXNlLk5vZGUuY2FsbCh0aGlzLCAnZGVyJywgcGFyZW50KTtcbn1cbmluaGVyaXRzKERFUk5vZGUsIGJhc2UuTm9kZSk7XG5cbkRFUk5vZGUucHJvdG90eXBlLl9wZWVrVGFnID0gZnVuY3Rpb24gcGVla1RhZyhidWZmZXIsIHRhZywgYW55KSB7XG4gIGlmIChidWZmZXIuaXNFbXB0eSgpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgc3RhdGUgPSBidWZmZXIuc2F2ZSgpO1xuICB2YXIgZGVjb2RlZFRhZyA9IGRlckRlY29kZVRhZyhidWZmZXIsICdGYWlsZWQgdG8gcGVlayB0YWc6IFwiJyArIHRhZyArICdcIicpO1xuICBpZiAoYnVmZmVyLmlzRXJyb3IoZGVjb2RlZFRhZykpXG4gICAgcmV0dXJuIGRlY29kZWRUYWc7XG5cbiAgYnVmZmVyLnJlc3RvcmUoc3RhdGUpO1xuXG4gIHJldHVybiBkZWNvZGVkVGFnLnRhZyA9PT0gdGFnIHx8IGRlY29kZWRUYWcudGFnU3RyID09PSB0YWcgfHxcbiAgICAoZGVjb2RlZFRhZy50YWdTdHIgKyAnb2YnKSA9PT0gdGFnIHx8IGFueTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVUYWcgPSBmdW5jdGlvbiBkZWNvZGVUYWcoYnVmZmVyLCB0YWcsIGFueSkge1xuICB2YXIgZGVjb2RlZFRhZyA9IGRlckRlY29kZVRhZyhidWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gZGVjb2RlIHRhZyBvZiBcIicgKyB0YWcgKyAnXCInKTtcbiAgaWYgKGJ1ZmZlci5pc0Vycm9yKGRlY29kZWRUYWcpKVxuICAgIHJldHVybiBkZWNvZGVkVGFnO1xuXG4gIHZhciBsZW4gPSBkZXJEZWNvZGVMZW4oYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRUYWcucHJpbWl0aXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICdGYWlsZWQgdG8gZ2V0IGxlbmd0aCBvZiBcIicgKyB0YWcgKyAnXCInKTtcblxuICAvLyBGYWlsdXJlXG4gIGlmIChidWZmZXIuaXNFcnJvcihsZW4pKVxuICAgIHJldHVybiBsZW47XG5cbiAgaWYgKCFhbnkgJiZcbiAgICAgIGRlY29kZWRUYWcudGFnICE9PSB0YWcgJiZcbiAgICAgIGRlY29kZWRUYWcudGFnU3RyICE9PSB0YWcgJiZcbiAgICAgIGRlY29kZWRUYWcudGFnU3RyICsgJ29mJyAhPT0gdGFnKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRmFpbGVkIHRvIG1hdGNoIHRhZzogXCInICsgdGFnICsgJ1wiJyk7XG4gIH1cblxuICBpZiAoZGVjb2RlZFRhZy5wcmltaXRpdmUgfHwgbGVuICE9PSBudWxsKVxuICAgIHJldHVybiBidWZmZXIuc2tpcChsZW4sICdGYWlsZWQgdG8gbWF0Y2ggYm9keSBvZjogXCInICsgdGFnICsgJ1wiJyk7XG5cbiAgLy8gSW5kZWZpbml0ZSBsZW5ndGguLi4gZmluZCBFTkQgdGFnXG4gIHZhciBzdGF0ZSA9IGJ1ZmZlci5zYXZlKCk7XG4gIHZhciByZXMgPSB0aGlzLl9za2lwVW50aWxFbmQoXG4gICAgICBidWZmZXIsXG4gICAgICAnRmFpbGVkIHRvIHNraXAgaW5kZWZpbml0ZSBsZW5ndGggYm9keTogXCInICsgdGhpcy50YWcgKyAnXCInKTtcbiAgaWYgKGJ1ZmZlci5pc0Vycm9yKHJlcykpXG4gICAgcmV0dXJuIHJlcztcblxuICBsZW4gPSBidWZmZXIub2Zmc2V0IC0gc3RhdGUub2Zmc2V0O1xuICBidWZmZXIucmVzdG9yZShzdGF0ZSk7XG4gIHJldHVybiBidWZmZXIuc2tpcChsZW4sICdGYWlsZWQgdG8gbWF0Y2ggYm9keSBvZjogXCInICsgdGFnICsgJ1wiJyk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fc2tpcFVudGlsRW5kID0gZnVuY3Rpb24gc2tpcFVudGlsRW5kKGJ1ZmZlciwgZmFpbCkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciB0YWcgPSBkZXJEZWNvZGVUYWcoYnVmZmVyLCBmYWlsKTtcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IodGFnKSlcbiAgICAgIHJldHVybiB0YWc7XG4gICAgdmFyIGxlbiA9IGRlckRlY29kZUxlbihidWZmZXIsIHRhZy5wcmltaXRpdmUsIGZhaWwpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcihsZW4pKVxuICAgICAgcmV0dXJuIGxlbjtcblxuICAgIHZhciByZXM7XG4gICAgaWYgKHRhZy5wcmltaXRpdmUgfHwgbGVuICE9PSBudWxsKVxuICAgICAgcmVzID0gYnVmZmVyLnNraXAobGVuKVxuICAgIGVsc2VcbiAgICAgIHJlcyA9IHRoaXMuX3NraXBVbnRpbEVuZChidWZmZXIsIGZhaWwpO1xuXG4gICAgLy8gRmFpbHVyZVxuICAgIGlmIChidWZmZXIuaXNFcnJvcihyZXMpKVxuICAgICAgcmV0dXJuIHJlcztcblxuICAgIGlmICh0YWcudGFnU3RyID09PSAnZW5kJylcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlTGlzdCA9IGZ1bmN0aW9uIGRlY29kZUxpc3QoYnVmZmVyLCB0YWcsIGRlY29kZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlICghYnVmZmVyLmlzRW1wdHkoKSkge1xuICAgIHZhciBwb3NzaWJsZUVuZCA9IHRoaXMuX3BlZWtUYWcoYnVmZmVyLCAnZW5kJyk7XG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKHBvc3NpYmxlRW5kKSlcbiAgICAgIHJldHVybiBwb3NzaWJsZUVuZDtcblxuICAgIHZhciByZXMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIsICdkZXInLCBvcHRpb25zKTtcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IocmVzKSAmJiBwb3NzaWJsZUVuZClcbiAgICAgIGJyZWFrO1xuICAgIHJlc3VsdC5wdXNoKHJlcyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVTdHIgPSBmdW5jdGlvbiBkZWNvZGVTdHIoYnVmZmVyLCB0YWcpIHtcbiAgaWYgKHRhZyA9PT0gJ2JpdHN0cicpIHtcbiAgICB2YXIgdW51c2VkID0gYnVmZmVyLnJlYWRVSW50OCgpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcih1bnVzZWQpKVxuICAgICAgcmV0dXJuIHVudXNlZDtcbiAgICByZXR1cm4geyB1bnVzZWQ6IHVudXNlZCwgZGF0YTogYnVmZmVyLnJhdygpIH07XG4gIH0gZWxzZSBpZiAodGFnID09PSAnYm1wc3RyJykge1xuICAgIHZhciByYXcgPSBidWZmZXIucmF3KCk7XG4gICAgaWYgKHJhdy5sZW5ndGggJSAyID09PSAxKVxuICAgICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRGVjb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6IGJtcHN0ciBsZW5ndGggbWlzbWF0Y2gnKTtcblxuICAgIHZhciBzdHIgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhdy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJhdy5yZWFkVUludDE2QkUoaSAqIDIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdudW1zdHInKSB7XG4gICAgdmFyIG51bXN0ciA9IGJ1ZmZlci5yYXcoKS50b1N0cmluZygnYXNjaWknKTtcbiAgICBpZiAoIXRoaXMuX2lzTnVtc3RyKG51bXN0cikpIHtcbiAgICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0RlY29kaW5nIG9mIHN0cmluZyB0eXBlOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ251bXN0ciB1bnN1cHBvcnRlZCBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICAgIHJldHVybiBudW1zdHI7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnb2N0c3RyJykge1xuICAgIHJldHVybiBidWZmZXIucmF3KCk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnb2JqRGVzYycpIHtcbiAgICByZXR1cm4gYnVmZmVyLnJhdygpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3ByaW50c3RyJykge1xuICAgIHZhciBwcmludHN0ciA9IGJ1ZmZlci5yYXcoKS50b1N0cmluZygnYXNjaWknKTtcbiAgICBpZiAoIXRoaXMuX2lzUHJpbnRzdHIocHJpbnRzdHIpKSB7XG4gICAgICByZXR1cm4gYnVmZmVyLmVycm9yKCdEZWNvZGluZyBvZiBzdHJpbmcgdHlwZTogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdwcmludHN0ciB1bnN1cHBvcnRlZCBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICAgIHJldHVybiBwcmludHN0cjtcbiAgfSBlbHNlIGlmICgvc3RyJC8udGVzdCh0YWcpKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5yYXcoKS50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0RlY29kaW5nIG9mIHN0cmluZyB0eXBlOiAnICsgdGFnICsgJyB1bnN1cHBvcnRlZCcpO1xuICB9XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlT2JqaWQgPSBmdW5jdGlvbiBkZWNvZGVPYmppZChidWZmZXIsIHZhbHVlcywgcmVsYXRpdmUpIHtcbiAgdmFyIHJlc3VsdDtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG4gIHZhciBpZGVudCA9IDA7XG4gIHdoaWxlICghYnVmZmVyLmlzRW1wdHkoKSkge1xuICAgIHZhciBzdWJpZGVudCA9IGJ1ZmZlci5yZWFkVUludDgoKTtcbiAgICBpZGVudCA8PD0gNztcbiAgICBpZGVudCB8PSBzdWJpZGVudCAmIDB4N2Y7XG4gICAgaWYgKChzdWJpZGVudCAmIDB4ODApID09PSAwKSB7XG4gICAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50KTtcbiAgICAgIGlkZW50ID0gMDtcbiAgICB9XG4gIH1cbiAgaWYgKHN1YmlkZW50ICYgMHg4MClcbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50KTtcblxuICB2YXIgZmlyc3QgPSAoaWRlbnRpZmllcnNbMF0gLyA0MCkgfCAwO1xuICB2YXIgc2Vjb25kID0gaWRlbnRpZmllcnNbMF0gJSA0MDtcblxuICBpZiAocmVsYXRpdmUpXG4gICAgcmVzdWx0ID0gaWRlbnRpZmllcnM7XG4gIGVsc2VcbiAgICByZXN1bHQgPSBbZmlyc3QsIHNlY29uZF0uY29uY2F0KGlkZW50aWZpZXJzLnNsaWNlKDEpKTtcblxuICBpZiAodmFsdWVzKSB7XG4gICAgdmFyIHRtcCA9IHZhbHVlc1tyZXN1bHQuam9pbignICcpXTtcbiAgICBpZiAodG1wID09PSB1bmRlZmluZWQpXG4gICAgICB0bXAgPSB2YWx1ZXNbcmVzdWx0LmpvaW4oJy4nKV07XG4gICAgaWYgKHRtcCAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmVzdWx0ID0gdG1wO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVUaW1lID0gZnVuY3Rpb24gZGVjb2RlVGltZShidWZmZXIsIHRhZykge1xuICB2YXIgc3RyID0gYnVmZmVyLnJhdygpLnRvU3RyaW5nKCk7XG4gIGlmICh0YWcgPT09ICdnZW50aW1lJykge1xuICAgIHZhciB5ZWFyID0gc3RyLnNsaWNlKDAsIDQpIHwgMDtcbiAgICB2YXIgbW9uID0gc3RyLnNsaWNlKDQsIDYpIHwgMDtcbiAgICB2YXIgZGF5ID0gc3RyLnNsaWNlKDYsIDgpIHwgMDtcbiAgICB2YXIgaG91ciA9IHN0ci5zbGljZSg4LCAxMCkgfCAwO1xuICAgIHZhciBtaW4gPSBzdHIuc2xpY2UoMTAsIDEyKSB8IDA7XG4gICAgdmFyIHNlYyA9IHN0ci5zbGljZSgxMiwgMTQpIHwgMDtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICd1dGN0aW1lJykge1xuICAgIHZhciB5ZWFyID0gc3RyLnNsaWNlKDAsIDIpIHwgMDtcbiAgICB2YXIgbW9uID0gc3RyLnNsaWNlKDIsIDQpIHwgMDtcbiAgICB2YXIgZGF5ID0gc3RyLnNsaWNlKDQsIDYpIHwgMDtcbiAgICB2YXIgaG91ciA9IHN0ci5zbGljZSg2LCA4KSB8IDA7XG4gICAgdmFyIG1pbiA9IHN0ci5zbGljZSg4LCAxMCkgfCAwO1xuICAgIHZhciBzZWMgPSBzdHIuc2xpY2UoMTAsIDEyKSB8IDA7XG4gICAgaWYgKHllYXIgPCA3MClcbiAgICAgIHllYXIgPSAyMDAwICsgeWVhcjtcbiAgICBlbHNlXG4gICAgICB5ZWFyID0gMTkwMCArIHllYXI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRGVjb2RpbmcgJyArIHRhZyArICcgdGltZSBpcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICB9XG5cbiAgcmV0dXJuIERhdGUuVVRDKHllYXIsIG1vbiAtIDEsIGRheSwgaG91ciwgbWluLCBzZWMsIDApO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZU51bGwgPSBmdW5jdGlvbiBkZWNvZGVOdWxsKGJ1ZmZlcikge1xuICByZXR1cm4gbnVsbDtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVCb29sID0gZnVuY3Rpb24gZGVjb2RlQm9vbChidWZmZXIpIHtcbiAgdmFyIHJlcyA9IGJ1ZmZlci5yZWFkVUludDgoKTtcbiAgaWYgKGJ1ZmZlci5pc0Vycm9yKHJlcykpXG4gICAgcmV0dXJuIHJlcztcbiAgZWxzZVxuICAgIHJldHVybiByZXMgIT09IDA7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlSW50ID0gZnVuY3Rpb24gZGVjb2RlSW50KGJ1ZmZlciwgdmFsdWVzKSB7XG4gIC8vIEJpZ2ludCwgcmV0dXJuIGFzIGl0IGlzIChhc3N1bWUgYmlnIGVuZGlhbilcbiAgdmFyIHJhdyA9IGJ1ZmZlci5yYXcoKTtcbiAgdmFyIHJlcyA9IG5ldyBiaWdudW0ocmF3KTtcblxuICBpZiAodmFsdWVzKVxuICAgIHJlcyA9IHZhbHVlc1tyZXMudG9TdHJpbmcoMTApXSB8fCByZXM7XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl91c2UgPSBmdW5jdGlvbiB1c2UoZW50aXR5LCBvYmopIHtcbiAgaWYgKHR5cGVvZiBlbnRpdHkgPT09ICdmdW5jdGlvbicpXG4gICAgZW50aXR5ID0gZW50aXR5KG9iaik7XG4gIHJldHVybiBlbnRpdHkuX2dldERlY29kZXIoJ2RlcicpLnRyZWU7XG59O1xuXG4vLyBVdGlsaXR5IG1ldGhvZHNcblxuZnVuY3Rpb24gZGVyRGVjb2RlVGFnKGJ1ZiwgZmFpbCkge1xuICB2YXIgdGFnID0gYnVmLnJlYWRVSW50OChmYWlsKTtcbiAgaWYgKGJ1Zi5pc0Vycm9yKHRhZykpXG4gICAgcmV0dXJuIHRhZztcblxuICB2YXIgY2xzID0gZGVyLnRhZ0NsYXNzW3RhZyA+PiA2XTtcbiAgdmFyIHByaW1pdGl2ZSA9ICh0YWcgJiAweDIwKSA9PT0gMDtcblxuICAvLyBNdWx0aS1vY3RldCB0YWcgLSBsb2FkXG4gIGlmICgodGFnICYgMHgxZikgPT09IDB4MWYpIHtcbiAgICB2YXIgb2N0ID0gdGFnO1xuICAgIHRhZyA9IDA7XG4gICAgd2hpbGUgKChvY3QgJiAweDgwKSA9PT0gMHg4MCkge1xuICAgICAgb2N0ID0gYnVmLnJlYWRVSW50OChmYWlsKTtcbiAgICAgIGlmIChidWYuaXNFcnJvcihvY3QpKVxuICAgICAgICByZXR1cm4gb2N0O1xuXG4gICAgICB0YWcgPDw9IDc7XG4gICAgICB0YWcgfD0gb2N0ICYgMHg3ZjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFnICY9IDB4MWY7XG4gIH1cbiAgdmFyIHRhZ1N0ciA9IGRlci50YWdbdGFnXTtcblxuICByZXR1cm4ge1xuICAgIGNsczogY2xzLFxuICAgIHByaW1pdGl2ZTogcHJpbWl0aXZlLFxuICAgIHRhZzogdGFnLFxuICAgIHRhZ1N0cjogdGFnU3RyXG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlckRlY29kZUxlbihidWYsIHByaW1pdGl2ZSwgZmFpbCkge1xuICB2YXIgbGVuID0gYnVmLnJlYWRVSW50OChmYWlsKTtcbiAgaWYgKGJ1Zi5pc0Vycm9yKGxlbikpXG4gICAgcmV0dXJuIGxlbjtcblxuICAvLyBJbmRlZmluaXRlIGZvcm1cbiAgaWYgKCFwcmltaXRpdmUgJiYgbGVuID09PSAweDgwKVxuICAgIHJldHVybiBudWxsO1xuXG4gIC8vIERlZmluaXRlIGZvcm1cbiAgaWYgKChsZW4gJiAweDgwKSA9PT0gMCkge1xuICAgIC8vIFNob3J0IGZvcm1cbiAgICByZXR1cm4gbGVuO1xuICB9XG5cbiAgLy8gTG9uZyBmb3JtXG4gIHZhciBudW0gPSBsZW4gJiAweDdmO1xuICBpZiAobnVtID4gNClcbiAgICByZXR1cm4gYnVmLmVycm9yKCdsZW5ndGggb2N0ZWN0IGlzIHRvbyBsb25nJyk7XG5cbiAgbGVuID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgIGxlbiA8PD0gODtcbiAgICB2YXIgaiA9IGJ1Zi5yZWFkVUludDgoZmFpbCk7XG4gICAgaWYgKGJ1Zi5pc0Vycm9yKGopKVxuICAgICAgcmV0dXJuIGo7XG4gICAgbGVuIHw9IGo7XG4gIH1cblxuICByZXR1cm4gbGVuO1xufVxuIiwidmFyIGRlY29kZXJzID0gZXhwb3J0cztcblxuZGVjb2RlcnMuZGVyID0gcmVxdWlyZSgnLi9kZXInKTtcbmRlY29kZXJzLnBlbSA9IHJlcXVpcmUoJy4vcGVtJyk7XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIERFUkRlY29kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuXG5mdW5jdGlvbiBQRU1EZWNvZGVyKGVudGl0eSkge1xuICBERVJEZWNvZGVyLmNhbGwodGhpcywgZW50aXR5KTtcbiAgdGhpcy5lbmMgPSAncGVtJztcbn07XG5pbmhlcml0cyhQRU1EZWNvZGVyLCBERVJEZWNvZGVyKTtcbm1vZHVsZS5leHBvcnRzID0gUEVNRGVjb2RlcjtcblxuUEVNRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGxpbmVzID0gZGF0YS50b1N0cmluZygpLnNwbGl0KC9bXFxyXFxuXSsvZyk7XG5cbiAgdmFyIGxhYmVsID0gb3B0aW9ucy5sYWJlbC50b1VwcGVyQ2FzZSgpO1xuXG4gIHZhciByZSA9IC9eLS0tLS0oQkVHSU58RU5EKSAoW14tXSspLS0tLS0kLztcbiAgdmFyIHN0YXJ0ID0gLTE7XG4gIHZhciBlbmQgPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtYXRjaCA9IGxpbmVzW2ldLm1hdGNoKHJlKTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwpXG4gICAgICBjb250aW51ZTtcblxuICAgIGlmIChtYXRjaFsyXSAhPT0gbGFiZWwpXG4gICAgICBjb250aW51ZTtcblxuICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgIGlmIChtYXRjaFsxXSAhPT0gJ0JFR0lOJylcbiAgICAgICAgYnJlYWs7XG4gICAgICBzdGFydCA9IGk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtYXRjaFsxXSAhPT0gJ0VORCcpXG4gICAgICAgIGJyZWFrO1xuICAgICAgZW5kID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCA9PT0gLTEpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdQRU0gc2VjdGlvbiBub3QgZm91bmQgZm9yOiAnICsgbGFiZWwpO1xuXG4gIHZhciBiYXNlNjQgPSBsaW5lcy5zbGljZShzdGFydCArIDEsIGVuZCkuam9pbignJyk7XG4gIC8vIFJlbW92ZSBleGNlc3NpdmUgc3ltYm9sc1xuICBiYXNlNjQucmVwbGFjZSgvW15hLXowLTlcXCtcXC89XSsvZ2ksICcnKTtcblxuICB2YXIgaW5wdXQgPSBuZXcgQnVmZmVyKGJhc2U2NCwgJ2Jhc2U2NCcpO1xuICByZXR1cm4gREVSRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlLmNhbGwodGhpcywgaW5wdXQsIG9wdGlvbnMpO1xufTtcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgYXNuMSA9IHJlcXVpcmUoJy4uLy4uL2FzbjEnKTtcbnZhciBiYXNlID0gYXNuMS5iYXNlO1xuXG4vLyBJbXBvcnQgREVSIGNvbnN0YW50c1xudmFyIGRlciA9IGFzbjEuY29uc3RhbnRzLmRlcjtcblxuZnVuY3Rpb24gREVSRW5jb2RlcihlbnRpdHkpIHtcbiAgdGhpcy5lbmMgPSAnZGVyJztcbiAgdGhpcy5uYW1lID0gZW50aXR5Lm5hbWU7XG4gIHRoaXMuZW50aXR5ID0gZW50aXR5O1xuXG4gIC8vIENvbnN0cnVjdCBiYXNlIHRyZWVcbiAgdGhpcy50cmVlID0gbmV3IERFUk5vZGUoKTtcbiAgdGhpcy50cmVlLl9pbml0KGVudGl0eS5ib2R5KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERFUkVuY29kZXI7XG5cbkRFUkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCByZXBvcnRlcikge1xuICByZXR1cm4gdGhpcy50cmVlLl9lbmNvZGUoZGF0YSwgcmVwb3J0ZXIpLmpvaW4oKTtcbn07XG5cbi8vIFRyZWUgbWV0aG9kc1xuXG5mdW5jdGlvbiBERVJOb2RlKHBhcmVudCkge1xuICBiYXNlLk5vZGUuY2FsbCh0aGlzLCAnZGVyJywgcGFyZW50KTtcbn1cbmluaGVyaXRzKERFUk5vZGUsIGJhc2UuTm9kZSk7XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVDb21wb3NpdGUgPSBmdW5jdGlvbiBlbmNvZGVDb21wb3NpdGUodGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltaXRpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCkge1xuICB2YXIgZW5jb2RlZFRhZyA9IGVuY29kZVRhZyh0YWcsIHByaW1pdGl2ZSwgY2xzLCB0aGlzLnJlcG9ydGVyKTtcblxuICAvLyBTaG9ydCBmb3JtXG4gIGlmIChjb250ZW50Lmxlbmd0aCA8IDB4ODApIHtcbiAgICB2YXIgaGVhZGVyID0gbmV3IEJ1ZmZlcigyKTtcbiAgICBoZWFkZXJbMF0gPSBlbmNvZGVkVGFnO1xuICAgIGhlYWRlclsxXSA9IGNvbnRlbnQubGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKFsgaGVhZGVyLCBjb250ZW50IF0pO1xuICB9XG5cbiAgLy8gTG9uZyBmb3JtXG4gIC8vIENvdW50IG9jdGV0cyByZXF1aXJlZCB0byBzdG9yZSBsZW5ndGhcbiAgdmFyIGxlbk9jdGV0cyA9IDE7XG4gIGZvciAodmFyIGkgPSBjb250ZW50Lmxlbmd0aDsgaSA+PSAweDEwMDsgaSA+Pj0gOClcbiAgICBsZW5PY3RldHMrKztcblxuICB2YXIgaGVhZGVyID0gbmV3IEJ1ZmZlcigxICsgMSArIGxlbk9jdGV0cyk7XG4gIGhlYWRlclswXSA9IGVuY29kZWRUYWc7XG4gIGhlYWRlclsxXSA9IDB4ODAgfCBsZW5PY3RldHM7XG5cbiAgZm9yICh2YXIgaSA9IDEgKyBsZW5PY3RldHMsIGogPSBjb250ZW50Lmxlbmd0aDsgaiA+IDA7IGktLSwgaiA+Pj0gOClcbiAgICBoZWFkZXJbaV0gPSBqICYgMHhmZjtcblxuICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihbIGhlYWRlciwgY29udGVudCBdKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVTdHIgPSBmdW5jdGlvbiBlbmNvZGVTdHIoc3RyLCB0YWcpIHtcbiAgaWYgKHRhZyA9PT0gJ2JpdHN0cicpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihbIHN0ci51bnVzZWQgfCAwLCBzdHIuZGF0YSBdKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdibXBzdHInKSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3RyLmxlbmd0aCAqIDIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShzdHIuY2hhckNvZGVBdChpKSwgaSAqIDIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihidWYpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ251bXN0cicpIHtcbiAgICBpZiAoIXRoaXMuX2lzTnVtc3RyKHN0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdFbmNvZGluZyBvZiBzdHJpbmcgdHlwZTogbnVtc3RyIHN1cHBvcnRzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29ubHkgZGlnaXRzIGFuZCBzcGFjZScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihzdHIpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3ByaW50c3RyJykge1xuICAgIGlmICghdGhpcy5faXNQcmludHN0cihzdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignRW5jb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6IHByaW50c3RyIHN1cHBvcnRzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29ubHkgbGF0aW4gdXBwZXIgYW5kIGxvd2VyIGNhc2UgbGV0dGVycywgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGlnaXRzLCBzcGFjZSwgYXBvc3Ryb3BoZSwgbGVmdCBhbmQgcmlndGggJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGFyZW50aGVzaXMsIHBsdXMgc2lnbiwgY29tbWEsIGh5cGhlbiwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZG90LCBzbGFzaCwgY29sb24sIGVxdWFsIHNpZ24sICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3F1ZXN0aW9uIG1hcmsnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoc3RyKTtcbiAgfSBlbHNlIGlmICgvc3RyJC8udGVzdCh0YWcpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoc3RyKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdvYmpEZXNjJykge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKHN0cik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ0VuY29kaW5nIG9mIHN0cmluZyB0eXBlOiAnICsgdGFnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHVuc3VwcG9ydGVkJyk7XG4gIH1cbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVPYmppZCA9IGZ1bmN0aW9uIGVuY29kZU9iamlkKGlkLCB2YWx1ZXMsIHJlbGF0aXZlKSB7XG4gIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCF2YWx1ZXMpXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignc3RyaW5nIG9iamlkIGdpdmVuLCBidXQgbm8gdmFsdWVzIG1hcCBmb3VuZCcpO1xuICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdvYmppZCBub3QgZm91bmQgaW4gdmFsdWVzIG1hcCcpO1xuICAgIGlkID0gdmFsdWVzW2lkXS5zcGxpdCgvW1xcc1xcLl0rL2cpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspXG4gICAgICBpZFtpXSB8PSAwO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaWQpKSB7XG4gICAgaWQgPSBpZC5zbGljZSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWQubGVuZ3RoOyBpKyspXG4gICAgICBpZFtpXSB8PSAwO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGlkKSkge1xuICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdvYmppZCgpIHNob3VsZCBiZSBlaXRoZXIgYXJyYXkgb3Igc3RyaW5nLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZ290OiAnICsgSlNPTi5zdHJpbmdpZnkoaWQpKTtcbiAgfVxuXG4gIGlmICghcmVsYXRpdmUpIHtcbiAgICBpZiAoaWRbMV0gPj0gNDApXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignU2Vjb25kIG9iamlkIGlkZW50aWZpZXIgT09CJyk7XG4gICAgaWQuc3BsaWNlKDAsIDIsIGlkWzBdICogNDAgKyBpZFsxXSk7XG4gIH1cblxuICAvLyBDb3VudCBudW1iZXIgb2Ygb2N0ZXRzXG4gIHZhciBzaXplID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpZGVudCA9IGlkW2ldO1xuICAgIGZvciAoc2l6ZSsrOyBpZGVudCA+PSAweDgwOyBpZGVudCA+Pj0gNylcbiAgICAgIHNpemUrKztcbiAgfVxuXG4gIHZhciBvYmppZCA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gIHZhciBvZmZzZXQgPSBvYmppZC5sZW5ndGggLSAxO1xuICBmb3IgKHZhciBpID0gaWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgaWRlbnQgPSBpZFtpXTtcbiAgICBvYmppZFtvZmZzZXQtLV0gPSBpZGVudCAmIDB4N2Y7XG4gICAgd2hpbGUgKChpZGVudCA+Pj0gNykgPiAwKVxuICAgICAgb2JqaWRbb2Zmc2V0LS1dID0gMHg4MCB8IChpZGVudCAmIDB4N2YpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIob2JqaWQpO1xufTtcblxuZnVuY3Rpb24gdHdvKG51bSkge1xuICBpZiAobnVtIDwgMTApXG4gICAgcmV0dXJuICcwJyArIG51bTtcbiAgZWxzZVxuICAgIHJldHVybiBudW07XG59XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVUaW1lID0gZnVuY3Rpb24gZW5jb2RlVGltZSh0aW1lLCB0YWcpIHtcbiAgdmFyIHN0cjtcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0aW1lKTtcblxuICBpZiAodGFnID09PSAnZ2VudGltZScpIHtcbiAgICBzdHIgPSBbXG4gICAgICB0d28oZGF0ZS5nZXRGdWxsWWVhcigpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ0RhdGUoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENIb3VycygpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ01pbnV0ZXMoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENTZWNvbmRzKCkpLFxuICAgICAgJ1onXG4gICAgXS5qb2luKCcnKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICd1dGN0aW1lJykge1xuICAgIHN0ciA9IFtcbiAgICAgIHR3byhkYXRlLmdldEZ1bGxZZWFyKCkgJSAxMDApLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDRGF0ZSgpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ0hvdXJzKCkpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTWludXRlcygpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ1NlY29uZHMoKSksXG4gICAgICAnWidcbiAgICBdLmpvaW4oJycpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ0VuY29kaW5nICcgKyB0YWcgKyAnIHRpbWUgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9lbmNvZGVTdHIoc3RyLCAnb2N0c3RyJyk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlTnVsbCA9IGZ1bmN0aW9uIGVuY29kZU51bGwoKSB7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKCcnKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVJbnQgPSBmdW5jdGlvbiBlbmNvZGVJbnQobnVtLCB2YWx1ZXMpIHtcbiAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCF2YWx1ZXMpXG4gICAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignU3RyaW5nIGludCBvciBlbnVtIGdpdmVuLCBidXQgbm8gdmFsdWVzIG1hcCcpO1xuICAgIGlmICghdmFsdWVzLmhhc093blByb3BlcnR5KG51bSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdWYWx1ZXMgbWFwIGRvZXNuXFwndCBjb250YWluOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG51bSkpO1xuICAgIH1cbiAgICBudW0gPSB2YWx1ZXNbbnVtXTtcbiAgfVxuXG4gIC8vIEJpZ251bSwgYXNzdW1lIGJpZyBlbmRpYW5cbiAgaWYgKHR5cGVvZiBudW0gIT09ICdudW1iZXInICYmICFCdWZmZXIuaXNCdWZmZXIobnVtKSkge1xuICAgIHZhciBudW1BcnJheSA9IG51bS50b0FycmF5KCk7XG4gICAgaWYgKCFudW0uc2lnbiAmJiBudW1BcnJheVswXSAmIDB4ODApIHtcbiAgICAgIG51bUFycmF5LnVuc2hpZnQoMCk7XG4gICAgfVxuICAgIG51bSA9IG5ldyBCdWZmZXIobnVtQXJyYXkpO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihudW0pKSB7XG4gICAgdmFyIHNpemUgPSBudW0ubGVuZ3RoO1xuICAgIGlmIChudW0ubGVuZ3RoID09PSAwKVxuICAgICAgc2l6ZSsrO1xuXG4gICAgdmFyIG91dCA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgbnVtLmNvcHkob3V0KTtcbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMClcbiAgICAgIG91dFswXSA9IDBcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihvdXQpO1xuICB9XG5cbiAgaWYgKG51bSA8IDB4ODApXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIobnVtKTtcblxuICBpZiAobnVtIDwgMHgxMDApXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoWzAsIG51bV0pO1xuXG4gIHZhciBzaXplID0gMTtcbiAgZm9yICh2YXIgaSA9IG51bTsgaSA+PSAweDEwMDsgaSA+Pj0gOClcbiAgICBzaXplKys7XG5cbiAgdmFyIG91dCA9IG5ldyBBcnJheShzaXplKTtcbiAgZm9yICh2YXIgaSA9IG91dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIG91dFtpXSA9IG51bSAmIDB4ZmY7XG4gICAgbnVtID4+PSA4O1xuICB9XG4gIGlmKG91dFswXSAmIDB4ODApIHtcbiAgICBvdXQudW5zaGlmdCgwKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKG5ldyBCdWZmZXIob3V0KSk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZW5jb2RlQm9vbCA9IGZ1bmN0aW9uIGVuY29kZUJvb2wodmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIodmFsdWUgPyAweGZmIDogMCk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fdXNlID0gZnVuY3Rpb24gdXNlKGVudGl0eSwgb2JqKSB7XG4gIGlmICh0eXBlb2YgZW50aXR5ID09PSAnZnVuY3Rpb24nKVxuICAgIGVudGl0eSA9IGVudGl0eShvYmopO1xuICByZXR1cm4gZW50aXR5Ll9nZXRFbmNvZGVyKCdkZXInKS50cmVlO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3NraXBEZWZhdWx0ID0gZnVuY3Rpb24gc2tpcERlZmF1bHQoZGF0YUJ1ZmZlciwgcmVwb3J0ZXIsIHBhcmVudCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIHZhciBpO1xuICBpZiAoc3RhdGVbJ2RlZmF1bHQnXSA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGRhdGEgPSBkYXRhQnVmZmVyLmpvaW4oKTtcbiAgaWYgKHN0YXRlLmRlZmF1bHRCdWZmZXIgPT09IHVuZGVmaW5lZClcbiAgICBzdGF0ZS5kZWZhdWx0QnVmZmVyID0gdGhpcy5fZW5jb2RlVmFsdWUoc3RhdGVbJ2RlZmF1bHQnXSwgcmVwb3J0ZXIsIHBhcmVudCkuam9pbigpO1xuXG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gc3RhdGUuZGVmYXVsdEJ1ZmZlci5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAoaT0wOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcbiAgICBpZiAoZGF0YVtpXSAhPT0gc3RhdGUuZGVmYXVsdEJ1ZmZlcltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIFV0aWxpdHkgbWV0aG9kc1xuXG5mdW5jdGlvbiBlbmNvZGVUYWcodGFnLCBwcmltaXRpdmUsIGNscywgcmVwb3J0ZXIpIHtcbiAgdmFyIHJlcztcblxuICBpZiAodGFnID09PSAnc2Vxb2YnKVxuICAgIHRhZyA9ICdzZXEnO1xuICBlbHNlIGlmICh0YWcgPT09ICdzZXRvZicpXG4gICAgdGFnID0gJ3NldCc7XG5cbiAgaWYgKGRlci50YWdCeU5hbWUuaGFzT3duUHJvcGVydHkodGFnKSlcbiAgICByZXMgPSBkZXIudGFnQnlOYW1lW3RhZ107XG4gIGVsc2UgaWYgKHR5cGVvZiB0YWcgPT09ICdudW1iZXInICYmICh0YWcgfCAwKSA9PT0gdGFnKVxuICAgIHJlcyA9IHRhZztcbiAgZWxzZVxuICAgIHJldHVybiByZXBvcnRlci5lcnJvcignVW5rbm93biB0YWc6ICcgKyB0YWcpO1xuXG4gIGlmIChyZXMgPj0gMHgxZilcbiAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ011bHRpLW9jdGV0IHRhZyBlbmNvZGluZyB1bnN1cHBvcnRlZCcpO1xuXG4gIGlmICghcHJpbWl0aXZlKVxuICAgIHJlcyB8PSAweDIwO1xuXG4gIHJlcyB8PSAoZGVyLnRhZ0NsYXNzQnlOYW1lW2NscyB8fCAndW5pdmVyc2FsJ10gPDwgNik7XG5cbiAgcmV0dXJuIHJlcztcbn1cbiIsInZhciBlbmNvZGVycyA9IGV4cG9ydHM7XG5cbmVuY29kZXJzLmRlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG5lbmNvZGVycy5wZW0gPSByZXF1aXJlKCcuL3BlbScpO1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxudmFyIERFUkVuY29kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuXG5mdW5jdGlvbiBQRU1FbmNvZGVyKGVudGl0eSkge1xuICBERVJFbmNvZGVyLmNhbGwodGhpcywgZW50aXR5KTtcbiAgdGhpcy5lbmMgPSAncGVtJztcbn07XG5pbmhlcml0cyhQRU1FbmNvZGVyLCBERVJFbmNvZGVyKTtcbm1vZHVsZS5leHBvcnRzID0gUEVNRW5jb2RlcjtcblxuUEVNRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGJ1ZiA9IERFUkVuY29kZXIucHJvdG90eXBlLmVuY29kZS5jYWxsKHRoaXMsIGRhdGEpO1xuXG4gIHZhciBwID0gYnVmLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgdmFyIG91dCA9IFsgJy0tLS0tQkVHSU4gJyArIG9wdGlvbnMubGFiZWwgKyAnLS0tLS0nIF07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkgKz0gNjQpXG4gICAgb3V0LnB1c2gocC5zbGljZShpLCBpICsgNjQpKTtcbiAgb3V0LnB1c2goJy0tLS0tRU5EICcgKyBvcHRpb25zLmxhYmVsICsgJy0tLS0tJyk7XG4gIHJldHVybiBvdXQuam9pbignXFxuJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVXRpbHNcbiAgZnVuY3Rpb24gYXNzZXJ0ICh2YWwsIG1zZykge1xuICAgIGlmICghdmFsKSB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIH1cblxuICAvLyBDb3VsZCB1c2UgYGluaGVyaXRzYCBtb2R1bGUsIGJ1dCBkb24ndCB3YW50IHRvIG1vdmUgZnJvbSBzaW5nbGUgZmlsZVxuICAvLyBhcmNoaXRlY3R1cmUgeWV0LlxuICBmdW5jdGlvbiBpbmhlcml0cyAoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgfVxuXG4gIC8vIEJOXG5cbiAgZnVuY3Rpb24gQk4gKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKEJOLmlzQk4obnVtYmVyKSkge1xuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB0aGlzLndvcmRzID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBSZWR1Y3Rpb24gY29udGV4dFxuICAgIHRoaXMucmVkID0gbnVsbDtcblxuICAgIGlmIChudW1iZXIgIT09IG51bGwpIHtcbiAgICAgIGlmIChiYXNlID09PSAnbGUnIHx8IGJhc2UgPT09ICdiZScpIHtcbiAgICAgICAgZW5kaWFuID0gYmFzZTtcbiAgICAgICAgYmFzZSA9IDEwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbml0KG51bWJlciB8fCAwLCBiYXNlIHx8IDEwLCBlbmRpYW4gfHwgJ2JlJyk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gQk47XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CTiA9IEJOO1xuICB9XG5cbiAgQk4uQk4gPSBCTjtcbiAgQk4ud29yZFNpemUgPSAyNjtcblxuICB2YXIgQnVmZmVyO1xuICB0cnkge1xuICAgIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG5cbiAgQk4uaXNCTiA9IGZ1bmN0aW9uIGlzQk4gKG51bSkge1xuICAgIGlmIChudW0gaW5zdGFuY2VvZiBCTikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bSAhPT0gbnVsbCAmJiB0eXBlb2YgbnVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgbnVtLmNvbnN0cnVjdG9yLndvcmRTaXplID09PSBCTi53b3JkU2l6ZSAmJiBBcnJheS5pc0FycmF5KG51bS53b3Jkcyk7XG4gIH07XG5cbiAgQk4ubWF4ID0gZnVuY3Rpb24gbWF4IChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPiAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ubWluID0gZnVuY3Rpb24gbWluIChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPCAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdCAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0QXJyYXkobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAnaGV4Jykge1xuICAgICAgYmFzZSA9IDE2O1xuICAgIH1cbiAgICBhc3NlcnQoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNik7XG5cbiAgICBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGlmIChudW1iZXJbMF0gPT09ICctJykge1xuICAgICAgc3RhcnQrKztcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gMTYpIHtcbiAgICAgIHRoaXMuX3BhcnNlSGV4KG51bWJlciwgc3RhcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wYXJzZUJhc2UobnVtYmVyLCBiYXNlLCBzdGFydCk7XG4gICAgfVxuXG4gICAgaWYgKG51bWJlclswXSA9PT0gJy0nKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLnN0cmlwKCk7XG5cbiAgICBpZiAoZW5kaWFuICE9PSAnbGUnKSByZXR1cm47XG5cbiAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0TnVtYmVyID0gZnVuY3Rpb24gX2luaXROdW1iZXIgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgbnVtYmVyID0gLW51bWJlcjtcbiAgICB9XG4gICAgaWYgKG51bWJlciA8IDB4NDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFsgbnVtYmVyICYgMHgzZmZmZmZmIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChudW1iZXIgPCAweDEwMDAwMDAwMDAwMDAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobnVtYmVyIDwgMHgyMDAwMDAwMDAwMDAwMCk7IC8vIDIgXiA1MyAodW5zYWZlKVxuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZixcbiAgICAgICAgMVxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMztcbiAgICB9XG5cbiAgICBpZiAoZW5kaWFuICE9PSAnbGUnKSByZXR1cm47XG5cbiAgICAvLyBSZXZlcnNlIHRoZSBieXRlc1xuICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXRBcnJheSA9IGZ1bmN0aW9uIF9pbml0QXJyYXkgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgLy8gUGVyaGFwcyBhIFVpbnQ4QXJyYXlcbiAgICBhc3NlcnQodHlwZW9mIG51bWJlci5sZW5ndGggPT09ICdudW1iZXInKTtcbiAgICBpZiAobnVtYmVyLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gWyAwIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbChudW1iZXIubGVuZ3RoIC8gMyk7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICB2YXIgaiwgdztcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMSwgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgLSAxXSA8PCA4KSB8IChudW1iZXJbaSAtIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG4gICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpICsgMV0gPDwgOCkgfCAobnVtYmVyW2kgKyAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUhleCAoc3RyLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cbiAgICAgIHIgPDw9IDQ7XG5cbiAgICAgIC8vICdhJyAtICdmJ1xuICAgICAgaWYgKGMgPj0gNDkgJiYgYyA8PSA1NCkge1xuICAgICAgICByIHw9IGMgLSA0OSArIDB4YTtcblxuICAgICAgLy8gJ0EnIC0gJ0YnXG4gICAgICB9IGVsc2UgaWYgKGMgPj0gMTcgJiYgYyA8PSAyMikge1xuICAgICAgICByIHw9IGMgLSAxNyArIDB4YTtcblxuICAgICAgLy8gJzAnIC0gJzknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByIHw9IGMgJiAweGY7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUhleCA9IGZ1bmN0aW9uIF9wYXJzZUhleCAobnVtYmVyLCBzdGFydCkge1xuICAgIC8vIENyZWF0ZSBwb3NzaWJseSBiaWdnZXIgYXJyYXkgdG8gZW5zdXJlIHRoYXQgaXQgZml0cyB0aGUgbnVtYmVyXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwoKG51bWJlci5sZW5ndGggLSBzdGFydCkgLyA2KTtcbiAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIH1cblxuICAgIHZhciBqLCB3O1xuICAgIC8vIFNjYW4gMjQtYml0IGNodW5rcyBhbmQgYWRkIHRoZW0gdG8gdGhlIG51bWJlclxuICAgIHZhciBvZmYgPSAwO1xuICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSA2LCBqID0gMDsgaSA+PSBzdGFydDsgaSAtPSA2KSB7XG4gICAgICB3ID0gcGFyc2VIZXgobnVtYmVyLCBpLCBpICsgNik7XG4gICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAvLyBOT1RFOiBgMHgzZmZmZmZgIGlzIGludGVudGlvbmFsIGhlcmUsIDI2Yml0cyBtYXggc2hpZnQgKyAyNGJpdCBoZXggbGltYlxuICAgICAgdGhpcy53b3Jkc1tqICsgMV0gfD0gdyA+Pj4gKDI2IC0gb2ZmKSAmIDB4M2ZmZmZmO1xuICAgICAgb2ZmICs9IDI0O1xuICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgKyA2ICE9PSBzdGFydCkge1xuICAgICAgdyA9IHBhcnNlSGV4KG51bWJlciwgc3RhcnQsIGkgKyA2KTtcbiAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgIHRoaXMud29yZHNbaiArIDFdIHw9IHcgPj4+ICgyNiAtIG9mZikgJiAweDNmZmZmZjtcbiAgICB9XG4gICAgdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlQmFzZSAoc3RyLCBzdGFydCwgZW5kLCBtdWwpIHtcbiAgICB2YXIgciA9IDA7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGVuZCk7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuICAgICAgciAqPSBtdWw7XG5cbiAgICAgIC8vICdhJ1xuICAgICAgaWYgKGMgPj0gNDkpIHtcbiAgICAgICAgciArPSBjIC0gNDkgKyAweGE7XG5cbiAgICAgIC8vICdBJ1xuICAgICAgfSBlbHNlIGlmIChjID49IDE3KSB7XG4gICAgICAgIHIgKz0gYyAtIDE3ICsgMHhhO1xuXG4gICAgICAvLyAnMCcgLSAnOSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgKz0gYztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3BhcnNlQmFzZSA9IGZ1bmN0aW9uIF9wYXJzZUJhc2UgKG51bWJlciwgYmFzZSwgc3RhcnQpIHtcbiAgICAvLyBJbml0aWFsaXplIGFzIHplcm9cbiAgICB0aGlzLndvcmRzID0gWyAwIF07XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuXG4gICAgLy8gRmluZCBsZW5ndGggb2YgbGltYiBpbiBiYXNlXG4gICAgZm9yICh2YXIgbGltYkxlbiA9IDAsIGxpbWJQb3cgPSAxOyBsaW1iUG93IDw9IDB4M2ZmZmZmZjsgbGltYlBvdyAqPSBiYXNlKSB7XG4gICAgICBsaW1iTGVuKys7XG4gICAgfVxuICAgIGxpbWJMZW4tLTtcbiAgICBsaW1iUG93ID0gKGxpbWJQb3cgLyBiYXNlKSB8IDA7XG5cbiAgICB2YXIgdG90YWwgPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XG4gICAgdmFyIG1vZCA9IHRvdGFsICUgbGltYkxlbjtcbiAgICB2YXIgZW5kID0gTWF0aC5taW4odG90YWwsIHRvdGFsIC0gbW9kKSArIHN0YXJ0O1xuXG4gICAgdmFyIHdvcmQgPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBsaW1iTGVuKSB7XG4gICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgaSArIGxpbWJMZW4sIGJhc2UpO1xuXG4gICAgICB0aGlzLmltdWxuKGxpbWJQb3cpO1xuICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb2QgIT09IDApIHtcbiAgICAgIHZhciBwb3cgPSAxO1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIG51bWJlci5sZW5ndGgsIGJhc2UpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbW9kOyBpKyspIHtcbiAgICAgICAgcG93ICo9IGJhc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW11bG4ocG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChkZXN0KSB7XG4gICAgZGVzdC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXN0LndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICB9XG4gICAgZGVzdC5sZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICBkZXN0Lm5lZ2F0aXZlID0gdGhpcy5uZWdhdGl2ZTtcbiAgICBkZXN0LnJlZCA9IHRoaXMucmVkO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgciA9IG5ldyBCTihudWxsKTtcbiAgICB0aGlzLmNvcHkocik7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9leHBhbmQgPSBmdW5jdGlvbiBfZXhwYW5kIChzaXplKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFJlbW92ZSBsZWFkaW5nIGAwYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3RyaXAgPSBmdW5jdGlvbiBzdHJpcCAoKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoID4gMSAmJiB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fbm9ybVNpZ24gPSBmdW5jdGlvbiBfbm9ybVNpZ24gKCkge1xuICAgIC8vIC0wID0gMFxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgICByZXR1cm4gKHRoaXMucmVkID8gJzxCTi1SOiAnIDogJzxCTjogJykgKyB0aGlzLnRvU3RyaW5nKDE2KSArICc+JztcbiAgfTtcblxuICAvKlxuXG4gIHZhciB6ZXJvcyA9IFtdO1xuICB2YXIgZ3JvdXBTaXplcyA9IFtdO1xuICB2YXIgZ3JvdXBCYXNlcyA9IFtdO1xuXG4gIHZhciBzID0gJyc7XG4gIHZhciBpID0gLTE7XG4gIHdoaWxlICgrK2kgPCBCTi53b3JkU2l6ZSkge1xuICAgIHplcm9zW2ldID0gcztcbiAgICBzICs9ICcwJztcbiAgfVxuICBncm91cFNpemVzWzBdID0gMDtcbiAgZ3JvdXBTaXplc1sxXSA9IDA7XG4gIGdyb3VwQmFzZXNbMF0gPSAwO1xuICBncm91cEJhc2VzWzFdID0gMDtcbiAgdmFyIGJhc2UgPSAyIC0gMTtcbiAgd2hpbGUgKCsrYmFzZSA8IDM2ICsgMSkge1xuICAgIHZhciBncm91cFNpemUgPSAwO1xuICAgIHZhciBncm91cEJhc2UgPSAxO1xuICAgIHdoaWxlIChncm91cEJhc2UgPCAoMSA8PCBCTi53b3JkU2l6ZSkgLyBiYXNlKSB7XG4gICAgICBncm91cEJhc2UgKj0gYmFzZTtcbiAgICAgIGdyb3VwU2l6ZSArPSAxO1xuICAgIH1cbiAgICBncm91cFNpemVzW2Jhc2VdID0gZ3JvdXBTaXplO1xuICAgIGdyb3VwQmFzZXNbYmFzZV0gPSBncm91cEJhc2U7XG4gIH1cblxuICAqL1xuXG4gIHZhciB6ZXJvcyA9IFtcbiAgICAnJyxcbiAgICAnMCcsXG4gICAgJzAwJyxcbiAgICAnMDAwJyxcbiAgICAnMDAwMCcsXG4gICAgJzAwMDAwJyxcbiAgICAnMDAwMDAwJyxcbiAgICAnMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAgXTtcblxuICB2YXIgZ3JvdXBTaXplcyA9IFtcbiAgICAwLCAwLFxuICAgIDI1LCAxNiwgMTIsIDExLCAxMCwgOSwgOCxcbiAgICA4LCA3LCA3LCA3LCA3LCA2LCA2LFxuICAgIDYsIDYsIDYsIDYsIDYsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNSxcbiAgICA1LCA1LCA1LCA1LCA1LCA1LCA1XG4gIF07XG5cbiAgdmFyIGdyb3VwQmFzZXMgPSBbXG4gICAgMCwgMCxcbiAgICAzMzU1NDQzMiwgNDMwNDY3MjEsIDE2Nzc3MjE2LCA0ODgyODEyNSwgNjA0NjYxNzYsIDQwMzUzNjA3LCAxNjc3NzIxNixcbiAgICA0MzA0NjcyMSwgMTAwMDAwMDAsIDE5NDg3MTcxLCAzNTgzMTgwOCwgNjI3NDg1MTcsIDc1Mjk1MzYsIDExMzkwNjI1LFxuICAgIDE2Nzc3MjE2LCAyNDEzNzU2OSwgMzQwMTIyMjQsIDQ3MDQ1ODgxLCA2NDAwMDAwMCwgNDA4NDEwMSwgNTE1MzYzMixcbiAgICA2NDM2MzQzLCA3OTYyNjI0LCA5NzY1NjI1LCAxMTg4MTM3NiwgMTQzNDg5MDcsIDE3MjEwMzY4LCAyMDUxMTE0OSxcbiAgICAyNDMwMDAwMCwgMjg2MjkxNTEsIDMzNTU0NDMyLCAzOTEzNTM5MywgNDU0MzU0MjQsIDUyNTIxODc1LCA2MDQ2NjE3NlxuICBdO1xuXG4gIEJOLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChiYXNlLCBwYWRkaW5nKSB7XG4gICAgYmFzZSA9IGJhc2UgfHwgMTA7XG4gICAgcGFkZGluZyA9IHBhZGRpbmcgfCAwIHx8IDE7XG5cbiAgICB2YXIgb3V0O1xuICAgIGlmIChiYXNlID09PSAxNiB8fCBiYXNlID09PSAnaGV4Jykge1xuICAgICAgb3V0ID0gJyc7XG4gICAgICB2YXIgb2ZmID0gMDtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldO1xuICAgICAgICB2YXIgd29yZCA9ICgoKHcgPDwgb2ZmKSB8IGNhcnJ5KSAmIDB4ZmZmZmZmKS50b1N0cmluZygxNik7XG4gICAgICAgIGNhcnJ5ID0gKHcgPj4+ICgyNCAtIG9mZikpICYgMHhmZmZmZmY7XG4gICAgICAgIGlmIChjYXJyeSAhPT0gMCB8fCBpICE9PSB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBvdXQgPSB6ZXJvc1s2IC0gd29yZC5sZW5ndGhdICsgd29yZCArIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgPSB3b3JkICsgb3V0O1xuICAgICAgICB9XG4gICAgICAgIG9mZiArPSAyO1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgIG91dCA9IGNhcnJ5LnRvU3RyaW5nKDE2KSArIG91dDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KSB7XG4gICAgICAvLyB2YXIgZ3JvdXBTaXplID0gTWF0aC5mbG9vcihCTi53b3JkU2l6ZSAqIE1hdGguTE4yIC8gTWF0aC5sb2coYmFzZSkpO1xuICAgICAgdmFyIGdyb3VwU2l6ZSA9IGdyb3VwU2l6ZXNbYmFzZV07XG4gICAgICAvLyB2YXIgZ3JvdXBCYXNlID0gTWF0aC5wb3coYmFzZSwgZ3JvdXBTaXplKTtcbiAgICAgIHZhciBncm91cEJhc2UgPSBncm91cEJhc2VzW2Jhc2VdO1xuICAgICAgb3V0ID0gJyc7XG4gICAgICB2YXIgYyA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGMubmVnYXRpdmUgPSAwO1xuICAgICAgd2hpbGUgKCFjLmlzWmVybygpKSB7XG4gICAgICAgIHZhciByID0gYy5tb2RuKGdyb3VwQmFzZSkudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgIGMgPSBjLmlkaXZuKGdyb3VwQmFzZSk7XG5cbiAgICAgICAgaWYgKCFjLmlzWmVybygpKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbZ3JvdXBTaXplIC0gci5sZW5ndGhdICsgciArIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgPSByICsgb3V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBhc3NlcnQoZmFsc2UsICdCYXNlIHNob3VsZCBiZSBiZXR3ZWVuIDIgYW5kIDM2Jyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIgKCkge1xuICAgIHZhciByZXQgPSB0aGlzLndvcmRzWzBdO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0ICs9IHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA9PT0gMyAmJiB0aGlzLndvcmRzWzJdID09PSAweDAxKSB7XG4gICAgICAvLyBOT1RFOiBhdCB0aGlzIHN0YWdlIGl0IGlzIGtub3duIHRoYXQgdGhlIHRvcCBiaXQgaXMgc2V0XG4gICAgICByZXQgKz0gMHgxMDAwMDAwMDAwMDAwMCArICh0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gMikge1xuICAgICAgYXNzZXJ0KGZhbHNlLCAnTnVtYmVyIGNhbiBvbmx5IHNhZmVseSBzdG9yZSB1cCB0byA1MyBiaXRzJyk7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgPyAtcmV0IDogcmV0O1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKDE2KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlciAoZW5kaWFuLCBsZW5ndGgpIHtcbiAgICBhc3NlcnQodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpO1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEJ1ZmZlciwgZW5kaWFuLCBsZW5ndGgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSAoZW5kaWFuLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShBcnJheSwgZW5kaWFuLCBsZW5ndGgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0FycmF5TGlrZSA9IGZ1bmN0aW9uIHRvQXJyYXlMaWtlIChBcnJheVR5cGUsIGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0aGlzLmJ5dGVMZW5ndGgoKTtcbiAgICB2YXIgcmVxTGVuZ3RoID0gbGVuZ3RoIHx8IE1hdGgubWF4KDEsIGJ5dGVMZW5ndGgpO1xuICAgIGFzc2VydChieXRlTGVuZ3RoIDw9IHJlcUxlbmd0aCwgJ2J5dGUgYXJyYXkgbG9uZ2VyIHRoYW4gZGVzaXJlZCBsZW5ndGgnKTtcbiAgICBhc3NlcnQocmVxTGVuZ3RoID4gMCwgJ1JlcXVlc3RlZCBhcnJheSBsZW5ndGggPD0gMCcpO1xuXG4gICAgdGhpcy5zdHJpcCgpO1xuICAgIHZhciBsaXR0bGVFbmRpYW4gPSBlbmRpYW4gPT09ICdsZSc7XG4gICAgdmFyIHJlcyA9IG5ldyBBcnJheVR5cGUocmVxTGVuZ3RoKTtcblxuICAgIHZhciBiLCBpO1xuICAgIHZhciBxID0gdGhpcy5jbG9uZSgpO1xuICAgIGlmICghbGl0dGxlRW5kaWFuKSB7XG4gICAgICAvLyBBc3N1bWUgYmlnLWVuZGlhblxuICAgICAgZm9yIChpID0gMDsgaSA8IHJlcUxlbmd0aCAtIGJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgICByZXNbaV0gPSAwO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyAhcS5pc1plcm8oKTsgaSsrKSB7XG4gICAgICAgIGIgPSBxLmFuZGxuKDB4ZmYpO1xuICAgICAgICBxLml1c2hybig4KTtcblxuICAgICAgICByZXNbcmVxTGVuZ3RoIC0gaSAtIDFdID0gYjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgIXEuaXNaZXJvKCk7IGkrKykge1xuICAgICAgICBiID0gcS5hbmRsbigweGZmKTtcbiAgICAgICAgcS5pdXNocm4oOCk7XG5cbiAgICAgICAgcmVzW2ldID0gYjtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IGkgPCByZXFMZW5ndGg7IGkrKykge1xuICAgICAgICByZXNbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgaWYgKE1hdGguY2x6MzIpIHtcbiAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcbiAgICAgIHJldHVybiAzMiAtIE1hdGguY2x6MzIodyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcbiAgICAgIHZhciB0ID0gdztcbiAgICAgIHZhciByID0gMDtcbiAgICAgIGlmICh0ID49IDB4MTAwMCkge1xuICAgICAgICByICs9IDEzO1xuICAgICAgICB0ID4+Pj0gMTM7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDQwKSB7XG4gICAgICAgIHIgKz0gNztcbiAgICAgICAgdCA+Pj49IDc7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDgpIHtcbiAgICAgICAgciArPSA0O1xuICAgICAgICB0ID4+Pj0gNDtcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4MDIpIHtcbiAgICAgICAgciArPSAyO1xuICAgICAgICB0ID4+Pj0gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByICsgdDtcbiAgICB9O1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl96ZXJvQml0cyA9IGZ1bmN0aW9uIF96ZXJvQml0cyAodykge1xuICAgIC8vIFNob3J0LWN1dFxuICAgIGlmICh3ID09PSAwKSByZXR1cm4gMjY7XG5cbiAgICB2YXIgdCA9IHc7XG4gICAgdmFyIHIgPSAwO1xuICAgIGlmICgodCAmIDB4MWZmZikgPT09IDApIHtcbiAgICAgIHIgKz0gMTM7XG4gICAgICB0ID4+Pj0gMTM7XG4gICAgfVxuICAgIGlmICgodCAmIDB4N2YpID09PSAwKSB7XG4gICAgICByICs9IDc7XG4gICAgICB0ID4+Pj0gNztcbiAgICB9XG4gICAgaWYgKCh0ICYgMHhmKSA9PT0gMCkge1xuICAgICAgciArPSA0O1xuICAgICAgdCA+Pj49IDQ7XG4gICAgfVxuICAgIGlmICgodCAmIDB4MykgPT09IDApIHtcbiAgICAgIHIgKz0gMjtcbiAgICAgIHQgPj4+PSAyO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDEpID09PSAwKSB7XG4gICAgICByKys7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIC8vIFJldHVybiBudW1iZXIgb2YgdXNlZCBiaXRzIGluIGEgQk5cbiAgQk4ucHJvdG90eXBlLmJpdExlbmd0aCA9IGZ1bmN0aW9uIGJpdExlbmd0aCAoKSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGhpID0gdGhpcy5fY291bnRCaXRzKHcpO1xuICAgIHJldHVybiAodGhpcy5sZW5ndGggLSAxKSAqIDI2ICsgaGk7XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9CaXRBcnJheSAobnVtKSB7XG4gICAgdmFyIHcgPSBuZXcgQXJyYXkobnVtLmJpdExlbmd0aCgpKTtcblxuICAgIGZvciAodmFyIGJpdCA9IDA7IGJpdCA8IHcubGVuZ3RoOyBiaXQrKykge1xuICAgICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuICAgICAgd1tiaXRdID0gKG51bS53b3Jkc1tvZmZdICYgKDEgPDwgd2JpdCkpID4+PiB3Yml0O1xuICAgIH1cblxuICAgIHJldHVybiB3O1xuICB9XG5cbiAgLy8gTnVtYmVyIG9mIHRyYWlsaW5nIHplcm8gYml0c1xuICBCTi5wcm90b3R5cGUuemVyb0JpdHMgPSBmdW5jdGlvbiB6ZXJvQml0cyAoKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiAwO1xuXG4gICAgdmFyIHIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGIgPSB0aGlzLl96ZXJvQml0cyh0aGlzLndvcmRzW2ldKTtcbiAgICAgIHIgKz0gYjtcbiAgICAgIGlmIChiICE9PSAyNikgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gYnl0ZUxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmJpdExlbmd0aCgpIC8gOCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvVHdvcyA9IGZ1bmN0aW9uIHRvVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWJzKCkuaW5vdG4od2lkdGgpLmlhZGRuKDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mcm9tVHdvcyA9IGZ1bmN0aW9uIGZyb21Ud29zICh3aWR0aCkge1xuICAgIGlmICh0aGlzLnRlc3RuKHdpZHRoIC0gMSkpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vdG4od2lkdGgpLmlhZGRuKDEpLmluZWcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbiBpc05lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDA7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYFxuICBCTi5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmluZWcoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW5lZyA9IGZ1bmN0aW9uIGluZWcgKCkge1xuICAgIGlmICghdGhpcy5pc1plcm8oKSkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdW9yID0gZnVuY3Rpb24gaXVvciAobnVtKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldIHwgbnVtLndvcmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlvciA9IGZ1bmN0aW9uIGlvciAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVvcihudW0pO1xuICB9O1xuXG4gIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pb3IodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVvciA9IGZ1bmN0aW9uIHVvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdW9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1b3IodGhpcyk7XG4gIH07XG5cbiAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdWFuZCA9IGZ1bmN0aW9uIGl1YW5kIChudW0pIHtcbiAgICAvLyBiID0gbWluLWxlbmd0aChudW0sIHRoaXMpXG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSAmIG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGIubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFuZCA9IGZ1bmN0aW9uIGlhbmQgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1YW5kKG51bSk7XG4gIH07XG5cbiAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFuZChudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYW5kKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51YW5kID0gZnVuY3Rpb24gdWFuZCAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdWFuZChudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdWFuZCh0aGlzKTtcbiAgfTtcblxuICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1eG9yID0gZnVuY3Rpb24gaXV4b3IgKG51bSkge1xuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYTtcbiAgICB2YXIgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldIF4gYi53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcyAhPT0gYSkge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5peG9yID0gZnVuY3Rpb24gaXhvciAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXV4b3IobnVtKTtcbiAgfTtcblxuICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5peG9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml4b3IodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnV4b3IgPSBmdW5jdGlvbiB1eG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1eG9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1eG9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIE5vdCBgYHRoaXNgYCB3aXRoIGBgd2lkdGhgYCBiaXR3aWR0aFxuICBCTi5wcm90b3R5cGUuaW5vdG4gPSBmdW5jdGlvbiBpbm90biAod2lkdGgpIHtcbiAgICBhc3NlcnQodHlwZW9mIHdpZHRoID09PSAnbnVtYmVyJyAmJiB3aWR0aCA+PSAwKTtcblxuICAgIHZhciBieXRlc05lZWRlZCA9IE1hdGguY2VpbCh3aWR0aCAvIDI2KSB8IDA7XG4gICAgdmFyIGJpdHNMZWZ0ID0gd2lkdGggJSAyNjtcblxuICAgIC8vIEV4dGVuZCB0aGUgYnVmZmVyIHdpdGggbGVhZGluZyB6ZXJvZXNcbiAgICB0aGlzLl9leHBhbmQoYnl0ZXNOZWVkZWQpO1xuXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgYnl0ZXNOZWVkZWQtLTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgY29tcGxldGUgd29yZHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzTmVlZGVkOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgdGhlIHJlc2lkdWVcbiAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAoMHgzZmZmZmZmID4+ICgyNiAtIGJpdHNMZWZ0KSk7XG4gICAgfVxuXG4gICAgLy8gQW5kIHJlbW92ZSBsZWFkaW5nIHplcm9lc1xuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm5vdG4gPSBmdW5jdGlvbiBub3RuICh3aWR0aCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5vdG4od2lkdGgpO1xuICB9O1xuXG4gIC8vIFNldCBgYml0YCBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnNldG4gPSBmdW5jdGlvbiBzZXRuIChiaXQsIHZhbCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG5cbiAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuICAgIHRoaXMuX2V4cGFuZChvZmYgKyAxKTtcblxuICAgIGlmICh2YWwpIHtcbiAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSB8ICgxIDw8IHdiaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gJiB+KDEgPDwgd2JpdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAobnVtKSB7XG4gICAgdmFyIHI7XG5cbiAgICAvLyBuZWdhdGl2ZSArIHBvc2l0aXZlXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuXG4gICAgLy8gcG9zaXRpdmUgKyBuZWdhdGl2ZVxuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG4gICAgfVxuXG4gICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICAgIHZhciBhLCBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAvLyBDb3B5IHRoZSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIH0gZWxzZSBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEFkZCBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAobnVtKSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwICYmIHRoaXMubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXMgPSB0aGlzLnN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSBpZiAobnVtLm5lZ2F0aXZlID09PSAwICYmIHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gbnVtLnN1Yih0aGlzKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGQobnVtKTtcblxuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYWRkKHRoaXMpO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAobnVtKSB7XG4gICAgLy8gdGhpcyAtICgtbnVtKSA9IHRoaXMgKyBudW1cbiAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgdmFyIHIgPSB0aGlzLmlhZGQobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcblxuICAgIC8vIC10aGlzIC0gbnVtID0gLSh0aGlzICsgbnVtKVxuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGQobnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gICAgfVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlXG4gICAgdmFyIGNtcCA9IHRoaXMuY21wKG51bSk7XG5cbiAgICAvLyBPcHRpbWl6YXRpb24gLSB6ZXJvaWZ5XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGEgPiBiXG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGNtcCA+IDApIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSAtIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICAvLyBDb3B5IHJlc3Qgb2YgdGhlIHdvcmRzXG4gICAgaWYgKGNhcnJ5ID09PSAwICYmIGkgPCBhLmxlbmd0aCAmJiBhICE9PSB0aGlzKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSk7XG5cbiAgICBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWIobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBzbWFsbE11bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG4gICAgdmFyIGxlbiA9IChzZWxmLmxlbmd0aCArIG51bS5sZW5ndGgpIHwgMDtcbiAgICBvdXQubGVuZ3RoID0gbGVuO1xuICAgIGxlbiA9IChsZW4gLSAxKSB8IDA7XG5cbiAgICAvLyBQZWVsIG9uZSBpdGVyYXRpb24gKGNvbXBpbGVyIGNhbid0IGRvIGl0LCBiZWNhdXNlIG9mIGNvZGUgY29tcGxleGl0eSlcbiAgICB2YXIgYSA9IHNlbGYud29yZHNbMF0gfCAwO1xuICAgIHZhciBiID0gbnVtLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICB2YXIgY2FycnkgPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgIG91dC53b3Jkc1swXSA9IGxvO1xuXG4gICAgZm9yICh2YXIgayA9IDE7IGsgPCBsZW47IGsrKykge1xuICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICAgIHZhciBuY2FycnkgPSBjYXJyeSA+Pj4gMjY7XG4gICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgICB2YXIgaSA9IChrIC0gaikgfCAwO1xuICAgICAgICBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICAgIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICByID0gYSAqIGIgKyByd29yZDtcbiAgICAgICAgbmNhcnJ5ICs9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAgIHJ3b3JkID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIH1cbiAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkIHwgMDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5IHwgMDtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeSB8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5sZW5ndGgtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG4gIH1cblxuICAvLyBUT0RPKGluZHV0bnkpOiBpdCBtYXkgYmUgcmVhc29uYWJsZSB0byBvbWl0IGl0IGZvciB1c2VycyB3aG8gZG9uJ3QgbmVlZFxuICAvLyB0byB3b3JrIHdpdGggMjU2LWJpdCBudW1iZXJzLCBvdGhlcndpc2UgaXQgZ2l2ZXMgMjAlIGltcHJvdmVtZW50IGZvciAyNTYtYml0XG4gIC8vIG11bHRpcGxpY2F0aW9uIChsaWtlIGVsbGlwdGljIHNlY3AyNTZrMSkuXG4gIHZhciBjb21iMTBNdWxUbyA9IGZ1bmN0aW9uIGNvbWIxME11bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIHZhciBhID0gc2VsZi53b3JkcztcbiAgICB2YXIgYiA9IG51bS53b3JkcztcbiAgICB2YXIgbyA9IG91dC53b3JkcztcbiAgICB2YXIgYyA9IDA7XG4gICAgdmFyIGxvO1xuICAgIHZhciBtaWQ7XG4gICAgdmFyIGhpO1xuICAgIHZhciBhMCA9IGFbMF0gfCAwO1xuICAgIHZhciBhbDAgPSBhMCAmIDB4MWZmZjtcbiAgICB2YXIgYWgwID0gYTAgPj4+IDEzO1xuICAgIHZhciBhMSA9IGFbMV0gfCAwO1xuICAgIHZhciBhbDEgPSBhMSAmIDB4MWZmZjtcbiAgICB2YXIgYWgxID0gYTEgPj4+IDEzO1xuICAgIHZhciBhMiA9IGFbMl0gfCAwO1xuICAgIHZhciBhbDIgPSBhMiAmIDB4MWZmZjtcbiAgICB2YXIgYWgyID0gYTIgPj4+IDEzO1xuICAgIHZhciBhMyA9IGFbM10gfCAwO1xuICAgIHZhciBhbDMgPSBhMyAmIDB4MWZmZjtcbiAgICB2YXIgYWgzID0gYTMgPj4+IDEzO1xuICAgIHZhciBhNCA9IGFbNF0gfCAwO1xuICAgIHZhciBhbDQgPSBhNCAmIDB4MWZmZjtcbiAgICB2YXIgYWg0ID0gYTQgPj4+IDEzO1xuICAgIHZhciBhNSA9IGFbNV0gfCAwO1xuICAgIHZhciBhbDUgPSBhNSAmIDB4MWZmZjtcbiAgICB2YXIgYWg1ID0gYTUgPj4+IDEzO1xuICAgIHZhciBhNiA9IGFbNl0gfCAwO1xuICAgIHZhciBhbDYgPSBhNiAmIDB4MWZmZjtcbiAgICB2YXIgYWg2ID0gYTYgPj4+IDEzO1xuICAgIHZhciBhNyA9IGFbN10gfCAwO1xuICAgIHZhciBhbDcgPSBhNyAmIDB4MWZmZjtcbiAgICB2YXIgYWg3ID0gYTcgPj4+IDEzO1xuICAgIHZhciBhOCA9IGFbOF0gfCAwO1xuICAgIHZhciBhbDggPSBhOCAmIDB4MWZmZjtcbiAgICB2YXIgYWg4ID0gYTggPj4+IDEzO1xuICAgIHZhciBhOSA9IGFbOV0gfCAwO1xuICAgIHZhciBhbDkgPSBhOSAmIDB4MWZmZjtcbiAgICB2YXIgYWg5ID0gYTkgPj4+IDEzO1xuICAgIHZhciBiMCA9IGJbMF0gfCAwO1xuICAgIHZhciBibDAgPSBiMCAmIDB4MWZmZjtcbiAgICB2YXIgYmgwID0gYjAgPj4+IDEzO1xuICAgIHZhciBiMSA9IGJbMV0gfCAwO1xuICAgIHZhciBibDEgPSBiMSAmIDB4MWZmZjtcbiAgICB2YXIgYmgxID0gYjEgPj4+IDEzO1xuICAgIHZhciBiMiA9IGJbMl0gfCAwO1xuICAgIHZhciBibDIgPSBiMiAmIDB4MWZmZjtcbiAgICB2YXIgYmgyID0gYjIgPj4+IDEzO1xuICAgIHZhciBiMyA9IGJbM10gfCAwO1xuICAgIHZhciBibDMgPSBiMyAmIDB4MWZmZjtcbiAgICB2YXIgYmgzID0gYjMgPj4+IDEzO1xuICAgIHZhciBiNCA9IGJbNF0gfCAwO1xuICAgIHZhciBibDQgPSBiNCAmIDB4MWZmZjtcbiAgICB2YXIgYmg0ID0gYjQgPj4+IDEzO1xuICAgIHZhciBiNSA9IGJbNV0gfCAwO1xuICAgIHZhciBibDUgPSBiNSAmIDB4MWZmZjtcbiAgICB2YXIgYmg1ID0gYjUgPj4+IDEzO1xuICAgIHZhciBiNiA9IGJbNl0gfCAwO1xuICAgIHZhciBibDYgPSBiNiAmIDB4MWZmZjtcbiAgICB2YXIgYmg2ID0gYjYgPj4+IDEzO1xuICAgIHZhciBiNyA9IGJbN10gfCAwO1xuICAgIHZhciBibDcgPSBiNyAmIDB4MWZmZjtcbiAgICB2YXIgYmg3ID0gYjcgPj4+IDEzO1xuICAgIHZhciBiOCA9IGJbOF0gfCAwO1xuICAgIHZhciBibDggPSBiOCAmIDB4MWZmZjtcbiAgICB2YXIgYmg4ID0gYjggPj4+IDEzO1xuICAgIHZhciBiOSA9IGJbOV0gfCAwO1xuICAgIHZhciBibDkgPSBiOSAmIDB4MWZmZjtcbiAgICB2YXIgYmg5ID0gYjkgPj4+IDEzO1xuXG4gICAgb3V0Lm5lZ2F0aXZlID0gc2VsZi5uZWdhdGl2ZSBeIG51bS5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0gMTk7XG4gICAgLyogayA9IDAgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDAsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMCwgYmgwKTtcbiAgICB2YXIgdzAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcwID4+PiAyNikpIHwgMDtcbiAgICB3MCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDEsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDEpKSB8IDA7XG4gICAgdmFyIHcxID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MSA+Pj4gMjYpKSB8IDA7XG4gICAgdzEgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwyLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDIsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDIsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMikpIHwgMDtcbiAgICB2YXIgdzIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcyID4+PiAyNikpIHwgMDtcbiAgICB3MiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDMgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDMsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMywgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMykpIHwgMDtcbiAgICB2YXIgdzMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHczID4+PiAyNikpIHwgMDtcbiAgICB3MyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDQgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDQsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNCwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDQpKSB8IDA7XG4gICAgdmFyIHc0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NCA+Pj4gMjYpKSB8IDA7XG4gICAgdzQgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw1LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDUsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDUsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNSkpIHwgMDtcbiAgICB2YXIgdzUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc1ID4+PiAyNikpIHwgMDtcbiAgICB3NSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDYgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDYsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNiwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNikpIHwgMDtcbiAgICB2YXIgdzYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc2ID4+PiAyNikpIHwgMDtcbiAgICB3NiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDcgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDcsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNywgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNywgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDcpKSB8IDA7XG4gICAgdmFyIHc3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NyA+Pj4gMjYpKSB8IDA7XG4gICAgdzcgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw4LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDgsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDgsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOCkpIHwgMDtcbiAgICB2YXIgdzggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc4ID4+PiAyNikpIHwgMDtcbiAgICB3OCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDkgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzkgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc5ID4+PiAyNikpIHwgMDtcbiAgICB3OSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDEpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMSk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTAgPj4+IDI2KSkgfCAwO1xuICAgIHcxMCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDExICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDIpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMSA+Pj4gMjYpKSB8IDA7XG4gICAgdzExICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTIgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMyk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgzKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwzKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgzKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTIgPj4+IDI2KSkgfCAwO1xuICAgIHcxMiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDQpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEzID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTMgPj4+IDI2KSkgfCAwO1xuICAgIHcxMyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDUpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNSk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNCA+Pj4gMjYpKSB8IDA7XG4gICAgdzE0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTUgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNik7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg2KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw2KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg2KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTUgPj4+IDI2KSkgfCAwO1xuICAgIHcxNSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDcpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTYgPj4+IDI2KSkgfCAwO1xuICAgIHcxNiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDgpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNyA+Pj4gMjYpKSB8IDA7XG4gICAgdzE3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTggKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg5KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw5KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg5KTtcbiAgICB2YXIgdzE4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTggPj4+IDI2KSkgfCAwO1xuICAgIHcxOCAmPSAweDNmZmZmZmY7XG4gICAgb1swXSA9IHcwO1xuICAgIG9bMV0gPSB3MTtcbiAgICBvWzJdID0gdzI7XG4gICAgb1szXSA9IHczO1xuICAgIG9bNF0gPSB3NDtcbiAgICBvWzVdID0gdzU7XG4gICAgb1s2XSA9IHc2O1xuICAgIG9bN10gPSB3NztcbiAgICBvWzhdID0gdzg7XG4gICAgb1s5XSA9IHc5O1xuICAgIG9bMTBdID0gdzEwO1xuICAgIG9bMTFdID0gdzExO1xuICAgIG9bMTJdID0gdzEyO1xuICAgIG9bMTNdID0gdzEzO1xuICAgIG9bMTRdID0gdzE0O1xuICAgIG9bMTVdID0gdzE1O1xuICAgIG9bMTZdID0gdzE2O1xuICAgIG9bMTddID0gdzE3O1xuICAgIG9bMThdID0gdzE4O1xuICAgIGlmIChjICE9PSAwKSB7XG4gICAgICBvWzE5XSA9IGM7XG4gICAgICBvdXQubGVuZ3RoKys7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH07XG5cbiAgLy8gUG9seWZpbGwgY29tYlxuICBpZiAoIU1hdGguaW11bCkge1xuICAgIGNvbWIxME11bFRvID0gc21hbGxNdWxUbztcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpZ011bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aDtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgdmFyIGhuY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3V0Lmxlbmd0aCAtIDE7IGsrKykge1xuICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICAgIHZhciBuY2FycnkgPSBobmNhcnJ5O1xuICAgICAgaG5jYXJyeSA9IDA7XG4gICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgICB2YXIgaSA9IGsgLSBqO1xuICAgICAgICB2YXIgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICB2YXIgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICAgIHZhciByID0gYSAqIGI7XG5cbiAgICAgICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArICgociAvIDB4NDAwMDAwMCkgfCAwKSkgfCAwO1xuICAgICAgICBsbyA9IChsbyArIHJ3b3JkKSB8IDA7XG4gICAgICAgIHJ3b3JkID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAobG8gPj4+IDI2KSkgfCAwO1xuXG4gICAgICAgIGhuY2FycnkgKz0gbmNhcnJ5ID4+PiAyNjtcbiAgICAgICAgbmNhcnJ5ICY9IDB4M2ZmZmZmZjtcbiAgICAgIH1cbiAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkO1xuICAgICAgY2FycnkgPSBuY2Fycnk7XG4gICAgICBuY2FycnkgPSBobmNhcnJ5O1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuICB9XG5cbiAgZnVuY3Rpb24ganVtYm9NdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICB2YXIgZmZ0bSA9IG5ldyBGRlRNKCk7XG4gICAgcmV0dXJuIGZmdG0ubXVscChzZWxmLCBudW0sIG91dCk7XG4gIH1cblxuICBCTi5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbiBtdWxUbyAobnVtLCBvdXQpIHtcbiAgICB2YXIgcmVzO1xuICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aCArIG51bS5sZW5ndGg7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxMCAmJiBudW0ubGVuZ3RoID09PSAxMCkge1xuICAgICAgcmVzID0gY29tYjEwTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSBpZiAobGVuIDwgNjMpIHtcbiAgICAgIHJlcyA9IHNtYWxsTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSBpZiAobGVuIDwgMTAyNCkge1xuICAgICAgcmVzID0gYmlnTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvb2xleS1UdWtleSBhbGdvcml0aG0gZm9yIEZGVFxuICAvLyBzbGlnaHRseSByZXZpc2l0ZWQgdG8gcmVseSBvbiBsb29waW5nIGluc3RlYWQgb2YgcmVjdXJzaW9uXG5cbiAgZnVuY3Rpb24gRkZUTSAoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuXG4gIEZGVE0ucHJvdG90eXBlLm1ha2VSQlQgPSBmdW5jdGlvbiBtYWtlUkJUIChOKSB7XG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGwgPSBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyhOKSAtIDE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHRbaV0gPSB0aGlzLnJldkJpbihpLCBsLCBOKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGJpbmFyeS1yZXZlcnNlZCByZXByZXNlbnRhdGlvbiBvZiBgeGBcbiAgRkZUTS5wcm90b3R5cGUucmV2QmluID0gZnVuY3Rpb24gcmV2QmluICh4LCBsLCBOKSB7XG4gICAgaWYgKHggPT09IDAgfHwgeCA9PT0gTiAtIDEpIHJldHVybiB4O1xuXG4gICAgdmFyIHJiID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgcmIgfD0gKHggJiAxKSA8PCAobCAtIGkgLSAxKTtcbiAgICAgIHggPj49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJiO1xuICB9O1xuXG4gIC8vIFBlcmZvcm1zIFwidHdlZWRsaW5nXCIgcGhhc2UsIHRoZXJlZm9yZSAnZW11bGF0aW5nJ1xuICAvLyBiZWhhdmlvdXIgb2YgdGhlIHJlY3Vyc2l2ZSBhbGdvcml0aG1cbiAgRkZUTS5wcm90b3R5cGUucGVybXV0ZSA9IGZ1bmN0aW9uIHBlcm11dGUgKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgcnR3c1tpXSA9IHJ3c1tyYnRbaV1dO1xuICAgICAgaXR3c1tpXSA9IGl3c1tyYnRbaV1dO1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0gKHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOLCByYnQpIHtcbiAgICB0aGlzLnBlcm11dGUocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTik7XG5cbiAgICBmb3IgKHZhciBzID0gMTsgcyA8IE47IHMgPDw9IDEpIHtcbiAgICAgIHZhciBsID0gcyA8PCAxO1xuXG4gICAgICB2YXIgcnR3ZGYgPSBNYXRoLmNvcygyICogTWF0aC5QSSAvIGwpO1xuICAgICAgdmFyIGl0d2RmID0gTWF0aC5zaW4oMiAqIE1hdGguUEkgLyBsKTtcblxuICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBOOyBwICs9IGwpIHtcbiAgICAgICAgdmFyIHJ0d2RmXyA9IHJ0d2RmO1xuICAgICAgICB2YXIgaXR3ZGZfID0gaXR3ZGY7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzOyBqKyspIHtcbiAgICAgICAgICB2YXIgcmUgPSBydHdzW3AgKyBqXTtcbiAgICAgICAgICB2YXIgaWUgPSBpdHdzW3AgKyBqXTtcblxuICAgICAgICAgIHZhciBybyA9IHJ0d3NbcCArIGogKyBzXTtcbiAgICAgICAgICB2YXIgaW8gPSBpdHdzW3AgKyBqICsgc107XG5cbiAgICAgICAgICB2YXIgcnggPSBydHdkZl8gKiBybyAtIGl0d2RmXyAqIGlvO1xuXG4gICAgICAgICAgaW8gPSBydHdkZl8gKiBpbyArIGl0d2RmXyAqIHJvO1xuICAgICAgICAgIHJvID0gcng7XG5cbiAgICAgICAgICBydHdzW3AgKyBqXSA9IHJlICsgcm87XG4gICAgICAgICAgaXR3c1twICsgal0gPSBpZSArIGlvO1xuXG4gICAgICAgICAgcnR3c1twICsgaiArIHNdID0gcmUgLSBybztcbiAgICAgICAgICBpdHdzW3AgKyBqICsgc10gPSBpZSAtIGlvO1xuXG4gICAgICAgICAgLyoganNoaW50IG1heGRlcHRoIDogZmFsc2UgKi9cbiAgICAgICAgICBpZiAoaiAhPT0gbCkge1xuICAgICAgICAgICAgcnggPSBydHdkZiAqIHJ0d2RmXyAtIGl0d2RmICogaXR3ZGZfO1xuXG4gICAgICAgICAgICBpdHdkZl8gPSBydHdkZiAqIGl0d2RmXyArIGl0d2RmICogcnR3ZGZfO1xuICAgICAgICAgICAgcnR3ZGZfID0gcng7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmd1ZXNzTGVuMTNiID0gZnVuY3Rpb24gZ3Vlc3NMZW4xM2IgKG4sIG0pIHtcbiAgICB2YXIgTiA9IE1hdGgubWF4KG0sIG4pIHwgMTtcbiAgICB2YXIgb2RkID0gTiAmIDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoTiA9IE4gLyAyIHwgMDsgTjsgTiA9IE4gPj4+IDEpIHtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gMSA8PCBpICsgMSArIG9kZDtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5jb25qdWdhdGUgPSBmdW5jdGlvbiBjb25qdWdhdGUgKHJ3cywgaXdzLCBOKSB7XG4gICAgaWYgKE4gPD0gMSkgcmV0dXJuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgICB2YXIgdCA9IHJ3c1tpXTtcblxuICAgICAgcndzW2ldID0gcndzW04gLSBpIC0gMV07XG4gICAgICByd3NbTiAtIGkgLSAxXSA9IHQ7XG5cbiAgICAgIHQgPSBpd3NbaV07XG5cbiAgICAgIGl3c1tpXSA9IC1pd3NbTiAtIGkgLSAxXTtcbiAgICAgIGl3c1tOIC0gaSAtIDFdID0gLXQ7XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLm5vcm1hbGl6ZTEzYiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZTEzYiAod3MsIE4pIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHcgPSBNYXRoLnJvdW5kKHdzWzIgKiBpICsgMV0gLyBOKSAqIDB4MjAwMCArXG4gICAgICAgIE1hdGgucm91bmQod3NbMiAqIGldIC8gTikgK1xuICAgICAgICBjYXJyeTtcblxuICAgICAgd3NbaV0gPSB3ICYgMHgzZmZmZmZmO1xuXG4gICAgICBpZiAodyA8IDB4NDAwMDAwMCkge1xuICAgICAgICBjYXJyeSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXJyeSA9IHcgLyAweDQwMDAwMDAgfCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3cztcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5jb252ZXJ0MTNiID0gZnVuY3Rpb24gY29udmVydDEzYiAod3MsIGxlbiwgcndzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYXJyeSA9IGNhcnJ5ICsgKHdzW2ldIHwgMCk7XG5cbiAgICAgIHJ3c1syICogaV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgICByd3NbMiAqIGkgKyAxXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICB9XG5cbiAgICAvLyBQYWQgd2l0aCB6ZXJvZXNcbiAgICBmb3IgKGkgPSAyICogbGVuOyBpIDwgTjsgKytpKSB7XG4gICAgICByd3NbaV0gPSAwO1xuICAgIH1cblxuICAgIGFzc2VydChjYXJyeSA9PT0gMCk7XG4gICAgYXNzZXJ0KChjYXJyeSAmIH4weDFmZmYpID09PSAwKTtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5zdHViID0gZnVuY3Rpb24gc3R1YiAoTikge1xuICAgIHZhciBwaCA9IG5ldyBBcnJheShOKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgcGhbaV0gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBwaDtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5tdWxwID0gZnVuY3Rpb24gbXVscCAoeCwgeSwgb3V0KSB7XG4gICAgdmFyIE4gPSAyICogdGhpcy5ndWVzc0xlbjEzYih4Lmxlbmd0aCwgeS5sZW5ndGgpO1xuXG4gICAgdmFyIHJidCA9IHRoaXMubWFrZVJCVChOKTtcblxuICAgIHZhciBfID0gdGhpcy5zdHViKE4pO1xuXG4gICAgdmFyIHJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgcndzdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgaXdzdCA9IG5ldyBBcnJheShOKTtcblxuICAgIHZhciBucndzID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBucndzdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbml3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgcm13cyA9IG91dC53b3JkcztcbiAgICBybXdzLmxlbmd0aCA9IE47XG5cbiAgICB0aGlzLmNvbnZlcnQxM2IoeC53b3JkcywgeC5sZW5ndGgsIHJ3cywgTik7XG4gICAgdGhpcy5jb252ZXJ0MTNiKHkud29yZHMsIHkubGVuZ3RoLCBucndzLCBOKTtcblxuICAgIHRoaXMudHJhbnNmb3JtKHJ3cywgXywgcndzdCwgaXdzdCwgTiwgcmJ0KTtcbiAgICB0aGlzLnRyYW5zZm9ybShucndzLCBfLCBucndzdCwgbml3c3QsIE4sIHJidCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdmFyIHJ4ID0gcndzdFtpXSAqIG5yd3N0W2ldIC0gaXdzdFtpXSAqIG5pd3N0W2ldO1xuICAgICAgaXdzdFtpXSA9IHJ3c3RbaV0gKiBuaXdzdFtpXSArIGl3c3RbaV0gKiBucndzdFtpXTtcbiAgICAgIHJ3c3RbaV0gPSByeDtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmp1Z2F0ZShyd3N0LCBpd3N0LCBOKTtcbiAgICB0aGlzLnRyYW5zZm9ybShyd3N0LCBpd3N0LCBybXdzLCBfLCBOLCByYnQpO1xuICAgIHRoaXMuY29uanVnYXRlKHJtd3MsIF8sIE4pO1xuICAgIHRoaXMubm9ybWFsaXplMTNiKHJtd3MsIE4pO1xuXG4gICAgb3V0Lm5lZ2F0aXZlID0geC5uZWdhdGl2ZSBeIHkubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IHgubGVuZ3RoICsgeS5sZW5ndGg7XG4gICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuICB9O1xuXG4gIC8vIE11bHRpcGx5IGB0aGlzYCBieSBgbnVtYFxuICBCTi5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChudW0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzLm11bFRvKG51bSwgb3V0KTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBlbXBsb3lpbmcgRkZUXG4gIEJOLnByb3RvdHlwZS5tdWxmID0gZnVuY3Rpb24gbXVsZiAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgTXVsdGlwbGljYXRpb25cbiAgQk4ucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLm11bFRvKG51bSwgdGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmltdWxuID0gZnVuY3Rpb24gaW11bG4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG5cbiAgICAvLyBDYXJyeVxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKiBudW07XG4gICAgICB2YXIgbG8gPSAodyAmIDB4M2ZmZmZmZikgKyAoY2FycnkgJiAweDNmZmZmZmYpO1xuICAgICAgY2FycnkgPj49IDI2O1xuICAgICAgY2FycnkgKz0gKHcgLyAweDQwMDAwMDApIHwgMDtcbiAgICAgIC8vIE5PVEU6IGxvIGlzIDI3Yml0IG1heGltdW1cbiAgICAgIGNhcnJ5ICs9IGxvID4+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm11bG4gPSBmdW5jdGlvbiBtdWxuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltdWxuKG51bSk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKCkge1xuICAgIHJldHVybiB0aGlzLm11bCh0aGlzKTtcbiAgfTtcblxuICAvLyBgdGhpc2AgKiBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbXVsKHRoaXMuY2xvbmUoKSk7XG4gIH07XG5cbiAgLy8gTWF0aC5wb3coYHRoaXNgLCBgbnVtYClcbiAgQk4ucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAobnVtKSB7XG4gICAgdmFyIHcgPSB0b0JpdEFycmF5KG51bSk7XG4gICAgaWYgKHcubGVuZ3RoID09PSAwKSByZXR1cm4gbmV3IEJOKDEpO1xuXG4gICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lc1xuICAgIHZhciByZXMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdy5sZW5ndGg7IGkrKywgcmVzID0gcmVzLnNxcigpKSB7XG4gICAgICBpZiAod1tpXSAhPT0gMCkgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKCsraSA8IHcubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBxID0gcmVzLnNxcigpOyBpIDwgdy5sZW5ndGg7IGkrKywgcSA9IHEuc3FyKCkpIHtcbiAgICAgICAgaWYgKHdbaV0gPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHJlcy5tdWwocSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0IGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXNobG4gPSBmdW5jdGlvbiBpdXNobG4gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG4gICAgdmFyIGNhcnJ5TWFzayA9ICgweDNmZmZmZmYgPj4+ICgyNiAtIHIpKSA8PCAoMjYgLSByKTtcbiAgICB2YXIgaTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmV3Q2FycnkgPSB0aGlzLndvcmRzW2ldICYgY2FycnlNYXNrO1xuICAgICAgICB2YXIgYyA9ICgodGhpcy53b3Jkc1tpXSB8IDApIC0gbmV3Q2FycnkpIDw8IHI7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjIHwgY2Fycnk7XG4gICAgICAgIGNhcnJ5ID0gbmV3Q2FycnkgPj4+ICgyNiAtIHIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FycnkpIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzICE9PSAwKSB7XG4gICAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIHNdID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggKz0gcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc2hsbiA9IGZ1bmN0aW9uIGlzaGxuIChiaXRzKSB7XG4gICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodCBpbi1wbGFjZVxuICAvLyBOT1RFOiBgaGludGAgaXMgYSBsb3dlc3QgYml0IGJlZm9yZSB0cmFpbGluZyB6ZXJvZXNcbiAgLy8gTk9URTogaWYgYGV4dGVuZGVkYCBpcyBwcmVzZW50IC0gaXQgd2lsbCBiZSBmaWxsZWQgd2l0aCBkZXN0cm95ZWQgYml0c1xuICBCTi5wcm90b3R5cGUuaXVzaHJuID0gZnVuY3Rpb24gaXVzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgaDtcbiAgICBpZiAoaGludCkge1xuICAgICAgaCA9IChoaW50IC0gKGhpbnQgJSAyNikpIC8gMjY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSAwO1xuICAgIH1cblxuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gTWF0aC5taW4oKGJpdHMgLSByKSAvIDI2LCB0aGlzLmxlbmd0aCk7XG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG4gICAgdmFyIG1hc2tlZFdvcmRzID0gZXh0ZW5kZWQ7XG5cbiAgICBoIC09IHM7XG4gICAgaCA9IE1hdGgubWF4KDAsIGgpO1xuXG4gICAgLy8gRXh0ZW5kZWQgbW9kZSwgY29weSBtYXNrZWQgcGFydFxuICAgIGlmIChtYXNrZWRXb3Jkcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgbWFza2VkV29yZHMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgICAgfVxuICAgICAgbWFza2VkV29yZHMubGVuZ3RoID0gcztcbiAgICB9XG5cbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgLy8gTm8tb3AsIHdlIHNob3VsZCBub3QgbW92ZSBhbnl0aGluZyBhdCBhbGxcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gcykge1xuICAgICAgdGhpcy5sZW5ndGggLT0gcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2kgKyBzXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiAoY2FycnkgIT09IDAgfHwgaSA+PSBoKTsgaS0tKSB7XG4gICAgICB2YXIgd29yZCA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IChjYXJyeSA8PCAoMjYgLSByKSkgfCAod29yZCA+Pj4gcik7XG4gICAgICBjYXJyeSA9IHdvcmQgJiBtYXNrO1xuICAgIH1cblxuICAgIC8vIFB1c2ggY2FycmllZCBiaXRzIGFzIGEgbWFza1xuICAgIGlmIChtYXNrZWRXb3JkcyAmJiBjYXJyeSAhPT0gMCkge1xuICAgICAgbWFza2VkV29yZHMud29yZHNbbWFza2VkV29yZHMubGVuZ3RoKytdID0gY2Fycnk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc2hybiA9IGZ1bmN0aW9uIGlzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNocm4oYml0cywgaGludCwgZXh0ZW5kZWQpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LWxlZnRcbiAgQk4ucHJvdG90eXBlLnNobG4gPSBmdW5jdGlvbiBzaGxuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hsbihiaXRzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXNobG4gPSBmdW5jdGlvbiB1c2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaGxuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LXJpZ2h0XG4gIEJOLnByb3RvdHlwZS5zaHJuID0gZnVuY3Rpb24gc2hybiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNocm4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaHJuID0gZnVuY3Rpb24gdXNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hybihiaXRzKTtcbiAgfTtcblxuICAvLyBUZXN0IGlmIG4gYml0IGlzIHNldFxuICBCTi5wcm90b3R5cGUudGVzdG4gPSBmdW5jdGlvbiB0ZXN0biAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBiaXQgYW5kIHJldHVyblxuICAgIHZhciB3ID0gdGhpcy53b3Jkc1tzXTtcblxuICAgIHJldHVybiAhISh3ICYgcSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyIChpbi1wbGFjZSlcbiAgQk4ucHJvdG90eXBlLmltYXNrbiA9IGZ1bmN0aW9uIGltYXNrbiAoYml0cykge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcblxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAnaW1hc2tuIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZSBudW1iZXJzJyk7XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHMrKztcbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1pbihzLCB0aGlzLmxlbmd0aCk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gJj0gbWFzaztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlclxuICBCTi5wcm90b3R5cGUubWFza24gPSBmdW5jdGlvbiBtYXNrbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW1hc2tuKGJpdHMpO1xuICB9O1xuXG4gIC8vIEFkZCBwbGFpbiBudW1iZXIgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5pYWRkbiA9IGZ1bmN0aW9uIGlhZGRuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pc3VibigtbnVtKTtcblxuICAgIC8vIFBvc3NpYmxlIHNpZ24gY2hhbmdlXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiAodGhpcy53b3Jkc1swXSB8IDApIDwgbnVtKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gPSBudW0gLSAodGhpcy53b3Jkc1swXSB8IDApO1xuICAgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pc3VibihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aG91dCBjaGVja3NcbiAgICByZXR1cm4gdGhpcy5faWFkZG4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lhZGRuID0gZnVuY3Rpb24gX2lhZGRuIChudW0pIHtcbiAgICB0aGlzLndvcmRzWzBdICs9IG51bTtcblxuICAgIC8vIENhcnJ5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldID49IDB4NDAwMDAwMDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldIC09IDB4NDAwMDAwMDtcbiAgICAgIGlmIChpID09PSB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0rKztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSArIDEpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgcGxhaW4gbnVtYmVyIGBudW1gIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5pc3VibiA9IGZ1bmN0aW9uIGlzdWJuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pYWRkbigtbnVtKTtcblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaWFkZG4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy53b3Jkc1swXSAtPSBudW07XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA8IDApIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAtdGhpcy53b3Jkc1swXTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDYXJyeVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldIDwgMDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gKz0gMHg0MDAwMDAwO1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSAtPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmFkZG4gPSBmdW5jdGlvbiBhZGRuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnN1Ym4gPSBmdW5jdGlvbiBzdWJuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWJuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlhYnMgPSBmdW5jdGlvbiBpYWJzICgpIHtcbiAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiBhYnMgKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFicygpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faXNobG5zdWJtdWwgPSBmdW5jdGlvbiBfaXNobG5zdWJtdWwgKG51bSwgbXVsLCBzaGlmdCkge1xuICAgIHZhciBsZW4gPSBudW0ubGVuZ3RoICsgc2hpZnQ7XG4gICAgdmFyIGk7XG5cbiAgICB0aGlzLl9leHBhbmQobGVuKTtcblxuICAgIHZhciB3O1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgdmFyIHJpZ2h0ID0gKG51bS53b3Jkc1tpXSB8IDApICogbXVsO1xuICAgICAgdyAtPSByaWdodCAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gKHcgPj4gMjYpIC0gKChyaWdodCAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIGZvciAoOyBpIDwgdGhpcy5sZW5ndGggLSBzaGlmdDsgaSsrKSB7XG4gICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIGlmIChjYXJyeSA9PT0gMCkgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblxuICAgIC8vIFN1YnRyYWN0aW9uIG92ZXJmbG93XG4gICAgYXNzZXJ0KGNhcnJ5ID09PSAtMSk7XG4gICAgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3ID0gLSh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl93b3JkRGl2ID0gZnVuY3Rpb24gX3dvcmREaXYgKG51bSwgbW9kZSkge1xuICAgIHZhciBzaGlmdCA9IHRoaXMubGVuZ3RoIC0gbnVtLmxlbmd0aDtcblxuICAgIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICAgIHZhciBiID0gbnVtO1xuXG4gICAgLy8gTm9ybWFsaXplXG4gICAgdmFyIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG4gICAgdmFyIGJoaUJpdHMgPSB0aGlzLl9jb3VudEJpdHMoYmhpKTtcbiAgICBzaGlmdCA9IDI2IC0gYmhpQml0cztcbiAgICBpZiAoc2hpZnQgIT09IDApIHtcbiAgICAgIGIgPSBiLnVzaGxuKHNoaWZ0KTtcbiAgICAgIGEuaXVzaGxuKHNoaWZ0KTtcbiAgICAgIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBxdW90aWVudFxuICAgIHZhciBtID0gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgICB2YXIgcTtcblxuICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgcSA9IG5ldyBCTihudWxsKTtcbiAgICAgIHEubGVuZ3RoID0gbSArIDE7XG4gICAgICBxLndvcmRzID0gbmV3IEFycmF5KHEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcS5sZW5ndGg7IGkrKykge1xuICAgICAgICBxLndvcmRzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGlmZiA9IGEuY2xvbmUoKS5faXNobG5zdWJtdWwoYiwgMSwgbSk7XG4gICAgaWYgKGRpZmYubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIGEgPSBkaWZmO1xuICAgICAgaWYgKHEpIHtcbiAgICAgICAgcS53b3Jkc1ttXSA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IG0gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgdmFyIHFqID0gKGEud29yZHNbYi5sZW5ndGggKyBqXSB8IDApICogMHg0MDAwMDAwICtcbiAgICAgICAgKGEud29yZHNbYi5sZW5ndGggKyBqIC0gMV0gfCAwKTtcblxuICAgICAgLy8gTk9URTogKHFqIC8gYmhpKSBpcyAoMHgzZmZmZmZmICogMHg0MDAwMDAwICsgMHgzZmZmZmZmKSAvIDB4MjAwMDAwMCBtYXhcbiAgICAgIC8vICgweDdmZmZmZmYpXG4gICAgICBxaiA9IE1hdGgubWluKChxaiAvIGJoaSkgfCAwLCAweDNmZmZmZmYpO1xuXG4gICAgICBhLl9pc2hsbnN1Ym11bChiLCBxaiwgaik7XG4gICAgICB3aGlsZSAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBxai0tO1xuICAgICAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgYS5faXNobG5zdWJtdWwoYiwgMSwgaik7XG4gICAgICAgIGlmICghYS5pc1plcm8oKSkge1xuICAgICAgICAgIGEubmVnYXRpdmUgXj0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHEpIHtcbiAgICAgICAgcS53b3Jkc1tqXSA9IHFqO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocSkge1xuICAgICAgcS5zdHJpcCgpO1xuICAgIH1cbiAgICBhLnN0cmlwKCk7XG5cbiAgICAvLyBEZW5vcm1hbGl6ZVxuICAgIGlmIChtb2RlICE9PSAnZGl2JyAmJiBzaGlmdCAhPT0gMCkge1xuICAgICAgYS5pdXNocm4oc2hpZnQpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkaXY6IHEgfHwgbnVsbCxcbiAgICAgIG1vZDogYVxuICAgIH07XG4gIH07XG5cbiAgLy8gTk9URTogMSkgYG1vZGVgIGNhbiBiZSBzZXQgdG8gYG1vZGAgdG8gcmVxdWVzdCBtb2Qgb25seSxcbiAgLy8gICAgICAgdG8gYGRpdmAgdG8gcmVxdWVzdCBkaXYgb25seSwgb3IgYmUgYWJzZW50IHRvXG4gIC8vICAgICAgIHJlcXVlc3QgYm90aCBkaXYgJiBtb2RcbiAgLy8gICAgICAgMikgYHBvc2l0aXZlYCBpcyB0cnVlIGlmIHVuc2lnbmVkIG1vZCBpcyByZXF1ZXN0ZWRcbiAgQk4ucHJvdG90eXBlLmRpdm1vZCA9IGZ1bmN0aW9uIGRpdm1vZCAobnVtLCBtb2RlLCBwb3NpdGl2ZSkge1xuICAgIGFzc2VydCghbnVtLmlzWmVybygpKTtcblxuICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IG5ldyBCTigwKSxcbiAgICAgICAgbW9kOiBuZXcgQk4oMClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGRpdiwgbW9kLCByZXM7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0sIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBtb2QuaWFkZChudW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiByZXMubW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICgodGhpcy5uZWdhdGl2ZSAmIG51bS5uZWdhdGl2ZSkgIT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlzdWIobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHJlcy5kaXYsXG4gICAgICAgIG1vZDogbW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmUgYXQgdGhpcyBwb2ludFxuXG4gICAgLy8gU3RyaXAgYm90aCBudW1iZXJzIHRvIGFwcHJveGltYXRlIHNoaWZ0IHZhbHVlXG4gICAgaWYgKG51bS5sZW5ndGggPiB0aGlzLmxlbmd0aCB8fCB0aGlzLmNtcChudW0pIDwgMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogdGhpc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBWZXJ5IHNob3J0IHJlZHVjdGlvblxuICAgIGlmIChudW0ubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAobW9kZSA9PT0gJ2RpdicpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICAgIG1vZDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSA9PT0gJ21vZCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXY6IG51bGwsXG4gICAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RuKG51bS53b3Jkc1swXSkpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd29yZERpdihudW0sIG1vZGUpO1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgIC8gYG51bWBcbiAgQk4ucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIGRpdiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ2RpdicsIGZhbHNlKS5kaXY7XG4gIH07XG5cbiAgLy8gRmluZCBgdGhpc2AgJSBgbnVtYFxuICBCTi5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gbW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgZmFsc2UpLm1vZDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudW1vZCA9IGZ1bmN0aW9uIHVtb2QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCB0cnVlKS5tb2Q7XG4gIH07XG5cbiAgLy8gRmluZCBSb3VuZChgdGhpc2AgLyBgbnVtYClcbiAgQk4ucHJvdG90eXBlLmRpdlJvdW5kID0gZnVuY3Rpb24gZGl2Um91bmQgKG51bSkge1xuICAgIHZhciBkbSA9IHRoaXMuZGl2bW9kKG51bSk7XG5cbiAgICAvLyBGYXN0IGNhc2UgLSBleGFjdCBkaXZpc2lvblxuICAgIGlmIChkbS5tb2QuaXNaZXJvKCkpIHJldHVybiBkbS5kaXY7XG5cbiAgICB2YXIgbW9kID0gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0ubW9kLmlzdWIobnVtKSA6IGRtLm1vZDtcblxuICAgIHZhciBoYWxmID0gbnVtLnVzaHJuKDEpO1xuICAgIHZhciByMiA9IG51bS5hbmRsbigxKTtcbiAgICB2YXIgY21wID0gbW9kLmNtcChoYWxmKTtcblxuICAgIC8vIFJvdW5kIGRvd25cbiAgICBpZiAoY21wIDwgMCB8fCByMiA9PT0gMSAmJiBjbXAgPT09IDApIHJldHVybiBkbS5kaXY7XG5cbiAgICAvLyBSb3VuZCB1cFxuICAgIHJldHVybiBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5kaXYuaXN1Ym4oMSkgOiBkbS5kaXYuaWFkZG4oMSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm1vZG4gPSBmdW5jdGlvbiBtb2RuIChudW0pIHtcbiAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG4gICAgdmFyIHAgPSAoMSA8PCAyNikgJSBudW07XG5cbiAgICB2YXIgYWNjID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgYWNjID0gKHAgKiBhY2MgKyAodGhpcy53b3Jkc1tpXSB8IDApKSAlIG51bTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9O1xuXG4gIC8vIEluLXBsYWNlIGRpdmlzaW9uIGJ5IG51bWJlclxuICBCTi5wcm90b3R5cGUuaWRpdm4gPSBmdW5jdGlvbiBpZGl2biAobnVtKSB7XG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICsgY2FycnkgKiAweDQwMDAwMDA7XG4gICAgICB0aGlzLndvcmRzW2ldID0gKHcgLyBudW0pIHwgMDtcbiAgICAgIGNhcnJ5ID0gdyAlIG51bTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5kaXZuID0gZnVuY3Rpb24gZGl2biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pZGl2bihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lZ2NkID0gZnVuY3Rpb24gZWdjZCAocCkge1xuICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcbiAgICBhc3NlcnQoIXAuaXNaZXJvKCkpO1xuXG4gICAgdmFyIHggPSB0aGlzO1xuICAgIHZhciB5ID0gcC5jbG9uZSgpO1xuXG4gICAgaWYgKHgubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHggPSB4LnVtb2QocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4LmNsb25lKCk7XG4gICAgfVxuXG4gICAgLy8gQSAqIHggKyBCICogeSA9IHhcbiAgICB2YXIgQSA9IG5ldyBCTigxKTtcbiAgICB2YXIgQiA9IG5ldyBCTigwKTtcblxuICAgIC8vIEMgKiB4ICsgRCAqIHkgPSB5XG4gICAgdmFyIEMgPSBuZXcgQk4oMCk7XG4gICAgdmFyIEQgPSBuZXcgQk4oMSk7XG5cbiAgICB2YXIgZyA9IDA7XG5cbiAgICB3aGlsZSAoeC5pc0V2ZW4oKSAmJiB5LmlzRXZlbigpKSB7XG4gICAgICB4Lml1c2hybigxKTtcbiAgICAgIHkuaXVzaHJuKDEpO1xuICAgICAgKytnO1xuICAgIH1cblxuICAgIHZhciB5cCA9IHkuY2xvbmUoKTtcbiAgICB2YXIgeHAgPSB4LmNsb25lKCk7XG5cbiAgICB3aGlsZSAoIXguaXNaZXJvKCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbSA9IDE7ICh4LndvcmRzWzBdICYgaW0pID09PSAwICYmIGkgPCAyNjsgKytpLCBpbSA8PD0gMSk7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgeC5pdXNocm4oaSk7XG4gICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKEEuaXNPZGQoKSB8fCBCLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIEEuaWFkZCh5cCk7XG4gICAgICAgICAgICBCLmlzdWIoeHApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEEuaXVzaHJuKDEpO1xuICAgICAgICAgIEIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7ICh5LndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG4gICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgeS5pdXNocm4oaik7XG4gICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKEMuaXNPZGQoKSB8fCBELmlzT2RkKCkpIHtcbiAgICAgICAgICAgIEMuaWFkZCh5cCk7XG4gICAgICAgICAgICBELmlzdWIoeHApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIEMuaXVzaHJuKDEpO1xuICAgICAgICAgIEQuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh4LmNtcCh5KSA+PSAwKSB7XG4gICAgICAgIHguaXN1Yih5KTtcbiAgICAgICAgQS5pc3ViKEMpO1xuICAgICAgICBCLmlzdWIoRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5LmlzdWIoeCk7XG4gICAgICAgIEMuaXN1YihBKTtcbiAgICAgICAgRC5pc3ViKEIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhOiBDLFxuICAgICAgYjogRCxcbiAgICAgIGdjZDogeS5pdXNobG4oZylcbiAgICB9O1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgcmVkdWNlZCBpbmNhcm5hdGlvbiBvZiB0aGUgYmluYXJ5IEVFQVxuICAvLyBhYm92ZSwgZGVzaWduYXRlZCB0byBpbnZlcnQgbWVtYmVycyBvZiB0aGVcbiAgLy8gX3ByaW1lXyBmaWVsZHMgRihwKSBhdCBhIG1heGltYWwgc3BlZWRcbiAgQk4ucHJvdG90eXBlLl9pbnZtcCA9IGZ1bmN0aW9uIF9pbnZtcCAocCkge1xuICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcbiAgICBhc3NlcnQoIXAuaXNaZXJvKCkpO1xuXG4gICAgdmFyIGEgPSB0aGlzO1xuICAgIHZhciBiID0gcC5jbG9uZSgpO1xuXG4gICAgaWYgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGEgPSBhLnVtb2QocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBhLmNsb25lKCk7XG4gICAgfVxuXG4gICAgdmFyIHgxID0gbmV3IEJOKDEpO1xuICAgIHZhciB4MiA9IG5ldyBCTigwKTtcblxuICAgIHZhciBkZWx0YSA9IGIuY2xvbmUoKTtcblxuICAgIHdoaWxlIChhLmNtcG4oMSkgPiAwICYmIGIuY21wbigxKSA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbSA9IDE7IChhLndvcmRzWzBdICYgaW0pID09PSAwICYmIGkgPCAyNjsgKytpLCBpbSA8PD0gMSk7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgYS5pdXNocm4oaSk7XG4gICAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKHgxLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIHgxLmlhZGQoZGVsdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgxLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoYi53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIGIuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmICh4Mi5pc09kZCgpKSB7XG4gICAgICAgICAgICB4Mi5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4Mi5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGEuY21wKGIpID49IDApIHtcbiAgICAgICAgYS5pc3ViKGIpO1xuICAgICAgICB4MS5pc3ViKHgyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGIuaXN1YihhKTtcbiAgICAgICAgeDIuaXN1Yih4MSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlcztcbiAgICBpZiAoYS5jbXBuKDEpID09PSAwKSB7XG4gICAgICByZXMgPSB4MTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0geDI7XG4gICAgfVxuXG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQocCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ2NkID0gZnVuY3Rpb24gZ2NkIChudW0pIHtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIG51bS5hYnMoKTtcbiAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gdGhpcy5hYnMoKTtcblxuICAgIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICAgIHZhciBiID0gbnVtLmNsb25lKCk7XG4gICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgYi5uZWdhdGl2ZSA9IDA7XG5cbiAgICAvLyBSZW1vdmUgY29tbW9uIGZhY3RvciBvZiB0d29cbiAgICBmb3IgKHZhciBzaGlmdCA9IDA7IGEuaXNFdmVuKCkgJiYgYi5pc0V2ZW4oKTsgc2hpZnQrKykge1xuICAgICAgYS5pdXNocm4oMSk7XG4gICAgICBiLml1c2hybigxKTtcbiAgICB9XG5cbiAgICBkbyB7XG4gICAgICB3aGlsZSAoYS5pc0V2ZW4oKSkge1xuICAgICAgICBhLml1c2hybigxKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChiLmlzRXZlbigpKSB7XG4gICAgICAgIGIuaXVzaHJuKDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgciA9IGEuY21wKGIpO1xuICAgICAgaWYgKHIgPCAwKSB7XG4gICAgICAgIC8vIFN3YXAgYGFgIGFuZCBgYmAgdG8gbWFrZSBgYWAgYWx3YXlzIGJpZ2dlciB0aGFuIGBiYFxuICAgICAgICB2YXIgdCA9IGE7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBiID0gdDtcbiAgICAgIH0gZWxzZSBpZiAociA9PT0gMCB8fCBiLmNtcG4oMSkgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGEuaXN1YihiKTtcbiAgICB9IHdoaWxlICh0cnVlKTtcblxuICAgIHJldHVybiBiLml1c2hsbihzaGlmdCk7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IG51bWJlciBpbiB0aGUgZmllbGQgRihudW0pXG4gIEJOLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZWdjZChudW0pLmEudW1vZChudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4gKCkge1xuICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMTtcbiAgfTtcblxuICAvLyBBbmQgZmlyc3Qgd29yZCBhbmQgbnVtXG4gIEJOLnByb3RvdHlwZS5hbmRsbiA9IGZ1bmN0aW9uIGFuZGxuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy53b3Jkc1swXSAmIG51bTtcbiAgfTtcblxuICAvLyBJbmNyZW1lbnQgYXQgdGhlIGJpdCBwb3NpdGlvbiBpbi1saW5lXG4gIEJOLnByb3RvdHlwZS5iaW5jbiA9IGZ1bmN0aW9uIGJpbmNuIChiaXQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicpO1xuICAgIHZhciByID0gYml0ICUgMjY7XG4gICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgICB2YXIgcSA9IDEgPDwgcjtcblxuICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHRoaXMuX2V4cGFuZChzICsgMSk7XG4gICAgICB0aGlzLndvcmRzW3NdIHw9IHE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgYml0IGFuZCBwcm9wYWdhdGUsIGlmIG5lZWRlZFxuICAgIHZhciBjYXJyeSA9IHE7XG4gICAgZm9yICh2YXIgaSA9IHM7IGNhcnJ5ICE9PSAwICYmIGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdyArPSBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+Pj4gMjY7XG4gICAgICB3ICY9IDB4M2ZmZmZmZjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB3O1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8gKCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jbXBuID0gZnVuY3Rpb24gY21wbiAobnVtKSB7XG4gICAgdmFyIG5lZ2F0aXZlID0gbnVtIDwgMDtcblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmICFuZWdhdGl2ZSkgcmV0dXJuIC0xO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG5lZ2F0aXZlKSByZXR1cm4gMTtcblxuICAgIHRoaXMuc3RyaXAoKTtcblxuICAgIHZhciByZXM7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIG51bSA9IC1udW07XG4gICAgICB9XG5cbiAgICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmLCAnTnVtYmVyIGlzIHRvbyBiaWcnKTtcblxuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzWzBdIHwgMDtcbiAgICAgIHJlcyA9IHcgPT09IG51bSA/IDAgOiB3IDwgbnVtID8gLTEgOiAxO1xuICAgIH1cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gQ29tcGFyZSB0d28gbnVtYmVycyBhbmQgcmV0dXJuOlxuICAvLyAxIC0gaWYgYHRoaXNgID4gYG51bWBcbiAgLy8gMCAtIGlmIGB0aGlzYCA9PSBgbnVtYFxuICAvLyAtMSAtIGlmIGB0aGlzYCA8IGBudW1gXG4gIEJOLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbiBjbXAgKG51bSkge1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkgcmV0dXJuIC0xO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIDE7XG5cbiAgICB2YXIgcmVzID0gdGhpcy51Y21wKG51bSk7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIFVuc2lnbmVkIGNvbXBhcmlzb25cbiAgQk4ucHJvdG90eXBlLnVjbXAgPSBmdW5jdGlvbiB1Y21wIChudW0pIHtcbiAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBoYXZlIHRoZSBzYW1lIHNpZ25cbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gMTtcbiAgICBpZiAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSByZXR1cm4gLTE7XG5cbiAgICB2YXIgcmVzID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGEgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHZhciBiID0gbnVtLndvcmRzW2ldIHwgMDtcblxuICAgICAgaWYgKGEgPT09IGIpIGNvbnRpbnVlO1xuICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgIHJlcyA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChhID4gYikge1xuICAgICAgICByZXMgPSAxO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0biA9IGZ1bmN0aW9uIGd0biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAxO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndCA9IGZ1bmN0aW9uIGd0IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlbiA9IGZ1bmN0aW9uIGd0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndGUgPSBmdW5jdGlvbiBndGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID49IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0biA9IGZ1bmN0aW9uIGx0biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiBsdCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IC0xO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGVuID0gZnVuY3Rpb24gbHRlbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ZSA9IGZ1bmN0aW9uIGx0ZSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPD0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZXFuID0gZnVuY3Rpb24gZXFuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAwO1xuICB9O1xuXG4gIC8vXG4gIC8vIEEgcmVkdWNlIGNvbnRleHQsIGNvdWxkIGJlIHVzaW5nIG1vbnRnb21lcnkgb3Igc29tZXRoaW5nIGJldHRlciwgZGVwZW5kaW5nXG4gIC8vIG9uIHRoZSBgbWAgaXRzZWxmLlxuICAvL1xuICBCTi5yZWQgPSBmdW5jdGlvbiByZWQgKG51bSkge1xuICAgIHJldHVybiBuZXcgUmVkKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvUmVkID0gZnVuY3Rpb24gdG9SZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIHJldHVybiBjdHguY29udmVydFRvKHRoaXMpLl9mb3JjZVJlZChjdHgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mcm9tUmVkID0gZnVuY3Rpb24gZnJvbVJlZCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAnZnJvbVJlZCB3b3JrcyBvbmx5IHdpdGggbnVtYmVycyBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIHJldHVybiB0aGlzLnJlZC5jb252ZXJ0RnJvbSh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2ZvcmNlUmVkID0gZnVuY3Rpb24gX2ZvcmNlUmVkIChjdHgpIHtcbiAgICB0aGlzLnJlZCA9IGN0eDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZm9yY2VSZWQgPSBmdW5jdGlvbiBmb3JjZVJlZCAoY3R4KSB7XG4gICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkQWRkID0gZnVuY3Rpb24gcmVkQWRkIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmFkZCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJQWRkID0gZnVuY3Rpb24gcmVkSUFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSUFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaWFkZCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTdWIgPSBmdW5jdGlvbiByZWRTdWIgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3ViKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElTdWIgPSBmdW5jdGlvbiByZWRJU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pc3ViKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFNobCA9IGZ1bmN0aW9uIHJlZFNobCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU2hsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zaGwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkTXVsID0gZnVuY3Rpb24gcmVkTXVsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgICByZXR1cm4gdGhpcy5yZWQubXVsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElNdWwgPSBmdW5jdGlvbiByZWRJTXVsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaW11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTcXIgPSBmdW5jdGlvbiByZWRTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FyKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3FyID0gZnVuY3Rpb24gcmVkSVNxciAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXNxcih0aGlzKTtcbiAgfTtcblxuICAvLyBTcXVhcmUgcm9vdCBvdmVyIHBcbiAgQk4ucHJvdG90eXBlLnJlZFNxcnQgPSBmdW5jdGlvbiByZWRTcXJ0ICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXJ0IHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zcXJ0KHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJbnZtID0gZnVuY3Rpb24gcmVkSW52bSAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSW52bSB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaW52bSh0aGlzKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgICUgYHJlZCBtb2R1bG9gXG4gIEJOLnByb3RvdHlwZS5yZWROZWcgPSBmdW5jdGlvbiByZWROZWcgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE5lZyB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQubmVnKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRQb3cgPSBmdW5jdGlvbiByZWRQb3cgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCAmJiAhbnVtLnJlZCwgJ3JlZFBvdyhub3JtYWxOdW0pJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnBvdyh0aGlzLCBudW0pO1xuICB9O1xuXG4gIC8vIFByaW1lIG51bWJlcnMgd2l0aCBlZmZpY2llbnQgcmVkdWN0aW9uXG4gIHZhciBwcmltZXMgPSB7XG4gICAgazI1NjogbnVsbCxcbiAgICBwMjI0OiBudWxsLFxuICAgIHAxOTI6IG51bGwsXG4gICAgcDI1NTE5OiBudWxsXG4gIH07XG5cbiAgLy8gUHNldWRvLU1lcnNlbm5lIHByaW1lXG4gIGZ1bmN0aW9uIE1QcmltZSAobmFtZSwgcCkge1xuICAgIC8vIFAgPSAyIF4gTiAtIEtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucCA9IG5ldyBCTihwLCAxNik7XG4gICAgdGhpcy5uID0gdGhpcy5wLmJpdExlbmd0aCgpO1xuICAgIHRoaXMuayA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5uKS5pc3ViKHRoaXMucCk7XG5cbiAgICB0aGlzLnRtcCA9IHRoaXMuX3RtcCgpO1xuICB9XG5cbiAgTVByaW1lLnByb3RvdHlwZS5fdG1wID0gZnVuY3Rpb24gX3RtcCAoKSB7XG4gICAgdmFyIHRtcCA9IG5ldyBCTihudWxsKTtcbiAgICB0bXAud29yZHMgPSBuZXcgQXJyYXkoTWF0aC5jZWlsKHRoaXMubiAvIDEzKSk7XG4gICAgcmV0dXJuIHRtcDtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmlyZWR1Y2UgPSBmdW5jdGlvbiBpcmVkdWNlIChudW0pIHtcbiAgICAvLyBBc3N1bWVzIHRoYXQgYG51bWAgaXMgbGVzcyB0aGFuIGBQXjJgXG4gICAgLy8gbnVtID0gSEkgKiAoMiBeIE4gLSBLKSArIEhJICogSyArIExPID0gSEkgKiBLICsgTE8gKG1vZCBQKVxuICAgIHZhciByID0gbnVtO1xuICAgIHZhciBybGVuO1xuXG4gICAgZG8ge1xuICAgICAgdGhpcy5zcGxpdChyLCB0aGlzLnRtcCk7XG4gICAgICByID0gdGhpcy5pbXVsSyhyKTtcbiAgICAgIHIgPSByLmlhZGQodGhpcy50bXApO1xuICAgICAgcmxlbiA9IHIuYml0TGVuZ3RoKCk7XG4gICAgfSB3aGlsZSAocmxlbiA+IHRoaXMubik7XG5cbiAgICB2YXIgY21wID0gcmxlbiA8IHRoaXMubiA/IC0xIDogci51Y21wKHRoaXMucCk7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgci53b3Jkc1swXSA9IDA7XG4gICAgICByLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICByLmlzdWIodGhpcy5wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgci5zdHJpcCgpO1xuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dCkge1xuICAgIGlucHV0Lml1c2hybih0aGlzLm4sIDAsIG91dCk7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICByZXR1cm4gbnVtLmltdWwodGhpcy5rKTtcbiAgfTtcblxuICBmdW5jdGlvbiBLMjU2ICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAnazI1NicsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnKTtcbiAgfVxuICBpbmhlcml0cyhLMjU2LCBNUHJpbWUpO1xuXG4gIEsyNTYucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXRwdXQpIHtcbiAgICAvLyAyNTYgPSA5ICogMjYgKyAyMlxuICAgIHZhciBtYXNrID0gMHgzZmZmZmY7XG5cbiAgICB2YXIgb3V0TGVuID0gTWF0aC5taW4oaW5wdXQubGVuZ3RoLCA5KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dExlbjsgaSsrKSB7XG4gICAgICBvdXRwdXQud29yZHNbaV0gPSBpbnB1dC53b3Jkc1tpXTtcbiAgICB9XG4gICAgb3V0cHV0Lmxlbmd0aCA9IG91dExlbjtcblxuICAgIGlmIChpbnB1dC5sZW5ndGggPD0gOSkge1xuICAgICAgaW5wdXQud29yZHNbMF0gPSAwO1xuICAgICAgaW5wdXQubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTaGlmdCBieSA5IGxpbWJzXG4gICAgdmFyIHByZXYgPSBpbnB1dC53b3Jkc1s5XTtcbiAgICBvdXRwdXQud29yZHNbb3V0cHV0Lmxlbmd0aCsrXSA9IHByZXYgJiBtYXNrO1xuXG4gICAgZm9yIChpID0gMTA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5leHQgPSBpbnB1dC53b3Jkc1tpXSB8IDA7XG4gICAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gKChuZXh0ICYgbWFzaykgPDwgNCkgfCAocHJldiA+Pj4gMjIpO1xuICAgICAgcHJldiA9IG5leHQ7XG4gICAgfVxuICAgIHByZXYgPj4+PSAyMjtcbiAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gcHJldjtcbiAgICBpZiAocHJldiA9PT0gMCAmJiBpbnB1dC5sZW5ndGggPiAxMCkge1xuICAgICAgaW5wdXQubGVuZ3RoIC09IDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gOTtcbiAgICB9XG4gIH07XG5cbiAgSzI1Ni5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgLy8gSyA9IDB4MTAwMDAwM2QxID0gWyAweDQwLCAweDNkMSBdXG4gICAgbnVtLndvcmRzW251bS5sZW5ndGhdID0gMDtcbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aCArIDFdID0gMDtcbiAgICBudW0ubGVuZ3RoICs9IDI7XG5cbiAgICAvLyBib3VuZGVkIGF0OiAweDQwICogMHgzZmZmZmZmICsgMHgzZDAgPSAweDEwMDAwMDM5MFxuICAgIHZhciBsbyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gbnVtLndvcmRzW2ldIHwgMDtcbiAgICAgIGxvICs9IHcgKiAweDNkMTtcbiAgICAgIG51bS53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgbG8gPSB3ICogMHg0MCArICgobG8gLyAweDQwMDAwMDApIHwgMCk7XG4gICAgfVxuXG4gICAgLy8gRmFzdCBsZW5ndGggcmVkdWN0aW9uXG4gICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgIG51bS5sZW5ndGgtLTtcbiAgICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICAgIG51bS5sZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICBmdW5jdGlvbiBQMjI0ICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncDIyNCcsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDEnKTtcbiAgfVxuICBpbmhlcml0cyhQMjI0LCBNUHJpbWUpO1xuXG4gIGZ1bmN0aW9uIFAxOTIgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMTkyJyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZicpO1xuICB9XG4gIGluaGVyaXRzKFAxOTIsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDI1NTE5ICgpIHtcbiAgICAvLyAyIF4gMjU1IC0gMTlcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAnMjU1MTknLFxuICAgICAgJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnKTtcbiAgfVxuICBpbmhlcml0cyhQMjU1MTksIE1QcmltZSk7XG5cbiAgUDI1NTE5LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxM1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoaSA9IChudW0ud29yZHNbaV0gfCAwKSAqIDB4MTMgKyBjYXJyeTtcbiAgICAgIHZhciBsbyA9IGhpICYgMHgzZmZmZmZmO1xuICAgICAgaGkgPj4+PSAyNjtcblxuICAgICAgbnVtLndvcmRzW2ldID0gbG87XG4gICAgICBjYXJyeSA9IGhpO1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoKytdID0gY2Fycnk7XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgLy8gRXhwb3J0ZWQgbW9zdGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB1c2UgcGxhaW4gbmFtZSBpbnN0ZWFkXG4gIEJOLl9wcmltZSA9IGZ1bmN0aW9uIHByaW1lIChuYW1lKSB7XG4gICAgLy8gQ2FjaGVkIHZlcnNpb24gb2YgcHJpbWVcbiAgICBpZiAocHJpbWVzW25hbWVdKSByZXR1cm4gcHJpbWVzW25hbWVdO1xuXG4gICAgdmFyIHByaW1lO1xuICAgIGlmIChuYW1lID09PSAnazI1NicpIHtcbiAgICAgIHByaW1lID0gbmV3IEsyNTYoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjI0Jykge1xuICAgICAgcHJpbWUgPSBuZXcgUDIyNCgpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AxOTInKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMTkyKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDI1NTE5Jykge1xuICAgICAgcHJpbWUgPSBuZXcgUDI1NTE5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwcmltZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHByaW1lc1tuYW1lXSA9IHByaW1lO1xuXG4gICAgcmV0dXJuIHByaW1lO1xuICB9O1xuXG4gIC8vXG4gIC8vIEJhc2UgcmVkdWN0aW9uIGVuZ2luZVxuICAvL1xuICBmdW5jdGlvbiBSZWQgKG0pIHtcbiAgICBpZiAodHlwZW9mIG0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgcHJpbWUgPSBCTi5fcHJpbWUobSk7XG4gICAgICB0aGlzLm0gPSBwcmltZS5wO1xuICAgICAgdGhpcy5wcmltZSA9IHByaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobS5ndG4oMSksICdtb2R1bHVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIDEnKTtcbiAgICAgIHRoaXMubSA9IG07XG4gICAgICB0aGlzLnByaW1lID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBSZWQucHJvdG90eXBlLl92ZXJpZnkxID0gZnVuY3Rpb24gX3ZlcmlmeTEgKGEpIHtcbiAgICBhc3NlcnQoYS5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgYXNzZXJ0KGEucmVkLCAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTIgPSBmdW5jdGlvbiBfdmVyaWZ5MiAoYSwgYikge1xuICAgIGFzc2VydCgoYS5uZWdhdGl2ZSB8IGIubmVnYXRpdmUpID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQgJiYgYS5yZWQgPT09IGIucmVkLFxuICAgICAgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmltb2QgPSBmdW5jdGlvbiBpbW9kIChhKSB7XG4gICAgaWYgKHRoaXMucHJpbWUpIHJldHVybiB0aGlzLnByaW1lLmlyZWR1Y2UoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuICAgIHJldHVybiBhLnVtb2QodGhpcy5tKS5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tLnN1YihhKS5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuYWRkKGIpO1xuICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5pYWRkKGIpO1xuICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5zdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5pc3ViKGIpO1xuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zaGwgPSBmdW5jdGlvbiBzaGwgKGEsIG51bSkge1xuICAgIHRoaXMuX3ZlcmlmeTEoYSk7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLnVzaGxuKG51bSkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS5pbXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLm11bChiKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoYSkge1xuICAgIHJldHVybiB0aGlzLmltdWwoYSwgYS5jbG9uZSgpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoYSkge1xuICAgIHJldHVybiB0aGlzLm11bChhLCBhKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbiBzcXJ0IChhKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkpIHJldHVybiBhLmNsb25lKCk7XG5cbiAgICB2YXIgbW9kMyA9IHRoaXMubS5hbmRsbigzKTtcbiAgICBhc3NlcnQobW9kMyAlIDIgPT09IDEpO1xuXG4gICAgLy8gRmFzdCBjYXNlXG4gICAgaWYgKG1vZDMgPT09IDMpIHtcbiAgICAgIHZhciBwb3cgPSB0aGlzLm0uYWRkKG5ldyBCTigxKSkuaXVzaHJuKDIpO1xuICAgICAgcmV0dXJuIHRoaXMucG93KGEsIHBvdyk7XG4gICAgfVxuXG4gICAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtIChUb3RhbGx5IHVub3B0aW1pemVkIGFuZCBzbG93KVxuICAgIC8vXG4gICAgLy8gRmluZCBRIGFuZCBTLCB0aGF0IFEgKiAyIF4gUyA9IChQIC0gMSlcbiAgICB2YXIgcSA9IHRoaXMubS5zdWJuKDEpO1xuICAgIHZhciBzID0gMDtcbiAgICB3aGlsZSAoIXEuaXNaZXJvKCkgJiYgcS5hbmRsbigxKSA9PT0gMCkge1xuICAgICAgcysrO1xuICAgICAgcS5pdXNocm4oMSk7XG4gICAgfVxuICAgIGFzc2VydCghcS5pc1plcm8oKSk7XG5cbiAgICB2YXIgb25lID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIHZhciBuT25lID0gb25lLnJlZE5lZygpO1xuXG4gICAgLy8gRmluZCBxdWFkcmF0aWMgbm9uLXJlc2lkdWVcbiAgICAvLyBOT1RFOiBNYXggaXMgc3VjaCBiZWNhdXNlIG9mIGdlbmVyYWxpemVkIFJpZW1hbm4gaHlwb3RoZXNpcy5cbiAgICB2YXIgbHBvdyA9IHRoaXMubS5zdWJuKDEpLml1c2hybigxKTtcbiAgICB2YXIgeiA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgICB6ID0gbmV3IEJOKDIgKiB6ICogeikudG9SZWQodGhpcyk7XG5cbiAgICB3aGlsZSAodGhpcy5wb3coeiwgbHBvdykuY21wKG5PbmUpICE9PSAwKSB7XG4gICAgICB6LnJlZElBZGQobk9uZSk7XG4gICAgfVxuXG4gICAgdmFyIGMgPSB0aGlzLnBvdyh6LCBxKTtcbiAgICB2YXIgciA9IHRoaXMucG93KGEsIHEuYWRkbigxKS5pdXNocm4oMSkpO1xuICAgIHZhciB0ID0gdGhpcy5wb3coYSwgcSk7XG4gICAgdmFyIG0gPSBzO1xuICAgIHdoaWxlICh0LmNtcChvbmUpICE9PSAwKSB7XG4gICAgICB2YXIgdG1wID0gdDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyB0bXAuY21wKG9uZSkgIT09IDA7IGkrKykge1xuICAgICAgICB0bXAgPSB0bXAucmVkU3FyKCk7XG4gICAgICB9XG4gICAgICBhc3NlcnQoaSA8IG0pO1xuICAgICAgdmFyIGIgPSB0aGlzLnBvdyhjLCBuZXcgQk4oMSkuaXVzaGxuKG0gLSBpIC0gMSkpO1xuXG4gICAgICByID0gci5yZWRNdWwoYik7XG4gICAgICBjID0gYi5yZWRTcXIoKTtcbiAgICAgIHQgPSB0LnJlZE11bChjKTtcbiAgICAgIG0gPSBpO1xuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcbiAgICB2YXIgaW52ID0gYS5faW52bXAodGhpcy5tKTtcbiAgICBpZiAoaW52Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpbnYubmVnYXRpdmUgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpLnJlZE5lZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludik7XG4gICAgfVxuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChhLCBudW0pIHtcbiAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIGlmIChudW0uY21wbigxKSA9PT0gMCkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciB3aW5kb3dTaXplID0gNDtcbiAgICB2YXIgd25kID0gbmV3IEFycmF5KDEgPDwgd2luZG93U2l6ZSk7XG4gICAgd25kWzBdID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIHduZFsxXSA9IGE7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCB3bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHduZFtpXSA9IHRoaXMubXVsKHduZFtpIC0gMV0sIGEpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSB3bmRbMF07XG4gICAgdmFyIGN1cnJlbnQgPSAwO1xuICAgIHZhciBjdXJyZW50TGVuID0gMDtcbiAgICB2YXIgc3RhcnQgPSBudW0uYml0TGVuZ3RoKCkgJSAyNjtcbiAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgIHN0YXJ0ID0gMjY7XG4gICAgfVxuXG4gICAgZm9yIChpID0gbnVtLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgd29yZCA9IG51bS53b3Jkc1tpXTtcbiAgICAgIGZvciAodmFyIGogPSBzdGFydCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIHZhciBiaXQgPSAod29yZCA+PiBqKSAmIDE7XG4gICAgICAgIGlmIChyZXMgIT09IHduZFswXSkge1xuICAgICAgICAgIHJlcyA9IHRoaXMuc3FyKHJlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYml0ID09PSAwICYmIGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgICBjdXJyZW50TGVuID0gMDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPDw9IDE7XG4gICAgICAgIGN1cnJlbnQgfD0gYml0O1xuICAgICAgICBjdXJyZW50TGVuKys7XG4gICAgICAgIGlmIChjdXJyZW50TGVuICE9PSB3aW5kb3dTaXplICYmIChpICE9PSAwIHx8IGogIT09IDApKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSB0aGlzLm11bChyZXMsIHduZFtjdXJyZW50XSk7XG4gICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICBjdXJyZW50ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gMjY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG4gICAgdmFyIHIgPSBudW0udW1vZCh0aGlzLm0pO1xuXG4gICAgcmV0dXJuIHIgPT09IG51bSA/IHIuY2xvbmUoKSA6IHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgcmVzID0gbnVtLmNsb25lKCk7XG4gICAgcmVzLnJlZCA9IG51bGw7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvL1xuICAvLyBNb250Z29tZXJ5IG1ldGhvZCBlbmdpbmVcbiAgLy9cblxuICBCTi5tb250ID0gZnVuY3Rpb24gbW9udCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBNb250KG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gTW9udCAobSkge1xuICAgIFJlZC5jYWxsKHRoaXMsIG0pO1xuXG4gICAgdGhpcy5zaGlmdCA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgICBpZiAodGhpcy5zaGlmdCAlIDI2ICE9PSAwKSB7XG4gICAgICB0aGlzLnNoaWZ0ICs9IDI2IC0gKHRoaXMuc2hpZnQgJSAyNik7XG4gICAgfVxuXG4gICAgdGhpcy5yID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLnNoaWZ0KTtcbiAgICB0aGlzLnIyID0gdGhpcy5pbW9kKHRoaXMuci5zcXIoKSk7XG4gICAgdGhpcy5yaW52ID0gdGhpcy5yLl9pbnZtcCh0aGlzLm0pO1xuXG4gICAgdGhpcy5taW52ID0gdGhpcy5yaW52Lm11bCh0aGlzLnIpLmlzdWJuKDEpLmRpdih0aGlzLm0pO1xuICAgIHRoaXMubWludiA9IHRoaXMubWludi51bW9kKHRoaXMucik7XG4gICAgdGhpcy5taW52ID0gdGhpcy5yLnN1Yih0aGlzLm1pbnYpO1xuICB9XG4gIGluaGVyaXRzKE1vbnQsIFJlZCk7XG5cbiAgTW9udC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5pbW9kKG51bS51c2hsbih0aGlzLnNoaWZ0KSk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG4gICAgdmFyIHIgPSB0aGlzLmltb2QobnVtLm11bCh0aGlzLnJpbnYpKTtcbiAgICByLnJlZCA9IG51bGw7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcbiAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSB7XG4gICAgICBhLndvcmRzWzBdID0gMDtcbiAgICAgIGEubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIHZhciB0ID0gYS5pbXVsKGIpO1xuICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICAgIHZhciByZXMgPSB1O1xuXG4gICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG4gICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcbiAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDApLl9mb3JjZVJlZCh0aGlzKTtcblxuICAgIHZhciB0ID0gYS5tdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG4gICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG4gICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIC8vIChBUileLTEgKiBSXjIgPSAoQV4tMSAqIFJeLTEpICogUl4yID0gQV4tMSAqIFJcbiAgICB2YXIgcmVzID0gdGhpcy5pbW9kKGEuX2ludm1wKHRoaXMubSkubXVsKHRoaXMucjIpKTtcbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcbn0pKHR5cGVvZiBtb2R1bGUgPT09ICd1bmRlZmluZWQnIHx8IG1vZHVsZSwgdGhpcyk7XG4iLCJ2YXIgcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByYW5kKGxlbikge1xuICBpZiAoIXIpXG4gICAgciA9IG5ldyBSYW5kKG51bGwpO1xuXG4gIHJldHVybiByLmdlbmVyYXRlKGxlbik7XG59O1xuXG5mdW5jdGlvbiBSYW5kKHJhbmQpIHtcbiAgdGhpcy5yYW5kID0gcmFuZDtcbn1cbm1vZHVsZS5leHBvcnRzLlJhbmQgPSBSYW5kO1xuXG5SYW5kLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlKGxlbikge1xuICByZXR1cm4gdGhpcy5fcmFuZChsZW4pO1xufTtcblxuLy8gRW11bGF0ZSBjcnlwdG8gQVBJIHVzaW5nIHJhbmR5XG5SYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgaWYgKHRoaXMucmFuZC5nZXRCeXRlcylcbiAgICByZXR1cm4gdGhpcy5yYW5kLmdldEJ5dGVzKG4pO1xuXG4gIHZhciByZXMgPSBuZXcgVWludDhBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyBpKyspXG4gICAgcmVzW2ldID0gdGhpcy5yYW5kLmdldEJ5dGUoKTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbmlmICh0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcpIHtcbiAgaWYgKHNlbGYuY3J5cHRvICYmIHNlbGYuY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIE1vZGVybiBicm93c2Vyc1xuICAgIFJhbmQucHJvdG90eXBlLl9yYW5kID0gZnVuY3Rpb24gX3JhbmQobikge1xuICAgICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KG4pO1xuICAgICAgc2VsZi5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoc2VsZi5tc0NyeXB0byAmJiBzZWxmLm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIElFXG4gICAgUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbiBfcmFuZChuKSB7XG4gICAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgICBzZWxmLm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpO1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuXG4gIC8vIFNhZmFyaSdzIFdlYldvcmtlcnMgZG8gbm90IGhhdmUgYGNyeXB0b2BcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0Jykge1xuICAgIC8vIE9sZCBqdW5rXG4gICAgUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgIH07XG4gIH1cbn0gZWxzZSB7XG4gIC8vIE5vZGUuanMgb3IgV2ViIHdvcmtlciB3aXRoIG5vIGNyeXB0byBzdXBwb3J0XG4gIHRyeSB7XG4gICAgdmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuICAgIGlmICh0eXBlb2YgY3J5cHRvLnJhbmRvbUJ5dGVzICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkJyk7XG5cbiAgICBSYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMobik7XG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG4iLCIvLyBiYXNlZCBvbiB0aGUgYWVzIGltcGxpbWVudGF0aW9uIGluIHRyaXBsZSBzZWNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rZXliYXNlL3RyaXBsZXNlY1xuLy8gd2hpY2ggaXMgaW4gdHVybiBiYXNlZCBvbiB0aGUgb25lIGZyb20gY3J5cHRvLWpzXG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbmZ1bmN0aW9uIGFzVUludDMyQXJyYXkgKGJ1Zikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBCdWZmZXIuZnJvbShidWYpXG5cbiAgdmFyIGxlbiA9IChidWYubGVuZ3RoIC8gNCkgfCAwXG4gIHZhciBvdXQgPSBuZXcgQXJyYXkobGVuKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSBidWYucmVhZFVJbnQzMkJFKGkgKiA0KVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBzY3J1YlZlYyAodikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyB2KyspIHtcbiAgICB2W2ldID0gMFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyeXB0QmxvY2sgKE0sIGtleVNjaGVkdWxlLCBTVUJfTUlYLCBTQk9YLCBuUm91bmRzKSB7XG4gIHZhciBTVUJfTUlYMCA9IFNVQl9NSVhbMF1cbiAgdmFyIFNVQl9NSVgxID0gU1VCX01JWFsxXVxuICB2YXIgU1VCX01JWDIgPSBTVUJfTUlYWzJdXG4gIHZhciBTVUJfTUlYMyA9IFNVQl9NSVhbM11cblxuICB2YXIgczAgPSBNWzBdIF4ga2V5U2NoZWR1bGVbMF1cbiAgdmFyIHMxID0gTVsxXSBeIGtleVNjaGVkdWxlWzFdXG4gIHZhciBzMiA9IE1bMl0gXiBrZXlTY2hlZHVsZVsyXVxuICB2YXIgczMgPSBNWzNdIF4ga2V5U2NoZWR1bGVbM11cbiAgdmFyIHQwLCB0MSwgdDIsIHQzXG4gIHZhciBrc1JvdyA9IDRcblxuICBmb3IgKHZhciByb3VuZCA9IDE7IHJvdW5kIDwgblJvdW5kczsgcm91bmQrKykge1xuICAgIHQwID0gU1VCX01JWDBbczAgPj4+IDI0XSBeIFNVQl9NSVgxWyhzMSA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYMlsoczIgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYM1tzMyAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgICB0MSA9IFNVQl9NSVgwW3MxID4+PiAyNF0gXiBTVUJfTUlYMVsoczIgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWDJbKHMzID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWDNbczAgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgdDIgPSBTVUJfTUlYMFtzMiA+Pj4gMjRdIF4gU1VCX01JWDFbKHMzID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVgyWyhzMCA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVgzW3MxICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHQzID0gU1VCX01JWDBbczMgPj4+IDI0XSBeIFNVQl9NSVgxWyhzMCA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYMlsoczEgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYM1tzMiAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgICBzMCA9IHQwXG4gICAgczEgPSB0MVxuICAgIHMyID0gdDJcbiAgICBzMyA9IHQzXG4gIH1cblxuICB0MCA9ICgoU0JPWFtzMCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMSA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMyID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMyAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHQxID0gKChTQk9YW3MxID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMyID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczMgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MwICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgdDIgPSAoKFNCT1hbczIgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczMgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczEgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICB0MyA9ICgoU0JPWFtzMyA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMxID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMiAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHQwID0gdDAgPj4+IDBcbiAgdDEgPSB0MSA+Pj4gMFxuICB0MiA9IHQyID4+PiAwXG4gIHQzID0gdDMgPj4+IDBcblxuICByZXR1cm4gW3QwLCB0MSwgdDIsIHQzXVxufVxuXG4vLyBBRVMgY29uc3RhbnRzXG52YXIgUkNPTiA9IFsweDAwLCAweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XVxudmFyIEcgPSAoZnVuY3Rpb24gKCkge1xuICAvLyBDb21wdXRlIGRvdWJsZSB0YWJsZVxuICB2YXIgZCA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAodmFyIGogPSAwOyBqIDwgMjU2OyBqKyspIHtcbiAgICBpZiAoaiA8IDEyOCkge1xuICAgICAgZFtqXSA9IGogPDwgMVxuICAgIH0gZWxzZSB7XG4gICAgICBkW2pdID0gKGogPDwgMSkgXiAweDExYlxuICAgIH1cbiAgfVxuXG4gIHZhciBTQk9YID0gW11cbiAgdmFyIElOVl9TQk9YID0gW11cbiAgdmFyIFNVQl9NSVggPSBbW10sIFtdLCBbXSwgW11dXG4gIHZhciBJTlZfU1VCX01JWCA9IFtbXSwgW10sIFtdLCBbXV1cblxuICAvLyBXYWxrIEdGKDJeOClcbiAgdmFyIHggPSAwXG4gIHZhciB4aSA9IDBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgIC8vIENvbXB1dGUgc2JveFxuICAgIHZhciBzeCA9IHhpIF4gKHhpIDw8IDEpIF4gKHhpIDw8IDIpIF4gKHhpIDw8IDMpIF4gKHhpIDw8IDQpXG4gICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzXG4gICAgU0JPWFt4XSA9IHN4XG4gICAgSU5WX1NCT1hbc3hdID0geFxuXG4gICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuICAgIHZhciB4MiA9IGRbeF1cbiAgICB2YXIgeDQgPSBkW3gyXVxuICAgIHZhciB4OCA9IGRbeDRdXG5cbiAgICAvLyBDb21wdXRlIHN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgdmFyIHQgPSAoZFtzeF0gKiAweDEwMSkgXiAoc3ggKiAweDEwMTAxMDApXG4gICAgU1VCX01JWFswXVt4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KVxuICAgIFNVQl9NSVhbMV1beF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpXG4gICAgU1VCX01JWFsyXVt4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KVxuICAgIFNVQl9NSVhbM11beF0gPSB0XG5cbiAgICAvLyBDb21wdXRlIGludiBzdWIgYnl0ZXMsIGludiBtaXggY29sdW1ucyB0YWJsZXNcbiAgICB0ID0gKHg4ICogMHgxMDEwMTAxKSBeICh4NCAqIDB4MTAwMDEpIF4gKHgyICogMHgxMDEpIF4gKHggKiAweDEwMTAxMDApXG4gICAgSU5WX1NVQl9NSVhbMF1bc3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpXG4gICAgSU5WX1NVQl9NSVhbMV1bc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KVxuICAgIElOVl9TVUJfTUlYWzJdW3N4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KVxuICAgIElOVl9TVUJfTUlYWzNdW3N4XSA9IHRcblxuICAgIGlmICh4ID09PSAwKSB7XG4gICAgICB4ID0geGkgPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV1cbiAgICAgIHhpIF49IGRbZFt4aV1dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBTQk9YOiBTQk9YLFxuICAgIElOVl9TQk9YOiBJTlZfU0JPWCxcbiAgICBTVUJfTUlYOiBTVUJfTUlYLFxuICAgIElOVl9TVUJfTUlYOiBJTlZfU1VCX01JWFxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIEFFUyAoa2V5KSB7XG4gIHRoaXMuX2tleSA9IGFzVUludDMyQXJyYXkoa2V5KVxuICB0aGlzLl9yZXNldCgpXG59XG5cbkFFUy5ibG9ja1NpemUgPSA0ICogNFxuQUVTLmtleVNpemUgPSAyNTYgLyA4XG5BRVMucHJvdG90eXBlLmJsb2NrU2l6ZSA9IEFFUy5ibG9ja1NpemVcbkFFUy5wcm90b3R5cGUua2V5U2l6ZSA9IEFFUy5rZXlTaXplXG5BRVMucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGtleVdvcmRzID0gdGhpcy5fa2V5XG4gIHZhciBrZXlTaXplID0ga2V5V29yZHMubGVuZ3RoXG4gIHZhciBuUm91bmRzID0ga2V5U2l6ZSArIDZcbiAgdmFyIGtzUm93cyA9IChuUm91bmRzICsgMSkgKiA0XG5cbiAgdmFyIGtleVNjaGVkdWxlID0gW11cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBrZXlTaXplOyBrKyspIHtcbiAgICBrZXlTY2hlZHVsZVtrXSA9IGtleVdvcmRzW2tdXG4gIH1cblxuICBmb3IgKGsgPSBrZXlTaXplOyBrIDwga3NSb3dzOyBrKyspIHtcbiAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2sgLSAxXVxuXG4gICAgaWYgKGsgJSBrZXlTaXplID09PSAwKSB7XG4gICAgICB0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpXG4gICAgICB0ID1cbiAgICAgICAgKEcuU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHxcbiAgICAgICAgKEcuU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHxcbiAgICAgICAgKEcuU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8XG4gICAgICAgIChHLlNCT1hbdCAmIDB4ZmZdKVxuXG4gICAgICB0IF49IFJDT05bKGsgLyBrZXlTaXplKSB8IDBdIDw8IDI0XG4gICAgfSBlbHNlIGlmIChrZXlTaXplID4gNiAmJiBrICUga2V5U2l6ZSA9PT0gNCkge1xuICAgICAgdCA9XG4gICAgICAgIChHLlNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8XG4gICAgICAgIChHLlNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8XG4gICAgICAgIChHLlNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfFxuICAgICAgICAoRy5TQk9YW3QgJiAweGZmXSlcbiAgICB9XG5cbiAgICBrZXlTY2hlZHVsZVtrXSA9IGtleVNjaGVkdWxlW2sgLSBrZXlTaXplXSBeIHRcbiAgfVxuXG4gIHZhciBpbnZLZXlTY2hlZHVsZSA9IFtdXG4gIGZvciAodmFyIGlrID0gMDsgaWsgPCBrc1Jvd3M7IGlrKyspIHtcbiAgICB2YXIga3NSID0ga3NSb3dzIC0gaWtcbiAgICB2YXIgdHQgPSBrZXlTY2hlZHVsZVtrc1IgLSAoaWsgJSA0ID8gMCA6IDQpXVxuXG4gICAgaWYgKGlrIDwgNCB8fCBrc1IgPD0gNCkge1xuICAgICAgaW52S2V5U2NoZWR1bGVbaWtdID0gdHRcbiAgICB9IGVsc2Uge1xuICAgICAgaW52S2V5U2NoZWR1bGVbaWtdID1cbiAgICAgICAgRy5JTlZfU1VCX01JWFswXVtHLlNCT1hbdHQgPj4+IDI0XV0gXlxuICAgICAgICBHLklOVl9TVUJfTUlYWzFdW0cuU0JPWFsodHQgPj4+IDE2KSAmIDB4ZmZdXSBeXG4gICAgICAgIEcuSU5WX1NVQl9NSVhbMl1bRy5TQk9YWyh0dCA+Pj4gOCkgJiAweGZmXV0gXlxuICAgICAgICBHLklOVl9TVUJfTUlYWzNdW0cuU0JPWFt0dCAmIDB4ZmZdXVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX25Sb3VuZHMgPSBuUm91bmRzXG4gIHRoaXMuX2tleVNjaGVkdWxlID0ga2V5U2NoZWR1bGVcbiAgdGhpcy5faW52S2V5U2NoZWR1bGUgPSBpbnZLZXlTY2hlZHVsZVxufVxuXG5BRVMucHJvdG90eXBlLmVuY3J5cHRCbG9ja1JhdyA9IGZ1bmN0aW9uIChNKSB7XG4gIE0gPSBhc1VJbnQzMkFycmF5KE0pXG4gIHJldHVybiBjcnlwdEJsb2NrKE0sIHRoaXMuX2tleVNjaGVkdWxlLCBHLlNVQl9NSVgsIEcuU0JPWCwgdGhpcy5fblJvdW5kcylcbn1cblxuQUVTLnByb3RvdHlwZS5lbmNyeXB0QmxvY2sgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgb3V0ID0gdGhpcy5lbmNyeXB0QmxvY2tSYXcoTSlcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxNilcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzBdLCAwKVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMV0sIDQpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsyXSwgOClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzNdLCAxMilcbiAgcmV0dXJuIGJ1ZlxufVxuXG5BRVMucHJvdG90eXBlLmRlY3J5cHRCbG9jayA9IGZ1bmN0aW9uIChNKSB7XG4gIE0gPSBhc1VJbnQzMkFycmF5KE0pXG5cbiAgLy8gc3dhcFxuICB2YXIgbTEgPSBNWzFdXG4gIE1bMV0gPSBNWzNdXG4gIE1bM10gPSBtMVxuXG4gIHZhciBvdXQgPSBjcnlwdEJsb2NrKE0sIHRoaXMuX2ludktleVNjaGVkdWxlLCBHLklOVl9TVUJfTUlYLCBHLklOVl9TQk9YLCB0aGlzLl9uUm91bmRzKVxuICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDE2KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMF0sIDApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFszXSwgNClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzJdLCA4KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMV0sIDEyKVxuICByZXR1cm4gYnVmXG59XG5cbkFFUy5wcm90b3R5cGUuc2NydWIgPSBmdW5jdGlvbiAoKSB7XG4gIHNjcnViVmVjKHRoaXMuX2tleVNjaGVkdWxlKVxuICBzY3J1YlZlYyh0aGlzLl9pbnZLZXlTY2hlZHVsZSlcbiAgc2NydWJWZWModGhpcy5fa2V5KVxufVxuXG5tb2R1bGUuZXhwb3J0cy5BRVMgPSBBRVNcbiIsInZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgR0hBU0ggPSByZXF1aXJlKCcuL2doYXNoJylcbnZhciB4b3IgPSByZXF1aXJlKCdidWZmZXIteG9yJylcbnZhciBpbmNyMzIgPSByZXF1aXJlKCcuL2luY3IzMicpXG5cbmZ1bmN0aW9uIHhvclRlc3QgKGEsIGIpIHtcbiAgdmFyIG91dCA9IDBcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgb3V0KytcblxuICB2YXIgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgb3V0ICs9IChhW2ldIF4gYltpXSlcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gY2FsY0l2IChzZWxmLCBpdiwgY2spIHtcbiAgaWYgKGl2Lmxlbmd0aCA9PT0gMTIpIHtcbiAgICBzZWxmLl9maW5JRCA9IEJ1ZmZlci5jb25jYXQoW2l2LCBCdWZmZXIuZnJvbShbMCwgMCwgMCwgMV0pXSlcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbaXYsIEJ1ZmZlci5mcm9tKFswLCAwLCAwLCAyXSldKVxuICB9XG4gIHZhciBnaGFzaCA9IG5ldyBHSEFTSChjaylcbiAgdmFyIGxlbiA9IGl2Lmxlbmd0aFxuICB2YXIgdG9QYWQgPSBsZW4gJSAxNlxuICBnaGFzaC51cGRhdGUoaXYpXG4gIGlmICh0b1BhZCkge1xuICAgIHRvUGFkID0gMTYgLSB0b1BhZFxuICAgIGdoYXNoLnVwZGF0ZShCdWZmZXIuYWxsb2ModG9QYWQsIDApKVxuICB9XG4gIGdoYXNoLnVwZGF0ZShCdWZmZXIuYWxsb2MoOCwgMCkpXG4gIHZhciBpdkJpdHMgPSBsZW4gKiA4XG4gIHZhciB0YWlsID0gQnVmZmVyLmFsbG9jKDgpXG4gIHRhaWwud3JpdGVVSW50QkUoaXZCaXRzLCAwLCA4KVxuICBnaGFzaC51cGRhdGUodGFpbClcbiAgc2VsZi5fZmluSUQgPSBnaGFzaC5zdGF0ZVxuICB2YXIgb3V0ID0gQnVmZmVyLmZyb20oc2VsZi5fZmluSUQpXG4gIGluY3IzMihvdXQpXG4gIHJldHVybiBvdXRcbn1cbmZ1bmN0aW9uIFN0cmVhbUNpcGhlciAobW9kZSwga2V5LCBpdiwgZGVjcnlwdCkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuXG4gIHZhciBoID0gQnVmZmVyLmFsbG9jKDQsIDApXG5cbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB2YXIgY2sgPSB0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKGgpXG4gIHRoaXMuX2doYXNoID0gbmV3IEdIQVNIKGNrKVxuICBpdiA9IGNhbGNJdih0aGlzLCBpdiwgY2spXG5cbiAgdGhpcy5fcHJldiA9IEJ1ZmZlci5mcm9tKGl2KVxuICB0aGlzLl9jYWNoZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxuICB0aGlzLl9zZWNDYWNoZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxuICB0aGlzLl9kZWNyeXB0ID0gZGVjcnlwdFxuICB0aGlzLl9hbGVuID0gMFxuICB0aGlzLl9sZW4gPSAwXG4gIHRoaXMuX21vZGUgPSBtb2RlXG5cbiAgdGhpcy5fYXV0aFRhZyA9IG51bGxcbiAgdGhpcy5fY2FsbGVkID0gZmFsc2Vcbn1cblxuaW5oZXJpdHMoU3RyZWFtQ2lwaGVyLCBUcmFuc2Zvcm0pXG5cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICBpZiAoIXRoaXMuX2NhbGxlZCAmJiB0aGlzLl9hbGVuKSB7XG4gICAgdmFyIHJ1bXAgPSAxNiAtICh0aGlzLl9hbGVuICUgMTYpXG4gICAgaWYgKHJ1bXAgPCAxNikge1xuICAgICAgcnVtcCA9IEJ1ZmZlci5hbGxvYyhydW1wLCAwKVxuICAgICAgdGhpcy5fZ2hhc2gudXBkYXRlKHJ1bXApXG4gICAgfVxuICB9XG5cbiAgdGhpcy5fY2FsbGVkID0gdHJ1ZVxuICB2YXIgb3V0ID0gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rKVxuICBpZiAodGhpcy5fZGVjcnlwdCkge1xuICAgIHRoaXMuX2doYXNoLnVwZGF0ZShjaHVuaylcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9naGFzaC51cGRhdGUob3V0KVxuICB9XG4gIHRoaXMuX2xlbiArPSBjaHVuay5sZW5ndGhcbiAgcmV0dXJuIG91dFxufVxuXG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2RlY3J5cHQgJiYgIXRoaXMuX2F1dGhUYWcpIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc3RhdGUgb3IgdW5hYmxlIHRvIGF1dGhlbnRpY2F0ZSBkYXRhJylcblxuICB2YXIgdGFnID0geG9yKHRoaXMuX2doYXNoLmZpbmFsKHRoaXMuX2FsZW4gKiA4LCB0aGlzLl9sZW4gKiA4KSwgdGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayh0aGlzLl9maW5JRCkpXG4gIGlmICh0aGlzLl9kZWNyeXB0ICYmIHhvclRlc3QodGFnLCB0aGlzLl9hdXRoVGFnKSkgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzdGF0ZSBvciB1bmFibGUgdG8gYXV0aGVudGljYXRlIGRhdGEnKVxuXG4gIHRoaXMuX2F1dGhUYWcgPSB0YWdcbiAgdGhpcy5fY2lwaGVyLnNjcnViKClcbn1cblxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5nZXRBdXRoVGFnID0gZnVuY3Rpb24gZ2V0QXV0aFRhZyAoKSB7XG4gIGlmICh0aGlzLl9kZWNyeXB0IHx8ICFCdWZmZXIuaXNCdWZmZXIodGhpcy5fYXV0aFRhZykpIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBnZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxuXG4gIHJldHVybiB0aGlzLl9hdXRoVGFnXG59XG5cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuc2V0QXV0aFRhZyA9IGZ1bmN0aW9uIHNldEF1dGhUYWcgKHRhZykge1xuICBpZiAoIXRoaXMuX2RlY3J5cHQpIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBzZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxuXG4gIHRoaXMuX2F1dGhUYWcgPSB0YWdcbn1cblxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5zZXRBQUQgPSBmdW5jdGlvbiBzZXRBQUQgKGJ1Zikge1xuICBpZiAodGhpcy5fY2FsbGVkKSB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRpbmcgdG8gc2V0IEFBRCBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG5cbiAgdGhpcy5fZ2hhc2gudXBkYXRlKGJ1ZilcbiAgdGhpcy5fYWxlbiArPSBidWYubGVuZ3RoXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtQ2lwaGVyXG4iLCJ2YXIgY2lwaGVycyA9IHJlcXVpcmUoJy4vZW5jcnlwdGVyJylcbnZhciBkZWNpcGhlcnMgPSByZXF1aXJlKCcuL2RlY3J5cHRlcicpXG52YXIgbW9kZXMgPSByZXF1aXJlKCcuL21vZGVzL2xpc3QuanNvbicpXG5cbmZ1bmN0aW9uIGdldENpcGhlcnMgKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMobW9kZXMpXG59XG5cbmV4cG9ydHMuY3JlYXRlQ2lwaGVyID0gZXhwb3J0cy5DaXBoZXIgPSBjaXBoZXJzLmNyZWF0ZUNpcGhlclxuZXhwb3J0cy5jcmVhdGVDaXBoZXJpdiA9IGV4cG9ydHMuQ2lwaGVyaXYgPSBjaXBoZXJzLmNyZWF0ZUNpcGhlcml2XG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyID0gZXhwb3J0cy5EZWNpcGhlciA9IGRlY2lwaGVycy5jcmVhdGVEZWNpcGhlclxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlcml2ID0gZXhwb3J0cy5EZWNpcGhlcml2ID0gZGVjaXBoZXJzLmNyZWF0ZURlY2lwaGVyaXZcbmV4cG9ydHMubGlzdENpcGhlcnMgPSBleHBvcnRzLmdldENpcGhlcnMgPSBnZXRDaXBoZXJzXG4iLCJ2YXIgQXV0aENpcGhlciA9IHJlcXVpcmUoJy4vYXV0aENpcGhlcicpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBNT0RFUyA9IHJlcXVpcmUoJy4vbW9kZXMnKVxudmFyIFN0cmVhbUNpcGhlciA9IHJlcXVpcmUoJy4vc3RyZWFtQ2lwaGVyJylcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIGVidGsgPSByZXF1aXJlKCdldnBfYnl0ZXN0b2tleScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbmZ1bmN0aW9uIERlY2lwaGVyIChtb2RlLCBrZXksIGl2KSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG5cbiAgdGhpcy5fY2FjaGUgPSBuZXcgU3BsaXR0ZXIoKVxuICB0aGlzLl9sYXN0ID0gdm9pZCAwXG4gIHRoaXMuX2NpcGhlciA9IG5ldyBhZXMuQUVTKGtleSlcbiAgdGhpcy5fcHJldiA9IEJ1ZmZlci5mcm9tKGl2KVxuICB0aGlzLl9tb2RlID0gbW9kZVxuICB0aGlzLl9hdXRvcGFkZGluZyA9IHRydWVcbn1cblxuaW5oZXJpdHMoRGVjaXBoZXIsIFRyYW5zZm9ybSlcblxuRGVjaXBoZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLl9jYWNoZS5hZGQoZGF0YSlcbiAgdmFyIGNodW5rXG4gIHZhciB0aGluZ1xuICB2YXIgb3V0ID0gW11cbiAgd2hpbGUgKChjaHVuayA9IHRoaXMuX2NhY2hlLmdldCh0aGlzLl9hdXRvcGFkZGluZykpKSB7XG4gICAgdGhpbmcgPSB0aGlzLl9tb2RlLmRlY3J5cHQodGhpcywgY2h1bmspXG4gICAgb3V0LnB1c2godGhpbmcpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQob3V0KVxufVxuXG5EZWNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2h1bmsgPSB0aGlzLl9jYWNoZS5mbHVzaCgpXG4gIGlmICh0aGlzLl9hdXRvcGFkZGluZykge1xuICAgIHJldHVybiB1bnBhZCh0aGlzLl9tb2RlLmRlY3J5cHQodGhpcywgY2h1bmspKVxuICB9IGVsc2UgaWYgKGNodW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhIG5vdCBtdWx0aXBsZSBvZiBibG9jayBsZW5ndGgnKVxuICB9XG59XG5cbkRlY2lwaGVyLnByb3RvdHlwZS5zZXRBdXRvUGFkZGluZyA9IGZ1bmN0aW9uIChzZXRUbykge1xuICB0aGlzLl9hdXRvcGFkZGluZyA9ICEhc2V0VG9cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gU3BsaXR0ZXIgKCkge1xuICB0aGlzLmNhY2hlID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG59XG5cblNwbGl0dGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmNhY2hlID0gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgZGF0YV0pXG59XG5cblNwbGl0dGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoYXV0b1BhZGRpbmcpIHtcbiAgdmFyIG91dFxuICBpZiAoYXV0b1BhZGRpbmcpIHtcbiAgICBpZiAodGhpcy5jYWNoZS5sZW5ndGggPiAxNikge1xuICAgICAgb3V0ID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlLnNsaWNlKDE2KVxuICAgICAgcmV0dXJuIG91dFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5jYWNoZS5sZW5ndGggPj0gMTYpIHtcbiAgICAgIG91dCA9IHRoaXMuY2FjaGUuc2xpY2UoMCwgMTYpXG4gICAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICAgIHJldHVybiBvdXRcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5TcGxpdHRlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNhY2hlLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2FjaGVcbn1cblxuZnVuY3Rpb24gdW5wYWQgKGxhc3QpIHtcbiAgdmFyIHBhZGRlZCA9IGxhc3RbMTVdXG4gIGlmIChwYWRkZWQgPCAxIHx8IHBhZGRlZCA+IDE2KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gZGVjcnlwdCBkYXRhJylcbiAgfVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBwYWRkZWQpIHtcbiAgICBpZiAobGFzdFsoaSArICgxNiAtIHBhZGRlZCkpXSAhPT0gcGFkZGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBkZWNyeXB0IGRhdGEnKVxuICAgIH1cbiAgfVxuICBpZiAocGFkZGVkID09PSAxNikgcmV0dXJuXG5cbiAgcmV0dXJuIGxhc3Quc2xpY2UoMCwgMTYgLSBwYWRkZWQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlY2lwaGVyaXYgKHN1aXRlLCBwYXNzd29yZCwgaXYpIHtcbiAgdmFyIGNvbmZpZyA9IE1PREVTW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuXG4gIGlmICh0eXBlb2YgaXYgPT09ICdzdHJpbmcnKSBpdiA9IEJ1ZmZlci5mcm9tKGl2KVxuICBpZiAoY29uZmlnLm1vZGUgIT09ICdHQ00nICYmIGl2Lmxlbmd0aCAhPT0gY29uZmlnLml2KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGl2IGxlbmd0aCAnICsgaXYubGVuZ3RoKVxuXG4gIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICdzdHJpbmcnKSBwYXNzd29yZCA9IEJ1ZmZlci5mcm9tKHBhc3N3b3JkKVxuICBpZiAocGFzc3dvcmQubGVuZ3RoICE9PSBjb25maWcua2V5IC8gOCkgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBrZXkgbGVuZ3RoICcgKyBwYXNzd29yZC5sZW5ndGgpXG5cbiAgaWYgKGNvbmZpZy50eXBlID09PSAnc3RyZWFtJykge1xuICAgIHJldHVybiBuZXcgU3RyZWFtQ2lwaGVyKGNvbmZpZy5tb2R1bGUsIHBhc3N3b3JkLCBpdiwgdHJ1ZSlcbiAgfSBlbHNlIGlmIChjb25maWcudHlwZSA9PT0gJ2F1dGgnKSB7XG4gICAgcmV0dXJuIG5ldyBBdXRoQ2lwaGVyKGNvbmZpZy5tb2R1bGUsIHBhc3N3b3JkLCBpdiwgdHJ1ZSlcbiAgfVxuXG4gIHJldHVybiBuZXcgRGVjaXBoZXIoY29uZmlnLm1vZHVsZSwgcGFzc3dvcmQsIGl2KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWNpcGhlciAoc3VpdGUsIHBhc3N3b3JkKSB7XG4gIHZhciBjb25maWcgPSBNT0RFU1tzdWl0ZS50b0xvd2VyQ2FzZSgpXVxuICBpZiAoIWNvbmZpZykgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcblxuICB2YXIga2V5cyA9IGVidGsocGFzc3dvcmQsIGZhbHNlLCBjb25maWcua2V5LCBjb25maWcuaXYpXG4gIHJldHVybiBjcmVhdGVEZWNpcGhlcml2KHN1aXRlLCBrZXlzLmtleSwga2V5cy5pdilcbn1cblxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlciA9IGNyZWF0ZURlY2lwaGVyXG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyaXYgPSBjcmVhdGVEZWNpcGhlcml2XG4iLCJ2YXIgTU9ERVMgPSByZXF1aXJlKCcuL21vZGVzJylcbnZhciBBdXRoQ2lwaGVyID0gcmVxdWlyZSgnLi9hdXRoQ2lwaGVyJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIFN0cmVhbUNpcGhlciA9IHJlcXVpcmUoJy4vc3RyZWFtQ2lwaGVyJylcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIGVidGsgPSByZXF1aXJlKCdldnBfYnl0ZXN0b2tleScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbmZ1bmN0aW9uIENpcGhlciAobW9kZSwga2V5LCBpdikge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuXG4gIHRoaXMuX2NhY2hlID0gbmV3IFNwbGl0dGVyKClcbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB0aGlzLl9wcmV2ID0gQnVmZmVyLmZyb20oaXYpXG4gIHRoaXMuX21vZGUgPSBtb2RlXG4gIHRoaXMuX2F1dG9wYWRkaW5nID0gdHJ1ZVxufVxuXG5pbmhlcml0cyhDaXBoZXIsIFRyYW5zZm9ybSlcblxuQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5fY2FjaGUuYWRkKGRhdGEpXG4gIHZhciBjaHVua1xuICB2YXIgdGhpbmdcbiAgdmFyIG91dCA9IFtdXG5cbiAgd2hpbGUgKChjaHVuayA9IHRoaXMuX2NhY2hlLmdldCgpKSkge1xuICAgIHRoaW5nID0gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rKVxuICAgIG91dC5wdXNoKHRoaW5nKVxuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQob3V0KVxufVxuXG52YXIgUEFERElORyA9IEJ1ZmZlci5hbGxvYygxNiwgMHgxMClcblxuQ2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjaHVuayA9IHRoaXMuX2NhY2hlLmZsdXNoKClcbiAgaWYgKHRoaXMuX2F1dG9wYWRkaW5nKSB7XG4gICAgY2h1bmsgPSB0aGlzLl9tb2RlLmVuY3J5cHQodGhpcywgY2h1bmspXG4gICAgdGhpcy5fY2lwaGVyLnNjcnViKClcbiAgICByZXR1cm4gY2h1bmtcbiAgfVxuXG4gIGlmICghY2h1bmsuZXF1YWxzKFBBRERJTkcpKSB7XG4gICAgdGhpcy5fY2lwaGVyLnNjcnViKClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgbm90IG11bHRpcGxlIG9mIGJsb2NrIGxlbmd0aCcpXG4gIH1cbn1cblxuQ2lwaGVyLnByb3RvdHlwZS5zZXRBdXRvUGFkZGluZyA9IGZ1bmN0aW9uIChzZXRUbykge1xuICB0aGlzLl9hdXRvcGFkZGluZyA9ICEhc2V0VG9cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gU3BsaXR0ZXIgKCkge1xuICB0aGlzLmNhY2hlID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG59XG5cblNwbGl0dGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmNhY2hlID0gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgZGF0YV0pXG59XG5cblNwbGl0dGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNhY2hlLmxlbmd0aCA+IDE1KSB7XG4gICAgdmFyIG91dCA9IHRoaXMuY2FjaGUuc2xpY2UoMCwgMTYpXG4gICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUuc2xpY2UoMTYpXG4gICAgcmV0dXJuIG91dFxuICB9XG4gIHJldHVybiBudWxsXG59XG5cblNwbGl0dGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxlbiA9IDE2IC0gdGhpcy5jYWNoZS5sZW5ndGhcbiAgdmFyIHBhZEJ1ZmYgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuKVxuXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHBhZEJ1ZmYud3JpdGVVSW50OChsZW4sIGkpXG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbdGhpcy5jYWNoZSwgcGFkQnVmZl0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNpcGhlcml2IChzdWl0ZSwgcGFzc3dvcmQsIGl2KSB7XG4gIHZhciBjb25maWcgPSBNT0RFU1tzdWl0ZS50b0xvd2VyQ2FzZSgpXVxuICBpZiAoIWNvbmZpZykgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcblxuICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAnc3RyaW5nJykgcGFzc3dvcmQgPSBCdWZmZXIuZnJvbShwYXNzd29yZClcbiAgaWYgKHBhc3N3b3JkLmxlbmd0aCAhPT0gY29uZmlnLmtleSAvIDgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQga2V5IGxlbmd0aCAnICsgcGFzc3dvcmQubGVuZ3RoKVxuXG4gIGlmICh0eXBlb2YgaXYgPT09ICdzdHJpbmcnKSBpdiA9IEJ1ZmZlci5mcm9tKGl2KVxuICBpZiAoY29uZmlnLm1vZGUgIT09ICdHQ00nICYmIGl2Lmxlbmd0aCAhPT0gY29uZmlnLml2KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGl2IGxlbmd0aCAnICsgaXYubGVuZ3RoKVxuXG4gIGlmIChjb25maWcudHlwZSA9PT0gJ3N0cmVhbScpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbUNpcGhlcihjb25maWcubW9kdWxlLCBwYXNzd29yZCwgaXYpXG4gIH0gZWxzZSBpZiAoY29uZmlnLnR5cGUgPT09ICdhdXRoJykge1xuICAgIHJldHVybiBuZXcgQXV0aENpcGhlcihjb25maWcubW9kdWxlLCBwYXNzd29yZCwgaXYpXG4gIH1cblxuICByZXR1cm4gbmV3IENpcGhlcihjb25maWcubW9kdWxlLCBwYXNzd29yZCwgaXYpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNpcGhlciAoc3VpdGUsIHBhc3N3b3JkKSB7XG4gIHZhciBjb25maWcgPSBNT0RFU1tzdWl0ZS50b0xvd2VyQ2FzZSgpXVxuICBpZiAoIWNvbmZpZykgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcblxuICB2YXIga2V5cyA9IGVidGsocGFzc3dvcmQsIGZhbHNlLCBjb25maWcua2V5LCBjb25maWcuaXYpXG4gIHJldHVybiBjcmVhdGVDaXBoZXJpdihzdWl0ZSwga2V5cy5rZXksIGtleXMuaXYpXG59XG5cbmV4cG9ydHMuY3JlYXRlQ2lwaGVyaXYgPSBjcmVhdGVDaXBoZXJpdlxuZXhwb3J0cy5jcmVhdGVDaXBoZXIgPSBjcmVhdGVDaXBoZXJcbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIFpFUk9FUyA9IEJ1ZmZlci5hbGxvYygxNiwgMClcblxuZnVuY3Rpb24gdG9BcnJheSAoYnVmKSB7XG4gIHJldHVybiBbXG4gICAgYnVmLnJlYWRVSW50MzJCRSgwKSxcbiAgICBidWYucmVhZFVJbnQzMkJFKDQpLFxuICAgIGJ1Zi5yZWFkVUludDMyQkUoOCksXG4gICAgYnVmLnJlYWRVSW50MzJCRSgxMilcbiAgXVxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXkgKG91dCkge1xuICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDE2KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMF0gPj4+IDAsIDApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsxXSA+Pj4gMCwgNClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzJdID4+PiAwLCA4KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbM10gPj4+IDAsIDEyKVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIEdIQVNIIChrZXkpIHtcbiAgdGhpcy5oID0ga2V5XG4gIHRoaXMuc3RhdGUgPSBCdWZmZXIuYWxsb2MoMTYsIDApXG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMClcbn1cblxuLy8gZnJvbSBodHRwOi8vYml0d2lzZXNoaWZ0bGVmdC5naXRodWIuaW8vc2pjbC9kb2Mvc3ltYm9scy9zcmMvY29yZV9nY20uanMuaHRtbFxuLy8gYnkgSnVobyBWw6Row6QtSGVydHR1YVxuR0hBU0gucHJvdG90eXBlLmdoYXNoID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGJsb2NrLmxlbmd0aCkge1xuICAgIHRoaXMuc3RhdGVbaV0gXj0gYmxvY2tbaV1cbiAgfVxuICB0aGlzLl9tdWx0aXBseSgpXG59XG5cbkdIQVNILnByb3RvdHlwZS5fbXVsdGlwbHkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBWaSA9IHRvQXJyYXkodGhpcy5oKVxuICB2YXIgWmkgPSBbMCwgMCwgMCwgMF1cbiAgdmFyIGosIHhpLCBsc2JWaVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCAxMjgpIHtcbiAgICB4aSA9ICh0aGlzLnN0YXRlW35+KGkgLyA4KV0gJiAoMSA8PCAoNyAtIChpICUgOCkpKSkgIT09IDBcbiAgICBpZiAoeGkpIHtcbiAgICAgIC8vIFpfaSsxID0gWl9pIF4gVl9pXG4gICAgICBaaVswXSBePSBWaVswXVxuICAgICAgWmlbMV0gXj0gVmlbMV1cbiAgICAgIFppWzJdIF49IFZpWzJdXG4gICAgICBaaVszXSBePSBWaVszXVxuICAgIH1cblxuICAgIC8vIFN0b3JlIHRoZSB2YWx1ZSBvZiBMU0IoVl9pKVxuICAgIGxzYlZpID0gKFZpWzNdICYgMSkgIT09IDBcblxuICAgIC8vIFZfaSsxID0gVl9pID4+IDFcbiAgICBmb3IgKGogPSAzOyBqID4gMDsgai0tKSB7XG4gICAgICBWaVtqXSA9IChWaVtqXSA+Pj4gMSkgfCAoKFZpW2ogLSAxXSAmIDEpIDw8IDMxKVxuICAgIH1cbiAgICBWaVswXSA9IFZpWzBdID4+PiAxXG5cbiAgICAvLyBJZiBMU0IoVl9pKSBpcyAxLCBWX2krMSA9IChWX2kgPj4gMSkgXiBSXG4gICAgaWYgKGxzYlZpKSB7XG4gICAgICBWaVswXSA9IFZpWzBdIF4gKDB4ZTEgPDwgMjQpXG4gICAgfVxuICB9XG4gIHRoaXMuc3RhdGUgPSBmcm9tQXJyYXkoWmkpXG59XG5cbkdIQVNILnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBidWZdKVxuICB2YXIgY2h1bmtcbiAgd2hpbGUgKHRoaXMuY2FjaGUubGVuZ3RoID49IDE2KSB7XG4gICAgY2h1bmsgPSB0aGlzLmNhY2hlLnNsaWNlKDAsIDE2KVxuICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlLnNsaWNlKDE2KVxuICAgIHRoaXMuZ2hhc2goY2h1bmspXG4gIH1cbn1cblxuR0hBU0gucHJvdG90eXBlLmZpbmFsID0gZnVuY3Rpb24gKGFibCwgYmwpIHtcbiAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoKSB7XG4gICAgdGhpcy5naGFzaChCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBaRVJPRVNdLCAxNikpXG4gIH1cblxuICB0aGlzLmdoYXNoKGZyb21BcnJheShbMCwgYWJsLCAwLCBibF0pKVxuICByZXR1cm4gdGhpcy5zdGF0ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdIQVNIXG4iLCJmdW5jdGlvbiBpbmNyMzIgKGl2KSB7XG4gIHZhciBsZW4gPSBpdi5sZW5ndGhcbiAgdmFyIGl0ZW1cbiAgd2hpbGUgKGxlbi0tKSB7XG4gICAgaXRlbSA9IGl2LnJlYWRVSW50OChsZW4pXG4gICAgaWYgKGl0ZW0gPT09IDI1NSkge1xuICAgICAgaXYud3JpdGVVSW50OCgwLCBsZW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW0rK1xuICAgICAgaXYud3JpdGVVSW50OChpdGVtLCBsZW4pXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbmNyMzJcbiIsInZhciB4b3IgPSByZXF1aXJlKCdidWZmZXIteG9yJylcblxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGJsb2NrKSB7XG4gIHZhciBkYXRhID0geG9yKGJsb2NrLCBzZWxmLl9wcmV2KVxuXG4gIHNlbGYuX3ByZXYgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKGRhdGEpXG4gIHJldHVybiBzZWxmLl9wcmV2XG59XG5cbmV4cG9ydHMuZGVjcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBibG9jaykge1xuICB2YXIgcGFkID0gc2VsZi5fcHJldlxuXG4gIHNlbGYuX3ByZXYgPSBibG9ja1xuICB2YXIgb3V0ID0gc2VsZi5fY2lwaGVyLmRlY3J5cHRCbG9jayhibG9jaylcblxuICByZXR1cm4geG9yKG91dCwgcGFkKVxufVxuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmZ1bmN0aW9uIGVuY3J5cHRTdGFydCAoc2VsZiwgZGF0YSwgZGVjcnlwdCkge1xuICB2YXIgbGVuID0gZGF0YS5sZW5ndGhcbiAgdmFyIG91dCA9IHhvcihkYXRhLCBzZWxmLl9jYWNoZSlcbiAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jYWNoZS5zbGljZShsZW4pXG4gIHNlbGYuX3ByZXYgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9wcmV2LCBkZWNyeXB0ID8gZGF0YSA6IG91dF0pXG4gIHJldHVybiBvdXRcbn1cblxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGRhdGEsIGRlY3J5cHQpIHtcbiAgdmFyIG91dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxuICB2YXIgbGVuXG5cbiAgd2hpbGUgKGRhdGEubGVuZ3RoKSB7XG4gICAgaWYgKHNlbGYuX2NhY2hlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gICAgICBzZWxmLl9wcmV2ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG4gICAgfVxuXG4gICAgaWYgKHNlbGYuX2NhY2hlLmxlbmd0aCA8PSBkYXRhLmxlbmd0aCkge1xuICAgICAgbGVuID0gc2VsZi5fY2FjaGUubGVuZ3RoXG4gICAgICBvdXQgPSBCdWZmZXIuY29uY2F0KFtvdXQsIGVuY3J5cHRTdGFydChzZWxmLCBkYXRhLnNsaWNlKDAsIGxlbiksIGRlY3J5cHQpXSlcbiAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKGxlbilcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbb3V0LCBlbmNyeXB0U3RhcnQoc2VsZiwgZGF0YSwgZGVjcnlwdCldKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0XG59XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuZnVuY3Rpb24gZW5jcnlwdEJ5dGUgKHNlbGYsIGJ5dGVQYXJhbSwgZGVjcnlwdCkge1xuICB2YXIgcGFkXG4gIHZhciBpID0gLTFcbiAgdmFyIGxlbiA9IDhcbiAgdmFyIG91dCA9IDBcbiAgdmFyIGJpdCwgdmFsdWVcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHBhZCA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgICBiaXQgPSAoYnl0ZVBhcmFtICYgKDEgPDwgKDcgLSBpKSkpID8gMHg4MCA6IDBcbiAgICB2YWx1ZSA9IHBhZFswXSBeIGJpdFxuICAgIG91dCArPSAoKHZhbHVlICYgMHg4MCkgPj4gKGkgJSA4KSlcbiAgICBzZWxmLl9wcmV2ID0gc2hpZnRJbihzZWxmLl9wcmV2LCBkZWNyeXB0ID8gYml0IDogdmFsdWUpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBzaGlmdEluIChidWZmZXIsIHZhbHVlKSB7XG4gIHZhciBsZW4gPSBidWZmZXIubGVuZ3RoXG4gIHZhciBpID0gLTFcbiAgdmFyIG91dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShidWZmZXIubGVuZ3RoKVxuICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtidWZmZXIsIEJ1ZmZlci5mcm9tKFt2YWx1ZV0pXSlcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgb3V0W2ldID0gYnVmZmVyW2ldIDw8IDEgfCBidWZmZXJbaSArIDFdID4+ICg3KVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgY2h1bmssIGRlY3J5cHQpIHtcbiAgdmFyIGxlbiA9IGNodW5rLmxlbmd0aFxuICB2YXIgb3V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbilcbiAgdmFyIGkgPSAtMVxuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXRbaV0gPSBlbmNyeXB0Qnl0ZShzZWxmLCBjaHVua1tpXSwgZGVjcnlwdClcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5mdW5jdGlvbiBlbmNyeXB0Qnl0ZSAoc2VsZiwgYnl0ZVBhcmFtLCBkZWNyeXB0KSB7XG4gIHZhciBwYWQgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gIHZhciBvdXQgPSBwYWRbMF0gXiBieXRlUGFyYW1cblxuICBzZWxmLl9wcmV2ID0gQnVmZmVyLmNvbmNhdChbXG4gICAgc2VsZi5fcHJldi5zbGljZSgxKSxcbiAgICBCdWZmZXIuZnJvbShbZGVjcnlwdCA/IGJ5dGVQYXJhbSA6IG91dF0pXG4gIF0pXG5cbiAgcmV0dXJuIG91dFxufVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgY2h1bmssIGRlY3J5cHQpIHtcbiAgdmFyIGxlbiA9IGNodW5rLmxlbmd0aFxuICB2YXIgb3V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbilcbiAgdmFyIGkgPSAtMVxuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXRbaV0gPSBlbmNyeXB0Qnl0ZShzZWxmLCBjaHVua1tpXSwgZGVjcnlwdClcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cbiIsInZhciB4b3IgPSByZXF1aXJlKCdidWZmZXIteG9yJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGluY3IzMiA9IHJlcXVpcmUoJy4uL2luY3IzMicpXG5cbmZ1bmN0aW9uIGdldEJsb2NrIChzZWxmKSB7XG4gIHZhciBvdXQgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrUmF3KHNlbGYuX3ByZXYpXG4gIGluY3IzMihzZWxmLl9wcmV2KVxuICByZXR1cm4gb3V0XG59XG5cbnZhciBibG9ja1NpemUgPSAxNlxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGNodW5rKSB7XG4gIHZhciBjaHVua051bSA9IE1hdGguY2VpbChjaHVuay5sZW5ndGggLyBibG9ja1NpemUpXG4gIHZhciBzdGFydCA9IHNlbGYuX2NhY2hlLmxlbmd0aFxuICBzZWxmLl9jYWNoZSA9IEJ1ZmZlci5jb25jYXQoW1xuICAgIHNlbGYuX2NhY2hlLFxuICAgIEJ1ZmZlci5hbGxvY1Vuc2FmZShjaHVua051bSAqIGJsb2NrU2l6ZSlcbiAgXSlcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaHVua051bTsgaSsrKSB7XG4gICAgdmFyIG91dCA9IGdldEJsb2NrKHNlbGYpXG4gICAgdmFyIG9mZnNldCA9IHN0YXJ0ICsgaSAqIGJsb2NrU2l6ZVxuICAgIHNlbGYuX2NhY2hlLndyaXRlVUludDMyQkUob3V0WzBdLCBvZmZzZXQgKyAwKVxuICAgIHNlbGYuX2NhY2hlLndyaXRlVUludDMyQkUob3V0WzFdLCBvZmZzZXQgKyA0KVxuICAgIHNlbGYuX2NhY2hlLndyaXRlVUludDMyQkUob3V0WzJdLCBvZmZzZXQgKyA4KVxuICAgIHNlbGYuX2NhY2hlLndyaXRlVUludDMyQkUob3V0WzNdLCBvZmZzZXQgKyAxMilcbiAgfVxuICB2YXIgcGFkID0gc2VsZi5fY2FjaGUuc2xpY2UoMCwgY2h1bmsubGVuZ3RoKVxuICBzZWxmLl9jYWNoZSA9IHNlbGYuX2NhY2hlLnNsaWNlKGNodW5rLmxlbmd0aClcbiAgcmV0dXJuIHhvcihjaHVuaywgcGFkKVxufVxuIiwiZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGJsb2NrKSB7XG4gIHJldHVybiBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKGJsb2NrKVxufVxuXG5leHBvcnRzLmRlY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgYmxvY2spIHtcbiAgcmV0dXJuIHNlbGYuX2NpcGhlci5kZWNyeXB0QmxvY2soYmxvY2spXG59XG4iLCJ2YXIgbW9kZU1vZHVsZXMgPSB7XG4gIEVDQjogcmVxdWlyZSgnLi9lY2InKSxcbiAgQ0JDOiByZXF1aXJlKCcuL2NiYycpLFxuICBDRkI6IHJlcXVpcmUoJy4vY2ZiJyksXG4gIENGQjg6IHJlcXVpcmUoJy4vY2ZiOCcpLFxuICBDRkIxOiByZXF1aXJlKCcuL2NmYjEnKSxcbiAgT0ZCOiByZXF1aXJlKCcuL29mYicpLFxuICBDVFI6IHJlcXVpcmUoJy4vY3RyJyksXG4gIEdDTTogcmVxdWlyZSgnLi9jdHInKVxufVxuXG52YXIgbW9kZXMgPSByZXF1aXJlKCcuL2xpc3QuanNvbicpXG5cbmZvciAodmFyIGtleSBpbiBtb2Rlcykge1xuICBtb2Rlc1trZXldLm1vZHVsZSA9IG1vZGVNb2R1bGVzW21vZGVzW2tleV0ubW9kZV1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtb2Rlc1xuIiwidmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuXG5mdW5jdGlvbiBnZXRCbG9jayAoc2VsZikge1xuICBzZWxmLl9wcmV2ID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICByZXR1cm4gc2VsZi5fcHJldlxufVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgY2h1bmspIHtcbiAgd2hpbGUgKHNlbGYuX2NhY2hlLmxlbmd0aCA8IGNodW5rLmxlbmd0aCkge1xuICAgIHNlbGYuX2NhY2hlID0gQnVmZmVyLmNvbmNhdChbc2VsZi5fY2FjaGUsIGdldEJsb2NrKHNlbGYpXSlcbiAgfVxuXG4gIHZhciBwYWQgPSBzZWxmLl9jYWNoZS5zbGljZSgwLCBjaHVuay5sZW5ndGgpXG4gIHNlbGYuX2NhY2hlID0gc2VsZi5fY2FjaGUuc2xpY2UoY2h1bmsubGVuZ3RoKVxuICByZXR1cm4geG9yKGNodW5rLCBwYWQpXG59XG4iLCJ2YXIgYWVzID0gcmVxdWlyZSgnLi9hZXMnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5mdW5jdGlvbiBTdHJlYW1DaXBoZXIgKG1vZGUsIGtleSwgaXYsIGRlY3J5cHQpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcblxuICB0aGlzLl9jaXBoZXIgPSBuZXcgYWVzLkFFUyhrZXkpXG4gIHRoaXMuX3ByZXYgPSBCdWZmZXIuZnJvbShpdilcbiAgdGhpcy5fY2FjaGUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMClcbiAgdGhpcy5fc2VjQ2FjaGUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMClcbiAgdGhpcy5fZGVjcnlwdCA9IGRlY3J5cHRcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbn1cblxuaW5oZXJpdHMoU3RyZWFtQ2lwaGVyLCBUcmFuc2Zvcm0pXG5cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gdGhpcy5fbW9kZS5lbmNyeXB0KHRoaXMsIGNodW5rLCB0aGlzLl9kZWNyeXB0KVxufVxuXG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fY2lwaGVyLnNjcnViKClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW1DaXBoZXJcbiIsInZhciBERVMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWRlcycpXG52YXIgYWVzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1hZXMvYnJvd3NlcicpXG52YXIgYWVzTW9kZXMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWFlcy9tb2RlcycpXG52YXIgZGVzTW9kZXMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWRlcy9tb2RlcycpXG52YXIgZWJ0ayA9IHJlcXVpcmUoJ2V2cF9ieXRlc3Rva2V5JylcblxuZnVuY3Rpb24gY3JlYXRlQ2lwaGVyIChzdWl0ZSwgcGFzc3dvcmQpIHtcbiAgc3VpdGUgPSBzdWl0ZS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIGtleUxlbiwgaXZMZW5cbiAgaWYgKGFlc01vZGVzW3N1aXRlXSkge1xuICAgIGtleUxlbiA9IGFlc01vZGVzW3N1aXRlXS5rZXlcbiAgICBpdkxlbiA9IGFlc01vZGVzW3N1aXRlXS5pdlxuICB9IGVsc2UgaWYgKGRlc01vZGVzW3N1aXRlXSkge1xuICAgIGtleUxlbiA9IGRlc01vZGVzW3N1aXRlXS5rZXkgKiA4XG4gICAgaXZMZW4gPSBkZXNNb2Rlc1tzdWl0ZV0uaXZcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuICB9XG5cbiAgdmFyIGtleXMgPSBlYnRrKHBhc3N3b3JkLCBmYWxzZSwga2V5TGVuLCBpdkxlbilcbiAgcmV0dXJuIGNyZWF0ZUNpcGhlcml2KHN1aXRlLCBrZXlzLmtleSwga2V5cy5pdilcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVjaXBoZXIgKHN1aXRlLCBwYXNzd29yZCkge1xuICBzdWl0ZSA9IHN1aXRlLnRvTG93ZXJDYXNlKClcblxuICB2YXIga2V5TGVuLCBpdkxlblxuICBpZiAoYWVzTW9kZXNbc3VpdGVdKSB7XG4gICAga2V5TGVuID0gYWVzTW9kZXNbc3VpdGVdLmtleVxuICAgIGl2TGVuID0gYWVzTW9kZXNbc3VpdGVdLml2XG4gIH0gZWxzZSBpZiAoZGVzTW9kZXNbc3VpdGVdKSB7XG4gICAga2V5TGVuID0gZGVzTW9kZXNbc3VpdGVdLmtleSAqIDhcbiAgICBpdkxlbiA9IGRlc01vZGVzW3N1aXRlXS5pdlxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG4gIH1cblxuICB2YXIga2V5cyA9IGVidGsocGFzc3dvcmQsIGZhbHNlLCBrZXlMZW4sIGl2TGVuKVxuICByZXR1cm4gY3JlYXRlRGVjaXBoZXJpdihzdWl0ZSwga2V5cy5rZXksIGtleXMuaXYpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNpcGhlcml2IChzdWl0ZSwga2V5LCBpdikge1xuICBzdWl0ZSA9IHN1aXRlLnRvTG93ZXJDYXNlKClcbiAgaWYgKGFlc01vZGVzW3N1aXRlXSkgcmV0dXJuIGFlcy5jcmVhdGVDaXBoZXJpdihzdWl0ZSwga2V5LCBpdilcbiAgaWYgKGRlc01vZGVzW3N1aXRlXSkgcmV0dXJuIG5ldyBERVMoeyBrZXk6IGtleSwgaXY6IGl2LCBtb2RlOiBzdWl0ZSB9KVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlY2lwaGVyaXYgKHN1aXRlLCBrZXksIGl2KSB7XG4gIHN1aXRlID0gc3VpdGUudG9Mb3dlckNhc2UoKVxuICBpZiAoYWVzTW9kZXNbc3VpdGVdKSByZXR1cm4gYWVzLmNyZWF0ZURlY2lwaGVyaXYoc3VpdGUsIGtleSwgaXYpXG4gIGlmIChkZXNNb2Rlc1tzdWl0ZV0pIHJldHVybiBuZXcgREVTKHsga2V5OiBrZXksIGl2OiBpdiwgbW9kZTogc3VpdGUsIGRlY3J5cHQ6IHRydWUgfSlcblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxufVxuXG5mdW5jdGlvbiBnZXRDaXBoZXJzICgpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGRlc01vZGVzKS5jb25jYXQoYWVzLmdldENpcGhlcnMoKSlcbn1cblxuZXhwb3J0cy5jcmVhdGVDaXBoZXIgPSBleHBvcnRzLkNpcGhlciA9IGNyZWF0ZUNpcGhlclxuZXhwb3J0cy5jcmVhdGVDaXBoZXJpdiA9IGV4cG9ydHMuQ2lwaGVyaXYgPSBjcmVhdGVDaXBoZXJpdlxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlciA9IGV4cG9ydHMuRGVjaXBoZXIgPSBjcmVhdGVEZWNpcGhlclxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlcml2ID0gZXhwb3J0cy5EZWNpcGhlcml2ID0gY3JlYXRlRGVjaXBoZXJpdlxuZXhwb3J0cy5saXN0Q2lwaGVycyA9IGV4cG9ydHMuZ2V0Q2lwaGVycyA9IGdldENpcGhlcnNcbiIsInZhciBDaXBoZXJCYXNlID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxudmFyIGRlcyA9IHJlcXVpcmUoJ2Rlcy5qcycpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIG1vZGVzID0ge1xuICAnZGVzLWVkZTMtY2JjJzogZGVzLkNCQy5pbnN0YW50aWF0ZShkZXMuRURFKSxcbiAgJ2Rlcy1lZGUzJzogZGVzLkVERSxcbiAgJ2Rlcy1lZGUtY2JjJzogZGVzLkNCQy5pbnN0YW50aWF0ZShkZXMuRURFKSxcbiAgJ2Rlcy1lZGUnOiBkZXMuRURFLFxuICAnZGVzLWNiYyc6IGRlcy5DQkMuaW5zdGFudGlhdGUoZGVzLkRFUyksXG4gICdkZXMtZWNiJzogZGVzLkRFU1xufVxubW9kZXMuZGVzID0gbW9kZXNbJ2Rlcy1jYmMnXVxubW9kZXMuZGVzMyA9IG1vZGVzWydkZXMtZWRlMy1jYmMnXVxubW9kdWxlLmV4cG9ydHMgPSBERVNcbmluaGVyaXRzKERFUywgQ2lwaGVyQmFzZSlcbmZ1bmN0aW9uIERFUyAob3B0cykge1xuICBDaXBoZXJCYXNlLmNhbGwodGhpcylcbiAgdmFyIG1vZGVOYW1lID0gb3B0cy5tb2RlLnRvTG93ZXJDYXNlKClcbiAgdmFyIG1vZGUgPSBtb2Rlc1ttb2RlTmFtZV1cbiAgdmFyIHR5cGVcbiAgaWYgKG9wdHMuZGVjcnlwdCkge1xuICAgIHR5cGUgPSAnZGVjcnlwdCdcbiAgfSBlbHNlIHtcbiAgICB0eXBlID0gJ2VuY3J5cHQnXG4gIH1cbiAgdmFyIGtleSA9IG9wdHMua2V5XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGtleSkpIHtcbiAgICBrZXkgPSBCdWZmZXIuZnJvbShrZXkpXG4gIH1cbiAgaWYgKG1vZGVOYW1lID09PSAnZGVzLWVkZScgfHwgbW9kZU5hbWUgPT09ICdkZXMtZWRlLWNiYycpIHtcbiAgICBrZXkgPSBCdWZmZXIuY29uY2F0KFtrZXksIGtleS5zbGljZSgwLCA4KV0pXG4gIH1cbiAgdmFyIGl2ID0gb3B0cy5pdlxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihpdikpIHtcbiAgICBpdiA9IEJ1ZmZlci5mcm9tKGl2KVxuICB9XG4gIHRoaXMuX2RlcyA9IG1vZGUuY3JlYXRlKHtcbiAgICBrZXk6IGtleSxcbiAgICBpdjogaXYsXG4gICAgdHlwZTogdHlwZVxuICB9KVxufVxuREVTLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMuX2Rlcy51cGRhdGUoZGF0YSkpXG59XG5ERVMucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMuX2Rlcy5maW5hbCgpKVxufVxuIiwiZXhwb3J0c1snZGVzLWVjYiddID0ge1xuICBrZXk6IDgsXG4gIGl2OiAwXG59XG5leHBvcnRzWydkZXMtY2JjJ10gPSBleHBvcnRzLmRlcyA9IHtcbiAga2V5OiA4LFxuICBpdjogOFxufVxuZXhwb3J0c1snZGVzLWVkZTMtY2JjJ10gPSBleHBvcnRzLmRlczMgPSB7XG4gIGtleTogMjQsXG4gIGl2OiA4XG59XG5leHBvcnRzWydkZXMtZWRlMyddID0ge1xuICBrZXk6IDI0LFxuICBpdjogMFxufVxuZXhwb3J0c1snZGVzLWVkZS1jYmMnXSA9IHtcbiAga2V5OiAxNixcbiAgaXY6IDhcbn1cbmV4cG9ydHNbJ2Rlcy1lZGUnXSA9IHtcbiAga2V5OiAxNixcbiAgaXY6IDBcbn1cbiIsInZhciBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpO1xubW9kdWxlLmV4cG9ydHMgPSBjcnQ7XG5mdW5jdGlvbiBibGluZChwcml2KSB7XG4gIHZhciByID0gZ2V0cihwcml2KTtcbiAgdmFyIGJsaW5kZXIgPSByLnRvUmVkKGJuLm1vbnQocHJpdi5tb2R1bHVzKSlcbiAgLnJlZFBvdyhuZXcgYm4ocHJpdi5wdWJsaWNFeHBvbmVudCkpLmZyb21SZWQoKTtcbiAgcmV0dXJuIHtcbiAgICBibGluZGVyOiBibGluZGVyLFxuICAgIHVuYmxpbmRlcjpyLmludm0ocHJpdi5tb2R1bHVzKVxuICB9O1xufVxuZnVuY3Rpb24gY3J0KG1zZywgcHJpdikge1xuICB2YXIgYmxpbmRzID0gYmxpbmQocHJpdik7XG4gIHZhciBsZW4gPSBwcml2Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICB2YXIgbW9kID0gYm4ubW9udChwcml2Lm1vZHVsdXMpO1xuICB2YXIgYmxpbmRlZCA9IG5ldyBibihtc2cpLm11bChibGluZHMuYmxpbmRlcikudW1vZChwcml2Lm1vZHVsdXMpO1xuICB2YXIgYzEgPSBibGluZGVkLnRvUmVkKGJuLm1vbnQocHJpdi5wcmltZTEpKTtcbiAgdmFyIGMyID0gYmxpbmRlZC50b1JlZChibi5tb250KHByaXYucHJpbWUyKSk7XG4gIHZhciBxaW52ID0gcHJpdi5jb2VmZmljaWVudDtcbiAgdmFyIHAgPSBwcml2LnByaW1lMTtcbiAgdmFyIHEgPSBwcml2LnByaW1lMjtcbiAgdmFyIG0xID0gYzEucmVkUG93KHByaXYuZXhwb25lbnQxKTtcbiAgdmFyIG0yID0gYzIucmVkUG93KHByaXYuZXhwb25lbnQyKTtcbiAgbTEgPSBtMS5mcm9tUmVkKCk7XG4gIG0yID0gbTIuZnJvbVJlZCgpO1xuICB2YXIgaCA9IG0xLmlzdWIobTIpLmltdWwocWludikudW1vZChwKTtcbiAgaC5pbXVsKHEpO1xuICBtMi5pYWRkKGgpO1xuICByZXR1cm4gbmV3IEJ1ZmZlcihtMi5pbXVsKGJsaW5kcy51bmJsaW5kZXIpLnVtb2QocHJpdi5tb2R1bHVzKS50b0FycmF5KGZhbHNlLCBsZW4pKTtcbn1cbmNydC5nZXRyID0gZ2V0cjtcbmZ1bmN0aW9uIGdldHIocHJpdikge1xuICB2YXIgbGVuID0gcHJpdi5tb2R1bHVzLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIHIgPSBuZXcgYm4ocmFuZG9tQnl0ZXMobGVuKSk7XG4gIHdoaWxlIChyLmNtcChwcml2Lm1vZHVsdXMpID49ICAwIHx8ICFyLnVtb2QocHJpdi5wcmltZTEpIHx8ICFyLnVtb2QocHJpdi5wcmltZTIpKSB7XG4gICAgciA9IG5ldyBibihyYW5kb21CeXRlcyhsZW4pKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9icm93c2VyL2FsZ29yaXRobXMuanNvbicpXG4iLCJ2YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIHNpZ24gPSByZXF1aXJlKCcuL3NpZ24nKVxudmFyIHZlcmlmeSA9IHJlcXVpcmUoJy4vdmVyaWZ5JylcblxudmFyIGFsZ29yaXRobXMgPSByZXF1aXJlKCcuL2FsZ29yaXRobXMuanNvbicpXG5PYmplY3Qua2V5cyhhbGdvcml0aG1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgYWxnb3JpdGhtc1trZXldLmlkID0gbmV3IEJ1ZmZlcihhbGdvcml0aG1zW2tleV0uaWQsICdoZXgnKVxuICBhbGdvcml0aG1zW2tleS50b0xvd2VyQ2FzZSgpXSA9IGFsZ29yaXRobXNba2V5XVxufSlcblxuZnVuY3Rpb24gU2lnbiAoYWxnb3JpdGhtKSB7XG4gIHN0cmVhbS5Xcml0YWJsZS5jYWxsKHRoaXMpXG5cbiAgdmFyIGRhdGEgPSBhbGdvcml0aG1zW2FsZ29yaXRobV1cbiAgaWYgKCFkYXRhKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbWVzc2FnZSBkaWdlc3QnKVxuXG4gIHRoaXMuX2hhc2hUeXBlID0gZGF0YS5oYXNoXG4gIHRoaXMuX2hhc2ggPSBjcmVhdGVIYXNoKGRhdGEuaGFzaClcbiAgdGhpcy5fdGFnID0gZGF0YS5pZFxuICB0aGlzLl9zaWduVHlwZSA9IGRhdGEuc2lnblxufVxuaW5oZXJpdHMoU2lnbiwgc3RyZWFtLldyaXRhYmxlKVxuXG5TaWduLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiBfd3JpdGUgKGRhdGEsIF8sIGRvbmUpIHtcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcbiAgZG9uZSgpXG59XG5cblNpZ24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoZGF0YSwgZW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIGRhdGEgPSBuZXcgQnVmZmVyKGRhdGEsIGVuYylcblxuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxuICByZXR1cm4gdGhpc1xufVxuXG5TaWduLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbk1ldGhvZCAoa2V5LCBlbmMpIHtcbiAgdGhpcy5lbmQoKVxuICB2YXIgaGFzaCA9IHRoaXMuX2hhc2guZGlnZXN0KClcbiAgdmFyIHNpZyA9IHNpZ24oaGFzaCwga2V5LCB0aGlzLl9oYXNoVHlwZSwgdGhpcy5fc2lnblR5cGUsIHRoaXMuX3RhZylcblxuICByZXR1cm4gZW5jID8gc2lnLnRvU3RyaW5nKGVuYykgOiBzaWdcbn1cblxuZnVuY3Rpb24gVmVyaWZ5IChhbGdvcml0aG0pIHtcbiAgc3RyZWFtLldyaXRhYmxlLmNhbGwodGhpcylcblxuICB2YXIgZGF0YSA9IGFsZ29yaXRobXNbYWxnb3JpdGhtXVxuICBpZiAoIWRhdGEpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtZXNzYWdlIGRpZ2VzdCcpXG5cbiAgdGhpcy5faGFzaCA9IGNyZWF0ZUhhc2goZGF0YS5oYXNoKVxuICB0aGlzLl90YWcgPSBkYXRhLmlkXG4gIHRoaXMuX3NpZ25UeXBlID0gZGF0YS5zaWduXG59XG5pbmhlcml0cyhWZXJpZnksIHN0cmVhbS5Xcml0YWJsZSlcblxuVmVyaWZ5LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiBfd3JpdGUgKGRhdGEsIF8sIGRvbmUpIHtcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcbiAgZG9uZSgpXG59XG5cblZlcmlmeS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChkYXRhLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgZW5jKVxuXG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG4gIHJldHVybiB0aGlzXG59XG5cblZlcmlmeS5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5TWV0aG9kIChrZXksIHNpZywgZW5jKSB7XG4gIGlmICh0eXBlb2Ygc2lnID09PSAnc3RyaW5nJykgc2lnID0gbmV3IEJ1ZmZlcihzaWcsIGVuYylcblxuICB0aGlzLmVuZCgpXG4gIHZhciBoYXNoID0gdGhpcy5faGFzaC5kaWdlc3QoKVxuICByZXR1cm4gdmVyaWZ5KHNpZywgaGFzaCwga2V5LCB0aGlzLl9zaWduVHlwZSwgdGhpcy5fdGFnKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTaWduIChhbGdvcml0aG0pIHtcbiAgcmV0dXJuIG5ldyBTaWduKGFsZ29yaXRobSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVmVyaWZ5IChhbGdvcml0aG0pIHtcbiAgcmV0dXJuIG5ldyBWZXJpZnkoYWxnb3JpdGhtKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgU2lnbjogY3JlYXRlU2lnbixcbiAgVmVyaWZ5OiBjcmVhdGVWZXJpZnksXG4gIGNyZWF0ZVNpZ246IGNyZWF0ZVNpZ24sXG4gIGNyZWF0ZVZlcmlmeTogY3JlYXRlVmVyaWZ5XG59XG4iLCIvLyBtdWNoIG9mIHRoaXMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvc2VsZi1zaWduZWQvYmxvYi9naC1wYWdlcy9saWIvcnNhLmpzXG52YXIgY3JlYXRlSG1hYyA9IHJlcXVpcmUoJ2NyZWF0ZS1obWFjJylcbnZhciBjcnQgPSByZXF1aXJlKCdicm93c2VyaWZ5LXJzYScpXG52YXIgRUMgPSByZXF1aXJlKCdlbGxpcHRpYycpLmVjXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG52YXIgcGFyc2VLZXlzID0gcmVxdWlyZSgncGFyc2UtYXNuMScpXG52YXIgY3VydmVzID0gcmVxdWlyZSgnLi9jdXJ2ZXMuanNvbicpXG5cbmZ1bmN0aW9uIHNpZ24gKGhhc2gsIGtleSwgaGFzaFR5cGUsIHNpZ25UeXBlLCB0YWcpIHtcbiAgdmFyIHByaXYgPSBwYXJzZUtleXMoa2V5KVxuICBpZiAocHJpdi5jdXJ2ZSkge1xuICAgIC8vIHJzYSBrZXlzIGNhbiBiZSBpbnRlcnByZXRlZCBhcyBlY2RzYSBvbmVzIGluIG9wZW5zc2xcbiAgICBpZiAoc2lnblR5cGUgIT09ICdlY2RzYScgJiYgc2lnblR5cGUgIT09ICdlY2RzYS9yc2EnKSB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHByaXZhdGUga2V5IHR5cGUnKVxuICAgIHJldHVybiBlY1NpZ24oaGFzaCwgcHJpdilcbiAgfSBlbHNlIGlmIChwcml2LnR5cGUgPT09ICdkc2EnKSB7XG4gICAgaWYgKHNpZ25UeXBlICE9PSAnZHNhJykgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwcml2YXRlIGtleSB0eXBlJylcbiAgICByZXR1cm4gZHNhU2lnbihoYXNoLCBwcml2LCBoYXNoVHlwZSlcbiAgfSBlbHNlIHtcbiAgICBpZiAoc2lnblR5cGUgIT09ICdyc2EnICYmIHNpZ25UeXBlICE9PSAnZWNkc2EvcnNhJykgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwcml2YXRlIGtleSB0eXBlJylcbiAgfVxuICBoYXNoID0gQnVmZmVyLmNvbmNhdChbdGFnLCBoYXNoXSlcbiAgdmFyIGxlbiA9IHByaXYubW9kdWx1cy5ieXRlTGVuZ3RoKClcbiAgdmFyIHBhZCA9IFsgMCwgMSBdXG4gIHdoaWxlIChoYXNoLmxlbmd0aCArIHBhZC5sZW5ndGggKyAxIDwgbGVuKSBwYWQucHVzaCgweGZmKVxuICBwYWQucHVzaCgweDAwKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBoYXNoLmxlbmd0aCkgcGFkLnB1c2goaGFzaFtpXSlcblxuICB2YXIgb3V0ID0gY3J0KHBhZCwgcHJpdilcbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBlY1NpZ24gKGhhc2gsIHByaXYpIHtcbiAgdmFyIGN1cnZlSWQgPSBjdXJ2ZXNbcHJpdi5jdXJ2ZS5qb2luKCcuJyldXG4gIGlmICghY3VydmVJZCkgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGN1cnZlICcgKyBwcml2LmN1cnZlLmpvaW4oJy4nKSlcblxuICB2YXIgY3VydmUgPSBuZXcgRUMoY3VydmVJZClcbiAgdmFyIGtleSA9IGN1cnZlLmtleUZyb21Qcml2YXRlKHByaXYucHJpdmF0ZUtleSlcbiAgdmFyIG91dCA9IGtleS5zaWduKGhhc2gpXG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIob3V0LnRvREVSKCkpXG59XG5cbmZ1bmN0aW9uIGRzYVNpZ24gKGhhc2gsIHByaXYsIGFsZ28pIHtcbiAgdmFyIHggPSBwcml2LnBhcmFtcy5wcml2X2tleVxuICB2YXIgcCA9IHByaXYucGFyYW1zLnBcbiAgdmFyIHEgPSBwcml2LnBhcmFtcy5xXG4gIHZhciBnID0gcHJpdi5wYXJhbXMuZ1xuICB2YXIgciA9IG5ldyBCTigwKVxuICB2YXIga1xuICB2YXIgSCA9IGJpdHMyaW50KGhhc2gsIHEpLm1vZChxKVxuICB2YXIgcyA9IGZhbHNlXG4gIHZhciBrdiA9IGdldEtleSh4LCBxLCBoYXNoLCBhbGdvKVxuICB3aGlsZSAocyA9PT0gZmFsc2UpIHtcbiAgICBrID0gbWFrZUtleShxLCBrdiwgYWxnbylcbiAgICByID0gbWFrZVIoZywgaywgcCwgcSlcbiAgICBzID0gay5pbnZtKHEpLmltdWwoSC5hZGQoeC5tdWwocikpKS5tb2QocSlcbiAgICBpZiAocy5jbXBuKDApID09PSAwKSB7XG4gICAgICBzID0gZmFsc2VcbiAgICAgIHIgPSBuZXcgQk4oMClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvREVSKHIsIHMpXG59XG5cbmZ1bmN0aW9uIHRvREVSIChyLCBzKSB7XG4gIHIgPSByLnRvQXJyYXkoKVxuICBzID0gcy50b0FycmF5KClcblxuICAvLyBQYWQgdmFsdWVzXG4gIGlmIChyWzBdICYgMHg4MCkgciA9IFsgMCBdLmNvbmNhdChyKVxuICBpZiAoc1swXSAmIDB4ODApIHMgPSBbIDAgXS5jb25jYXQocylcblxuICB2YXIgdG90YWwgPSByLmxlbmd0aCArIHMubGVuZ3RoICsgNFxuICB2YXIgcmVzID0gWyAweDMwLCB0b3RhbCwgMHgwMiwgci5sZW5ndGggXVxuICByZXMgPSByZXMuY29uY2F0KHIsIFsgMHgwMiwgcy5sZW5ndGggXSwgcylcbiAgcmV0dXJuIG5ldyBCdWZmZXIocmVzKVxufVxuXG5mdW5jdGlvbiBnZXRLZXkgKHgsIHEsIGhhc2gsIGFsZ28pIHtcbiAgeCA9IG5ldyBCdWZmZXIoeC50b0FycmF5KCkpXG4gIGlmICh4Lmxlbmd0aCA8IHEuYnl0ZUxlbmd0aCgpKSB7XG4gICAgdmFyIHplcm9zID0gbmV3IEJ1ZmZlcihxLmJ5dGVMZW5ndGgoKSAtIHgubGVuZ3RoKVxuICAgIHplcm9zLmZpbGwoMClcbiAgICB4ID0gQnVmZmVyLmNvbmNhdChbIHplcm9zLCB4IF0pXG4gIH1cbiAgdmFyIGhsZW4gPSBoYXNoLmxlbmd0aFxuICB2YXIgaGJpdHMgPSBiaXRzMm9jdGV0cyhoYXNoLCBxKVxuICB2YXIgdiA9IG5ldyBCdWZmZXIoaGxlbilcbiAgdi5maWxsKDEpXG4gIHZhciBrID0gbmV3IEJ1ZmZlcihobGVuKVxuICBrLmZpbGwoMClcbiAgayA9IGNyZWF0ZUhtYWMoYWxnbywgaykudXBkYXRlKHYpLnVwZGF0ZShuZXcgQnVmZmVyKFsgMCBdKSkudXBkYXRlKHgpLnVwZGF0ZShoYml0cykuZGlnZXN0KClcbiAgdiA9IGNyZWF0ZUhtYWMoYWxnbywgaykudXBkYXRlKHYpLmRpZ2VzdCgpXG4gIGsgPSBjcmVhdGVIbWFjKGFsZ28sIGspLnVwZGF0ZSh2KS51cGRhdGUobmV3IEJ1ZmZlcihbIDEgXSkpLnVwZGF0ZSh4KS51cGRhdGUoaGJpdHMpLmRpZ2VzdCgpXG4gIHYgPSBjcmVhdGVIbWFjKGFsZ28sIGspLnVwZGF0ZSh2KS5kaWdlc3QoKVxuICByZXR1cm4geyBrOiBrLCB2OiB2IH1cbn1cblxuZnVuY3Rpb24gYml0czJpbnQgKG9iaXRzLCBxKSB7XG4gIHZhciBiaXRzID0gbmV3IEJOKG9iaXRzKVxuICB2YXIgc2hpZnQgPSAob2JpdHMubGVuZ3RoIDw8IDMpIC0gcS5iaXRMZW5ndGgoKVxuICBpZiAoc2hpZnQgPiAwKSBiaXRzLmlzaHJuKHNoaWZ0KVxuICByZXR1cm4gYml0c1xufVxuXG5mdW5jdGlvbiBiaXRzMm9jdGV0cyAoYml0cywgcSkge1xuICBiaXRzID0gYml0czJpbnQoYml0cywgcSlcbiAgYml0cyA9IGJpdHMubW9kKHEpXG4gIHZhciBvdXQgPSBuZXcgQnVmZmVyKGJpdHMudG9BcnJheSgpKVxuICBpZiAob3V0Lmxlbmd0aCA8IHEuYnl0ZUxlbmd0aCgpKSB7XG4gICAgdmFyIHplcm9zID0gbmV3IEJ1ZmZlcihxLmJ5dGVMZW5ndGgoKSAtIG91dC5sZW5ndGgpXG4gICAgemVyb3MuZmlsbCgwKVxuICAgIG91dCA9IEJ1ZmZlci5jb25jYXQoWyB6ZXJvcywgb3V0IF0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBtYWtlS2V5IChxLCBrdiwgYWxnbykge1xuICB2YXIgdFxuICB2YXIga1xuXG4gIGRvIHtcbiAgICB0ID0gbmV3IEJ1ZmZlcigwKVxuXG4gICAgd2hpbGUgKHQubGVuZ3RoICogOCA8IHEuYml0TGVuZ3RoKCkpIHtcbiAgICAgIGt2LnYgPSBjcmVhdGVIbWFjKGFsZ28sIGt2LmspLnVwZGF0ZShrdi52KS5kaWdlc3QoKVxuICAgICAgdCA9IEJ1ZmZlci5jb25jYXQoWyB0LCBrdi52IF0pXG4gICAgfVxuXG4gICAgayA9IGJpdHMyaW50KHQsIHEpXG4gICAga3YuayA9IGNyZWF0ZUhtYWMoYWxnbywga3YuaykudXBkYXRlKGt2LnYpLnVwZGF0ZShuZXcgQnVmZmVyKFsgMCBdKSkuZGlnZXN0KClcbiAgICBrdi52ID0gY3JlYXRlSG1hYyhhbGdvLCBrdi5rKS51cGRhdGUoa3YudikuZGlnZXN0KClcbiAgfSB3aGlsZSAoay5jbXAocSkgIT09IC0xKVxuXG4gIHJldHVybiBrXG59XG5cbmZ1bmN0aW9uIG1ha2VSIChnLCBrLCBwLCBxKSB7XG4gIHJldHVybiBnLnRvUmVkKEJOLm1vbnQocCkpLnJlZFBvdyhrKS5mcm9tUmVkKCkubW9kKHEpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2lnblxubW9kdWxlLmV4cG9ydHMuZ2V0S2V5ID0gZ2V0S2V5XG5tb2R1bGUuZXhwb3J0cy5tYWtlS2V5ID0gbWFrZUtleVxuIiwiLy8gbXVjaCBvZiB0aGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L3NlbGYtc2lnbmVkL2Jsb2IvZ2gtcGFnZXMvbGliL3JzYS5qc1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKVxudmFyIEVDID0gcmVxdWlyZSgnZWxsaXB0aWMnKS5lY1xudmFyIHBhcnNlS2V5cyA9IHJlcXVpcmUoJ3BhcnNlLWFzbjEnKVxudmFyIGN1cnZlcyA9IHJlcXVpcmUoJy4vY3VydmVzLmpzb24nKVxuXG5mdW5jdGlvbiB2ZXJpZnkgKHNpZywgaGFzaCwga2V5LCBzaWduVHlwZSwgdGFnKSB7XG4gIHZhciBwdWIgPSBwYXJzZUtleXMoa2V5KVxuICBpZiAocHViLnR5cGUgPT09ICdlYycpIHtcbiAgICAvLyByc2Ega2V5cyBjYW4gYmUgaW50ZXJwcmV0ZWQgYXMgZWNkc2Egb25lcyBpbiBvcGVuc3NsXG4gICAgaWYgKHNpZ25UeXBlICE9PSAnZWNkc2EnICYmIHNpZ25UeXBlICE9PSAnZWNkc2EvcnNhJykgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwdWJsaWMga2V5IHR5cGUnKVxuICAgIHJldHVybiBlY1ZlcmlmeShzaWcsIGhhc2gsIHB1YilcbiAgfSBlbHNlIGlmIChwdWIudHlwZSA9PT0gJ2RzYScpIHtcbiAgICBpZiAoc2lnblR5cGUgIT09ICdkc2EnKSB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHB1YmxpYyBrZXkgdHlwZScpXG4gICAgcmV0dXJuIGRzYVZlcmlmeShzaWcsIGhhc2gsIHB1YilcbiAgfSBlbHNlIHtcbiAgICBpZiAoc2lnblR5cGUgIT09ICdyc2EnICYmIHNpZ25UeXBlICE9PSAnZWNkc2EvcnNhJykgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBwdWJsaWMga2V5IHR5cGUnKVxuICB9XG4gIGhhc2ggPSBCdWZmZXIuY29uY2F0KFt0YWcsIGhhc2hdKVxuICB2YXIgbGVuID0gcHViLm1vZHVsdXMuYnl0ZUxlbmd0aCgpXG4gIHZhciBwYWQgPSBbIDEgXVxuICB2YXIgcGFkTnVtID0gMFxuICB3aGlsZSAoaGFzaC5sZW5ndGggKyBwYWQubGVuZ3RoICsgMiA8IGxlbikge1xuICAgIHBhZC5wdXNoKDB4ZmYpXG4gICAgcGFkTnVtKytcbiAgfVxuICBwYWQucHVzaCgweDAwKVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBoYXNoLmxlbmd0aCkge1xuICAgIHBhZC5wdXNoKGhhc2hbaV0pXG4gIH1cbiAgcGFkID0gbmV3IEJ1ZmZlcihwYWQpXG4gIHZhciByZWQgPSBCTi5tb250KHB1Yi5tb2R1bHVzKVxuICBzaWcgPSBuZXcgQk4oc2lnKS50b1JlZChyZWQpXG5cbiAgc2lnID0gc2lnLnJlZFBvdyhuZXcgQk4ocHViLnB1YmxpY0V4cG9uZW50KSlcbiAgc2lnID0gbmV3IEJ1ZmZlcihzaWcuZnJvbVJlZCgpLnRvQXJyYXkoKSlcbiAgdmFyIG91dCA9IHBhZE51bSA8IDggPyAxIDogMFxuICBsZW4gPSBNYXRoLm1pbihzaWcubGVuZ3RoLCBwYWQubGVuZ3RoKVxuICBpZiAoc2lnLmxlbmd0aCAhPT0gcGFkLmxlbmd0aCkgb3V0ID0gMVxuXG4gIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSBvdXQgfD0gc2lnW2ldIF4gcGFkW2ldXG4gIHJldHVybiBvdXQgPT09IDBcbn1cblxuZnVuY3Rpb24gZWNWZXJpZnkgKHNpZywgaGFzaCwgcHViKSB7XG4gIHZhciBjdXJ2ZUlkID0gY3VydmVzW3B1Yi5kYXRhLmFsZ29yaXRobS5jdXJ2ZS5qb2luKCcuJyldXG4gIGlmICghY3VydmVJZCkgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGN1cnZlICcgKyBwdWIuZGF0YS5hbGdvcml0aG0uY3VydmUuam9pbignLicpKVxuXG4gIHZhciBjdXJ2ZSA9IG5ldyBFQyhjdXJ2ZUlkKVxuICB2YXIgcHVia2V5ID0gcHViLmRhdGEuc3ViamVjdFByaXZhdGVLZXkuZGF0YVxuXG4gIHJldHVybiBjdXJ2ZS52ZXJpZnkoaGFzaCwgc2lnLCBwdWJrZXkpXG59XG5cbmZ1bmN0aW9uIGRzYVZlcmlmeSAoc2lnLCBoYXNoLCBwdWIpIHtcbiAgdmFyIHAgPSBwdWIuZGF0YS5wXG4gIHZhciBxID0gcHViLmRhdGEucVxuICB2YXIgZyA9IHB1Yi5kYXRhLmdcbiAgdmFyIHkgPSBwdWIuZGF0YS5wdWJfa2V5XG4gIHZhciB1bnBhY2tlZCA9IHBhcnNlS2V5cy5zaWduYXR1cmUuZGVjb2RlKHNpZywgJ2RlcicpXG4gIHZhciBzID0gdW5wYWNrZWQuc1xuICB2YXIgciA9IHVucGFja2VkLnJcbiAgY2hlY2tWYWx1ZShzLCBxKVxuICBjaGVja1ZhbHVlKHIsIHEpXG4gIHZhciBtb250cCA9IEJOLm1vbnQocClcbiAgdmFyIHcgPSBzLmludm0ocSlcbiAgdmFyIHYgPSBnLnRvUmVkKG1vbnRwKVxuICAgIC5yZWRQb3cobmV3IEJOKGhhc2gpLm11bCh3KS5tb2QocSkpXG4gICAgLmZyb21SZWQoKVxuICAgIC5tdWwoeS50b1JlZChtb250cCkucmVkUG93KHIubXVsKHcpLm1vZChxKSkuZnJvbVJlZCgpKVxuICAgIC5tb2QocClcbiAgICAubW9kKHEpXG4gIHJldHVybiB2LmNtcChyKSA9PT0gMFxufVxuXG5mdW5jdGlvbiBjaGVja1ZhbHVlIChiLCBxKSB7XG4gIGlmIChiLmNtcG4oMCkgPD0gMCkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNpZycpXG4gIGlmIChiLmNtcChxKSA+PSBxKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2ZXJpZnlcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geG9yIChhLCBiKSB7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpXG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKGxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgYnVmZmVyW2ldID0gYVtpXSBeIGJbaV1cbiAgfVxuXG4gIHJldHVybiBidWZmZXJcbn1cbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybVxudmFyIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2RlcicpLlN0cmluZ0RlY29kZXJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuZnVuY3Rpb24gQ2lwaGVyQmFzZSAoaGFzaE1vZGUpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcbiAgdGhpcy5oYXNoTW9kZSA9IHR5cGVvZiBoYXNoTW9kZSA9PT0gJ3N0cmluZydcbiAgaWYgKHRoaXMuaGFzaE1vZGUpIHtcbiAgICB0aGlzW2hhc2hNb2RlXSA9IHRoaXMuX2ZpbmFsT3JEaWdlc3RcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZpbmFsID0gdGhpcy5fZmluYWxPckRpZ2VzdFxuICB9XG4gIGlmICh0aGlzLl9maW5hbCkge1xuICAgIHRoaXMuX19maW5hbCA9IHRoaXMuX2ZpbmFsXG4gICAgdGhpcy5fZmluYWwgPSBudWxsXG4gIH1cbiAgdGhpcy5fZGVjb2RlciA9IG51bGxcbiAgdGhpcy5fZW5jb2RpbmcgPSBudWxsXG59XG5pbmhlcml0cyhDaXBoZXJCYXNlLCBUcmFuc2Zvcm0pXG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBpbnB1dEVuYywgb3V0cHV0RW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgaW5wdXRFbmMpXG4gIH1cblxuICB2YXIgb3V0RGF0YSA9IHRoaXMuX3VwZGF0ZShkYXRhKVxuICBpZiAodGhpcy5oYXNoTW9kZSkgcmV0dXJuIHRoaXNcblxuICBpZiAob3V0cHV0RW5jKSB7XG4gICAgb3V0RGF0YSA9IHRoaXMuX3RvU3RyaW5nKG91dERhdGEsIG91dHB1dEVuYylcbiAgfVxuXG4gIHJldHVybiBvdXREYXRhXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEF1dG9QYWRkaW5nID0gZnVuY3Rpb24gKCkge31cbkNpcGhlckJhc2UucHJvdG90eXBlLmdldEF1dGhUYWcgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIGdldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEF1dGhUYWcgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIHNldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEFBRCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gc2V0IGFhZCBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZGF0YSwgXywgbmV4dCkge1xuICB2YXIgZXJyXG4gIHRyeSB7XG4gICAgaWYgKHRoaXMuaGFzaE1vZGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShkYXRhKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2godGhpcy5fdXBkYXRlKGRhdGEpKVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGVyciA9IGVcbiAgfSBmaW5hbGx5IHtcbiAgICBuZXh0KGVycilcbiAgfVxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKGRvbmUpIHtcbiAgdmFyIGVyclxuICB0cnkge1xuICAgIHRoaXMucHVzaCh0aGlzLl9fZmluYWwoKSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVyciA9IGVcbiAgfVxuXG4gIGRvbmUoZXJyKVxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX2ZpbmFsT3JEaWdlc3QgPSBmdW5jdGlvbiAob3V0cHV0RW5jKSB7XG4gIHZhciBvdXREYXRhID0gdGhpcy5fX2ZpbmFsKCkgfHwgQnVmZmVyLmFsbG9jKDApXG4gIGlmIChvdXRwdXRFbmMpIHtcbiAgICBvdXREYXRhID0gdGhpcy5fdG9TdHJpbmcob3V0RGF0YSwgb3V0cHV0RW5jLCB0cnVlKVxuICB9XG4gIHJldHVybiBvdXREYXRhXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLl90b1N0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jLCBmaW4pIHtcbiAgaWYgKCF0aGlzLl9kZWNvZGVyKSB7XG4gICAgdGhpcy5fZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYylcbiAgICB0aGlzLl9lbmNvZGluZyA9IGVuY1xuICB9XG5cbiAgaWYgKHRoaXMuX2VuY29kaW5nICE9PSBlbmMpIHRocm93IG5ldyBFcnJvcignY2FuXFwndCBzd2l0Y2ggZW5jb2RpbmdzJylcblxuICB2YXIgb3V0ID0gdGhpcy5fZGVjb2Rlci53cml0ZSh2YWx1ZSlcbiAgaWYgKGZpbikge1xuICAgIG91dCArPSB0aGlzLl9kZWNvZGVyLmVuZCgpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2lwaGVyQmFzZVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwidmFyIGVsbGlwdGljID0gcmVxdWlyZSgnZWxsaXB0aWMnKVxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVDREggKGN1cnZlKSB7XG4gIHJldHVybiBuZXcgRUNESChjdXJ2ZSlcbn1cblxudmFyIGFsaWFzZXMgPSB7XG4gIHNlY3AyNTZrMToge1xuICAgIG5hbWU6ICdzZWNwMjU2azEnLFxuICAgIGJ5dGVMZW5ndGg6IDMyXG4gIH0sXG4gIHNlY3AyMjRyMToge1xuICAgIG5hbWU6ICdwMjI0JyxcbiAgICBieXRlTGVuZ3RoOiAyOFxuICB9LFxuICBwcmltZTI1NnYxOiB7XG4gICAgbmFtZTogJ3AyNTYnLFxuICAgIGJ5dGVMZW5ndGg6IDMyXG4gIH0sXG4gIHByaW1lMTkydjE6IHtcbiAgICBuYW1lOiAncDE5MicsXG4gICAgYnl0ZUxlbmd0aDogMjRcbiAgfSxcbiAgZWQyNTUxOToge1xuICAgIG5hbWU6ICdlZDI1NTE5JyxcbiAgICBieXRlTGVuZ3RoOiAzMlxuICB9LFxuICBzZWNwMzg0cjE6IHtcbiAgICBuYW1lOiAncDM4NCcsXG4gICAgYnl0ZUxlbmd0aDogNDhcbiAgfSxcbiAgc2VjcDUyMXIxOiB7XG4gICAgbmFtZTogJ3A1MjEnLFxuICAgIGJ5dGVMZW5ndGg6IDY2XG4gIH1cbn1cblxuYWxpYXNlcy5wMjI0ID0gYWxpYXNlcy5zZWNwMjI0cjFcbmFsaWFzZXMucDI1NiA9IGFsaWFzZXMuc2VjcDI1NnIxID0gYWxpYXNlcy5wcmltZTI1NnYxXG5hbGlhc2VzLnAxOTIgPSBhbGlhc2VzLnNlY3AxOTJyMSA9IGFsaWFzZXMucHJpbWUxOTJ2MVxuYWxpYXNlcy5wMzg0ID0gYWxpYXNlcy5zZWNwMzg0cjFcbmFsaWFzZXMucDUyMSA9IGFsaWFzZXMuc2VjcDUyMXIxXG5cbmZ1bmN0aW9uIEVDREggKGN1cnZlKSB7XG4gIHRoaXMuY3VydmVUeXBlID0gYWxpYXNlc1tjdXJ2ZV1cbiAgaWYgKCF0aGlzLmN1cnZlVHlwZSkge1xuICAgIHRoaXMuY3VydmVUeXBlID0ge1xuICAgICAgbmFtZTogY3VydmVcbiAgICB9XG4gIH1cbiAgdGhpcy5jdXJ2ZSA9IG5ldyBlbGxpcHRpYy5lYyh0aGlzLmN1cnZlVHlwZS5uYW1lKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbiAgdGhpcy5rZXlzID0gdm9pZCAwXG59XG5cbkVDREgucHJvdG90eXBlLmdlbmVyYXRlS2V5cyA9IGZ1bmN0aW9uIChlbmMsIGZvcm1hdCkge1xuICB0aGlzLmtleXMgPSB0aGlzLmN1cnZlLmdlbktleVBhaXIoKVxuICByZXR1cm4gdGhpcy5nZXRQdWJsaWNLZXkoZW5jLCBmb3JtYXQpXG59XG5cbkVDREgucHJvdG90eXBlLmNvbXB1dGVTZWNyZXQgPSBmdW5jdGlvbiAob3RoZXIsIGluZW5jLCBlbmMpIHtcbiAgaW5lbmMgPSBpbmVuYyB8fCAndXRmOCdcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgb3RoZXIgPSBuZXcgQnVmZmVyKG90aGVyLCBpbmVuYylcbiAgfVxuICB2YXIgb3RoZXJQdWIgPSB0aGlzLmN1cnZlLmtleUZyb21QdWJsaWMob3RoZXIpLmdldFB1YmxpYygpXG4gIHZhciBvdXQgPSBvdGhlclB1Yi5tdWwodGhpcy5rZXlzLmdldFByaXZhdGUoKSkuZ2V0WCgpXG4gIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZShvdXQsIGVuYywgdGhpcy5jdXJ2ZVR5cGUuYnl0ZUxlbmd0aClcbn1cblxuRUNESC5wcm90b3R5cGUuZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24gKGVuYywgZm9ybWF0KSB7XG4gIHZhciBrZXkgPSB0aGlzLmtleXMuZ2V0UHVibGljKGZvcm1hdCA9PT0gJ2NvbXByZXNzZWQnLCB0cnVlKVxuICBpZiAoZm9ybWF0ID09PSAnaHlicmlkJykge1xuICAgIGlmIChrZXlba2V5Lmxlbmd0aCAtIDFdICUgMikge1xuICAgICAga2V5WzBdID0gN1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlbMF0gPSA2XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZShrZXksIGVuYylcbn1cblxuRUNESC5wcm90b3R5cGUuZ2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKHRoaXMua2V5cy5nZXRQcml2YXRlKCksIGVuYylcbn1cblxuRUNESC5wcm90b3R5cGUuc2V0UHVibGljS2V5ID0gZnVuY3Rpb24gKHB1YiwgZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAndXRmOCdcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocHViKSkge1xuICAgIHB1YiA9IG5ldyBCdWZmZXIocHViLCBlbmMpXG4gIH1cbiAgdGhpcy5rZXlzLl9pbXBvcnRQdWJsaWMocHViKVxuICByZXR1cm4gdGhpc1xufVxuXG5FQ0RILnByb3RvdHlwZS5zZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24gKHByaXYsIGVuYykge1xuICBlbmMgPSBlbmMgfHwgJ3V0ZjgnXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHByaXYpKSB7XG4gICAgcHJpdiA9IG5ldyBCdWZmZXIocHJpdiwgZW5jKVxuICB9XG5cbiAgdmFyIF9wcml2ID0gbmV3IEJOKHByaXYpXG4gIF9wcml2ID0gX3ByaXYudG9TdHJpbmcoMTYpXG4gIHRoaXMua2V5cyA9IHRoaXMuY3VydmUuZ2VuS2V5UGFpcigpXG4gIHRoaXMua2V5cy5faW1wb3J0UHJpdmF0ZShfcHJpdilcbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gZm9ybWF0UmV0dXJuVmFsdWUgKGJuLCBlbmMsIGxlbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYm4pKSB7XG4gICAgYm4gPSBibi50b0FycmF5KClcbiAgfVxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihibilcbiAgaWYgKGxlbiAmJiBidWYubGVuZ3RoIDwgbGVuKSB7XG4gICAgdmFyIHplcm9zID0gbmV3IEJ1ZmZlcihsZW4gLSBidWYubGVuZ3RoKVxuICAgIHplcm9zLmZpbGwoMClcbiAgICBidWYgPSBCdWZmZXIuY29uY2F0KFt6ZXJvcywgYnVmXSlcbiAgfVxuICBpZiAoIWVuYykge1xuICAgIHJldHVybiBidWZcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYnVmLnRvU3RyaW5nKGVuYylcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgTUQ1ID0gcmVxdWlyZSgnbWQ1LmpzJylcbnZhciBSSVBFTUQxNjAgPSByZXF1aXJlKCdyaXBlbWQxNjAnKVxudmFyIHNoYSA9IHJlcXVpcmUoJ3NoYS5qcycpXG52YXIgQmFzZSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcblxuZnVuY3Rpb24gSGFzaCAoaGFzaCkge1xuICBCYXNlLmNhbGwodGhpcywgJ2RpZ2VzdCcpXG5cbiAgdGhpcy5faGFzaCA9IGhhc2hcbn1cblxuaW5oZXJpdHMoSGFzaCwgQmFzZSlcblxuSGFzaC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG59XG5cbkhhc2gucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2hhc2guZGlnZXN0KClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVIYXNoIChhbGcpIHtcbiAgYWxnID0gYWxnLnRvTG93ZXJDYXNlKClcbiAgaWYgKGFsZyA9PT0gJ21kNScpIHJldHVybiBuZXcgTUQ1KClcbiAgaWYgKGFsZyA9PT0gJ3JtZDE2MCcgfHwgYWxnID09PSAncmlwZW1kMTYwJykgcmV0dXJuIG5ldyBSSVBFTUQxNjAoKVxuXG4gIHJldHVybiBuZXcgSGFzaChzaGEoYWxnKSlcbn1cbiIsInZhciBNRDUgPSByZXF1aXJlKCdtZDUuanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgcmV0dXJuIG5ldyBNRDUoKS51cGRhdGUoYnVmZmVyKS5kaWdlc3QoKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgTGVnYWN5ID0gcmVxdWlyZSgnLi9sZWdhY3knKVxudmFyIEJhc2UgPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBtZDUgPSByZXF1aXJlKCdjcmVhdGUtaGFzaC9tZDUnKVxudmFyIFJJUEVNRDE2MCA9IHJlcXVpcmUoJ3JpcGVtZDE2MCcpXG5cbnZhciBzaGEgPSByZXF1aXJlKCdzaGEuanMnKVxuXG52YXIgWkVST1MgPSBCdWZmZXIuYWxsb2MoMTI4KVxuXG5mdW5jdGlvbiBIbWFjIChhbGcsIGtleSkge1xuICBCYXNlLmNhbGwodGhpcywgJ2RpZ2VzdCcpXG4gIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgIGtleSA9IEJ1ZmZlci5mcm9tKGtleSlcbiAgfVxuXG4gIHZhciBibG9ja3NpemUgPSAoYWxnID09PSAnc2hhNTEyJyB8fCBhbGcgPT09ICdzaGEzODQnKSA/IDEyOCA6IDY0XG5cbiAgdGhpcy5fYWxnID0gYWxnXG4gIHRoaXMuX2tleSA9IGtleVxuICBpZiAoa2V5Lmxlbmd0aCA+IGJsb2Nrc2l6ZSkge1xuICAgIHZhciBoYXNoID0gYWxnID09PSAncm1kMTYwJyA/IG5ldyBSSVBFTUQxNjAoKSA6IHNoYShhbGcpXG4gICAga2V5ID0gaGFzaC51cGRhdGUoa2V5KS5kaWdlc3QoKVxuICB9IGVsc2UgaWYgKGtleS5sZW5ndGggPCBibG9ja3NpemUpIHtcbiAgICBrZXkgPSBCdWZmZXIuY29uY2F0KFtrZXksIFpFUk9TXSwgYmxvY2tzaXplKVxuICB9XG5cbiAgdmFyIGlwYWQgPSB0aGlzLl9pcGFkID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2Nrc2l6ZSlcbiAgdmFyIG9wYWQgPSB0aGlzLl9vcGFkID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2Nrc2l6ZSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2Nrc2l6ZTsgaSsrKSB7XG4gICAgaXBhZFtpXSA9IGtleVtpXSBeIDB4MzZcbiAgICBvcGFkW2ldID0ga2V5W2ldIF4gMHg1Q1xuICB9XG4gIHRoaXMuX2hhc2ggPSBhbGcgPT09ICdybWQxNjAnID8gbmV3IFJJUEVNRDE2MCgpIDogc2hhKGFsZylcbiAgdGhpcy5faGFzaC51cGRhdGUoaXBhZClcbn1cblxuaW5oZXJpdHMoSG1hYywgQmFzZSlcblxuSG1hYy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG59XG5cbkhtYWMucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGggPSB0aGlzLl9oYXNoLmRpZ2VzdCgpXG4gIHZhciBoYXNoID0gdGhpcy5fYWxnID09PSAncm1kMTYwJyA/IG5ldyBSSVBFTUQxNjAoKSA6IHNoYSh0aGlzLl9hbGcpXG4gIHJldHVybiBoYXNoLnVwZGF0ZSh0aGlzLl9vcGFkKS51cGRhdGUoaCkuZGlnZXN0KClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVIbWFjIChhbGcsIGtleSkge1xuICBhbGcgPSBhbGcudG9Mb3dlckNhc2UoKVxuICBpZiAoYWxnID09PSAncm1kMTYwJyB8fCBhbGcgPT09ICdyaXBlbWQxNjAnKSB7XG4gICAgcmV0dXJuIG5ldyBIbWFjKCdybWQxNjAnLCBrZXkpXG4gIH1cbiAgaWYgKGFsZyA9PT0gJ21kNScpIHtcbiAgICByZXR1cm4gbmV3IExlZ2FjeShtZDUsIGtleSlcbiAgfVxuICByZXR1cm4gbmV3IEhtYWMoYWxnLCBrZXkpXG59XG4iLCIndXNlIHN0cmljdCdcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgQmFzZSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcblxudmFyIFpFUk9TID0gQnVmZmVyLmFsbG9jKDEyOClcbnZhciBibG9ja3NpemUgPSA2NFxuXG5mdW5jdGlvbiBIbWFjIChhbGcsIGtleSkge1xuICBCYXNlLmNhbGwodGhpcywgJ2RpZ2VzdCcpXG4gIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgIGtleSA9IEJ1ZmZlci5mcm9tKGtleSlcbiAgfVxuXG4gIHRoaXMuX2FsZyA9IGFsZ1xuICB0aGlzLl9rZXkgPSBrZXlcblxuICBpZiAoa2V5Lmxlbmd0aCA+IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IGFsZyhrZXkpXG4gIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA8IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwgWkVST1NdLCBibG9ja3NpemUpXG4gIH1cblxuICB2YXIgaXBhZCA9IHRoaXMuX2lwYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYmxvY2tzaXplKVxuICB2YXIgb3BhZCA9IHRoaXMuX29wYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYmxvY2tzaXplKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzaXplOyBpKyspIHtcbiAgICBpcGFkW2ldID0ga2V5W2ldIF4gMHgzNlxuICAgIG9wYWRbaV0gPSBrZXlbaV0gXiAweDVDXG4gIH1cblxuICB0aGlzLl9oYXNoID0gW2lwYWRdXG59XG5cbmluaGVyaXRzKEhtYWMsIEJhc2UpXG5cbkhtYWMucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLl9oYXNoLnB1c2goZGF0YSlcbn1cblxuSG1hYy5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaCA9IHRoaXMuX2FsZyhCdWZmZXIuY29uY2F0KHRoaXMuX2hhc2gpKVxuICByZXR1cm4gdGhpcy5fYWxnKEJ1ZmZlci5jb25jYXQoW3RoaXMuX29wYWQsIGhdKSlcbn1cbm1vZHVsZS5leHBvcnRzID0gSG1hY1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBleHBvcnRzLnJuZyA9IGV4cG9ydHMucHNldWRvUmFuZG9tQnl0ZXMgPSBleHBvcnRzLnBybmcgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpXG5leHBvcnRzLmNyZWF0ZUhhc2ggPSBleHBvcnRzLkhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpXG5leHBvcnRzLmNyZWF0ZUhtYWMgPSBleHBvcnRzLkhtYWMgPSByZXF1aXJlKCdjcmVhdGUtaG1hYycpXG5cbnZhciBhbGdvcyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktc2lnbi9hbGdvcycpXG52YXIgYWxnb0tleXMgPSBPYmplY3Qua2V5cyhhbGdvcylcbnZhciBoYXNoZXMgPSBbJ3NoYTEnLCAnc2hhMjI0JywgJ3NoYTI1NicsICdzaGEzODQnLCAnc2hhNTEyJywgJ21kNScsICdybWQxNjAnXS5jb25jYXQoYWxnb0tleXMpXG5leHBvcnRzLmdldEhhc2hlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGhhc2hlc1xufVxuXG52YXIgcCA9IHJlcXVpcmUoJ3Bia2RmMicpXG5leHBvcnRzLnBia2RmMiA9IHAucGJrZGYyXG5leHBvcnRzLnBia2RmMlN5bmMgPSBwLnBia2RmMlN5bmNcblxudmFyIGFlcyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktY2lwaGVyJylcblxuZXhwb3J0cy5DaXBoZXIgPSBhZXMuQ2lwaGVyXG5leHBvcnRzLmNyZWF0ZUNpcGhlciA9IGFlcy5jcmVhdGVDaXBoZXJcbmV4cG9ydHMuQ2lwaGVyaXYgPSBhZXMuQ2lwaGVyaXZcbmV4cG9ydHMuY3JlYXRlQ2lwaGVyaXYgPSBhZXMuY3JlYXRlQ2lwaGVyaXZcbmV4cG9ydHMuRGVjaXBoZXIgPSBhZXMuRGVjaXBoZXJcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXIgPSBhZXMuY3JlYXRlRGVjaXBoZXJcbmV4cG9ydHMuRGVjaXBoZXJpdiA9IGFlcy5EZWNpcGhlcml2XG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyaXYgPSBhZXMuY3JlYXRlRGVjaXBoZXJpdlxuZXhwb3J0cy5nZXRDaXBoZXJzID0gYWVzLmdldENpcGhlcnNcbmV4cG9ydHMubGlzdENpcGhlcnMgPSBhZXMubGlzdENpcGhlcnNcblxudmFyIGRoID0gcmVxdWlyZSgnZGlmZmllLWhlbGxtYW4nKVxuXG5leHBvcnRzLkRpZmZpZUhlbGxtYW5Hcm91cCA9IGRoLkRpZmZpZUhlbGxtYW5Hcm91cFxuZXhwb3J0cy5jcmVhdGVEaWZmaWVIZWxsbWFuR3JvdXAgPSBkaC5jcmVhdGVEaWZmaWVIZWxsbWFuR3JvdXBcbmV4cG9ydHMuZ2V0RGlmZmllSGVsbG1hbiA9IGRoLmdldERpZmZpZUhlbGxtYW5cbmV4cG9ydHMuY3JlYXRlRGlmZmllSGVsbG1hbiA9IGRoLmNyZWF0ZURpZmZpZUhlbGxtYW5cbmV4cG9ydHMuRGlmZmllSGVsbG1hbiA9IGRoLkRpZmZpZUhlbGxtYW5cblxudmFyIHNpZ24gPSByZXF1aXJlKCdicm93c2VyaWZ5LXNpZ24nKVxuXG5leHBvcnRzLmNyZWF0ZVNpZ24gPSBzaWduLmNyZWF0ZVNpZ25cbmV4cG9ydHMuU2lnbiA9IHNpZ24uU2lnblxuZXhwb3J0cy5jcmVhdGVWZXJpZnkgPSBzaWduLmNyZWF0ZVZlcmlmeVxuZXhwb3J0cy5WZXJpZnkgPSBzaWduLlZlcmlmeVxuXG5leHBvcnRzLmNyZWF0ZUVDREggPSByZXF1aXJlKCdjcmVhdGUtZWNkaCcpXG5cbnZhciBwdWJsaWNFbmNyeXB0ID0gcmVxdWlyZSgncHVibGljLWVuY3J5cHQnKVxuXG5leHBvcnRzLnB1YmxpY0VuY3J5cHQgPSBwdWJsaWNFbmNyeXB0LnB1YmxpY0VuY3J5cHRcbmV4cG9ydHMucHJpdmF0ZUVuY3J5cHQgPSBwdWJsaWNFbmNyeXB0LnByaXZhdGVFbmNyeXB0XG5leHBvcnRzLnB1YmxpY0RlY3J5cHQgPSBwdWJsaWNFbmNyeXB0LnB1YmxpY0RlY3J5cHRcbmV4cG9ydHMucHJpdmF0ZURlY3J5cHQgPSBwdWJsaWNFbmNyeXB0LnByaXZhdGVEZWNyeXB0XG5cbi8vIHRoZSBsZWFzdCBJIGNhbiBkbyBpcyBtYWtlIGVycm9yIG1lc3NhZ2VzIGZvciB0aGUgcmVzdCBvZiB0aGUgbm9kZS5qcy9jcnlwdG8gYXBpLlxuLy8gO1tcbi8vICAgJ2NyZWF0ZUNyZWRlbnRpYWxzJ1xuLy8gXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4vLyAgIGV4cG9ydHNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4vLyAgICAgdGhyb3cgbmV3IEVycm9yKFtcbi8vICAgICAgICdzb3JyeSwgJyArIG5hbWUgKyAnIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnLFxuLy8gICAgICAgJ3dlIGFjY2VwdCBwdWxsIHJlcXVlc3RzJyxcbi8vICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvLWJyb3dzZXJpZnkvY3J5cHRvLWJyb3dzZXJpZnknXG4vLyAgICAgXS5qb2luKCdcXG4nKSlcbi8vICAgfVxuLy8gfSlcblxudmFyIHJmID0gcmVxdWlyZSgncmFuZG9tZmlsbCcpXG5cbmV4cG9ydHMucmFuZG9tRmlsbCA9IHJmLnJhbmRvbUZpbGxcbmV4cG9ydHMucmFuZG9tRmlsbFN5bmMgPSByZi5yYW5kb21GaWxsU3luY1xuXG5leHBvcnRzLmNyZWF0ZUNyZWRlbnRpYWxzID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoW1xuICAgICdzb3JyeSwgY3JlYXRlQ3JlZGVudGlhbHMgaXMgbm90IGltcGxlbWVudGVkIHlldCcsXG4gICAgJ3dlIGFjY2VwdCBwdWxsIHJlcXVlc3RzJyxcbiAgICAnaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0by1icm93c2VyaWZ5L2NyeXB0by1icm93c2VyaWZ5J1xuICBdLmpvaW4oJ1xcbicpKVxufVxuXG5leHBvcnRzLmNvbnN0YW50cyA9IHtcbiAgJ0RIX0NIRUNLX1BfTk9UX1NBRkVfUFJJTUUnOiAyLFxuICAnREhfQ0hFQ0tfUF9OT1RfUFJJTUUnOiAxLFxuICAnREhfVU5BQkxFX1RPX0NIRUNLX0dFTkVSQVRPUic6IDQsXG4gICdESF9OT1RfU1VJVEFCTEVfR0VORVJBVE9SJzogOCxcbiAgJ05QTl9FTkFCTEVEJzogMSxcbiAgJ0FMUE5fRU5BQkxFRCc6IDEsXG4gICdSU0FfUEtDUzFfUEFERElORyc6IDEsXG4gICdSU0FfU1NMVjIzX1BBRERJTkcnOiAyLFxuICAnUlNBX05PX1BBRERJTkcnOiAzLFxuICAnUlNBX1BLQ1MxX09BRVBfUEFERElORyc6IDQsXG4gICdSU0FfWDkzMV9QQURESU5HJzogNSxcbiAgJ1JTQV9QS0NTMV9QU1NfUEFERElORyc6IDYsXG4gICdQT0lOVF9DT05WRVJTSU9OX0NPTVBSRVNTRUQnOiAyLFxuICAnUE9JTlRfQ09OVkVSU0lPTl9VTkNPTVBSRVNTRUQnOiA0LFxuICAnUE9JTlRfQ09OVkVSU0lPTl9IWUJSSUQnOiA2XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMudXRpbHMgPSByZXF1aXJlKCcuL2Rlcy91dGlscycpO1xuZXhwb3J0cy5DaXBoZXIgPSByZXF1aXJlKCcuL2Rlcy9jaXBoZXInKTtcbmV4cG9ydHMuREVTID0gcmVxdWlyZSgnLi9kZXMvZGVzJyk7XG5leHBvcnRzLkNCQyA9IHJlcXVpcmUoJy4vZGVzL2NiYycpO1xuZXhwb3J0cy5FREUgPSByZXF1aXJlKCcuL2Rlcy9lZGUnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBwcm90byA9IHt9O1xuXG5mdW5jdGlvbiBDQkNTdGF0ZShpdikge1xuICBhc3NlcnQuZXF1YWwoaXYubGVuZ3RoLCA4LCAnSW52YWxpZCBJViBsZW5ndGgnKTtcblxuICB0aGlzLml2ID0gbmV3IEFycmF5KDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXYubGVuZ3RoOyBpKyspXG4gICAgdGhpcy5pdltpXSA9IGl2W2ldO1xufVxuXG5mdW5jdGlvbiBpbnN0YW50aWF0ZShCYXNlKSB7XG4gIGZ1bmN0aW9uIENCQyhvcHRpb25zKSB7XG4gICAgQmFzZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2NiY0luaXQoKTtcbiAgfVxuICBpbmhlcml0cyhDQkMsIEJhc2UpO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvdG8pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBDQkMucHJvdG90eXBlW2tleV0gPSBwcm90b1trZXldO1xuICB9XG5cbiAgQ0JDLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDQkMob3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIENCQztcbn1cblxuZXhwb3J0cy5pbnN0YW50aWF0ZSA9IGluc3RhbnRpYXRlO1xuXG5wcm90by5fY2JjSW5pdCA9IGZ1bmN0aW9uIF9jYmNJbml0KCkge1xuICB2YXIgc3RhdGUgPSBuZXcgQ0JDU3RhdGUodGhpcy5vcHRpb25zLml2KTtcbiAgdGhpcy5fY2JjU3RhdGUgPSBzdGF0ZTtcbn07XG5cbnByb3RvLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKGlucCwgaW5PZmYsIG91dCwgb3V0T2ZmKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2NiY1N0YXRlO1xuICB2YXIgc3VwZXJQcm90byA9IHRoaXMuY29uc3RydWN0b3Iuc3VwZXJfLnByb3RvdHlwZTtcblxuICB2YXIgaXYgPSBzdGF0ZS5pdjtcbiAgaWYgKHRoaXMudHlwZSA9PT0gJ2VuY3J5cHQnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgICAgaXZbaV0gXj0gaW5wW2luT2ZmICsgaV07XG5cbiAgICBzdXBlclByb3RvLl91cGRhdGUuY2FsbCh0aGlzLCBpdiwgMCwgb3V0LCBvdXRPZmYpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgICAgaXZbaV0gPSBvdXRbb3V0T2ZmICsgaV07XG4gIH0gZWxzZSB7XG4gICAgc3VwZXJQcm90by5fdXBkYXRlLmNhbGwodGhpcywgaW5wLCBpbk9mZiwgb3V0LCBvdXRPZmYpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgICAgb3V0W291dE9mZiArIGldIF49IGl2W2ldO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgICAgaXZbaV0gPSBpbnBbaW5PZmYgKyBpXTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxuZnVuY3Rpb24gQ2lwaGVyKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICB0aGlzLnR5cGUgPSB0aGlzLm9wdGlvbnMudHlwZTtcbiAgdGhpcy5ibG9ja1NpemUgPSA4O1xuICB0aGlzLl9pbml0KCk7XG5cbiAgdGhpcy5idWZmZXIgPSBuZXcgQXJyYXkodGhpcy5ibG9ja1NpemUpO1xuICB0aGlzLmJ1ZmZlck9mZiA9IDA7XG59XG5tb2R1bGUuZXhwb3J0cyA9IENpcGhlcjtcblxuQ2lwaGVyLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIF9pbml0KCkge1xuICAvLyBNaWdodCBiZSBvdmVycmlkZWRcbn07XG5cbkNpcGhlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGRhdGEpIHtcbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodGhpcy50eXBlID09PSAnZGVjcnlwdCcpXG4gICAgcmV0dXJuIHRoaXMuX3VwZGF0ZURlY3J5cHQoZGF0YSk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlRW5jcnlwdChkYXRhKTtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX2J1ZmZlciA9IGZ1bmN0aW9uIF9idWZmZXIoZGF0YSwgb2ZmKSB7XG4gIC8vIEFwcGVuZCBkYXRhIHRvIGJ1ZmZlclxuICB2YXIgbWluID0gTWF0aC5taW4odGhpcy5idWZmZXIubGVuZ3RoIC0gdGhpcy5idWZmZXJPZmYsIGRhdGEubGVuZ3RoIC0gb2ZmKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkrKylcbiAgICB0aGlzLmJ1ZmZlclt0aGlzLmJ1ZmZlck9mZiArIGldID0gZGF0YVtvZmYgKyBpXTtcbiAgdGhpcy5idWZmZXJPZmYgKz0gbWluO1xuXG4gIC8vIFNoaWZ0IG5leHRcbiAgcmV0dXJuIG1pbjtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX2ZsdXNoQnVmZmVyID0gZnVuY3Rpb24gX2ZsdXNoQnVmZmVyKG91dCwgb2ZmKSB7XG4gIHRoaXMuX3VwZGF0ZSh0aGlzLmJ1ZmZlciwgMCwgb3V0LCBvZmYpO1xuICB0aGlzLmJ1ZmZlck9mZiA9IDA7XG4gIHJldHVybiB0aGlzLmJsb2NrU2l6ZTtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZUVuY3J5cHQgPSBmdW5jdGlvbiBfdXBkYXRlRW5jcnlwdChkYXRhKSB7XG4gIHZhciBpbnB1dE9mZiA9IDA7XG4gIHZhciBvdXRwdXRPZmYgPSAwO1xuXG4gIHZhciBjb3VudCA9ICgodGhpcy5idWZmZXJPZmYgKyBkYXRhLmxlbmd0aCkgLyB0aGlzLmJsb2NrU2l6ZSkgfCAwO1xuICB2YXIgb3V0ID0gbmV3IEFycmF5KGNvdW50ICogdGhpcy5ibG9ja1NpemUpO1xuXG4gIGlmICh0aGlzLmJ1ZmZlck9mZiAhPT0gMCkge1xuICAgIGlucHV0T2ZmICs9IHRoaXMuX2J1ZmZlcihkYXRhLCBpbnB1dE9mZik7XG5cbiAgICBpZiAodGhpcy5idWZmZXJPZmYgPT09IHRoaXMuYnVmZmVyLmxlbmd0aClcbiAgICAgIG91dHB1dE9mZiArPSB0aGlzLl9mbHVzaEJ1ZmZlcihvdXQsIG91dHB1dE9mZik7XG4gIH1cblxuICAvLyBXcml0ZSBibG9ja3NcbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoIC0gKChkYXRhLmxlbmd0aCAtIGlucHV0T2ZmKSAlIHRoaXMuYmxvY2tTaXplKTtcbiAgZm9yICg7IGlucHV0T2ZmIDwgbWF4OyBpbnB1dE9mZiArPSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIHRoaXMuX3VwZGF0ZShkYXRhLCBpbnB1dE9mZiwgb3V0LCBvdXRwdXRPZmYpO1xuICAgIG91dHB1dE9mZiArPSB0aGlzLmJsb2NrU2l6ZTtcbiAgfVxuXG4gIC8vIFF1ZXVlIHJlc3RcbiAgZm9yICg7IGlucHV0T2ZmIDwgZGF0YS5sZW5ndGg7IGlucHV0T2ZmKyssIHRoaXMuYnVmZmVyT2ZmKyspXG4gICAgdGhpcy5idWZmZXJbdGhpcy5idWZmZXJPZmZdID0gZGF0YVtpbnB1dE9mZl07XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZURlY3J5cHQgPSBmdW5jdGlvbiBfdXBkYXRlRGVjcnlwdChkYXRhKSB7XG4gIHZhciBpbnB1dE9mZiA9IDA7XG4gIHZhciBvdXRwdXRPZmYgPSAwO1xuXG4gIHZhciBjb3VudCA9IE1hdGguY2VpbCgodGhpcy5idWZmZXJPZmYgKyBkYXRhLmxlbmd0aCkgLyB0aGlzLmJsb2NrU2l6ZSkgLSAxO1xuICB2YXIgb3V0ID0gbmV3IEFycmF5KGNvdW50ICogdGhpcy5ibG9ja1NpemUpO1xuXG4gIC8vIFRPRE8oaW5kdXRueSk6IG9wdGltaXplIGl0LCB0aGlzIGlzIGZhciBmcm9tIG9wdGltYWxcbiAgZm9yICg7IGNvdW50ID4gMDsgY291bnQtLSkge1xuICAgIGlucHV0T2ZmICs9IHRoaXMuX2J1ZmZlcihkYXRhLCBpbnB1dE9mZik7XG4gICAgb3V0cHV0T2ZmICs9IHRoaXMuX2ZsdXNoQnVmZmVyKG91dCwgb3V0cHV0T2ZmKTtcbiAgfVxuXG4gIC8vIEJ1ZmZlciByZXN0IG9mIHRoZSBpbnB1dFxuICBpbnB1dE9mZiArPSB0aGlzLl9idWZmZXIoZGF0YSwgaW5wdXRPZmYpO1xuXG4gIHJldHVybiBvdXQ7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLmZpbmFsID0gZnVuY3Rpb24gZmluYWwoYnVmZmVyKSB7XG4gIHZhciBmaXJzdDtcbiAgaWYgKGJ1ZmZlcilcbiAgICBmaXJzdCA9IHRoaXMudXBkYXRlKGJ1ZmZlcik7XG5cbiAgdmFyIGxhc3Q7XG4gIGlmICh0aGlzLnR5cGUgPT09ICdlbmNyeXB0JylcbiAgICBsYXN0ID0gdGhpcy5fZmluYWxFbmNyeXB0KCk7XG4gIGVsc2VcbiAgICBsYXN0ID0gdGhpcy5fZmluYWxEZWNyeXB0KCk7XG5cbiAgaWYgKGZpcnN0KVxuICAgIHJldHVybiBmaXJzdC5jb25jYXQobGFzdCk7XG4gIGVsc2VcbiAgICByZXR1cm4gbGFzdDtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX3BhZCA9IGZ1bmN0aW9uIF9wYWQoYnVmZmVyLCBvZmYpIHtcbiAgaWYgKG9mZiA9PT0gMClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgd2hpbGUgKG9mZiA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgYnVmZmVyW29mZisrXSA9IDA7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl9maW5hbEVuY3J5cHQgPSBmdW5jdGlvbiBfZmluYWxFbmNyeXB0KCkge1xuICBpZiAoIXRoaXMuX3BhZCh0aGlzLmJ1ZmZlciwgdGhpcy5idWZmZXJPZmYpKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgb3V0ID0gbmV3IEFycmF5KHRoaXMuYmxvY2tTaXplKTtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuYnVmZmVyLCAwLCBvdXQsIDApO1xuICByZXR1cm4gb3V0O1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fdW5wYWQgPSBmdW5jdGlvbiBfdW5wYWQoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXI7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl9maW5hbERlY3J5cHQgPSBmdW5jdGlvbiBfZmluYWxEZWNyeXB0KCkge1xuICBhc3NlcnQuZXF1YWwodGhpcy5idWZmZXJPZmYsIHRoaXMuYmxvY2tTaXplLCAnTm90IGVub3VnaCBkYXRhIHRvIGRlY3J5cHQnKTtcbiAgdmFyIG91dCA9IG5ldyBBcnJheSh0aGlzLmJsb2NrU2l6ZSk7XG4gIHRoaXMuX2ZsdXNoQnVmZmVyKG91dCwgMCk7XG5cbiAgcmV0dXJuIHRoaXMuX3VucGFkKG91dCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxudmFyIGRlcyA9IHJlcXVpcmUoJy4uL2RlcycpO1xudmFyIHV0aWxzID0gZGVzLnV0aWxzO1xudmFyIENpcGhlciA9IGRlcy5DaXBoZXI7XG5cbmZ1bmN0aW9uIERFU1N0YXRlKCkge1xuICB0aGlzLnRtcCA9IG5ldyBBcnJheSgyKTtcbiAgdGhpcy5rZXlzID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gREVTKG9wdGlvbnMpIHtcbiAgQ2lwaGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdmFyIHN0YXRlID0gbmV3IERFU1N0YXRlKCk7XG4gIHRoaXMuX2Rlc1N0YXRlID0gc3RhdGU7XG5cbiAgdGhpcy5kZXJpdmVLZXlzKHN0YXRlLCBvcHRpb25zLmtleSk7XG59XG5pbmhlcml0cyhERVMsIENpcGhlcik7XG5tb2R1bGUuZXhwb3J0cyA9IERFUztcblxuREVTLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgREVTKG9wdGlvbnMpO1xufTtcblxudmFyIHNoaWZ0VGFibGUgPSBbXG4gIDEsIDEsIDIsIDIsIDIsIDIsIDIsIDIsXG4gIDEsIDIsIDIsIDIsIDIsIDIsIDIsIDFcbl07XG5cbkRFUy5wcm90b3R5cGUuZGVyaXZlS2V5cyA9IGZ1bmN0aW9uIGRlcml2ZUtleXMoc3RhdGUsIGtleSkge1xuICBzdGF0ZS5rZXlzID0gbmV3IEFycmF5KDE2ICogMik7XG5cbiAgYXNzZXJ0LmVxdWFsKGtleS5sZW5ndGgsIHRoaXMuYmxvY2tTaXplLCAnSW52YWxpZCBrZXkgbGVuZ3RoJyk7XG5cbiAgdmFyIGtMID0gdXRpbHMucmVhZFVJbnQzMkJFKGtleSwgMCk7XG4gIHZhciBrUiA9IHV0aWxzLnJlYWRVSW50MzJCRShrZXksIDQpO1xuXG4gIHV0aWxzLnBjMShrTCwga1IsIHN0YXRlLnRtcCwgMCk7XG4gIGtMID0gc3RhdGUudG1wWzBdO1xuICBrUiA9IHN0YXRlLnRtcFsxXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5rZXlzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIHNoaWZ0ID0gc2hpZnRUYWJsZVtpID4+PiAxXTtcbiAgICBrTCA9IHV0aWxzLnIyOHNobChrTCwgc2hpZnQpO1xuICAgIGtSID0gdXRpbHMucjI4c2hsKGtSLCBzaGlmdCk7XG4gICAgdXRpbHMucGMyKGtMLCBrUiwgc3RhdGUua2V5cywgaSk7XG4gIH1cbn07XG5cbkRFUy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUoaW5wLCBpbk9mZiwgb3V0LCBvdXRPZmYpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fZGVzU3RhdGU7XG5cbiAgdmFyIGwgPSB1dGlscy5yZWFkVUludDMyQkUoaW5wLCBpbk9mZik7XG4gIHZhciByID0gdXRpbHMucmVhZFVJbnQzMkJFKGlucCwgaW5PZmYgKyA0KTtcblxuICAvLyBJbml0aWFsIFBlcm11dGF0aW9uXG4gIHV0aWxzLmlwKGwsIHIsIHN0YXRlLnRtcCwgMCk7XG4gIGwgPSBzdGF0ZS50bXBbMF07XG4gIHIgPSBzdGF0ZS50bXBbMV07XG5cbiAgaWYgKHRoaXMudHlwZSA9PT0gJ2VuY3J5cHQnKVxuICAgIHRoaXMuX2VuY3J5cHQoc3RhdGUsIGwsIHIsIHN0YXRlLnRtcCwgMCk7XG4gIGVsc2VcbiAgICB0aGlzLl9kZWNyeXB0KHN0YXRlLCBsLCByLCBzdGF0ZS50bXAsIDApO1xuXG4gIGwgPSBzdGF0ZS50bXBbMF07XG4gIHIgPSBzdGF0ZS50bXBbMV07XG5cbiAgdXRpbHMud3JpdGVVSW50MzJCRShvdXQsIGwsIG91dE9mZik7XG4gIHV0aWxzLndyaXRlVUludDMyQkUob3V0LCByLCBvdXRPZmYgKyA0KTtcbn07XG5cbkRFUy5wcm90b3R5cGUuX3BhZCA9IGZ1bmN0aW9uIF9wYWQoYnVmZmVyLCBvZmYpIHtcbiAgdmFyIHZhbHVlID0gYnVmZmVyLmxlbmd0aCAtIG9mZjtcbiAgZm9yICh2YXIgaSA9IG9mZjsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKylcbiAgICBidWZmZXJbaV0gPSB2YWx1ZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkRFUy5wcm90b3R5cGUuX3VucGFkID0gZnVuY3Rpb24gX3VucGFkKGJ1ZmZlcikge1xuICB2YXIgcGFkID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSAxXTtcbiAgZm9yICh2YXIgaSA9IGJ1ZmZlci5sZW5ndGggLSBwYWQ7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspXG4gICAgYXNzZXJ0LmVxdWFsKGJ1ZmZlcltpXSwgcGFkKTtcblxuICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIGJ1ZmZlci5sZW5ndGggLSBwYWQpO1xufTtcblxuREVTLnByb3RvdHlwZS5fZW5jcnlwdCA9IGZ1bmN0aW9uIF9lbmNyeXB0KHN0YXRlLCBsU3RhcnQsIHJTdGFydCwgb3V0LCBvZmYpIHtcbiAgdmFyIGwgPSBsU3RhcnQ7XG4gIHZhciByID0gclN0YXJ0O1xuXG4gIC8vIEFwcGx5IGYoKSB4MTYgdGltZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5rZXlzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGtleUwgPSBzdGF0ZS5rZXlzW2ldO1xuICAgIHZhciBrZXlSID0gc3RhdGUua2V5c1tpICsgMV07XG5cbiAgICAvLyBmKHIsIGspXG4gICAgdXRpbHMuZXhwYW5kKHIsIHN0YXRlLnRtcCwgMCk7XG5cbiAgICBrZXlMIF49IHN0YXRlLnRtcFswXTtcbiAgICBrZXlSIF49IHN0YXRlLnRtcFsxXTtcbiAgICB2YXIgcyA9IHV0aWxzLnN1YnN0aXR1dGUoa2V5TCwga2V5Uik7XG4gICAgdmFyIGYgPSB1dGlscy5wZXJtdXRlKHMpO1xuXG4gICAgdmFyIHQgPSByO1xuICAgIHIgPSAobCBeIGYpID4+PiAwO1xuICAgIGwgPSB0O1xuICB9XG5cbiAgLy8gUmV2ZXJzZSBJbml0aWFsIFBlcm11dGF0aW9uXG4gIHV0aWxzLnJpcChyLCBsLCBvdXQsIG9mZik7XG59O1xuXG5ERVMucHJvdG90eXBlLl9kZWNyeXB0ID0gZnVuY3Rpb24gX2RlY3J5cHQoc3RhdGUsIGxTdGFydCwgclN0YXJ0LCBvdXQsIG9mZikge1xuICB2YXIgbCA9IHJTdGFydDtcbiAgdmFyIHIgPSBsU3RhcnQ7XG5cbiAgLy8gQXBwbHkgZigpIHgxNiB0aW1lc1xuICBmb3IgKHZhciBpID0gc3RhdGUua2V5cy5sZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgIHZhciBrZXlMID0gc3RhdGUua2V5c1tpXTtcbiAgICB2YXIga2V5UiA9IHN0YXRlLmtleXNbaSArIDFdO1xuXG4gICAgLy8gZihyLCBrKVxuICAgIHV0aWxzLmV4cGFuZChsLCBzdGF0ZS50bXAsIDApO1xuXG4gICAga2V5TCBePSBzdGF0ZS50bXBbMF07XG4gICAga2V5UiBePSBzdGF0ZS50bXBbMV07XG4gICAgdmFyIHMgPSB1dGlscy5zdWJzdGl0dXRlKGtleUwsIGtleVIpO1xuICAgIHZhciBmID0gdXRpbHMucGVybXV0ZShzKTtcblxuICAgIHZhciB0ID0gbDtcbiAgICBsID0gKHIgXiBmKSA+Pj4gMDtcbiAgICByID0gdDtcbiAgfVxuXG4gIC8vIFJldmVyc2UgSW5pdGlhbCBQZXJtdXRhdGlvblxuICB1dGlscy5yaXAobCwgciwgb3V0LCBvZmYpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBkZXMgPSByZXF1aXJlKCcuLi9kZXMnKTtcbnZhciBDaXBoZXIgPSBkZXMuQ2lwaGVyO1xudmFyIERFUyA9IGRlcy5ERVM7XG5cbmZ1bmN0aW9uIEVERVN0YXRlKHR5cGUsIGtleSkge1xuICBhc3NlcnQuZXF1YWwoa2V5Lmxlbmd0aCwgMjQsICdJbnZhbGlkIGtleSBsZW5ndGgnKTtcblxuICB2YXIgazEgPSBrZXkuc2xpY2UoMCwgOCk7XG4gIHZhciBrMiA9IGtleS5zbGljZSg4LCAxNik7XG4gIHZhciBrMyA9IGtleS5zbGljZSgxNiwgMjQpO1xuXG4gIGlmICh0eXBlID09PSAnZW5jcnlwdCcpIHtcbiAgICB0aGlzLmNpcGhlcnMgPSBbXG4gICAgICBERVMuY3JlYXRlKHsgdHlwZTogJ2VuY3J5cHQnLCBrZXk6IGsxIH0pLFxuICAgICAgREVTLmNyZWF0ZSh7IHR5cGU6ICdkZWNyeXB0Jywga2V5OiBrMiB9KSxcbiAgICAgIERFUy5jcmVhdGUoeyB0eXBlOiAnZW5jcnlwdCcsIGtleTogazMgfSlcbiAgICBdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuY2lwaGVycyA9IFtcbiAgICAgIERFUy5jcmVhdGUoeyB0eXBlOiAnZGVjcnlwdCcsIGtleTogazMgfSksXG4gICAgICBERVMuY3JlYXRlKHsgdHlwZTogJ2VuY3J5cHQnLCBrZXk6IGsyIH0pLFxuICAgICAgREVTLmNyZWF0ZSh7IHR5cGU6ICdkZWNyeXB0Jywga2V5OiBrMSB9KVxuICAgIF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRURFKG9wdGlvbnMpIHtcbiAgQ2lwaGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdmFyIHN0YXRlID0gbmV3IEVERVN0YXRlKHRoaXMudHlwZSwgdGhpcy5vcHRpb25zLmtleSk7XG4gIHRoaXMuX2VkZVN0YXRlID0gc3RhdGU7XG59XG5pbmhlcml0cyhFREUsIENpcGhlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gRURFO1xuXG5FREUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBFREUob3B0aW9ucyk7XG59O1xuXG5FREUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKGlucCwgaW5PZmYsIG91dCwgb3V0T2ZmKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2VkZVN0YXRlO1xuXG4gIHN0YXRlLmNpcGhlcnNbMF0uX3VwZGF0ZShpbnAsIGluT2ZmLCBvdXQsIG91dE9mZik7XG4gIHN0YXRlLmNpcGhlcnNbMV0uX3VwZGF0ZShvdXQsIG91dE9mZiwgb3V0LCBvdXRPZmYpO1xuICBzdGF0ZS5jaXBoZXJzWzJdLl91cGRhdGUob3V0LCBvdXRPZmYsIG91dCwgb3V0T2ZmKTtcbn07XG5cbkVERS5wcm90b3R5cGUuX3BhZCA9IERFUy5wcm90b3R5cGUuX3BhZDtcbkVERS5wcm90b3R5cGUuX3VucGFkID0gREVTLnByb3RvdHlwZS5fdW5wYWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFKGJ5dGVzLCBvZmYpIHtcbiAgdmFyIHJlcyA9ICAoYnl0ZXNbMCArIG9mZl0gPDwgMjQpIHxcbiAgICAgICAgICAgICAoYnl0ZXNbMSArIG9mZl0gPDwgMTYpIHxcbiAgICAgICAgICAgICAoYnl0ZXNbMiArIG9mZl0gPDwgOCkgfFxuICAgICAgICAgICAgIGJ5dGVzWzMgKyBvZmZdO1xuICByZXR1cm4gcmVzID4+PiAwO1xufTtcblxuZXhwb3J0cy53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRShieXRlcywgdmFsdWUsIG9mZikge1xuICBieXRlc1swICsgb2ZmXSA9IHZhbHVlID4+PiAyNDtcbiAgYnl0ZXNbMSArIG9mZl0gPSAodmFsdWUgPj4+IDE2KSAmIDB4ZmY7XG4gIGJ5dGVzWzIgKyBvZmZdID0gKHZhbHVlID4+PiA4KSAmIDB4ZmY7XG4gIGJ5dGVzWzMgKyBvZmZdID0gdmFsdWUgJiAweGZmO1xufTtcblxuZXhwb3J0cy5pcCA9IGZ1bmN0aW9uIGlwKGluTCwgaW5SLCBvdXQsIG9mZikge1xuICB2YXIgb3V0TCA9IDA7XG4gIHZhciBvdXRSID0gMDtcblxuICBmb3IgKHZhciBpID0gNjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgICBvdXRMIDw8PSAxO1xuICAgICAgb3V0TCB8PSAoaW5SID4+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICAgIG91dEwgPDw9IDE7XG4gICAgICBvdXRMIHw9IChpbkwgPj4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gNjsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSAyNTsgaiArPSA4KSB7XG4gICAgICBvdXRSIDw8PSAxO1xuICAgICAgb3V0UiB8PSAoaW5SID4+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAxOyBqIDw9IDI1OyBqICs9IDgpIHtcbiAgICAgIG91dFIgPDw9IDE7XG4gICAgICBvdXRSIHw9IChpbkwgPj4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gIH1cblxuICBvdXRbb2ZmICsgMF0gPSBvdXRMID4+PiAwO1xuICBvdXRbb2ZmICsgMV0gPSBvdXRSID4+PiAwO1xufTtcblxuZXhwb3J0cy5yaXAgPSBmdW5jdGlvbiByaXAoaW5MLCBpblIsIG91dCwgb2ZmKSB7XG4gIHZhciBvdXRMID0gMDtcbiAgdmFyIG91dFIgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDI0OyBqID49IDA7IGogLT0gOCkge1xuICAgICAgb3V0TCA8PD0gMTtcbiAgICAgIG91dEwgfD0gKGluUiA+Pj4gKGogKyBpKSkgJiAxO1xuICAgICAgb3V0TCA8PD0gMTtcbiAgICAgIG91dEwgfD0gKGluTCA+Pj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBpID0gNDsgaSA8IDg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAyNDsgaiA+PSAwOyBqIC09IDgpIHtcbiAgICAgIG91dFIgPDw9IDE7XG4gICAgICBvdXRSIHw9IChpblIgPj4+IChqICsgaSkpICYgMTtcbiAgICAgIG91dFIgPDw9IDE7XG4gICAgICBvdXRSIHw9IChpbkwgPj4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gIH1cblxuICBvdXRbb2ZmICsgMF0gPSBvdXRMID4+PiAwO1xuICBvdXRbb2ZmICsgMV0gPSBvdXRSID4+PiAwO1xufTtcblxuZXhwb3J0cy5wYzEgPSBmdW5jdGlvbiBwYzEoaW5MLCBpblIsIG91dCwgb2ZmKSB7XG4gIHZhciBvdXRMID0gMDtcbiAgdmFyIG91dFIgPSAwO1xuXG4gIC8vIDcsIDE1LCAyMywgMzEsIDM5LCA0NywgNTUsIDYzXG4gIC8vIDYsIDE0LCAyMiwgMzAsIDM5LCA0NywgNTUsIDYzXG4gIC8vIDUsIDEzLCAyMSwgMjksIDM5LCA0NywgNTUsIDYzXG4gIC8vIDQsIDEyLCAyMCwgMjhcbiAgZm9yICh2YXIgaSA9IDc7IGkgPj0gNTsgaS0tKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgICAgb3V0TCA8PD0gMTtcbiAgICAgIG91dEwgfD0gKGluUiA+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICAgIG91dEwgPDw9IDE7XG4gICAgICBvdXRMIHw9IChpbkwgPj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgb3V0TCA8PD0gMTtcbiAgICBvdXRMIHw9IChpblIgPj4gKGogKyBpKSkgJiAxO1xuICB9XG5cbiAgLy8gMSwgOSwgMTcsIDI1LCAzMywgNDEsIDQ5LCA1N1xuICAvLyAyLCAxMCwgMTgsIDI2LCAzNCwgNDIsIDUwLCA1OFxuICAvLyAzLCAxMSwgMTksIDI3LCAzNSwgNDMsIDUxLCA1OVxuICAvLyAzNiwgNDQsIDUyLCA2MFxuICBmb3IgKHZhciBpID0gMTsgaSA8PSAzOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgICBvdXRSIDw8PSAxO1xuICAgICAgb3V0UiB8PSAoaW5SID4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgICAgb3V0UiA8PD0gMTtcbiAgICAgIG91dFIgfD0gKGluTCA+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICBvdXRSIDw8PSAxO1xuICAgIG91dFIgfD0gKGluTCA+PiAoaiArIGkpKSAmIDE7XG4gIH1cblxuICBvdXRbb2ZmICsgMF0gPSBvdXRMID4+PiAwO1xuICBvdXRbb2ZmICsgMV0gPSBvdXRSID4+PiAwO1xufTtcblxuZXhwb3J0cy5yMjhzaGwgPSBmdW5jdGlvbiByMjhzaGwobnVtLCBzaGlmdCkge1xuICByZXR1cm4gKChudW0gPDwgc2hpZnQpICYgMHhmZmZmZmZmKSB8IChudW0gPj4+ICgyOCAtIHNoaWZ0KSk7XG59O1xuXG52YXIgcGMydGFibGUgPSBbXG4gIC8vIGluTCA9PiBvdXRMXG4gIDE0LCAxMSwgMTcsIDQsIDI3LCAyMywgMjUsIDAsXG4gIDEzLCAyMiwgNywgMTgsIDUsIDksIDE2LCAyNCxcbiAgMiwgMjAsIDEyLCAyMSwgMSwgOCwgMTUsIDI2LFxuXG4gIC8vIGluUiA9PiBvdXRSXG4gIDE1LCA0LCAyNSwgMTksIDksIDEsIDI2LCAxNixcbiAgNSwgMTEsIDIzLCA4LCAxMiwgNywgMTcsIDAsXG4gIDIyLCAzLCAxMCwgMTQsIDYsIDIwLCAyNywgMjRcbl07XG5cbmV4cG9ydHMucGMyID0gZnVuY3Rpb24gcGMyKGluTCwgaW5SLCBvdXQsIG9mZikge1xuICB2YXIgb3V0TCA9IDA7XG4gIHZhciBvdXRSID0gMDtcblxuICB2YXIgbGVuID0gcGMydGFibGUubGVuZ3RoID4+PiAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0TCA8PD0gMTtcbiAgICBvdXRMIHw9IChpbkwgPj4+IHBjMnRhYmxlW2ldKSAmIDB4MTtcbiAgfVxuICBmb3IgKHZhciBpID0gbGVuOyBpIDwgcGMydGFibGUubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRSIDw8PSAxO1xuICAgIG91dFIgfD0gKGluUiA+Pj4gcGMydGFibGVbaV0pICYgMHgxO1xuICB9XG5cbiAgb3V0W29mZiArIDBdID0gb3V0TCA+Pj4gMDtcbiAgb3V0W29mZiArIDFdID0gb3V0UiA+Pj4gMDtcbn07XG5cbmV4cG9ydHMuZXhwYW5kID0gZnVuY3Rpb24gZXhwYW5kKHIsIG91dCwgb2ZmKSB7XG4gIHZhciBvdXRMID0gMDtcbiAgdmFyIG91dFIgPSAwO1xuXG4gIG91dEwgPSAoKHIgJiAxKSA8PCA1KSB8IChyID4+PiAyNyk7XG4gIGZvciAodmFyIGkgPSAyMzsgaSA+PSAxNTsgaSAtPSA0KSB7XG4gICAgb3V0TCA8PD0gNjtcbiAgICBvdXRMIHw9IChyID4+PiBpKSAmIDB4M2Y7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDExOyBpID49IDM7IGkgLT0gNCkge1xuICAgIG91dFIgfD0gKHIgPj4+IGkpICYgMHgzZjtcbiAgICBvdXRSIDw8PSA2O1xuICB9XG4gIG91dFIgfD0gKChyICYgMHgxZikgPDwgMSkgfCAociA+Pj4gMzEpO1xuXG4gIG91dFtvZmYgKyAwXSA9IG91dEwgPj4+IDA7XG4gIG91dFtvZmYgKyAxXSA9IG91dFIgPj4+IDA7XG59O1xuXG52YXIgc1RhYmxlID0gW1xuICAxNCwgMCwgNCwgMTUsIDEzLCA3LCAxLCA0LCAyLCAxNCwgMTUsIDIsIDExLCAxMywgOCwgMSxcbiAgMywgMTAsIDEwLCA2LCA2LCAxMiwgMTIsIDExLCA1LCA5LCA5LCA1LCAwLCAzLCA3LCA4LFxuICA0LCAxNSwgMSwgMTIsIDE0LCA4LCA4LCAyLCAxMywgNCwgNiwgOSwgMiwgMSwgMTEsIDcsXG4gIDE1LCA1LCAxMiwgMTEsIDksIDMsIDcsIDE0LCAzLCAxMCwgMTAsIDAsIDUsIDYsIDAsIDEzLFxuXG4gIDE1LCAzLCAxLCAxMywgOCwgNCwgMTQsIDcsIDYsIDE1LCAxMSwgMiwgMywgOCwgNCwgMTQsXG4gIDksIDEyLCA3LCAwLCAyLCAxLCAxMywgMTAsIDEyLCA2LCAwLCA5LCA1LCAxMSwgMTAsIDUsXG4gIDAsIDEzLCAxNCwgOCwgNywgMTAsIDExLCAxLCAxMCwgMywgNCwgMTUsIDEzLCA0LCAxLCAyLFxuICA1LCAxMSwgOCwgNiwgMTIsIDcsIDYsIDEyLCA5LCAwLCAzLCA1LCAyLCAxNCwgMTUsIDksXG5cbiAgMTAsIDEzLCAwLCA3LCA5LCAwLCAxNCwgOSwgNiwgMywgMywgNCwgMTUsIDYsIDUsIDEwLFxuICAxLCAyLCAxMywgOCwgMTIsIDUsIDcsIDE0LCAxMSwgMTIsIDQsIDExLCAyLCAxNSwgOCwgMSxcbiAgMTMsIDEsIDYsIDEwLCA0LCAxMywgOSwgMCwgOCwgNiwgMTUsIDksIDMsIDgsIDAsIDcsXG4gIDExLCA0LCAxLCAxNSwgMiwgMTQsIDEyLCAzLCA1LCAxMSwgMTAsIDUsIDE0LCAyLCA3LCAxMixcblxuICA3LCAxMywgMTMsIDgsIDE0LCAxMSwgMywgNSwgMCwgNiwgNiwgMTUsIDksIDAsIDEwLCAzLFxuICAxLCA0LCAyLCA3LCA4LCAyLCA1LCAxMiwgMTEsIDEsIDEyLCAxMCwgNCwgMTQsIDE1LCA5LFxuICAxMCwgMywgNiwgMTUsIDksIDAsIDAsIDYsIDEyLCAxMCwgMTEsIDEsIDcsIDEzLCAxMywgOCxcbiAgMTUsIDksIDEsIDQsIDMsIDUsIDE0LCAxMSwgNSwgMTIsIDIsIDcsIDgsIDIsIDQsIDE0LFxuXG4gIDIsIDE0LCAxMiwgMTEsIDQsIDIsIDEsIDEyLCA3LCA0LCAxMCwgNywgMTEsIDEzLCA2LCAxLFxuICA4LCA1LCA1LCAwLCAzLCAxNSwgMTUsIDEwLCAxMywgMywgMCwgOSwgMTQsIDgsIDksIDYsXG4gIDQsIDExLCAyLCA4LCAxLCAxMiwgMTEsIDcsIDEwLCAxLCAxMywgMTQsIDcsIDIsIDgsIDEzLFxuICAxNSwgNiwgOSwgMTUsIDEyLCAwLCA1LCA5LCA2LCAxMCwgMywgNCwgMCwgNSwgMTQsIDMsXG5cbiAgMTIsIDEwLCAxLCAxNSwgMTAsIDQsIDE1LCAyLCA5LCA3LCAyLCAxMiwgNiwgOSwgOCwgNSxcbiAgMCwgNiwgMTMsIDEsIDMsIDEzLCA0LCAxNCwgMTQsIDAsIDcsIDExLCA1LCAzLCAxMSwgOCxcbiAgOSwgNCwgMTQsIDMsIDE1LCAyLCA1LCAxMiwgMiwgOSwgOCwgNSwgMTIsIDE1LCAzLCAxMCxcbiAgNywgMTEsIDAsIDE0LCA0LCAxLCAxMCwgNywgMSwgNiwgMTMsIDAsIDExLCA4LCA2LCAxMyxcblxuICA0LCAxMywgMTEsIDAsIDIsIDExLCAxNCwgNywgMTUsIDQsIDAsIDksIDgsIDEsIDEzLCAxMCxcbiAgMywgMTQsIDEyLCAzLCA5LCA1LCA3LCAxMiwgNSwgMiwgMTAsIDE1LCA2LCA4LCAxLCA2LFxuICAxLCA2LCA0LCAxMSwgMTEsIDEzLCAxMywgOCwgMTIsIDEsIDMsIDQsIDcsIDEwLCAxNCwgNyxcbiAgMTAsIDksIDE1LCA1LCA2LCAwLCA4LCAxNSwgMCwgMTQsIDUsIDIsIDksIDMsIDIsIDEyLFxuXG4gIDEzLCAxLCAyLCAxNSwgOCwgMTMsIDQsIDgsIDYsIDEwLCAxNSwgMywgMTEsIDcsIDEsIDQsXG4gIDEwLCAxMiwgOSwgNSwgMywgNiwgMTQsIDExLCA1LCAwLCAwLCAxNCwgMTIsIDksIDcsIDIsXG4gIDcsIDIsIDExLCAxLCA0LCAxNCwgMSwgNywgOSwgNCwgMTIsIDEwLCAxNCwgOCwgMiwgMTMsXG4gIDAsIDE1LCA2LCAxMiwgMTAsIDksIDEzLCAwLCAxNSwgMywgMywgNSwgNSwgNiwgOCwgMTFcbl07XG5cbmV4cG9ydHMuc3Vic3RpdHV0ZSA9IGZ1bmN0aW9uIHN1YnN0aXR1dGUoaW5MLCBpblIpIHtcbiAgdmFyIG91dCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgdmFyIGIgPSAoaW5MID4+PiAoMTggLSBpICogNikpICYgMHgzZjtcbiAgICB2YXIgc2IgPSBzVGFibGVbaSAqIDB4NDAgKyBiXTtcblxuICAgIG91dCA8PD0gNDtcbiAgICBvdXQgfD0gc2I7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICB2YXIgYiA9IChpblIgPj4+ICgxOCAtIGkgKiA2KSkgJiAweDNmO1xuICAgIHZhciBzYiA9IHNUYWJsZVs0ICogMHg0MCArIGkgKiAweDQwICsgYl07XG5cbiAgICBvdXQgPDw9IDQ7XG4gICAgb3V0IHw9IHNiO1xuICB9XG4gIHJldHVybiBvdXQgPj4+IDA7XG59O1xuXG52YXIgcGVybXV0ZVRhYmxlID0gW1xuICAxNiwgMjUsIDEyLCAxMSwgMywgMjAsIDQsIDE1LCAzMSwgMTcsIDksIDYsIDI3LCAxNCwgMSwgMjIsXG4gIDMwLCAyNCwgOCwgMTgsIDAsIDUsIDI5LCAyMywgMTMsIDE5LCAyLCAyNiwgMTAsIDIxLCAyOCwgN1xuXTtcblxuZXhwb3J0cy5wZXJtdXRlID0gZnVuY3Rpb24gcGVybXV0ZShudW0pIHtcbiAgdmFyIG91dCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGVybXV0ZVRhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0IDw8PSAxO1xuICAgIG91dCB8PSAobnVtID4+PiBwZXJtdXRlVGFibGVbaV0pICYgMHgxO1xuICB9XG4gIHJldHVybiBvdXQgPj4+IDA7XG59O1xuXG5leHBvcnRzLnBhZFNwbGl0ID0gZnVuY3Rpb24gcGFkU3BsaXQobnVtLCBzaXplLCBncm91cCkge1xuICB2YXIgc3RyID0gbnVtLnRvU3RyaW5nKDIpO1xuICB3aGlsZSAoc3RyLmxlbmd0aCA8IHNpemUpXG4gICAgc3RyID0gJzAnICsgc3RyO1xuXG4gIHZhciBvdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpICs9IGdyb3VwKVxuICAgIG91dC5wdXNoKHN0ci5zbGljZShpLCBpICsgZ3JvdXApKTtcbiAgcmV0dXJuIG91dC5qb2luKCcgJyk7XG59O1xuIiwidmFyIGdlbmVyYXRlUHJpbWUgPSByZXF1aXJlKCcuL2xpYi9nZW5lcmF0ZVByaW1lJylcbnZhciBwcmltZXMgPSByZXF1aXJlKCcuL2xpYi9wcmltZXMuanNvbicpXG5cbnZhciBESCA9IHJlcXVpcmUoJy4vbGliL2RoJylcblxuZnVuY3Rpb24gZ2V0RGlmZmllSGVsbG1hbiAobW9kKSB7XG4gIHZhciBwcmltZSA9IG5ldyBCdWZmZXIocHJpbWVzW21vZF0ucHJpbWUsICdoZXgnKVxuICB2YXIgZ2VuID0gbmV3IEJ1ZmZlcihwcmltZXNbbW9kXS5nZW4sICdoZXgnKVxuXG4gIHJldHVybiBuZXcgREgocHJpbWUsIGdlbilcbn1cblxudmFyIEVOQ09ESU5HUyA9IHtcbiAgJ2JpbmFyeSc6IHRydWUsICdoZXgnOiB0cnVlLCAnYmFzZTY0JzogdHJ1ZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEaWZmaWVIZWxsbWFuIChwcmltZSwgZW5jLCBnZW5lcmF0b3IsIGdlbmMpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihlbmMpIHx8IEVOQ09ESU5HU1tlbmNdID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY3JlYXRlRGlmZmllSGVsbG1hbihwcmltZSwgJ2JpbmFyeScsIGVuYywgZ2VuZXJhdG9yKVxuICB9XG5cbiAgZW5jID0gZW5jIHx8ICdiaW5hcnknXG4gIGdlbmMgPSBnZW5jIHx8ICdiaW5hcnknXG4gIGdlbmVyYXRvciA9IGdlbmVyYXRvciB8fCBuZXcgQnVmZmVyKFsyXSlcblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihnZW5lcmF0b3IpKSB7XG4gICAgZ2VuZXJhdG9yID0gbmV3IEJ1ZmZlcihnZW5lcmF0b3IsIGdlbmMpXG4gIH1cblxuICBpZiAodHlwZW9mIHByaW1lID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBuZXcgREgoZ2VuZXJhdGVQcmltZShwcmltZSwgZ2VuZXJhdG9yKSwgZ2VuZXJhdG9yLCB0cnVlKVxuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocHJpbWUpKSB7XG4gICAgcHJpbWUgPSBuZXcgQnVmZmVyKHByaW1lLCBlbmMpXG4gIH1cblxuICByZXR1cm4gbmV3IERIKHByaW1lLCBnZW5lcmF0b3IsIHRydWUpXG59XG5cbmV4cG9ydHMuRGlmZmllSGVsbG1hbkdyb3VwID0gZXhwb3J0cy5jcmVhdGVEaWZmaWVIZWxsbWFuR3JvdXAgPSBleHBvcnRzLmdldERpZmZpZUhlbGxtYW4gPSBnZXREaWZmaWVIZWxsbWFuXG5leHBvcnRzLmNyZWF0ZURpZmZpZUhlbGxtYW4gPSBleHBvcnRzLkRpZmZpZUhlbGxtYW4gPSBjcmVhdGVEaWZmaWVIZWxsbWFuXG4iLCJ2YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIE1pbGxlclJhYmluID0gcmVxdWlyZSgnbWlsbGVyLXJhYmluJyk7XG52YXIgbWlsbGVyUmFiaW4gPSBuZXcgTWlsbGVyUmFiaW4oKTtcbnZhciBUV0VOVFlGT1VSID0gbmV3IEJOKDI0KTtcbnZhciBFTEVWRU4gPSBuZXcgQk4oMTEpO1xudmFyIFRFTiA9IG5ldyBCTigxMCk7XG52YXIgVEhSRUUgPSBuZXcgQk4oMyk7XG52YXIgU0VWRU4gPSBuZXcgQk4oNyk7XG52YXIgcHJpbWVzID0gcmVxdWlyZSgnLi9nZW5lcmF0ZVByaW1lJyk7XG52YXIgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpO1xubW9kdWxlLmV4cG9ydHMgPSBESDtcblxuZnVuY3Rpb24gc2V0UHVibGljS2V5KHB1YiwgZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAndXRmOCc7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHB1YikpIHtcbiAgICBwdWIgPSBuZXcgQnVmZmVyKHB1YiwgZW5jKTtcbiAgfVxuICB0aGlzLl9wdWIgPSBuZXcgQk4ocHViKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHNldFByaXZhdGVLZXkocHJpdiwgZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAndXRmOCc7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHByaXYpKSB7XG4gICAgcHJpdiA9IG5ldyBCdWZmZXIocHJpdiwgZW5jKTtcbiAgfVxuICB0aGlzLl9wcml2ID0gbmV3IEJOKHByaXYpO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByaW1lQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGNoZWNrUHJpbWUocHJpbWUsIGdlbmVyYXRvcikge1xuICB2YXIgZ2VuID0gZ2VuZXJhdG9yLnRvU3RyaW5nKCdoZXgnKTtcbiAgdmFyIGhleCA9IFtnZW4sIHByaW1lLnRvU3RyaW5nKDE2KV0uam9pbignXycpO1xuICBpZiAoaGV4IGluIHByaW1lQ2FjaGUpIHtcbiAgICByZXR1cm4gcHJpbWVDYWNoZVtoZXhdO1xuICB9XG4gIHZhciBlcnJvciA9IDA7XG5cbiAgaWYgKHByaW1lLmlzRXZlbigpIHx8XG4gICAgIXByaW1lcy5zaW1wbGVTaWV2ZSB8fFxuICAgICFwcmltZXMuZmVybWF0VGVzdChwcmltZSkgfHxcbiAgICAhbWlsbGVyUmFiaW4udGVzdChwcmltZSkpIHtcbiAgICAvL25vdCBhIHByaW1lIHNvICsxXG4gICAgZXJyb3IgKz0gMTtcblxuICAgIGlmIChnZW4gPT09ICcwMicgfHwgZ2VuID09PSAnMDUnKSB7XG4gICAgICAvLyB3ZSdkIGJlIGFibGUgdG8gY2hlY2sgdGhlIGdlbmVyYXRvclxuICAgICAgLy8gaXQgd291bGQgZmFpbCBzbyArOFxuICAgICAgZXJyb3IgKz0gODtcbiAgICB9IGVsc2Uge1xuICAgICAgLy93ZSB3b3VsZG4ndCBiZSBhYmxlIHRvIHRlc3QgdGhlIGdlbmVyYXRvclxuICAgICAgLy8gc28gKzRcbiAgICAgIGVycm9yICs9IDQ7XG4gICAgfVxuICAgIHByaW1lQ2FjaGVbaGV4XSA9IGVycm9yO1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBpZiAoIW1pbGxlclJhYmluLnRlc3QocHJpbWUuc2hybigxKSkpIHtcbiAgICAvL25vdCBhIHNhZmUgcHJpbWVcbiAgICBlcnJvciArPSAyO1xuICB9XG4gIHZhciByZW07XG4gIHN3aXRjaCAoZ2VuKSB7XG4gICAgY2FzZSAnMDInOlxuICAgICAgaWYgKHByaW1lLm1vZChUV0VOVFlGT1VSKS5jbXAoRUxFVkVOKSkge1xuICAgICAgICAvLyB1bnN1aWRhYmxlIGdlbmVyYXRvclxuICAgICAgICBlcnJvciArPSA4O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnMDUnOlxuICAgICAgcmVtID0gcHJpbWUubW9kKFRFTik7XG4gICAgICBpZiAocmVtLmNtcChUSFJFRSkgJiYgcmVtLmNtcChTRVZFTikpIHtcbiAgICAgICAgLy8gcHJpbWUgbW9kIDEwIG5lZWRzIHRvIGVxdWFsIDMgb3IgN1xuICAgICAgICBlcnJvciArPSA4O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGVycm9yICs9IDQ7XG4gIH1cbiAgcHJpbWVDYWNoZVtoZXhdID0gZXJyb3I7XG4gIHJldHVybiBlcnJvcjtcbn1cblxuZnVuY3Rpb24gREgocHJpbWUsIGdlbmVyYXRvciwgbWFsbGVhYmxlKSB7XG4gIHRoaXMuc2V0R2VuZXJhdG9yKGdlbmVyYXRvcik7XG4gIHRoaXMuX19wcmltZSA9IG5ldyBCTihwcmltZSk7XG4gIHRoaXMuX3ByaW1lID0gQk4ubW9udCh0aGlzLl9fcHJpbWUpO1xuICB0aGlzLl9wcmltZUxlbiA9IHByaW1lLmxlbmd0aDtcbiAgdGhpcy5fcHViID0gdW5kZWZpbmVkO1xuICB0aGlzLl9wcml2ID0gdW5kZWZpbmVkO1xuICB0aGlzLl9wcmltZUNvZGUgPSB1bmRlZmluZWQ7XG4gIGlmIChtYWxsZWFibGUpIHtcbiAgICB0aGlzLnNldFB1YmxpY0tleSA9IHNldFB1YmxpY0tleTtcbiAgICB0aGlzLnNldFByaXZhdGVLZXkgPSBzZXRQcml2YXRlS2V5O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3ByaW1lQ29kZSA9IDg7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShESC5wcm90b3R5cGUsICd2ZXJpZnlFcnJvcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9wcmltZUNvZGUgIT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLl9wcmltZUNvZGUgPSBjaGVja1ByaW1lKHRoaXMuX19wcmltZSwgdGhpcy5fX2dlbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcmltZUNvZGU7XG4gIH1cbn0pO1xuREgucHJvdG90eXBlLmdlbmVyYXRlS2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLl9wcml2KSB7XG4gICAgdGhpcy5fcHJpdiA9IG5ldyBCTihyYW5kb21CeXRlcyh0aGlzLl9wcmltZUxlbikpO1xuICB9XG4gIHRoaXMuX3B1YiA9IHRoaXMuX2dlbi50b1JlZCh0aGlzLl9wcmltZSkucmVkUG93KHRoaXMuX3ByaXYpLmZyb21SZWQoKTtcbiAgcmV0dXJuIHRoaXMuZ2V0UHVibGljS2V5KCk7XG59O1xuXG5ESC5wcm90b3R5cGUuY29tcHV0ZVNlY3JldCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICBvdGhlciA9IG5ldyBCTihvdGhlcik7XG4gIG90aGVyID0gb3RoZXIudG9SZWQodGhpcy5fcHJpbWUpO1xuICB2YXIgc2VjcmV0ID0gb3RoZXIucmVkUG93KHRoaXMuX3ByaXYpLmZyb21SZWQoKTtcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIoc2VjcmV0LnRvQXJyYXkoKSk7XG4gIHZhciBwcmltZSA9IHRoaXMuZ2V0UHJpbWUoKTtcbiAgaWYgKG91dC5sZW5ndGggPCBwcmltZS5sZW5ndGgpIHtcbiAgICB2YXIgZnJvbnQgPSBuZXcgQnVmZmVyKHByaW1lLmxlbmd0aCAtIG91dC5sZW5ndGgpO1xuICAgIGZyb250LmZpbGwoMCk7XG4gICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbZnJvbnQsIG91dF0pO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG5ESC5wcm90b3R5cGUuZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24gZ2V0UHVibGljS2V5KGVuYykge1xuICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUodGhpcy5fcHViLCBlbmMpO1xufTtcblxuREgucHJvdG90eXBlLmdldFByaXZhdGVLZXkgPSBmdW5jdGlvbiBnZXRQcml2YXRlS2V5KGVuYykge1xuICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUodGhpcy5fcHJpdiwgZW5jKTtcbn07XG5cbkRILnByb3RvdHlwZS5nZXRQcmltZSA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKHRoaXMuX19wcmltZSwgZW5jKTtcbn07XG5cbkRILnByb3RvdHlwZS5nZXRHZW5lcmF0b3IgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZSh0aGlzLl9nZW4sIGVuYyk7XG59O1xuXG5ESC5wcm90b3R5cGUuc2V0R2VuZXJhdG9yID0gZnVuY3Rpb24gKGdlbiwgZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAndXRmOCc7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGdlbikpIHtcbiAgICBnZW4gPSBuZXcgQnVmZmVyKGdlbiwgZW5jKTtcbiAgfVxuICB0aGlzLl9fZ2VuID0gZ2VuO1xuICB0aGlzLl9nZW4gPSBuZXcgQk4oZ2VuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmb3JtYXRSZXR1cm5WYWx1ZShibiwgZW5jKSB7XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKGJuLnRvQXJyYXkoKSk7XG4gIGlmICghZW5jKSB7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYnVmLnRvU3RyaW5nKGVuYyk7XG4gIH1cbn1cbiIsInZhciByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRQcmltZTtcbmZpbmRQcmltZS5zaW1wbGVTaWV2ZSA9IHNpbXBsZVNpZXZlO1xuZmluZFByaW1lLmZlcm1hdFRlc3QgPSBmZXJtYXRUZXN0O1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBUV0VOVFlGT1VSID0gbmV3IEJOKDI0KTtcbnZhciBNaWxsZXJSYWJpbiA9IHJlcXVpcmUoJ21pbGxlci1yYWJpbicpO1xudmFyIG1pbGxlclJhYmluID0gbmV3IE1pbGxlclJhYmluKCk7XG52YXIgT05FID0gbmV3IEJOKDEpO1xudmFyIFRXTyA9IG5ldyBCTigyKTtcbnZhciBGSVZFID0gbmV3IEJOKDUpO1xudmFyIFNJWFRFRU4gPSBuZXcgQk4oMTYpO1xudmFyIEVJR0hUID0gbmV3IEJOKDgpO1xudmFyIFRFTiA9IG5ldyBCTigxMCk7XG52YXIgVEhSRUUgPSBuZXcgQk4oMyk7XG52YXIgU0VWRU4gPSBuZXcgQk4oNyk7XG52YXIgRUxFVkVOID0gbmV3IEJOKDExKTtcbnZhciBGT1VSID0gbmV3IEJOKDQpO1xudmFyIFRXRUxWRSA9IG5ldyBCTigxMik7XG52YXIgcHJpbWVzID0gbnVsbDtcblxuZnVuY3Rpb24gX2dldFByaW1lcygpIHtcbiAgaWYgKHByaW1lcyAhPT0gbnVsbClcbiAgICByZXR1cm4gcHJpbWVzO1xuXG4gIHZhciBsaW1pdCA9IDB4MTAwMDAwO1xuICB2YXIgcmVzID0gW107XG4gIHJlc1swXSA9IDI7XG4gIGZvciAodmFyIGkgPSAxLCBrID0gMzsgayA8IGxpbWl0OyBrICs9IDIpIHtcbiAgICB2YXIgc3FydCA9IE1hdGguY2VpbChNYXRoLnNxcnQoaykpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaSAmJiByZXNbal0gPD0gc3FydDsgaisrKVxuICAgICAgaWYgKGsgJSByZXNbal0gPT09IDApXG4gICAgICAgIGJyZWFrO1xuXG4gICAgaWYgKGkgIT09IGogJiYgcmVzW2pdIDw9IHNxcnQpXG4gICAgICBjb250aW51ZTtcblxuICAgIHJlc1tpKytdID0gaztcbiAgfVxuICBwcmltZXMgPSByZXM7XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZVNpZXZlKHApIHtcbiAgdmFyIHByaW1lcyA9IF9nZXRQcmltZXMoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByaW1lcy5sZW5ndGg7IGkrKylcbiAgICBpZiAocC5tb2RuKHByaW1lc1tpXSkgPT09IDApIHtcbiAgICAgIGlmIChwLmNtcG4ocHJpbWVzW2ldKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGZlcm1hdFRlc3QocCkge1xuICB2YXIgcmVkID0gQk4ubW9udChwKTtcbiAgcmV0dXJuIFRXTy50b1JlZChyZWQpLnJlZFBvdyhwLnN1Ym4oMSkpLmZyb21SZWQoKS5jbXBuKDEpID09PSAwO1xufVxuXG5mdW5jdGlvbiBmaW5kUHJpbWUoYml0cywgZ2VuKSB7XG4gIGlmIChiaXRzIDwgMTYpIHtcbiAgICAvLyB0aGlzIGlzIHdoYXQgb3BlbnNzbCBkb2VzXG4gICAgaWYgKGdlbiA9PT0gMiB8fCBnZW4gPT09IDUpIHtcbiAgICAgIHJldHVybiBuZXcgQk4oWzB4OGMsIDB4N2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBCTihbMHg4YywgMHgyN10pO1xuICAgIH1cbiAgfVxuICBnZW4gPSBuZXcgQk4oZ2VuKTtcblxuICB2YXIgbnVtLCBuMjtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIG51bSA9IG5ldyBCTihyYW5kb21CeXRlcyhNYXRoLmNlaWwoYml0cyAvIDgpKSk7XG4gICAgd2hpbGUgKG51bS5iaXRMZW5ndGgoKSA+IGJpdHMpIHtcbiAgICAgIG51bS5pc2hybigxKTtcbiAgICB9XG4gICAgaWYgKG51bS5pc0V2ZW4oKSkge1xuICAgICAgbnVtLmlhZGQoT05FKTtcbiAgICB9XG4gICAgaWYgKCFudW0udGVzdG4oMSkpIHtcbiAgICAgIG51bS5pYWRkKFRXTyk7XG4gICAgfVxuICAgIGlmICghZ2VuLmNtcChUV08pKSB7XG4gICAgICB3aGlsZSAobnVtLm1vZChUV0VOVFlGT1VSKS5jbXAoRUxFVkVOKSkge1xuICAgICAgICBudW0uaWFkZChGT1VSKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFnZW4uY21wKEZJVkUpKSB7XG4gICAgICB3aGlsZSAobnVtLm1vZChURU4pLmNtcChUSFJFRSkpIHtcbiAgICAgICAgbnVtLmlhZGQoRk9VUik7XG4gICAgICB9XG4gICAgfVxuICAgIG4yID0gbnVtLnNocm4oMSk7XG4gICAgaWYgKHNpbXBsZVNpZXZlKG4yKSAmJiBzaW1wbGVTaWV2ZShudW0pICYmXG4gICAgICBmZXJtYXRUZXN0KG4yKSAmJiBmZXJtYXRUZXN0KG51bSkgJiZcbiAgICAgIG1pbGxlclJhYmluLnRlc3QobjIpICYmIG1pbGxlclJhYmluLnRlc3QobnVtKSkge1xuICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gIH1cblxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxsaXB0aWMgPSBleHBvcnRzO1xuXG5lbGxpcHRpYy52ZXJzaW9uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbmVsbGlwdGljLnV0aWxzID0gcmVxdWlyZSgnLi9lbGxpcHRpYy91dGlscycpO1xuZWxsaXB0aWMucmFuZCA9IHJlcXVpcmUoJ2Jyb3JhbmQnKTtcbmVsbGlwdGljLmN1cnZlID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9jdXJ2ZScpO1xuZWxsaXB0aWMuY3VydmVzID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9jdXJ2ZXMnKTtcblxuLy8gUHJvdG9jb2xzXG5lbGxpcHRpYy5lYyA9IHJlcXVpcmUoJy4vZWxsaXB0aWMvZWMnKTtcbmVsbGlwdGljLmVkZHNhID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9lZGRzYScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGdldE5BRiA9IHV0aWxzLmdldE5BRjtcbnZhciBnZXRKU0YgPSB1dGlscy5nZXRKU0Y7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBCYXNlQ3VydmUodHlwZSwgY29uZikge1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnAgPSBuZXcgQk4oY29uZi5wLCAxNik7XG5cbiAgLy8gVXNlIE1vbnRnb21lcnksIHdoZW4gdGhlcmUgaXMgbm8gZmFzdCByZWR1Y3Rpb24gZm9yIHRoZSBwcmltZVxuICB0aGlzLnJlZCA9IGNvbmYucHJpbWUgPyBCTi5yZWQoY29uZi5wcmltZSkgOiBCTi5tb250KHRoaXMucCk7XG5cbiAgLy8gVXNlZnVsIGZvciBtYW55IGN1cnZlc1xuICB0aGlzLnplcm8gPSBuZXcgQk4oMCkudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLm9uZSA9IG5ldyBCTigxKS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMudHdvID0gbmV3IEJOKDIpLnRvUmVkKHRoaXMucmVkKTtcblxuICAvLyBDdXJ2ZSBjb25maWd1cmF0aW9uLCBvcHRpb25hbFxuICB0aGlzLm4gPSBjb25mLm4gJiYgbmV3IEJOKGNvbmYubiwgMTYpO1xuICB0aGlzLmcgPSBjb25mLmcgJiYgdGhpcy5wb2ludEZyb21KU09OKGNvbmYuZywgY29uZi5nUmVkKTtcblxuICAvLyBUZW1wb3JhcnkgYXJyYXlzXG4gIHRoaXMuX3duYWZUMSA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fd25hZlQyID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl93bmFmVDMgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX3duYWZUNCA9IG5ldyBBcnJheSg0KTtcblxuICAvLyBHZW5lcmFsaXplZCBHcmVnIE1heHdlbGwncyB0cmlja1xuICB2YXIgYWRqdXN0Q291bnQgPSB0aGlzLm4gJiYgdGhpcy5wLmRpdih0aGlzLm4pO1xuICBpZiAoIWFkanVzdENvdW50IHx8IGFkanVzdENvdW50LmNtcG4oMTAwKSA+IDApIHtcbiAgICB0aGlzLnJlZE4gPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX21heHdlbGxUcmljayA9IHRydWU7XG4gICAgdGhpcy5yZWROID0gdGhpcy5uLnRvUmVkKHRoaXMucmVkKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBCYXNlQ3VydmU7XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX2ZpeGVkTmFmTXVsID0gZnVuY3Rpb24gX2ZpeGVkTmFmTXVsKHAsIGspIHtcbiAgYXNzZXJ0KHAucHJlY29tcHV0ZWQpO1xuICB2YXIgZG91YmxlcyA9IHAuX2dldERvdWJsZXMoKTtcblxuICB2YXIgbmFmID0gZ2V0TkFGKGssIDEpO1xuICB2YXIgSSA9ICgxIDw8IChkb3VibGVzLnN0ZXAgKyAxKSkgLSAoZG91Ymxlcy5zdGVwICUgMiA9PT0gMCA/IDIgOiAxKTtcbiAgSSAvPSAzO1xuXG4gIC8vIFRyYW5zbGF0ZSBpbnRvIG1vcmUgd2luZG93ZWQgZm9ybVxuICB2YXIgcmVwciA9IFtdO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IG5hZi5sZW5ndGg7IGogKz0gZG91Ymxlcy5zdGVwKSB7XG4gICAgdmFyIG5hZlcgPSAwO1xuICAgIGZvciAodmFyIGsgPSBqICsgZG91Ymxlcy5zdGVwIC0gMTsgayA+PSBqOyBrLS0pXG4gICAgICBuYWZXID0gKG5hZlcgPDwgMSkgKyBuYWZba107XG4gICAgcmVwci5wdXNoKG5hZlcpO1xuICB9XG5cbiAgdmFyIGEgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgdmFyIGIgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgZm9yICh2YXIgaSA9IEk7IGkgPiAwOyBpLS0pIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlcHIubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBuYWZXID0gcmVwcltqXTtcbiAgICAgIGlmIChuYWZXID09PSBpKVxuICAgICAgICBiID0gYi5taXhlZEFkZChkb3VibGVzLnBvaW50c1tqXSk7XG4gICAgICBlbHNlIGlmIChuYWZXID09PSAtaSlcbiAgICAgICAgYiA9IGIubWl4ZWRBZGQoZG91Ymxlcy5wb2ludHNbal0ubmVnKCkpO1xuICAgIH1cbiAgICBhID0gYS5hZGQoYik7XG4gIH1cbiAgcmV0dXJuIGEudG9QKCk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLl93bmFmTXVsID0gZnVuY3Rpb24gX3duYWZNdWwocCwgaykge1xuICB2YXIgdyA9IDQ7XG5cbiAgLy8gUHJlY29tcHV0ZSB3aW5kb3dcbiAgdmFyIG5hZlBvaW50cyA9IHAuX2dldE5BRlBvaW50cyh3KTtcbiAgdyA9IG5hZlBvaW50cy53bmQ7XG4gIHZhciB3bmQgPSBuYWZQb2ludHMucG9pbnRzO1xuXG4gIC8vIEdldCBOQUYgZm9ybVxuICB2YXIgbmFmID0gZ2V0TkFGKGssIHcpO1xuXG4gIC8vIEFkZCBgdGhpc2AqKE4rMSkgZm9yIGV2ZXJ5IHctTkFGIGluZGV4XG4gIHZhciBhY2MgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgZm9yICh2YXIgaSA9IG5hZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIC8vIENvdW50IHplcm9lc1xuICAgIGZvciAodmFyIGsgPSAwOyBpID49IDAgJiYgbmFmW2ldID09PSAwOyBpLS0pXG4gICAgICBrKys7XG4gICAgaWYgKGkgPj0gMClcbiAgICAgIGsrKztcbiAgICBhY2MgPSBhY2MuZGJscChrKTtcblxuICAgIGlmIChpIDwgMClcbiAgICAgIGJyZWFrO1xuICAgIHZhciB6ID0gbmFmW2ldO1xuICAgIGFzc2VydCh6ICE9PSAwKTtcbiAgICBpZiAocC50eXBlID09PSAnYWZmaW5lJykge1xuICAgICAgLy8gSiArLSBQXG4gICAgICBpZiAoeiA+IDApXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZCh3bmRbKHogLSAxKSA+PiAxXSk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZCh3bmRbKC16IC0gMSkgPj4gMV0ubmVnKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBKICstIEpcbiAgICAgIGlmICh6ID4gMClcbiAgICAgICAgYWNjID0gYWNjLmFkZCh3bmRbKHogLSAxKSA+PiAxXSk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5hZGQod25kWygteiAtIDEpID4+IDFdLm5lZygpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHAudHlwZSA9PT0gJ2FmZmluZScgPyBhY2MudG9QKCkgOiBhY2M7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLl93bmFmTXVsQWRkID0gZnVuY3Rpb24gX3duYWZNdWxBZGQoZGVmVyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29lZmZzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqYWNvYmlhblJlc3VsdCkge1xuICB2YXIgd25kV2lkdGggPSB0aGlzLl93bmFmVDE7XG4gIHZhciB3bmQgPSB0aGlzLl93bmFmVDI7XG4gIHZhciBuYWYgPSB0aGlzLl93bmFmVDM7XG5cbiAgLy8gRmlsbCBhbGwgYXJyYXlzXG4gIHZhciBtYXggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHAgPSBwb2ludHNbaV07XG4gICAgdmFyIG5hZlBvaW50cyA9IHAuX2dldE5BRlBvaW50cyhkZWZXKTtcbiAgICB3bmRXaWR0aFtpXSA9IG5hZlBvaW50cy53bmQ7XG4gICAgd25kW2ldID0gbmFmUG9pbnRzLnBvaW50cztcbiAgfVxuXG4gIC8vIENvbWIgc21hbGwgd2luZG93IE5BRnNcbiAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMTsgaSAtPSAyKSB7XG4gICAgdmFyIGEgPSBpIC0gMTtcbiAgICB2YXIgYiA9IGk7XG4gICAgaWYgKHduZFdpZHRoW2FdICE9PSAxIHx8IHduZFdpZHRoW2JdICE9PSAxKSB7XG4gICAgICBuYWZbYV0gPSBnZXROQUYoY29lZmZzW2FdLCB3bmRXaWR0aFthXSk7XG4gICAgICBuYWZbYl0gPSBnZXROQUYoY29lZmZzW2JdLCB3bmRXaWR0aFtiXSk7XG4gICAgICBtYXggPSBNYXRoLm1heChuYWZbYV0ubGVuZ3RoLCBtYXgpO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobmFmW2JdLmxlbmd0aCwgbWF4KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjb21iID0gW1xuICAgICAgcG9pbnRzW2FdLCAvKiAxICovXG4gICAgICBudWxsLCAvKiAzICovXG4gICAgICBudWxsLCAvKiA1ICovXG4gICAgICBwb2ludHNbYl0gLyogNyAqL1xuICAgIF07XG5cbiAgICAvLyBUcnkgdG8gYXZvaWQgUHJvamVjdGl2ZSBwb2ludHMsIGlmIHBvc3NpYmxlXG4gICAgaWYgKHBvaW50c1thXS55LmNtcChwb2ludHNbYl0ueSkgPT09IDApIHtcbiAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0uYWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgfSBlbHNlIGlmIChwb2ludHNbYV0ueS5jbXAocG9pbnRzW2JdLnkucmVkTmVnKCkpID09PSAwKSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLmFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gW1xuICAgICAgLTMsIC8qIC0xIC0xICovXG4gICAgICAtMSwgLyogLTEgMCAqL1xuICAgICAgLTUsIC8qIC0xIDEgKi9cbiAgICAgIC03LCAvKiAwIC0xICovXG4gICAgICAwLCAvKiAwIDAgKi9cbiAgICAgIDcsIC8qIDAgMSAqL1xuICAgICAgNSwgLyogMSAtMSAqL1xuICAgICAgMSwgLyogMSAwICovXG4gICAgICAzICAvKiAxIDEgKi9cbiAgICBdO1xuXG4gICAgdmFyIGpzZiA9IGdldEpTRihjb2VmZnNbYV0sIGNvZWZmc1tiXSk7XG4gICAgbWF4ID0gTWF0aC5tYXgoanNmWzBdLmxlbmd0aCwgbWF4KTtcbiAgICBuYWZbYV0gPSBuZXcgQXJyYXkobWF4KTtcbiAgICBuYWZbYl0gPSBuZXcgQXJyYXkobWF4KTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1heDsgaisrKSB7XG4gICAgICB2YXIgamEgPSBqc2ZbMF1bal0gfCAwO1xuICAgICAgdmFyIGpiID0ganNmWzFdW2pdIHwgMDtcblxuICAgICAgbmFmW2FdW2pdID0gaW5kZXhbKGphICsgMSkgKiAzICsgKGpiICsgMSldO1xuICAgICAgbmFmW2JdW2pdID0gMDtcbiAgICAgIHduZFthXSA9IGNvbWI7XG4gICAgfVxuICB9XG5cbiAgdmFyIGFjYyA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICB2YXIgdG1wID0gdGhpcy5fd25hZlQ0O1xuICBmb3IgKHZhciBpID0gbWF4OyBpID49IDA7IGktLSkge1xuICAgIHZhciBrID0gMDtcblxuICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgIHZhciB6ZXJvID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgdG1wW2pdID0gbmFmW2pdW2ldIHwgMDtcbiAgICAgICAgaWYgKHRtcFtqXSAhPT0gMClcbiAgICAgICAgICB6ZXJvID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXplcm8pXG4gICAgICAgIGJyZWFrO1xuICAgICAgaysrO1xuICAgICAgaS0tO1xuICAgIH1cbiAgICBpZiAoaSA+PSAwKVxuICAgICAgaysrO1xuICAgIGFjYyA9IGFjYy5kYmxwKGspO1xuICAgIGlmIChpIDwgMClcbiAgICAgIGJyZWFrO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgdmFyIHogPSB0bXBbal07XG4gICAgICB2YXIgcDtcbiAgICAgIGlmICh6ID09PSAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGVsc2UgaWYgKHogPiAwKVxuICAgICAgICBwID0gd25kW2pdWyh6IC0gMSkgPj4gMV07XG4gICAgICBlbHNlIGlmICh6IDwgMClcbiAgICAgICAgcCA9IHduZFtqXVsoLXogLSAxKSA+PiAxXS5uZWcoKTtcblxuICAgICAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZChwKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYWNjID0gYWNjLmFkZChwKTtcbiAgICB9XG4gIH1cbiAgLy8gWmVyb2lmeSByZWZlcmVuY2VzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgd25kW2ldID0gbnVsbDtcblxuICBpZiAoamFjb2JpYW5SZXN1bHQpXG4gICAgcmV0dXJuIGFjYztcbiAgZWxzZVxuICAgIHJldHVybiBhY2MudG9QKCk7XG59O1xuXG5mdW5jdGlvbiBCYXNlUG9pbnQoY3VydmUsIHR5cGUpIHtcbiAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnByZWNvbXB1dGVkID0gbnVsbDtcbn1cbkJhc2VDdXJ2ZS5CYXNlUG9pbnQgPSBCYXNlUG9pbnQ7XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSgvKm90aGVyKi8pIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUudmFsaWRhdGUodGhpcyk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLmRlY29kZVBvaW50ID0gZnVuY3Rpb24gZGVjb2RlUG9pbnQoYnl0ZXMsIGVuYykge1xuICBieXRlcyA9IHV0aWxzLnRvQXJyYXkoYnl0ZXMsIGVuYyk7XG5cbiAgdmFyIGxlbiA9IHRoaXMucC5ieXRlTGVuZ3RoKCk7XG5cbiAgLy8gdW5jb21wcmVzc2VkLCBoeWJyaWQtb2RkLCBoeWJyaWQtZXZlblxuICBpZiAoKGJ5dGVzWzBdID09PSAweDA0IHx8IGJ5dGVzWzBdID09PSAweDA2IHx8IGJ5dGVzWzBdID09PSAweDA3KSAmJlxuICAgICAgYnl0ZXMubGVuZ3RoIC0gMSA9PT0gMiAqIGxlbikge1xuICAgIGlmIChieXRlc1swXSA9PT0gMHgwNilcbiAgICAgIGFzc2VydChieXRlc1tieXRlcy5sZW5ndGggLSAxXSAlIDIgPT09IDApO1xuICAgIGVsc2UgaWYgKGJ5dGVzWzBdID09PSAweDA3KVxuICAgICAgYXNzZXJ0KGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdICUgMiA9PT0gMSk7XG5cbiAgICB2YXIgcmVzID0gIHRoaXMucG9pbnQoYnl0ZXMuc2xpY2UoMSwgMSArIGxlbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzLnNsaWNlKDEgKyBsZW4sIDEgKyAyICogbGVuKSk7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2UgaWYgKChieXRlc1swXSA9PT0gMHgwMiB8fCBieXRlc1swXSA9PT0gMHgwMykgJiZcbiAgICAgICAgICAgICAgYnl0ZXMubGVuZ3RoIC0gMSA9PT0gbGVuKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRGcm9tWChieXRlcy5zbGljZSgxLCAxICsgbGVuKSwgYnl0ZXNbMF0gPT09IDB4MDMpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwb2ludCBmb3JtYXQnKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZW5jb2RlQ29tcHJlc3NlZCA9IGZ1bmN0aW9uIGVuY29kZUNvbXByZXNzZWQoZW5jKSB7XG4gIHJldHVybiB0aGlzLmVuY29kZShlbmMsIHRydWUpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZW5jb2RlID0gZnVuY3Rpb24gX2VuY29kZShjb21wYWN0KSB7XG4gIHZhciBsZW4gPSB0aGlzLmN1cnZlLnAuYnl0ZUxlbmd0aCgpO1xuICB2YXIgeCA9IHRoaXMuZ2V0WCgpLnRvQXJyYXkoJ2JlJywgbGVuKTtcblxuICBpZiAoY29tcGFjdClcbiAgICByZXR1cm4gWyB0aGlzLmdldFkoKS5pc0V2ZW4oKSA/IDB4MDIgOiAweDAzIF0uY29uY2F0KHgpO1xuXG4gIHJldHVybiBbIDB4MDQgXS5jb25jYXQoeCwgdGhpcy5nZXRZKCkudG9BcnJheSgnYmUnLCBsZW4pKSA7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShlbmMsIGNvbXBhY3QpIHtcbiAgcmV0dXJuIHV0aWxzLmVuY29kZSh0aGlzLl9lbmNvZGUoY29tcGFjdCksIGVuYyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLnByZWNvbXB1dGUgPSBmdW5jdGlvbiBwcmVjb21wdXRlKHBvd2VyKSB7XG4gIGlmICh0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHZhciBwcmVjb21wdXRlZCA9IHtcbiAgICBkb3VibGVzOiBudWxsLFxuICAgIG5hZjogbnVsbCxcbiAgICBiZXRhOiBudWxsXG4gIH07XG4gIHByZWNvbXB1dGVkLm5hZiA9IHRoaXMuX2dldE5BRlBvaW50cyg4KTtcbiAgcHJlY29tcHV0ZWQuZG91YmxlcyA9IHRoaXMuX2dldERvdWJsZXMoNCwgcG93ZXIpO1xuICBwcmVjb21wdXRlZC5iZXRhID0gdGhpcy5fZ2V0QmV0YSgpO1xuICB0aGlzLnByZWNvbXB1dGVkID0gcHJlY29tcHV0ZWQ7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9oYXNEb3VibGVzID0gZnVuY3Rpb24gX2hhc0RvdWJsZXMoaykge1xuICBpZiAoIXRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBkb3VibGVzID0gdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzO1xuICBpZiAoIWRvdWJsZXMpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiBkb3VibGVzLnBvaW50cy5sZW5ndGggPj0gTWF0aC5jZWlsKChrLmJpdExlbmd0aCgpICsgMSkgLyBkb3VibGVzLnN0ZXApO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0RG91YmxlcyA9IGZ1bmN0aW9uIF9nZXREb3VibGVzKHN0ZXAsIHBvd2VyKSB7XG4gIGlmICh0aGlzLnByZWNvbXB1dGVkICYmIHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcylcbiAgICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzO1xuXG4gIHZhciBkb3VibGVzID0gWyB0aGlzIF07XG4gIHZhciBhY2MgPSB0aGlzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvd2VyOyBpICs9IHN0ZXApIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0ZXA7IGorKylcbiAgICAgIGFjYyA9IGFjYy5kYmwoKTtcbiAgICBkb3VibGVzLnB1c2goYWNjKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0ZXA6IHN0ZXAsXG4gICAgcG9pbnRzOiBkb3VibGVzXG4gIH07XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXROQUZQb2ludHMgPSBmdW5jdGlvbiBfZ2V0TkFGUG9pbnRzKHduZCkge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZCAmJiB0aGlzLnByZWNvbXB1dGVkLm5hZilcbiAgICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5uYWY7XG5cbiAgdmFyIHJlcyA9IFsgdGhpcyBdO1xuICB2YXIgbWF4ID0gKDEgPDwgd25kKSAtIDE7XG4gIHZhciBkYmwgPSBtYXggPT09IDEgPyBudWxsIDogdGhpcy5kYmwoKTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBtYXg7IGkrKylcbiAgICByZXNbaV0gPSByZXNbaSAtIDFdLmFkZChkYmwpO1xuICByZXR1cm4ge1xuICAgIHduZDogd25kLFxuICAgIHBvaW50czogcmVzXG4gIH07XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXRCZXRhID0gZnVuY3Rpb24gX2dldEJldGEoKSB7XG4gIHJldHVybiBudWxsO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24gZGJscChrKSB7XG4gIHZhciByID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrOyBpKyspXG4gICAgciA9IHIuZGJsKCk7XG4gIHJldHVybiByO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY3VydmUnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCYXNlID0gY3VydmUuYmFzZTtcblxudmFyIGFzc2VydCA9IGVsbGlwdGljLnV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gRWR3YXJkc0N1cnZlKGNvbmYpIHtcbiAgLy8gTk9URTogSW1wb3J0YW50IGFzIHdlIGFyZSBjcmVhdGluZyBwb2ludCBpbiBCYXNlLmNhbGwoKVxuICB0aGlzLnR3aXN0ZWQgPSAoY29uZi5hIHwgMCkgIT09IDE7XG4gIHRoaXMubU9uZUEgPSB0aGlzLnR3aXN0ZWQgJiYgKGNvbmYuYSB8IDApID09PSAtMTtcbiAgdGhpcy5leHRlbmRlZCA9IHRoaXMubU9uZUE7XG5cbiAgQmFzZS5jYWxsKHRoaXMsICdlZHdhcmRzJywgY29uZik7XG5cbiAgdGhpcy5hID0gbmV3IEJOKGNvbmYuYSwgMTYpLnVtb2QodGhpcy5yZWQubSk7XG4gIHRoaXMuYSA9IHRoaXMuYS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYyA9IG5ldyBCTihjb25mLmMsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYzIgPSB0aGlzLmMucmVkU3FyKCk7XG4gIHRoaXMuZCA9IG5ldyBCTihjb25mLmQsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuZGQgPSB0aGlzLmQucmVkQWRkKHRoaXMuZCk7XG5cbiAgYXNzZXJ0KCF0aGlzLnR3aXN0ZWQgfHwgdGhpcy5jLmZyb21SZWQoKS5jbXBuKDEpID09PSAwKTtcbiAgdGhpcy5vbmVDID0gKGNvbmYuYyB8IDApID09PSAxO1xufVxuaW5oZXJpdHMoRWR3YXJkc0N1cnZlLCBCYXNlKTtcbm1vZHVsZS5leHBvcnRzID0gRWR3YXJkc0N1cnZlO1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLl9tdWxBID0gZnVuY3Rpb24gX211bEEobnVtKSB7XG4gIGlmICh0aGlzLm1PbmVBKVxuICAgIHJldHVybiBudW0ucmVkTmVnKCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5hLnJlZE11bChudW0pO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5fbXVsQyA9IGZ1bmN0aW9uIF9tdWxDKG51bSkge1xuICBpZiAodGhpcy5vbmVDKVxuICAgIHJldHVybiBudW07XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jLnJlZE11bChudW0pO1xufTtcblxuLy8gSnVzdCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIFNob3J0IGN1cnZlXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLmpwb2ludCA9IGZ1bmN0aW9uIGpwb2ludCh4LCB5LCB6LCB0KSB7XG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHksIHosIHQpO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5wb2ludEZyb21YID0gZnVuY3Rpb24gcG9pbnRGcm9tWCh4LCBvZGQpIHtcbiAgeCA9IG5ldyBCTih4LCAxNik7XG4gIGlmICgheC5yZWQpXG4gICAgeCA9IHgudG9SZWQodGhpcy5yZWQpO1xuXG4gIHZhciB4MiA9IHgucmVkU3FyKCk7XG4gIHZhciByaHMgPSB0aGlzLmMyLnJlZFN1Yih0aGlzLmEucmVkTXVsKHgyKSk7XG4gIHZhciBsaHMgPSB0aGlzLm9uZS5yZWRTdWIodGhpcy5jMi5yZWRNdWwodGhpcy5kKS5yZWRNdWwoeDIpKTtcblxuICB2YXIgeTIgPSByaHMucmVkTXVsKGxocy5yZWRJbnZtKCkpO1xuICB2YXIgeSA9IHkyLnJlZFNxcnQoKTtcbiAgaWYgKHkucmVkU3FyKCkucmVkU3ViKHkyKS5jbXAodGhpcy56ZXJvKSAhPT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9pbnQnKTtcblxuICB2YXIgaXNPZGQgPSB5LmZyb21SZWQoKS5pc09kZCgpO1xuICBpZiAob2RkICYmICFpc09kZCB8fCAhb2RkICYmIGlzT2RkKVxuICAgIHkgPSB5LnJlZE5lZygpO1xuXG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHkpO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5wb2ludEZyb21ZID0gZnVuY3Rpb24gcG9pbnRGcm9tWSh5LCBvZGQpIHtcbiAgeSA9IG5ldyBCTih5LCAxNik7XG4gIGlmICgheS5yZWQpXG4gICAgeSA9IHkudG9SZWQodGhpcy5yZWQpO1xuXG4gIC8vIHheMiA9ICh5XjIgLSBjXjIpIC8gKGNeMiBkIHleMiAtIGEpXG4gIHZhciB5MiA9IHkucmVkU3FyKCk7XG4gIHZhciBsaHMgPSB5Mi5yZWRTdWIodGhpcy5jMik7XG4gIHZhciByaHMgPSB5Mi5yZWRNdWwodGhpcy5kKS5yZWRNdWwodGhpcy5jMikucmVkU3ViKHRoaXMuYSk7XG4gIHZhciB4MiA9IGxocy5yZWRNdWwocmhzLnJlZEludm0oKSk7XG5cbiAgaWYgKHgyLmNtcCh0aGlzLnplcm8pID09PSAwKSB7XG4gICAgaWYgKG9kZClcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCcpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLnBvaW50KHRoaXMuemVybywgeSk7XG4gIH1cblxuICB2YXIgeCA9IHgyLnJlZFNxcnQoKTtcbiAgaWYgKHgucmVkU3FyKCkucmVkU3ViKHgyKS5jbXAodGhpcy56ZXJvKSAhPT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9pbnQnKTtcblxuICBpZiAoeC5mcm9tUmVkKCkuaXNPZGQoKSAhPT0gb2RkKVxuICAgIHggPSB4LnJlZE5lZygpO1xuXG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHkpO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHBvaW50KSB7XG4gIGlmIChwb2ludC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgLy8gQ3VydmU6IEEgKiBYXjIgKyBZXjIgPSBDXjIgKiAoMSArIEQgKiBYXjIgKiBZXjIpXG4gIHBvaW50Lm5vcm1hbGl6ZSgpO1xuXG4gIHZhciB4MiA9IHBvaW50LngucmVkU3FyKCk7XG4gIHZhciB5MiA9IHBvaW50LnkucmVkU3FyKCk7XG4gIHZhciBsaHMgPSB4Mi5yZWRNdWwodGhpcy5hKS5yZWRBZGQoeTIpO1xuICB2YXIgcmhzID0gdGhpcy5jMi5yZWRNdWwodGhpcy5vbmUucmVkQWRkKHRoaXMuZC5yZWRNdWwoeDIpLnJlZE11bCh5MikpKTtcblxuICByZXR1cm4gbGhzLmNtcChyaHMpID09PSAwO1xufTtcblxuZnVuY3Rpb24gUG9pbnQoY3VydmUsIHgsIHksIHosIHQpIHtcbiAgQmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ3Byb2plY3RpdmUnKTtcbiAgaWYgKHggPT09IG51bGwgJiYgeSA9PT0gbnVsbCAmJiB6ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gdGhpcy5jdXJ2ZS56ZXJvO1xuICAgIHRoaXMueSA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMueiA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMudCA9IHRoaXMuY3VydmUuemVybztcbiAgICB0aGlzLnpPbmUgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IG5ldyBCTih4LCAxNik7XG4gICAgdGhpcy55ID0gbmV3IEJOKHksIDE2KTtcbiAgICB0aGlzLnogPSB6ID8gbmV3IEJOKHosIDE2KSA6IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMudCA9IHQgJiYgbmV3IEJOKHQsIDE2KTtcbiAgICBpZiAoIXRoaXMueC5yZWQpXG4gICAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy55LnJlZClcbiAgICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnoucmVkKVxuICAgICAgdGhpcy56ID0gdGhpcy56LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICBpZiAodGhpcy50ICYmICF0aGlzLnQucmVkKVxuICAgICAgdGhpcy50ID0gdGhpcy50LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICB0aGlzLnpPbmUgPSB0aGlzLnogPT09IHRoaXMuY3VydmUub25lO1xuXG4gICAgLy8gVXNlIGV4dGVuZGVkIGNvb3JkaW5hdGVzXG4gICAgaWYgKHRoaXMuY3VydmUuZXh0ZW5kZWQgJiYgIXRoaXMudCkge1xuICAgICAgdGhpcy50ID0gdGhpcy54LnJlZE11bCh0aGlzLnkpO1xuICAgICAgaWYgKCF0aGlzLnpPbmUpXG4gICAgICAgIHRoaXMudCA9IHRoaXMudC5yZWRNdWwodGhpcy56LnJlZEludm0oKSk7XG4gICAgfVxuICB9XG59XG5pbmhlcml0cyhQb2ludCwgQmFzZS5CYXNlUG9pbnQpO1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnBvaW50RnJvbUpTT04gPSBmdW5jdGlvbiBwb2ludEZyb21KU09OKG9iaikge1xuICByZXR1cm4gUG9pbnQuZnJvbUpTT04odGhpcywgb2JqKTtcbn07XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCh4LCB5LCB6LCB0KSB7XG4gIHJldHVybiBuZXcgUG9pbnQodGhpcywgeCwgeSwgeiwgdCk7XG59O1xuXG5Qb2ludC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKGN1cnZlLCBvYmopIHtcbiAgcmV0dXJuIG5ldyBQb2ludChjdXJ2ZSwgb2JqWzBdLCBvYmpbMV0sIG9ialsyXSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBQb2ludCB4OiAnICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB5OiAnICsgdGhpcy55LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB6OiAnICsgdGhpcy56LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIC8vIFhYWCBUaGlzIGNvZGUgYXNzdW1lcyB0aGF0IHplcm8gaXMgYWx3YXlzIHplcm8gaW4gcmVkXG4gIHJldHVybiB0aGlzLnguY21wbigwKSA9PT0gMCAmJlxuICAgICh0aGlzLnkuY21wKHRoaXMueikgPT09IDAgfHxcbiAgICAodGhpcy56T25lICYmIHRoaXMueS5jbXAodGhpcy5jdXJ2ZS5jKSA9PT0gMCkpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLl9leHREYmwgPSBmdW5jdGlvbiBfZXh0RGJsKCkge1xuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC0xLmh0bWxcbiAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwOC1od2NkXG4gIC8vIDRNICsgNFNcblxuICAvLyBBID0gWDFeMlxuICB2YXIgYSA9IHRoaXMueC5yZWRTcXIoKTtcbiAgLy8gQiA9IFkxXjJcbiAgdmFyIGIgPSB0aGlzLnkucmVkU3FyKCk7XG4gIC8vIEMgPSAyICogWjFeMlxuICB2YXIgYyA9IHRoaXMuei5yZWRTcXIoKTtcbiAgYyA9IGMucmVkSUFkZChjKTtcbiAgLy8gRCA9IGEgKiBBXG4gIHZhciBkID0gdGhpcy5jdXJ2ZS5fbXVsQShhKTtcbiAgLy8gRSA9IChYMSArIFkxKV4yIC0gQSAtIEJcbiAgdmFyIGUgPSB0aGlzLngucmVkQWRkKHRoaXMueSkucmVkU3FyKCkucmVkSVN1YihhKS5yZWRJU3ViKGIpO1xuICAvLyBHID0gRCArIEJcbiAgdmFyIGcgPSBkLnJlZEFkZChiKTtcbiAgLy8gRiA9IEcgLSBDXG4gIHZhciBmID0gZy5yZWRTdWIoYyk7XG4gIC8vIEggPSBEIC0gQlxuICB2YXIgaCA9IGQucmVkU3ViKGIpO1xuICAvLyBYMyA9IEUgKiBGXG4gIHZhciBueCA9IGUucmVkTXVsKGYpO1xuICAvLyBZMyA9IEcgKiBIXG4gIHZhciBueSA9IGcucmVkTXVsKGgpO1xuICAvLyBUMyA9IEUgKiBIXG4gIHZhciBudCA9IGUucmVkTXVsKGgpO1xuICAvLyBaMyA9IEYgKiBHXG4gIHZhciBueiA9IGYucmVkTXVsKGcpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnksIG56LCBudCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX3Byb2pEYmwgPSBmdW5jdGlvbiBfcHJvakRibCgpIHtcbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtcHJvamVjdGl2ZS5odG1sXG4gIC8vICAgICAjZG91YmxpbmctZGJsLTIwMDgtYmJqbHBcbiAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwNy1ibFxuICAvLyBhbmQgb3RoZXJzXG4gIC8vIEdlbmVyYWxseSAzTSArIDRTIG9yIDJNICsgNFNcblxuICAvLyBCID0gKFgxICsgWTEpXjJcbiAgdmFyIGIgPSB0aGlzLngucmVkQWRkKHRoaXMueSkucmVkU3FyKCk7XG4gIC8vIEMgPSBYMV4yXG4gIHZhciBjID0gdGhpcy54LnJlZFNxcigpO1xuICAvLyBEID0gWTFeMlxuICB2YXIgZCA9IHRoaXMueS5yZWRTcXIoKTtcblxuICB2YXIgbng7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICBpZiAodGhpcy5jdXJ2ZS50d2lzdGVkKSB7XG4gICAgLy8gRSA9IGEgKiBDXG4gICAgdmFyIGUgPSB0aGlzLmN1cnZlLl9tdWxBKGMpO1xuICAgIC8vIEYgPSBFICsgRFxuICAgIHZhciBmID0gZS5yZWRBZGQoZCk7XG4gICAgaWYgKHRoaXMuek9uZSkge1xuICAgICAgLy8gWDMgPSAoQiAtIEMgLSBEKSAqIChGIC0gMilcbiAgICAgIG54ID0gYi5yZWRTdWIoYykucmVkU3ViKGQpLnJlZE11bChmLnJlZFN1Yih0aGlzLmN1cnZlLnR3bykpO1xuICAgICAgLy8gWTMgPSBGICogKEUgLSBEKVxuICAgICAgbnkgPSBmLnJlZE11bChlLnJlZFN1YihkKSk7XG4gICAgICAvLyBaMyA9IEZeMiAtIDIgKiBGXG4gICAgICBueiA9IGYucmVkU3FyKCkucmVkU3ViKGYpLnJlZFN1YihmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSCA9IFoxXjJcbiAgICAgIHZhciBoID0gdGhpcy56LnJlZFNxcigpO1xuICAgICAgLy8gSiA9IEYgLSAyICogSFxuICAgICAgdmFyIGogPSBmLnJlZFN1YihoKS5yZWRJU3ViKGgpO1xuICAgICAgLy8gWDMgPSAoQi1DLUQpKkpcbiAgICAgIG54ID0gYi5yZWRTdWIoYykucmVkSVN1YihkKS5yZWRNdWwoaik7XG4gICAgICAvLyBZMyA9IEYgKiAoRSAtIEQpXG4gICAgICBueSA9IGYucmVkTXVsKGUucmVkU3ViKGQpKTtcbiAgICAgIC8vIFozID0gRiAqIEpcbiAgICAgIG56ID0gZi5yZWRNdWwoaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEUgPSBDICsgRFxuICAgIHZhciBlID0gYy5yZWRBZGQoZCk7XG4gICAgLy8gSCA9IChjICogWjEpXjJcbiAgICB2YXIgaCA9IHRoaXMuY3VydmUuX211bEModGhpcy56KS5yZWRTcXIoKTtcbiAgICAvLyBKID0gRSAtIDIgKiBIXG4gICAgdmFyIGogPSBlLnJlZFN1YihoKS5yZWRTdWIoaCk7XG4gICAgLy8gWDMgPSBjICogKEIgLSBFKSAqIEpcbiAgICBueCA9IHRoaXMuY3VydmUuX211bEMoYi5yZWRJU3ViKGUpKS5yZWRNdWwoaik7XG4gICAgLy8gWTMgPSBjICogRSAqIChDIC0gRClcbiAgICBueSA9IHRoaXMuY3VydmUuX211bEMoZSkucmVkTXVsKGMucmVkSVN1YihkKSk7XG4gICAgLy8gWjMgPSBFICogSlxuICAgIG56ID0gZS5yZWRNdWwoaik7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55LCBueik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gRG91YmxlIGluIGV4dGVuZGVkIGNvb3JkaW5hdGVzXG4gIGlmICh0aGlzLmN1cnZlLmV4dGVuZGVkKVxuICAgIHJldHVybiB0aGlzLl9leHREYmwoKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLl9wcm9qRGJsKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2V4dEFkZCA9IGZ1bmN0aW9uIF9leHRBZGQocCkge1xuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC0xLmh0bWxcbiAgLy8gICAgICNhZGRpdGlvbi1hZGQtMjAwOC1od2NkLTNcbiAgLy8gOE1cblxuICAvLyBBID0gKFkxIC0gWDEpICogKFkyIC0gWDIpXG4gIHZhciBhID0gdGhpcy55LnJlZFN1Yih0aGlzLngpLnJlZE11bChwLnkucmVkU3ViKHAueCkpO1xuICAvLyBCID0gKFkxICsgWDEpICogKFkyICsgWDIpXG4gIHZhciBiID0gdGhpcy55LnJlZEFkZCh0aGlzLngpLnJlZE11bChwLnkucmVkQWRkKHAueCkpO1xuICAvLyBDID0gVDEgKiBrICogVDJcbiAgdmFyIGMgPSB0aGlzLnQucmVkTXVsKHRoaXMuY3VydmUuZGQpLnJlZE11bChwLnQpO1xuICAvLyBEID0gWjEgKiAyICogWjJcbiAgdmFyIGQgPSB0aGlzLnoucmVkTXVsKHAuei5yZWRBZGQocC56KSk7XG4gIC8vIEUgPSBCIC0gQVxuICB2YXIgZSA9IGIucmVkU3ViKGEpO1xuICAvLyBGID0gRCAtIENcbiAgdmFyIGYgPSBkLnJlZFN1YihjKTtcbiAgLy8gRyA9IEQgKyBDXG4gIHZhciBnID0gZC5yZWRBZGQoYyk7XG4gIC8vIEggPSBCICsgQVxuICB2YXIgaCA9IGIucmVkQWRkKGEpO1xuICAvLyBYMyA9IEUgKiBGXG4gIHZhciBueCA9IGUucmVkTXVsKGYpO1xuICAvLyBZMyA9IEcgKiBIXG4gIHZhciBueSA9IGcucmVkTXVsKGgpO1xuICAvLyBUMyA9IEUgKiBIXG4gIHZhciBudCA9IGUucmVkTXVsKGgpO1xuICAvLyBaMyA9IEYgKiBHXG4gIHZhciBueiA9IGYucmVkTXVsKGcpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnksIG56LCBudCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX3Byb2pBZGQgPSBmdW5jdGlvbiBfcHJvakFkZChwKSB7XG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLXByb2plY3RpdmUuaHRtbFxuICAvLyAgICAgI2FkZGl0aW9uLWFkZC0yMDA4LWJiamxwXG4gIC8vICAgICAjYWRkaXRpb24tYWRkLTIwMDctYmxcbiAgLy8gMTBNICsgMVNcblxuICAvLyBBID0gWjEgKiBaMlxuICB2YXIgYSA9IHRoaXMuei5yZWRNdWwocC56KTtcbiAgLy8gQiA9IEFeMlxuICB2YXIgYiA9IGEucmVkU3FyKCk7XG4gIC8vIEMgPSBYMSAqIFgyXG4gIHZhciBjID0gdGhpcy54LnJlZE11bChwLngpO1xuICAvLyBEID0gWTEgKiBZMlxuICB2YXIgZCA9IHRoaXMueS5yZWRNdWwocC55KTtcbiAgLy8gRSA9IGQgKiBDICogRFxuICB2YXIgZSA9IHRoaXMuY3VydmUuZC5yZWRNdWwoYykucmVkTXVsKGQpO1xuICAvLyBGID0gQiAtIEVcbiAgdmFyIGYgPSBiLnJlZFN1YihlKTtcbiAgLy8gRyA9IEIgKyBFXG4gIHZhciBnID0gYi5yZWRBZGQoZSk7XG4gIC8vIFgzID0gQSAqIEYgKiAoKFgxICsgWTEpICogKFgyICsgWTIpIC0gQyAtIEQpXG4gIHZhciB0bXAgPSB0aGlzLngucmVkQWRkKHRoaXMueSkucmVkTXVsKHAueC5yZWRBZGQocC55KSkucmVkSVN1YihjKS5yZWRJU3ViKGQpO1xuICB2YXIgbnggPSBhLnJlZE11bChmKS5yZWRNdWwodG1wKTtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIGlmICh0aGlzLmN1cnZlLnR3aXN0ZWQpIHtcbiAgICAvLyBZMyA9IEEgKiBHICogKEQgLSBhICogQylcbiAgICBueSA9IGEucmVkTXVsKGcpLnJlZE11bChkLnJlZFN1Yih0aGlzLmN1cnZlLl9tdWxBKGMpKSk7XG4gICAgLy8gWjMgPSBGICogR1xuICAgIG56ID0gZi5yZWRNdWwoZyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gWTMgPSBBICogRyAqIChEIC0gQylcbiAgICBueSA9IGEucmVkTXVsKGcpLnJlZE11bChkLnJlZFN1YihjKSk7XG4gICAgLy8gWjMgPSBjICogRiAqIEdcbiAgICBueiA9IHRoaXMuY3VydmUuX211bEMoZikucmVkTXVsKGcpO1xuICB9XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnopO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gcDtcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGlmICh0aGlzLmN1cnZlLmV4dGVuZGVkKVxuICAgIHJldHVybiB0aGlzLl9leHRBZGQocCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5fcHJvakFkZChwKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaykge1xuICBpZiAodGhpcy5faGFzRG91YmxlcyhrKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZml4ZWROYWZNdWwodGhpcywgayk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bCh0aGlzLCBrKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWxBZGQgPSBmdW5jdGlvbiBtdWxBZGQoazEsIHAsIGsyKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsIFsgdGhpcywgcCBdLCBbIGsxLCBrMiBdLCAyLCBmYWxzZSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuam11bEFkZCA9IGZ1bmN0aW9uIGptdWxBZGQoazEsIHAsIGsyKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsIFsgdGhpcywgcCBdLCBbIGsxLCBrMiBdLCAyLCB0cnVlKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUoKSB7XG4gIGlmICh0aGlzLnpPbmUpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gTm9ybWFsaXplIGNvb3JkaW5hdGVzXG4gIHZhciB6aSA9IHRoaXMuei5yZWRJbnZtKCk7XG4gIHRoaXMueCA9IHRoaXMueC5yZWRNdWwoemkpO1xuICB0aGlzLnkgPSB0aGlzLnkucmVkTXVsKHppKTtcbiAgaWYgKHRoaXMudClcbiAgICB0aGlzLnQgPSB0aGlzLnQucmVkTXVsKHppKTtcbiAgdGhpcy56ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gIHRoaXMuek9uZSA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZygpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQodGhpcy54LnJlZE5lZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ICYmIHRoaXMudC5yZWROZWcoKSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFgoKSB7XG4gIHRoaXMubm9ybWFsaXplKCk7XG4gIHJldHVybiB0aGlzLnguZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiBnZXRZKCkge1xuICB0aGlzLm5vcm1hbGl6ZSgpO1xuICByZXR1cm4gdGhpcy55LmZyb21SZWQoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKG90aGVyKSB7XG4gIHJldHVybiB0aGlzID09PSBvdGhlciB8fFxuICAgICAgICAgdGhpcy5nZXRYKCkuY21wKG90aGVyLmdldFgoKSkgPT09IDAgJiZcbiAgICAgICAgIHRoaXMuZ2V0WSgpLmNtcChvdGhlci5nZXRZKCkpID09PSAwO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmVxWFRvUCA9IGZ1bmN0aW9uIGVxWFRvUCh4KSB7XG4gIHZhciByeCA9IHgudG9SZWQodGhpcy5jdXJ2ZS5yZWQpLnJlZE11bCh0aGlzLnopO1xuICBpZiAodGhpcy54LmNtcChyeCkgPT09IDApXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgdmFyIHhjID0geC5jbG9uZSgpO1xuICB2YXIgdCA9IHRoaXMuY3VydmUucmVkTi5yZWRNdWwodGhpcy56KTtcbiAgZm9yICg7Oykge1xuICAgIHhjLmlhZGQodGhpcy5jdXJ2ZS5uKTtcbiAgICBpZiAoeGMuY21wKHRoaXMuY3VydmUucCkgPj0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHJ4LnJlZElBZGQodCk7XG4gICAgaWYgKHRoaXMueC5jbXAocngpID09PSAwKVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8vIENvbXBhdGliaWxpdHkgd2l0aCBCYXNlQ3VydmVcblBvaW50LnByb3RvdHlwZS50b1AgPSBQb2ludC5wcm90b3R5cGUubm9ybWFsaXplO1xuUG9pbnQucHJvdG90eXBlLm1peGVkQWRkID0gUG9pbnQucHJvdG90eXBlLmFkZDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlID0gZXhwb3J0cztcblxuY3VydmUuYmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuY3VydmUuc2hvcnQgPSByZXF1aXJlKCcuL3Nob3J0Jyk7XG5jdXJ2ZS5tb250ID0gcmVxdWlyZSgnLi9tb250Jyk7XG5jdXJ2ZS5lZHdhcmRzID0gcmVxdWlyZSgnLi9lZHdhcmRzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2N1cnZlJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCYXNlID0gY3VydmUuYmFzZTtcblxudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xuXG5mdW5jdGlvbiBNb250Q3VydmUoY29uZikge1xuICBCYXNlLmNhbGwodGhpcywgJ21vbnQnLCBjb25mKTtcblxuICB0aGlzLmEgPSBuZXcgQk4oY29uZi5hLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmIgPSBuZXcgQk4oY29uZi5iLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmk0ID0gbmV3IEJOKDQpLnRvUmVkKHRoaXMucmVkKS5yZWRJbnZtKCk7XG4gIHRoaXMudHdvID0gbmV3IEJOKDIpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5hMjQgPSB0aGlzLmk0LnJlZE11bCh0aGlzLmEucmVkQWRkKHRoaXMudHdvKSk7XG59XG5pbmhlcml0cyhNb250Q3VydmUsIEJhc2UpO1xubW9kdWxlLmV4cG9ydHMgPSBNb250Q3VydmU7XG5cbk1vbnRDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShwb2ludCkge1xuICB2YXIgeCA9IHBvaW50Lm5vcm1hbGl6ZSgpLng7XG4gIHZhciB4MiA9IHgucmVkU3FyKCk7XG4gIHZhciByaHMgPSB4Mi5yZWRNdWwoeCkucmVkQWRkKHgyLnJlZE11bCh0aGlzLmEpKS5yZWRBZGQoeCk7XG4gIHZhciB5ID0gcmhzLnJlZFNxcnQoKTtcblxuICByZXR1cm4geS5yZWRTcXIoKS5jbXAocmhzKSA9PT0gMDtcbn07XG5cbmZ1bmN0aW9uIFBvaW50KGN1cnZlLCB4LCB6KSB7XG4gIEJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdwcm9qZWN0aXZlJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHogPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnogPSB0aGlzLmN1cnZlLnplcm87XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IEJOKHgsIDE2KTtcbiAgICB0aGlzLnogPSBuZXcgQk4oeiwgMTYpO1xuICAgIGlmICghdGhpcy54LnJlZClcbiAgICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnoucmVkKVxuICAgICAgdGhpcy56ID0gdGhpcy56LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgfVxufVxuaW5oZXJpdHMoUG9pbnQsIEJhc2UuQmFzZVBvaW50KTtcblxuTW9udEN1cnZlLnByb3RvdHlwZS5kZWNvZGVQb2ludCA9IGZ1bmN0aW9uIGRlY29kZVBvaW50KGJ5dGVzLCBlbmMpIHtcbiAgcmV0dXJuIHRoaXMucG9pbnQodXRpbHMudG9BcnJheShieXRlcywgZW5jKSwgMSk7XG59O1xuXG5Nb250Q3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoeCwgeikge1xuICByZXR1cm4gbmV3IFBvaW50KHRoaXMsIHgsIHopO1xufTtcblxuTW9udEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21KU09OID0gZnVuY3Rpb24gcG9pbnRGcm9tSlNPTihvYmopIHtcbiAgcmV0dXJuIFBvaW50LmZyb21KU09OKHRoaXMsIG9iaik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUucHJlY29tcHV0ZSA9IGZ1bmN0aW9uIHByZWNvbXB1dGUoKSB7XG4gIC8vIE5vLW9wXG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIF9lbmNvZGUoKSB7XG4gIHJldHVybiB0aGlzLmdldFgoKS50b0FycmF5KCdiZScsIHRoaXMuY3VydmUucC5ieXRlTGVuZ3RoKCkpO1xufTtcblxuUG9pbnQuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihjdXJ2ZSwgb2JqKSB7XG4gIHJldHVybiBuZXcgUG9pbnQoY3VydmUsIG9ialswXSwgb2JqWzFdIHx8IGN1cnZlLm9uZSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBQb2ludCB4OiAnICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB6OiAnICsgdGhpcy56LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIC8vIFhYWCBUaGlzIGNvZGUgYXNzdW1lcyB0aGF0IHplcm8gaXMgYWx3YXlzIHplcm8gaW4gcmVkXG4gIHJldHVybiB0aGlzLnouY21wbigwKSA9PT0gMDtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIC8vIGh0dHA6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tbW9udGdvbS14ei5odG1sI2RvdWJsaW5nLWRibC0xOTg3LW0tM1xuICAvLyAyTSArIDJTICsgNEFcblxuICAvLyBBID0gWDEgKyBaMVxuICB2YXIgYSA9IHRoaXMueC5yZWRBZGQodGhpcy56KTtcbiAgLy8gQUEgPSBBXjJcbiAgdmFyIGFhID0gYS5yZWRTcXIoKTtcbiAgLy8gQiA9IFgxIC0gWjFcbiAgdmFyIGIgPSB0aGlzLngucmVkU3ViKHRoaXMueik7XG4gIC8vIEJCID0gQl4yXG4gIHZhciBiYiA9IGIucmVkU3FyKCk7XG4gIC8vIEMgPSBBQSAtIEJCXG4gIHZhciBjID0gYWEucmVkU3ViKGJiKTtcbiAgLy8gWDMgPSBBQSAqIEJCXG4gIHZhciBueCA9IGFhLnJlZE11bChiYik7XG4gIC8vIFozID0gQyAqIChCQiArIEEyNCAqIEMpXG4gIHZhciBueiA9IGMucmVkTXVsKGJiLnJlZEFkZCh0aGlzLmN1cnZlLmEyNC5yZWRNdWwoYykpKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG56KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBvbiBNb250Z29tZXJ5IGN1cnZlJyk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZGlmZkFkZCA9IGZ1bmN0aW9uIGRpZmZBZGQocCwgZGlmZikge1xuICAvLyBodHRwOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLW1vbnRnb20teHouaHRtbCNkaWZmYWRkLWRhZGQtMTk4Ny1tLTNcbiAgLy8gNE0gKyAyUyArIDZBXG5cbiAgLy8gQSA9IFgyICsgWjJcbiAgdmFyIGEgPSB0aGlzLngucmVkQWRkKHRoaXMueik7XG4gIC8vIEIgPSBYMiAtIFoyXG4gIHZhciBiID0gdGhpcy54LnJlZFN1Yih0aGlzLnopO1xuICAvLyBDID0gWDMgKyBaM1xuICB2YXIgYyA9IHAueC5yZWRBZGQocC56KTtcbiAgLy8gRCA9IFgzIC0gWjNcbiAgdmFyIGQgPSBwLngucmVkU3ViKHAueik7XG4gIC8vIERBID0gRCAqIEFcbiAgdmFyIGRhID0gZC5yZWRNdWwoYSk7XG4gIC8vIENCID0gQyAqIEJcbiAgdmFyIGNiID0gYy5yZWRNdWwoYik7XG4gIC8vIFg1ID0gWjEgKiAoREEgKyBDQileMlxuICB2YXIgbnggPSBkaWZmLnoucmVkTXVsKGRhLnJlZEFkZChjYikucmVkU3FyKCkpO1xuICAvLyBaNSA9IFgxICogKERBIC0gQ0IpXjJcbiAgdmFyIG56ID0gZGlmZi54LnJlZE11bChkYS5yZWRJU3ViKGNiKS5yZWRTcXIoKSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGspIHtcbiAgdmFyIHQgPSBrLmNsb25lKCk7XG4gIHZhciBhID0gdGhpczsgLy8gKE4gLyAyKSAqIFEgKyBRXG4gIHZhciBiID0gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTsgLy8gKE4gLyAyKSAqIFFcbiAgdmFyIGMgPSB0aGlzOyAvLyBRXG5cbiAgZm9yICh2YXIgYml0cyA9IFtdOyB0LmNtcG4oMCkgIT09IDA7IHQuaXVzaHJuKDEpKVxuICAgIGJpdHMucHVzaCh0LmFuZGxuKDEpKTtcblxuICBmb3IgKHZhciBpID0gYml0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChiaXRzW2ldID09PSAwKSB7XG4gICAgICAvLyBOICogUSArIFEgPSAoKE4gLyAyKSAqIFEgKyBRKSkgKyAoTiAvIDIpICogUVxuICAgICAgYSA9IGEuZGlmZkFkZChiLCBjKTtcbiAgICAgIC8vIE4gKiBRID0gMiAqICgoTiAvIDIpICogUSArIFEpKVxuICAgICAgYiA9IGIuZGJsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE4gKiBRID0gKChOIC8gMikgKiBRICsgUSkgKyAoKE4gLyAyKSAqIFEpXG4gICAgICBiID0gYS5kaWZmQWRkKGIsIGMpO1xuICAgICAgLy8gTiAqIFEgKyBRID0gMiAqICgoTiAvIDIpICogUSArIFEpXG4gICAgICBhID0gYS5kYmwoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGI7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24gbXVsQWRkKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgb24gTW9udGdvbWVyeSBjdXJ2ZScpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmp1bWxBZGQgPSBmdW5jdGlvbiBqdW1sQWRkKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgb24gTW9udGdvbWVyeSBjdXJ2ZScpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WCgpLmNtcChvdGhlci5nZXRYKCkpID09PSAwO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgdGhpcy54ID0gdGhpcy54LnJlZE11bCh0aGlzLnoucmVkSW52bSgpKTtcbiAgdGhpcy56ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYKCkge1xuICAvLyBOb3JtYWxpemUgY29vcmRpbmF0ZXNcbiAgdGhpcy5ub3JtYWxpemUoKTtcblxuICByZXR1cm4gdGhpcy54LmZyb21SZWQoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2N1cnZlJyk7XG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQmFzZSA9IGN1cnZlLmJhc2U7XG5cbnZhciBhc3NlcnQgPSBlbGxpcHRpYy51dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIFNob3J0Q3VydmUoY29uZikge1xuICBCYXNlLmNhbGwodGhpcywgJ3Nob3J0JywgY29uZik7XG5cbiAgdGhpcy5hID0gbmV3IEJOKGNvbmYuYSwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5iID0gbmV3IEJOKGNvbmYuYiwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy50aW52ID0gdGhpcy50d28ucmVkSW52bSgpO1xuXG4gIHRoaXMuemVyb0EgPSB0aGlzLmEuZnJvbVJlZCgpLmNtcG4oMCkgPT09IDA7XG4gIHRoaXMudGhyZWVBID0gdGhpcy5hLmZyb21SZWQoKS5zdWIodGhpcy5wKS5jbXBuKC0zKSA9PT0gMDtcblxuICAvLyBJZiB0aGUgY3VydmUgaXMgZW5kb21vcnBoaWMsIHByZWNhbGN1bGF0ZSBiZXRhIGFuZCBsYW1iZGFcbiAgdGhpcy5lbmRvID0gdGhpcy5fZ2V0RW5kb21vcnBoaXNtKGNvbmYpO1xuICB0aGlzLl9lbmRvV25hZlQxID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl9lbmRvV25hZlQyID0gbmV3IEFycmF5KDQpO1xufVxuaW5oZXJpdHMoU2hvcnRDdXJ2ZSwgQmFzZSk7XG5tb2R1bGUuZXhwb3J0cyA9IFNob3J0Q3VydmU7XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvbW9ycGhpc20gPSBmdW5jdGlvbiBfZ2V0RW5kb21vcnBoaXNtKGNvbmYpIHtcbiAgLy8gTm8gZWZmaWNpZW50IGVuZG9tb3JwaGlzbVxuICBpZiAoIXRoaXMuemVyb0EgfHwgIXRoaXMuZyB8fCAhdGhpcy5uIHx8IHRoaXMucC5tb2RuKDMpICE9PSAxKVxuICAgIHJldHVybjtcblxuICAvLyBDb21wdXRlIGJldGEgYW5kIGxhbWJkYSwgdGhhdCBsYW1iZGEgKiBQID0gKGJldGEgKiBQeDsgUHkpXG4gIHZhciBiZXRhO1xuICB2YXIgbGFtYmRhO1xuICBpZiAoY29uZi5iZXRhKSB7XG4gICAgYmV0YSA9IG5ldyBCTihjb25mLmJldGEsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJldGFzID0gdGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMucCk7XG4gICAgLy8gQ2hvb3NlIHRoZSBzbWFsbGVzdCBiZXRhXG4gICAgYmV0YSA9IGJldGFzWzBdLmNtcChiZXRhc1sxXSkgPCAwID8gYmV0YXNbMF0gOiBiZXRhc1sxXTtcbiAgICBiZXRhID0gYmV0YS50b1JlZCh0aGlzLnJlZCk7XG4gIH1cbiAgaWYgKGNvbmYubGFtYmRhKSB7XG4gICAgbGFtYmRhID0gbmV3IEJOKGNvbmYubGFtYmRhLCAxNik7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2hvb3NlIHRoZSBsYW1iZGEgdGhhdCBpcyBtYXRjaGluZyBzZWxlY3RlZCBiZXRhXG4gICAgdmFyIGxhbWJkYXMgPSB0aGlzLl9nZXRFbmRvUm9vdHModGhpcy5uKTtcbiAgICBpZiAodGhpcy5nLm11bChsYW1iZGFzWzBdKS54LmNtcCh0aGlzLmcueC5yZWRNdWwoYmV0YSkpID09PSAwKSB7XG4gICAgICBsYW1iZGEgPSBsYW1iZGFzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYW1iZGEgPSBsYW1iZGFzWzFdO1xuICAgICAgYXNzZXJ0KHRoaXMuZy5tdWwobGFtYmRhKS54LmNtcCh0aGlzLmcueC5yZWRNdWwoYmV0YSkpID09PSAwKTtcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgYmFzaXMgdmVjdG9ycywgdXNlZCBmb3IgYmFsYW5jZWQgbGVuZ3RoLXR3byByZXByZXNlbnRhdGlvblxuICB2YXIgYmFzaXM7XG4gIGlmIChjb25mLmJhc2lzKSB7XG4gICAgYmFzaXMgPSBjb25mLmJhc2lzLm1hcChmdW5jdGlvbih2ZWMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGE6IG5ldyBCTih2ZWMuYSwgMTYpLFxuICAgICAgICBiOiBuZXcgQk4odmVjLmIsIDE2KVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBiYXNpcyA9IHRoaXMuX2dldEVuZG9CYXNpcyhsYW1iZGEpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiZXRhOiBiZXRhLFxuICAgIGxhbWJkYTogbGFtYmRhLFxuICAgIGJhc2lzOiBiYXNpc1xuICB9O1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9Sb290cyA9IGZ1bmN0aW9uIF9nZXRFbmRvUm9vdHMobnVtKSB7XG4gIC8vIEZpbmQgcm9vdHMgb2YgZm9yIHheMiArIHggKyAxIGluIEZcbiAgLy8gUm9vdCA9ICgtMSArLSBTcXJ0KC0zKSkgLyAyXG4gIC8vXG4gIHZhciByZWQgPSBudW0gPT09IHRoaXMucCA/IHRoaXMucmVkIDogQk4ubW9udChudW0pO1xuICB2YXIgdGludiA9IG5ldyBCTigyKS50b1JlZChyZWQpLnJlZEludm0oKTtcbiAgdmFyIG50aW52ID0gdGludi5yZWROZWcoKTtcblxuICB2YXIgcyA9IG5ldyBCTigzKS50b1JlZChyZWQpLnJlZE5lZygpLnJlZFNxcnQoKS5yZWRNdWwodGludik7XG5cbiAgdmFyIGwxID0gbnRpbnYucmVkQWRkKHMpLmZyb21SZWQoKTtcbiAgdmFyIGwyID0gbnRpbnYucmVkU3ViKHMpLmZyb21SZWQoKTtcbiAgcmV0dXJuIFsgbDEsIGwyIF07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb0Jhc2lzID0gZnVuY3Rpb24gX2dldEVuZG9CYXNpcyhsYW1iZGEpIHtcbiAgLy8gYXByeFNxcnQgPj0gc3FydCh0aGlzLm4pXG4gIHZhciBhcHJ4U3FydCA9IHRoaXMubi51c2hybihNYXRoLmZsb29yKHRoaXMubi5iaXRMZW5ndGgoKSAvIDIpKTtcblxuICAvLyAzLjc0XG4gIC8vIFJ1biBFR0NELCB1bnRpbCByKEwgKyAxKSA8IGFwcnhTcXJ0XG4gIHZhciB1ID0gbGFtYmRhO1xuICB2YXIgdiA9IHRoaXMubi5jbG9uZSgpO1xuICB2YXIgeDEgPSBuZXcgQk4oMSk7XG4gIHZhciB5MSA9IG5ldyBCTigwKTtcbiAgdmFyIHgyID0gbmV3IEJOKDApO1xuICB2YXIgeTIgPSBuZXcgQk4oMSk7XG5cbiAgLy8gTk9URTogYWxsIHZlY3RvcnMgYXJlIHJvb3RzIG9mOiBhICsgYiAqIGxhbWJkYSA9IDAgKG1vZCBuKVxuICB2YXIgYTA7XG4gIHZhciBiMDtcbiAgLy8gRmlyc3QgdmVjdG9yXG4gIHZhciBhMTtcbiAgdmFyIGIxO1xuICAvLyBTZWNvbmQgdmVjdG9yXG4gIHZhciBhMjtcbiAgdmFyIGIyO1xuXG4gIHZhciBwcmV2UjtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcjtcbiAgdmFyIHg7XG4gIHdoaWxlICh1LmNtcG4oMCkgIT09IDApIHtcbiAgICB2YXIgcSA9IHYuZGl2KHUpO1xuICAgIHIgPSB2LnN1YihxLm11bCh1KSk7XG4gICAgeCA9IHgyLnN1YihxLm11bCh4MSkpO1xuICAgIHZhciB5ID0geTIuc3ViKHEubXVsKHkxKSk7XG5cbiAgICBpZiAoIWExICYmIHIuY21wKGFwcnhTcXJ0KSA8IDApIHtcbiAgICAgIGEwID0gcHJldlIubmVnKCk7XG4gICAgICBiMCA9IHgxO1xuICAgICAgYTEgPSByLm5lZygpO1xuICAgICAgYjEgPSB4O1xuICAgIH0gZWxzZSBpZiAoYTEgJiYgKytpID09PSAyKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcHJldlIgPSByO1xuXG4gICAgdiA9IHU7XG4gICAgdSA9IHI7XG4gICAgeDIgPSB4MTtcbiAgICB4MSA9IHg7XG4gICAgeTIgPSB5MTtcbiAgICB5MSA9IHk7XG4gIH1cbiAgYTIgPSByLm5lZygpO1xuICBiMiA9IHg7XG5cbiAgdmFyIGxlbjEgPSBhMS5zcXIoKS5hZGQoYjEuc3FyKCkpO1xuICB2YXIgbGVuMiA9IGEyLnNxcigpLmFkZChiMi5zcXIoKSk7XG4gIGlmIChsZW4yLmNtcChsZW4xKSA+PSAwKSB7XG4gICAgYTIgPSBhMDtcbiAgICBiMiA9IGIwO1xuICB9XG5cbiAgLy8gTm9ybWFsaXplIHNpZ25zXG4gIGlmIChhMS5uZWdhdGl2ZSkge1xuICAgIGExID0gYTEubmVnKCk7XG4gICAgYjEgPSBiMS5uZWcoKTtcbiAgfVxuICBpZiAoYTIubmVnYXRpdmUpIHtcbiAgICBhMiA9IGEyLm5lZygpO1xuICAgIGIyID0gYjIubmVnKCk7XG4gIH1cblxuICByZXR1cm4gW1xuICAgIHsgYTogYTEsIGI6IGIxIH0sXG4gICAgeyBhOiBhMiwgYjogYjIgfVxuICBdO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9TcGxpdCA9IGZ1bmN0aW9uIF9lbmRvU3BsaXQoaykge1xuICB2YXIgYmFzaXMgPSB0aGlzLmVuZG8uYmFzaXM7XG4gIHZhciB2MSA9IGJhc2lzWzBdO1xuICB2YXIgdjIgPSBiYXNpc1sxXTtcblxuICB2YXIgYzEgPSB2Mi5iLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuICB2YXIgYzIgPSB2MS5iLm5lZygpLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuXG4gIHZhciBwMSA9IGMxLm11bCh2MS5hKTtcbiAgdmFyIHAyID0gYzIubXVsKHYyLmEpO1xuICB2YXIgcTEgPSBjMS5tdWwodjEuYik7XG4gIHZhciBxMiA9IGMyLm11bCh2Mi5iKTtcblxuICAvLyBDYWxjdWxhdGUgYW5zd2VyXG4gIHZhciBrMSA9IGsuc3ViKHAxKS5zdWIocDIpO1xuICB2YXIgazIgPSBxMS5hZGQocTIpLm5lZygpO1xuICByZXR1cm4geyBrMTogazEsIGsyOiBrMiB9O1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWCA9IGZ1bmN0aW9uIHBvaW50RnJvbVgoeCwgb2RkKSB7XG4gIHggPSBuZXcgQk4oeCwgMTYpO1xuICBpZiAoIXgucmVkKVxuICAgIHggPSB4LnRvUmVkKHRoaXMucmVkKTtcblxuICB2YXIgeTIgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkKHgucmVkTXVsKHRoaXMuYSkpLnJlZElBZGQodGhpcy5iKTtcbiAgdmFyIHkgPSB5Mi5yZWRTcXJ0KCk7XG4gIGlmICh5LnJlZFNxcigpLnJlZFN1Yih5MikuY21wKHRoaXMuemVybykgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG5cbiAgLy8gWFhYIElzIHRoZXJlIGFueSB3YXkgdG8gdGVsbCBpZiB0aGUgbnVtYmVyIGlzIG9kZCB3aXRob3V0IGNvbnZlcnRpbmcgaXRcbiAgLy8gdG8gbm9uLXJlZCBmb3JtP1xuICB2YXIgaXNPZGQgPSB5LmZyb21SZWQoKS5pc09kZCgpO1xuICBpZiAob2RkICYmICFpc09kZCB8fCAhb2RkICYmIGlzT2RkKVxuICAgIHkgPSB5LnJlZE5lZygpO1xuXG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHkpO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShwb2ludCkge1xuICBpZiAocG9pbnQuaW5mKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIHZhciB4ID0gcG9pbnQueDtcbiAgdmFyIHkgPSBwb2ludC55O1xuXG4gIHZhciBheCA9IHRoaXMuYS5yZWRNdWwoeCk7XG4gIHZhciByaHMgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkKGF4KS5yZWRJQWRkKHRoaXMuYik7XG4gIHJldHVybiB5LnJlZFNxcigpLnJlZElTdWIocmhzKS5jbXBuKDApID09PSAwO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9XbmFmTXVsQWRkID1cbiAgICBmdW5jdGlvbiBfZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMsIGphY29iaWFuUmVzdWx0KSB7XG4gIHZhciBucG9pbnRzID0gdGhpcy5fZW5kb1duYWZUMTtcbiAgdmFyIG5jb2VmZnMgPSB0aGlzLl9lbmRvV25hZlQyO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzcGxpdCA9IHRoaXMuX2VuZG9TcGxpdChjb2VmZnNbaV0pO1xuICAgIHZhciBwID0gcG9pbnRzW2ldO1xuICAgIHZhciBiZXRhID0gcC5fZ2V0QmV0YSgpO1xuXG4gICAgaWYgKHNwbGl0LmsxLm5lZ2F0aXZlKSB7XG4gICAgICBzcGxpdC5rMS5pbmVnKCk7XG4gICAgICBwID0gcC5uZWcodHJ1ZSk7XG4gICAgfVxuICAgIGlmIChzcGxpdC5rMi5uZWdhdGl2ZSkge1xuICAgICAgc3BsaXQuazIuaW5lZygpO1xuICAgICAgYmV0YSA9IGJldGEubmVnKHRydWUpO1xuICAgIH1cblxuICAgIG5wb2ludHNbaSAqIDJdID0gcDtcbiAgICBucG9pbnRzW2kgKiAyICsgMV0gPSBiZXRhO1xuICAgIG5jb2VmZnNbaSAqIDJdID0gc3BsaXQuazE7XG4gICAgbmNvZWZmc1tpICogMiArIDFdID0gc3BsaXQuazI7XG4gIH1cbiAgdmFyIHJlcyA9IHRoaXMuX3duYWZNdWxBZGQoMSwgbnBvaW50cywgbmNvZWZmcywgaSAqIDIsIGphY29iaWFuUmVzdWx0KTtcblxuICAvLyBDbGVhbi11cCByZWZlcmVuY2VzIHRvIHBvaW50cyBhbmQgY29lZmZpY2llbnRzXG4gIGZvciAodmFyIGogPSAwOyBqIDwgaSAqIDI7IGorKykge1xuICAgIG5wb2ludHNbal0gPSBudWxsO1xuICAgIG5jb2VmZnNbal0gPSBudWxsO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeSwgaXNSZWQpIHtcbiAgQmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ2FmZmluZScpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gbnVsbDtcbiAgICB0aGlzLnkgPSBudWxsO1xuICAgIHRoaXMuaW5mID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgIHRoaXMueSA9IG5ldyBCTih5LCAxNik7XG4gICAgLy8gRm9yY2UgcmVkZ29tZXJ5IHJlcHJlc2VudGF0aW9uIHdoZW4gbG9hZGluZyBmcm9tIEpTT05cbiAgICBpZiAoaXNSZWQpIHtcbiAgICAgIHRoaXMueC5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgICB0aGlzLnkuZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMueC5yZWQpXG4gICAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy55LnJlZClcbiAgICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgdGhpcy5pbmYgPSBmYWxzZTtcbiAgfVxufVxuaW5oZXJpdHMoUG9pbnQsIEJhc2UuQmFzZVBvaW50KTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCh4LCB5LCBpc1JlZCkge1xuICByZXR1cm4gbmV3IFBvaW50KHRoaXMsIHgsIHksIGlzUmVkKTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50RnJvbUpTT04gPSBmdW5jdGlvbiBwb2ludEZyb21KU09OKG9iaiwgcmVkKSB7XG4gIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmosIHJlZCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2dldEJldGEgPSBmdW5jdGlvbiBfZ2V0QmV0YSgpIHtcbiAgaWYgKCF0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuO1xuXG4gIHZhciBwcmUgPSB0aGlzLnByZWNvbXB1dGVkO1xuICBpZiAocHJlICYmIHByZS5iZXRhKVxuICAgIHJldHVybiBwcmUuYmV0YTtcblxuICB2YXIgYmV0YSA9IHRoaXMuY3VydmUucG9pbnQodGhpcy54LnJlZE11bCh0aGlzLmN1cnZlLmVuZG8uYmV0YSksIHRoaXMueSk7XG4gIGlmIChwcmUpIHtcbiAgICB2YXIgY3VydmUgPSB0aGlzLmN1cnZlO1xuICAgIHZhciBlbmRvTXVsID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIGN1cnZlLnBvaW50KHAueC5yZWRNdWwoY3VydmUuZW5kby5iZXRhKSwgcC55KTtcbiAgICB9O1xuICAgIHByZS5iZXRhID0gYmV0YTtcbiAgICBiZXRhLnByZWNvbXB1dGVkID0ge1xuICAgICAgYmV0YTogbnVsbCxcbiAgICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICAgIHduZDogcHJlLm5hZi53bmQsXG4gICAgICAgIHBvaW50czogcHJlLm5hZi5wb2ludHMubWFwKGVuZG9NdWwpXG4gICAgICB9LFxuICAgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuICAgICAgICBwb2ludHM6IHByZS5kb3VibGVzLnBvaW50cy5tYXAoZW5kb011bClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBiZXRhO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgaWYgKCF0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiBbIHRoaXMueCwgdGhpcy55IF07XG5cbiAgcmV0dXJuIFsgdGhpcy54LCB0aGlzLnksIHRoaXMucHJlY29tcHV0ZWQgJiYge1xuICAgIGRvdWJsZXM6IHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcyAmJiB7XG4gICAgICBzdGVwOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMuc3RlcCxcbiAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzLnBvaW50cy5zbGljZSgxKVxuICAgIH0sXG4gICAgbmFmOiB0aGlzLnByZWNvbXB1dGVkLm5hZiAmJiB7XG4gICAgICB3bmQ6IHRoaXMucHJlY29tcHV0ZWQubmFmLnduZCxcbiAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5uYWYucG9pbnRzLnNsaWNlKDEpXG4gICAgfVxuICB9IF07XG59O1xuXG5Qb2ludC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKGN1cnZlLCBvYmosIHJlZCkge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpXG4gICAgb2JqID0gSlNPTi5wYXJzZShvYmopO1xuICB2YXIgcmVzID0gY3VydmUucG9pbnQob2JqWzBdLCBvYmpbMV0sIHJlZCk7XG4gIGlmICghb2JqWzJdKVxuICAgIHJldHVybiByZXM7XG5cbiAgZnVuY3Rpb24gb2JqMnBvaW50KG9iaikge1xuICAgIHJldHVybiBjdXJ2ZS5wb2ludChvYmpbMF0sIG9ialsxXSwgcmVkKTtcbiAgfVxuXG4gIHZhciBwcmUgPSBvYmpbMl07XG4gIHJlcy5wcmVjb21wdXRlZCA9IHtcbiAgICBiZXRhOiBudWxsLFxuICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG4gICAgICBwb2ludHM6IFsgcmVzIF0uY29uY2F0KHByZS5kb3VibGVzLnBvaW50cy5tYXAob2JqMnBvaW50KSlcbiAgICB9LFxuICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgcG9pbnRzOiBbIHJlcyBdLmNvbmNhdChwcmUubmFmLnBvaW50cy5tYXAob2JqMnBvaW50KSlcbiAgICB9XG4gIH07XG4gIHJldHVybiByZXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBQb2ludCB4OiAnICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB5OiAnICsgdGhpcy55LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIHJldHVybiB0aGlzLmluZjtcbn07XG5cblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiBwO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gUCArIFAgPSAyUFxuICBpZiAodGhpcy5lcShwKSlcbiAgICByZXR1cm4gdGhpcy5kYmwoKTtcblxuICAvLyBQICsgKC1QKSA9IE9cbiAgaWYgKHRoaXMubmVnKCkuZXEocCkpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgLy8gUCArIFEgPSBPXG4gIGlmICh0aGlzLnguY21wKHAueCkgPT09IDApXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgdmFyIGMgPSB0aGlzLnkucmVkU3ViKHAueSk7XG4gIGlmIChjLmNtcG4oMCkgIT09IDApXG4gICAgYyA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIocC54KS5yZWRJbnZtKCkpO1xuICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodGhpcy54KS5yZWRJU3ViKHAueCk7XG4gIHZhciBueSA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIobngpKS5yZWRJU3ViKHRoaXMueSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gMlAgPSBPXG4gIHZhciB5czEgPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gIGlmICh5czEuY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblxuICB2YXIgeDIgPSB0aGlzLngucmVkU3FyKCk7XG4gIHZhciBkeWludiA9IHlzMS5yZWRJbnZtKCk7XG4gIHZhciBjID0geDIucmVkQWRkKHgyKS5yZWRJQWRkKHgyKS5yZWRJQWRkKGEpLnJlZE11bChkeWludik7XG5cbiAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHRoaXMueC5yZWRBZGQodGhpcy54KSk7XG4gIHZhciBueSA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIobngpKS5yZWRJU3ViKHRoaXMueSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFgoKSB7XG4gIHJldHVybiB0aGlzLnguZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiBnZXRZKCkge1xuICByZXR1cm4gdGhpcy55LmZyb21SZWQoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaykge1xuICBrID0gbmV3IEJOKGssIDE2KTtcblxuICBpZiAodGhpcy5faGFzRG91YmxlcyhrKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZml4ZWROYWZNdWwodGhpcywgayk7XG4gIGVsc2UgaWYgKHRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQoWyB0aGlzIF0sIFsgayBdKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIG11bEFkZChrMSwgcDIsIGsyKSB7XG4gIHZhciBwb2ludHMgPSBbIHRoaXMsIHAyIF07XG4gIHZhciBjb2VmZnMgPSBbIGsxLCBrMiBdO1xuICBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBwb2ludHMsIGNvZWZmcywgMik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuam11bEFkZCA9IGZ1bmN0aW9uIGptdWxBZGQoazEsIHAyLCBrMikge1xuICB2YXIgcG9pbnRzID0gWyB0aGlzLCBwMiBdO1xuICB2YXIgY29lZmZzID0gWyBrMSwgazIgXTtcbiAgaWYgKHRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMsIHRydWUpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgcG9pbnRzLCBjb2VmZnMsIDIsIHRydWUpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEocCkge1xuICByZXR1cm4gdGhpcyA9PT0gcCB8fFxuICAgICAgICAgdGhpcy5pbmYgPT09IHAuaW5mICYmXG4gICAgICAgICAgICAgKHRoaXMuaW5mIHx8IHRoaXMueC5jbXAocC54KSA9PT0gMCAmJiB0aGlzLnkuY21wKHAueSkgPT09IDApO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyhfcHJlY29tcHV0ZSkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIHJlcyA9IHRoaXMuY3VydmUucG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCkpO1xuICBpZiAoX3ByZWNvbXB1dGUgJiYgdGhpcy5wcmVjb21wdXRlZCkge1xuICAgIHZhciBwcmUgPSB0aGlzLnByZWNvbXB1dGVkO1xuICAgIHZhciBuZWdhdGUgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gcC5uZWcoKTtcbiAgICB9O1xuICAgIHJlcy5wcmVjb21wdXRlZCA9IHtcbiAgICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICAgIHduZDogcHJlLm5hZi53bmQsXG4gICAgICAgIHBvaW50czogcHJlLm5hZi5wb2ludHMubWFwKG5lZ2F0ZSlcbiAgICAgIH0sXG4gICAgICBkb3VibGVzOiBwcmUuZG91YmxlcyAmJiB7XG4gICAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG4gICAgICAgIHBvaW50czogcHJlLmRvdWJsZXMucG9pbnRzLm1hcChuZWdhdGUpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnRvSiA9IGZ1bmN0aW9uIHRvSigpIHtcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcblxuICB2YXIgcmVzID0gdGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LCB0aGlzLnksIHRoaXMuY3VydmUub25lKTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIEpQb2ludChjdXJ2ZSwgeCwgeSwgeikge1xuICBCYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAnamFjb2JpYW4nKTtcbiAgaWYgKHggPT09IG51bGwgJiYgeSA9PT0gbnVsbCAmJiB6ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy55ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy56ID0gbmV3IEJOKDApO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IG5ldyBCTih4LCAxNik7XG4gICAgdGhpcy55ID0gbmV3IEJOKHksIDE2KTtcbiAgICB0aGlzLnogPSBuZXcgQk4oeiwgMTYpO1xuICB9XG4gIGlmICghdGhpcy54LnJlZClcbiAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICBpZiAoIXRoaXMueS5yZWQpXG4gICAgdGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgaWYgKCF0aGlzLnoucmVkKVxuICAgIHRoaXMueiA9IHRoaXMuei50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG5cbiAgdGhpcy56T25lID0gdGhpcy56ID09PSB0aGlzLmN1cnZlLm9uZTtcbn1cbmluaGVyaXRzKEpQb2ludCwgQmFzZS5CYXNlUG9pbnQpO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5qcG9pbnQgPSBmdW5jdGlvbiBqcG9pbnQoeCwgeSwgeikge1xuICByZXR1cm4gbmV3IEpQb2ludCh0aGlzLCB4LCB5LCB6KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUudG9QID0gZnVuY3Rpb24gdG9QKCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgdmFyIHppbnYgPSB0aGlzLnoucmVkSW52bSgpO1xuICB2YXIgemludjIgPSB6aW52LnJlZFNxcigpO1xuICB2YXIgYXggPSB0aGlzLngucmVkTXVsKHppbnYyKTtcbiAgdmFyIGF5ID0gdGhpcy55LnJlZE11bCh6aW52MikucmVkTXVsKHppbnYpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KGF4LCBheSk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZygpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KHRoaXMueCwgdGhpcy55LnJlZE5lZygpLCB0aGlzLnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gMTJNICsgNFMgKyA3QVxuICB2YXIgcHoyID0gcC56LnJlZFNxcigpO1xuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciB1MSA9IHRoaXMueC5yZWRNdWwocHoyKTtcbiAgdmFyIHUyID0gcC54LnJlZE11bCh6Mik7XG4gIHZhciBzMSA9IHRoaXMueS5yZWRNdWwocHoyLnJlZE11bChwLnopKTtcbiAgdmFyIHMyID0gcC55LnJlZE11bCh6Mi5yZWRNdWwodGhpcy56KSk7XG5cbiAgdmFyIGggPSB1MS5yZWRTdWIodTIpO1xuICB2YXIgciA9IHMxLnJlZFN1YihzMik7XG4gIGlmIChoLmNtcG4oMCkgPT09IDApIHtcbiAgICBpZiAoci5jbXBuKDApICE9PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLmRibCgpO1xuICB9XG5cbiAgdmFyIGgyID0gaC5yZWRTcXIoKTtcbiAgdmFyIGgzID0gaDIucmVkTXVsKGgpO1xuICB2YXIgdiA9IHUxLnJlZE11bChoMik7XG5cbiAgdmFyIG54ID0gci5yZWRTcXIoKS5yZWRJQWRkKGgzKS5yZWRJU3ViKHYpLnJlZElTdWIodik7XG4gIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7XG4gIHZhciBueiA9IHRoaXMuei5yZWRNdWwocC56KS5yZWRNdWwoaCk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5taXhlZEFkZCA9IGZ1bmN0aW9uIG1peGVkQWRkKHApIHtcbiAgLy8gTyArIFAgPSBQXG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gcC50b0ooKTtcblxuICAvLyBQICsgTyA9IFBcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIDhNICsgM1MgKyA3QVxuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciB1MSA9IHRoaXMueDtcbiAgdmFyIHUyID0gcC54LnJlZE11bCh6Mik7XG4gIHZhciBzMSA9IHRoaXMueTtcbiAgdmFyIHMyID0gcC55LnJlZE11bCh6MikucmVkTXVsKHRoaXMueik7XG5cbiAgdmFyIGggPSB1MS5yZWRTdWIodTIpO1xuICB2YXIgciA9IHMxLnJlZFN1YihzMik7XG4gIGlmIChoLmNtcG4oMCkgPT09IDApIHtcbiAgICBpZiAoci5jbXBuKDApICE9PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLmRibCgpO1xuICB9XG5cbiAgdmFyIGgyID0gaC5yZWRTcXIoKTtcbiAgdmFyIGgzID0gaDIucmVkTXVsKGgpO1xuICB2YXIgdiA9IHUxLnJlZE11bChoMik7XG5cbiAgdmFyIG54ID0gci5yZWRTcXIoKS5yZWRJQWRkKGgzKS5yZWRJU3ViKHYpLnJlZElTdWIodik7XG4gIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7XG4gIHZhciBueiA9IHRoaXMuei5yZWRNdWwoaCk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24gZGJscChwb3cpIHtcbiAgaWYgKHBvdyA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAoIXBvdylcbiAgICByZXR1cm4gdGhpcy5kYmwoKTtcblxuICBpZiAodGhpcy5jdXJ2ZS56ZXJvQSB8fCB0aGlzLmN1cnZlLnRocmVlQSkge1xuICAgIHZhciByID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvdzsgaSsrKVxuICAgICAgciA9IHIuZGJsKCk7XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICAvLyAxTSArIDJTICsgMUEgKyBOICogKDRTICsgNU0gKyA4QSlcbiAgLy8gTiA9IDEgPT4gNk0gKyA2UyArIDlBXG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuICB2YXIgdGludiA9IHRoaXMuY3VydmUudGludjtcblxuICB2YXIganggPSB0aGlzLng7XG4gIHZhciBqeSA9IHRoaXMueTtcbiAgdmFyIGp6ID0gdGhpcy56O1xuICB2YXIgano0ID0ganoucmVkU3FyKCkucmVkU3FyKCk7XG5cbiAgLy8gUmV1c2UgcmVzdWx0c1xuICB2YXIganlkID0gankucmVkQWRkKGp5KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3c7IGkrKykge1xuICAgIHZhciBqeDIgPSBqeC5yZWRTcXIoKTtcbiAgICB2YXIganlkMiA9IGp5ZC5yZWRTcXIoKTtcbiAgICB2YXIganlkNCA9IGp5ZDIucmVkU3FyKCk7XG4gICAgdmFyIGMgPSBqeDIucmVkQWRkKGp4MikucmVkSUFkZChqeDIpLnJlZElBZGQoYS5yZWRNdWwoano0KSk7XG5cbiAgICB2YXIgdDEgPSBqeC5yZWRNdWwoanlkMik7XG4gICAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHQxLnJlZEFkZCh0MSkpO1xuICAgIHZhciB0MiA9IHQxLnJlZElTdWIobngpO1xuICAgIHZhciBkbnkgPSBjLnJlZE11bCh0Mik7XG4gICAgZG55ID0gZG55LnJlZElBZGQoZG55KS5yZWRJU3ViKGp5ZDQpO1xuICAgIHZhciBueiA9IGp5ZC5yZWRNdWwoanopO1xuICAgIGlmIChpICsgMSA8IHBvdylcbiAgICAgIGp6NCA9IGp6NC5yZWRNdWwoanlkNCk7XG5cbiAgICBqeCA9IG54O1xuICAgIGp6ID0gbno7XG4gICAganlkID0gZG55O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KGp4LCBqeWQucmVkTXVsKHRpbnYpLCBqeik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uIGRibCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGlmICh0aGlzLmN1cnZlLnplcm9BKVxuICAgIHJldHVybiB0aGlzLl96ZXJvRGJsKCk7XG4gIGVsc2UgaWYgKHRoaXMuY3VydmUudGhyZWVBKVxuICAgIHJldHVybiB0aGlzLl90aHJlZURibCgpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX2RibCgpO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5femVyb0RibCA9IGZ1bmN0aW9uIF96ZXJvRGJsKCkge1xuICB2YXIgbng7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICAvLyBaID0gMVxuICBpZiAodGhpcy56T25lKSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWxcbiAgICAvLyAgICAgI2RvdWJsaW5nLW1kYmwtMjAwNy1ibFxuICAgIC8vIDFNICsgNVMgKyAxNEFcblxuICAgIC8vIFhYID0gWDFeMlxuICAgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBZWSA9IFkxXjJcbiAgICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gWVlZWSA9IFlZXjJcbiAgICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuICAgIC8vIFMgPSAyICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKVxuICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgICBzID0gcy5yZWRJQWRkKHMpO1xuICAgIC8vIE0gPSAzICogWFggKyBhOyBhID0gMFxuICAgIHZhciBtID0geHgucmVkQWRkKHh4KS5yZWRJQWRkKHh4KTtcbiAgICAvLyBUID0gTSBeIDIgLSAyKlNcbiAgICB2YXIgdCA9IG0ucmVkU3FyKCkucmVkSVN1YihzKS5yZWRJU3ViKHMpO1xuXG4gICAgLy8gOCAqIFlZWVlcbiAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuXG4gICAgLy8gWDMgPSBUXG4gICAgbnggPSB0O1xuICAgIC8vIFkzID0gTSAqIChTIC0gVCkgLSA4ICogWVlZWVxuICAgIG55ID0gbS5yZWRNdWwocy5yZWRJU3ViKHQpKS5yZWRJU3ViKHl5eXk4KTtcbiAgICAvLyBaMyA9IDIqWTFcbiAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbFxuICAgIC8vICAgICAjZG91YmxpbmctZGJsLTIwMDktbFxuICAgIC8vIDJNICsgNVMgKyAxM0FcblxuICAgIC8vIEEgPSBYMV4yXG4gICAgdmFyIGEgPSB0aGlzLngucmVkU3FyKCk7XG4gICAgLy8gQiA9IFkxXjJcbiAgICB2YXIgYiA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBDID0gQl4yXG4gICAgdmFyIGMgPSBiLnJlZFNxcigpO1xuICAgIC8vIEQgPSAyICogKChYMSArIEIpXjIgLSBBIC0gQylcbiAgICB2YXIgZCA9IHRoaXMueC5yZWRBZGQoYikucmVkU3FyKCkucmVkSVN1YihhKS5yZWRJU3ViKGMpO1xuICAgIGQgPSBkLnJlZElBZGQoZCk7XG4gICAgLy8gRSA9IDMgKiBBXG4gICAgdmFyIGUgPSBhLnJlZEFkZChhKS5yZWRJQWRkKGEpO1xuICAgIC8vIEYgPSBFXjJcbiAgICB2YXIgZiA9IGUucmVkU3FyKCk7XG5cbiAgICAvLyA4ICogQ1xuICAgIHZhciBjOCA9IGMucmVkSUFkZChjKTtcbiAgICBjOCA9IGM4LnJlZElBZGQoYzgpO1xuICAgIGM4ID0gYzgucmVkSUFkZChjOCk7XG5cbiAgICAvLyBYMyA9IEYgLSAyICogRFxuICAgIG54ID0gZi5yZWRJU3ViKGQpLnJlZElTdWIoZCk7XG4gICAgLy8gWTMgPSBFICogKEQgLSBYMykgLSA4ICogQ1xuICAgIG55ID0gZS5yZWRNdWwoZC5yZWRJU3ViKG54KSkucmVkSVN1YihjOCk7XG4gICAgLy8gWjMgPSAyICogWTEgKiBaMVxuICAgIG56ID0gdGhpcy55LnJlZE11bCh0aGlzLnopO1xuICAgIG56ID0gbnoucmVkSUFkZChueik7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl90aHJlZURibCA9IGZ1bmN0aW9uIF90aHJlZURibCgpIHtcbiAgdmFyIG54O1xuICB2YXIgbnk7XG4gIHZhciBuejtcbiAgLy8gWiA9IDFcbiAgaWYgKHRoaXMuek9uZSkge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMy5odG1sXG4gICAgLy8gICAgICNkb3VibGluZy1tZGJsLTIwMDctYmxcbiAgICAvLyAxTSArIDVTICsgMTVBXG5cbiAgICAvLyBYWCA9IFgxXjJcbiAgICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG4gICAgLy8gWVkgPSBZMV4yXG4gICAgdmFyIHl5ID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIFlZWVkgPSBZWV4yXG4gICAgdmFyIHl5eXkgPSB5eS5yZWRTcXIoKTtcbiAgICAvLyBTID0gMiAqICgoWDEgKyBZWSleMiAtIFhYIC0gWVlZWSlcbiAgICB2YXIgcyA9IHRoaXMueC5yZWRBZGQoeXkpLnJlZFNxcigpLnJlZElTdWIoeHgpLnJlZElTdWIoeXl5eSk7XG4gICAgcyA9IHMucmVkSUFkZChzKTtcbiAgICAvLyBNID0gMyAqIFhYICsgYVxuICAgIHZhciBtID0geHgucmVkQWRkKHh4KS5yZWRJQWRkKHh4KS5yZWRJQWRkKHRoaXMuY3VydmUuYSk7XG4gICAgLy8gVCA9IE1eMiAtIDIgKiBTXG4gICAgdmFyIHQgPSBtLnJlZFNxcigpLnJlZElTdWIocykucmVkSVN1YihzKTtcbiAgICAvLyBYMyA9IFRcbiAgICBueCA9IHQ7XG4gICAgLy8gWTMgPSBNICogKFMgLSBUKSAtIDggKiBZWVlZXG4gICAgdmFyIHl5eXk4ID0geXl5eS5yZWRJQWRkKHl5eXkpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcbiAgICBueSA9IG0ucmVkTXVsKHMucmVkSVN1Yih0KSkucmVkSVN1Yih5eXl5OCk7XG4gICAgLy8gWjMgPSAyICogWTFcbiAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTMuaHRtbCNkb3VibGluZy1kYmwtMjAwMS1iXG4gICAgLy8gM00gKyA1U1xuXG4gICAgLy8gZGVsdGEgPSBaMV4yXG4gICAgdmFyIGRlbHRhID0gdGhpcy56LnJlZFNxcigpO1xuICAgIC8vIGdhbW1hID0gWTFeMlxuICAgIHZhciBnYW1tYSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBiZXRhID0gWDEgKiBnYW1tYVxuICAgIHZhciBiZXRhID0gdGhpcy54LnJlZE11bChnYW1tYSk7XG4gICAgLy8gYWxwaGEgPSAzICogKFgxIC0gZGVsdGEpICogKFgxICsgZGVsdGEpXG4gICAgdmFyIGFscGhhID0gdGhpcy54LnJlZFN1YihkZWx0YSkucmVkTXVsKHRoaXMueC5yZWRBZGQoZGVsdGEpKTtcbiAgICBhbHBoYSA9IGFscGhhLnJlZEFkZChhbHBoYSkucmVkSUFkZChhbHBoYSk7XG4gICAgLy8gWDMgPSBhbHBoYV4yIC0gOCAqIGJldGFcbiAgICB2YXIgYmV0YTQgPSBiZXRhLnJlZElBZGQoYmV0YSk7XG4gICAgYmV0YTQgPSBiZXRhNC5yZWRJQWRkKGJldGE0KTtcbiAgICB2YXIgYmV0YTggPSBiZXRhNC5yZWRBZGQoYmV0YTQpO1xuICAgIG54ID0gYWxwaGEucmVkU3FyKCkucmVkSVN1YihiZXRhOCk7XG4gICAgLy8gWjMgPSAoWTEgKyBaMSleMiAtIGdhbW1hIC0gZGVsdGFcbiAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy56KS5yZWRTcXIoKS5yZWRJU3ViKGdhbW1hKS5yZWRJU3ViKGRlbHRhKTtcbiAgICAvLyBZMyA9IGFscGhhICogKDQgKiBiZXRhIC0gWDMpIC0gOCAqIGdhbW1hXjJcbiAgICB2YXIgZ2dhbW1hOCA9IGdhbW1hLnJlZFNxcigpO1xuICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG4gICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcbiAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgIG55ID0gYWxwaGEucmVkTXVsKGJldGE0LnJlZElTdWIobngpKS5yZWRJU3ViKGdnYW1tYTgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5fZGJsID0gZnVuY3Rpb24gX2RibCgpIHtcbiAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG5cbiAgLy8gNE0gKyA2UyArIDEwQVxuICB2YXIganggPSB0aGlzLng7XG4gIHZhciBqeSA9IHRoaXMueTtcbiAgdmFyIGp6ID0gdGhpcy56O1xuICB2YXIgano0ID0ganoucmVkU3FyKCkucmVkU3FyKCk7XG5cbiAgdmFyIGp4MiA9IGp4LnJlZFNxcigpO1xuICB2YXIgankyID0gankucmVkU3FyKCk7XG5cbiAgdmFyIGMgPSBqeDIucmVkQWRkKGp4MikucmVkSUFkZChqeDIpLnJlZElBZGQoYS5yZWRNdWwoano0KSk7XG5cbiAgdmFyIGp4ZDQgPSBqeC5yZWRBZGQoangpO1xuICBqeGQ0ID0ganhkNC5yZWRJQWRkKGp4ZDQpO1xuICB2YXIgdDEgPSBqeGQ0LnJlZE11bChqeTIpO1xuICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodDEucmVkQWRkKHQxKSk7XG4gIHZhciB0MiA9IHQxLnJlZElTdWIobngpO1xuXG4gIHZhciBqeWQ4ID0gankyLnJlZFNxcigpO1xuICBqeWQ4ID0ganlkOC5yZWRJQWRkKGp5ZDgpO1xuICBqeWQ4ID0ganlkOC5yZWRJQWRkKGp5ZDgpO1xuICBqeWQ4ID0ganlkOC5yZWRJQWRkKGp5ZDgpO1xuICB2YXIgbnkgPSBjLnJlZE11bCh0MikucmVkSVN1YihqeWQ4KTtcbiAgdmFyIG56ID0gankucmVkQWRkKGp5KS5yZWRNdWwoanopO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUudHJwbCA9IGZ1bmN0aW9uIHRycGwoKSB7XG4gIGlmICghdGhpcy5jdXJ2ZS56ZXJvQSlcbiAgICByZXR1cm4gdGhpcy5kYmwoKS5hZGQodGhpcyk7XG5cbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWwjdHJpcGxpbmctdHBsLTIwMDctYmxcbiAgLy8gNU0gKyAxMFMgKyAuLi5cblxuICAvLyBYWCA9IFgxXjJcbiAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAvLyBZWSA9IFkxXjJcbiAgdmFyIHl5ID0gdGhpcy55LnJlZFNxcigpO1xuICAvLyBaWiA9IFoxXjJcbiAgdmFyIHp6ID0gdGhpcy56LnJlZFNxcigpO1xuICAvLyBZWVlZID0gWVleMlxuICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuICAvLyBNID0gMyAqIFhYICsgYSAqIFpaMjsgYSA9IDBcbiAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO1xuICAvLyBNTSA9IE1eMlxuICB2YXIgbW0gPSBtLnJlZFNxcigpO1xuICAvLyBFID0gNiAqICgoWDEgKyBZWSleMiAtIFhYIC0gWVlZWSkgLSBNTVxuICB2YXIgZSA9IHRoaXMueC5yZWRBZGQoeXkpLnJlZFNxcigpLnJlZElTdWIoeHgpLnJlZElTdWIoeXl5eSk7XG4gIGUgPSBlLnJlZElBZGQoZSk7XG4gIGUgPSBlLnJlZEFkZChlKS5yZWRJQWRkKGUpO1xuICBlID0gZS5yZWRJU3ViKG1tKTtcbiAgLy8gRUUgPSBFXjJcbiAgdmFyIGVlID0gZS5yZWRTcXIoKTtcbiAgLy8gVCA9IDE2KllZWVlcbiAgdmFyIHQgPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gIHQgPSB0LnJlZElBZGQodCk7XG4gIHQgPSB0LnJlZElBZGQodCk7XG4gIHQgPSB0LnJlZElBZGQodCk7XG4gIC8vIFUgPSAoTSArIEUpXjIgLSBNTSAtIEVFIC0gVFxuICB2YXIgdSA9IG0ucmVkSUFkZChlKS5yZWRTcXIoKS5yZWRJU3ViKG1tKS5yZWRJU3ViKGVlKS5yZWRJU3ViKHQpO1xuICAvLyBYMyA9IDQgKiAoWDEgKiBFRSAtIDQgKiBZWSAqIFUpXG4gIHZhciB5eXU0ID0geXkucmVkTXVsKHUpO1xuICB5eXU0ID0geXl1NC5yZWRJQWRkKHl5dTQpO1xuICB5eXU0ID0geXl1NC5yZWRJQWRkKHl5dTQpO1xuICB2YXIgbnggPSB0aGlzLngucmVkTXVsKGVlKS5yZWRJU3ViKHl5dTQpO1xuICBueCA9IG54LnJlZElBZGQobngpO1xuICBueCA9IG54LnJlZElBZGQobngpO1xuICAvLyBZMyA9IDggKiBZMSAqIChVICogKFQgLSBVKSAtIEUgKiBFRSlcbiAgdmFyIG55ID0gdGhpcy55LnJlZE11bCh1LnJlZE11bCh0LnJlZElTdWIodSkpLnJlZElTdWIoZS5yZWRNdWwoZWUpKSk7XG4gIG55ID0gbnkucmVkSUFkZChueSk7XG4gIG55ID0gbnkucmVkSUFkZChueSk7XG4gIG55ID0gbnkucmVkSUFkZChueSk7XG4gIC8vIFozID0gKFoxICsgRSleMiAtIFpaIC0gRUVcbiAgdmFyIG56ID0gdGhpcy56LnJlZEFkZChlKS5yZWRTcXIoKS5yZWRJU3ViKHp6KS5yZWRJU3ViKGVlKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrLCBrYmFzZSkge1xuICBrID0gbmV3IEJOKGssIGtiYXNlKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bCh0aGlzLCBrKTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShwKSB7XG4gIGlmIChwLnR5cGUgPT09ICdhZmZpbmUnKVxuICAgIHJldHVybiB0aGlzLmVxKHAudG9KKCkpO1xuXG4gIGlmICh0aGlzID09PSBwKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIHgxICogejJeMiA9PSB4MiAqIHoxXjJcbiAgdmFyIHoyID0gdGhpcy56LnJlZFNxcigpO1xuICB2YXIgcHoyID0gcC56LnJlZFNxcigpO1xuICBpZiAodGhpcy54LnJlZE11bChwejIpLnJlZElTdWIocC54LnJlZE11bCh6MikpLmNtcG4oMCkgIT09IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIHkxICogejJeMyA9PSB5MiAqIHoxXjNcbiAgdmFyIHozID0gejIucmVkTXVsKHRoaXMueik7XG4gIHZhciBwejMgPSBwejIucmVkTXVsKHAueik7XG4gIHJldHVybiB0aGlzLnkucmVkTXVsKHB6MykucmVkSVN1YihwLnkucmVkTXVsKHozKSkuY21wbigwKSA9PT0gMDtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZXFYVG9QID0gZnVuY3Rpb24gZXFYVG9QKHgpIHtcbiAgdmFyIHpzID0gdGhpcy56LnJlZFNxcigpO1xuICB2YXIgcnggPSB4LnRvUmVkKHRoaXMuY3VydmUucmVkKS5yZWRNdWwoenMpO1xuICBpZiAodGhpcy54LmNtcChyeCkgPT09IDApXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgdmFyIHhjID0geC5jbG9uZSgpO1xuICB2YXIgdCA9IHRoaXMuY3VydmUucmVkTi5yZWRNdWwoenMpO1xuICBmb3IgKDs7KSB7XG4gICAgeGMuaWFkZCh0aGlzLmN1cnZlLm4pO1xuICAgIGlmICh4Yy5jbXAodGhpcy5jdXJ2ZS5wKSA+PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgcngucmVkSUFkZCh0KTtcbiAgICBpZiAodGhpcy54LmNtcChyeCkgPT09IDApXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuSlBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIEpQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBKUG9pbnQgeDogJyArIHRoaXMueC50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB5OiAnICsgdGhpcy55LnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHo6ICcgKyB0aGlzLnoudG9TdHJpbmcoMTYsIDIpICsgJz4nO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgLy8gWFhYIFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgemVybyBpcyBhbHdheXMgemVybyBpbiByZWRcbiAgcmV0dXJuIHRoaXMuei5jbXBuKDApID09PSAwO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlcyA9IGV4cG9ydHM7XG5cbnZhciBoYXNoID0gcmVxdWlyZSgnaGFzaC5qcycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vZWxsaXB0aWMnKTtcblxudmFyIGFzc2VydCA9IGVsbGlwdGljLnV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gUHJlc2V0Q3VydmUob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy50eXBlID09PSAnc2hvcnQnKVxuICAgIHRoaXMuY3VydmUgPSBuZXcgZWxsaXB0aWMuY3VydmUuc2hvcnQob3B0aW9ucyk7XG4gIGVsc2UgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ2Vkd2FyZHMnKVxuICAgIHRoaXMuY3VydmUgPSBuZXcgZWxsaXB0aWMuY3VydmUuZWR3YXJkcyhvcHRpb25zKTtcbiAgZWxzZVxuICAgIHRoaXMuY3VydmUgPSBuZXcgZWxsaXB0aWMuY3VydmUubW9udChvcHRpb25zKTtcbiAgdGhpcy5nID0gdGhpcy5jdXJ2ZS5nO1xuICB0aGlzLm4gPSB0aGlzLmN1cnZlLm47XG4gIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaDtcblxuICBhc3NlcnQodGhpcy5nLnZhbGlkYXRlKCksICdJbnZhbGlkIGN1cnZlJyk7XG4gIGFzc2VydCh0aGlzLmcubXVsKHRoaXMubikuaXNJbmZpbml0eSgpLCAnSW52YWxpZCBjdXJ2ZSwgRypOICE9IE8nKTtcbn1cbmN1cnZlcy5QcmVzZXRDdXJ2ZSA9IFByZXNldEN1cnZlO1xuXG5mdW5jdGlvbiBkZWZpbmVDdXJ2ZShuYW1lLCBvcHRpb25zKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJ2ZXMsIG5hbWUsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGN1cnZlID0gbmV3IFByZXNldEN1cnZlKG9wdGlvbnMpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcywgbmFtZSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBjdXJ2ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY3VydmU7XG4gICAgfVxuICB9KTtcbn1cblxuZGVmaW5lQ3VydmUoJ3AxOTInLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiAncDE5MicsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICc2NDIxMDUxOSBlNTljODBlNyAwZmE3ZTlhYiA3MjI0MzA0OSBmZWI4ZGVlYyBjMTQ2YjliMScsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiA5OWRlZjgzNiAxNDZiYzliMSBiNGQyMjgzMScsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICcxODhkYTgwZSBiMDMwOTBmNiA3Y2JmMjBlYiA0M2ExODgwMCBmNGZmMGFmZCA4MmZmMTAxMicsXG4gICAgJzA3MTkyYjk1IGZmYzhkYTc4IDYzMTAxMWVkIDZiMjRjZGQ1IDczZjk3N2ExIDFlNzk0ODExJ1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ3AyMjQnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiAncDIyNCcsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScsXG4gIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZScsXG4gIGI6ICdiNDA1MGE4NSAwYzA0YjNhYiBmNTQxMzI1NiA1MDQ0YjBiNyBkN2JmZDhiYSAyNzBiMzk0MyAyMzU1ZmZiNCcsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmMTZhMiBlMGI4ZjAzZSAxM2RkMjk0NSA1YzVjMmEzZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICdiNzBlMGNiZCA2YmI0YmY3ZiAzMjEzOTBiOSA0YTAzYzFkMyA1NmMyMTEyMiAzNDMyODBkNiAxMTVjMWQyMScsXG4gICAgJ2JkMzc2Mzg4IGI1ZjcyM2ZiIDRjMjJkZmU2IGNkNDM3NWEwIDVhMDc0NzY0IDQ0ZDU4MTk5IDg1MDA3ZTM0J1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ3AyNTYnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiBudWxsLFxuICBwOiAnZmZmZmZmZmYgMDAwMDAwMDEgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnLFxuICBhOiAnZmZmZmZmZmYgMDAwMDAwMDEgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmMnLFxuICBiOiAnNWFjNjM1ZDggYWEzYTkzZTcgYjNlYmJkNTUgNzY5ODg2YmMgNjUxZDA2YjAgY2M1M2IwZjYgM2JjZTNjM2UgMjdkMjYwNGInLFxuICBuOiAnZmZmZmZmZmYgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgYmNlNmZhYWQgYTcxNzllODQgZjNiOWNhYzIgZmM2MzI1NTEnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnNmIxN2QxZjIgZTEyYzQyNDcgZjhiY2U2ZTUgNjNhNDQwZjIgNzcwMzdkODEgMmRlYjMzYTAgZjRhMTM5NDUgZDg5OGMyOTYnLFxuICAgICc0ZmUzNDJlMiBmZTFhN2Y5YiA4ZWU3ZWI0YSA3YzBmOWUxNiAyYmNlMzM1NyA2YjMxNWVjZSBjYmI2NDA2OCAzN2JmNTFmNSdcbiAgXVxufSk7XG5cbmRlZmluZUN1cnZlKCdwMzg0Jywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogbnVsbCxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmUgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmYnLFxuICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZSBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmYycsXG4gIGI6ICdiMzMxMmZhNyBlMjNlZTdlNCA5ODhlMDU2YiBlM2Y4MmQxOSAxODFkOWM2ZSBmZTgxNDExMiAwMzE0MDg4ZiAnICtcbiAgICAgJzUwMTM4NzVhIGM2NTYzOThkIDhhMmVkMTlkIDJhODVjOGVkIGQzZWMyYWVmJyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGM3NjM0ZDgxICcgK1xuICAgICAnZjQzNzJkZGYgNTgxYTBkYjIgNDhiMGE3N2EgZWNlYzE5NmEgY2NjNTI5NzMnLFxuICBoYXNoOiBoYXNoLnNoYTM4NCxcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnYWE4N2NhMjIgYmU4YjA1MzcgOGViMWM3MWUgZjMyMGFkNzQgNmUxZDNiNjIgOGJhNzliOTggNTlmNzQxZTAgODI1NDJhMzggJyArXG4gICAgJzU1MDJmMjVkIGJmNTUyOTZjIDNhNTQ1ZTM4IDcyNzYwYWI3JyxcbiAgICAnMzYxN2RlNGEgOTYyNjJjNmYgNWQ5ZTk4YmYgOTI5MmRjMjkgZjhmNDFkYmQgMjg5YTE0N2MgZTlkYTMxMTMgYjVmMGI4YzAgJyArXG4gICAgJzBhNjBiMWNlIDFkN2U4MTlkIDdhNDMxZDdjIDkwZWEwZTVmJ1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ3A1MjEnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiBudWxsLFxuICBwOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmJyxcbiAgYTogJzAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICcwMDAwMDA1MSA5NTNlYjk2MSA4ZTFjOWExZiA5MjlhMjFhMCBiNjg1NDBlZSBhMmRhNzI1YiAnICtcbiAgICAgJzk5YjMxNWYzIGI4YjQ4OTkxIDhlZjEwOWUxIDU2MTkzOTUxIGVjN2U5MzdiIDE2NTJjMGJkICcgK1xuICAgICAnM2JiMWJmMDcgMzU3M2RmODggM2QyYzM0ZjEgZWY0NTFmZDQgNmI1MDNmMDAnLFxuICBuOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYSA1MTg2ODc4MyBiZjJmOTY2YiA3ZmNjMDE0OCAnICtcbiAgICAgJ2Y3MDlhNWQwIDNiYjVjOWI4IDg5OWM0N2FlIGJiNmZiNzFlIDkxMzg2NDA5JyxcbiAgaGFzaDogaGFzaC5zaGE1MTIsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzAwMDAwMGM2IDg1OGUwNmI3IDA0MDRlOWNkIDllM2VjYjY2IDIzOTViNDQyIDljNjQ4MTM5ICcgK1xuICAgICcwNTNmYjUyMSBmODI4YWY2MCA2YjRkM2RiYSBhMTRiNWU3NyBlZmU3NTkyOCBmZTFkYzEyNyAnICtcbiAgICAnYTJmZmE4ZGUgMzM0OGIzYzEgODU2YTQyOWIgZjk3ZTdlMzEgYzJlNWJkNjYnLFxuICAgICcwMDAwMDExOCAzOTI5NmE3OCA5YTNiYzAwNCA1YzhhNWZiNCAyYzdkMWJkOSA5OGY1NDQ0OSAnICtcbiAgICAnNTc5YjQ0NjggMTdhZmJkMTcgMjczZTY2MmMgOTdlZTcyOTkgNWVmNDI2NDAgYzU1MGI5MDEgJyArXG4gICAgJzNmYWQwNzYxIDM1M2M3MDg2IGEyNzJjMjQwIDg4YmU5NDc2IDlmZDE2NjUwJ1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ2N1cnZlMjU1MTknLCB7XG4gIHR5cGU6ICdtb250JyxcbiAgcHJpbWU6ICdwMjU1MTknLFxuICBwOiAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcsXG4gIGE6ICc3NmQwNicsXG4gIGI6ICcxJyxcbiAgbjogJzEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWQnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnOSdcbiAgXVxufSk7XG5cbmRlZmluZUN1cnZlKCdlZDI1NTE5Jywge1xuICB0eXBlOiAnZWR3YXJkcycsXG4gIHByaW1lOiAncDI1NTE5JyxcbiAgcDogJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnLFxuICBhOiAnLTEnLFxuICBjOiAnMScsXG4gIC8vIC0xMjE2NjUgKiAoMTIxNjY2XigtMSkpIChtb2QgUClcbiAgZDogJzUyMDM2Y2VlMmI2ZmZlNzMgOGNjNzQwNzk3Nzc5ZTg5OCAwMDcwMGE0ZDQxNDFkOGFiIDc1ZWI0ZGNhMTM1OTc4YTMnLFxuICBuOiAnMTAwMDAwMDAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwIDE0ZGVmOWRlYTJmNzljZDYgNTgxMjYzMWE1Y2Y1ZDNlZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICcyMTY5MzZkM2NkNmU1M2ZlYzBhNGUyMzFmZGQ2ZGM1YzY5MmNjNzYwOTUyNWE3YjJjOTU2MmQ2MDhmMjVkNTFhJyxcblxuICAgIC8vIDQvNVxuICAgICc2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjU4J1xuICBdXG59KTtcblxudmFyIHByZTtcbnRyeSB7XG4gIHByZSA9IHJlcXVpcmUoJy4vcHJlY29tcHV0ZWQvc2VjcDI1NmsxJyk7XG59IGNhdGNoIChlKSB7XG4gIHByZSA9IHVuZGVmaW5lZDtcbn1cblxuZGVmaW5lQ3VydmUoJ3NlY3AyNTZrMScsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6ICdrMjU2JyxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyxcbiAgYTogJzAnLFxuICBiOiAnNycsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBiYWFlZGNlNiBhZjQ4YTAzYiBiZmQyNWU4YyBkMDM2NDE0MScsXG4gIGg6ICcxJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG5cbiAgLy8gUHJlY29tcHV0ZWQgZW5kb21vcnBoaXNtXG4gIGJldGE6ICc3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlJyxcbiAgbGFtYmRhOiAnNTM2M2FkNGNjMDVjMzBlMGE1MjYxYzAyODgxMjY0NWExMjJlMjJlYTIwODE2Njc4ZGYwMjk2N2MxYjIzYmQ3MicsXG4gIGJhc2lzOiBbXG4gICAge1xuICAgICAgYTogJzMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1JyxcbiAgICAgIGI6ICctZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnXG4gICAgfSxcbiAgICB7XG4gICAgICBhOiAnMTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4JyxcbiAgICAgIGI6ICczMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNSdcbiAgICB9XG4gIF0sXG5cbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnNzliZTY2N2VmOWRjYmJhYzU1YTA2Mjk1Y2U4NzBiMDcwMjliZmNkYjJkY2UyOGQ5NTlmMjgxNWIxNmY4MTc5OCcsXG4gICAgJzQ4M2FkYTc3MjZhM2M0NjU1ZGE0ZmJmYzBlMTEwOGE4ZmQxN2I0NDhhNjg1NTQxOTljNDdkMDhmZmIxMGQ0YjgnLFxuICAgIHByZVxuICBdXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBIbWFjRFJCRyA9IHJlcXVpcmUoJ2htYWMtZHJiZycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxudmFyIEtleVBhaXIgPSByZXF1aXJlKCcuL2tleScpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG5cbmZ1bmN0aW9uIEVDKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVDKSlcbiAgICByZXR1cm4gbmV3IEVDKG9wdGlvbnMpO1xuXG4gIC8vIFNob3J0Y3V0IGBlbGxpcHRpYy5lYyhjdXJ2ZS1uYW1lKWBcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIGFzc2VydChlbGxpcHRpYy5jdXJ2ZXMuaGFzT3duUHJvcGVydHkob3B0aW9ucyksICdVbmtub3duIGN1cnZlICcgKyBvcHRpb25zKTtcblxuICAgIG9wdGlvbnMgPSBlbGxpcHRpYy5jdXJ2ZXNbb3B0aW9uc107XG4gIH1cblxuICAvLyBTaG9ydGN1dCBmb3IgYGVsbGlwdGljLmVjKGVsbGlwdGljLmN1cnZlcy5jdXJ2ZU5hbWUpYFxuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIGVsbGlwdGljLmN1cnZlcy5QcmVzZXRDdXJ2ZSlcbiAgICBvcHRpb25zID0geyBjdXJ2ZTogb3B0aW9ucyB9O1xuXG4gIHRoaXMuY3VydmUgPSBvcHRpb25zLmN1cnZlLmN1cnZlO1xuICB0aGlzLm4gPSB0aGlzLmN1cnZlLm47XG4gIHRoaXMubmggPSB0aGlzLm4udXNocm4oMSk7XG4gIHRoaXMuZyA9IHRoaXMuY3VydmUuZztcblxuICAvLyBQb2ludCBvbiBjdXJ2ZVxuICB0aGlzLmcgPSBvcHRpb25zLmN1cnZlLmc7XG4gIHRoaXMuZy5wcmVjb21wdXRlKG9wdGlvbnMuY3VydmUubi5iaXRMZW5ndGgoKSArIDEpO1xuXG4gIC8vIEhhc2ggZm9yIGZ1bmN0aW9uIGZvciBEUkJHXG4gIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaCB8fCBvcHRpb25zLmN1cnZlLmhhc2g7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEVDO1xuXG5FQy5wcm90b3R5cGUua2V5UGFpciA9IGZ1bmN0aW9uIGtleVBhaXIob3B0aW9ucykge1xuICByZXR1cm4gbmV3IEtleVBhaXIodGhpcywgb3B0aW9ucyk7XG59O1xuXG5FQy5wcm90b3R5cGUua2V5RnJvbVByaXZhdGUgPSBmdW5jdGlvbiBrZXlGcm9tUHJpdmF0ZShwcml2LCBlbmMpIHtcbiAgcmV0dXJuIEtleVBhaXIuZnJvbVByaXZhdGUodGhpcywgcHJpdiwgZW5jKTtcbn07XG5cbkVDLnByb3RvdHlwZS5rZXlGcm9tUHVibGljID0gZnVuY3Rpb24ga2V5RnJvbVB1YmxpYyhwdWIsIGVuYykge1xuICByZXR1cm4gS2V5UGFpci5mcm9tUHVibGljKHRoaXMsIHB1YiwgZW5jKTtcbn07XG5cbkVDLnByb3RvdHlwZS5nZW5LZXlQYWlyID0gZnVuY3Rpb24gZ2VuS2V5UGFpcihvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucylcbiAgICBvcHRpb25zID0ge307XG5cbiAgLy8gSW5zdGFudGlhdGUgSG1hY19EUkJHXG4gIHZhciBkcmJnID0gbmV3IEhtYWNEUkJHKHtcbiAgICBoYXNoOiB0aGlzLmhhc2gsXG4gICAgcGVyczogb3B0aW9ucy5wZXJzLFxuICAgIHBlcnNFbmM6IG9wdGlvbnMucGVyc0VuYyB8fCAndXRmOCcsXG4gICAgZW50cm9weTogb3B0aW9ucy5lbnRyb3B5IHx8IGVsbGlwdGljLnJhbmQodGhpcy5oYXNoLmhtYWNTdHJlbmd0aCksXG4gICAgZW50cm9weUVuYzogb3B0aW9ucy5lbnRyb3B5ICYmIG9wdGlvbnMuZW50cm9weUVuYyB8fCAndXRmOCcsXG4gICAgbm9uY2U6IHRoaXMubi50b0FycmF5KClcbiAgfSk7XG5cbiAgdmFyIGJ5dGVzID0gdGhpcy5uLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIG5zMiA9IHRoaXMubi5zdWIobmV3IEJOKDIpKTtcbiAgZG8ge1xuICAgIHZhciBwcml2ID0gbmV3IEJOKGRyYmcuZ2VuZXJhdGUoYnl0ZXMpKTtcbiAgICBpZiAocHJpdi5jbXAobnMyKSA+IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHByaXYuaWFkZG4oMSk7XG4gICAgcmV0dXJuIHRoaXMua2V5RnJvbVByaXZhdGUocHJpdik7XG4gIH0gd2hpbGUgKHRydWUpO1xufTtcblxuRUMucHJvdG90eXBlLl90cnVuY2F0ZVRvTiA9IGZ1bmN0aW9uIHRydW5jYXRlVG9OKG1zZywgdHJ1bmNPbmx5KSB7XG4gIHZhciBkZWx0YSA9IG1zZy5ieXRlTGVuZ3RoKCkgKiA4IC0gdGhpcy5uLmJpdExlbmd0aCgpO1xuICBpZiAoZGVsdGEgPiAwKVxuICAgIG1zZyA9IG1zZy51c2hybihkZWx0YSk7XG4gIGlmICghdHJ1bmNPbmx5ICYmIG1zZy5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBtc2cuc3ViKHRoaXMubik7XG4gIGVsc2VcbiAgICByZXR1cm4gbXNnO1xufTtcblxuRUMucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1zZywga2V5LCBlbmMsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBlbmMgPT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucyA9IGVuYztcbiAgICBlbmMgPSBudWxsO1xuICB9XG4gIGlmICghb3B0aW9ucylcbiAgICBvcHRpb25zID0ge307XG5cbiAga2V5ID0gdGhpcy5rZXlGcm9tUHJpdmF0ZShrZXksIGVuYyk7XG4gIG1zZyA9IHRoaXMuX3RydW5jYXRlVG9OKG5ldyBCTihtc2csIDE2KSk7XG5cbiAgLy8gWmVyby1leHRlbmQga2V5IHRvIHByb3ZpZGUgZW5vdWdoIGVudHJvcHlcbiAgdmFyIGJ5dGVzID0gdGhpcy5uLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIGJrZXkgPSBrZXkuZ2V0UHJpdmF0ZSgpLnRvQXJyYXkoJ2JlJywgYnl0ZXMpO1xuXG4gIC8vIFplcm8tZXh0ZW5kIG5vbmNlIHRvIGhhdmUgdGhlIHNhbWUgYnl0ZSBzaXplIGFzIE5cbiAgdmFyIG5vbmNlID0gbXNnLnRvQXJyYXkoJ2JlJywgYnl0ZXMpO1xuXG4gIC8vIEluc3RhbnRpYXRlIEhtYWNfRFJCR1xuICB2YXIgZHJiZyA9IG5ldyBIbWFjRFJCRyh7XG4gICAgaGFzaDogdGhpcy5oYXNoLFxuICAgIGVudHJvcHk6IGJrZXksXG4gICAgbm9uY2U6IG5vbmNlLFxuICAgIHBlcnM6IG9wdGlvbnMucGVycyxcbiAgICBwZXJzRW5jOiBvcHRpb25zLnBlcnNFbmMgfHwgJ3V0ZjgnXG4gIH0pO1xuXG4gIC8vIE51bWJlciBvZiBieXRlcyB0byBnZW5lcmF0ZVxuICB2YXIgbnMxID0gdGhpcy5uLnN1YihuZXcgQk4oMSkpO1xuXG4gIGZvciAodmFyIGl0ZXIgPSAwOyB0cnVlOyBpdGVyKyspIHtcbiAgICB2YXIgayA9IG9wdGlvbnMuayA/XG4gICAgICAgIG9wdGlvbnMuayhpdGVyKSA6XG4gICAgICAgIG5ldyBCTihkcmJnLmdlbmVyYXRlKHRoaXMubi5ieXRlTGVuZ3RoKCkpKTtcbiAgICBrID0gdGhpcy5fdHJ1bmNhdGVUb04oaywgdHJ1ZSk7XG4gICAgaWYgKGsuY21wbigxKSA8PSAwIHx8IGsuY21wKG5zMSkgPj0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIGtwID0gdGhpcy5nLm11bChrKTtcbiAgICBpZiAoa3AuaXNJbmZpbml0eSgpKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIga3BYID0ga3AuZ2V0WCgpO1xuICAgIHZhciByID0ga3BYLnVtb2QodGhpcy5uKTtcbiAgICBpZiAoci5jbXBuKDApID09PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIgcyA9IGsuaW52bSh0aGlzLm4pLm11bChyLm11bChrZXkuZ2V0UHJpdmF0ZSgpKS5pYWRkKG1zZykpO1xuICAgIHMgPSBzLnVtb2QodGhpcy5uKTtcbiAgICBpZiAocy5jbXBuKDApID09PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIgcmVjb3ZlcnlQYXJhbSA9IChrcC5nZXRZKCkuaXNPZGQoKSA/IDEgOiAwKSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoa3BYLmNtcChyKSAhPT0gMCA/IDIgOiAwKTtcblxuICAgIC8vIFVzZSBjb21wbGVtZW50IG9mIGBzYCwgaWYgaXQgaXMgPiBgbiAvIDJgXG4gICAgaWYgKG9wdGlvbnMuY2Fub25pY2FsICYmIHMuY21wKHRoaXMubmgpID4gMCkge1xuICAgICAgcyA9IHRoaXMubi5zdWIocyk7XG4gICAgICByZWNvdmVyeVBhcmFtIF49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoeyByOiByLCBzOiBzLCByZWNvdmVyeVBhcmFtOiByZWNvdmVyeVBhcmFtIH0pO1xuICB9XG59O1xuXG5FQy5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1zZywgc2lnbmF0dXJlLCBrZXksIGVuYykge1xuICBtc2cgPSB0aGlzLl90cnVuY2F0ZVRvTihuZXcgQk4obXNnLCAxNikpO1xuICBrZXkgPSB0aGlzLmtleUZyb21QdWJsaWMoa2V5LCBlbmMpO1xuICBzaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKHNpZ25hdHVyZSwgJ2hleCcpO1xuXG4gIC8vIFBlcmZvcm0gcHJpbWl0aXZlIHZhbHVlcyB2YWxpZGF0aW9uXG4gIHZhciByID0gc2lnbmF0dXJlLnI7XG4gIHZhciBzID0gc2lnbmF0dXJlLnM7XG4gIGlmIChyLmNtcG4oMSkgPCAwIHx8IHIuY21wKHRoaXMubikgPj0gMClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChzLmNtcG4oMSkgPCAwIHx8IHMuY21wKHRoaXMubikgPj0gMClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gVmFsaWRhdGUgc2lnbmF0dXJlXG4gIHZhciBzaW52ID0gcy5pbnZtKHRoaXMubik7XG4gIHZhciB1MSA9IHNpbnYubXVsKG1zZykudW1vZCh0aGlzLm4pO1xuICB2YXIgdTIgPSBzaW52Lm11bChyKS51bW9kKHRoaXMubik7XG5cbiAgaWYgKCF0aGlzLmN1cnZlLl9tYXh3ZWxsVHJpY2spIHtcbiAgICB2YXIgcCA9IHRoaXMuZy5tdWxBZGQodTEsIGtleS5nZXRQdWJsaWMoKSwgdTIpO1xuICAgIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiBwLmdldFgoKS51bW9kKHRoaXMubikuY21wKHIpID09PSAwO1xuICB9XG5cbiAgLy8gTk9URTogR3JlZyBNYXh3ZWxsJ3MgdHJpY2ssIGluc3BpcmVkIGJ5OlxuICAvLyBodHRwczovL2dpdC5pby92YWQzS1xuXG4gIHZhciBwID0gdGhpcy5nLmptdWxBZGQodTEsIGtleS5nZXRQdWJsaWMoKSwgdTIpO1xuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIENvbXBhcmUgYHAueGAgb2YgSmFjb2JpYW4gcG9pbnQgd2l0aCBgcmAsXG4gIC8vIHRoaXMgd2lsbCBkbyBgcC54ID09IHIgKiBwLnpeMmAgaW5zdGVhZCBvZiBtdWx0aXBseWluZyBgcC54YCBieSB0aGVcbiAgLy8gaW52ZXJzZSBvZiBgcC56XjJgXG4gIHJldHVybiBwLmVxWFRvUChyKTtcbn07XG5cbkVDLnByb3RvdHlwZS5yZWNvdmVyUHViS2V5ID0gZnVuY3Rpb24obXNnLCBzaWduYXR1cmUsIGosIGVuYykge1xuICBhc3NlcnQoKDMgJiBqKSA9PT0gaiwgJ1RoZSByZWNvdmVyeSBwYXJhbSBpcyBtb3JlIHRoYW4gdHdvIGJpdHMnKTtcbiAgc2lnbmF0dXJlID0gbmV3IFNpZ25hdHVyZShzaWduYXR1cmUsIGVuYyk7XG5cbiAgdmFyIG4gPSB0aGlzLm47XG4gIHZhciBlID0gbmV3IEJOKG1zZyk7XG4gIHZhciByID0gc2lnbmF0dXJlLnI7XG4gIHZhciBzID0gc2lnbmF0dXJlLnM7XG5cbiAgLy8gQSBzZXQgTFNCIHNpZ25pZmllcyB0aGF0IHRoZSB5LWNvb3JkaW5hdGUgaXMgb2RkXG4gIHZhciBpc1lPZGQgPSBqICYgMTtcbiAgdmFyIGlzU2Vjb25kS2V5ID0gaiA+PiAxO1xuICBpZiAoci5jbXAodGhpcy5jdXJ2ZS5wLnVtb2QodGhpcy5jdXJ2ZS5uKSkgPj0gMCAmJiBpc1NlY29uZEtleSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHNlbmNvbmQga2V5IGNhbmRpbmF0ZScpO1xuXG4gIC8vIDEuMS4gTGV0IHggPSByICsgam4uXG4gIGlmIChpc1NlY29uZEtleSlcbiAgICByID0gdGhpcy5jdXJ2ZS5wb2ludEZyb21YKHIuYWRkKHRoaXMuY3VydmUubiksIGlzWU9kZCk7XG4gIGVsc2VcbiAgICByID0gdGhpcy5jdXJ2ZS5wb2ludEZyb21YKHIsIGlzWU9kZCk7XG5cbiAgdmFyIHJJbnYgPSBzaWduYXR1cmUuci5pbnZtKG4pO1xuICB2YXIgczEgPSBuLnN1YihlKS5tdWwockludikudW1vZChuKTtcbiAgdmFyIHMyID0gcy5tdWwockludikudW1vZChuKTtcblxuICAvLyAxLjYuMSBDb21wdXRlIFEgPSByXi0xIChzUiAtICBlRylcbiAgLy8gICAgICAgICAgICAgICBRID0gcl4tMSAoc1IgKyAtZUcpXG4gIHJldHVybiB0aGlzLmcubXVsQWRkKHMxLCByLCBzMik7XG59O1xuXG5FQy5wcm90b3R5cGUuZ2V0S2V5UmVjb3ZlcnlQYXJhbSA9IGZ1bmN0aW9uKGUsIHNpZ25hdHVyZSwgUSwgZW5jKSB7XG4gIHNpZ25hdHVyZSA9IG5ldyBTaWduYXR1cmUoc2lnbmF0dXJlLCBlbmMpO1xuICBpZiAoc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW0gIT09IG51bGwpXG4gICAgcmV0dXJuIHNpZ25hdHVyZS5yZWNvdmVyeVBhcmFtO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgdmFyIFFwcmltZTtcbiAgICB0cnkge1xuICAgICAgUXByaW1lID0gdGhpcy5yZWNvdmVyUHViS2V5KGUsIHNpZ25hdHVyZSwgaSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKFFwcmltZS5lcShRKSlcbiAgICAgIHJldHVybiBpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgdmFsaWQgcmVjb3ZlcnkgZmFjdG9yJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gS2V5UGFpcihlYywgb3B0aW9ucykge1xuICB0aGlzLmVjID0gZWM7XG4gIHRoaXMucHJpdiA9IG51bGw7XG4gIHRoaXMucHViID0gbnVsbDtcblxuICAvLyBLZXlQYWlyKGVjLCB7IHByaXY6IC4uLiwgcHViOiAuLi4gfSlcbiAgaWYgKG9wdGlvbnMucHJpdilcbiAgICB0aGlzLl9pbXBvcnRQcml2YXRlKG9wdGlvbnMucHJpdiwgb3B0aW9ucy5wcml2RW5jKTtcbiAgaWYgKG9wdGlvbnMucHViKVxuICAgIHRoaXMuX2ltcG9ydFB1YmxpYyhvcHRpb25zLnB1Yiwgb3B0aW9ucy5wdWJFbmMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBLZXlQYWlyO1xuXG5LZXlQYWlyLmZyb21QdWJsaWMgPSBmdW5jdGlvbiBmcm9tUHVibGljKGVjLCBwdWIsIGVuYykge1xuICBpZiAocHViIGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICByZXR1cm4gcHViO1xuXG4gIHJldHVybiBuZXcgS2V5UGFpcihlYywge1xuICAgIHB1YjogcHViLFxuICAgIHB1YkVuYzogZW5jXG4gIH0pO1xufTtcblxuS2V5UGFpci5mcm9tUHJpdmF0ZSA9IGZ1bmN0aW9uIGZyb21Qcml2YXRlKGVjLCBwcml2LCBlbmMpIHtcbiAgaWYgKHByaXYgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBwcml2O1xuXG4gIHJldHVybiBuZXcgS2V5UGFpcihlYywge1xuICAgIHByaXY6IHByaXYsXG4gICAgcHJpdkVuYzogZW5jXG4gIH0pO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgdmFyIHB1YiA9IHRoaXMuZ2V0UHVibGljKCk7XG5cbiAgaWYgKHB1Yi5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnSW52YWxpZCBwdWJsaWMga2V5JyB9O1xuICBpZiAoIXB1Yi52YWxpZGF0ZSgpKVxuICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ1B1YmxpYyBrZXkgaXMgbm90IGEgcG9pbnQnIH07XG4gIGlmICghcHViLm11bCh0aGlzLmVjLmN1cnZlLm4pLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdQdWJsaWMga2V5ICogTiAhPSBPJyB9O1xuXG4gIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgcmVhc29uOiBudWxsIH07XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQdWJsaWMgPSBmdW5jdGlvbiBnZXRQdWJsaWMoY29tcGFjdCwgZW5jKSB7XG4gIC8vIGNvbXBhY3QgaXMgb3B0aW9uYWwgYXJndW1lbnRcbiAgaWYgKHR5cGVvZiBjb21wYWN0ID09PSAnc3RyaW5nJykge1xuICAgIGVuYyA9IGNvbXBhY3Q7XG4gICAgY29tcGFjdCA9IG51bGw7XG4gIH1cblxuICBpZiAoIXRoaXMucHViKVxuICAgIHRoaXMucHViID0gdGhpcy5lYy5nLm11bCh0aGlzLnByaXYpO1xuXG4gIGlmICghZW5jKVxuICAgIHJldHVybiB0aGlzLnB1YjtcblxuICByZXR1cm4gdGhpcy5wdWIuZW5jb2RlKGVuYywgY29tcGFjdCk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQcml2YXRlID0gZnVuY3Rpb24gZ2V0UHJpdmF0ZShlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHRoaXMucHJpdi50b1N0cmluZygxNiwgMik7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5wcml2O1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFByaXZhdGUgPSBmdW5jdGlvbiBfaW1wb3J0UHJpdmF0ZShrZXksIGVuYykge1xuICB0aGlzLnByaXYgPSBuZXcgQk4oa2V5LCBlbmMgfHwgMTYpO1xuXG4gIC8vIEVuc3VyZSB0aGF0IHRoZSBwcml2IHdvbid0IGJlIGJpZ2dlciB0aGFuIG4sIG90aGVyd2lzZSB3ZSBtYXkgZmFpbFxuICAvLyBpbiBmaXhlZCBtdWx0aXBsaWNhdGlvbiBtZXRob2RcbiAgdGhpcy5wcml2ID0gdGhpcy5wcml2LnVtb2QodGhpcy5lYy5jdXJ2ZS5uKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLl9pbXBvcnRQdWJsaWMgPSBmdW5jdGlvbiBfaW1wb3J0UHVibGljKGtleSwgZW5jKSB7XG4gIGlmIChrZXkueCB8fCBrZXkueSkge1xuICAgIC8vIE1vbnRnb21lcnkgcG9pbnRzIG9ubHkgaGF2ZSBhbiBgeGAgY29vcmRpbmF0ZS5cbiAgICAvLyBXZWllcnN0cmFzcy9FZHdhcmRzIHBvaW50cyBvbiB0aGUgb3RoZXIgaGFuZCBoYXZlIGJvdGggYHhgIGFuZFxuICAgIC8vIGB5YCBjb29yZGluYXRlcy5cbiAgICBpZiAodGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnbW9udCcpIHtcbiAgICAgIGFzc2VydChrZXkueCwgJ05lZWQgeCBjb29yZGluYXRlJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVjLmN1cnZlLnR5cGUgPT09ICdzaG9ydCcgfHxcbiAgICAgICAgICAgICAgIHRoaXMuZWMuY3VydmUudHlwZSA9PT0gJ2Vkd2FyZHMnKSB7XG4gICAgICBhc3NlcnQoa2V5LnggJiYga2V5LnksICdOZWVkIGJvdGggeCBhbmQgeSBjb29yZGluYXRlJyk7XG4gICAgfVxuICAgIHRoaXMucHViID0gdGhpcy5lYy5jdXJ2ZS5wb2ludChrZXkueCwga2V5LnkpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnB1YiA9IHRoaXMuZWMuY3VydmUuZGVjb2RlUG9pbnQoa2V5LCBlbmMpO1xufTtcblxuLy8gRUNESFxuS2V5UGFpci5wcm90b3R5cGUuZGVyaXZlID0gZnVuY3Rpb24gZGVyaXZlKHB1Yikge1xuICByZXR1cm4gcHViLm11bCh0aGlzLnByaXYpLmdldFgoKTtcbn07XG5cbi8vIEVDRFNBXG5LZXlQYWlyLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtc2csIGVuYywgb3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5lYy5zaWduKG1zZywgdGhpcywgZW5jLCBvcHRpb25zKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtc2csIHNpZ25hdHVyZSkge1xuICByZXR1cm4gdGhpcy5lYy52ZXJpZnkobXNnLCBzaWduYXR1cmUsIHRoaXMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIHJldHVybiAnPEtleSBwcml2OiAnICsgKHRoaXMucHJpdiAmJiB0aGlzLnByaXYudG9TdHJpbmcoMTYsIDIpKSArXG4gICAgICAgICAnIHB1YjogJyArICh0aGlzLnB1YiAmJiB0aGlzLnB1Yi5pbnNwZWN0KCkpICsgJyA+Jztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG5cbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgdXRpbHMgPSBlbGxpcHRpYy51dGlscztcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIFNpZ25hdHVyZShvcHRpb25zLCBlbmMpIHtcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBTaWduYXR1cmUpXG4gICAgcmV0dXJuIG9wdGlvbnM7XG5cbiAgaWYgKHRoaXMuX2ltcG9ydERFUihvcHRpb25zLCBlbmMpKVxuICAgIHJldHVybjtcblxuICBhc3NlcnQob3B0aW9ucy5yICYmIG9wdGlvbnMucywgJ1NpZ25hdHVyZSB3aXRob3V0IHIgb3IgcycpO1xuICB0aGlzLnIgPSBuZXcgQk4ob3B0aW9ucy5yLCAxNik7XG4gIHRoaXMucyA9IG5ldyBCTihvcHRpb25zLnMsIDE2KTtcbiAgaWYgKG9wdGlvbnMucmVjb3ZlcnlQYXJhbSA9PT0gdW5kZWZpbmVkKVxuICAgIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG51bGw7XG4gIGVsc2VcbiAgICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBvcHRpb25zLnJlY292ZXJ5UGFyYW07XG59XG5tb2R1bGUuZXhwb3J0cyA9IFNpZ25hdHVyZTtcblxuZnVuY3Rpb24gUG9zaXRpb24oKSB7XG4gIHRoaXMucGxhY2UgPSAwO1xufVxuXG5mdW5jdGlvbiBnZXRMZW5ndGgoYnVmLCBwKSB7XG4gIHZhciBpbml0aWFsID0gYnVmW3AucGxhY2UrK107XG4gIGlmICghKGluaXRpYWwgJiAweDgwKSkge1xuICAgIHJldHVybiBpbml0aWFsO1xuICB9XG4gIHZhciBvY3RldExlbiA9IGluaXRpYWwgJiAweGY7XG4gIHZhciB2YWwgPSAwO1xuICBmb3IgKHZhciBpID0gMCwgb2ZmID0gcC5wbGFjZTsgaSA8IG9jdGV0TGVuOyBpKyssIG9mZisrKSB7XG4gICAgdmFsIDw8PSA4O1xuICAgIHZhbCB8PSBidWZbb2ZmXTtcbiAgfVxuICBwLnBsYWNlID0gb2ZmO1xuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBybVBhZGRpbmcoYnVmKSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGggLSAxO1xuICB3aGlsZSAoIWJ1ZltpXSAmJiAhKGJ1ZltpICsgMV0gJiAweDgwKSAmJiBpIDwgbGVuKSB7XG4gICAgaSsrO1xuICB9XG4gIGlmIChpID09PSAwKSB7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuICByZXR1cm4gYnVmLnNsaWNlKGkpO1xufVxuXG5TaWduYXR1cmUucHJvdG90eXBlLl9pbXBvcnRERVIgPSBmdW5jdGlvbiBfaW1wb3J0REVSKGRhdGEsIGVuYykge1xuICBkYXRhID0gdXRpbHMudG9BcnJheShkYXRhLCBlbmMpO1xuICB2YXIgcCA9IG5ldyBQb3NpdGlvbigpO1xuICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDMwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gIGlmICgobGVuICsgcC5wbGFjZSkgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHJsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gIHZhciByID0gZGF0YS5zbGljZShwLnBsYWNlLCBybGVuICsgcC5wbGFjZSk7XG4gIHAucGxhY2UgKz0gcmxlbjtcbiAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgwMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgc2xlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcbiAgaWYgKGRhdGEubGVuZ3RoICE9PSBzbGVuICsgcC5wbGFjZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcyA9IGRhdGEuc2xpY2UocC5wbGFjZSwgc2xlbiArIHAucGxhY2UpO1xuICBpZiAoclswXSA9PT0gMCAmJiAoclsxXSAmIDB4ODApKSB7XG4gICAgciA9IHIuc2xpY2UoMSk7XG4gIH1cbiAgaWYgKHNbMF0gPT09IDAgJiYgKHNbMV0gJiAweDgwKSkge1xuICAgIHMgPSBzLnNsaWNlKDEpO1xuICB9XG5cbiAgdGhpcy5yID0gbmV3IEJOKHIpO1xuICB0aGlzLnMgPSBuZXcgQk4ocyk7XG4gIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG51bGw7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBjb25zdHJ1Y3RMZW5ndGgoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA8IDB4ODApIHtcbiAgICBhcnIucHVzaChsZW4pO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb2N0ZXRzID0gMSArIChNYXRoLmxvZyhsZW4pIC8gTWF0aC5MTjIgPj4+IDMpO1xuICBhcnIucHVzaChvY3RldHMgfCAweDgwKTtcbiAgd2hpbGUgKC0tb2N0ZXRzKSB7XG4gICAgYXJyLnB1c2goKGxlbiA+Pj4gKG9jdGV0cyA8PCAzKSkgJiAweGZmKTtcbiAgfVxuICBhcnIucHVzaChsZW4pO1xufVxuXG5TaWduYXR1cmUucHJvdG90eXBlLnRvREVSID0gZnVuY3Rpb24gdG9ERVIoZW5jKSB7XG4gIHZhciByID0gdGhpcy5yLnRvQXJyYXkoKTtcbiAgdmFyIHMgPSB0aGlzLnMudG9BcnJheSgpO1xuXG4gIC8vIFBhZCB2YWx1ZXNcbiAgaWYgKHJbMF0gJiAweDgwKVxuICAgIHIgPSBbIDAgXS5jb25jYXQocik7XG4gIC8vIFBhZCB2YWx1ZXNcbiAgaWYgKHNbMF0gJiAweDgwKVxuICAgIHMgPSBbIDAgXS5jb25jYXQocyk7XG5cbiAgciA9IHJtUGFkZGluZyhyKTtcbiAgcyA9IHJtUGFkZGluZyhzKTtcblxuICB3aGlsZSAoIXNbMF0gJiYgIShzWzFdICYgMHg4MCkpIHtcbiAgICBzID0gcy5zbGljZSgxKTtcbiAgfVxuICB2YXIgYXJyID0gWyAweDAyIF07XG4gIGNvbnN0cnVjdExlbmd0aChhcnIsIHIubGVuZ3RoKTtcbiAgYXJyID0gYXJyLmNvbmNhdChyKTtcbiAgYXJyLnB1c2goMHgwMik7XG4gIGNvbnN0cnVjdExlbmd0aChhcnIsIHMubGVuZ3RoKTtcbiAgdmFyIGJhY2tIYWxmID0gYXJyLmNvbmNhdChzKTtcbiAgdmFyIHJlcyA9IFsgMHgzMCBdO1xuICBjb25zdHJ1Y3RMZW5ndGgocmVzLCBiYWNrSGFsZi5sZW5ndGgpO1xuICByZXMgPSByZXMuY29uY2F0KGJhY2tIYWxmKTtcbiAgcmV0dXJuIHV0aWxzLmVuY29kZShyZXMsIGVuYyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJ2hhc2guanMnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgdXRpbHMgPSBlbGxpcHRpYy51dGlscztcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG52YXIgcGFyc2VCeXRlcyA9IHV0aWxzLnBhcnNlQnl0ZXM7XG52YXIgS2V5UGFpciA9IHJlcXVpcmUoJy4va2V5Jyk7XG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9zaWduYXR1cmUnKTtcblxuZnVuY3Rpb24gRUREU0EoY3VydmUpIHtcbiAgYXNzZXJ0KGN1cnZlID09PSAnZWQyNTUxOScsICdvbmx5IHRlc3RlZCB3aXRoIGVkMjU1MTkgc28gZmFyJyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVERFNBKSlcbiAgICByZXR1cm4gbmV3IEVERFNBKGN1cnZlKTtcblxuICB2YXIgY3VydmUgPSBlbGxpcHRpYy5jdXJ2ZXNbY3VydmVdLmN1cnZlO1xuICB0aGlzLmN1cnZlID0gY3VydmU7XG4gIHRoaXMuZyA9IGN1cnZlLmc7XG4gIHRoaXMuZy5wcmVjb21wdXRlKGN1cnZlLm4uYml0TGVuZ3RoKCkgKyAxKTtcblxuICB0aGlzLnBvaW50Q2xhc3MgPSBjdXJ2ZS5wb2ludCgpLmNvbnN0cnVjdG9yO1xuICB0aGlzLmVuY29kaW5nTGVuZ3RoID0gTWF0aC5jZWlsKGN1cnZlLm4uYml0TGVuZ3RoKCkgLyA4KTtcbiAgdGhpcy5oYXNoID0gaGFzaC5zaGE1MTI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRUREU0E7XG5cbi8qKlxuKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gbWVzc2FnZSAtIG1lc3NhZ2UgYnl0ZXNcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd8S2V5UGFpcn0gc2VjcmV0IC0gc2VjcmV0IGJ5dGVzIG9yIGEga2V5cGFpclxuKiBAcmV0dXJucyB7U2lnbmF0dXJlfSAtIHNpZ25hdHVyZVxuKi9cbkVERFNBLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtZXNzYWdlLCBzZWNyZXQpIHtcbiAgbWVzc2FnZSA9IHBhcnNlQnl0ZXMobWVzc2FnZSk7XG4gIHZhciBrZXkgPSB0aGlzLmtleUZyb21TZWNyZXQoc2VjcmV0KTtcbiAgdmFyIHIgPSB0aGlzLmhhc2hJbnQoa2V5Lm1lc3NhZ2VQcmVmaXgoKSwgbWVzc2FnZSk7XG4gIHZhciBSID0gdGhpcy5nLm11bChyKTtcbiAgdmFyIFJlbmNvZGVkID0gdGhpcy5lbmNvZGVQb2ludChSKTtcbiAgdmFyIHNfID0gdGhpcy5oYXNoSW50KFJlbmNvZGVkLCBrZXkucHViQnl0ZXMoKSwgbWVzc2FnZSlcbiAgICAgICAgICAgICAgIC5tdWwoa2V5LnByaXYoKSk7XG4gIHZhciBTID0gci5hZGQoc18pLnVtb2QodGhpcy5jdXJ2ZS5uKTtcbiAgcmV0dXJuIHRoaXMubWFrZVNpZ25hdHVyZSh7IFI6IFIsIFM6IFMsIFJlbmNvZGVkOiBSZW5jb2RlZCB9KTtcbn07XG5cbi8qKlxuKiBAcGFyYW0ge0FycmF5fSBtZXNzYWdlIC0gbWVzc2FnZSBieXRlc1xuKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xTaWduYXR1cmV9IHNpZyAtIHNpZyBieXRlc1xuKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xQb2ludHxLZXlQYWlyfSBwdWIgLSBwdWJsaWMga2V5XG4qIEByZXR1cm5zIHtCb29sZWFufSAtIHRydWUgaWYgcHVibGljIGtleSBtYXRjaGVzIHNpZyBvZiBtZXNzYWdlXG4qL1xuRUREU0EucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlLCBzaWcsIHB1Yikge1xuICBtZXNzYWdlID0gcGFyc2VCeXRlcyhtZXNzYWdlKTtcbiAgc2lnID0gdGhpcy5tYWtlU2lnbmF0dXJlKHNpZyk7XG4gIHZhciBrZXkgPSB0aGlzLmtleUZyb21QdWJsaWMocHViKTtcbiAgdmFyIGggPSB0aGlzLmhhc2hJbnQoc2lnLlJlbmNvZGVkKCksIGtleS5wdWJCeXRlcygpLCBtZXNzYWdlKTtcbiAgdmFyIFNHID0gdGhpcy5nLm11bChzaWcuUygpKTtcbiAgdmFyIFJwbHVzQWggPSBzaWcuUigpLmFkZChrZXkucHViKCkubXVsKGgpKTtcbiAgcmV0dXJuIFJwbHVzQWguZXEoU0cpO1xufTtcblxuRUREU0EucHJvdG90eXBlLmhhc2hJbnQgPSBmdW5jdGlvbiBoYXNoSW50KCkge1xuICB2YXIgaGFzaCA9IHRoaXMuaGFzaCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICBoYXNoLnVwZGF0ZShhcmd1bWVudHNbaV0pO1xuICByZXR1cm4gdXRpbHMuaW50RnJvbUxFKGhhc2guZGlnZXN0KCkpLnVtb2QodGhpcy5jdXJ2ZS5uKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5rZXlGcm9tUHVibGljID0gZnVuY3Rpb24ga2V5RnJvbVB1YmxpYyhwdWIpIHtcbiAgcmV0dXJuIEtleVBhaXIuZnJvbVB1YmxpYyh0aGlzLCBwdWIpO1xufTtcblxuRUREU0EucHJvdG90eXBlLmtleUZyb21TZWNyZXQgPSBmdW5jdGlvbiBrZXlGcm9tU2VjcmV0KHNlY3JldCkge1xuICByZXR1cm4gS2V5UGFpci5mcm9tU2VjcmV0KHRoaXMsIHNlY3JldCk7XG59O1xuXG5FRERTQS5wcm90b3R5cGUubWFrZVNpZ25hdHVyZSA9IGZ1bmN0aW9uIG1ha2VTaWduYXR1cmUoc2lnKSB7XG4gIGlmIChzaWcgaW5zdGFuY2VvZiBTaWduYXR1cmUpXG4gICAgcmV0dXJuIHNpZztcbiAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcywgc2lnKTtcbn07XG5cbi8qKlxuKiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1qb3NlZnNzb24tZWRkc2EtZWQyNTUxOS0wMyNzZWN0aW9uLTUuMlxuKlxuKiBFRERTQSBkZWZpbmVzIG1ldGhvZHMgZm9yIGVuY29kaW5nIGFuZCBkZWNvZGluZyBwb2ludHMgYW5kIGludGVnZXJzLiBUaGVzZSBhcmVcbiogaGVscGVyIGNvbnZlbmllbmNlIG1ldGhvZHMsIHRoYXQgcGFzcyBhbG9uZyB0byB1dGlsaXR5IGZ1bmN0aW9ucyBpbXBsaWVkXG4qIHBhcmFtZXRlcnMuXG4qXG4qL1xuRUREU0EucHJvdG90eXBlLmVuY29kZVBvaW50ID0gZnVuY3Rpb24gZW5jb2RlUG9pbnQocG9pbnQpIHtcbiAgdmFyIGVuYyA9IHBvaW50LmdldFkoKS50b0FycmF5KCdsZScsIHRoaXMuZW5jb2RpbmdMZW5ndGgpO1xuICBlbmNbdGhpcy5lbmNvZGluZ0xlbmd0aCAtIDFdIHw9IHBvaW50LmdldFgoKS5pc09kZCgpID8gMHg4MCA6IDA7XG4gIHJldHVybiBlbmM7XG59O1xuXG5FRERTQS5wcm90b3R5cGUuZGVjb2RlUG9pbnQgPSBmdW5jdGlvbiBkZWNvZGVQb2ludChieXRlcykge1xuICBieXRlcyA9IHV0aWxzLnBhcnNlQnl0ZXMoYnl0ZXMpO1xuXG4gIHZhciBsYXN0SXggPSBieXRlcy5sZW5ndGggLSAxO1xuICB2YXIgbm9ybWVkID0gYnl0ZXMuc2xpY2UoMCwgbGFzdEl4KS5jb25jYXQoYnl0ZXNbbGFzdEl4XSAmIH4weDgwKTtcbiAgdmFyIHhJc09kZCA9IChieXRlc1tsYXN0SXhdICYgMHg4MCkgIT09IDA7XG5cbiAgdmFyIHkgPSB1dGlscy5pbnRGcm9tTEUobm9ybWVkKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnRGcm9tWSh5LCB4SXNPZGQpO1xufTtcblxuRUREU0EucHJvdG90eXBlLmVuY29kZUludCA9IGZ1bmN0aW9uIGVuY29kZUludChudW0pIHtcbiAgcmV0dXJuIG51bS50b0FycmF5KCdsZScsIHRoaXMuZW5jb2RpbmdMZW5ndGgpO1xufTtcblxuRUREU0EucHJvdG90eXBlLmRlY29kZUludCA9IGZ1bmN0aW9uIGRlY29kZUludChieXRlcykge1xuICByZXR1cm4gdXRpbHMuaW50RnJvbUxFKGJ5dGVzKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5pc1BvaW50ID0gZnVuY3Rpb24gaXNQb2ludCh2YWwpIHtcbiAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIHRoaXMucG9pbnRDbGFzcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgdXRpbHMgPSBlbGxpcHRpYy51dGlscztcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG52YXIgcGFyc2VCeXRlcyA9IHV0aWxzLnBhcnNlQnl0ZXM7XG52YXIgY2FjaGVkUHJvcGVydHkgPSB1dGlscy5jYWNoZWRQcm9wZXJ0eTtcblxuLyoqXG4qIEBwYXJhbSB7RUREU0F9IGVkZHNhIC0gaW5zdGFuY2VcbiogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIHB1YmxpYy9wcml2YXRlIGtleSBwYXJhbWV0ZXJzXG4qXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZT59IFtwYXJhbXMuc2VjcmV0XSAtIHNlY3JldCBzZWVkIGJ5dGVzXG4qIEBwYXJhbSB7UG9pbnR9IFtwYXJhbXMucHViXSAtIHB1YmxpYyBrZXkgcG9pbnQgKGFrYSBgQWAgaW4gZWRkc2EgdGVybXMpXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZT59IFtwYXJhbXMucHViXSAtIHB1YmxpYyBrZXkgcG9pbnQgZW5jb2RlZCBhcyBieXRlc1xuKlxuKi9cbmZ1bmN0aW9uIEtleVBhaXIoZWRkc2EsIHBhcmFtcykge1xuICB0aGlzLmVkZHNhID0gZWRkc2E7XG4gIHRoaXMuX3NlY3JldCA9IHBhcnNlQnl0ZXMocGFyYW1zLnNlY3JldCk7XG4gIGlmIChlZGRzYS5pc1BvaW50KHBhcmFtcy5wdWIpKVxuICAgIHRoaXMuX3B1YiA9IHBhcmFtcy5wdWI7XG4gIGVsc2VcbiAgICB0aGlzLl9wdWJCeXRlcyA9IHBhcnNlQnl0ZXMocGFyYW1zLnB1Yik7XG59XG5cbktleVBhaXIuZnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGZyb21QdWJsaWMoZWRkc2EsIHB1Yikge1xuICBpZiAocHViIGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICByZXR1cm4gcHViO1xuICByZXR1cm4gbmV3IEtleVBhaXIoZWRkc2EsIHsgcHViOiBwdWIgfSk7XG59O1xuXG5LZXlQYWlyLmZyb21TZWNyZXQgPSBmdW5jdGlvbiBmcm9tU2VjcmV0KGVkZHNhLCBzZWNyZXQpIHtcbiAgaWYgKHNlY3JldCBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgcmV0dXJuIHNlY3JldDtcbiAgcmV0dXJuIG5ldyBLZXlQYWlyKGVkZHNhLCB7IHNlY3JldDogc2VjcmV0IH0pO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuc2VjcmV0ID0gZnVuY3Rpb24gc2VjcmV0KCkge1xuICByZXR1cm4gdGhpcy5fc2VjcmV0O1xufTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ3B1YkJ5dGVzJywgZnVuY3Rpb24gcHViQnl0ZXMoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmVuY29kZVBvaW50KHRoaXMucHViKCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KEtleVBhaXIsICdwdWInLCBmdW5jdGlvbiBwdWIoKSB7XG4gIGlmICh0aGlzLl9wdWJCeXRlcylcbiAgICByZXR1cm4gdGhpcy5lZGRzYS5kZWNvZGVQb2ludCh0aGlzLl9wdWJCeXRlcyk7XG4gIHJldHVybiB0aGlzLmVkZHNhLmcubXVsKHRoaXMucHJpdigpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAncHJpdkJ5dGVzJywgZnVuY3Rpb24gcHJpdkJ5dGVzKCkge1xuICB2YXIgZWRkc2EgPSB0aGlzLmVkZHNhO1xuICB2YXIgaGFzaCA9IHRoaXMuaGFzaCgpO1xuICB2YXIgbGFzdEl4ID0gZWRkc2EuZW5jb2RpbmdMZW5ndGggLSAxO1xuXG4gIHZhciBhID0gaGFzaC5zbGljZSgwLCBlZGRzYS5lbmNvZGluZ0xlbmd0aCk7XG4gIGFbMF0gJj0gMjQ4O1xuICBhW2xhc3RJeF0gJj0gMTI3O1xuICBhW2xhc3RJeF0gfD0gNjQ7XG5cbiAgcmV0dXJuIGE7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ3ByaXYnLCBmdW5jdGlvbiBwcml2KCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5kZWNvZGVJbnQodGhpcy5wcml2Qnl0ZXMoKSk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ2hhc2gnLCBmdW5jdGlvbiBoYXNoKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5oYXNoKCkudXBkYXRlKHRoaXMuc2VjcmV0KCkpLmRpZ2VzdCgpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KEtleVBhaXIsICdtZXNzYWdlUHJlZml4JywgZnVuY3Rpb24gbWVzc2FnZVByZWZpeCgpIHtcbiAgcmV0dXJuIHRoaXMuaGFzaCgpLnNsaWNlKHRoaXMuZWRkc2EuZW5jb2RpbmdMZW5ndGgpO1xufSk7XG5cbktleVBhaXIucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1lc3NhZ2UpIHtcbiAgYXNzZXJ0KHRoaXMuX3NlY3JldCwgJ0tleVBhaXIgY2FuIG9ubHkgdmVyaWZ5Jyk7XG4gIHJldHVybiB0aGlzLmVkZHNhLnNpZ24obWVzc2FnZSwgdGhpcyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSwgc2lnKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLnZlcmlmeShtZXNzYWdlLCBzaWcsIHRoaXMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuZ2V0U2VjcmV0ID0gZnVuY3Rpb24gZ2V0U2VjcmV0KGVuYykge1xuICBhc3NlcnQodGhpcy5fc2VjcmV0LCAnS2V5UGFpciBpcyBwdWJsaWMgb25seScpO1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHRoaXMuc2VjcmV0KCksIGVuYyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQdWJsaWMgPSBmdW5jdGlvbiBnZXRQdWJsaWMoZW5jKSB7XG4gIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy5wdWJCeXRlcygpLCBlbmMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlQYWlyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcbnZhciBjYWNoZWRQcm9wZXJ0eSA9IHV0aWxzLmNhY2hlZFByb3BlcnR5O1xudmFyIHBhcnNlQnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzO1xuXG4vKipcbiogQHBhcmFtIHtFRERTQX0gZWRkc2EgLSBlZGRzYSBpbnN0YW5jZVxuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPnxPYmplY3R9IHNpZyAtXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZXM+fFBvaW50fSBbc2lnLlJdIC0gUiBwb2ludCBhcyBQb2ludCBvciBieXRlc1xuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPnxibn0gW3NpZy5TXSAtIFMgc2NhbGFyIGFzIGJuIG9yIGJ5dGVzXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZXM+fSBbc2lnLlJlbmNvZGVkXSAtIFIgcG9pbnQgZW5jb2RlZFxuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPn0gW3NpZy5TZW5jb2RlZF0gLSBTIHNjYWxhciBlbmNvZGVkXG4qL1xuZnVuY3Rpb24gU2lnbmF0dXJlKGVkZHNhLCBzaWcpIHtcbiAgdGhpcy5lZGRzYSA9IGVkZHNhO1xuXG4gIGlmICh0eXBlb2Ygc2lnICE9PSAnb2JqZWN0JylcbiAgICBzaWcgPSBwYXJzZUJ5dGVzKHNpZyk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc2lnKSkge1xuICAgIHNpZyA9IHtcbiAgICAgIFI6IHNpZy5zbGljZSgwLCBlZGRzYS5lbmNvZGluZ0xlbmd0aCksXG4gICAgICBTOiBzaWcuc2xpY2UoZWRkc2EuZW5jb2RpbmdMZW5ndGgpXG4gICAgfTtcbiAgfVxuXG4gIGFzc2VydChzaWcuUiAmJiBzaWcuUywgJ1NpZ25hdHVyZSB3aXRob3V0IFIgb3IgUycpO1xuXG4gIGlmIChlZGRzYS5pc1BvaW50KHNpZy5SKSlcbiAgICB0aGlzLl9SID0gc2lnLlI7XG4gIGlmIChzaWcuUyBpbnN0YW5jZW9mIEJOKVxuICAgIHRoaXMuX1MgPSBzaWcuUztcblxuICB0aGlzLl9SZW5jb2RlZCA9IEFycmF5LmlzQXJyYXkoc2lnLlIpID8gc2lnLlIgOiBzaWcuUmVuY29kZWQ7XG4gIHRoaXMuX1NlbmNvZGVkID0gQXJyYXkuaXNBcnJheShzaWcuUykgPyBzaWcuUyA6IHNpZy5TZW5jb2RlZDtcbn1cblxuY2FjaGVkUHJvcGVydHkoU2lnbmF0dXJlLCAnUycsIGZ1bmN0aW9uIFMoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmRlY29kZUludCh0aGlzLlNlbmNvZGVkKCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KFNpZ25hdHVyZSwgJ1InLCBmdW5jdGlvbiBSKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5kZWNvZGVQb2ludCh0aGlzLlJlbmNvZGVkKCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KFNpZ25hdHVyZSwgJ1JlbmNvZGVkJywgZnVuY3Rpb24gUmVuY29kZWQoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmVuY29kZVBvaW50KHRoaXMuUigpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShTaWduYXR1cmUsICdTZW5jb2RlZCcsIGZ1bmN0aW9uIFNlbmNvZGVkKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5lbmNvZGVJbnQodGhpcy5TKCkpO1xufSk7XG5cblNpZ25hdHVyZS5wcm90b3R5cGUudG9CeXRlcyA9IGZ1bmN0aW9uIHRvQnl0ZXMoKSB7XG4gIHJldHVybiB0aGlzLlJlbmNvZGVkKCkuY29uY2F0KHRoaXMuU2VuY29kZWQoKSk7XG59O1xuXG5TaWduYXR1cmUucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24gdG9IZXgoKSB7XG4gIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy50b0J5dGVzKCksICdoZXgnKS50b1VwcGVyQ2FzZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaWduYXR1cmU7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZG91Ymxlczoge1xuICAgIHN0ZXA6IDQsXG4gICAgcG9pbnRzOiBbXG4gICAgICBbXG4gICAgICAgICdlNjBmY2U5M2I1OWU5ZWM1MzAxMWFhYmMyMWMyM2U5N2IyYTMxMzY5Yjg3YTVhZTljNDRlZTg5ZTJhNmRlYzBhJyxcbiAgICAgICAgJ2Y3ZTM1MDczOTllNTk1OTI5ZGI5OWYzNGY1NzkzNzEwMTI5Njg5MWU0NGQyM2YwYmUxZjMyY2NlNjk2MTY4MjEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODI4MjI2MzIxMmM2MDlkOWVhMmE2ZTNlMTcyZGUyMzhkOGMzOWNhYmQ1YWMxY2ExMDY0NmUyM2ZkNWY1MTUwOCcsXG4gICAgICAgICcxMWY4YTgwOTg1NTdkZmU0NWU4MjU2ZTgzMGI2MGFjZTYyZDYxM2FjMmY3YjE3YmVkMzFiNmVhZmY2ZTI2Y2FmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE3NWUxNTlmNzI4Yjg2NWE3MmY5OWNjNmM2ZmM4NDZkZTBiOTM4MzNmZDIyMjJlZDczZmNlNWI1NTFlNWI3MzknLFxuICAgICAgICAnZDM1MDZlMGQ5ZTNjNzllYmE0ZWY5N2E1MWZmNzFmNWVhY2I1OTU1YWRkMjQzNDVjNmVmYTZmZmVlOWZlZDY5NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNjNkOTBkNDQ3YjAwYzljOTljZWFjMDViNjI2MmVlMDUzNDQxYzdlNTU1NTJmZmU1MjZiYWQ4ZjgzZmY0NjQwJyxcbiAgICAgICAgJzRlMjczYWRmYzczMjIyMTk1M2I0NDUzOTdmMzM2MzE0NWI5YTg5MDA4MTk5ZWNiNjIwMDNjN2YzYmVlOWRlOSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4YjRiNWYxNjVkZjNjMmJlOGM2MjQ0YjViNzQ1NjM4ODQzZTRhNzgxYTE1YmNkMWI2OWY3OWE1NWRmZmRmODBjJyxcbiAgICAgICAgJzRhYWQwYTZmNjhkMzA4YjRiM2ZiZDc4MTNhYjBkYTA0ZjllMzM2NTQ2MTYyZWU1NmIzZWZmMGM2NWZkNGZkMzYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzIzY2JhYTZlNWRiOTk2ZDZiZjc3MWMwMGJkNTQ4YzdiNzAwZGJmZmE2YzBlNzdiY2I2MTE1OTI1MjMyZmNkYScsXG4gICAgICAgICc5NmU4NjdiNTU5NWNjNDk4YTkyMTEzNzQ4ODgyNGQ2ZTI2NjBhMDY1Mzc3OTQ5NDgwMWRjMDY5ZDllYjM5ZjVmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VlYmZhNGQ0OTNiZWJmOThiYTVmZWVjODEyYzJkM2I1MDk0Nzk2MTIzN2E5MTk4MzlhNTMzZWNhMGU3ZGQ3ZmEnLFxuICAgICAgICAnNWQ5YThjYTM5NzBlZjBmMjY5ZWU3ZWRhZjE3ODA4OWQ5YWU0Y2RjM2E3MTFmNzEyZGRmZDRmZGFlMWRlODk5OSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxMDBmNDRkYTY5NmU3MTY3Mjc5MWQwYTA5YjdiZGU0NTlmMTIxNWEyOWIzYzAzYmZlZmQ3ODM1YjM5YTQ4ZGIwJyxcbiAgICAgICAgJ2NkZDllMTMxOTJhMDBiNzcyZWM4ZjMzMDBjMDkwNjY2YjdmZjRhMThmZjUxOTVhYzBmYmQ1Y2Q2MmJjNjVhMDknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTEwMzFiZTI2MmM3ZWQxYjFkYzkyMjdhNGEwNGMwMTdhNzdmOGQ0NDY0ZjNiMzg1MmM4YWNkZTZlNTM0ZmQyZCcsXG4gICAgICAgICc5ZDcwNjE5Mjg5NDA0MDVlNmJiNmE0MTc2NTk3NTM1YWYyOTJkZDQxOWUxY2VkNzlhNDRmMThmMjk0NTZhMDBkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZlZWE2Y2FlNDZkNTViNTMwYWMyODM5ZjE0M2JkN2VjNWNmOGIyNjZhNDFkNmFmNTJkNWU2ODhkOTA5NDY5NmQnLFxuICAgICAgICAnZTU3YzZiNmM5N2RjZTFiYWIwNmU0ZTEyYmYzZWNkNWM5ODFjODk1N2NjNDE0NDJkMzE1NWRlYmYxODA5MDA4OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkYTY3YTkxZDkxMDQ5Y2RjYjM2N2JlNGJlNmZmY2EzY2ZlZWQ2NTdkODA4NTgzZGUzM2ZhOTc4YmMxZWM2Y2IxJyxcbiAgICAgICAgJzliYWNhYTM1NDgxNjQyYmM0MWY0NjNmN2VjOTc4MGU1ZGVjN2FkYzUwOGY3NDBhMTdlOWVhOGUyN2E2OGJlMWQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTM5MDRmYWEwYjMzNGNkZGE2ZTAwMDkzNWVmMjIxNTFlYzA4ZDBmN2JiMTEwNjlmNTc1NDVjY2MxYTM3YjdjMCcsXG4gICAgICAgICc1YmMwODdkMGJjODAxMDZkODhjOWVjY2FjMjBkM2MxYzEzOTk5OTgxZTE0NDM0Njk5ZGNiMDk2YjAyMjc3MWM4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhlN2JjZDBiZDM1OTgzYTc3MTljY2E3NzY0Y2E5MDY3NzliNTNhMDQzYTliOGJjYWVmZjk1OWY0M2FkODYwNDcnLFxuICAgICAgICAnMTBiNzc3MGIyYTNkYTRiMzk0MDMxMDQyMGNhOTUxNDU3OWU4OGUyZTQ3ZmQ2OGIzZWExMDA0N2U4NDYwMzcyYSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczODVlZWQzNGMxY2RmZjIxZTZkMDgxODY4OWI4MWJkZTcxYTdmNGYxODM5N2U2NjkwYTg0MWUxNTk5YzQzODYyJyxcbiAgICAgICAgJzI4M2JlYmMzZThlYTIzZjU2NzAxZGUxOWU5ZWJmNDU3NmIzMDRlZWMyMDg2ZGM4Y2MwNDU4ZmU1NTQyZTU0NTMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNmY5ZDliODAzZWNmMTkxNjM3YzczYTQ0MTNkZmExODBmZGRmODRhNTk0N2ZiYzljNjA2ZWQ4NmMzZmFjM2E3JyxcbiAgICAgICAgJzdjODBjNjhlNjAzMDU5YmE2OWI4ZTJhMzBlNDVjNGQ0N2VhNGRkMmY1YzI4MTAwMmQ4Njg5MDYwM2E4NDIxNjAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzMyMmQ0MDEyNDNjNGUyNTgyYTIxNDdjMTA0ZDZlY2JmNzc0ZDE2M2RiMGY1ZTUzMTNiN2UwZTc0MmQwZTZiZCcsXG4gICAgICAgICc1NmU3MDc5N2U5NjY0ZWY1YmZiMDE5YmM0ZGRhZjliNzI4MDVmNjNlYTI4NzNhZjYyNGYzYTJlOTZjMjhiMmEwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg1NjcyYzdkMmRlMGI3ZGEyYmQxNzcwZDg5NjY1ODY4NzQxYjNmOWFmNzY0MzM5NzcyMWQ3NGQyODEzNGFiODMnLFxuICAgICAgICAnN2M0ODFiOWI1YjQzYjJlYjYzNzQwNDliZmE2MmMyZTVlNzdmMTdmY2M1Mjk4ZjQ0YzhlMzA5NGY3OTAzMTNhNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5NDhiZjgwOWIxOTg4YTQ2YjA2YzlmMTkxOTQxM2IxMGY5MjI2YzYwZjY2ODgzMmZmZDk1OWFmNjBjODJhMGEnLFxuICAgICAgICAnNTNhNTYyODU2ZGNiNjY0NmRjNmI3NGM1ZDFjMzQxOGM2ZDRkZmYwOGM5N2NkMmJlZDRjYjdmODhkOGM4ZTU4OSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2MjYwY2U3ZjQ2MTgwMWMzNGYwNjdjZTBmMDI4NzNhOGYxYjBlNDRkZmM2OTc1MmFjY2VjZDgxOWYzOGZkOGU4JyxcbiAgICAgICAgJ2JjMmRhODJiNmZhNWI1NzFhN2YwOTA0OTc3NmExZWY3ZWNkMjkyMjM4MDUxYzE5OGMxYTg0ZTk1YjJiNGFlMTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTUwMzdkZTBhZmMxZDhkNDNkODM0ODQxNGJiZjQxMDMwNDNlYzhmNTc1YmZkYzQzMjk1M2NjOGQyMDM3ZmEyZCcsXG4gICAgICAgICc0NTcxNTM0YmFhOTRkM2I1ZjlmOThkMDlmYjk5MGJkZGJkNWY1YjAzZWM0ODFmMTBlMGU1ZGM4NDFkNzU1YmRhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UwNjM3MmIwZjRhMjA3YWRmNWVhOTA1ZThmMTc3MWI0ZTdlOGRiZDFjNmE2YzViNzI1ODY2YTBhZTRmY2U3MjUnLFxuICAgICAgICAnN2E5MDg5NzRiY2UxOGNmZTEyYTI3YmIyYWQ1YTQ4OGNkNzQ4NGE3Nzg3MTA0ODcwYjI3MDM0Zjk0ZWVlMzFkZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyMTNjN2E3MTVjZDVkNDUzNThkMGJiZjlkYzBjZTAyMjA0YjEwYmRkZTJhM2Y1ODU0MGFkNjkwOGQwNTU5NzU0JyxcbiAgICAgICAgJzRiNmRhZDBiNWFlNDYyNTA3MDEzYWQwNjI0NWJhMTkwYmI0ODUwZjVmMzZhN2VlZGRmZjJjMjc1MzRiNDU4ZjInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNGU3YzI3MmE3YWY0YjM0ZThkYmI5MzUyYTU0MTlhODdlMjgzOGM3MGFkYzYyY2RkZjBjYzNhM2IwOGZiZDUzYycsXG4gICAgICAgICcxNzc0OWM3NjZjOWQwYjE4ZTE2ZmQwOWY2ZGVmNjgxYjUzMGI5NjE0YmZmN2RkMzNlMGIzOTQxODE3ZGNhYWU2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZlYTc0ZTNkYmU3NzhiMWIxMGYyMzhhZDYxNjg2YWE1Yzc2ZTNkYjJiZTQzMDU3NjMyNDI3ZTI4NDBmYjI3YjYnLFxuICAgICAgICAnNmUwNTY4ZGI5YjBiMTMyOTdjZjY3NGRlY2NiNmFmOTMxMjZiNTk2Yjk3M2Y3Yjc3NzAxZDNkYjdmMjNjYjk2ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NmU2NDExM2Y2NzdjZjBlMTBhMjU3MGQ1OTk5NjhkMzE1NDRlMTc5Yjc2MDQzMjk1MmMwMmE0NDE3YmRkZTM5JyxcbiAgICAgICAgJ2M5MGRkZjhkZWU0ZTk1Y2Y1NzcwNjZkNzA2ODFmMGQzNWUyYTMzZDJiNTZkMjAzMmI0YjE3NTJkMTkwMWFjMDEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzczOGM1NmIwM2IyYWJlMWU4MjgxYmFhNzQzZjhmOWE4ZjdjYzY0M2RmMjZjYmVlM2FiMTUwMjQyYmNiYjg5MScsXG4gICAgICAgICc4OTNmYjU3ODk1MWFkMjUzN2Y3MThmMmVhY2JmYmJiYjgyMzE0ZWVmNzg4MGNmZTkxN2U3MzVkOTY5OWE4NGMzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q4OTU2MjY1NDhiNjViODFlMjY0Yzc2MzdjOTcyODc3ZDFkNzJlNWYzYTkyNTAxNDM3MmU5ZjY1ODhmNmMxNGInLFxuICAgICAgICAnZmViZmFhMzhmMmJjN2VhZTcyOGVjNjA4MThjMzQwZWIwMzQyOGQ2MzJiYjA2N2UxNzkzNjNlZDc1ZDdkOTkxZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiOGRhOTQwMzJhOTU3NTE4ZWIwZjY0MzM1NzFlODc2MWNlZmZjNzM2OTNlODRlZGQ0OTE1MGE1NjRmNjc2ZTAzJyxcbiAgICAgICAgJzI4MDRkZmE0NDgwNWExZTRkN2M5OWNjOTc2MjgwOGIwOTJjYzU4NGQ5NWZmM2I1MTE0ODhlNGU3NGVmZGY2ZTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTgwZmVhMTQ0NDFmYjMzYTdkOGFkYWI5NDc1ZDdmYWIyMDE5ZWZmYjUxNTZhNzkyZjFhMTE3NzhlM2MwZGY1ZCcsXG4gICAgICAgICdlZWQxZGU3ZjYzOGUwMDc3MWU4OTc2OGNhM2NhOTQ0NzJkMTU1ZTgwYWYzMjJlYTlmY2I0MjkxYjZhYzllYzc4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2EzMDE2OTdiZGZjZDcwNDMxM2JhNDhlNTFkNTY3NTQzZjJhMTgyMDMxZWZkNjkxNWRkYzA3YmJjYzRlMTYwNzAnLFxuICAgICAgICAnNzM3MGY5MWNmYjY3ZTRmNTA4MTgwOWZhMjVkNDBmOWIxNzM1ZGJmN2MwYTExYTEzMGMwZDFhMDQxZTE3N2VhMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5MGFkODViMzg5ZDZiOTM2NDYzZjlkMDUxMjY3OGRlMjA4Y2MzMzBiMTEzMDdmZmZhYjdhYzYzZTNmYjA0ZWQ0JyxcbiAgICAgICAgJ2U1MDdhMzYyMGEzODI2MWFmZmRjYmQ5NDI3MjIyYjgzOWFlZmFiZTE1ODI4OTRkOTkxZDRkNDhjYjZlZjE1MCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4ZjY4YjlkMmY2M2I1ZjMzOTIzOWMxYWQ5ODFmMTYyZWU4OGM1Njc4NzIzZWEzMzUxYjdiNDQ0YzllYzRjMGRhJyxcbiAgICAgICAgJzY2MmE5ZjJkYmEwNjM5ODZkZTFkOTBjMmI2YmUyMTVkYmJlYTJjZmU5NTUxMGJmZGYyM2NiZjc5NTAxZmZmODInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTRmM2ZiMDE3NmFmODVkNjVmZjk5ZmY5MTk4YzM2MDkxZjQ4ZTg2NTAzNjgxZTNlNjY4NmZkNTA1MzIzMWUxMScsXG4gICAgICAgICcxZTYzNjMzYWQwZWY0ZjFjMTY2MWE2ZDBlYTAyYjcyODZjYzdlNzRlYzk1MWQxYzk4MjJjMzg1NzZmZWI3M2JjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhjMDBmYTliMThlYmYzMzFlYjk2MTUzN2E0NWE0MjY2YzcwMzRmMmYwZDRlMWQwNzE2ZmI2ZWFlMjBlYWUyOWUnLFxuICAgICAgICAnZWZhNDcyNjdmZWE1MjFhMWE5ZGMzNDNhMzczNmM5NzRjMmZhZGFmYTgxZTM2YzU0ZTdkMmE0YzY2NzAyNDE0YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlN2EyNmNlNjlkZDQ4MjlmM2UxMGNlYzBhOWU5OGVkMzE0M2QwODRmMzA4YjkyYzA5OTdmZGRmYzYwY2IzZTQxJyxcbiAgICAgICAgJzJhNzU4ZTMwMGZhNzk4NGI0NzFiMDA2YTFhYWZiYjE4ZDBhNmIyYzA0MjBlODNlMjBlOGE5NDIxY2YyY2ZkNTEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjY0NTllMGVlMzY2MmVjOGQyMzU0MGMyMjNiY2JkYzU3MWNiY2I5NjdkNzk0MjRmM2NmMjllYjNkZTZiODBlZicsXG4gICAgICAgICc2N2M4NzZkMDZmM2UwNmRlMWRhZGYxNmU1NjYxZGIzYzRiM2FlNmQ0OGUzNWIyZmYzMGJmMGI2MWE3MWJhNDUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDY4YTgwYzgyODBiYjg0MDc5MzIzNGFhMTE4ZjA2MjMxZDZmMWZjNjdlNzNjNWE1ZGVkYTBmNWI0OTY5NDNlOCcsXG4gICAgICAgICdkYjhiYTlmZmY0YjU4NmQwMGM0YjFmOTE3N2IwZTI4YjViMGU3YjhmNzg0NTI5NWEyOTRjODQyNjZiMTMzMTIwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMyNGFlZDdkZjY1YzgwNDI1MmRjMDI3MDkwN2EzMGIwOTYxMmFlYjk3MzQ0OWNlYTQwOTU5ODBmYzI4ZDNkNWQnLFxuICAgICAgICAnNjQ4YTM2NTc3NGI2MWYyZmYxMzBjMGMzNWFlYzFmNGYxOTIxM2IwYzdlMzMyODQzOTY3MjI0YWY5NmFiN2M4NCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ZGY5YzE0OTE5Y2RlNjFmNmQ1MWRmZGJlNWZlZTVkY2VlYzQxNDNiYThkMWNhODg4ZThiZDM3M2ZkMDU0Yzk2JyxcbiAgICAgICAgJzM1ZWM1MTA5MmQ4NzI4MDUwOTc0YzIzYTFkODVkNGI1ZDUwNmNkYzI4ODQ5MDE5MmViYWMwNmNhZDEwZDVkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzljMzkxOWE4NGE0NzQ4NzBmYWVkOGE5YzFjYzY2MDIxNTIzNDg5MDU0ZDdmMDMwOGNiZmM5OWM4YWMxZjk4Y2QnLFxuICAgICAgICAnZGRiODRmMGY0YTRkZGQ1NzU4NGYwNDRiZjI2MGU2NDE5MDUzMjZmNzZjNjRjOGU2YmU3ZTVlMDNkNGZjNTk5ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2MDU3MTcwYjFkZDEyZmRmOGRlMDVmMjgxZDhlMDZiYjkxZTE0OTNhOGI5MWQ0Y2M1YTIxMzgyMTIwYTk1OWU1JyxcbiAgICAgICAgJzlhMWFmMGIyNmE2YTQ4MDdhZGQ5YTJkYWY3MWRmMjYyNDY1MTUyYmMzZWUyNGM2NWU4OTliZTkzMjM4NWEyYTgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTU3NmRmOGUyM2EwODQxMTQyMTQzOWE0NTE4ZGEzMTg4MGNlZjBmYmE3ZDRkZjEyYjFhNjk3M2VlY2I5NDI2NicsXG4gICAgICAgICc0MGE2YmYyMGU3NjY0MGIyYzkyYjk3YWZlNThjZDgyYzQzMmUxMGE3ZjUxNGQ5ZjNlZThiZTExYWUxYjI4ZWM4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc3NzhhNzhjMjhkZWMzZTMwYTA1ZmU5NjI5ZGU4YzM4YmIzMGQxZjVjZjlhM2EyMDhmNzYzODg5YmU1OGFkNzEnLFxuICAgICAgICAnMzQ2MjZkOWFiNWE1YjIyZmY3MDk4ZTEyZjJmZjU4MDA4N2IzODQxMWZmMjRhYzU2M2I1MTNmYzFmZDlmNDNhYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5Mjg5NTVlZTYzN2E4NDQ2MzcyOWZkMzBlN2FmZDJlZDVmOTYyNzRlNWFkN2U1Y2IwOWVkYTljMDZkOTAzYWMnLFxuICAgICAgICAnYzI1NjIxMDAzZDNmNDJhODI3Yjc4YTEzMDkzYTk1ZWVhYzNkMjZlZmE4YThkODNmYzUxODBlOTM1YmNkMDkxZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NWQwZmVmM2VjNmRiMTA5Mzk5MDY0ZjNhMGUzYjI4NTU2NDViNGE5MDdhZDM1NDUyN2FhZTc1MTYzZDgyNzUxJyxcbiAgICAgICAgJzFmMDM2NDg0MTNhMzhjMGJlMjlkNDk2ZTU4MmNmNTY2M2U4NzUxZTk2ODc3MzMxNTgyYzIzN2EyNGViMWY5NjInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmYyYjBkY2U5N2VlY2U5N2MxYzliNjA0MTc5OGI4NWRmZGZiNmQ4ODgyZGEyMDMwOGY1NDA0ODI0NTI2MDg3ZScsXG4gICAgICAgICc0OTNkMTNmZWY1MjRiYTE4OGFmNGM0ZGM1NGQwNzkzNmM3YjdlZDZmYjkwZTJjZWIyYzk1MWUwMWYwYzI5OTA3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzgyN2ZiYmU0YjFlODgwZWE5ZWQyYjJlNjMwMWIyMTJiNTdmMWVlMTQ4Y2Q2ZGQyODc4MGU1ZTJjZjg1NmUyNDEnLFxuICAgICAgICAnYzYwZjljOTIzYzcyN2IwYjcxYmVmMmM2N2QxZDEyNjg3ZmY3YTYzMTg2OTAzMTY2ZDYwNWI2OGJhZWMyOTNlYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYWE2NDlmMjFmNTFiZGJhZTdiZTRhZTM0Y2U2ZTUyMTdhNThmZGNlN2Y0N2Y5YWE3ZjNiNThmYTIxMjBlMmIzJyxcbiAgICAgICAgJ2JlMzI3OWVkNWJiYmIwM2FjNjlhODBmODk4NzlhYTVhMDFhNmI5NjVmMTNmN2U1OWQ0N2E1MzA1YmE1YWQ5M2QnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTRhNDJkNDNjNWNmMTY5ZDkzOTFkZjZkZWNmNDJlZTU0MWI2ZDhmMGM5YTEzNzQwMWUyMzYzMmRkYTM0ZDI0ZicsXG4gICAgICAgICc0ZDlmOTJlNzE2ZDFjNzM1MjZmYzk5Y2NmYjhhZDM0Y2U4ODZlZWRmYThkOGU0ZjEzYTdmNzEzMWRlYmE5NDE0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzFlYzgwZmVmMzYwY2JkZDk1NDE2MGZhZGFiMzUyYjZiOTJiNTM1NzZhODhmZWE0OTQ3MTczYjlkNDMwMGJmMTknLFxuICAgICAgICAnYWVlZmU5Mzc1NmI1MzQwZDJmM2E0OTU4YTdhYmJmNWUwMTQ2ZTc3ZjYyOTVhMDdiNjcxY2RjMWNjMTA3Y2VmZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNDZhNzc4YzA0NjcwYzJmOTFiMDBhZjQ2ODBkZmE4YmNlMzQ5MDcxN2Q1OGJhODg5ZGRiNTkyODM2NjY0MmJlJyxcbiAgICAgICAgJ2IzMThlMGVjMzM1NDAyOGFkZDY2OTgyN2Y5ZDRiMjg3MGFhYTk3MWQyZjdlNWVkMWQwYjI5NzQ4M2Q4M2VmZDAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmE1MGMwZjYxZDIyZTVmMDdlM2FjZWJiMWFhMDdiMTI4ZDAwMTIyMDlhMjhiOTc3NmQ3NmE4NzkzMTgwZWVmOScsXG4gICAgICAgICc2Yjg0YzY5MjIzOTdlYmE5YjcyY2QyODcyMjgxYTY4YTVlNjgzMjkzYTU3YTIxM2IzOGNkOGQ3ZDNmNGYyODExJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RhMWQ2MWQwY2E3MjFhMTFiMWE1YmY2YjdkODhlODQyMWEyODhhYjVkNWJiYTUyMjBlNTNkMzJiNWYwNjdlYzInLFxuICAgICAgICAnODE1N2Y1NWE3Yzk5MzA2Yzc5YzA3NjYxNjFjOTFlMjk2NmE3Mzg5OWQyNzliNDhhNjU1ZmJhMGYxYWQ4MzZmMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhOGUyODJmZjBjOTcwNjkwNzIxNWZmOThlOGZkNDE2NjE1MzExZGUwNDQ2ZjFlMDYyYTczYjA2MTBkMDY0ZTEzJyxcbiAgICAgICAgJzdmOTczNTViOGRiODFjMDlhYmZiN2YzYzViMjUxNTg4OGI2NzlhM2U1MGRkNmJkNmNlZjdjNzMxMTFmNGNjMGMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTc0YTUzYjljOWEyODU4NzJkMzllNTZlNjkxM2NhYjE1ZDU5YjFmYTUxMjUwOGMwMjJmMzgyZGU4MzE5NDk3YycsXG4gICAgICAgICdjY2M5ZGMzN2FiZmM5YzE2NTdiNDE1NWYyYzQ3ZjllNjY0NmIzYTFkOGNiOTg1NDM4M2RhMTNhYzA3OWFmYTczJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzk1OTM5Njk4MTk0Mzc4NWMzZDNlNTdlZGY1MDE4Y2RiZTAzOWU3MzBlNDkxOGIzZDg4NGZkZmYwOTQ3NWI3YmEnLFxuICAgICAgICAnMmU3ZTU1Mjg4OGMzMzFkZDhiYTAzODZhNGI5Y2Q2ODQ5YzY1M2Y2NGM4NzA5Mzg1ZTliOGFiZjg3NTI0ZjJmZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkMmE2M2E1MGFlNDAxZTU2ZDY0NWExMTUzYjEwOWE4ZmNjYTBhNDNkNTYxZmJhMmRiYjUxMzQwYzlkODJiMTUxJyxcbiAgICAgICAgJ2U4MmQ4NmZiNjQ0M2ZjYjc1NjVhZWU1OGIyOTQ4MjIwYTcwZjc1MGFmNDg0Y2E1MmQ0MTQyMTc0ZGNmODk0MDUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjQ1ODdlMjMzNTQ3MWViODkwZWU3ODk2ZDdjZmRjODY2YmFjYmRiZDM4MzkzMTdiMzQzNmY5YjQ1NjE3ZTA3MycsXG4gICAgICAgICdkOTlmY2RkNWJmNjkwMmUyYWU5NmRkNjQ0N2MyOTlhMTg1YjkwYTM5MTMzYWVhYjM1ODI5OWU1ZTlmYWY2NTg5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg0ODFiZGUwZTRlNGQ4ODViM2E1NDZkM2U1NDlkZTA0MmYwYWE2Y2VhMjUwZTdmZDM1OGQ2Yzg2ZGQ0NWU0NTgnLFxuICAgICAgICAnMzhlZTdiOGNiYTU0MDRkZDg0YTI1YmYzOWNlY2IyY2E5MDBhNzljNDJiMjYyZTU1NmQ2NGIxYjU5Nzc5MDU3ZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxMzQ2NGE1N2E3ODEwMmFhNjJiNjk3OWFlODE3ZjQ2MzdmZmNmZWQzYzRiMWNlMzBiY2Q2MzAzZjZjYWY2NjZiJyxcbiAgICAgICAgJzY5YmUxNTkwMDQ2MTQ1ODBlZjdlNDMzNDUzY2NiMGNhNDhmMzAwYTgxZDA5NDJlMTNmNDk1YTkwN2Y2ZWNjMjcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYmM0YTlkZjViNzEzZmUyZTlhZWY0MzBiY2MxZGM5N2EwY2Q5Y2NlZGUyZjI4NTg4Y2FkYTNhMGQyZDgzZjM2NicsXG4gICAgICAgICdkM2E4MWNhNmU3ODVjMDYzODM5MzdhZGY0Yjc5OGNhYTZlOGE5ZmJmYTU0N2IxNmQ3NThkNjY2NTgxZjMzYzEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGMyOGE5N2JmODI5OGJjMGQyM2Q4Yzc0OTQ1MmEzMmU2OTRiNjVlMzBhOTQ3MmEzOTU0YWIzMGZlNTMyNGNhYScsXG4gICAgICAgICc0MGEzMDQ2M2EzMzA1MTkzMzc4ZmVkZjMxZjdjYzBlYjdhZTc4NGYwNDUxY2I5NDU5ZTcxZGM3M2NiZWY5NDgyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhlYTk2NjYxMzk1MjdhOGMxZGQ5NGNlNGYwNzFmZDIzYzhiMzUwYzVhNGJiMzM3NDhjNGJhMTExZmFjY2FlMCcsXG4gICAgICAgICc2MjBlZmFiYmM4ZWUyNzgyZTI0ZTdjMGNmYjk1YzVkNzM1Yjc4M2JlOWNmMGY4ZTk1NWFmMzRhMzBlNjJiOTQ1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RkMzYyNWZhZWY1YmEwNjA3NDY2OTcxNmJiZDM3ODhkODliZGRlODE1OTU5OTY4MDkyZjc2Y2M0ZWI5YTk3ODcnLFxuICAgICAgICAnN2ExODhmYTM1MjBlMzBkNDYxZGEyNTAxMDQ1NzMxY2E5NDE0NjE5ODI4ODMzOTU5MzdmNjhkMDBjNjQ0YTU3MydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmNzEwZDc5ZDllYjk2MjI5N2U0ZjYyMzJiNDBlOGY3ZmViMmJjNjM4MTQ2MTRkNjkyYzEyZGU3NTI0MDgyMjFlJyxcbiAgICAgICAgJ2VhOThlNjcyMzJkM2IzMjk1ZDNiNTM1NTMyMTE1Y2NhYzg2MTJjNzIxODUxNjE3NTI2YWU0N2E5Yzc3YmZjODInXG4gICAgICBdXG4gICAgXVxuICB9LFxuICBuYWY6IHtcbiAgICB3bmQ6IDcsXG4gICAgcG9pbnRzOiBbXG4gICAgICBbXG4gICAgICAgICdmOTMwOGEwMTkyNThjMzEwNDkzNDRmODVmODlkNTIyOWI1MzFjODQ1ODM2Zjk5YjA4NjAxZjExM2JjZTAzNmY5JyxcbiAgICAgICAgJzM4OGY3YjBmNjMyZGU4MTQwZmUzMzdlNjJhMzdmMzU2NjUwMGE5OTkzNGMyMjMxYjZjYjlmZDc1ODRiOGU2NzInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMmY4YmRlNGQxYTA3MjA5MzU1YjRhNzI1MGE1YzUxMjhlODhiODRiZGRjNjE5YWI3Y2JhOGQ1NjliMjQwZWZlNCcsXG4gICAgICAgICdkOGFjMjIyNjM2ZTVlM2Q2ZDRkYmE5ZGRhNmM5YzQyNmY3ODgyNzFiYWIwZDY4NDBkY2E4N2QzYWE2YWM2MmQ2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzVjYmRmMDY0NmU1ZGI0ZWFhMzk4ZjM2NWYyZWE3YTBlM2Q0MTliN2UwMzMwZTM5Y2U5MmJkZGVkY2FjNGY5YmMnLFxuICAgICAgICAnNmFlYmNhNDBiYTI1NTk2MGEzMTc4ZDZkODYxYTU0ZGJhODEzZDBiODEzZmRlN2I1YTUwODI2MjgwODcyNjRkYSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhY2Q0ODRlMmYwYzdmNjUzMDlhZDE3OGE5ZjU1OWFiZGUwOTc5Njk3NGM1N2U3MTRjMzVmMTEwZGZjMjdjY2JlJyxcbiAgICAgICAgJ2NjMzM4OTIxYjBhN2Q5ZmQ2NDM4MDk3MTc2M2I2MWU5YWRkODg4YTQzNzVmOGUwZjA1Y2MyNjJhYzY0ZjljMzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzc0YWU3Zjg1OGE5NDExZTVlZjQyNDZiNzBjNjVhYWM1NjQ5OTgwYmU1YzE3ODkxYmJlYzE3ODk1ZGEwMDhjYicsXG4gICAgICAgICdkOTg0YTAzMmViNmI1ZTE5MDI0M2RkNTZkN2I3YjM2NTM3MmRiMWUyZGZmOWQ2YTgzMDFkNzRjOWM5NTNjNjFiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YyODc3M2MyZDk3NTI4OGJjN2QxZDIwNWMzNzQ4NjUxYjA3NWZiYzY2MTBlNThjZGRlZWRkZjhmMTk0MDVhYTgnLFxuICAgICAgICAnYWIwOTAyZThkODgwYTg5NzU4MjEyZWI2NWNkYWY0NzNhMWEwNmRhNTIxZmE5MWYyOWI1Y2I1MmRiMDNlZDgxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q3OTI0ZDRmN2Q0M2VhOTY1YTQ2NWFlMzA5NWZmNDExMzFlNTk0NmYzYzg1Zjc5ZTQ0YWRiY2Y4ZTI3ZTA4MGUnLFxuICAgICAgICAnNTgxZTI4NzJhODZjNzJhNjgzODQyZWMyMjhjYzZkZWZlYTQwYWYyYmQ4OTZkM2E1YzUwNGRjOWZmNmEyNmI1OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkZWZkZWE0Y2RiNjc3NzUwYTQyMGZlZTgwN2VhY2YyMWViOTg5OGFlNzliOTc2ODc2NmU0ZmFhMDRhMmQ0YTM0JyxcbiAgICAgICAgJzQyMTFhYjA2OTQ2MzUxNjhlOTk3YjBlYWQyYTkzZGFlY2VkMWY0YTA0YTk1YzBmNmNmYjE5OWY2OWU1NmViNzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMmI0ZWEwYTc5N2E0NDNkMjkzZWY1Y2ZmNDQ0ZjQ5NzlmMDZhY2ZlYmQ3ZTg2ZDI3NzQ3NTY1NjEzODM4NWI2YycsXG4gICAgICAgICc4NWU4OWJjMDM3OTQ1ZDkzYjM0MzA4M2I1YTFjODYxMzFhMDFmNjBjNTAyNjk3NjNiNTcwYzg1NGU1YzA5YjdhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM1MmJiZjRhNGNkZDEyNTY0ZjkzZmEzMzJjZTMzMzMwMWQ5YWQ0MDI3MWY4MTA3MTgxMzQwYWVmMjViZTU5ZDUnLFxuICAgICAgICAnMzIxZWI0MDc1MzQ4ZjUzNGQ1OWMxODI1OWRkYTNlMWY0YTFiM2IyZTcxYjEwMzljNjdiZDNkOGJjZjgxOTk4YydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyZmEyMTA0ZDZiMzhkMTFiMDIzMDAxMDU1OTg3OTEyNGU0MmFiOGRmZWZmNWZmMjlkYzljZGFkZDRlY2FjYzNmJyxcbiAgICAgICAgJzJkZTEwNjgyOTVkZDg2NWI2NDU2OTMzNWJkNWRkODAxODFkNzBlY2ZjODgyNjQ4NDIzYmE3NmI1MzJiN2Q2NydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5MjQ4Mjc5YjA5YjRkNjhkYWIyMWE5YjA2NmVkZGE4MzI2M2MzZDg0ZTA5NTcyZTI2OWNhMGNkN2Y1NDUzNzE0JyxcbiAgICAgICAgJzczMDE2ZjdiZjIzNGFhZGU1ZDFhYTcxYmRlYTJiMWZmM2ZjMGRlMmE4ODc5MTJmZmU1NGEzMmNlOTdjYjM0MDInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGFlZDRmMmJlM2E4YmYyNzhlNzAxMzJmYjBiZWI3NTIyZjU3MGUxNDRiZjYxNWMwN2U5OTZkNDQzZGVlODcyOScsXG4gICAgICAgICdhNjlkY2U0YTdkNmM5OGU4ZDRhMWFjYTg3ZWY4ZDcwMDNmODNjMjMwZjNhZmE3MjZhYjQwZTUyMjkwYmUxYzU1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M0NGQxMmM3MDY1ZDgxMmU4YWNmMjhkN2NiYjE5ZjkwMTFlY2Q5ZTlmZGYyODFiMGU2YTNiNWU4N2QyMmU3ZGInLFxuICAgICAgICAnMjExOWE0NjBjZTMyNmNkYzc2YzQ1OTI2Yzk4MmZkYWMwZTEwNmU4NjFlZGY2MWM1YTAzOTA2M2YwZTBlNjQ4MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2YTI0NWJmNmRjNjk4NTA0Yzg5YTIwY2ZkZWQ2MDg1MzE1MmI2OTUzMzZjMjgwNjNiNjFjNjVjYmQyNjllNmI0JyxcbiAgICAgICAgJ2UwMjJjZjQyYzJiZDRhNzA4YjNmNTEyNmYxNmEyNGFkOGIzM2JhNDhkMDQyM2I2ZWZkNWU2MzQ4MTAwZDhhODInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTY5N2ZmYTZmZDlkZTYyN2MwNzdlM2QyZmU1NDEwODRjZTEzMzAwYjBiZWMxMTQ2Zjk1YWU1N2YwZDBiZDZhNScsXG4gICAgICAgICdiOWMzOThmMTg2ODA2ZjVkMjc1NjE1MDZlNDU1NzQzM2EyY2YxNTAwOWU0OThhZTdhZGVlOWQ2M2QwMWIyMzk2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzYwNWJkYjAxOTk4MTcxOGI5ODZkMGYwN2U4MzRjYjBkOWRlYjgzNjBmZmI3ZjYxZGY5ODIzNDVlZjI3YTc0NzknLFxuICAgICAgICAnMjk3MmQyZGU0ZjhkMjA2ODFhNzhkOTNlYzk2ZmUyM2MyNmJmYWU4NGZiMTRkYjQzYjAxZTFlOTA1NmI4YzQ5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzYyZDE0ZGFiNDE1MGJmNDk3NDAyZmRjNDVhMjE1ZTEwZGNiMDFjMzU0OTU5YjEwY2ZlMzFjN2U5ZDg3ZmYzM2QnLFxuICAgICAgICAnODBmYzA2YmQ4Y2M1YjAxMDk4MDg4YTE5NTBlZWQwZGIwMWFhMTMyOTY3YWI0NzIyMzVmNTY0MjQ4M2IyNWVhZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4MGM2MGFkMDA0MGYyN2RhZGU1YjRiMDZjNDA4ZTU2YjJjNTBlOWY1NmI5YjhiNDI1ZTU1NWMyZjg2MzA4YjZmJyxcbiAgICAgICAgJzFjMzgzMDNmMWNjNWMzMGYyNmU2NmJhZDdmZTcyZjcwYTY1ZWVkNGNiZTcwMjRlYjFhYTAxZjU2NDMwYmQ1N2EnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnN2E5Mzc1YWQ2MTY3YWQ1NGFhNzRjNjM0OGNjNTRkMzQ0Y2M1ZGM5NDg3ZDg0NzA0OWQ1ZWFiYjBmYTAzYzhmYicsXG4gICAgICAgICdkMGUzZmE5ZWNhODcyNjkwOTU1OWUwZDc5MjY5MDQ2YmRjNTllYTEwYzcwY2UyYjAyZDQ5OWVjMjI0ZGM3ZjcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDUyOGVjZDliNjk2YjU0YzkwN2E5ZWQwNDU0NDdhNzliYjQwOGVjMzliNjhkZjUwNGJiNTFmNDU5YmMzZmZjOScsXG4gICAgICAgICdlZWNmNDEyNTMxMzZlNWY5OTk2NmYyMTg4MWZkNjU2ZWJjNDM0NTQwNWM1MjBkYmMwNjM0NjViNTIxNDA5OTMzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ5MzcwYTRiNWY0MzQxMmVhMjVmNTE0ZThlY2RhZDA1MjY2MTE1ZTRhN2VjYjEzODcyMzE4MDhmOGI0NTk2MycsXG4gICAgICAgICc3NThmM2Y0MWFmZDZlZDQyOGIzMDgxYjA1MTJmZDYyYTU0YzNmM2FmYmI1YjY3NjRiNjUzMDUyYTEyOTQ5YzlhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc3ZjIzMDkzNmVlODhjYmJkNzNkZjkzMGQ2NDcwMmVmODgxZDgxMWUwZTE0OThlMmYxYzEzZWIxZmMzNDVkNzQnLFxuICAgICAgICAnOTU4ZWY0MmE3ODg2YjY0MDBhMDgyNjZlOWJhMWIzNzg5NmM5NTMzMGQ5NzA3N2NiYmU4ZWIzYzc2NzFjNjBkNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmMmRhYzk5MWNjNGNlNGI5ZWE0NDg4N2U1YzdjMGJjZTU4YzgwMDc0YWI5ZDRkYmFlYjI4NTMxYjc3MzlmNTMwJyxcbiAgICAgICAgJ2UwZGVkYzliM2IyZjhkYWQ0ZGExZjMyZGVjMjUzMWRmOWViNWZiZWIwNTk4ZTRmZDFhMTE3ZGJhNzAzYTNjMzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDYzYjNkOWY2NjI2MjFmYjFiNGJlOGZiYmUyNTIwMTI1YTIxNmNkZmM5ZGFlM2RlYmNiYTQ4NTBjNjkwZDQ1YicsXG4gICAgICAgICc1ZWQ0MzBkNzhjMjk2YzM1NDMxMTQzMDZkZDg2MjJkN2M2MjJlMjdjOTcwYTFkZTMxY2IzNzdiMDFhZjczMDdlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YxNmY4MDQyNDRlNDZlMmEwOTIzMmQ0YWZmM2I1OTk3NmI5OGZhYzE0MzI4YTJkMWEzMjQ5NmI0OTk5OGYyNDcnLFxuICAgICAgICAnY2VkYWJkOWI4MjIwM2Y3ZTEzZDIwNmZjZGY0ZTMzZDkyYTZjNTNjMjZlNWNjZTI2ZDY1Nzk5NjJjNGUzMWRmNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjYWY3NTQyNzJkYzg0NTYzYjAzNTJiN2ExNDMxMWFmNTVkMjQ1MzE1YWNlMjdjNjUzNjllMTVmNzE1MWQ0MWQxJyxcbiAgICAgICAgJ2NiNDc0NjYwZWYzNWY1ZjJhNDFiNjQzZmE1ZTQ2MDU3NWY0ZmE5Yjc5NjIyMzJhNWMzMmY5MDgzMThhMDQ0NzYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMjYwMGNhNGIyODJjYjk4NmY4NWQwZjE3MDk5NzlkOGI0NGEwOWMwN2NiODZkN2MxMjQ0OTdiYzg2ZjA4MjEyMCcsXG4gICAgICAgICc0MTE5Yjg4NzUzYzE1YmQ2YTY5M2IwM2ZjZGRiYjQ1ZDVhYzZiZTc0YWI1ZjBlZjQ0YjBiZTk0NzVhN2U0YjQwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc2MzVjYTcyZDdlODQzMmMzMzhlYzUzY2QxMjIyMGJjMDFjNDg2ODVlMjRmN2RjOGM2MDJhNzc0Njk5OGU0MzUnLFxuICAgICAgICAnOTFiNjQ5NjA5NDg5ZDYxM2QxZDVlNTkwZjc4ZTZkNzRlY2ZjMDYxZDU3MDQ4YmFkOWU3NmYzMDJjNWI5YzYxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc1NGUzMjM5ZjMyNTU3MGNkYmJmNGE4N2RlZWU4YTY2YjdmMmIzMzQ3OWQ0NjhmYmMxYTUwNzQzYmY1NmNjMTgnLFxuICAgICAgICAnNjczZmI4NmU1YmRhMzBmYjNjZDBlZDMwNGVhNDlhMDIzZWUzM2QwMTk3YTY5NWQwYzVkOTgwOTNjNTM2NjgzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UzZTZiZDEwNzFhMWU5NmFmZjU3ODU5YzgyZDU3MGYwMzMwODAwNjYxZDFjOTUyZjlmZTI2OTQ2OTFkOWI5ZTgnLFxuICAgICAgICAnNTljOWUwYmJhMzk0ZTc2ZjQwYzBhYTU4Mzc5YTNjYjZhNWEyMjgzOTkzZTkwYzQxNjcwMDJhZjQ5MjBlMzdmNSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxODZiNDgzZDA1NmEwMzM4MjZhZTczZDg4ZjczMjk4NWM0Y2NiMWYzMmJhMzVmNGI0Y2M0N2ZkY2YwNGFhNmViJyxcbiAgICAgICAgJzNiOTUyZDMyYzY3Y2Y3N2UyZTE3NDQ2ZTIwNDE4MGFiMjFmYjgwOTA4OTUxMzhiNGE0YTc5N2Y4NmU4MDg4OGInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGY5ZDcwYTZiOTg3NmNlNTQ0Yzk4NTYxZjRiZTRmNzI1NDQyZTZkMmI3MzdkOWM5MWE4MzIxNzI0Y2UwOTYzZicsXG4gICAgICAgICc1NWViMmRhZmQ4NGQ2Y2NkNWY4NjJiNzg1ZGMzOWQ0YWIxNTcyMjI3MjBlZjlkYTIxN2I4YzQ1Y2YyYmEyNDE3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzVlZGQ1Y2MyM2M1MWU4N2E0OTdjYTgxNWQ1ZGNlMGY4YWI1MjU1NGY4NDllZDg5OTVkZTY0YzVmMzRjZTcxNDMnLFxuICAgICAgICAnZWZhZTljOGRiYzE0MTMwNjYxZThjZWMwMzBjODlhZDBjMTNjNjZjMGQxN2EyOTA1Y2RjNzA2YWI3Mzk5YTg2OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyOTA3OThjMmI2NDc2ODMwZGExMmZlMDIyODdlOWU3NzdhYTNmYmExYzM1NWIxN2E3MjJkMzYyZjg0NjE0ZmJhJyxcbiAgICAgICAgJ2UzOGRhNzZkY2Q0NDA2MjE5ODhkMDBiY2Y3OWFmMjVkNWIyOWMwOTRkYjJhMjMxNDZkMDAzYWZkNDE5NDNlN2EnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYWYzYzQyM2E5NWQ5ZjViMzA1NDc1NGVmYTE1MGFjMzljZDI5NTUyZmUzNjAyNTczNjJkZmRlY2VmNDA1M2I0NScsXG4gICAgICAgICdmOThhM2ZkODMxZWIyYjc0OWE5M2IwZTZmMzVjZmI0MGM4Y2Q1YWE2NjdhMTU1ODFiYzJmZWRlZDQ5OGZkOWM2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc2NmRiYjI0ZDEzNGU3NDVjY2NhYTI4Yzk5YmYyNzQ5MDZiYjY2YjI2ZGNmOThkZjhkMmZlZDUwZDg4NDI0OWEnLFxuICAgICAgICAnNzQ0YjExNTJlYWNiZTVlMzhkY2M4ODc5ODBkYTM4Yjg5NzU4NGE2NWZhMDZjZWRkMmM5MjRmOTdjYmFjNTk5NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1OWRiZjQ2ZjhjOTQ3NTliYTIxMjc3YzMzNzg0ZjQxNjQ1ZjdiNDRmNmM1OTZhNThjZTkyZTY2NjE5MWFiZTNlJyxcbiAgICAgICAgJ2M1MzRhZDQ0MTc1ZmJjMzAwZjRlYTZjZTY0ODMwOWEwNDJjZTczOWE3OTE5Nzk4Y2Q4NWUyMTZjNGEzMDdmNmUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjEzYWRhOTUxMDNjNDUzNzMwNWU2OTFlNzRlOWE0YThkZDY0N2U3MTFhOTVlNzNjYjYyZGM2MDE4Y2ZkODdiOCcsXG4gICAgICAgICdlMTM4MTdiNDRlZTE0ZGU2NjNiZjRiYzgwODM0MWYzMjY5NDllMjFhNmE3NWMyNTcwNzc4NDE5YmRhZjU3MzNkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc3NTRiNGZhMGU4YWNlZDA2ZDQxNjdhMmM1OWNjYTRjZGExODY5YzA2ZWJhZGZiNjQ4ODU1MDAxNWE4ODUyMmMnLFxuICAgICAgICAnMzBlOTNlODY0ZTY2OWQ4MjIyNGI5NjdjMzAyMGI4ZmE4ZDFlNGUzNTBiNmNiY2M1MzdhNDhiNTc4NDExNjNhMidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5NDhkY2FkZjU5OTBlMDQ4YWEzODc0ZDQ2YWJlZjlkNzAxODU4Zjk1ZGU4MDQxZDJhNjgyOGM5OWUyMjYyNTE5JyxcbiAgICAgICAgJ2U0OTFhNDI1MzdmNmU1OTdkNWQyOGEzMjI0YjFiYzI1ZGY5MTU0ZWZiZDJlZjFkMmNiYmEyY2FlNTM0N2Q1N2UnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzk2MjQxNDQ1MGM3NmMxNjg5YzdiNDhmODIwMmVjMzdmYjIyNGNmNWFjMGJmYTE1NzAzMjhhOGEzZDdjNzdhYicsXG4gICAgICAgICcxMDBiNjEwZWM0ZmZiNDc2MGQ1YzFmYzEzM2VmNmY2YjEyNTA3YTA1MWYwNGFjNTc2MGFmYTViMjlkYjgzNDM3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM1MTQwODc4MzQ5NjRiNTRiMTViMTYwNjQ0ZDkxNTQ4NWExNjk3NzIyNWI4ODQ3YmIwZGQwODUxMzdlYzQ3Y2EnLFxuICAgICAgICAnZWYwYWZiYjIwNTYyMDU0NDhlMTY1MmM0OGU4MTI3ZmM2MDM5ZTc3YzE1YzIzNzhiN2U3ZDE1YTBkZTI5MzMxMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkM2NjMzBhZDZiNDgzZTRiYzc5Y2UyYzlkZDhiYzU0OTkzZTk0N2ViOGRmNzg3YjQ0Mjk0M2QzZjdiNTI3ZWFmJyxcbiAgICAgICAgJzhiMzc4YTIyZDgyNzI3OGQ4OWM1ZTliZThmOTUwOGFlM2MyYWQ0NjI5MDM1ODYzMGFmYjM0ZGIwNGVlZGUwYTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTYyNGQ4NDc4MDczMjg2MGNlMWM3OGZjYmZlZmUwOGIyYjI5ODIzZGI5MTNmNjQ5Mzk3NWJhMGZmNDg0NzYxMCcsXG4gICAgICAgICc2ODY1MWNmOWI2ZGE5MDNlMDkxNDQ0OGM2Y2Q5ZDRjYTg5Njg3OGY1MjgyYmU0YzhjYzA2ZTJhNDA0MDc4NTc1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzczM2NlODBkYTk1NWE4YTI2OTAyYzk1NjMzZTYyYTk4NTE5MjQ3NGI1YWYyMDdkYTZkZjdiNGZkNWZjNjFjZDQnLFxuICAgICAgICAnZjU0MzVhMmJkMmJhZGY3ZDQ4NWE0ZDhiOGRiOWZjY2UzZTFlZjhlMDIwMWU0NTc4YzU0NjczYmMxZGM1ZWExZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNWQ5NDQxMjU0OTQ1MDY0Y2YxYTFjMzNiYmQzYjQ5Zjg5NjZjNTA5MjE3MWU2OTllZjI1OGRmYWI4MWMwNDVjJyxcbiAgICAgICAgJ2Q1NmViMzBiNjk0NjNlNzIzNGY1MTM3YjczYjg0MTc3NDM0ODAwYmFjZWJmYzY4NWZjMzdiYmU5ZWZlNDA3MGQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTFkMGZjZjJlYzlkZTY3NWI2MTIxMzZlNWNlNzBkMjcxYzIxNDE3YzlkMmI4YWFhYWMxMzg1OTlkMDcxNzk0MCcsXG4gICAgICAgICdlZGQ3N2Y1MGJjYjVhM2NhYjJlOTA3MzczMDk2NjdmMjY0MTQ2MmE1NDA3MGYzZDUxOTIxMmQzOWMxOTdhNjI5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UyMmZiZTE1YzBhZjhjY2M1NzgwYzA3MzVmODRkYmU5YTc5MGJhZGVlODI0NWMwNmM3Y2EzNzMzMWNiMzY5ODAnLFxuICAgICAgICAnYTg1NWJhYmFkNWNkNjBjODhiNDMwYTY5ZjUzYTFhN2EzODI4OTE1NDk2NDc5OWJlNDNkMDZkNzdkMzFkYTA2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMxMTA5MWRkOTg2MGU4ZTIwZWUxMzQ3M2MxMTU1ZjVmNjk2MzVlMzk0NzA0ZWFhNzQwMDk0NTIyNDZjZmE5YjMnLFxuICAgICAgICAnNjZkYjY1NmY4N2QxZjA0ZmZmZDFmMDQ3ODhjMDY4MzA4NzFlYzVhNjRmZWVlNjg1YmQ4MGYwYjEyODZkODM3NCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNGMxZmQwNGQzMDFiZTg5YjMxYzA0NDJkM2U2YWMyNDg4MzkyOGI0NWE5MzQwNzgxODY3ZDQyMzJlYzJkYmRmJyxcbiAgICAgICAgJzk0MTQ2ODVlOTdiMWI1OTU0YmQ0NmY3MzAxNzQxMzZkNTdmMWNlZWI0ODc0NDNkYzUzMjE4NTdiYTczYWJlZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmMjE5ZWE1ZDZiNTQ3MDFjMWMxNGRlNWI1NTdlYjQyYThkMTNmM2FiYmNkMDhhZmZjYzJhNWU2YjA0OWI4ZDYzJyxcbiAgICAgICAgJzRjYjk1OTU3ZTgzZDQwYjBmNzNhZjQ1NDRjY2NmNmIxZjRiMDhkM2MwN2IyN2ZiOGQ4YzI5NjJhNDAwNzY2ZDEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDdiODc0MGY3NGE4ZmJhYWIxZjY4M2RiOGY0NWRlMjY1NDNhNTQ5MGJjYTYyNzA4NzIzNjkxMjQ2OWEwYjQ0OCcsXG4gICAgICAgICdmYTc3OTY4MTI4ZDljOTJlZTEwMTBmMzM3YWQ0NzE3ZWZmMTVkYjVlZDNjMDQ5YjM0MTFlMDMxNWVhYTQ1OTNiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMyZDMxYzIyMmY4ZjZmMGVmODZmN2M5OGQzYTMzMzVlYWQ1YmNkMzJhYmRkOTQyODlmZTRkMzA5MWFhODI0YmYnLFxuICAgICAgICAnNWYzMDMyZjU4OTIxNTZlMzljY2QzZDc5MTViOWUxZGEyZTZkYWM5ZTZmMjZlOTYxMTE4ZDE0Yjg0NjJlMTY2MSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NDYxZjM3MTkxNGFiMzI2NzEwNDVhMTU1ZDk4MzFlYTg3OTNkNzdjZDU5NTkyYzQzNDBmODZjYmMxODM0N2I1JyxcbiAgICAgICAgJzhlYzBiYTIzOGI5NmJlYzBjYmRkZGNhZTBhYTQ0MjU0MmVlZTFmZjUwYzk4NmVhNmIzOTg0N2IzY2MwOTJmZjYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWUwNzlhZGIxZGYxODYwMDc0MzU2YTI1YWEzODIwNmE2ZDcxNmIyYzNlNjc0NTNkMjg3Njk4YmFkN2IyYjJkNicsXG4gICAgICAgICc4ZGMyNDEyYWFmZTNiZTVjNGM1ZjM3ZTBlY2M1ZjlmNmE0NDY5ODlhZjA0YzRlMjVlYmFhYzQ3OWVjMWM4YzFlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE2ZWM5M2U0NDdlYzgzZjA0NjdiMTgzMDJlZTYyMGY3ZTY1ZGUzMzE4NzRjOWRjNzJiZmQ4NjE2YmE5ZGE2YjUnLFxuICAgICAgICAnNWU0NjMxMTUwZTYyZmI0MGQwZThjMmE3Y2E1ODA0YTM5ZDU4MTg2YTUwZTQ5NzEzOTYyNjc3OGUyNWIwNjc0ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYWE1Zjk4MGMyNDVmNmYwMzg5NzgyOTBhZmE3MGI2YmQ4ODU1ODk3Zjk4YjZhYTQ4NWI5NjA2NWQ1MzdiZDk5JyxcbiAgICAgICAgJ2Y2NWY1ZDNlMjkyYzJlMDgxOWE1MjgzOTFjOTk0NjI0ZDc4NDg2OWQ3ZTZlYTY3ZmIxODA0MTAyNGVkYzA3ZGMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzhjOTQwNzU0NGFjMTMyNjkyZWUxOTEwYTAyNDM5OTU4YWUwNDg3NzE1MTM0MmVhOTZjNGI2YjM1YTQ5ZjUxJyxcbiAgICAgICAgJ2YzZTAzMTkxNjllYjliODVkNTQwNDc5NTUzOWE1ZTY4ZmExZmJkNTgzYzA2NGQyNDYyYjY3NWYxOTRhM2RkYjQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDk0ZjRiZTIxOWExYTc3MDE2ZGNkODM4NDMxYWVhMDAwMWNkYzhhZTdhNmZjNjg4NzI2NTc4ZDk3MDI4NTdhNScsXG4gICAgICAgICc0MjI0MmE5NjkyODNhNWYzMzliYTdmMDc1ZTM2YmEyYWY5MjVjZTMwZDc2N2VkNmU1NWY0YjAzMTg4MGQ1NjJjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2E1OThhODAzMGRhNmQ4NmM2YmM3ZjJmNTE0NGVhNTQ5ZDI4MjExZWE1OGZhYTcwZWJmNGMxZTY2NWMxZmU5YjUnLFxuICAgICAgICAnMjA0YjVkNmY4NDgyMmMzMDdlNGI0YTcxNDA3MzdhZWMyM2ZjNjNiNjViMzVmODZhMTAwMjZkYmQyZDg2NGU2YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjNDE5MTYzNjVhYmIyYjVkMDkxOTJmNWYyZGJlYWZlYzIwOGYwMjBmMTI1NzBhMTg0ZGJhZGMzZTU4NTk1OTk3JyxcbiAgICAgICAgJzRmMTQzNTFkMDA4N2VmYTQ5ZDI0NWIzMjg5ODQ5ODlkNWNhZjk0NTBmMzRiZmMwZWQxNmU5NmI1OGZhOTkxMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NDFkNjA2M2E1ODZmYTQ3NWE3MjQ2MDRkYTAzYmM1YjkyYTJlMGQyZTBhMzZhY2ZlNGM3M2E1NTE0NzQyODgxJyxcbiAgICAgICAgJzczODY3ZjU5YzA2NTllODE5MDRmOWExYzc1NDM2OThlNjI1NjJkNjc0NGMxNjljZTdhMzZkZTAxYThkNjE1NCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1ZTk1YmIzOTlhNjk3MWQzNzYwMjY5NDdmODliZGUyZjI4MmIzMzgxMDkyOGJlNGRlZDExMmFjNGQ3MGUyMGQ1JyxcbiAgICAgICAgJzM5ZjIzZjM2NjgwOTA4NWJlZWJmYzcxMTgxMzEzNzc1YTk5YzlhZWQ3ZDhiYTM4YjE2MTM4NGM3NDYwMTI4NjUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzZlNDY0MWE1Mzk0OGZkNDc2YzM5ZjhhOTlmZDk3NGU1ZWMwNzU2NGI1MzE1ZDhiZjk5NDcxYmNhMGVmMmY2NicsXG4gICAgICAgICdkMjQyNGIxYjFhYmU0ZWI4MTY0MjI3YjA4NWM5YWE5NDU2ZWExMzQ5M2ZkNTYzZTA2ZmQ1MWNmNTY5NGM3OGZjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMzNjU4MWVhN2JmYmJiMjkwYzE5MWEyZjUwN2E0MWNmNTY0Mzg0MjE3MGU5MTRmYWVhYjI3YzJjNTc5ZjcyNicsXG4gICAgICAgICdlYWQxMjE2ODU5NWZlMWJlOTkyNTIxMjliNmU1NmIzMzkxZjdhYjE0MTBjZDFlMGVmM2RjZGNhYmQyZmRhMjI0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhhYjg5ODE2ZGFkZmQ2YjZhMWYyNjM0ZmNmMDBlYzg0MDM3ODEwMjVlZDY4OTBjNDg0OTc0MjcwNmJkNDNlZGUnLFxuICAgICAgICAnNmZkY2VmMDlmMmY2ZDBhMDQ0ZTY1NGFlZjYyNDEzNmY1MDNkNDU5YzNlODk4NDU4NThhNDdhOTEyOWNkZDI0ZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxZTMzZjFhNzQ2YzljNTc3ODEzMzM0NGQ5Mjk5ZmNhYTIwYjA5MzhlOGFjZmYyNTQ0YmI0MDI4NGI4YzVmYjk0JyxcbiAgICAgICAgJzYwNjYwMjU3ZGQxMWIzYWE5YzhlZDYxOGQyNGVkZmYyMzA2ZDMyMGYxZDAzMDEwZTMzYTdkMjA1N2YzYjNiNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NWI3YzFkY2IzY2VjMWI3ZWU3ZjMwZGVkNzlkZDIwYTBlZDFmNGNjMThjYmNmY2ZhNDEwMzYxZmQ4ZjA4ZjMxJyxcbiAgICAgICAgJzNkOThhOWNkZDAyNmRkNDNmMzkwNDhmMjVhODg0N2Y0ZmNhZmFkMTg5NWQ3YTYzM2M2ZmVkM2MzNWU5OTk1MTEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMjlkZjlmYmQ4ZDllNDY1MDkyNzVmNGIxMjVkNmQ0NWQ3ZmJlOWEzYjg3OGE3YWY4NzJhMjgwMDY2MWFjNWY1MScsXG4gICAgICAgICdiNGM0ZmU5OWM3NzVhNjA2ZTJkODg2MjE3OTEzOWZmZGE2MWRjODYxYzAxOWU1NWNkMjg3NmViMmEyN2Q4NGInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTBiMWNhZTA2YjBhODQ3YTNmZWE2ZTY3MWFhZjhhZGZkZmU1OGNhMmY3NjgxMDVjODA4MmIyZTQ0OWZjZTI1MicsXG4gICAgICAgICdhZTQzNDEwMmVkZGUwOTU4ZWM0YjE5ZDkxN2E2YTI4ZTZiNzJkYTE4MzRhZmYwZTY1MGYwNDk1MDNhMjk2Y2YyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzRlOGNlYWZiOWIzZTlhMTM2ZGM3ZmY2N2U4NDAyOTViNDk5ZGZiM2IyMTMzZTRiYTExM2YyZTRjMGUxMjFlNScsXG4gICAgICAgICdjZjIxNzQxMThjOGI2ZDdhNGI0OGY2ZDUzNGNlNWM3OTQyMmMwODZhNjM0NjA1MDJiODI3Y2U2MmEzMjY2ODNjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2QyNGE0NGUwNDdlMTliNmY1YWZiODFjN2NhMmY2OTA4MGE1MDc2Njg5YTAxMDkxOWY0MjcyNWMyYjc4OWEzM2InLFxuICAgICAgICAnNmZiOGQ1NTkxYjQ2NmY4ZmM2M2RiNTBmMWMwZjFjNjkwMTNmOTk2ODg3YjgyNDRkMmNkZWM0MTdhZmVhOGZhMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYTAxNjA2YTdhNmM5Y2RkMjQ5ZmRmY2ZhY2I5OTU4NDAwMWVkZDI4YWJiYWI3N2I1MTA0ZTk4ZThlM2IzNWQ0JyxcbiAgICAgICAgJzMyMmFmNDkwOGM3MzEyYjBjZmJmZTM2OWY3YTdiM2NkYjdkNDQ5NGJjMjgyMzcwMGNmZDY1MjE4OGEzZWE5OGQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYWY4YWRkYmYyYjY2MWM4YTZjNjMyODY1NWViOTY2NTEyNTIwMDdkOGM1ZWEzMWJlNGFkMTk2ZGU4Y2UyMTMxZicsXG4gICAgICAgICc2NzQ5ZTY3YzAyOWI4NWY1MmEwMzRlYWZkMDk2ODM2YjI1MjA4MTg2ODBlMjZhYzhmM2RmYmNkYjcxNzQ5NzAwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UzYWUxOTc0NTY2Y2EwNmNjNTE2ZDQ3ZTBmYjE2NWE2NzRhM2RhYmNmY2ExNWU3MjJmMGUzNDUwZjQ1ODg5JyxcbiAgICAgICAgJzJhZWFiZTdlNDUzMTUxMDExNjIxN2YwN2JmNGQwNzMwMGRlOTdlNDg3NGY4MWY1MzM0MjBhNzJlZWIwYmQ2YTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTkxZWUzNTUzMTNkOTk3MjFjZjY5OTNmZmVkMWUzZTMwMTk5M2ZmM2VkMjU4ODAyMDc1ZWE4Y2VkMzk3ZTI0NicsXG4gICAgICAgICdiMGVhNTU4YTExM2MzMGJlYTYwZmM0Nzc1NDYwYzc5MDFmZjBiMDUzZDI1Y2EyYmRlZWU5OGYxYTRiZTVkMTk2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzExMzk2ZDU1ZmRhNTRjNDlmMTlhYTk3MzE4ZDhkYTYxZmE4NTg0ZTQ3YjA4NDk0NTA3N2NmMDMyNTViNTI5ODQnLFxuICAgICAgICAnOTk4Yzc0YThjZDQ1YWMwMTI4OWQ1ODMzYTdiZWI0NzQ0ZmY1MzZiMDFiMjU3YmU0YzU3NjdiZWE5M2VhNTdhNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczYzVkMmExYmEzOWM1YTE3OTAwMDA3MzhjOWUwYzQwYjhkY2RmZDU0Njg3NTRiNjQwNTU0MDE1N2UwMTdhYTdhJyxcbiAgICAgICAgJ2IyMjg0Mjc5OTk1YTM0ZTJmOWQ0ZGU3Mzk2ZmMxOGI4MGY5YjhiOWZkZDI3MGY2NjYxZjc5Y2E0YzgxYmQyNTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnY2M4NzA0YjhhNjBhMGRlZmEzYTk5YTcyOTlmMmU5YzNmYmMzOTVhZmIwNGFjMDc4NDI1ZWY4YTE3OTNjYzAzMCcsXG4gICAgICAgICdiZGQ0NjAzOWZlZWQxNzg4MWQxZTA4NjJkYjM0N2Y4Y2YzOTViNzRmYzRiY2RjNGU5NDBiNzRlM2FjMWYxYjEzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M1MzNlNGY3ZWE4NTU1YWFjZDk3NzdhYzVjYWQyOWI5N2RkNGRlZmNjYzUzZWU3ZWEyMDQxMTliMjg4OWIxOTcnLFxuICAgICAgICAnNmYwYTI1NmJjNWVmZGY0MjlhMmZiNjI0MmYxYTQzYTJkOWI5MjViYjRhNGIzYTI2YmI4ZTBmNDVlYjU5NjA5NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjMTRmOGYyY2NiMjdkNmYxMDlmNmQwOGQwM2NjOTZhNjliYThjMzRlZWMwN2JiY2Y1NjZkNDhlMzNkYTY1OTMnLFxuICAgICAgICAnYzM1OWQ2OTIzYmIzOThmN2ZkNDQ3M2UxNmZlMWMyODQ3NWI3NDBkZDA5ODA3NWU2YzBlODY0OTExM2RjM2EzOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhNmNiYzMwNDZiYzZhNDUwYmFjMjQ3ODlmYTE3MTE1YTRjOTczOWVkNzVmOGYyMWNlNDQxZjcyZTBiOTBlNmVmJyxcbiAgICAgICAgJzIxYWU3ZjQ2ODBlODg5YmIxMzA2MTllMmMwZjk1YTM2MGNlYjU3M2M3MDYwMzEzOTg2MmFmZDYxN2ZhOWI5ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNDdkNmQ5YTAyYzQ4OTI3ZWJmYjg2YzEzNTliMWNhZjEzMGEzYzAyNjdkMTFjZTYzNDRiMzlmOTlkNDNjYzM4JyxcbiAgICAgICAgJzYwZWE3ZjYxYTM1MzUyNGQxYzk4N2Y2ZWNlYzkyZjA4NmQ1NjVhYjY4Nzg3MGNiMTI2ODlmZjFlMzFjNzQ0NDgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGE2NTQ1ZDIxODFkYjhkOTgzZjdkY2IzNzVlZjU4NjZkNDdjNjdiMWJmMzFjOGNmODU1ZWY3NDM3YjcyNjU2YScsXG4gICAgICAgICc0OWI5NjcxNWFiNjg3OGE3OWU3OGYwN2NlNTY4MGM1ZDY2NzMwNTFiNDkzNWJkODk3ZmVhODI0Yjc3ZGMyMDhhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M0MDc0N2NjOWQwMTJjYjFhMTNiODE0ODMwOWM2ZGU3ZWMyNWQ2OTQ1ZDY1NzE0NmI5ZDU5OTRiOGZlYjExMTEnLFxuICAgICAgICAnNWNhNTYwNzUzYmUyYTEyZmM2ZGU2Y2FmMmNiNDg5NTY1ZGI5MzYxNTZiOTUxNGUxYmI1ZTgzMDM3ZTBmYTJkNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ZTQyYzhlYzgyYzk5Nzk4Y2NmM2E2MTBiZTg3MGU3ODMzOGM3ZjcxMzM0OGJkMzRjODIwM2VmNDAzN2YzNTAyJyxcbiAgICAgICAgJzc1NzFkNzRlZTVlMGZiOTJhN2E4YjMzYTA3NzgzMzQxYTU0OTIxNDRjYzU0YmNjNDBhOTQ0NzM2OTM2MDY0MzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzc3NWFiNzA4OWJjNmFmODIzYWJhMmUxYWY3MGIyMzZkMjUxY2FkYjBjODY3NDMyODc1MjJhMWIzYjBkZWRlYScsXG4gICAgICAgICdiZTUyZDEwN2JjZmEwOWQ4YmNiOTczNmE4MjhjZmE3ZmFjOGRiMTdiZjdhNzZhMmM0MmFkOTYxNDA5MDE4Y2Y3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2NlZTMxY2JmN2UzNGVjMzc5ZDk0ZmI4MTRkM2Q3NzVhZDk1NDU5NWQxMzE0YmE4ODQ2OTU5ZTNlODJmNzRlMjYnLFxuICAgICAgICAnOGZkNjRhMTRjMDZiNTg5YzI2Yjk0N2FlMmJjZjZiZmEwMTQ5ZWYwYmUxNGVkNGQ4MGY0NDhhMDFjNDNiMWM2ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiNGY5ZWFlYTA5YjY5MTc2MTlmNmVhNmE0ZWI1NDY0ZWZkZGI1OGZkNDViMWViZWZjZGMxYTAxZDA4YjQ3OTg2JyxcbiAgICAgICAgJzM5ZTVjOTkyNWI1YTU0YjA3NDMzYTRmMThjNjE3MjZmOGJiMTMxYzAxMmNhNTQyZWIyNGE4YWMwNzIwMDY4MmEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDQyNjNkZmMzZDJkZjkyM2EwMTc5YTQ4OTY2ZDMwY2U4NGUyNTE1YWZjM2RjY2MxYjc3OTA3NzkyZWJjYzYwZScsXG4gICAgICAgICc2MmRmYWYwN2EwZjc4ZmViMzBlMzBkNjI5NTg1M2NlMTg5ZTEyNzc2MGFkNmNmN2ZhZTE2NGUxMjJhMjA4ZDU0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ4NDU3NTI0ODIwZmE2NWE0ZjhkMzVlYjY5MzA4NTdjMDAzMmFjYzBhNGEyZGU0MjIyMzNlZWRhODk3NjEyYzQnLFxuICAgICAgICAnMjVhNzQ4YWIzNjc5NzlkOTg3MzNjMzhhMWZhMWMyZTdkYzZjYzA3ZGIyZDYwYTlhZTdhNzZhYWE0OWJkMGY3NydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkZmVlZWYxODgxMTAxZjJjYjExNjQ0ZjNhMmFmZGZjMjA0NWUxOTkxOTE1MjkyM2YzNjdhMTc2N2MxMWNjZWRhJyxcbiAgICAgICAgJ2VjZmI3MDU2Y2YxZGUwNDJmOTQyMGJhYjM5Njc5M2MwYzM5MGJkZTc0YjRiYmRmZjE2YTgzYWUwOWE5YTc1MTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNmQ3ZWY2YjE3NTQzZjgzNzNjNTczZjQ0ZTFmMzg5ODM1ZDg5YmNiYzYwNjJjZWQzNmM4MmRmODNiOGZhZTg1OScsXG4gICAgICAgICdjZDQ1MGVjMzM1NDM4OTg2ZGZlZmExMGM1N2ZlYTliY2M1MjFhMDk1OWIyZDgwYmJmNzRiMTkwZGNhNzEyZDEwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U3NTYwNWQ1OTEwMmE1YTI2ODQ1MDBkM2I5OTFmMmUzZjNjODhiOTMyMjU1NDcwMzVhZjI1YWY2NmUwNDU0MWYnLFxuICAgICAgICAnZjVjNTQ3NTRhOGY3MWVlNTQwYjliNDg3Mjg0NzNlMzE0ZjcyOWFjNTMwOGIwNjkzODM2MDk5MGUyYmZhZDEyNSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYjk4NjYwZjRjNGRmYWEwNmEyYmU0NTNkNTAyMGJjOTlhMGMyZTYwYWJlMzg4NDU3ZGQ0M2ZlZmIxZWQ2MjBjJyxcbiAgICAgICAgJzZjYjlhODg3NmQ5Y2I4NTIwNjA5YWYzYWRkMjZjZDIwYTBhN2NkOGE5NDExMTMxY2U4NWY0NDEwMDA5OTIyM2UnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTNlODdiMDI3ZDg1MTRkMzU5MzlmMmU2ODkyYjE5OTIyMTU0NTk2OTQxODg4MzM2ZGMzNTYzZTNiOGRiYTk0MicsXG4gICAgICAgICdmZWY1YTNjNjgwNTlhNmRlYzVkNjI0MTE0YmYxZTkxYWFjMmI5ZGE1NjhkNmFiZWIyNTcwZDU1NjQ2YjhhZGYxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VlMTYzMDI2ZTlmZDZmZTAxN2MzOGYwNmE1YmU2ZmMxMjU0MjRiMzcxY2UyNzA4ZTdiZjQ0OTE2OTFlNTc2NGEnLFxuICAgICAgICAnMWFjYjI1MGYyNTVkZDYxYzQzZDk0Y2NjNjcwZDBmNThmNDlhZTNmYTE1Yjk2NjIzZTU0MzBkYTBhZDZjNjJiMidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiMjY4ZjVlZjlhZDUxZTRkNzhkZTNhNzUwYzJkYzg5YjFlNjI2ZDQzNTA1ODY3OTk5OTMyZTVkYjMzYWYzZDgwJyxcbiAgICAgICAgJzVmMzEwZDRiM2M5OWI5ZWJiMTlmNzdkNDFjMWRlZTAxOGNmMGQzNGZkNDE5MTYxNDAwM2U5NDVhMTIxNmU0MjMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmYwN2YzMTE4YTlkZjAzNWU5ZmFkODVlYjZjN2JmZTQyYjAyZjAxY2E5OWNlZWEzYmY3ZmZkYmE5M2M0NzUwZCcsXG4gICAgICAgICc0MzgxMzZkNjAzZTg1OGEzYTVjNDQwYzM4ZWNjYmFkZGMxZDI5NDIxMTRlMmVkZGQ0NzQwZDA5OGNlZDFmMGQ4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhkOGI5ODU1YzdjMDUyYTM0MTQ2ZmQyMGZmYjY1OGJlYTRiOWY2OWUwZDgyNWViZWMxNmU4YzNjZTJiNTI2YTEnLFxuICAgICAgICAnY2RiNTU5ZWVkYzJkNzlmOTI2YmFmNDRmYjg0ZWE0ZDQ0YmNmNTBmZWU1MWQ3Y2ViMzBlMmU3ZjQ2MzAzNjc1OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1MmRiMGI1Mzg0ZGZiZjA1YmZhOWQ0NzJkN2FlMjZkZmU0Yjg1MWNlY2E5MWIxZWJhNTQyNjMxODBkYTMyYjYzJyxcbiAgICAgICAgJ2MzYjk5N2QwNTBlZTVkNDIzZWJhZjY2YTZkYjlmNTdiMzE4MGM5MDI4NzU2NzlkZTkyNGI2OWQ4NGE3YjM3NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlNjJmOTQ5MGQzZDUxZGE2Mzk1ZWZkMjRlODA5MTljYzdkMGYyOWMzZjNmYTQ4YzZmZmY1NDNiZWNiZDQzMzUyJyxcbiAgICAgICAgJzZkODlhZDdiYTQ4NzZiMGIyMmMyY2EyODBjNjgyODYyZjM0MmM4NTkxZjFkYWY1MTcwZTA3YmZkOWNjYWZhN2QnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnN2YzMGVhMjQ3NmIzOTliNDk1NzUwOWM4OGY3N2QwMTkxYWZhMmZmNWNiN2IxNGZkNmQ4ZTdkNjVhYWFiMTE5MycsXG4gICAgICAgICdjYTVlZjdkNGIyMzFjOTRjM2IxNTM4OWE1ZjYzMTFlOWRhZmY3YmI2N2IxMDNlOTg4MGVmNGJmZjYzN2FjYWVjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzUwOThmZjFlMWQ5ZjE0ZmI0NmEyMTBmYWRhNmM5MDNmZWYwZmI3YjRhMWRkMWQ5YWM2MGEwMzYxODAwYjdhMDAnLFxuICAgICAgICAnOTczMTE0MWQ4MWZjOGY4MDg0ZDM3YzZlNzU0MjAwNmIzZWUxYjQwZDYwZGZlNTM2MmE1YjEzMmZkMTdkZGMwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMyYjc4YzdkZTllZTUxMmE3Mjg5NWJlNmI5Y2JlZmE2ZTJmM2M0Y2NjZTQ0NWM5NmI5ZjJjODFlMjc3OGFkNTgnLFxuICAgICAgICAnZWUxODQ5ZjUxM2RmNzFlMzJlZmMzODk2ZWUyODI2MGM3M2JiODA1NDdhZTIyNzViYTQ5NzIzNzc5NGM4NzUzYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlMmNiNzRmZGRjOGU5ZmJjZDA3NmVlZjJhN2M3MmIwY2UzN2Q1MGYwODI2OWRmYzA3NGI1ODE1NTA1NDdhNGY3JyxcbiAgICAgICAgJ2QzYWEyZWQ3MWM5ZGQyMjQ3YTYyZGYwNjI3MzZlYjBiYWRkZWE5ZTM2MTIyZDJiZTg2NDFhYmNiMDA1Y2M0YTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODQzODQ0NzU2NmQ0ZDdiZWRhZGMyOTk0OTZhYjM1NzQyNjAwOWEzNWYyMzVjYjE0MWJlMGQ5OWNkMTBhZTNhOCcsXG4gICAgICAgICdjNGUxMDIwOTE2OTgwYTRkYTVkMDFhYzVlNmFkMzMwNzM0ZWYwZDc5MDY2MzFjNGYyMzkwNDI2YjJlZGQ3OTFmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQxNjJkNDg4Yjg5NDAyMDM5YjU4NGM2ZmM2YzMwODg3MDU4N2Q5YzQ2ZjY2MGI4NzhhYjY1YzgyYzcxMWQ2N2UnLFxuICAgICAgICAnNjcxNjNlOTAzMjM2Mjg5Zjc3NmYyMmMyNWZiOGEzYWZjMTczMmYyYjg0YjRlOTVkYmRhNDdhZTVhMDg1MjY0OSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczZmFkM2ZhODRjYWYwZjM0ZjBmODliZmQyZGNmNTRmYzE3NWQ3NjdhZWMzZTUwNjg0ZjNiYTRhNGJmNWY2ODNkJyxcbiAgICAgICAgJ2NkMWJjN2NiNmNjNDA3YmIyZjBjYTY0N2M3MThhNzMwY2Y3MTg3MmU3ZDBkMmE1M2ZhMjBlZmNkZmU2MTgyNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2NzRmMjYwMGEzMDA3YTAwNTY4YzFhN2NlMDVkMDgxNmMxZmI4NGJmMTM3MDc5OGYxYzY5NTMyZmFlYjFhODZiJyxcbiAgICAgICAgJzI5OWQyMWY5NDEzZjMzYjNlZGY0M2IyNTcwMDQ1ODBiNzBkYjU3ZGEwYjE4MjI1OWUwOWVlY2M2OWUwZDM4YTUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDMyZjRkYTU0YWRlNzRhYmI4MWI4MTVhZDFmYjNiMjYzZDgyZDZjNjkyNzE0YmNmZjg3ZDI5YmQ1ZWU5ZjA4ZicsXG4gICAgICAgICdmOTQyOWU3MzhiOGU1M2I5NjhlOTkwMTZjMDU5NzA3NzgyZTE0ZjQ1MzUzNTlkNTgyZmM0MTY5MTBiM2VlYTg3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMwZTRlNjcwNDM1Mzg1NTU2ZTU5MzY1NzEzNTg0NWQzNmZiYjY5MzFmNzJiMDhjYjFlZDk1NGYxZTNjZTNmZjYnLFxuICAgICAgICAnNDYyZjliY2U2MTk4OTg2Mzg0OTkzNTAxMTNiYmM5YjEwYTg3OGQzNWRhNzA3NDBkYzY5NWE1NTllYjg4ZGI3YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiZTIwNjIwMDNjNTFjYzMwMDQ2ODI5MDQzMzBlNGRlZTdmM2RjZDEwYjAxZTU4MGJmMTk3MWIwNGQ0Y2FkMjk3JyxcbiAgICAgICAgJzYyMTg4YmM0OWQ2MWU1NDI4NTczZDQ4YTc0ZTFjNjU1YjFjNjEwOTA5MDU2ODJhMGQ1NTU4ZWQ3MmRjY2I5YmMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTMxNDQ0MjNhY2UzNDUxZWQyOWUwZmI5YWMyYWYyMTFjYjZlODRhNjAxZGY1OTkzYzQxOTg1OWZmZjVkZjA0YScsXG4gICAgICAgICc3YzEwZGZiMTY0YzM0MjVmNWM3MWEzZjlkNzk5MjAzOGYxMDY1MjI0ZjcyYmI5ZDFkOTAyYTZkMTMwMzdiNDdjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2IwMTVmODA0NGY1ZmNiZGNmMjFjYTI2ZDZjMzRmYjgxOTc4MjkyMDVjN2I3ZDJhN2NiNjY0MThjMTU3YjExMmMnLFxuICAgICAgICAnYWI4YzFlMDg2ZDA0ZTgxMzc0NGE2NTViMmRmOGQ1ZjgzYjNjZGM2ZmFhMzA4OGMxZDNhZWExNDU0ZTNhMWQ1ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkNWU5ZTFkYTY0OWQ5N2Q4OWU0ODY4MTE3YTQ2NWEzYTRmOGExOGRlNTdhMTQwZDM2YjNmMmFmMzQxYTIxYjUyJyxcbiAgICAgICAgJzRjYjA0NDM3ZjM5MWVkNzMxMTFhMTNjYzFkNGRkMGRiMTY5MzQ2NWMyMjQwNDgwZDg5NTVlODU5MmYyNzQ0N2EnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDNhZTQxMDQ3ZGQ3Y2EwNjVkYmY4ZWQ3N2I5OTI0Mzk5ODMwMDVjZDcyZTE2ZDZmOTk2YTUzMTZkMzY5NjZiYicsXG4gICAgICAgICdiZDFhZWIyMWFkMjJlYmIyMmExMGYwMzAzNDE3YzZkOTY0ZjhjZGQ3ZGYwYWNhNjE0YjEwZGMxNGQxMjVhYzQ2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ2M2UyNzYzZDg4NWY5NThmYzY2Y2RkMjI4MDBmMGE0ODcxOTdkMGE4MmUzNzdiNDlmODBhZjg3Yzg5N2IwNjUnLFxuICAgICAgICAnYmZlZmFjZGIwZTVkMGZkN2RmM2EzMTFhOTRkZTA2MmIyNmI4MGM2MWZiYzk3NTA4Yjc5OTkyNjcxZWY3Y2E3ZidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3OTg1ZmRmZDEyN2MwNTY3YzZmNTNlYzFiYjYzZWMzMTU4ZTU5N2M0MGJmZTc0N2M4M2NkZGZjOTEwNjQxOTE3JyxcbiAgICAgICAgJzYwM2MxMmRhZjNkOTg2MmVmMmIyNWZlMWRlMjg5YWVkMjRlZDI5MWUwZWM2NzA4NzAzYTViZDU2N2YzMmVkMDMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzRhMWFkNmI1Zjc2ZTM5ZGIyZGQyNDk0MTBlYWM3Zjk5ZTc0YzU5Y2I4M2QyZDBlZDVmZjE1NDNkYTc3MDNlOScsXG4gICAgICAgICdjYzYxNTdlZjE4YzljNjNjZDYxOTNkODM2MzFiYmVhMDA5M2UwOTY4OTQyZThjMzNkNTczN2ZkNzkwZTBkYjA4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMwNjgyYTUwNzAzMzc1ZjYwMmQ0MTY2NjRiYTE5YjdmYzliYWI0MmM3Mjc0NzQ2M2E3MWQwODk2YjIyZjZkYTMnLFxuICAgICAgICAnNTUzZTA0ZjZiMDE4YjRmYTZjOGYzOWU3ZjMxMWQzMTc2MjkwZDBlMGYxOWNhNzNmMTc3MTRkOTk3N2EyMmZmOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5ZTIxNThmMGQ3YzBkNWYyNmMzNzkxZWZlZmE3OTU5NzY1NGU3YTJiMjQ2NGY1MmIxZWU2YzEzNDc3NjllZjU3JyxcbiAgICAgICAgJzcxMmZjZGQxYjkwNTNmMDkwMDNhMzQ4MWZhNzc2MmU5ZmZkN2M4ZWYzNWEzODUwOWUyZmJmMjYyOTAwODM3MydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNzZlMjY5ODlhNDNjOWNmZWJhNDAyOWMyMDI1MzhjMjgxNzJlNTY2ZTNjNGZjZTczMjI4NTdmM2JlMzI3ZDY2JyxcbiAgICAgICAgJ2VkOGNjOWQwNGIyOWViODc3ZDI3MGI0ODc4ZGM0M2MxOWFlZmQzMWY0ZWVlMDllZTdiNDc4MzRjMWZhNGIxYzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzVkNDZlZmVhMzc3MWU2ZTY4YWJiODlhMTNhZDc0N2VjZjE4OTIzOTNkZmM0ZjFiNzAwNDc4OGM1MDM3NGRhOCcsXG4gICAgICAgICc5ODUyMzkwYTk5NTA3Njc5ZmQwYjg2ZmQyYjM5YTg2OGQ3ZWZjMjIxNTEzNDZlMWEzY2E0NzI2NTg2YTZiZWQ4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzgwOWEyMGM2N2Q2NDkwMGZmYjY5OGM0YzgyNWY2ZDVmMjMxMGZiMDQ1MWM4NjkzNDViNzMxOWY2NDU2MDU3MjEnLFxuICAgICAgICAnOWU5OTQ5ODBkOTkxN2UyMmI3NmIwNjE5MjdmYTA0MTQzZDA5NmNjYzU0OTYzZTZhNWViZmE1ZjNmOGUyODZjMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxYjM4OTAzYTQzZjdmMTE0ZWQ0NTAwYjRlYWM3MDgzZmRlZmVjZTFjZjI5YzYzNTI4ZDU2MzQ0NmY5NzJjMTgwJyxcbiAgICAgICAgJzQwMzZlZGM5MzFhNjBhZTg4OTM1M2Y3N2ZkNTNkZTRhMjcwOGIyNmI2ZjVkYTcyYWQzMzk0MTE5ZGFmNDA4ZjknXG4gICAgICBdXG4gICAgXVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSBleHBvcnRzO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBtaW5Bc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG52YXIgbWluVXRpbHMgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtY3J5cHRvLXV0aWxzJyk7XG5cbnV0aWxzLmFzc2VydCA9IG1pbkFzc2VydDtcbnV0aWxzLnRvQXJyYXkgPSBtaW5VdGlscy50b0FycmF5O1xudXRpbHMuemVybzIgPSBtaW5VdGlscy56ZXJvMjtcbnV0aWxzLnRvSGV4ID0gbWluVXRpbHMudG9IZXg7XG51dGlscy5lbmNvZGUgPSBtaW5VdGlscy5lbmNvZGU7XG5cbi8vIFJlcHJlc2VudCBudW0gaW4gYSB3LU5BRiBmb3JtXG5mdW5jdGlvbiBnZXROQUYobnVtLCB3KSB7XG4gIHZhciBuYWYgPSBbXTtcbiAgdmFyIHdzID0gMSA8PCAodyArIDEpO1xuICB2YXIgayA9IG51bS5jbG9uZSgpO1xuICB3aGlsZSAoay5jbXBuKDEpID49IDApIHtcbiAgICB2YXIgejtcbiAgICBpZiAoay5pc09kZCgpKSB7XG4gICAgICB2YXIgbW9kID0gay5hbmRsbih3cyAtIDEpO1xuICAgICAgaWYgKG1vZCA+ICh3cyA+PiAxKSAtIDEpXG4gICAgICAgIHogPSAod3MgPj4gMSkgLSBtb2Q7XG4gICAgICBlbHNlXG4gICAgICAgIHogPSBtb2Q7XG4gICAgICBrLmlzdWJuKHopO1xuICAgIH0gZWxzZSB7XG4gICAgICB6ID0gMDtcbiAgICB9XG4gICAgbmFmLnB1c2goeik7XG5cbiAgICAvLyBPcHRpbWl6YXRpb24sIHNoaWZ0IGJ5IHdvcmQgaWYgcG9zc2libGVcbiAgICB2YXIgc2hpZnQgPSAoay5jbXBuKDApICE9PSAwICYmIGsuYW5kbG4od3MgLSAxKSA9PT0gMCkgPyAodyArIDEpIDogMTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHNoaWZ0OyBpKyspXG4gICAgICBuYWYucHVzaCgwKTtcbiAgICBrLml1c2hybihzaGlmdCk7XG4gIH1cblxuICByZXR1cm4gbmFmO1xufVxudXRpbHMuZ2V0TkFGID0gZ2V0TkFGO1xuXG4vLyBSZXByZXNlbnQgazEsIGsyIGluIGEgSm9pbnQgU3BhcnNlIEZvcm1cbmZ1bmN0aW9uIGdldEpTRihrMSwgazIpIHtcbiAgdmFyIGpzZiA9IFtcbiAgICBbXSxcbiAgICBbXVxuICBdO1xuXG4gIGsxID0gazEuY2xvbmUoKTtcbiAgazIgPSBrMi5jbG9uZSgpO1xuICB2YXIgZDEgPSAwO1xuICB2YXIgZDIgPSAwO1xuICB3aGlsZSAoazEuY21wbigtZDEpID4gMCB8fCBrMi5jbXBuKC1kMikgPiAwKSB7XG5cbiAgICAvLyBGaXJzdCBwaGFzZVxuICAgIHZhciBtMTQgPSAoazEuYW5kbG4oMykgKyBkMSkgJiAzO1xuICAgIHZhciBtMjQgPSAoazIuYW5kbG4oMykgKyBkMikgJiAzO1xuICAgIGlmIChtMTQgPT09IDMpXG4gICAgICBtMTQgPSAtMTtcbiAgICBpZiAobTI0ID09PSAzKVxuICAgICAgbTI0ID0gLTE7XG4gICAgdmFyIHUxO1xuICAgIGlmICgobTE0ICYgMSkgPT09IDApIHtcbiAgICAgIHUxID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG04ID0gKGsxLmFuZGxuKDcpICsgZDEpICYgNztcbiAgICAgIGlmICgobTggPT09IDMgfHwgbTggPT09IDUpICYmIG0yNCA9PT0gMilcbiAgICAgICAgdTEgPSAtbTE0O1xuICAgICAgZWxzZVxuICAgICAgICB1MSA9IG0xNDtcbiAgICB9XG4gICAganNmWzBdLnB1c2godTEpO1xuXG4gICAgdmFyIHUyO1xuICAgIGlmICgobTI0ICYgMSkgPT09IDApIHtcbiAgICAgIHUyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG04ID0gKGsyLmFuZGxuKDcpICsgZDIpICYgNztcbiAgICAgIGlmICgobTggPT09IDMgfHwgbTggPT09IDUpICYmIG0xNCA9PT0gMilcbiAgICAgICAgdTIgPSAtbTI0O1xuICAgICAgZWxzZVxuICAgICAgICB1MiA9IG0yNDtcbiAgICB9XG4gICAganNmWzFdLnB1c2godTIpO1xuXG4gICAgLy8gU2Vjb25kIHBoYXNlXG4gICAgaWYgKDIgKiBkMSA9PT0gdTEgKyAxKVxuICAgICAgZDEgPSAxIC0gZDE7XG4gICAgaWYgKDIgKiBkMiA9PT0gdTIgKyAxKVxuICAgICAgZDIgPSAxIC0gZDI7XG4gICAgazEuaXVzaHJuKDEpO1xuICAgIGsyLml1c2hybigxKTtcbiAgfVxuXG4gIHJldHVybiBqc2Y7XG59XG51dGlscy5nZXRKU0YgPSBnZXRKU0Y7XG5cbmZ1bmN0aW9uIGNhY2hlZFByb3BlcnR5KG9iaiwgbmFtZSwgY29tcHV0ZXIpIHtcbiAgdmFyIGtleSA9ICdfJyArIG5hbWU7XG4gIG9iai5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiBjYWNoZWRQcm9wZXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpc1trZXldICE9PSB1bmRlZmluZWQgPyB0aGlzW2tleV0gOlxuICAgICAgICAgICB0aGlzW2tleV0gPSBjb21wdXRlci5jYWxsKHRoaXMpO1xuICB9O1xufVxudXRpbHMuY2FjaGVkUHJvcGVydHkgPSBjYWNoZWRQcm9wZXJ0eTtcblxuZnVuY3Rpb24gcGFyc2VCeXRlcyhieXRlcykge1xuICByZXR1cm4gdHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJyA/IHV0aWxzLnRvQXJyYXkoYnl0ZXMsICdoZXgnKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXM7XG59XG51dGlscy5wYXJzZUJ5dGVzID0gcGFyc2VCeXRlcztcblxuZnVuY3Rpb24gaW50RnJvbUxFKGJ5dGVzKSB7XG4gIHJldHVybiBuZXcgQk4oYnl0ZXMsICdoZXgnLCAnbGUnKTtcbn1cbnV0aWxzLmludEZyb21MRSA9IGludEZyb21MRTtcblxuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgTUQ1ID0gcmVxdWlyZSgnbWQ1LmpzJylcblxuLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG5mdW5jdGlvbiBFVlBfQnl0ZXNUb0tleSAocGFzc3dvcmQsIHNhbHQsIGtleUJpdHMsIGl2TGVuKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHBhc3N3b3JkKSkgcGFzc3dvcmQgPSBCdWZmZXIuZnJvbShwYXNzd29yZCwgJ2JpbmFyeScpXG4gIGlmIChzYWx0KSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoc2FsdCkpIHNhbHQgPSBCdWZmZXIuZnJvbShzYWx0LCAnYmluYXJ5JylcbiAgICBpZiAoc2FsdC5sZW5ndGggIT09IDgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzYWx0IHNob3VsZCBiZSBCdWZmZXIgd2l0aCA4IGJ5dGUgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBrZXlMZW4gPSBrZXlCaXRzIC8gOFxuICB2YXIga2V5ID0gQnVmZmVyLmFsbG9jKGtleUxlbilcbiAgdmFyIGl2ID0gQnVmZmVyLmFsbG9jKGl2TGVuIHx8IDApXG4gIHZhciB0bXAgPSBCdWZmZXIuYWxsb2MoMClcblxuICB3aGlsZSAoa2V5TGVuID4gMCB8fCBpdkxlbiA+IDApIHtcbiAgICB2YXIgaGFzaCA9IG5ldyBNRDUoKVxuICAgIGhhc2gudXBkYXRlKHRtcClcbiAgICBoYXNoLnVwZGF0ZShwYXNzd29yZClcbiAgICBpZiAoc2FsdCkgaGFzaC51cGRhdGUoc2FsdClcbiAgICB0bXAgPSBoYXNoLmRpZ2VzdCgpXG5cbiAgICB2YXIgdXNlZCA9IDBcblxuICAgIGlmIChrZXlMZW4gPiAwKSB7XG4gICAgICB2YXIga2V5U3RhcnQgPSBrZXkubGVuZ3RoIC0ga2V5TGVuXG4gICAgICB1c2VkID0gTWF0aC5taW4oa2V5TGVuLCB0bXAubGVuZ3RoKVxuICAgICAgdG1wLmNvcHkoa2V5LCBrZXlTdGFydCwgMCwgdXNlZClcbiAgICAgIGtleUxlbiAtPSB1c2VkXG4gICAgfVxuXG4gICAgaWYgKHVzZWQgPCB0bXAubGVuZ3RoICYmIGl2TGVuID4gMCkge1xuICAgICAgdmFyIGl2U3RhcnQgPSBpdi5sZW5ndGggLSBpdkxlblxuICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGl2TGVuLCB0bXAubGVuZ3RoIC0gdXNlZClcbiAgICAgIHRtcC5jb3B5KGl2LCBpdlN0YXJ0LCB1c2VkLCB1c2VkICsgbGVuZ3RoKVxuICAgICAgaXZMZW4gLT0gbGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdG1wLmZpbGwoMClcbiAgcmV0dXJuIHsga2V5OiBrZXksIGl2OiBpdiB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRVZQX0J5dGVzVG9LZXlcbiIsIid1c2Ugc3RyaWN0J1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbmZ1bmN0aW9uIHRocm93SWZOb3RTdHJpbmdPckJ1ZmZlciAodmFsLCBwcmVmaXgpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsKSAmJiB0eXBlb2YgdmFsICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocHJlZml4ICsgJyBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgYnVmZmVyJylcbiAgfVxufVxuXG5mdW5jdGlvbiBIYXNoQmFzZSAoYmxvY2tTaXplKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG5cbiAgdGhpcy5fYmxvY2sgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYmxvY2tTaXplKVxuICB0aGlzLl9ibG9ja1NpemUgPSBibG9ja1NpemVcbiAgdGhpcy5fYmxvY2tPZmZzZXQgPSAwXG4gIHRoaXMuX2xlbmd0aCA9IFswLCAwLCAwLCAwXVxuXG4gIHRoaXMuX2ZpbmFsaXplZCA9IGZhbHNlXG59XG5cbmluaGVyaXRzKEhhc2hCYXNlLCBUcmFuc2Zvcm0pXG5cbkhhc2hCYXNlLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgdmFyIGVycm9yID0gbnVsbFxuICB0cnkge1xuICAgIHRoaXMudXBkYXRlKGNodW5rLCBlbmNvZGluZylcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3IgPSBlcnJcbiAgfVxuXG4gIGNhbGxiYWNrKGVycm9yKVxufVxuXG5IYXNoQmFzZS5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciBlcnJvciA9IG51bGxcbiAgdHJ5IHtcbiAgICB0aGlzLnB1c2godGhpcy5kaWdlc3QoKSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3IgPSBlcnJcbiAgfVxuXG4gIGNhbGxiYWNrKGVycm9yKVxufVxuXG5IYXNoQmFzZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nKSB7XG4gIHRocm93SWZOb3RTdHJpbmdPckJ1ZmZlcihkYXRhLCAnRGF0YScpXG4gIGlmICh0aGlzLl9maW5hbGl6ZWQpIHRocm93IG5ldyBFcnJvcignRGlnZXN0IGFscmVhZHkgY2FsbGVkJylcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCBlbmNvZGluZylcblxuICAvLyBjb25zdW1lIGRhdGFcbiAgdmFyIGJsb2NrID0gdGhpcy5fYmxvY2tcbiAgdmFyIG9mZnNldCA9IDBcbiAgd2hpbGUgKHRoaXMuX2Jsb2NrT2Zmc2V0ICsgZGF0YS5sZW5ndGggLSBvZmZzZXQgPj0gdGhpcy5fYmxvY2tTaXplKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX2Jsb2NrT2Zmc2V0OyBpIDwgdGhpcy5fYmxvY2tTaXplOykgYmxvY2tbaSsrXSA9IGRhdGFbb2Zmc2V0KytdXG4gICAgdGhpcy5fdXBkYXRlKClcbiAgICB0aGlzLl9ibG9ja09mZnNldCA9IDBcbiAgfVxuICB3aGlsZSAob2Zmc2V0IDwgZGF0YS5sZW5ndGgpIGJsb2NrW3RoaXMuX2Jsb2NrT2Zmc2V0KytdID0gZGF0YVtvZmZzZXQrK11cblxuICAvLyB1cGRhdGUgbGVuZ3RoXG4gIGZvciAodmFyIGogPSAwLCBjYXJyeSA9IGRhdGEubGVuZ3RoICogODsgY2FycnkgPiAwOyArK2opIHtcbiAgICB0aGlzLl9sZW5ndGhbal0gKz0gY2FycnlcbiAgICBjYXJyeSA9ICh0aGlzLl9sZW5ndGhbal0gLyAweDAxMDAwMDAwMDApIHwgMFxuICAgIGlmIChjYXJyeSA+IDApIHRoaXMuX2xlbmd0aFtqXSAtPSAweDAxMDAwMDAwMDAgKiBjYXJyeVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuSGFzaEJhc2UucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3VwZGF0ZSBpcyBub3QgaW1wbGVtZW50ZWQnKVxufVxuXG5IYXNoQmFzZS5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGlmICh0aGlzLl9maW5hbGl6ZWQpIHRocm93IG5ldyBFcnJvcignRGlnZXN0IGFscmVhZHkgY2FsbGVkJylcbiAgdGhpcy5fZmluYWxpemVkID0gdHJ1ZVxuXG4gIHZhciBkaWdlc3QgPSB0aGlzLl9kaWdlc3QoKVxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkgZGlnZXN0ID0gZGlnZXN0LnRvU3RyaW5nKGVuY29kaW5nKVxuXG4gIC8vIHJlc2V0IHN0YXRlXG4gIHRoaXMuX2Jsb2NrLmZpbGwoMClcbiAgdGhpcy5fYmxvY2tPZmZzZXQgPSAwXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB0aGlzLl9sZW5ndGhbaV0gPSAwXG5cbiAgcmV0dXJuIGRpZ2VzdFxufVxuXG5IYXNoQmFzZS5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfZGlnZXN0IGlzIG5vdCBpbXBsZW1lbnRlZCcpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaEJhc2VcbiIsInZhciBoYXNoID0gZXhwb3J0cztcblxuaGFzaC51dGlscyA9IHJlcXVpcmUoJy4vaGFzaC91dGlscycpO1xuaGFzaC5jb21tb24gPSByZXF1aXJlKCcuL2hhc2gvY29tbW9uJyk7XG5oYXNoLnNoYSA9IHJlcXVpcmUoJy4vaGFzaC9zaGEnKTtcbmhhc2gucmlwZW1kID0gcmVxdWlyZSgnLi9oYXNoL3JpcGVtZCcpO1xuaGFzaC5obWFjID0gcmVxdWlyZSgnLi9oYXNoL2htYWMnKTtcblxuLy8gUHJveHkgaGFzaCBmdW5jdGlvbnMgdG8gdGhlIG1haW4gb2JqZWN0XG5oYXNoLnNoYTEgPSBoYXNoLnNoYS5zaGExO1xuaGFzaC5zaGEyNTYgPSBoYXNoLnNoYS5zaGEyNTY7XG5oYXNoLnNoYTIyNCA9IGhhc2guc2hhLnNoYTIyNDtcbmhhc2guc2hhMzg0ID0gaGFzaC5zaGEuc2hhMzg0O1xuaGFzaC5zaGE1MTIgPSBoYXNoLnNoYS5zaGE1MTI7XG5oYXNoLnJpcGVtZDE2MCA9IGhhc2gucmlwZW1kLnJpcGVtZDE2MDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxuZnVuY3Rpb24gQmxvY2tIYXNoKCkge1xuICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdUb3RhbCA9IDA7XG4gIHRoaXMuYmxvY2tTaXplID0gdGhpcy5jb25zdHJ1Y3Rvci5ibG9ja1NpemU7XG4gIHRoaXMub3V0U2l6ZSA9IHRoaXMuY29uc3RydWN0b3Iub3V0U2l6ZTtcbiAgdGhpcy5obWFjU3RyZW5ndGggPSB0aGlzLmNvbnN0cnVjdG9yLmhtYWNTdHJlbmd0aDtcbiAgdGhpcy5wYWRMZW5ndGggPSB0aGlzLmNvbnN0cnVjdG9yLnBhZExlbmd0aCAvIDg7XG4gIHRoaXMuZW5kaWFuID0gJ2JpZyc7XG5cbiAgdGhpcy5fZGVsdGE4ID0gdGhpcy5ibG9ja1NpemUgLyA4O1xuICB0aGlzLl9kZWx0YTMyID0gdGhpcy5ibG9ja1NpemUgLyAzMjtcbn1cbmV4cG9ydHMuQmxvY2tIYXNoID0gQmxvY2tIYXNoO1xuXG5CbG9ja0hhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIGVuYykge1xuICAvLyBDb252ZXJ0IG1lc3NhZ2UgdG8gYXJyYXksIHBhZCBpdCwgYW5kIGpvaW4gaW50byAzMmJpdCBibG9ja3NcbiAgbXNnID0gdXRpbHMudG9BcnJheShtc2csIGVuYyk7XG4gIGlmICghdGhpcy5wZW5kaW5nKVxuICAgIHRoaXMucGVuZGluZyA9IG1zZztcbiAgZWxzZVxuICAgIHRoaXMucGVuZGluZyA9IHRoaXMucGVuZGluZy5jb25jYXQobXNnKTtcbiAgdGhpcy5wZW5kaW5nVG90YWwgKz0gbXNnLmxlbmd0aDtcblxuICAvLyBFbm91Z2ggZGF0YSwgdHJ5IHVwZGF0aW5nXG4gIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID49IHRoaXMuX2RlbHRhOCkge1xuICAgIG1zZyA9IHRoaXMucGVuZGluZztcblxuICAgIC8vIFByb2Nlc3MgcGVuZGluZyBkYXRhIGluIGJsb2Nrc1xuICAgIHZhciByID0gbXNnLmxlbmd0aCAlIHRoaXMuX2RlbHRhODtcbiAgICB0aGlzLnBlbmRpbmcgPSBtc2cuc2xpY2UobXNnLmxlbmd0aCAtIHIsIG1zZy5sZW5ndGgpO1xuICAgIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcblxuICAgIG1zZyA9IHV0aWxzLmpvaW4zMihtc2csIDAsIG1zZy5sZW5ndGggLSByLCB0aGlzLmVuZGlhbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IHRoaXMuX2RlbHRhMzIpXG4gICAgICB0aGlzLl91cGRhdGUobXNnLCBpLCBpICsgdGhpcy5fZGVsdGEzMik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICB0aGlzLnVwZGF0ZSh0aGlzLl9wYWQoKSk7XG4gIGFzc2VydCh0aGlzLnBlbmRpbmcgPT09IG51bGwpO1xuXG4gIHJldHVybiB0aGlzLl9kaWdlc3QoZW5jKTtcbn07XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUuX3BhZCA9IGZ1bmN0aW9uIHBhZCgpIHtcbiAgdmFyIGxlbiA9IHRoaXMucGVuZGluZ1RvdGFsO1xuICB2YXIgYnl0ZXMgPSB0aGlzLl9kZWx0YTg7XG4gIHZhciBrID0gYnl0ZXMgLSAoKGxlbiArIHRoaXMucGFkTGVuZ3RoKSAlIGJ5dGVzKTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShrICsgdGhpcy5wYWRMZW5ndGgpO1xuICByZXNbMF0gPSAweDgwO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGs7IGkrKylcbiAgICByZXNbaV0gPSAwO1xuXG4gIC8vIEFwcGVuZCBsZW5ndGhcbiAgbGVuIDw8PSAzO1xuICBpZiAodGhpcy5lbmRpYW4gPT09ICdiaWcnKSB7XG4gICAgZm9yICh2YXIgdCA9IDg7IHQgPCB0aGlzLnBhZExlbmd0aDsgdCsrKVxuICAgICAgcmVzW2krK10gPSAwO1xuXG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMjQpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiA4KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSBsZW4gJiAweGZmO1xuICB9IGVsc2Uge1xuICAgIHJlc1tpKytdID0gbGVuICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDgpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAyNCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcblxuICAgIGZvciAodCA9IDg7IHQgPCB0aGlzLnBhZExlbmd0aDsgdCsrKVxuICAgICAgcmVzW2krK10gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG5cbmZ1bmN0aW9uIEhtYWMoaGFzaCwga2V5LCBlbmMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhtYWMpKVxuICAgIHJldHVybiBuZXcgSG1hYyhoYXNoLCBrZXksIGVuYyk7XG4gIHRoaXMuSGFzaCA9IGhhc2g7XG4gIHRoaXMuYmxvY2tTaXplID0gaGFzaC5ibG9ja1NpemUgLyA4O1xuICB0aGlzLm91dFNpemUgPSBoYXNoLm91dFNpemUgLyA4O1xuICB0aGlzLmlubmVyID0gbnVsbDtcbiAgdGhpcy5vdXRlciA9IG51bGw7XG5cbiAgdGhpcy5faW5pdCh1dGlscy50b0FycmF5KGtleSwgZW5jKSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEhtYWM7XG5cbkhtYWMucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdChrZXkpIHtcbiAgLy8gU2hvcnRlbiBrZXksIGlmIG5lZWRlZFxuICBpZiAoa2V5Lmxlbmd0aCA+IHRoaXMuYmxvY2tTaXplKVxuICAgIGtleSA9IG5ldyB0aGlzLkhhc2goKS51cGRhdGUoa2V5KS5kaWdlc3QoKTtcbiAgYXNzZXJ0KGtleS5sZW5ndGggPD0gdGhpcy5ibG9ja1NpemUpO1xuXG4gIC8vIEFkZCBwYWRkaW5nIHRvIGtleVxuICBmb3IgKHZhciBpID0ga2V5Lmxlbmd0aDsgaSA8IHRoaXMuYmxvY2tTaXplOyBpKyspXG4gICAga2V5LnB1c2goMCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKylcbiAgICBrZXlbaV0gXj0gMHgzNjtcbiAgdGhpcy5pbm5lciA9IG5ldyB0aGlzLkhhc2goKS51cGRhdGUoa2V5KTtcblxuICAvLyAweDM2IF4gMHg1YyA9IDB4NmFcbiAgZm9yIChpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKylcbiAgICBrZXlbaV0gXj0gMHg2YTtcbiAgdGhpcy5vdXRlciA9IG5ldyB0aGlzLkhhc2goKS51cGRhdGUoa2V5KTtcbn07XG5cbkhtYWMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIGVuYykge1xuICB0aGlzLmlubmVyLnVwZGF0ZShtc2csIGVuYyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuSG1hYy5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICB0aGlzLm91dGVyLnVwZGF0ZSh0aGlzLmlubmVyLmRpZ2VzdCgpKTtcbiAgcmV0dXJuIHRoaXMub3V0ZXIuZGlnZXN0KGVuYyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxudmFyIHJvdGwzMiA9IHV0aWxzLnJvdGwzMjtcbnZhciBzdW0zMiA9IHV0aWxzLnN1bTMyO1xudmFyIHN1bTMyXzMgPSB1dGlscy5zdW0zMl8zO1xudmFyIHN1bTMyXzQgPSB1dGlscy5zdW0zMl80O1xudmFyIEJsb2NrSGFzaCA9IGNvbW1vbi5CbG9ja0hhc2g7XG5cbmZ1bmN0aW9uIFJJUEVNRDE2MCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJJUEVNRDE2MCkpXG4gICAgcmV0dXJuIG5ldyBSSVBFTUQxNjAoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcblxuICB0aGlzLmggPSBbIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjAgXTtcbiAgdGhpcy5lbmRpYW4gPSAnbGl0dGxlJztcbn1cbnV0aWxzLmluaGVyaXRzKFJJUEVNRDE2MCwgQmxvY2tIYXNoKTtcbmV4cG9ydHMucmlwZW1kMTYwID0gUklQRU1EMTYwO1xuXG5SSVBFTUQxNjAuYmxvY2tTaXplID0gNTEyO1xuUklQRU1EMTYwLm91dFNpemUgPSAxNjA7XG5SSVBFTUQxNjAuaG1hY1N0cmVuZ3RoID0gMTkyO1xuUklQRU1EMTYwLnBhZExlbmd0aCA9IDY0O1xuXG5SSVBFTUQxNjAucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobXNnLCBzdGFydCkge1xuICB2YXIgQSA9IHRoaXMuaFswXTtcbiAgdmFyIEIgPSB0aGlzLmhbMV07XG4gIHZhciBDID0gdGhpcy5oWzJdO1xuICB2YXIgRCA9IHRoaXMuaFszXTtcbiAgdmFyIEUgPSB0aGlzLmhbNF07XG4gIHZhciBBaCA9IEE7XG4gIHZhciBCaCA9IEI7XG4gIHZhciBDaCA9IEM7XG4gIHZhciBEaCA9IEQ7XG4gIHZhciBFaCA9IEU7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7IGorKykge1xuICAgIHZhciBUID0gc3VtMzIoXG4gICAgICByb3RsMzIoXG4gICAgICAgIHN1bTMyXzQoQSwgZihqLCBCLCBDLCBEKSwgbXNnW3Jbal0gKyBzdGFydF0sIEsoaikpLFxuICAgICAgICBzW2pdKSxcbiAgICAgIEUpO1xuICAgIEEgPSBFO1xuICAgIEUgPSBEO1xuICAgIEQgPSByb3RsMzIoQywgMTApO1xuICAgIEMgPSBCO1xuICAgIEIgPSBUO1xuICAgIFQgPSBzdW0zMihcbiAgICAgIHJvdGwzMihcbiAgICAgICAgc3VtMzJfNChBaCwgZig3OSAtIGosIEJoLCBDaCwgRGgpLCBtc2dbcmhbal0gKyBzdGFydF0sIEtoKGopKSxcbiAgICAgICAgc2hbal0pLFxuICAgICAgRWgpO1xuICAgIEFoID0gRWg7XG4gICAgRWggPSBEaDtcbiAgICBEaCA9IHJvdGwzMihDaCwgMTApO1xuICAgIENoID0gQmg7XG4gICAgQmggPSBUO1xuICB9XG4gIFQgPSBzdW0zMl8zKHRoaXMuaFsxXSwgQywgRGgpO1xuICB0aGlzLmhbMV0gPSBzdW0zMl8zKHRoaXMuaFsyXSwgRCwgRWgpO1xuICB0aGlzLmhbMl0gPSBzdW0zMl8zKHRoaXMuaFszXSwgRSwgQWgpO1xuICB0aGlzLmhbM10gPSBzdW0zMl8zKHRoaXMuaFs0XSwgQSwgQmgpO1xuICB0aGlzLmhbNF0gPSBzdW0zMl8zKHRoaXMuaFswXSwgQiwgQ2gpO1xuICB0aGlzLmhbMF0gPSBUO1xufTtcblxuUklQRU1EMTYwLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdsaXR0bGUnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2xpdHRsZScpO1xufTtcblxuZnVuY3Rpb24gZihqLCB4LCB5LCB6KSB7XG4gIGlmIChqIDw9IDE1KVxuICAgIHJldHVybiB4IF4geSBeIHo7XG4gIGVsc2UgaWYgKGogPD0gMzEpXG4gICAgcmV0dXJuICh4ICYgeSkgfCAoKH54KSAmIHopO1xuICBlbHNlIGlmIChqIDw9IDQ3KVxuICAgIHJldHVybiAoeCB8ICh+eSkpIF4gejtcbiAgZWxzZSBpZiAoaiA8PSA2MylcbiAgICByZXR1cm4gKHggJiB6KSB8ICh5ICYgKH56KSk7XG4gIGVsc2VcbiAgICByZXR1cm4geCBeICh5IHwgKH56KSk7XG59XG5cbmZ1bmN0aW9uIEsoaikge1xuICBpZiAoaiA8PSAxNSlcbiAgICByZXR1cm4gMHgwMDAwMDAwMDtcbiAgZWxzZSBpZiAoaiA8PSAzMSlcbiAgICByZXR1cm4gMHg1YTgyNzk5OTtcbiAgZWxzZSBpZiAoaiA8PSA0NylcbiAgICByZXR1cm4gMHg2ZWQ5ZWJhMTtcbiAgZWxzZSBpZiAoaiA8PSA2MylcbiAgICByZXR1cm4gMHg4ZjFiYmNkYztcbiAgZWxzZVxuICAgIHJldHVybiAweGE5NTNmZDRlO1xufVxuXG5mdW5jdGlvbiBLaChqKSB7XG4gIGlmIChqIDw9IDE1KVxuICAgIHJldHVybiAweDUwYTI4YmU2O1xuICBlbHNlIGlmIChqIDw9IDMxKVxuICAgIHJldHVybiAweDVjNGRkMTI0O1xuICBlbHNlIGlmIChqIDw9IDQ3KVxuICAgIHJldHVybiAweDZkNzAzZWYzO1xuICBlbHNlIGlmIChqIDw9IDYzKVxuICAgIHJldHVybiAweDdhNmQ3NmU5O1xuICBlbHNlXG4gICAgcmV0dXJuIDB4MDAwMDAwMDA7XG59XG5cbnZhciByID0gW1xuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICA3LCA0LCAxMywgMSwgMTAsIDYsIDE1LCAzLCAxMiwgMCwgOSwgNSwgMiwgMTQsIDExLCA4LFxuICAzLCAxMCwgMTQsIDQsIDksIDE1LCA4LCAxLCAyLCA3LCAwLCA2LCAxMywgMTEsIDUsIDEyLFxuICAxLCA5LCAxMSwgMTAsIDAsIDgsIDEyLCA0LCAxMywgMywgNywgMTUsIDE0LCA1LCA2LCAyLFxuICA0LCAwLCA1LCA5LCA3LCAxMiwgMiwgMTAsIDE0LCAxLCAzLCA4LCAxMSwgNiwgMTUsIDEzXG5dO1xuXG52YXIgcmggPSBbXG4gIDUsIDE0LCA3LCAwLCA5LCAyLCAxMSwgNCwgMTMsIDYsIDE1LCA4LCAxLCAxMCwgMywgMTIsXG4gIDYsIDExLCAzLCA3LCAwLCAxMywgNSwgMTAsIDE0LCAxNSwgOCwgMTIsIDQsIDksIDEsIDIsXG4gIDE1LCA1LCAxLCAzLCA3LCAxNCwgNiwgOSwgMTEsIDgsIDEyLCAyLCAxMCwgMCwgNCwgMTMsXG4gIDgsIDYsIDQsIDEsIDMsIDExLCAxNSwgMCwgNSwgMTIsIDIsIDEzLCA5LCA3LCAxMCwgMTQsXG4gIDEyLCAxNSwgMTAsIDQsIDEsIDUsIDgsIDcsIDYsIDIsIDEzLCAxNCwgMCwgMywgOSwgMTFcbl07XG5cbnZhciBzID0gW1xuICAxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDgsXG4gIDcsIDYsIDgsIDEzLCAxMSwgOSwgNywgMTUsIDcsIDEyLCAxNSwgOSwgMTEsIDcsIDEzLCAxMixcbiAgMTEsIDEzLCA2LCA3LCAxNCwgOSwgMTMsIDE1LCAxNCwgOCwgMTMsIDYsIDUsIDEyLCA3LCA1LFxuICAxMSwgMTIsIDE0LCAxNSwgMTQsIDE1LCA5LCA4LCA5LCAxNCwgNSwgNiwgOCwgNiwgNSwgMTIsXG4gIDksIDE1LCA1LCAxMSwgNiwgOCwgMTMsIDEyLCA1LCAxMiwgMTMsIDE0LCAxMSwgOCwgNSwgNlxuXTtcblxudmFyIHNoID0gW1xuICA4LCA5LCA5LCAxMSwgMTMsIDE1LCAxNSwgNSwgNywgNywgOCwgMTEsIDE0LCAxNCwgMTIsIDYsXG4gIDksIDEzLCAxNSwgNywgMTIsIDgsIDksIDExLCA3LCA3LCAxMiwgNywgNiwgMTUsIDEzLCAxMSxcbiAgOSwgNywgMTUsIDExLCA4LCA2LCA2LCAxNCwgMTIsIDEzLCA1LCAxNCwgMTMsIDEzLCA3LCA1LFxuICAxNSwgNSwgOCwgMTEsIDE0LCAxNCwgNiwgMTQsIDYsIDksIDEyLCA5LCAxMiwgNSwgMTUsIDgsXG4gIDgsIDUsIDEyLCA5LCAxMiwgNSwgMTQsIDYsIDgsIDEzLCA2LCA1LCAxNSwgMTMsIDExLCAxMVxuXTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5zaGExID0gcmVxdWlyZSgnLi9zaGEvMScpO1xuZXhwb3J0cy5zaGEyMjQgPSByZXF1aXJlKCcuL3NoYS8yMjQnKTtcbmV4cG9ydHMuc2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEvMjU2Jyk7XG5leHBvcnRzLnNoYTM4NCA9IHJlcXVpcmUoJy4vc2hhLzM4NCcpO1xuZXhwb3J0cy5zaGE1MTIgPSByZXF1aXJlKCcuL3NoYS81MTInKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBzaGFDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG52YXIgcm90bDMyID0gdXRpbHMucm90bDMyO1xudmFyIHN1bTMyID0gdXRpbHMuc3VtMzI7XG52YXIgc3VtMzJfNSA9IHV0aWxzLnN1bTMyXzU7XG52YXIgZnRfMSA9IHNoYUNvbW1vbi5mdF8xO1xudmFyIEJsb2NrSGFzaCA9IGNvbW1vbi5CbG9ja0hhc2g7XG5cbnZhciBzaGExX0sgPSBbXG4gIDB4NUE4Mjc5OTksIDB4NkVEOUVCQTEsXG4gIDB4OEYxQkJDREMsIDB4Q0E2MkMxRDZcbl07XG5cbmZ1bmN0aW9uIFNIQTEoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEExKSlcbiAgICByZXR1cm4gbmV3IFNIQTEoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gW1xuICAgIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsXG4gICAgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMCBdO1xuICB0aGlzLlcgPSBuZXcgQXJyYXkoODApO1xufVxuXG51dGlscy5pbmhlcml0cyhTSEExLCBCbG9ja0hhc2gpO1xubW9kdWxlLmV4cG9ydHMgPSBTSEExO1xuXG5TSEExLmJsb2NrU2l6ZSA9IDUxMjtcblNIQTEub3V0U2l6ZSA9IDE2MDtcblNIQTEuaG1hY1N0cmVuZ3RoID0gODA7XG5TSEExLnBhZExlbmd0aCA9IDY0O1xuXG5TSEExLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHZhciBXID0gdGhpcy5XO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcbiAgICBXW2ldID0gbXNnW3N0YXJ0ICsgaV07XG5cbiAgZm9yKDsgaSA8IFcubGVuZ3RoOyBpKyspXG4gICAgV1tpXSA9IHJvdGwzMihXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdLCAxKTtcblxuICB2YXIgYSA9IHRoaXMuaFswXTtcbiAgdmFyIGIgPSB0aGlzLmhbMV07XG4gIHZhciBjID0gdGhpcy5oWzJdO1xuICB2YXIgZCA9IHRoaXMuaFszXTtcbiAgdmFyIGUgPSB0aGlzLmhbNF07XG5cbiAgZm9yIChpID0gMDsgaSA8IFcubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcyA9IH5+KGkgLyAyMCk7XG4gICAgdmFyIHQgPSBzdW0zMl81KHJvdGwzMihhLCA1KSwgZnRfMShzLCBiLCBjLCBkKSwgZSwgV1tpXSwgc2hhMV9LW3NdKTtcbiAgICBlID0gZDtcbiAgICBkID0gYztcbiAgICBjID0gcm90bDMyKGIsIDMwKTtcbiAgICBiID0gYTtcbiAgICBhID0gdDtcbiAgfVxuXG4gIHRoaXMuaFswXSA9IHN1bTMyKHRoaXMuaFswXSwgYSk7XG4gIHRoaXMuaFsxXSA9IHN1bTMyKHRoaXMuaFsxXSwgYik7XG4gIHRoaXMuaFsyXSA9IHN1bTMyKHRoaXMuaFsyXSwgYyk7XG4gIHRoaXMuaFszXSA9IHN1bTMyKHRoaXMuaFszXSwgZCk7XG4gIHRoaXMuaFs0XSA9IHN1bTMyKHRoaXMuaFs0XSwgZSk7XG59O1xuXG5TSEExLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2JpZycpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBTSEEyNTYgPSByZXF1aXJlKCcuLzI1NicpO1xuXG5mdW5jdGlvbiBTSEEyMjQoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEEyMjQpKVxuICAgIHJldHVybiBuZXcgU0hBMjI0KCk7XG5cbiAgU0hBMjU2LmNhbGwodGhpcyk7XG4gIHRoaXMuaCA9IFtcbiAgICAweGMxMDU5ZWQ4LCAweDM2N2NkNTA3LCAweDMwNzBkZDE3LCAweGY3MGU1OTM5LFxuICAgIDB4ZmZjMDBiMzEsIDB4Njg1ODE1MTEsIDB4NjRmOThmYTcsIDB4YmVmYTRmYTQgXTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTIyNCwgU0hBMjU2KTtcbm1vZHVsZS5leHBvcnRzID0gU0hBMjI0O1xuXG5TSEEyMjQuYmxvY2tTaXplID0gNTEyO1xuU0hBMjI0Lm91dFNpemUgPSAyMjQ7XG5TSEEyMjQuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBMjI0LnBhZExlbmd0aCA9IDY0O1xuXG5TSEEyMjQucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIC8vIEp1c3QgdHJ1bmNhdGUgb3V0cHV0XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaC5zbGljZSgwLCA3KSwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLnNsaWNlKDAsIDcpLCAnYmlnJyk7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG52YXIgc2hhQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG5cbnZhciBzdW0zMiA9IHV0aWxzLnN1bTMyO1xudmFyIHN1bTMyXzQgPSB1dGlscy5zdW0zMl80O1xudmFyIHN1bTMyXzUgPSB1dGlscy5zdW0zMl81O1xudmFyIGNoMzIgPSBzaGFDb21tb24uY2gzMjtcbnZhciBtYWozMiA9IHNoYUNvbW1vbi5tYWozMjtcbnZhciBzMF8yNTYgPSBzaGFDb21tb24uczBfMjU2O1xudmFyIHMxXzI1NiA9IHNoYUNvbW1vbi5zMV8yNTY7XG52YXIgZzBfMjU2ID0gc2hhQ29tbW9uLmcwXzI1NjtcbnZhciBnMV8yNTYgPSBzaGFDb21tb24uZzFfMjU2O1xuXG52YXIgQmxvY2tIYXNoID0gY29tbW9uLkJsb2NrSGFzaDtcblxudmFyIHNoYTI1Nl9LID0gW1xuICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LFxuICAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLFxuICAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLFxuICAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LFxuICAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLFxuICAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLFxuICAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LFxuICAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LFxuICAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dO1xuXG5mdW5jdGlvbiBTSEEyNTYoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEEyNTYpKVxuICAgIHJldHVybiBuZXcgU0hBMjU2KCk7XG5cbiAgQmxvY2tIYXNoLmNhbGwodGhpcyk7XG4gIHRoaXMuaCA9IFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLFxuICAgIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbiAgXTtcbiAgdGhpcy5rID0gc2hhMjU2X0s7XG4gIHRoaXMuVyA9IG5ldyBBcnJheSg2NCk7XG59XG51dGlscy5pbmhlcml0cyhTSEEyNTYsIEJsb2NrSGFzaCk7XG5tb2R1bGUuZXhwb3J0cyA9IFNIQTI1NjtcblxuU0hBMjU2LmJsb2NrU2l6ZSA9IDUxMjtcblNIQTI1Ni5vdXRTaXplID0gMjU2O1xuU0hBMjU2LmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTI1Ni5wYWRMZW5ndGggPSA2NDtcblxuU0hBMjU2LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHZhciBXID0gdGhpcy5XO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcbiAgICBXW2ldID0gbXNnW3N0YXJ0ICsgaV07XG4gIGZvciAoOyBpIDwgVy5sZW5ndGg7IGkrKylcbiAgICBXW2ldID0gc3VtMzJfNChnMV8yNTYoV1tpIC0gMl0pLCBXW2kgLSA3XSwgZzBfMjU2KFdbaSAtIDE1XSksIFdbaSAtIDE2XSk7XG5cbiAgdmFyIGEgPSB0aGlzLmhbMF07XG4gIHZhciBiID0gdGhpcy5oWzFdO1xuICB2YXIgYyA9IHRoaXMuaFsyXTtcbiAgdmFyIGQgPSB0aGlzLmhbM107XG4gIHZhciBlID0gdGhpcy5oWzRdO1xuICB2YXIgZiA9IHRoaXMuaFs1XTtcbiAgdmFyIGcgPSB0aGlzLmhbNl07XG4gIHZhciBoID0gdGhpcy5oWzddO1xuXG4gIGFzc2VydCh0aGlzLmsubGVuZ3RoID09PSBXLmxlbmd0aCk7XG4gIGZvciAoaSA9IDA7IGkgPCBXLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIFQxID0gc3VtMzJfNShoLCBzMV8yNTYoZSksIGNoMzIoZSwgZiwgZyksIHRoaXMua1tpXSwgV1tpXSk7XG4gICAgdmFyIFQyID0gc3VtMzIoczBfMjU2KGEpLCBtYWozMihhLCBiLCBjKSk7XG4gICAgaCA9IGc7XG4gICAgZyA9IGY7XG4gICAgZiA9IGU7XG4gICAgZSA9IHN1bTMyKGQsIFQxKTtcbiAgICBkID0gYztcbiAgICBjID0gYjtcbiAgICBiID0gYTtcbiAgICBhID0gc3VtMzIoVDEsIFQyKTtcbiAgfVxuXG4gIHRoaXMuaFswXSA9IHN1bTMyKHRoaXMuaFswXSwgYSk7XG4gIHRoaXMuaFsxXSA9IHN1bTMyKHRoaXMuaFsxXSwgYik7XG4gIHRoaXMuaFsyXSA9IHN1bTMyKHRoaXMuaFsyXSwgYyk7XG4gIHRoaXMuaFszXSA9IHN1bTMyKHRoaXMuaFszXSwgZCk7XG4gIHRoaXMuaFs0XSA9IHN1bTMyKHRoaXMuaFs0XSwgZSk7XG4gIHRoaXMuaFs1XSA9IHN1bTMyKHRoaXMuaFs1XSwgZik7XG4gIHRoaXMuaFs2XSA9IHN1bTMyKHRoaXMuaFs2XSwgZyk7XG4gIHRoaXMuaFs3XSA9IHN1bTMyKHRoaXMuaFs3XSwgaCk7XG59O1xuXG5TSEEyNTYucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG52YXIgU0hBNTEyID0gcmVxdWlyZSgnLi81MTInKTtcblxuZnVuY3Rpb24gU0hBMzg0KCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMzg0KSlcbiAgICByZXR1cm4gbmV3IFNIQTM4NCgpO1xuXG4gIFNIQTUxMi5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHhjYmJiOWQ1ZCwgMHhjMTA1OWVkOCxcbiAgICAweDYyOWEyOTJhLCAweDM2N2NkNTA3LFxuICAgIDB4OTE1OTAxNWEsIDB4MzA3MGRkMTcsXG4gICAgMHgxNTJmZWNkOCwgMHhmNzBlNTkzOSxcbiAgICAweDY3MzMyNjY3LCAweGZmYzAwYjMxLFxuICAgIDB4OGViNDRhODcsIDB4Njg1ODE1MTEsXG4gICAgMHhkYjBjMmUwZCwgMHg2NGY5OGZhNyxcbiAgICAweDQ3YjU0ODFkLCAweGJlZmE0ZmE0IF07XG59XG51dGlscy5pbmhlcml0cyhTSEEzODQsIFNIQTUxMik7XG5tb2R1bGUuZXhwb3J0cyA9IFNIQTM4NDtcblxuU0hBMzg0LmJsb2NrU2l6ZSA9IDEwMjQ7XG5TSEEzODQub3V0U2l6ZSA9IDM4NDtcblNIQTM4NC5obWFjU3RyZW5ndGggPSAxOTI7XG5TSEEzODQucGFkTGVuZ3RoID0gMTI4O1xuXG5TSEEzODQucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaC5zbGljZSgwLCAxMiksICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaC5zbGljZSgwLCAxMiksICdiaWcnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG52YXIgcm90cjY0X2hpID0gdXRpbHMucm90cjY0X2hpO1xudmFyIHJvdHI2NF9sbyA9IHV0aWxzLnJvdHI2NF9sbztcbnZhciBzaHI2NF9oaSA9IHV0aWxzLnNocjY0X2hpO1xudmFyIHNocjY0X2xvID0gdXRpbHMuc2hyNjRfbG87XG52YXIgc3VtNjQgPSB1dGlscy5zdW02NDtcbnZhciBzdW02NF9oaSA9IHV0aWxzLnN1bTY0X2hpO1xudmFyIHN1bTY0X2xvID0gdXRpbHMuc3VtNjRfbG87XG52YXIgc3VtNjRfNF9oaSA9IHV0aWxzLnN1bTY0XzRfaGk7XG52YXIgc3VtNjRfNF9sbyA9IHV0aWxzLnN1bTY0XzRfbG87XG52YXIgc3VtNjRfNV9oaSA9IHV0aWxzLnN1bTY0XzVfaGk7XG52YXIgc3VtNjRfNV9sbyA9IHV0aWxzLnN1bTY0XzVfbG87XG5cbnZhciBCbG9ja0hhc2ggPSBjb21tb24uQmxvY2tIYXNoO1xuXG52YXIgc2hhNTEyX0sgPSBbXG4gIDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIsIDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QsXG4gIDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYsIDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMsXG4gIDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgsIDB4NTlmMTExZjEsIDB4YjYwNWQwMTksXG4gIDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIsIDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgsXG4gIDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIsIDB4MTI4MzViMDEsIDB4NDU3MDZmYmUsXG4gIDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMsIDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIsXG4gIDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYsIDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEsXG4gIDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUsIDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQsXG4gIDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIsIDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMsXG4gIDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUsIDB4MjQwY2ExY2MsIDB4NzdhYzljNjUsXG4gIDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUsIDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMsXG4gIDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQsIDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUsXG4gIDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIsIDB4YTgzMWM2NmQsIDB4MmRiNDMyMTAsXG4gIDB4YjAwMzI3YzgsIDB4OThmYjIxM2YsIDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQsXG4gIDB4YzZlMDBiZjMsIDB4M2RhODhmYzIsIDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUsXG4gIDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYsIDB4MTQyOTI5NjcsIDB4MGEwZTZlNzAsXG4gIDB4MjdiNzBhODUsIDB4NDZkMjJmZmMsIDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYsXG4gIDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQsIDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYsXG4gIDB4NjUwYTczNTQsIDB4OGJhZjYzZGUsIDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgsXG4gIDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYsIDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IsXG4gIDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQsIDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEsXG4gIDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEsIDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzAsXG4gIDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgsIDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTAsXG4gIDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEsIDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgsXG4gIDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgsIDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMsXG4gIDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTksIDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgsXG4gIDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMsIDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IsXG4gIDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMsIDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMsXG4gIDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMsIDB4NzhhNTYzNmYsIDB4NDMxNzJmNjAsXG4gIDB4ODRjODc4MTQsIDB4YTFmMGFiNzIsIDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMsXG4gIDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgsIDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTksXG4gIDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUsIDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIsXG4gIDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMsIDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcsXG4gIDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUsIDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgsXG4gIDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEsIDB4MGE2MzdkYzUsIDB4YTJjODk4YTYsXG4gIDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUsIDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIsXG4gIDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQsIDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMsXG4gIDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMsIDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMsXG4gIDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYsIDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEsXG4gIDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMsIDB4NmM0NDE5OGMsIDB4NGE0NzU4MTdcbl07XG5cbmZ1bmN0aW9uIFNIQTUxMigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTUxMikpXG4gICAgcmV0dXJuIG5ldyBTSEE1MTIoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gW1xuICAgIDB4NmEwOWU2NjcsIDB4ZjNiY2M5MDgsXG4gICAgMHhiYjY3YWU4NSwgMHg4NGNhYTczYixcbiAgICAweDNjNmVmMzcyLCAweGZlOTRmODJiLFxuICAgIDB4YTU0ZmY1M2EsIDB4NWYxZDM2ZjEsXG4gICAgMHg1MTBlNTI3ZiwgMHhhZGU2ODJkMSxcbiAgICAweDliMDU2ODhjLCAweDJiM2U2YzFmLFxuICAgIDB4MWY4M2Q5YWIsIDB4ZmI0MWJkNmIsXG4gICAgMHg1YmUwY2QxOSwgMHgxMzdlMjE3OSBdO1xuICB0aGlzLmsgPSBzaGE1MTJfSztcbiAgdGhpcy5XID0gbmV3IEFycmF5KDE2MCk7XG59XG51dGlscy5pbmhlcml0cyhTSEE1MTIsIEJsb2NrSGFzaCk7XG5tb2R1bGUuZXhwb3J0cyA9IFNIQTUxMjtcblxuU0hBNTEyLmJsb2NrU2l6ZSA9IDEwMjQ7XG5TSEE1MTIub3V0U2l6ZSA9IDUxMjtcblNIQTUxMi5obWFjU3RyZW5ndGggPSAxOTI7XG5TSEE1MTIucGFkTGVuZ3RoID0gMTI4O1xuXG5TSEE1MTIucHJvdG90eXBlLl9wcmVwYXJlQmxvY2sgPSBmdW5jdGlvbiBfcHJlcGFyZUJsb2NrKG1zZywgc3RhcnQpIHtcbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgLy8gMzIgeCAzMmJpdCB3b3Jkc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspXG4gICAgV1tpXSA9IG1zZ1tzdGFydCArIGldO1xuICBmb3IgKDsgaSA8IFcubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgYzBfaGkgPSBnMV81MTJfaGkoV1tpIC0gNF0sIFdbaSAtIDNdKTsgIC8vIGkgLSAyXG4gICAgdmFyIGMwX2xvID0gZzFfNTEyX2xvKFdbaSAtIDRdLCBXW2kgLSAzXSk7XG4gICAgdmFyIGMxX2hpID0gV1tpIC0gMTRdOyAgLy8gaSAtIDdcbiAgICB2YXIgYzFfbG8gPSBXW2kgLSAxM107XG4gICAgdmFyIGMyX2hpID0gZzBfNTEyX2hpKFdbaSAtIDMwXSwgV1tpIC0gMjldKTsgIC8vIGkgLSAxNVxuICAgIHZhciBjMl9sbyA9IGcwXzUxMl9sbyhXW2kgLSAzMF0sIFdbaSAtIDI5XSk7XG4gICAgdmFyIGMzX2hpID0gV1tpIC0gMzJdOyAgLy8gaSAtIDE2XG4gICAgdmFyIGMzX2xvID0gV1tpIC0gMzFdO1xuXG4gICAgV1tpXSA9IHN1bTY0XzRfaGkoXG4gICAgICBjMF9oaSwgYzBfbG8sXG4gICAgICBjMV9oaSwgYzFfbG8sXG4gICAgICBjMl9oaSwgYzJfbG8sXG4gICAgICBjM19oaSwgYzNfbG8pO1xuICAgIFdbaSArIDFdID0gc3VtNjRfNF9sbyhcbiAgICAgIGMwX2hpLCBjMF9sbyxcbiAgICAgIGMxX2hpLCBjMV9sbyxcbiAgICAgIGMyX2hpLCBjMl9sbyxcbiAgICAgIGMzX2hpLCBjM19sbyk7XG4gIH1cbn07XG5cblNIQTUxMi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUobXNnLCBzdGFydCkge1xuICB0aGlzLl9wcmVwYXJlQmxvY2sobXNnLCBzdGFydCk7XG5cbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgdmFyIGFoID0gdGhpcy5oWzBdO1xuICB2YXIgYWwgPSB0aGlzLmhbMV07XG4gIHZhciBiaCA9IHRoaXMuaFsyXTtcbiAgdmFyIGJsID0gdGhpcy5oWzNdO1xuICB2YXIgY2ggPSB0aGlzLmhbNF07XG4gIHZhciBjbCA9IHRoaXMuaFs1XTtcbiAgdmFyIGRoID0gdGhpcy5oWzZdO1xuICB2YXIgZGwgPSB0aGlzLmhbN107XG4gIHZhciBlaCA9IHRoaXMuaFs4XTtcbiAgdmFyIGVsID0gdGhpcy5oWzldO1xuICB2YXIgZmggPSB0aGlzLmhbMTBdO1xuICB2YXIgZmwgPSB0aGlzLmhbMTFdO1xuICB2YXIgZ2ggPSB0aGlzLmhbMTJdO1xuICB2YXIgZ2wgPSB0aGlzLmhbMTNdO1xuICB2YXIgaGggPSB0aGlzLmhbMTRdO1xuICB2YXIgaGwgPSB0aGlzLmhbMTVdO1xuXG4gIGFzc2VydCh0aGlzLmsubGVuZ3RoID09PSBXLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBjMF9oaSA9IGhoO1xuICAgIHZhciBjMF9sbyA9IGhsO1xuICAgIHZhciBjMV9oaSA9IHMxXzUxMl9oaShlaCwgZWwpO1xuICAgIHZhciBjMV9sbyA9IHMxXzUxMl9sbyhlaCwgZWwpO1xuICAgIHZhciBjMl9oaSA9IGNoNjRfaGkoZWgsIGVsLCBmaCwgZmwsIGdoLCBnbCk7XG4gICAgdmFyIGMyX2xvID0gY2g2NF9sbyhlaCwgZWwsIGZoLCBmbCwgZ2gsIGdsKTtcbiAgICB2YXIgYzNfaGkgPSB0aGlzLmtbaV07XG4gICAgdmFyIGMzX2xvID0gdGhpcy5rW2kgKyAxXTtcbiAgICB2YXIgYzRfaGkgPSBXW2ldO1xuICAgIHZhciBjNF9sbyA9IFdbaSArIDFdO1xuXG4gICAgdmFyIFQxX2hpID0gc3VtNjRfNV9oaShcbiAgICAgIGMwX2hpLCBjMF9sbyxcbiAgICAgIGMxX2hpLCBjMV9sbyxcbiAgICAgIGMyX2hpLCBjMl9sbyxcbiAgICAgIGMzX2hpLCBjM19sbyxcbiAgICAgIGM0X2hpLCBjNF9sbyk7XG4gICAgdmFyIFQxX2xvID0gc3VtNjRfNV9sbyhcbiAgICAgIGMwX2hpLCBjMF9sbyxcbiAgICAgIGMxX2hpLCBjMV9sbyxcbiAgICAgIGMyX2hpLCBjMl9sbyxcbiAgICAgIGMzX2hpLCBjM19sbyxcbiAgICAgIGM0X2hpLCBjNF9sbyk7XG5cbiAgICBjMF9oaSA9IHMwXzUxMl9oaShhaCwgYWwpO1xuICAgIGMwX2xvID0gczBfNTEyX2xvKGFoLCBhbCk7XG4gICAgYzFfaGkgPSBtYWo2NF9oaShhaCwgYWwsIGJoLCBibCwgY2gsIGNsKTtcbiAgICBjMV9sbyA9IG1hajY0X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wpO1xuXG4gICAgdmFyIFQyX2hpID0gc3VtNjRfaGkoYzBfaGksIGMwX2xvLCBjMV9oaSwgYzFfbG8pO1xuICAgIHZhciBUMl9sbyA9IHN1bTY0X2xvKGMwX2hpLCBjMF9sbywgYzFfaGksIGMxX2xvKTtcblxuICAgIGhoID0gZ2g7XG4gICAgaGwgPSBnbDtcblxuICAgIGdoID0gZmg7XG4gICAgZ2wgPSBmbDtcblxuICAgIGZoID0gZWg7XG4gICAgZmwgPSBlbDtcblxuICAgIGVoID0gc3VtNjRfaGkoZGgsIGRsLCBUMV9oaSwgVDFfbG8pO1xuICAgIGVsID0gc3VtNjRfbG8oZGwsIGRsLCBUMV9oaSwgVDFfbG8pO1xuXG4gICAgZGggPSBjaDtcbiAgICBkbCA9IGNsO1xuXG4gICAgY2ggPSBiaDtcbiAgICBjbCA9IGJsO1xuXG4gICAgYmggPSBhaDtcbiAgICBibCA9IGFsO1xuXG4gICAgYWggPSBzdW02NF9oaShUMV9oaSwgVDFfbG8sIFQyX2hpLCBUMl9sbyk7XG4gICAgYWwgPSBzdW02NF9sbyhUMV9oaSwgVDFfbG8sIFQyX2hpLCBUMl9sbyk7XG4gIH1cblxuICBzdW02NCh0aGlzLmgsIDAsIGFoLCBhbCk7XG4gIHN1bTY0KHRoaXMuaCwgMiwgYmgsIGJsKTtcbiAgc3VtNjQodGhpcy5oLCA0LCBjaCwgY2wpO1xuICBzdW02NCh0aGlzLmgsIDYsIGRoLCBkbCk7XG4gIHN1bTY0KHRoaXMuaCwgOCwgZWgsIGVsKTtcbiAgc3VtNjQodGhpcy5oLCAxMCwgZmgsIGZsKTtcbiAgc3VtNjQodGhpcy5oLCAxMiwgZ2gsIGdsKTtcbiAgc3VtNjQodGhpcy5oLCAxNCwgaGgsIGhsKTtcbn07XG5cblNIQTUxMi5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdiaWcnKTtcbn07XG5cbmZ1bmN0aW9uIGNoNjRfaGkoeGgsIHhsLCB5aCwgeWwsIHpoKSB7XG4gIHZhciByID0gKHhoICYgeWgpIF4gKCh+eGgpICYgemgpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGNoNjRfbG8oeGgsIHhsLCB5aCwgeWwsIHpoLCB6bCkge1xuICB2YXIgciA9ICh4bCAmIHlsKSBeICgofnhsKSAmIHpsKTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBtYWo2NF9oaSh4aCwgeGwsIHloLCB5bCwgemgpIHtcbiAgdmFyIHIgPSAoeGggJiB5aCkgXiAoeGggJiB6aCkgXiAoeWggJiB6aCk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gbWFqNjRfbG8oeGgsIHhsLCB5aCwgeWwsIHpoLCB6bCkge1xuICB2YXIgciA9ICh4bCAmIHlsKSBeICh4bCAmIHpsKSBeICh5bCAmIHpsKTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBzMF81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDI4KTtcbiAgdmFyIGMxX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgMik7ICAvLyAzNFxuICB2YXIgYzJfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCA3KTsgIC8vIDM5XG5cbiAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gczBfNTEyX2xvKHhoLCB4bCkge1xuICB2YXIgYzBfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAyOCk7XG4gIHZhciBjMV9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDIpOyAgLy8gMzRcbiAgdmFyIGMyX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgNyk7ICAvLyAzOVxuXG4gIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMxXzUxMl9oaSh4aCwgeGwpIHtcbiAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMTQpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAxOCk7XG4gIHZhciBjMl9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDkpOyAgLy8gNDFcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBzMV81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDE0KTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMTgpO1xuICB2YXIgYzJfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCA5KTsgIC8vIDQxXG5cbiAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gZzBfNTEyX2hpKHhoLCB4bCkge1xuICB2YXIgYzBfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAxKTtcbiAgdmFyIGMxX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgOCk7XG4gIHZhciBjMl9oaSA9IHNocjY0X2hpKHhoLCB4bCwgNyk7XG5cbiAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gZzBfNTEyX2xvKHhoLCB4bCkge1xuICB2YXIgYzBfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAxKTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgOCk7XG4gIHZhciBjMl9sbyA9IHNocjY0X2xvKHhoLCB4bCwgNyk7XG5cbiAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gZzFfNTEyX2hpKHhoLCB4bCkge1xuICB2YXIgYzBfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAxOSk7XG4gIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDI5KTsgIC8vIDYxXG4gIHZhciBjMl9oaSA9IHNocjY0X2hpKHhoLCB4bCwgNik7XG5cbiAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gZzFfNTEyX2xvKHhoLCB4bCkge1xuICB2YXIgYzBfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAxOSk7XG4gIHZhciBjMV9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDI5KTsgIC8vIDYxXG4gIHZhciBjMl9sbyA9IHNocjY0X2xvKHhoLCB4bCwgNik7XG5cbiAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciByb3RyMzIgPSB1dGlscy5yb3RyMzI7XG5cbmZ1bmN0aW9uIGZ0XzEocywgeCwgeSwgeikge1xuICBpZiAocyA9PT0gMClcbiAgICByZXR1cm4gY2gzMih4LCB5LCB6KTtcbiAgaWYgKHMgPT09IDEgfHwgcyA9PT0gMylcbiAgICByZXR1cm4gcDMyKHgsIHksIHopO1xuICBpZiAocyA9PT0gMilcbiAgICByZXR1cm4gbWFqMzIoeCwgeSwgeik7XG59XG5leHBvcnRzLmZ0XzEgPSBmdF8xO1xuXG5mdW5jdGlvbiBjaDMyKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgXiAoKH54KSAmIHopO1xufVxuZXhwb3J0cy5jaDMyID0gY2gzMjtcblxuZnVuY3Rpb24gbWFqMzIoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSBeICh4ICYgeikgXiAoeSAmIHopO1xufVxuZXhwb3J0cy5tYWozMiA9IG1hajMyO1xuXG5mdW5jdGlvbiBwMzIoeCwgeSwgeikge1xuICByZXR1cm4geCBeIHkgXiB6O1xufVxuZXhwb3J0cy5wMzIgPSBwMzI7XG5cbmZ1bmN0aW9uIHMwXzI1Nih4KSB7XG4gIHJldHVybiByb3RyMzIoeCwgMikgXiByb3RyMzIoeCwgMTMpIF4gcm90cjMyKHgsIDIyKTtcbn1cbmV4cG9ydHMuczBfMjU2ID0gczBfMjU2O1xuXG5mdW5jdGlvbiBzMV8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDYpIF4gcm90cjMyKHgsIDExKSBeIHJvdHIzMih4LCAyNSk7XG59XG5leHBvcnRzLnMxXzI1NiA9IHMxXzI1NjtcblxuZnVuY3Rpb24gZzBfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCA3KSBeIHJvdHIzMih4LCAxOCkgXiAoeCA+Pj4gMyk7XG59XG5leHBvcnRzLmcwXzI1NiA9IGcwXzI1NjtcblxuZnVuY3Rpb24gZzFfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCAxNykgXiByb3RyMzIoeCwgMTkpIF4gKHggPj4+IDEwKTtcbn1cbmV4cG9ydHMuZzFfMjU2ID0gZzFfMjU2O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5pbmhlcml0cyA9IGluaGVyaXRzO1xuXG5mdW5jdGlvbiBpc1N1cnJvZ2F0ZVBhaXIobXNnLCBpKSB7XG4gIGlmICgobXNnLmNoYXJDb2RlQXQoaSkgJiAweEZDMDApICE9PSAweEQ4MDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGkgPCAwIHx8IGkgKyAxID49IG1zZy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIChtc2cuY2hhckNvZGVBdChpICsgMSkgJiAweEZDMDApID09PSAweERDMDA7XG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkobXNnLCBlbmMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobXNnKSlcbiAgICByZXR1cm4gbXNnLnNsaWNlKCk7XG4gIGlmICghbXNnKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIHJlcyA9IFtdO1xuICBpZiAodHlwZW9mIG1zZyA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIWVuYykge1xuICAgICAgLy8gSW5zcGlyZWQgYnkgc3RyaW5nVG9VdGY4Qnl0ZUFycmF5KCkgaW4gY2xvc3VyZS1saWJyYXJ5IGJ5IEdvb2dsZVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWxpYnJhcnkvYmxvYi84NTk4ZDg3MjQyYWY1OWFhYzIzMzI3MDc0MmM4OTg0ZTJiMmJkYmUwL2Nsb3N1cmUvZ29vZy9jcnlwdC9jcnlwdC5qcyNMMTE3LUwxNDNcbiAgICAgIC8vIEFwYWNoZSBMaWNlbnNlIDIuMFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWxpYnJhcnkvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICAgICAgdmFyIHAgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBtc2cuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICByZXNbcCsrXSA9IGM7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA8IDIwNDgpIHtcbiAgICAgICAgICByZXNbcCsrXSA9IChjID4+IDYpIHwgMTkyO1xuICAgICAgICAgIHJlc1twKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTdXJyb2dhdGVQYWlyKG1zZywgaSkpIHtcbiAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAmIDB4MDNGRikgPDwgMTApICsgKG1zZy5jaGFyQ29kZUF0KCsraSkgJiAweDAzRkYpO1xuICAgICAgICAgIHJlc1twKytdID0gKGMgPj4gMTgpIHwgMjQwO1xuICAgICAgICAgIHJlc1twKytdID0gKChjID4+IDEyKSAmIDYzKSB8IDEyODtcbiAgICAgICAgICByZXNbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgICAgICByZXNbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc1twKytdID0gKGMgPj4gMTIpIHwgMjI0O1xuICAgICAgICAgIHJlc1twKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgICAgIHJlc1twKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVuYyA9PT0gJ2hleCcpIHtcbiAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKC9bXmEtejAtOV0rL2lnLCAnJyk7XG4gICAgICBpZiAobXNnLmxlbmd0aCAlIDIgIT09IDApXG4gICAgICAgIG1zZyA9ICcwJyArIG1zZztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgIHJlcy5wdXNoKHBhcnNlSW50KG1zZ1tpXSArIG1zZ1tpICsgMV0sIDE2KSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgICByZXNbaV0gPSBtc2dbaV0gfCAwO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5leHBvcnRzLnRvQXJyYXkgPSB0b0FycmF5O1xuXG5mdW5jdGlvbiB0b0hleChtc2cpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICByZXMgKz0gemVybzIobXNnW2ldLnRvU3RyaW5nKDE2KSk7XG4gIHJldHVybiByZXM7XG59XG5leHBvcnRzLnRvSGV4ID0gdG9IZXg7XG5cbmZ1bmN0aW9uIGh0b25sKHcpIHtcbiAgdmFyIHJlcyA9ICh3ID4+PiAyNCkgfFxuICAgICAgICAgICAgKCh3ID4+PiA4KSAmIDB4ZmYwMCkgfFxuICAgICAgICAgICAgKCh3IDw8IDgpICYgMHhmZjAwMDApIHxcbiAgICAgICAgICAgICgodyAmIDB4ZmYpIDw8IDI0KTtcbiAgcmV0dXJuIHJlcyA+Pj4gMDtcbn1cbmV4cG9ydHMuaHRvbmwgPSBodG9ubDtcblxuZnVuY3Rpb24gdG9IZXgzMihtc2csIGVuZGlhbikge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHcgPSBtc2dbaV07XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2xpdHRsZScpXG4gICAgICB3ID0gaHRvbmwodyk7XG4gICAgcmVzICs9IHplcm84KHcudG9TdHJpbmcoMTYpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy50b0hleDMyID0gdG9IZXgzMjtcblxuZnVuY3Rpb24gemVybzIod29yZCkge1xuICBpZiAod29yZC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuICcwJyArIHdvcmQ7XG4gIGVsc2VcbiAgICByZXR1cm4gd29yZDtcbn1cbmV4cG9ydHMuemVybzIgPSB6ZXJvMjtcblxuZnVuY3Rpb24gemVybzgod29yZCkge1xuICBpZiAod29yZC5sZW5ndGggPT09IDcpXG4gICAgcmV0dXJuICcwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA2KVxuICAgIHJldHVybiAnMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDUpXG4gICAgcmV0dXJuICcwMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDQpXG4gICAgcmV0dXJuICcwMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAzKVxuICAgIHJldHVybiAnMDAwMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDIpXG4gICAgcmV0dXJuICcwMDAwMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuICcwMDAwMDAwJyArIHdvcmQ7XG4gIGVsc2VcbiAgICByZXR1cm4gd29yZDtcbn1cbmV4cG9ydHMuemVybzggPSB6ZXJvODtcblxuZnVuY3Rpb24gam9pbjMyKG1zZywgc3RhcnQsIGVuZCwgZW5kaWFuKSB7XG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcbiAgYXNzZXJ0KGxlbiAlIDQgPT09IDApO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbiAvIDQpO1xuICBmb3IgKHZhciBpID0gMCwgayA9IHN0YXJ0OyBpIDwgcmVzLmxlbmd0aDsgaSsrLCBrICs9IDQpIHtcbiAgICB2YXIgdztcbiAgICBpZiAoZW5kaWFuID09PSAnYmlnJylcbiAgICAgIHcgPSAobXNnW2tdIDw8IDI0KSB8IChtc2dbayArIDFdIDw8IDE2KSB8IChtc2dbayArIDJdIDw8IDgpIHwgbXNnW2sgKyAzXTtcbiAgICBlbHNlXG4gICAgICB3ID0gKG1zZ1trICsgM10gPDwgMjQpIHwgKG1zZ1trICsgMl0gPDwgMTYpIHwgKG1zZ1trICsgMV0gPDwgOCkgfCBtc2dba107XG4gICAgcmVzW2ldID0gdyA+Pj4gMDtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5qb2luMzIgPSBqb2luMzI7XG5cbmZ1bmN0aW9uIHNwbGl0MzIobXNnLCBlbmRpYW4pIHtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShtc2cubGVuZ3RoICogNCk7XG4gIGZvciAodmFyIGkgPSAwLCBrID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKywgayArPSA0KSB7XG4gICAgdmFyIG0gPSBtc2dbaV07XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JpZycpIHtcbiAgICAgIHJlc1trXSA9IG0gPj4+IDI0O1xuICAgICAgcmVzW2sgKyAxXSA9IChtID4+PiAxNikgJiAweGZmO1xuICAgICAgcmVzW2sgKyAyXSA9IChtID4+PiA4KSAmIDB4ZmY7XG4gICAgICByZXNbayArIDNdID0gbSAmIDB4ZmY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1trICsgM10gPSBtID4+PiAyNDtcbiAgICAgIHJlc1trICsgMl0gPSAobSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgIHJlc1trICsgMV0gPSAobSA+Pj4gOCkgJiAweGZmO1xuICAgICAgcmVzW2tdID0gbSAmIDB4ZmY7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5leHBvcnRzLnNwbGl0MzIgPSBzcGxpdDMyO1xuXG5mdW5jdGlvbiByb3RyMzIodywgYikge1xuICByZXR1cm4gKHcgPj4+IGIpIHwgKHcgPDwgKDMyIC0gYikpO1xufVxuZXhwb3J0cy5yb3RyMzIgPSByb3RyMzI7XG5cbmZ1bmN0aW9uIHJvdGwzMih3LCBiKSB7XG4gIHJldHVybiAodyA8PCBiKSB8ICh3ID4+PiAoMzIgLSBiKSk7XG59XG5leHBvcnRzLnJvdGwzMiA9IHJvdGwzMjtcblxuZnVuY3Rpb24gc3VtMzIoYSwgYikge1xuICByZXR1cm4gKGEgKyBiKSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtMzIgPSBzdW0zMjtcblxuZnVuY3Rpb24gc3VtMzJfMyhhLCBiLCBjKSB7XG4gIHJldHVybiAoYSArIGIgKyBjKSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtMzJfMyA9IHN1bTMyXzM7XG5cbmZ1bmN0aW9uIHN1bTMyXzQoYSwgYiwgYywgZCkge1xuICByZXR1cm4gKGEgKyBiICsgYyArIGQpID4+PiAwO1xufVxuZXhwb3J0cy5zdW0zMl80ID0gc3VtMzJfNDtcblxuZnVuY3Rpb24gc3VtMzJfNShhLCBiLCBjLCBkLCBlKSB7XG4gIHJldHVybiAoYSArIGIgKyBjICsgZCArIGUpID4+PiAwO1xufVxuZXhwb3J0cy5zdW0zMl81ID0gc3VtMzJfNTtcblxuZnVuY3Rpb24gc3VtNjQoYnVmLCBwb3MsIGFoLCBhbCkge1xuICB2YXIgYmggPSBidWZbcG9zXTtcbiAgdmFyIGJsID0gYnVmW3BvcyArIDFdO1xuXG4gIHZhciBsbyA9IChhbCArIGJsKSA+Pj4gMDtcbiAgdmFyIGhpID0gKGxvIDwgYWwgPyAxIDogMCkgKyBhaCArIGJoO1xuICBidWZbcG9zXSA9IGhpID4+PiAwO1xuICBidWZbcG9zICsgMV0gPSBsbztcbn1cbmV4cG9ydHMuc3VtNjQgPSBzdW02NDtcblxuZnVuY3Rpb24gc3VtNjRfaGkoYWgsIGFsLCBiaCwgYmwpIHtcbiAgdmFyIGxvID0gKGFsICsgYmwpID4+PiAwO1xuICB2YXIgaGkgPSAobG8gPCBhbCA/IDEgOiAwKSArIGFoICsgYmg7XG4gIHJldHVybiBoaSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfaGkgPSBzdW02NF9oaTtcblxuZnVuY3Rpb24gc3VtNjRfbG8oYWgsIGFsLCBiaCwgYmwpIHtcbiAgdmFyIGxvID0gYWwgKyBibDtcbiAgcmV0dXJuIGxvID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF9sbyA9IHN1bTY0X2xvO1xuXG5mdW5jdGlvbiBzdW02NF80X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCkge1xuICB2YXIgY2FycnkgPSAwO1xuICB2YXIgbG8gPSBhbDtcbiAgbG8gPSAobG8gKyBibCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgYWwgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBjbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgY2wgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBkbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgZGwgPyAxIDogMDtcblxuICB2YXIgaGkgPSBhaCArIGJoICsgY2ggKyBkaCArIGNhcnJ5O1xuICByZXR1cm4gaGkgPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0XzRfaGkgPSBzdW02NF80X2hpO1xuXG5mdW5jdGlvbiBzdW02NF80X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCkge1xuICB2YXIgbG8gPSBhbCArIGJsICsgY2wgKyBkbDtcbiAgcmV0dXJuIGxvID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF80X2xvID0gc3VtNjRfNF9sbztcblxuZnVuY3Rpb24gc3VtNjRfNV9oaShhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwsIGVoLCBlbCkge1xuICB2YXIgY2FycnkgPSAwO1xuICB2YXIgbG8gPSBhbDtcbiAgbG8gPSAobG8gKyBibCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgYWwgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBjbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgY2wgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBkbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgZGwgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBlbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgZWwgPyAxIDogMDtcblxuICB2YXIgaGkgPSBhaCArIGJoICsgY2ggKyBkaCArIGVoICsgY2Fycnk7XG4gIHJldHVybiBoaSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfNV9oaSA9IHN1bTY0XzVfaGk7XG5cbmZ1bmN0aW9uIHN1bTY0XzVfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsLCBlaCwgZWwpIHtcbiAgdmFyIGxvID0gYWwgKyBibCArIGNsICsgZGwgKyBlbDtcblxuICByZXR1cm4gbG8gPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0XzVfbG8gPSBzdW02NF81X2xvO1xuXG5mdW5jdGlvbiByb3RyNjRfaGkoYWgsIGFsLCBudW0pIHtcbiAgdmFyIHIgPSAoYWwgPDwgKDMyIC0gbnVtKSkgfCAoYWggPj4+IG51bSk7XG4gIHJldHVybiByID4+PiAwO1xufVxuZXhwb3J0cy5yb3RyNjRfaGkgPSByb3RyNjRfaGk7XG5cbmZ1bmN0aW9uIHJvdHI2NF9sbyhhaCwgYWwsIG51bSkge1xuICB2YXIgciA9IChhaCA8PCAoMzIgLSBudW0pKSB8IChhbCA+Pj4gbnVtKTtcbiAgcmV0dXJuIHIgPj4+IDA7XG59XG5leHBvcnRzLnJvdHI2NF9sbyA9IHJvdHI2NF9sbztcblxuZnVuY3Rpb24gc2hyNjRfaGkoYWgsIGFsLCBudW0pIHtcbiAgcmV0dXJuIGFoID4+PiBudW07XG59XG5leHBvcnRzLnNocjY0X2hpID0gc2hyNjRfaGk7XG5cbmZ1bmN0aW9uIHNocjY0X2xvKGFoLCBhbCwgbnVtKSB7XG4gIHZhciByID0gKGFoIDw8ICgzMiAtIG51bSkpIHwgKGFsID4+PiBudW0pO1xuICByZXR1cm4gciA+Pj4gMDtcbn1cbmV4cG9ydHMuc2hyNjRfbG8gPSBzaHI2NF9sbztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc2ggPSByZXF1aXJlKCdoYXNoLmpzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtY3J5cHRvLXV0aWxzJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG5mdW5jdGlvbiBIbWFjRFJCRyhvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIbWFjRFJCRykpXG4gICAgcmV0dXJuIG5ldyBIbWFjRFJCRyhvcHRpb25zKTtcbiAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoO1xuICB0aGlzLnByZWRSZXNpc3QgPSAhIW9wdGlvbnMucHJlZFJlc2lzdDtcblxuICB0aGlzLm91dExlbiA9IHRoaXMuaGFzaC5vdXRTaXplO1xuICB0aGlzLm1pbkVudHJvcHkgPSBvcHRpb25zLm1pbkVudHJvcHkgfHwgdGhpcy5oYXNoLmhtYWNTdHJlbmd0aDtcblxuICB0aGlzLl9yZXNlZWQgPSBudWxsO1xuICB0aGlzLnJlc2VlZEludGVydmFsID0gbnVsbDtcbiAgdGhpcy5LID0gbnVsbDtcbiAgdGhpcy5WID0gbnVsbDtcblxuICB2YXIgZW50cm9weSA9IHV0aWxzLnRvQXJyYXkob3B0aW9ucy5lbnRyb3B5LCBvcHRpb25zLmVudHJvcHlFbmMgfHwgJ2hleCcpO1xuICB2YXIgbm9uY2UgPSB1dGlscy50b0FycmF5KG9wdGlvbnMubm9uY2UsIG9wdGlvbnMubm9uY2VFbmMgfHwgJ2hleCcpO1xuICB2YXIgcGVycyA9IHV0aWxzLnRvQXJyYXkob3B0aW9ucy5wZXJzLCBvcHRpb25zLnBlcnNFbmMgfHwgJ2hleCcpO1xuICBhc3NlcnQoZW50cm9weS5sZW5ndGggPj0gKHRoaXMubWluRW50cm9weSAvIDgpLFxuICAgICAgICAgJ05vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogJyArIHRoaXMubWluRW50cm9weSArICcgYml0cycpO1xuICB0aGlzLl9pbml0KGVudHJvcHksIG5vbmNlLCBwZXJzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gSG1hY0RSQkc7XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoZW50cm9weSwgbm9uY2UsIHBlcnMpIHtcbiAgdmFyIHNlZWQgPSBlbnRyb3B5LmNvbmNhdChub25jZSkuY29uY2F0KHBlcnMpO1xuXG4gIHRoaXMuSyA9IG5ldyBBcnJheSh0aGlzLm91dExlbiAvIDgpO1xuICB0aGlzLlYgPSBuZXcgQXJyYXkodGhpcy5vdXRMZW4gLyA4KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLlYubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLktbaV0gPSAweDAwO1xuICAgIHRoaXMuVltpXSA9IDB4MDE7XG4gIH1cblxuICB0aGlzLl91cGRhdGUoc2VlZCk7XG4gIHRoaXMuX3Jlc2VlZCA9IDE7XG4gIHRoaXMucmVzZWVkSW50ZXJ2YWwgPSAweDEwMDAwMDAwMDAwMDA7ICAvLyAyXjQ4XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuX2htYWMgPSBmdW5jdGlvbiBobWFjKCkge1xuICByZXR1cm4gbmV3IGhhc2guaG1hYyh0aGlzLmhhc2gsIHRoaXMuSyk7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShzZWVkKSB7XG4gIHZhciBrbWFjID0gdGhpcy5faG1hYygpXG4gICAgICAgICAgICAgICAgIC51cGRhdGUodGhpcy5WKVxuICAgICAgICAgICAgICAgICAudXBkYXRlKFsgMHgwMCBdKTtcbiAgaWYgKHNlZWQpXG4gICAga21hYyA9IGttYWMudXBkYXRlKHNlZWQpO1xuICB0aGlzLksgPSBrbWFjLmRpZ2VzdCgpO1xuICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG4gIGlmICghc2VlZClcbiAgICByZXR1cm47XG5cbiAgdGhpcy5LID0gdGhpcy5faG1hYygpXG4gICAgICAgICAgICAgICAudXBkYXRlKHRoaXMuVilcbiAgICAgICAgICAgICAgIC51cGRhdGUoWyAweDAxIF0pXG4gICAgICAgICAgICAgICAudXBkYXRlKHNlZWQpXG4gICAgICAgICAgICAgICAuZGlnZXN0KCk7XG4gIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5yZXNlZWQgPSBmdW5jdGlvbiByZXNlZWQoZW50cm9weSwgZW50cm9weUVuYywgYWRkLCBhZGRFbmMpIHtcbiAgLy8gT3B0aW9uYWwgZW50cm9weSBlbmNcbiAgaWYgKHR5cGVvZiBlbnRyb3B5RW5jICE9PSAnc3RyaW5nJykge1xuICAgIGFkZEVuYyA9IGFkZDtcbiAgICBhZGQgPSBlbnRyb3B5RW5jO1xuICAgIGVudHJvcHlFbmMgPSBudWxsO1xuICB9XG5cbiAgZW50cm9weSA9IHV0aWxzLnRvQXJyYXkoZW50cm9weSwgZW50cm9weUVuYyk7XG4gIGFkZCA9IHV0aWxzLnRvQXJyYXkoYWRkLCBhZGRFbmMpO1xuXG4gIGFzc2VydChlbnRyb3B5Lmxlbmd0aCA+PSAodGhpcy5taW5FbnRyb3B5IC8gOCksXG4gICAgICAgICAnTm90IGVub3VnaCBlbnRyb3B5LiBNaW5pbXVtIGlzOiAnICsgdGhpcy5taW5FbnRyb3B5ICsgJyBiaXRzJyk7XG5cbiAgdGhpcy5fdXBkYXRlKGVudHJvcHkuY29uY2F0KGFkZCB8fCBbXSkpO1xuICB0aGlzLl9yZXNlZWQgPSAxO1xufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUobGVuLCBlbmMsIGFkZCwgYWRkRW5jKSB7XG4gIGlmICh0aGlzLl9yZXNlZWQgPiB0aGlzLnJlc2VlZEludGVydmFsKVxuICAgIHRocm93IG5ldyBFcnJvcignUmVzZWVkIGlzIHJlcXVpcmVkJyk7XG5cbiAgLy8gT3B0aW9uYWwgZW5jb2RpbmdcbiAgaWYgKHR5cGVvZiBlbmMgIT09ICdzdHJpbmcnKSB7XG4gICAgYWRkRW5jID0gYWRkO1xuICAgIGFkZCA9IGVuYztcbiAgICBlbmMgPSBudWxsO1xuICB9XG5cbiAgLy8gT3B0aW9uYWwgYWRkaXRpb25hbCBkYXRhXG4gIGlmIChhZGQpIHtcbiAgICBhZGQgPSB1dGlscy50b0FycmF5KGFkZCwgYWRkRW5jIHx8ICdoZXgnKTtcbiAgICB0aGlzLl91cGRhdGUoYWRkKTtcbiAgfVxuXG4gIHZhciB0ZW1wID0gW107XG4gIHdoaWxlICh0ZW1wLmxlbmd0aCA8IGxlbikge1xuICAgIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcbiAgICB0ZW1wID0gdGVtcC5jb25jYXQodGhpcy5WKTtcbiAgfVxuXG4gIHZhciByZXMgPSB0ZW1wLnNsaWNlKDAsIGxlbik7XG4gIHRoaXMuX3VwZGF0ZShhZGQpO1xuICB0aGlzLl9yZXNlZWQrKztcbiAgcmV0dXJuIHV0aWxzLmVuY29kZShyZXMsIGVuYyk7XG59O1xuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59OyIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIndXNlIHN0cmljdCdcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoQmFzZSA9IHJlcXVpcmUoJ2hhc2gtYmFzZScpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEFSUkFZMTYgPSBuZXcgQXJyYXkoMTYpXG5cbmZ1bmN0aW9uIE1ENSAoKSB7XG4gIEhhc2hCYXNlLmNhbGwodGhpcywgNjQpXG5cbiAgLy8gc3RhdGVcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbn1cblxuaW5oZXJpdHMoTUQ1LCBIYXNoQmFzZSlcblxuTUQ1LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgTSA9IEFSUkFZMTZcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBNW2ldID0gdGhpcy5fYmxvY2sucmVhZEludDMyTEUoaSAqIDQpXG5cbiAgdmFyIGEgPSB0aGlzLl9hXG4gIHZhciBiID0gdGhpcy5fYlxuICB2YXIgYyA9IHRoaXMuX2NcbiAgdmFyIGQgPSB0aGlzLl9kXG5cbiAgYSA9IGZuRihhLCBiLCBjLCBkLCBNWzBdLCAweGQ3NmFhNDc4LCA3KVxuICBkID0gZm5GKGQsIGEsIGIsIGMsIE1bMV0sIDB4ZThjN2I3NTYsIDEyKVxuICBjID0gZm5GKGMsIGQsIGEsIGIsIE1bMl0sIDB4MjQyMDcwZGIsIDE3KVxuICBiID0gZm5GKGIsIGMsIGQsIGEsIE1bM10sIDB4YzFiZGNlZWUsIDIyKVxuICBhID0gZm5GKGEsIGIsIGMsIGQsIE1bNF0sIDB4ZjU3YzBmYWYsIDcpXG4gIGQgPSBmbkYoZCwgYSwgYiwgYywgTVs1XSwgMHg0Nzg3YzYyYSwgMTIpXG4gIGMgPSBmbkYoYywgZCwgYSwgYiwgTVs2XSwgMHhhODMwNDYxMywgMTcpXG4gIGIgPSBmbkYoYiwgYywgZCwgYSwgTVs3XSwgMHhmZDQ2OTUwMSwgMjIpXG4gIGEgPSBmbkYoYSwgYiwgYywgZCwgTVs4XSwgMHg2OTgwOThkOCwgNylcbiAgZCA9IGZuRihkLCBhLCBiLCBjLCBNWzldLCAweDhiNDRmN2FmLCAxMilcbiAgYyA9IGZuRihjLCBkLCBhLCBiLCBNWzEwXSwgMHhmZmZmNWJiMSwgMTcpXG4gIGIgPSBmbkYoYiwgYywgZCwgYSwgTVsxMV0sIDB4ODk1Y2Q3YmUsIDIyKVxuICBhID0gZm5GKGEsIGIsIGMsIGQsIE1bMTJdLCAweDZiOTAxMTIyLCA3KVxuICBkID0gZm5GKGQsIGEsIGIsIGMsIE1bMTNdLCAweGZkOTg3MTkzLCAxMilcbiAgYyA9IGZuRihjLCBkLCBhLCBiLCBNWzE0XSwgMHhhNjc5NDM4ZSwgMTcpXG4gIGIgPSBmbkYoYiwgYywgZCwgYSwgTVsxNV0sIDB4NDliNDA4MjEsIDIyKVxuXG4gIGEgPSBmbkcoYSwgYiwgYywgZCwgTVsxXSwgMHhmNjFlMjU2MiwgNSlcbiAgZCA9IGZuRyhkLCBhLCBiLCBjLCBNWzZdLCAweGMwNDBiMzQwLCA5KVxuICBjID0gZm5HKGMsIGQsIGEsIGIsIE1bMTFdLCAweDI2NWU1YTUxLCAxNClcbiAgYiA9IGZuRyhiLCBjLCBkLCBhLCBNWzBdLCAweGU5YjZjN2FhLCAyMClcbiAgYSA9IGZuRyhhLCBiLCBjLCBkLCBNWzVdLCAweGQ2MmYxMDVkLCA1KVxuICBkID0gZm5HKGQsIGEsIGIsIGMsIE1bMTBdLCAweDAyNDQxNDUzLCA5KVxuICBjID0gZm5HKGMsIGQsIGEsIGIsIE1bMTVdLCAweGQ4YTFlNjgxLCAxNClcbiAgYiA9IGZuRyhiLCBjLCBkLCBhLCBNWzRdLCAweGU3ZDNmYmM4LCAyMClcbiAgYSA9IGZuRyhhLCBiLCBjLCBkLCBNWzldLCAweDIxZTFjZGU2LCA1KVxuICBkID0gZm5HKGQsIGEsIGIsIGMsIE1bMTRdLCAweGMzMzcwN2Q2LCA5KVxuICBjID0gZm5HKGMsIGQsIGEsIGIsIE1bM10sIDB4ZjRkNTBkODcsIDE0KVxuICBiID0gZm5HKGIsIGMsIGQsIGEsIE1bOF0sIDB4NDU1YTE0ZWQsIDIwKVxuICBhID0gZm5HKGEsIGIsIGMsIGQsIE1bMTNdLCAweGE5ZTNlOTA1LCA1KVxuICBkID0gZm5HKGQsIGEsIGIsIGMsIE1bMl0sIDB4ZmNlZmEzZjgsIDkpXG4gIGMgPSBmbkcoYywgZCwgYSwgYiwgTVs3XSwgMHg2NzZmMDJkOSwgMTQpXG4gIGIgPSBmbkcoYiwgYywgZCwgYSwgTVsxMl0sIDB4OGQyYTRjOGEsIDIwKVxuXG4gIGEgPSBmbkgoYSwgYiwgYywgZCwgTVs1XSwgMHhmZmZhMzk0MiwgNClcbiAgZCA9IGZuSChkLCBhLCBiLCBjLCBNWzhdLCAweDg3NzFmNjgxLCAxMSlcbiAgYyA9IGZuSChjLCBkLCBhLCBiLCBNWzExXSwgMHg2ZDlkNjEyMiwgMTYpXG4gIGIgPSBmbkgoYiwgYywgZCwgYSwgTVsxNF0sIDB4ZmRlNTM4MGMsIDIzKVxuICBhID0gZm5IKGEsIGIsIGMsIGQsIE1bMV0sIDB4YTRiZWVhNDQsIDQpXG4gIGQgPSBmbkgoZCwgYSwgYiwgYywgTVs0XSwgMHg0YmRlY2ZhOSwgMTEpXG4gIGMgPSBmbkgoYywgZCwgYSwgYiwgTVs3XSwgMHhmNmJiNGI2MCwgMTYpXG4gIGIgPSBmbkgoYiwgYywgZCwgYSwgTVsxMF0sIDB4YmViZmJjNzAsIDIzKVxuICBhID0gZm5IKGEsIGIsIGMsIGQsIE1bMTNdLCAweDI4OWI3ZWM2LCA0KVxuICBkID0gZm5IKGQsIGEsIGIsIGMsIE1bMF0sIDB4ZWFhMTI3ZmEsIDExKVxuICBjID0gZm5IKGMsIGQsIGEsIGIsIE1bM10sIDB4ZDRlZjMwODUsIDE2KVxuICBiID0gZm5IKGIsIGMsIGQsIGEsIE1bNl0sIDB4MDQ4ODFkMDUsIDIzKVxuICBhID0gZm5IKGEsIGIsIGMsIGQsIE1bOV0sIDB4ZDlkNGQwMzksIDQpXG4gIGQgPSBmbkgoZCwgYSwgYiwgYywgTVsxMl0sIDB4ZTZkYjk5ZTUsIDExKVxuICBjID0gZm5IKGMsIGQsIGEsIGIsIE1bMTVdLCAweDFmYTI3Y2Y4LCAxNilcbiAgYiA9IGZuSChiLCBjLCBkLCBhLCBNWzJdLCAweGM0YWM1NjY1LCAyMylcblxuICBhID0gZm5JKGEsIGIsIGMsIGQsIE1bMF0sIDB4ZjQyOTIyNDQsIDYpXG4gIGQgPSBmbkkoZCwgYSwgYiwgYywgTVs3XSwgMHg0MzJhZmY5NywgMTApXG4gIGMgPSBmbkkoYywgZCwgYSwgYiwgTVsxNF0sIDB4YWI5NDIzYTcsIDE1KVxuICBiID0gZm5JKGIsIGMsIGQsIGEsIE1bNV0sIDB4ZmM5M2EwMzksIDIxKVxuICBhID0gZm5JKGEsIGIsIGMsIGQsIE1bMTJdLCAweDY1NWI1OWMzLCA2KVxuICBkID0gZm5JKGQsIGEsIGIsIGMsIE1bM10sIDB4OGYwY2NjOTIsIDEwKVxuICBjID0gZm5JKGMsIGQsIGEsIGIsIE1bMTBdLCAweGZmZWZmNDdkLCAxNSlcbiAgYiA9IGZuSShiLCBjLCBkLCBhLCBNWzFdLCAweDg1ODQ1ZGQxLCAyMSlcbiAgYSA9IGZuSShhLCBiLCBjLCBkLCBNWzhdLCAweDZmYTg3ZTRmLCA2KVxuICBkID0gZm5JKGQsIGEsIGIsIGMsIE1bMTVdLCAweGZlMmNlNmUwLCAxMClcbiAgYyA9IGZuSShjLCBkLCBhLCBiLCBNWzZdLCAweGEzMDE0MzE0LCAxNSlcbiAgYiA9IGZuSShiLCBjLCBkLCBhLCBNWzEzXSwgMHg0ZTA4MTFhMSwgMjEpXG4gIGEgPSBmbkkoYSwgYiwgYywgZCwgTVs0XSwgMHhmNzUzN2U4MiwgNilcbiAgZCA9IGZuSShkLCBhLCBiLCBjLCBNWzExXSwgMHhiZDNhZjIzNSwgMTApXG4gIGMgPSBmbkkoYywgZCwgYSwgYiwgTVsyXSwgMHgyYWQ3ZDJiYiwgMTUpXG4gIGIgPSBmbkkoYiwgYywgZCwgYSwgTVs5XSwgMHhlYjg2ZDM5MSwgMjEpXG5cbiAgdGhpcy5fYSA9ICh0aGlzLl9hICsgYSkgfCAwXG4gIHRoaXMuX2IgPSAodGhpcy5fYiArIGIpIHwgMFxuICB0aGlzLl9jID0gKHRoaXMuX2MgKyBjKSB8IDBcbiAgdGhpcy5fZCA9ICh0aGlzLl9kICsgZCkgfCAwXG59XG5cbk1ENS5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gY3JlYXRlIHBhZGRpbmcgYW5kIGhhbmRsZSBibG9ja3NcbiAgdGhpcy5fYmxvY2tbdGhpcy5fYmxvY2tPZmZzZXQrK10gPSAweDgwXG4gIGlmICh0aGlzLl9ibG9ja09mZnNldCA+IDU2KSB7XG4gICAgdGhpcy5fYmxvY2suZmlsbCgwLCB0aGlzLl9ibG9ja09mZnNldCwgNjQpXG4gICAgdGhpcy5fdXBkYXRlKClcbiAgICB0aGlzLl9ibG9ja09mZnNldCA9IDBcbiAgfVxuXG4gIHRoaXMuX2Jsb2NrLmZpbGwoMCwgdGhpcy5fYmxvY2tPZmZzZXQsIDU2KVxuICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkxFKHRoaXMuX2xlbmd0aFswXSwgNTYpXG4gIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyTEUodGhpcy5fbGVuZ3RoWzFdLCA2MClcbiAgdGhpcy5fdXBkYXRlKClcblxuICAvLyBwcm9kdWNlIHJlc3VsdFxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDE2KVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2EsIDApXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fYiwgNClcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9jLCA4KVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2QsIDEyKVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIHJvdGwgKHgsIG4pIHtcbiAgcmV0dXJuICh4IDw8IG4pIHwgKHggPj4+ICgzMiAtIG4pKVxufVxuXG5mdW5jdGlvbiBmbkYgKGEsIGIsIGMsIGQsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKChiICYgYykgfCAoKH5iKSAmIGQpKSArIG0gKyBrKSB8IDAsIHMpICsgYikgfCAwXG59XG5cbmZ1bmN0aW9uIGZuRyAoYSwgYiwgYywgZCwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoKGIgJiBkKSB8IChjICYgKH5kKSkpICsgbSArIGspIHwgMCwgcykgKyBiKSB8IDBcbn1cblxuZnVuY3Rpb24gZm5IIChhLCBiLCBjLCBkLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArIChiIF4gYyBeIGQpICsgbSArIGspIHwgMCwgcykgKyBiKSB8IDBcbn1cblxuZnVuY3Rpb24gZm5JIChhLCBiLCBjLCBkLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArICgoYyBeIChiIHwgKH5kKSkpKSArIG0gKyBrKSB8IDAsIHMpICsgYikgfCAwXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTUQ1XG4iLCJ2YXIgYm4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGJyb3JhbmQgPSByZXF1aXJlKCdicm9yYW5kJyk7XG5cbmZ1bmN0aW9uIE1pbGxlclJhYmluKHJhbmQpIHtcbiAgdGhpcy5yYW5kID0gcmFuZCB8fCBuZXcgYnJvcmFuZC5SYW5kKCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IE1pbGxlclJhYmluO1xuXG5NaWxsZXJSYWJpbi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocmFuZCkge1xuICByZXR1cm4gbmV3IE1pbGxlclJhYmluKHJhbmQpO1xufTtcblxuTWlsbGVyUmFiaW4ucHJvdG90eXBlLl9yYW5kYmVsb3cgPSBmdW5jdGlvbiBfcmFuZGJlbG93KG4pIHtcbiAgdmFyIGxlbiA9IG4uYml0TGVuZ3RoKCk7XG4gIHZhciBtaW5fYnl0ZXMgPSBNYXRoLmNlaWwobGVuIC8gOCk7XG5cbiAgLy8gR2VuZXJhZ2UgcmFuZG9tIGJ5dGVzIHVudGlsIGEgbnVtYmVyIGxlc3MgdGhhbiBuIGlzIGZvdW5kLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdCAwLi5uLTEgaGF2ZSBhbiBlcXVhbCBwcm9iYWJpbGl0eSBvZiBiZWluZyBzZWxlY3RlZC5cbiAgZG9cbiAgICB2YXIgYSA9IG5ldyBibih0aGlzLnJhbmQuZ2VuZXJhdGUobWluX2J5dGVzKSk7XG4gIHdoaWxlIChhLmNtcChuKSA+PSAwKTtcblxuICByZXR1cm4gYTtcbn07XG5cbk1pbGxlclJhYmluLnByb3RvdHlwZS5fcmFuZHJhbmdlID0gZnVuY3Rpb24gX3JhbmRyYW5nZShzdGFydCwgc3RvcCkge1xuICAvLyBHZW5lcmF0ZSBhIHJhbmRvbSBudW1iZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHN0YXJ0IGFuZCBsZXNzIHRoYW4gc3RvcC5cbiAgdmFyIHNpemUgPSBzdG9wLnN1YihzdGFydCk7XG4gIHJldHVybiBzdGFydC5hZGQodGhpcy5fcmFuZGJlbG93KHNpemUpKTtcbn07XG5cbk1pbGxlclJhYmluLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gdGVzdChuLCBrLCBjYikge1xuICB2YXIgbGVuID0gbi5iaXRMZW5ndGgoKTtcbiAgdmFyIHJlZCA9IGJuLm1vbnQobik7XG4gIHZhciByb25lID0gbmV3IGJuKDEpLnRvUmVkKHJlZCk7XG5cbiAgaWYgKCFrKVxuICAgIGsgPSBNYXRoLm1heCgxLCAobGVuIC8gNDgpIHwgMCk7XG5cbiAgLy8gRmluZCBkIGFuZCBzLCAobiAtIDEpID0gKDIgXiBzKSAqIGQ7XG4gIHZhciBuMSA9IG4uc3VibigxKTtcbiAgZm9yICh2YXIgcyA9IDA7ICFuMS50ZXN0bihzKTsgcysrKSB7fVxuICB2YXIgZCA9IG4uc2hybihzKTtcblxuICB2YXIgcm4xID0gbjEudG9SZWQocmVkKTtcblxuICB2YXIgcHJpbWUgPSB0cnVlO1xuICBmb3IgKDsgayA+IDA7IGstLSkge1xuICAgIHZhciBhID0gdGhpcy5fcmFuZHJhbmdlKG5ldyBibigyKSwgbjEpO1xuICAgIGlmIChjYilcbiAgICAgIGNiKGEpO1xuXG4gICAgdmFyIHggPSBhLnRvUmVkKHJlZCkucmVkUG93KGQpO1xuICAgIGlmICh4LmNtcChyb25lKSA9PT0gMCB8fCB4LmNtcChybjEpID09PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHM7IGkrKykge1xuICAgICAgeCA9IHgucmVkU3FyKCk7XG5cbiAgICAgIGlmICh4LmNtcChyb25lKSA9PT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHguY21wKHJuMSkgPT09IDApXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpID09PSBzKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHByaW1lO1xufTtcblxuTWlsbGVyUmFiaW4ucHJvdG90eXBlLmdldERpdmlzb3IgPSBmdW5jdGlvbiBnZXREaXZpc29yKG4sIGspIHtcbiAgdmFyIGxlbiA9IG4uYml0TGVuZ3RoKCk7XG4gIHZhciByZWQgPSBibi5tb250KG4pO1xuICB2YXIgcm9uZSA9IG5ldyBibigxKS50b1JlZChyZWQpO1xuXG4gIGlmICghaylcbiAgICBrID0gTWF0aC5tYXgoMSwgKGxlbiAvIDQ4KSB8IDApO1xuXG4gIC8vIEZpbmQgZCBhbmQgcywgKG4gLSAxKSA9ICgyIF4gcykgKiBkO1xuICB2YXIgbjEgPSBuLnN1Ym4oMSk7XG4gIGZvciAodmFyIHMgPSAwOyAhbjEudGVzdG4ocyk7IHMrKykge31cbiAgdmFyIGQgPSBuLnNocm4ocyk7XG5cbiAgdmFyIHJuMSA9IG4xLnRvUmVkKHJlZCk7XG5cbiAgZm9yICg7IGsgPiAwOyBrLS0pIHtcbiAgICB2YXIgYSA9IHRoaXMuX3JhbmRyYW5nZShuZXcgYm4oMiksIG4xKTtcblxuICAgIHZhciBnID0gbi5nY2QoYSk7XG4gICAgaWYgKGcuY21wbigxKSAhPT0gMClcbiAgICAgIHJldHVybiBnO1xuXG4gICAgdmFyIHggPSBhLnRvUmVkKHJlZCkucmVkUG93KGQpO1xuICAgIGlmICh4LmNtcChyb25lKSA9PT0gMCB8fCB4LmNtcChybjEpID09PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHM7IGkrKykge1xuICAgICAgeCA9IHgucmVkU3FyKCk7XG5cbiAgICAgIGlmICh4LmNtcChyb25lKSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHguZnJvbVJlZCgpLnN1Ym4oMSkuZ2NkKG4pO1xuICAgICAgaWYgKHguY21wKHJuMSkgPT09IDApXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpID09PSBzKSB7XG4gICAgICB4ID0geC5yZWRTcXIoKTtcbiAgICAgIHJldHVybiB4LmZyb21SZWQoKS5zdWJuKDEpLmdjZChuKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBhc3NlcnQ7XG5cbmZ1bmN0aW9uIGFzc2VydCh2YWwsIG1zZykge1xuICBpZiAoIXZhbClcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG59XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGFzc2VydEVxdWFsKGwsIHIsIG1zZykge1xuICBpZiAobCAhPSByKVxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgKCdBc3NlcnRpb24gZmFpbGVkOiAnICsgbCArICcgIT0gJyArIHIpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IGV4cG9ydHM7XG5cbmZ1bmN0aW9uIHRvQXJyYXkobXNnLCBlbmMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobXNnKSlcbiAgICByZXR1cm4gbXNnLnNsaWNlKCk7XG4gIGlmICghbXNnKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIHJlcyA9IFtdO1xuICBpZiAodHlwZW9mIG1zZyAhPT0gJ3N0cmluZycpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICAgIHJlc1tpXSA9IG1zZ1tpXSB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZiAoZW5jID09PSAnaGV4Jykge1xuICAgIG1zZyA9IG1zZy5yZXBsYWNlKC9bXmEtejAtOV0rL2lnLCAnJyk7XG4gICAgaWYgKG1zZy5sZW5ndGggJSAyICE9PSAwKVxuICAgICAgbXNnID0gJzAnICsgbXNnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSAyKVxuICAgICAgcmVzLnB1c2gocGFyc2VJbnQobXNnW2ldICsgbXNnW2kgKyAxXSwgMTYpKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBtc2cuY2hhckNvZGVBdChpKTtcbiAgICAgIHZhciBoaSA9IGMgPj4gODtcbiAgICAgIHZhciBsbyA9IGMgJiAweGZmO1xuICAgICAgaWYgKGhpKVxuICAgICAgICByZXMucHVzaChoaSwgbG8pO1xuICAgICAgZWxzZVxuICAgICAgICByZXMucHVzaChsbyk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG51dGlscy50b0FycmF5ID0gdG9BcnJheTtcblxuZnVuY3Rpb24gemVybzIod29yZCkge1xuICBpZiAod29yZC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuICcwJyArIHdvcmQ7XG4gIGVsc2VcbiAgICByZXR1cm4gd29yZDtcbn1cbnV0aWxzLnplcm8yID0gemVybzI7XG5cbmZ1bmN0aW9uIHRvSGV4KG1zZykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgIHJlcyArPSB6ZXJvMihtc2dbaV0udG9TdHJpbmcoMTYpKTtcbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnRvSGV4ID0gdG9IZXg7XG5cbnV0aWxzLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShhcnIsIGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdG9IZXgoYXJyKTtcbiAgZWxzZVxuICAgIHJldHVybiBhcnI7XG59O1xuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uICRnZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgUmVmbGVjdEFwcGx5KHRoaXMubGlzdGVuZXIsIHRoaXMudGFyZ2V0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG4iLCJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcbiIsIi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvc2VsZi1zaWduZWQvYmxvYi9naC1wYWdlcy9saWIvYXNuMS5qc1xuLy8gRmVkb3IsIHlvdSBhcmUgYW1hemluZy5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYXNuMSA9IHJlcXVpcmUoJ2FzbjEuanMnKVxuXG5leHBvcnRzLmNlcnRpZmljYXRlID0gcmVxdWlyZSgnLi9jZXJ0aWZpY2F0ZScpXG5cbnZhciBSU0FQcml2YXRlS2V5ID0gYXNuMS5kZWZpbmUoJ1JTQVByaXZhdGVLZXknLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd2ZXJzaW9uJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ21vZHVsdXMnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHVibGljRXhwb25lbnQnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHJpdmF0ZUV4cG9uZW50JykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3ByaW1lMScpLmludCgpLFxuICAgIHRoaXMua2V5KCdwcmltZTInKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnZXhwb25lbnQxJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ2V4cG9uZW50MicpLmludCgpLFxuICAgIHRoaXMua2V5KCdjb2VmZmljaWVudCcpLmludCgpXG4gIClcbn0pXG5leHBvcnRzLlJTQVByaXZhdGVLZXkgPSBSU0FQcml2YXRlS2V5XG5cbnZhciBSU0FQdWJsaWNLZXkgPSBhc24xLmRlZmluZSgnUlNBUHVibGljS2V5JywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgnbW9kdWx1cycpLmludCgpLFxuICAgIHRoaXMua2V5KCdwdWJsaWNFeHBvbmVudCcpLmludCgpXG4gIClcbn0pXG5leHBvcnRzLlJTQVB1YmxpY0tleSA9IFJTQVB1YmxpY0tleVxuXG52YXIgUHVibGljS2V5ID0gYXNuMS5kZWZpbmUoJ1N1YmplY3RQdWJsaWNLZXlJbmZvJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgnYWxnb3JpdGhtJykudXNlKEFsZ29yaXRobUlkZW50aWZpZXIpLFxuICAgIHRoaXMua2V5KCdzdWJqZWN0UHVibGljS2V5JykuYml0c3RyKClcbiAgKVxufSlcbmV4cG9ydHMuUHVibGljS2V5ID0gUHVibGljS2V5XG5cbnZhciBBbGdvcml0aG1JZGVudGlmaWVyID0gYXNuMS5kZWZpbmUoJ0FsZ29yaXRobUlkZW50aWZpZXInLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdhbGdvcml0aG0nKS5vYmppZCgpLFxuICAgIHRoaXMua2V5KCdub25lJykubnVsbF8oKS5vcHRpb25hbCgpLFxuICAgIHRoaXMua2V5KCdjdXJ2ZScpLm9iamlkKCkub3B0aW9uYWwoKSxcbiAgICB0aGlzLmtleSgncGFyYW1zJykuc2VxKCkub2JqKFxuICAgICAgdGhpcy5rZXkoJ3AnKS5pbnQoKSxcbiAgICAgIHRoaXMua2V5KCdxJykuaW50KCksXG4gICAgICB0aGlzLmtleSgnZycpLmludCgpXG4gICAgKS5vcHRpb25hbCgpXG4gIClcbn0pXG5cbnZhciBQcml2YXRlS2V5SW5mbyA9IGFzbjEuZGVmaW5lKCdQcml2YXRlS2V5SW5mbycsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3ZlcnNpb24nKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnYWxnb3JpdGhtJykudXNlKEFsZ29yaXRobUlkZW50aWZpZXIpLFxuICAgIHRoaXMua2V5KCdzdWJqZWN0UHJpdmF0ZUtleScpLm9jdHN0cigpXG4gIClcbn0pXG5leHBvcnRzLlByaXZhdGVLZXkgPSBQcml2YXRlS2V5SW5mb1xudmFyIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvID0gYXNuMS5kZWZpbmUoJ0VuY3J5cHRlZFByaXZhdGVLZXlJbmZvJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgnYWxnb3JpdGhtJykuc2VxKCkub2JqKFxuICAgICAgdGhpcy5rZXkoJ2lkJykub2JqaWQoKSxcbiAgICAgIHRoaXMua2V5KCdkZWNyeXB0Jykuc2VxKCkub2JqKFxuICAgICAgICB0aGlzLmtleSgna2RlJykuc2VxKCkub2JqKFxuICAgICAgICAgIHRoaXMua2V5KCdpZCcpLm9iamlkKCksXG4gICAgICAgICAgdGhpcy5rZXkoJ2tkZXBhcmFtcycpLnNlcSgpLm9iaihcbiAgICAgICAgICAgIHRoaXMua2V5KCdzYWx0Jykub2N0c3RyKCksXG4gICAgICAgICAgICB0aGlzLmtleSgnaXRlcnMnKS5pbnQoKVxuICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgdGhpcy5rZXkoJ2NpcGhlcicpLnNlcSgpLm9iaihcbiAgICAgICAgICB0aGlzLmtleSgnYWxnbycpLm9iamlkKCksXG4gICAgICAgICAgdGhpcy5rZXkoJ2l2Jykub2N0c3RyKClcbiAgICAgICAgKVxuICAgICAgKVxuICAgICksXG4gICAgdGhpcy5rZXkoJ3N1YmplY3RQcml2YXRlS2V5Jykub2N0c3RyKClcbiAgKVxufSlcblxuZXhwb3J0cy5FbmNyeXB0ZWRQcml2YXRlS2V5ID0gRW5jcnlwdGVkUHJpdmF0ZUtleUluZm9cblxudmFyIERTQVByaXZhdGVLZXkgPSBhc24xLmRlZmluZSgnRFNBUHJpdmF0ZUtleScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3ZlcnNpb24nKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncCcpLmludCgpLFxuICAgIHRoaXMua2V5KCdxJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ2cnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHViX2tleScpLmludCgpLFxuICAgIHRoaXMua2V5KCdwcml2X2tleScpLmludCgpXG4gIClcbn0pXG5leHBvcnRzLkRTQVByaXZhdGVLZXkgPSBEU0FQcml2YXRlS2V5XG5cbmV4cG9ydHMuRFNBcGFyYW0gPSBhc24xLmRlZmluZSgnRFNBcGFyYW0nLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaW50KClcbn0pXG5cbnZhciBFQ1ByaXZhdGVLZXkgPSBhc24xLmRlZmluZSgnRUNQcml2YXRlS2V5JywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgndmVyc2lvbicpLmludCgpLFxuICAgIHRoaXMua2V5KCdwcml2YXRlS2V5Jykub2N0c3RyKCksXG4gICAgdGhpcy5rZXkoJ3BhcmFtZXRlcnMnKS5vcHRpb25hbCgpLmV4cGxpY2l0KDApLnVzZShFQ1BhcmFtZXRlcnMpLFxuICAgIHRoaXMua2V5KCdwdWJsaWNLZXknKS5vcHRpb25hbCgpLmV4cGxpY2l0KDEpLmJpdHN0cigpXG4gIClcbn0pXG5leHBvcnRzLkVDUHJpdmF0ZUtleSA9IEVDUHJpdmF0ZUtleVxuXG52YXIgRUNQYXJhbWV0ZXJzID0gYXNuMS5kZWZpbmUoJ0VDUGFyYW1ldGVycycsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jaG9pY2Uoe1xuICAgIG5hbWVkQ3VydmU6IHRoaXMub2JqaWQoKVxuICB9KVxufSlcblxuZXhwb3J0cy5zaWduYXR1cmUgPSBhc24xLmRlZmluZSgnc2lnbmF0dXJlJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgncicpLmludCgpLFxuICAgIHRoaXMua2V5KCdzJykuaW50KClcbiAgKVxufSlcbiIsIi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL1JhbnRhbmVuL25vZGUtZHRscy9ibG9iLzI1YTdkYzg2MWJkYTM4Y2ZlYWM5M2E3MjM1MDBlZWE0ZjBhYzJlODYvQ2VydGlmaWNhdGUuanNcbi8vIHRoYW5rcyB0byBAUmFudGFuZW5cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBhc24gPSByZXF1aXJlKCdhc24xLmpzJylcblxudmFyIFRpbWUgPSBhc24uZGVmaW5lKCdUaW1lJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLmNob2ljZSh7XG4gICAgdXRjVGltZTogdGhpcy51dGN0aW1lKCksXG4gICAgZ2VuZXJhbFRpbWU6IHRoaXMuZ2VudGltZSgpXG4gIH0pXG59KVxuXG52YXIgQXR0cmlidXRlVHlwZVZhbHVlID0gYXNuLmRlZmluZSgnQXR0cmlidXRlVHlwZVZhbHVlJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgndHlwZScpLm9iamlkKCksXG4gICAgdGhpcy5rZXkoJ3ZhbHVlJykuYW55KClcbiAgKVxufSlcblxudmFyIEFsZ29yaXRobUlkZW50aWZpZXIgPSBhc24uZGVmaW5lKCdBbGdvcml0aG1JZGVudGlmaWVyJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgnYWxnb3JpdGhtJykub2JqaWQoKSxcbiAgICB0aGlzLmtleSgncGFyYW1ldGVycycpLm9wdGlvbmFsKCksXG4gICAgdGhpcy5rZXkoJ2N1cnZlJykub2JqaWQoKS5vcHRpb25hbCgpXG4gIClcbn0pXG5cbnZhciBTdWJqZWN0UHVibGljS2V5SW5mbyA9IGFzbi5kZWZpbmUoJ1N1YmplY3RQdWJsaWNLZXlJbmZvJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgnYWxnb3JpdGhtJykudXNlKEFsZ29yaXRobUlkZW50aWZpZXIpLFxuICAgIHRoaXMua2V5KCdzdWJqZWN0UHVibGljS2V5JykuYml0c3RyKClcbiAgKVxufSlcblxudmFyIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWUgPSBhc24uZGVmaW5lKCdSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNldG9mKEF0dHJpYnV0ZVR5cGVWYWx1ZSlcbn0pXG5cbnZhciBSRE5TZXF1ZW5jZSA9IGFzbi5kZWZpbmUoJ1JETlNlcXVlbmNlJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcW9mKFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWUpXG59KVxuXG52YXIgTmFtZSA9IGFzbi5kZWZpbmUoJ05hbWUnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2hvaWNlKHtcbiAgICByZG5TZXF1ZW5jZTogdGhpcy51c2UoUkROU2VxdWVuY2UpXG4gIH0pXG59KVxuXG52YXIgVmFsaWRpdHkgPSBhc24uZGVmaW5lKCdWYWxpZGl0eScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ25vdEJlZm9yZScpLnVzZShUaW1lKSxcbiAgICB0aGlzLmtleSgnbm90QWZ0ZXInKS51c2UoVGltZSlcbiAgKVxufSlcblxudmFyIEV4dGVuc2lvbiA9IGFzbi5kZWZpbmUoJ0V4dGVuc2lvbicsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ2V4dG5JRCcpLm9iamlkKCksXG4gICAgdGhpcy5rZXkoJ2NyaXRpY2FsJykuYm9vbCgpLmRlZihmYWxzZSksXG4gICAgdGhpcy5rZXkoJ2V4dG5WYWx1ZScpLm9jdHN0cigpXG4gIClcbn0pXG5cbnZhciBUQlNDZXJ0aWZpY2F0ZSA9IGFzbi5kZWZpbmUoJ1RCU0NlcnRpZmljYXRlJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgndmVyc2lvbicpLmV4cGxpY2l0KDApLmludCgpLm9wdGlvbmFsKCksXG4gICAgdGhpcy5rZXkoJ3NlcmlhbE51bWJlcicpLmludCgpLFxuICAgIHRoaXMua2V5KCdzaWduYXR1cmUnKS51c2UoQWxnb3JpdGhtSWRlbnRpZmllciksXG4gICAgdGhpcy5rZXkoJ2lzc3VlcicpLnVzZShOYW1lKSxcbiAgICB0aGlzLmtleSgndmFsaWRpdHknKS51c2UoVmFsaWRpdHkpLFxuICAgIHRoaXMua2V5KCdzdWJqZWN0JykudXNlKE5hbWUpLFxuICAgIHRoaXMua2V5KCdzdWJqZWN0UHVibGljS2V5SW5mbycpLnVzZShTdWJqZWN0UHVibGljS2V5SW5mbyksXG4gICAgdGhpcy5rZXkoJ2lzc3VlclVuaXF1ZUlEJykuaW1wbGljaXQoMSkuYml0c3RyKCkub3B0aW9uYWwoKSxcbiAgICB0aGlzLmtleSgnc3ViamVjdFVuaXF1ZUlEJykuaW1wbGljaXQoMikuYml0c3RyKCkub3B0aW9uYWwoKSxcbiAgICB0aGlzLmtleSgnZXh0ZW5zaW9ucycpLmV4cGxpY2l0KDMpLnNlcW9mKEV4dGVuc2lvbikub3B0aW9uYWwoKVxuICApXG59KVxuXG52YXIgWDUwOUNlcnRpZmljYXRlID0gYXNuLmRlZmluZSgnWDUwOUNlcnRpZmljYXRlJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgndGJzQ2VydGlmaWNhdGUnKS51c2UoVEJTQ2VydGlmaWNhdGUpLFxuICAgIHRoaXMua2V5KCdzaWduYXR1cmVBbGdvcml0aG0nKS51c2UoQWxnb3JpdGhtSWRlbnRpZmllciksXG4gICAgdGhpcy5rZXkoJ3NpZ25hdHVyZVZhbHVlJykuYml0c3RyKClcbiAgKVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBYNTA5Q2VydGlmaWNhdGVcbiIsIi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYXBhdGlsL3BlbXN0cmlwXG52YXIgZmluZFByb2MgPSAvUHJvYy1UeXBlOiA0LEVOQ1JZUFRFRFtcXG5cXHJdK0RFSy1JbmZvOiBBRVMtKCg/OjEyOCl8KD86MTkyKXwoPzoyNTYpKS1DQkMsKFswLTlBLUhdKylbXFxuXFxyXSsoWzAtOUEtelxcblxcclxcK1xcL1xcPV0rKVtcXG5cXHJdKy9tXG52YXIgc3RhcnRSZWdleCA9IC9eLS0tLS1CRUdJTiAoKD86Lio/IEtFWSl8Q0VSVElGSUNBVEUpLS0tLS0vbVxudmFyIGZ1bGxSZWdleCA9IC9eLS0tLS1CRUdJTiAoKD86Lio/IEtFWSl8Q0VSVElGSUNBVEUpLS0tLS0oWzAtOUEtelxcblxcclxcK1xcL1xcPV0rKS0tLS0tRU5EIFxcMS0tLS0tJC9tXG52YXIgZXZwID0gcmVxdWlyZSgnZXZwX2J5dGVzdG9rZXknKVxudmFyIGNpcGhlcnMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWFlcycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9rZXksIHBhc3N3b3JkKSB7XG4gIHZhciBrZXkgPSBva2V5LnRvU3RyaW5nKClcbiAgdmFyIG1hdGNoID0ga2V5Lm1hdGNoKGZpbmRQcm9jKVxuICB2YXIgZGVjcnlwdGVkXG4gIGlmICghbWF0Y2gpIHtcbiAgICB2YXIgbWF0Y2gyID0ga2V5Lm1hdGNoKGZ1bGxSZWdleClcbiAgICBkZWNyeXB0ZWQgPSBuZXcgQnVmZmVyKG1hdGNoMlsyXS5yZXBsYWNlKC9bXFxyXFxuXS9nLCAnJyksICdiYXNlNjQnKVxuICB9IGVsc2Uge1xuICAgIHZhciBzdWl0ZSA9ICdhZXMnICsgbWF0Y2hbMV1cbiAgICB2YXIgaXYgPSBCdWZmZXIuZnJvbShtYXRjaFsyXSwgJ2hleCcpXG4gICAgdmFyIGNpcGhlclRleHQgPSBCdWZmZXIuZnJvbShtYXRjaFszXS5yZXBsYWNlKC9bXFxyXFxuXS9nLCAnJyksICdiYXNlNjQnKVxuICAgIHZhciBjaXBoZXJLZXkgPSBldnAocGFzc3dvcmQsIGl2LnNsaWNlKDAsIDgpLCBwYXJzZUludChtYXRjaFsxXSwgMTApKS5rZXlcbiAgICB2YXIgb3V0ID0gW11cbiAgICB2YXIgY2lwaGVyID0gY2lwaGVycy5jcmVhdGVEZWNpcGhlcml2KHN1aXRlLCBjaXBoZXJLZXksIGl2KVxuICAgIG91dC5wdXNoKGNpcGhlci51cGRhdGUoY2lwaGVyVGV4dCkpXG4gICAgb3V0LnB1c2goY2lwaGVyLmZpbmFsKCkpXG4gICAgZGVjcnlwdGVkID0gQnVmZmVyLmNvbmNhdChvdXQpXG4gIH1cbiAgdmFyIHRhZyA9IGtleS5tYXRjaChzdGFydFJlZ2V4KVsxXVxuICByZXR1cm4ge1xuICAgIHRhZzogdGFnLFxuICAgIGRhdGE6IGRlY3J5cHRlZFxuICB9XG59XG4iLCJ2YXIgYXNuMSA9IHJlcXVpcmUoJy4vYXNuMScpXG52YXIgYWVzaWQgPSByZXF1aXJlKCcuL2Flc2lkLmpzb24nKVxudmFyIGZpeFByb2MgPSByZXF1aXJlKCcuL2ZpeFByb2MnKVxudmFyIGNpcGhlcnMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWFlcycpXG52YXIgY29tcGF0ID0gcmVxdWlyZSgncGJrZGYyJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZUtleXNcblxuZnVuY3Rpb24gcGFyc2VLZXlzIChidWZmZXIpIHtcbiAgdmFyIHBhc3N3b3JkXG4gIGlmICh0eXBlb2YgYnVmZmVyID09PSAnb2JqZWN0JyAmJiAhQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICBwYXNzd29yZCA9IGJ1ZmZlci5wYXNzcGhyYXNlXG4gICAgYnVmZmVyID0gYnVmZmVyLmtleVxuICB9XG4gIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykge1xuICAgIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAgfVxuXG4gIHZhciBzdHJpcHBlZCA9IGZpeFByb2MoYnVmZmVyLCBwYXNzd29yZClcblxuICB2YXIgdHlwZSA9IHN0cmlwcGVkLnRhZ1xuICB2YXIgZGF0YSA9IHN0cmlwcGVkLmRhdGFcbiAgdmFyIHN1YnR5cGUsIG5kYXRhXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ0NFUlRJRklDQVRFJzpcbiAgICAgIG5kYXRhID0gYXNuMS5jZXJ0aWZpY2F0ZS5kZWNvZGUoZGF0YSwgJ2RlcicpLnRic0NlcnRpZmljYXRlLnN1YmplY3RQdWJsaWNLZXlJbmZvXG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgY2FzZSAnUFVCTElDIEtFWSc6XG4gICAgICBpZiAoIW5kYXRhKSB7XG4gICAgICAgIG5kYXRhID0gYXNuMS5QdWJsaWNLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgICAgfVxuICAgICAgc3VidHlwZSA9IG5kYXRhLmFsZ29yaXRobS5hbGdvcml0aG0uam9pbignLicpXG4gICAgICBzd2l0Y2ggKHN1YnR5cGUpIHtcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMTM1NDkuMS4xLjEnOlxuICAgICAgICAgIHJldHVybiBhc24xLlJTQVB1YmxpY0tleS5kZWNvZGUobmRhdGEuc3ViamVjdFB1YmxpY0tleS5kYXRhLCAnZGVyJylcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMDA0NS4yLjEnOlxuICAgICAgICAgIG5kYXRhLnN1YmplY3RQcml2YXRlS2V5ID0gbmRhdGEuc3ViamVjdFB1YmxpY0tleVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZWMnLFxuICAgICAgICAgICAgZGF0YTogbmRhdGFcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTAwNDAuNC4xJzpcbiAgICAgICAgICBuZGF0YS5hbGdvcml0aG0ucGFyYW1zLnB1Yl9rZXkgPSBhc24xLkRTQXBhcmFtLmRlY29kZShuZGF0YS5zdWJqZWN0UHVibGljS2V5LmRhdGEsICdkZXInKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZHNhJyxcbiAgICAgICAgICAgIGRhdGE6IG5kYXRhLmFsZ29yaXRobS5wYXJhbXNcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgaWQgJyArIHN1YnR5cGUpXG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IHR5cGUgJyArIHR5cGUpXG4gICAgY2FzZSAnRU5DUllQVEVEIFBSSVZBVEUgS0VZJzpcbiAgICAgIGRhdGEgPSBhc24xLkVuY3J5cHRlZFByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgICAgZGF0YSA9IGRlY3J5cHQoZGF0YSwgcGFzc3dvcmQpXG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgY2FzZSAnUFJJVkFURSBLRVknOlxuICAgICAgbmRhdGEgPSBhc24xLlByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgICAgc3VidHlwZSA9IG5kYXRhLmFsZ29yaXRobS5hbGdvcml0aG0uam9pbignLicpXG4gICAgICBzd2l0Y2ggKHN1YnR5cGUpIHtcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMTM1NDkuMS4xLjEnOlxuICAgICAgICAgIHJldHVybiBhc24xLlJTQVByaXZhdGVLZXkuZGVjb2RlKG5kYXRhLnN1YmplY3RQcml2YXRlS2V5LCAnZGVyJylcbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMDA0NS4yLjEnOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJ2ZTogbmRhdGEuYWxnb3JpdGhtLmN1cnZlLFxuICAgICAgICAgICAgcHJpdmF0ZUtleTogYXNuMS5FQ1ByaXZhdGVLZXkuZGVjb2RlKG5kYXRhLnN1YmplY3RQcml2YXRlS2V5LCAnZGVyJykucHJpdmF0ZUtleVxuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMDA0MC40LjEnOlxuICAgICAgICAgIG5kYXRhLmFsZ29yaXRobS5wYXJhbXMucHJpdl9rZXkgPSBhc24xLkRTQXBhcmFtLmRlY29kZShuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleSwgJ2RlcicpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdkc2EnLFxuICAgICAgICAgICAgcGFyYW1zOiBuZGF0YS5hbGdvcml0aG0ucGFyYW1zXG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IGlkICcgKyBzdWJ0eXBlKVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSB0eXBlICcgKyB0eXBlKVxuICAgIGNhc2UgJ1JTQSBQVUJMSUMgS0VZJzpcbiAgICAgIHJldHVybiBhc24xLlJTQVB1YmxpY0tleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgY2FzZSAnUlNBIFBSSVZBVEUgS0VZJzpcbiAgICAgIHJldHVybiBhc24xLlJTQVByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgIGNhc2UgJ0RTQSBQUklWQVRFIEtFWSc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZHNhJyxcbiAgICAgICAgcGFyYW1zOiBhc24xLkRTQVByaXZhdGVLZXkuZGVjb2RlKGRhdGEsICdkZXInKVxuICAgICAgfVxuICAgIGNhc2UgJ0VDIFBSSVZBVEUgS0VZJzpcbiAgICAgIGRhdGEgPSBhc24xLkVDUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJ2ZTogZGF0YS5wYXJhbWV0ZXJzLnZhbHVlLFxuICAgICAgICBwcml2YXRlS2V5OiBkYXRhLnByaXZhdGVLZXlcbiAgICAgIH1cbiAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IHR5cGUgJyArIHR5cGUpXG4gIH1cbn1cbnBhcnNlS2V5cy5zaWduYXR1cmUgPSBhc24xLnNpZ25hdHVyZVxuZnVuY3Rpb24gZGVjcnlwdCAoZGF0YSwgcGFzc3dvcmQpIHtcbiAgdmFyIHNhbHQgPSBkYXRhLmFsZ29yaXRobS5kZWNyeXB0LmtkZS5rZGVwYXJhbXMuc2FsdFxuICB2YXIgaXRlcnMgPSBwYXJzZUludChkYXRhLmFsZ29yaXRobS5kZWNyeXB0LmtkZS5rZGVwYXJhbXMuaXRlcnMudG9TdHJpbmcoKSwgMTApXG4gIHZhciBhbGdvID0gYWVzaWRbZGF0YS5hbGdvcml0aG0uZGVjcnlwdC5jaXBoZXIuYWxnby5qb2luKCcuJyldXG4gIHZhciBpdiA9IGRhdGEuYWxnb3JpdGhtLmRlY3J5cHQuY2lwaGVyLml2XG4gIHZhciBjaXBoZXJUZXh0ID0gZGF0YS5zdWJqZWN0UHJpdmF0ZUtleVxuICB2YXIga2V5bGVuID0gcGFyc2VJbnQoYWxnby5zcGxpdCgnLScpWzFdLCAxMCkgLyA4XG4gIHZhciBrZXkgPSBjb21wYXQucGJrZGYyU3luYyhwYXNzd29yZCwgc2FsdCwgaXRlcnMsIGtleWxlbiwgJ3NoYTEnKVxuICB2YXIgY2lwaGVyID0gY2lwaGVycy5jcmVhdGVEZWNpcGhlcml2KGFsZ28sIGtleSwgaXYpXG4gIHZhciBvdXQgPSBbXVxuICBvdXQucHVzaChjaXBoZXIudXBkYXRlKGNpcGhlclRleHQpKVxuICBvdXQucHVzaChjaXBoZXIuZmluYWwoKSlcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQob3V0KVxufVxuIiwiZXhwb3J0cy5wYmtkZjIgPSByZXF1aXJlKCcuL2xpYi9hc3luYycpXG5leHBvcnRzLnBia2RmMlN5bmMgPSByZXF1aXJlKCcuL2xpYi9zeW5jJylcbiIsInZhciBjaGVja1BhcmFtZXRlcnMgPSByZXF1aXJlKCcuL3ByZWNvbmRpdGlvbicpXG52YXIgZGVmYXVsdEVuY29kaW5nID0gcmVxdWlyZSgnLi9kZWZhdWx0LWVuY29kaW5nJylcbnZhciBzeW5jID0gcmVxdWlyZSgnLi9zeW5jJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgWkVST19CVUZcbnZhciBzdWJ0bGUgPSBnbG9iYWwuY3J5cHRvICYmIGdsb2JhbC5jcnlwdG8uc3VidGxlXG52YXIgdG9Ccm93c2VyID0ge1xuICAnc2hhJzogJ1NIQS0xJyxcbiAgJ3NoYS0xJzogJ1NIQS0xJyxcbiAgJ3NoYTEnOiAnU0hBLTEnLFxuICAnc2hhMjU2JzogJ1NIQS0yNTYnLFxuICAnc2hhLTI1Nic6ICdTSEEtMjU2JyxcbiAgJ3NoYTM4NCc6ICdTSEEtMzg0JyxcbiAgJ3NoYS0zODQnOiAnU0hBLTM4NCcsXG4gICdzaGEtNTEyJzogJ1NIQS01MTInLFxuICAnc2hhNTEyJzogJ1NIQS01MTInXG59XG52YXIgY2hlY2tzID0gW11cbmZ1bmN0aW9uIGNoZWNrTmF0aXZlIChhbGdvKSB7XG4gIGlmIChnbG9iYWwucHJvY2VzcyAmJiAhZ2xvYmFsLnByb2Nlc3MuYnJvd3Nlcikge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpXG4gIH1cbiAgaWYgKCFzdWJ0bGUgfHwgIXN1YnRsZS5pbXBvcnRLZXkgfHwgIXN1YnRsZS5kZXJpdmVCaXRzKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSlcbiAgfVxuICBpZiAoY2hlY2tzW2FsZ29dICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY2hlY2tzW2FsZ29dXG4gIH1cbiAgWkVST19CVUYgPSBaRVJPX0JVRiB8fCBCdWZmZXIuYWxsb2MoOClcbiAgdmFyIHByb20gPSBicm93c2VyUGJrZGYyKFpFUk9fQlVGLCBaRVJPX0JVRiwgMTAsIDEyOCwgYWxnbylcbiAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0pXG4gIGNoZWNrc1thbGdvXSA9IHByb21cbiAgcmV0dXJuIHByb21cbn1cblxuZnVuY3Rpb24gYnJvd3NlclBia2RmMiAocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGxlbmd0aCwgYWxnbykge1xuICByZXR1cm4gc3VidGxlLmltcG9ydEtleShcbiAgICAncmF3JywgcGFzc3dvcmQsIHtuYW1lOiAnUEJLREYyJ30sIGZhbHNlLCBbJ2Rlcml2ZUJpdHMnXVxuICApLnRoZW4oZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBzdWJ0bGUuZGVyaXZlQml0cyh7XG4gICAgICBuYW1lOiAnUEJLREYyJyxcbiAgICAgIHNhbHQ6IHNhbHQsXG4gICAgICBpdGVyYXRpb25zOiBpdGVyYXRpb25zLFxuICAgICAgaGFzaDoge1xuICAgICAgICBuYW1lOiBhbGdvXG4gICAgICB9XG4gICAgfSwga2V5LCBsZW5ndGggPDwgMylcbiAgfSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHJlcylcbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UgKHByb21pc2UsIGNhbGxiYWNrKSB7XG4gIHByb21pc2UudGhlbihmdW5jdGlvbiAob3V0KSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhudWxsLCBvdXQpXG4gICAgfSlcbiAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKGUpXG4gICAgfSlcbiAgfSlcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGRpZ2VzdCwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBkaWdlc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGRpZ2VzdFxuICAgIGRpZ2VzdCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgZGlnZXN0ID0gZGlnZXN0IHx8ICdzaGExJ1xuICB2YXIgYWxnbyA9IHRvQnJvd3NlcltkaWdlc3QudG9Mb3dlckNhc2UoKV1cblxuICBpZiAoIWFsZ28gfHwgdHlwZW9mIGdsb2JhbC5Qcm9taXNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG91dFxuICAgICAgdHJ5IHtcbiAgICAgICAgb3V0ID0gc3luYyhwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBkaWdlc3QpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlKVxuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgb3V0KVxuICAgIH0pXG4gIH1cblxuICBjaGVja1BhcmFtZXRlcnMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbilcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdObyBjYWxsYmFjayBwcm92aWRlZCB0byBwYmtkZjInKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYXNzd29yZCkpIHBhc3N3b3JkID0gQnVmZmVyLmZyb20ocGFzc3dvcmQsIGRlZmF1bHRFbmNvZGluZylcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoc2FsdCkpIHNhbHQgPSBCdWZmZXIuZnJvbShzYWx0LCBkZWZhdWx0RW5jb2RpbmcpXG5cbiAgcmVzb2x2ZVByb21pc2UoY2hlY2tOYXRpdmUoYWxnbykudGhlbihmdW5jdGlvbiAocmVzcCkge1xuICAgIGlmIChyZXNwKSByZXR1cm4gYnJvd3NlclBia2RmMihwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBhbGdvKVxuXG4gICAgcmV0dXJuIHN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0KVxuICB9KSwgY2FsbGJhY2spXG59XG4iLCJ2YXIgZGVmYXVsdEVuY29kaW5nXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKHByb2Nlc3MuYnJvd3Nlcikge1xuICBkZWZhdWx0RW5jb2RpbmcgPSAndXRmLTgnXG59IGVsc2Uge1xuICB2YXIgcFZlcnNpb25NYWpvciA9IHBhcnNlSW50KHByb2Nlc3MudmVyc2lvbi5zcGxpdCgnLicpWzBdLnNsaWNlKDEpLCAxMClcblxuICBkZWZhdWx0RW5jb2RpbmcgPSBwVmVyc2lvbk1ham9yID49IDYgPyAndXRmLTgnIDogJ2JpbmFyeSdcbn1cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdEVuY29kaW5nXG4iLCJ2YXIgTUFYX0FMTE9DID0gTWF0aC5wb3coMiwgMzApIC0gMSAvLyBkZWZhdWx0IGluIGlvanNcblxuZnVuY3Rpb24gY2hlY2tCdWZmZXIgKGJ1ZiwgbmFtZSkge1xuICBpZiAodHlwZW9mIGJ1ZiAhPT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihuYW1lICsgJyBtdXN0IGJlIGEgYnVmZmVyIG9yIHN0cmluZycpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbikge1xuICBjaGVja0J1ZmZlcihwYXNzd29yZCwgJ1Bhc3N3b3JkJylcbiAgY2hlY2tCdWZmZXIoc2FsdCwgJ1NhbHQnKVxuXG4gIGlmICh0eXBlb2YgaXRlcmF0aW9ucyAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJdGVyYXRpb25zIG5vdCBhIG51bWJlcicpXG4gIH1cblxuICBpZiAoaXRlcmF0aW9ucyA8IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQgaXRlcmF0aW9ucycpXG4gIH1cblxuICBpZiAodHlwZW9mIGtleWxlbiAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdLZXkgbGVuZ3RoIG5vdCBhIG51bWJlcicpXG4gIH1cblxuICBpZiAoa2V5bGVuIDwgMCB8fCBrZXlsZW4gPiBNQVhfQUxMT0MgfHwga2V5bGVuICE9PSBrZXlsZW4pIHsgLyogZXNsaW50IG5vLXNlbGYtY29tcGFyZTogMCAqL1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JhZCBrZXkgbGVuZ3RoJylcbiAgfVxufVxuIiwidmFyIG1kNSA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoL21kNScpXG52YXIgUklQRU1EMTYwID0gcmVxdWlyZSgncmlwZW1kMTYwJylcbnZhciBzaGEgPSByZXF1aXJlKCdzaGEuanMnKVxuXG52YXIgY2hlY2tQYXJhbWV0ZXJzID0gcmVxdWlyZSgnLi9wcmVjb25kaXRpb24nKVxudmFyIGRlZmF1bHRFbmNvZGluZyA9IHJlcXVpcmUoJy4vZGVmYXVsdC1lbmNvZGluZycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBaRVJPUyA9IEJ1ZmZlci5hbGxvYygxMjgpXG52YXIgc2l6ZXMgPSB7XG4gIG1kNTogMTYsXG4gIHNoYTE6IDIwLFxuICBzaGEyMjQ6IDI4LFxuICBzaGEyNTY6IDMyLFxuICBzaGEzODQ6IDQ4LFxuICBzaGE1MTI6IDY0LFxuICBybWQxNjA6IDIwLFxuICByaXBlbWQxNjA6IDIwXG59XG5cbmZ1bmN0aW9uIEhtYWMgKGFsZywga2V5LCBzYWx0TGVuKSB7XG4gIHZhciBoYXNoID0gZ2V0RGlnZXN0KGFsZylcbiAgdmFyIGJsb2Nrc2l6ZSA9IChhbGcgPT09ICdzaGE1MTInIHx8IGFsZyA9PT0gJ3NoYTM4NCcpID8gMTI4IDogNjRcblxuICBpZiAoa2V5Lmxlbmd0aCA+IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IGhhc2goa2V5KVxuICB9IGVsc2UgaWYgKGtleS5sZW5ndGggPCBibG9ja3NpemUpIHtcbiAgICBrZXkgPSBCdWZmZXIuY29uY2F0KFtrZXksIFpFUk9TXSwgYmxvY2tzaXplKVxuICB9XG5cbiAgdmFyIGlwYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYmxvY2tzaXplICsgc2l6ZXNbYWxnXSlcbiAgdmFyIG9wYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYmxvY2tzaXplICsgc2l6ZXNbYWxnXSlcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja3NpemU7IGkrKykge1xuICAgIGlwYWRbaV0gPSBrZXlbaV0gXiAweDM2XG4gICAgb3BhZFtpXSA9IGtleVtpXSBeIDB4NUNcbiAgfVxuXG4gIHZhciBpcGFkMSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShibG9ja3NpemUgKyBzYWx0TGVuICsgNClcbiAgaXBhZC5jb3B5KGlwYWQxLCAwLCAwLCBibG9ja3NpemUpXG4gIHRoaXMuaXBhZDEgPSBpcGFkMVxuICB0aGlzLmlwYWQyID0gaXBhZFxuICB0aGlzLm9wYWQgPSBvcGFkXG4gIHRoaXMuYWxnID0gYWxnXG4gIHRoaXMuYmxvY2tzaXplID0gYmxvY2tzaXplXG4gIHRoaXMuaGFzaCA9IGhhc2hcbiAgdGhpcy5zaXplID0gc2l6ZXNbYWxnXVxufVxuXG5IbWFjLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoZGF0YSwgaXBhZCkge1xuICBkYXRhLmNvcHkoaXBhZCwgdGhpcy5ibG9ja3NpemUpXG4gIHZhciBoID0gdGhpcy5oYXNoKGlwYWQpXG4gIGguY29weSh0aGlzLm9wYWQsIHRoaXMuYmxvY2tzaXplKVxuICByZXR1cm4gdGhpcy5oYXNoKHRoaXMub3BhZClcbn1cblxuZnVuY3Rpb24gZ2V0RGlnZXN0IChhbGcpIHtcbiAgZnVuY3Rpb24gc2hhRnVuYyAoZGF0YSkge1xuICAgIHJldHVybiBzaGEoYWxnKS51cGRhdGUoZGF0YSkuZGlnZXN0KClcbiAgfVxuICBmdW5jdGlvbiBybWQxNjBGdW5jIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBSSVBFTUQxNjAoKS51cGRhdGUoZGF0YSkuZGlnZXN0KClcbiAgfVxuXG4gIGlmIChhbGcgPT09ICdybWQxNjAnIHx8IGFsZyA9PT0gJ3JpcGVtZDE2MCcpIHJldHVybiBybWQxNjBGdW5jXG4gIGlmIChhbGcgPT09ICdtZDUnKSByZXR1cm4gbWQ1XG4gIHJldHVybiBzaGFGdW5jXG59XG5cbmZ1bmN0aW9uIHBia2RmMiAocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0KSB7XG4gIGNoZWNrUGFyYW1ldGVycyhwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuKVxuXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHBhc3N3b3JkKSkgcGFzc3dvcmQgPSBCdWZmZXIuZnJvbShwYXNzd29yZCwgZGVmYXVsdEVuY29kaW5nKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihzYWx0KSkgc2FsdCA9IEJ1ZmZlci5mcm9tKHNhbHQsIGRlZmF1bHRFbmNvZGluZylcblxuICBkaWdlc3QgPSBkaWdlc3QgfHwgJ3NoYTEnXG5cbiAgdmFyIGhtYWMgPSBuZXcgSG1hYyhkaWdlc3QsIHBhc3N3b3JkLCBzYWx0Lmxlbmd0aClcblxuICB2YXIgREsgPSBCdWZmZXIuYWxsb2NVbnNhZmUoa2V5bGVuKVxuICB2YXIgYmxvY2sxID0gQnVmZmVyLmFsbG9jVW5zYWZlKHNhbHQubGVuZ3RoICsgNClcbiAgc2FsdC5jb3B5KGJsb2NrMSwgMCwgMCwgc2FsdC5sZW5ndGgpXG5cbiAgdmFyIGRlc3RQb3MgPSAwXG4gIHZhciBoTGVuID0gc2l6ZXNbZGlnZXN0XVxuICB2YXIgbCA9IE1hdGguY2VpbChrZXlsZW4gLyBoTGVuKVxuXG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IGw7IGkrKykge1xuICAgIGJsb2NrMS53cml0ZVVJbnQzMkJFKGksIHNhbHQubGVuZ3RoKVxuXG4gICAgdmFyIFQgPSBobWFjLnJ1bihibG9jazEsIGhtYWMuaXBhZDEpXG4gICAgdmFyIFUgPSBUXG5cbiAgICBmb3IgKHZhciBqID0gMTsgaiA8IGl0ZXJhdGlvbnM7IGorKykge1xuICAgICAgVSA9IGhtYWMucnVuKFUsIGhtYWMuaXBhZDIpXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGhMZW47IGsrKykgVFtrXSBePSBVW2tdXG4gICAgfVxuXG4gICAgVC5jb3B5KERLLCBkZXN0UG9zKVxuICAgIGRlc3RQb3MgKz0gaExlblxuICB9XG5cbiAgcmV0dXJuIERLXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGJrZGYyXG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICghcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0geyBuZXh0VGljazogbmV4dFRpY2sgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG5cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJleHBvcnRzLnB1YmxpY0VuY3J5cHQgPSByZXF1aXJlKCcuL3B1YmxpY0VuY3J5cHQnKVxuZXhwb3J0cy5wcml2YXRlRGVjcnlwdCA9IHJlcXVpcmUoJy4vcHJpdmF0ZURlY3J5cHQnKVxuXG5leHBvcnRzLnByaXZhdGVFbmNyeXB0ID0gZnVuY3Rpb24gcHJpdmF0ZUVuY3J5cHQgKGtleSwgYnVmKSB7XG4gIHJldHVybiBleHBvcnRzLnB1YmxpY0VuY3J5cHQoa2V5LCBidWYsIHRydWUpXG59XG5cbmV4cG9ydHMucHVibGljRGVjcnlwdCA9IGZ1bmN0aW9uIHB1YmxpY0RlY3J5cHQgKGtleSwgYnVmKSB7XG4gIHJldHVybiBleHBvcnRzLnByaXZhdGVEZWNyeXB0KGtleSwgYnVmLCB0cnVlKVxufVxuIiwidmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2VlZCwgbGVuKSB7XG4gIHZhciB0ID0gQnVmZmVyLmFsbG9jKDApXG4gIHZhciBpID0gMFxuICB2YXIgY1xuICB3aGlsZSAodC5sZW5ndGggPCBsZW4pIHtcbiAgICBjID0gaTJvcHMoaSsrKVxuICAgIHQgPSBCdWZmZXIuY29uY2F0KFt0LCBjcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKHNlZWQpLnVwZGF0ZShjKS5kaWdlc3QoKV0pXG4gIH1cbiAgcmV0dXJuIHQuc2xpY2UoMCwgbGVuKVxufVxuXG5mdW5jdGlvbiBpMm9wcyAoYykge1xuICB2YXIgb3V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQpXG4gIG91dC53cml0ZVVJbnQzMkJFKGMsIDApXG4gIHJldHVybiBvdXRcbn1cbiIsInZhciBwYXJzZUtleXMgPSByZXF1aXJlKCdwYXJzZS1hc24xJylcbnZhciBtZ2YgPSByZXF1aXJlKCcuL21nZicpXG52YXIgeG9yID0gcmVxdWlyZSgnLi94b3InKVxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKVxudmFyIGNydCA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktcnNhJylcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKVxudmFyIHdpdGhQdWJsaWMgPSByZXF1aXJlKCcuL3dpdGhQdWJsaWMnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHJpdmF0ZURlY3J5cHQgKHByaXZhdGVLZXksIGVuYywgcmV2ZXJzZSkge1xuICB2YXIgcGFkZGluZ1xuICBpZiAocHJpdmF0ZUtleS5wYWRkaW5nKSB7XG4gICAgcGFkZGluZyA9IHByaXZhdGVLZXkucGFkZGluZ1xuICB9IGVsc2UgaWYgKHJldmVyc2UpIHtcbiAgICBwYWRkaW5nID0gMVxuICB9IGVsc2Uge1xuICAgIHBhZGRpbmcgPSA0XG4gIH1cblxuICB2YXIga2V5ID0gcGFyc2VLZXlzKHByaXZhdGVLZXkpXG4gIHZhciBrID0ga2V5Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpXG4gIGlmIChlbmMubGVuZ3RoID4gayB8fCBuZXcgQk4oZW5jKS5jbXAoa2V5Lm1vZHVsdXMpID49IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY3J5cHRpb24gZXJyb3InKVxuICB9XG4gIHZhciBtc2dcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBtc2cgPSB3aXRoUHVibGljKG5ldyBCTihlbmMpLCBrZXkpXG4gIH0gZWxzZSB7XG4gICAgbXNnID0gY3J0KGVuYywga2V5KVxuICB9XG4gIHZhciB6QnVmZmVyID0gQnVmZmVyLmFsbG9jKGsgLSBtc2cubGVuZ3RoKVxuICBtc2cgPSBCdWZmZXIuY29uY2F0KFt6QnVmZmVyLCBtc2ddLCBrKVxuICBpZiAocGFkZGluZyA9PT0gNCkge1xuICAgIHJldHVybiBvYWVwKGtleSwgbXNnKVxuICB9IGVsc2UgaWYgKHBhZGRpbmcgPT09IDEpIHtcbiAgICByZXR1cm4gcGtjczEoa2V5LCBtc2csIHJldmVyc2UpXG4gIH0gZWxzZSBpZiAocGFkZGluZyA9PT0gMykge1xuICAgIHJldHVybiBtc2dcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gcGFkZGluZycpXG4gIH1cbn1cblxuZnVuY3Rpb24gb2FlcCAoa2V5LCBtc2cpIHtcbiAgdmFyIGsgPSBrZXkubW9kdWx1cy5ieXRlTGVuZ3RoKClcbiAgdmFyIGlIYXNoID0gY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShCdWZmZXIuYWxsb2MoMCkpLmRpZ2VzdCgpXG4gIHZhciBoTGVuID0gaUhhc2gubGVuZ3RoXG4gIGlmIChtc2dbMF0gIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY3J5cHRpb24gZXJyb3InKVxuICB9XG4gIHZhciBtYXNrZWRTZWVkID0gbXNnLnNsaWNlKDEsIGhMZW4gKyAxKVxuICB2YXIgbWFza2VkRGIgPSBtc2cuc2xpY2UoaExlbiArIDEpXG4gIHZhciBzZWVkID0geG9yKG1hc2tlZFNlZWQsIG1nZihtYXNrZWREYiwgaExlbikpXG4gIHZhciBkYiA9IHhvcihtYXNrZWREYiwgbWdmKHNlZWQsIGsgLSBoTGVuIC0gMSkpXG4gIGlmIChjb21wYXJlKGlIYXNoLCBkYi5zbGljZSgwLCBoTGVuKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY3J5cHRpb24gZXJyb3InKVxuICB9XG4gIHZhciBpID0gaExlblxuICB3aGlsZSAoZGJbaV0gPT09IDApIHtcbiAgICBpKytcbiAgfVxuICBpZiAoZGJbaSsrXSAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVjcnlwdGlvbiBlcnJvcicpXG4gIH1cbiAgcmV0dXJuIGRiLnNsaWNlKGkpXG59XG5cbmZ1bmN0aW9uIHBrY3MxIChrZXksIG1zZywgcmV2ZXJzZSkge1xuICB2YXIgcDEgPSBtc2cuc2xpY2UoMCwgMilcbiAgdmFyIGkgPSAyXG4gIHZhciBzdGF0dXMgPSAwXG4gIHdoaWxlIChtc2dbaSsrXSAhPT0gMCkge1xuICAgIGlmIChpID49IG1zZy5sZW5ndGgpIHtcbiAgICAgIHN0YXR1cysrXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICB2YXIgcHMgPSBtc2cuc2xpY2UoMiwgaSAtIDEpXG5cbiAgaWYgKChwMS50b1N0cmluZygnaGV4JykgIT09ICcwMDAyJyAmJiAhcmV2ZXJzZSkgfHwgKHAxLnRvU3RyaW5nKCdoZXgnKSAhPT0gJzAwMDEnICYmIHJldmVyc2UpKSB7XG4gICAgc3RhdHVzKytcbiAgfVxuICBpZiAocHMubGVuZ3RoIDwgOCkge1xuICAgIHN0YXR1cysrXG4gIH1cbiAgaWYgKHN0YXR1cykge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVjcnlwdGlvbiBlcnJvcicpXG4gIH1cbiAgcmV0dXJuIG1zZy5zbGljZShpKVxufVxuZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBhID0gQnVmZmVyLmZyb20oYSlcbiAgYiA9IEJ1ZmZlci5mcm9tKGIpXG4gIHZhciBkaWYgPSAwXG4gIHZhciBsZW4gPSBhLmxlbmd0aFxuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgZGlmKytcbiAgICBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpXG4gIH1cbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgZGlmICs9IChhW2ldIF4gYltpXSlcbiAgfVxuICByZXR1cm4gZGlmXG59XG4iLCJ2YXIgcGFyc2VLZXlzID0gcmVxdWlyZSgncGFyc2UtYXNuMScpXG52YXIgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpXG52YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJylcbnZhciBtZ2YgPSByZXF1aXJlKCcuL21nZicpXG52YXIgeG9yID0gcmVxdWlyZSgnLi94b3InKVxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKVxudmFyIHdpdGhQdWJsaWMgPSByZXF1aXJlKCcuL3dpdGhQdWJsaWMnKVxudmFyIGNydCA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktcnNhJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHB1YmxpY0VuY3J5cHQgKHB1YmxpY0tleSwgbXNnLCByZXZlcnNlKSB7XG4gIHZhciBwYWRkaW5nXG4gIGlmIChwdWJsaWNLZXkucGFkZGluZykge1xuICAgIHBhZGRpbmcgPSBwdWJsaWNLZXkucGFkZGluZ1xuICB9IGVsc2UgaWYgKHJldmVyc2UpIHtcbiAgICBwYWRkaW5nID0gMVxuICB9IGVsc2Uge1xuICAgIHBhZGRpbmcgPSA0XG4gIH1cbiAgdmFyIGtleSA9IHBhcnNlS2V5cyhwdWJsaWNLZXkpXG4gIHZhciBwYWRkZWRNc2dcbiAgaWYgKHBhZGRpbmcgPT09IDQpIHtcbiAgICBwYWRkZWRNc2cgPSBvYWVwKGtleSwgbXNnKVxuICB9IGVsc2UgaWYgKHBhZGRpbmcgPT09IDEpIHtcbiAgICBwYWRkZWRNc2cgPSBwa2NzMShrZXksIG1zZywgcmV2ZXJzZSlcbiAgfSBlbHNlIGlmIChwYWRkaW5nID09PSAzKSB7XG4gICAgcGFkZGVkTXNnID0gbmV3IEJOKG1zZylcbiAgICBpZiAocGFkZGVkTXNnLmNtcChrZXkubW9kdWx1cykgPj0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhIHRvbyBsb25nIGZvciBtb2R1bHVzJylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHBhZGRpbmcnKVxuICB9XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgcmV0dXJuIGNydChwYWRkZWRNc2csIGtleSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gd2l0aFB1YmxpYyhwYWRkZWRNc2csIGtleSlcbiAgfVxufVxuXG5mdW5jdGlvbiBvYWVwIChrZXksIG1zZykge1xuICB2YXIgayA9IGtleS5tb2R1bHVzLmJ5dGVMZW5ndGgoKVxuICB2YXIgbUxlbiA9IG1zZy5sZW5ndGhcbiAgdmFyIGlIYXNoID0gY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShCdWZmZXIuYWxsb2MoMCkpLmRpZ2VzdCgpXG4gIHZhciBoTGVuID0gaUhhc2gubGVuZ3RoXG4gIHZhciBoTGVuMiA9IDIgKiBoTGVuXG4gIGlmIChtTGVuID4gayAtIGhMZW4yIC0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignbWVzc2FnZSB0b28gbG9uZycpXG4gIH1cbiAgdmFyIHBzID0gQnVmZmVyLmFsbG9jKGsgLSBtTGVuIC0gaExlbjIgLSAyKVxuICB2YXIgZGJsZW4gPSBrIC0gaExlbiAtIDFcbiAgdmFyIHNlZWQgPSByYW5kb21CeXRlcyhoTGVuKVxuICB2YXIgbWFza2VkRGIgPSB4b3IoQnVmZmVyLmNvbmNhdChbaUhhc2gsIHBzLCBCdWZmZXIuYWxsb2MoMSwgMSksIG1zZ10sIGRibGVuKSwgbWdmKHNlZWQsIGRibGVuKSlcbiAgdmFyIG1hc2tlZFNlZWQgPSB4b3Ioc2VlZCwgbWdmKG1hc2tlZERiLCBoTGVuKSlcbiAgcmV0dXJuIG5ldyBCTihCdWZmZXIuY29uY2F0KFtCdWZmZXIuYWxsb2MoMSksIG1hc2tlZFNlZWQsIG1hc2tlZERiXSwgaykpXG59XG5mdW5jdGlvbiBwa2NzMSAoa2V5LCBtc2csIHJldmVyc2UpIHtcbiAgdmFyIG1MZW4gPSBtc2cubGVuZ3RoXG4gIHZhciBrID0ga2V5Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpXG4gIGlmIChtTGVuID4gayAtIDExKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtZXNzYWdlIHRvbyBsb25nJylcbiAgfVxuICB2YXIgcHNcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBwcyA9IEJ1ZmZlci5hbGxvYyhrIC0gbUxlbiAtIDMsIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgcHMgPSBub25aZXJvKGsgLSBtTGVuIC0gMylcbiAgfVxuICByZXR1cm4gbmV3IEJOKEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFswLCByZXZlcnNlID8gMSA6IDJdKSwgcHMsIEJ1ZmZlci5hbGxvYygxKSwgbXNnXSwgaykpXG59XG5mdW5jdGlvbiBub25aZXJvIChsZW4pIHtcbiAgdmFyIG91dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW4pXG4gIHZhciBpID0gMFxuICB2YXIgY2FjaGUgPSByYW5kb21CeXRlcyhsZW4gKiAyKVxuICB2YXIgY3VyID0gMFxuICB2YXIgbnVtXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKGN1ciA9PT0gY2FjaGUubGVuZ3RoKSB7XG4gICAgICBjYWNoZSA9IHJhbmRvbUJ5dGVzKGxlbiAqIDIpXG4gICAgICBjdXIgPSAwXG4gICAgfVxuICAgIG51bSA9IGNhY2hlW2N1cisrXVxuICAgIGlmIChudW0pIHtcbiAgICAgIG91dFtpKytdID0gbnVtXG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRcbn1cbiIsInZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5mdW5jdGlvbiB3aXRoUHVibGljIChwYWRkZWRNc2csIGtleSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20ocGFkZGVkTXNnXG4gICAgLnRvUmVkKEJOLm1vbnQoa2V5Lm1vZHVsdXMpKVxuICAgIC5yZWRQb3cobmV3IEJOKGtleS5wdWJsaWNFeHBvbmVudCkpXG4gICAgLmZyb21SZWQoKVxuICAgIC50b0FycmF5KCkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2l0aFB1YmxpY1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4b3IgKGEsIGIpIHtcbiAgdmFyIGxlbiA9IGEubGVuZ3RoXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIGFbaV0gXj0gYltpXVxuICB9XG4gIHJldHVybiBhXG59XG4iLCIndXNlIHN0cmljdCdcblxuLy8gbGltaXQgb2YgQ3J5cHRvLmdldFJhbmRvbVZhbHVlcygpXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3J5cHRvL2dldFJhbmRvbVZhbHVlc1xudmFyIE1BWF9CWVRFUyA9IDY1NTM2XG5cbi8vIE5vZGUgc3VwcG9ydHMgcmVxdWVzdGluZyB1cCB0byB0aGlzIG51bWJlciBvZiBieXRlc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9pbnRlcm5hbC9jcnlwdG8vcmFuZG9tLmpzI0w0OFxudmFyIE1BWF9VSU5UMzIgPSA0Mjk0OTY3Mjk1XG5cbmZ1bmN0aW9uIG9sZEJyb3dzZXIgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIuXFxuVXNlIENocm9tZSwgRmlyZWZveCBvciBJbnRlcm5ldCBFeHBsb3JlciAxMScpXG59XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGNyeXB0byA9IGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvXG5cbmlmIChjcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJhbmRvbUJ5dGVzXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IG9sZEJyb3dzZXJcbn1cblxuZnVuY3Rpb24gcmFuZG9tQnl0ZXMgKHNpemUsIGNiKSB7XG4gIC8vIHBoYW50b21qcyBuZWVkcyB0byB0aHJvd1xuICBpZiAoc2l6ZSA+IE1BWF9VSU5UMzIpIHRocm93IG5ldyBSYW5nZUVycm9yKCdyZXF1ZXN0ZWQgdG9vIG1hbnkgcmFuZG9tIGJ5dGVzJylcblxuICB2YXIgYnl0ZXMgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSlcblxuICBpZiAoc2l6ZSA+IDApIHsgIC8vIGdldFJhbmRvbVZhbHVlcyBmYWlscyBvbiBJRSBpZiBzaXplID09IDBcbiAgICBpZiAoc2l6ZSA+IE1BWF9CWVRFUykgeyAvLyB0aGlzIGlzIHRoZSBtYXggYnl0ZXMgY3J5cHRvLmdldFJhbmRvbVZhbHVlc1xuICAgICAgLy8gY2FuIGRvIGF0IG9uY2Ugc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS93aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlc1xuICAgICAgZm9yICh2YXIgZ2VuZXJhdGVkID0gMDsgZ2VuZXJhdGVkIDwgc2l6ZTsgZ2VuZXJhdGVkICs9IE1BWF9CWVRFUykge1xuICAgICAgICAvLyBidWZmZXIuc2xpY2UgYXV0b21hdGljYWxseSBjaGVja3MgaWYgdGhlIGVuZCBpcyBwYXN0IHRoZSBlbmQgb2ZcbiAgICAgICAgLy8gdGhlIGJ1ZmZlciBzbyB3ZSBkb24ndCBoYXZlIHRvIGhlcmVcbiAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcy5zbGljZShnZW5lcmF0ZWQsIGdlbmVyYXRlZCArIE1BWF9CWVRFUykpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpXG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKG51bGwsIGJ5dGVzKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBvbGRCcm93c2VyICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdzZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyXFxudXNlIGNocm9tZSwgRmlyZUZveCBvciBJbnRlcm5ldCBFeHBsb3JlciAxMScpXG59XG52YXIgc2FmZUJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJylcbnZhciByYW5kb21ieXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJylcbnZhciBCdWZmZXIgPSBzYWZlQnVmZmVyLkJ1ZmZlclxudmFyIGtCdWZmZXJNYXhMZW5ndGggPSBzYWZlQnVmZmVyLmtNYXhMZW5ndGhcbnZhciBjcnlwdG8gPSBnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0b1xudmFyIGtNYXhVaW50MzIgPSBNYXRoLnBvdygyLCAzMikgLSAxXG5mdW5jdGlvbiBhc3NlcnRPZmZzZXQgKG9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgIT09IG9mZnNldCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29mZnNldCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPiBrTWF4VWludDMyIHx8IG9mZnNldCA8IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvZmZzZXQgbXVzdCBiZSBhIHVpbnQzMicpXG4gIH1cblxuICBpZiAob2Zmc2V0ID4ga0J1ZmZlck1heExlbmd0aCB8fCBvZmZzZXQgPiBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IG91dCBvZiByYW5nZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJyB8fCBzaXplICE9PSBzaXplKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChzaXplID4ga01heFVpbnQzMiB8fCBzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIHVpbnQzMicpXG4gIH1cblxuICBpZiAoc2l6ZSArIG9mZnNldCA+IGxlbmd0aCB8fCBzaXplID4ga0J1ZmZlck1heExlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdidWZmZXIgdG9vIHNtYWxsJylcbiAgfVxufVxuaWYgKChjcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykgfHwgIXByb2Nlc3MuYnJvd3Nlcikge1xuICBleHBvcnRzLnJhbmRvbUZpbGwgPSByYW5kb21GaWxsXG4gIGV4cG9ydHMucmFuZG9tRmlsbFN5bmMgPSByYW5kb21GaWxsU3luY1xufSBlbHNlIHtcbiAgZXhwb3J0cy5yYW5kb21GaWxsID0gb2xkQnJvd3NlclxuICBleHBvcnRzLnJhbmRvbUZpbGxTeW5jID0gb2xkQnJvd3NlclxufVxuZnVuY3Rpb24gcmFuZG9tRmlsbCAoYnVmLCBvZmZzZXQsIHNpemUsIGNiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikgJiYgIShidWYgaW5zdGFuY2VvZiBnbG9iYWwuVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZlwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgb3IgVWludDhBcnJheScpXG4gIH1cblxuICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gMFxuICAgIHNpemUgPSBidWYubGVuZ3RoXG4gIH0gZWxzZSBpZiAodHlwZW9mIHNpemUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IHNpemVcbiAgICBzaXplID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICB9IGVsc2UgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2JcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICB9XG4gIGFzc2VydE9mZnNldChvZmZzZXQsIGJ1Zi5sZW5ndGgpXG4gIGFzc2VydFNpemUoc2l6ZSwgb2Zmc2V0LCBidWYubGVuZ3RoKVxuICByZXR1cm4gYWN0dWFsRmlsbChidWYsIG9mZnNldCwgc2l6ZSwgY2IpXG59XG5cbmZ1bmN0aW9uIGFjdHVhbEZpbGwgKGJ1Ziwgb2Zmc2V0LCBzaXplLCBjYikge1xuICBpZiAocHJvY2Vzcy5icm93c2VyKSB7XG4gICAgdmFyIG91ckJ1ZiA9IGJ1Zi5idWZmZXJcbiAgICB2YXIgdWludCA9IG5ldyBVaW50OEFycmF5KG91ckJ1Ziwgb2Zmc2V0LCBzaXplKVxuICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXModWludClcbiAgICBpZiAoY2IpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBjYihudWxsLCBidWYpXG4gICAgICB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHJldHVybiBidWZcbiAgfVxuICBpZiAoY2IpIHtcbiAgICByYW5kb21ieXRlcyhzaXplLCBmdW5jdGlvbiAoZXJyLCBieXRlcykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgfVxuICAgICAgYnl0ZXMuY29weShidWYsIG9mZnNldClcbiAgICAgIGNiKG51bGwsIGJ1ZilcbiAgICB9KVxuICAgIHJldHVyblxuICB9XG4gIHZhciBieXRlcyA9IHJhbmRvbWJ5dGVzKHNpemUpXG4gIGJ5dGVzLmNvcHkoYnVmLCBvZmZzZXQpXG4gIHJldHVybiBidWZcbn1cbmZ1bmN0aW9uIHJhbmRvbUZpbGxTeW5jIChidWYsIG9mZnNldCwgc2l6ZSkge1xuICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvZmZzZXQgPSAwXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSAmJiAhKGJ1ZiBpbnN0YW5jZW9mIGdsb2JhbC5VaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBvciBVaW50OEFycmF5JylcbiAgfVxuXG4gIGFzc2VydE9mZnNldChvZmZzZXQsIGJ1Zi5sZW5ndGgpXG5cbiAgaWYgKHNpemUgPT09IHVuZGVmaW5lZCkgc2l6ZSA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcblxuICBhc3NlcnRTaXplKHNpemUsIG9mZnNldCwgYnVmLmxlbmd0aClcblxuICByZXR1cm4gYWN0dWFsRmlsbChidWYsIG9mZnNldCwgc2l6ZSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gYXZvaWQgc2NvcGUgY3JlZXAsIHRoZSBrZXlzIGFycmF5IGNhbiB0aGVuIGJlIGNvbGxlY3RlZFxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcG5hLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5lbmQoKTtcblxuICBwbmEubmV4dFRpY2soY2IsIGVycik7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG5cbiAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgcmVhZGFibGVId20gPSBvcHRpb25zLnJlYWRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmIChyZWFkYWJsZUh3bSB8fCByZWFkYWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHJlYWRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICBjYihlcnIpO1xufTtcblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICAgIGlmIChlcikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50JykpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwbmEubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHBuYS5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHsgaGFzVW5waXBlZDogZmFsc2UgfTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHBuYS5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH1cblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICBwLmRhdGEuY29weShyZXQpO1xuICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTtcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gICAgX3RoaXMyLmVtaXQoJ2Nsb3NlJyk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qIDxyZXBsYWNlbWVudD4gKi9cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcG5hLm5leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgd3JpdGFibGVId20gPSBvcHRpb25zLndyaXRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmICh3cml0YWJsZUh3bSB8fCB3cml0YWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHdyaXRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTtcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHBuYS5uZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG4gICAgcG5hLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcG5hLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwbmEubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfVxuICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGNvcmtSZXE7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLmVuZCgpO1xuICBjYihlcnIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAtLXRoaXMubGVuZ3RoO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICB9cmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAocCkge1xuICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpO1xuXG5pZiAodXRpbCAmJiB1dGlsLmluc3BlY3QgJiYgdXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICBtb2R1bGUuZXhwb3J0cy5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHV0aWwuaW5zcGVjdCh7IGxlbmd0aDogdGhpcy5sZW5ndGggfSk7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSArICcgJyArIG9iajtcbiAgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcbiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuUGFzc1Rocm91Z2hcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5UcmFuc2Zvcm1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuIiwiJ3VzZSBzdHJpY3QnXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaEJhc2UgPSByZXF1aXJlKCdoYXNoLWJhc2UnKVxuXG52YXIgQVJSQVkxNiA9IG5ldyBBcnJheSgxNilcblxudmFyIHpsID0gW1xuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICA3LCA0LCAxMywgMSwgMTAsIDYsIDE1LCAzLCAxMiwgMCwgOSwgNSwgMiwgMTQsIDExLCA4LFxuICAzLCAxMCwgMTQsIDQsIDksIDE1LCA4LCAxLCAyLCA3LCAwLCA2LCAxMywgMTEsIDUsIDEyLFxuICAxLCA5LCAxMSwgMTAsIDAsIDgsIDEyLCA0LCAxMywgMywgNywgMTUsIDE0LCA1LCA2LCAyLFxuICA0LCAwLCA1LCA5LCA3LCAxMiwgMiwgMTAsIDE0LCAxLCAzLCA4LCAxMSwgNiwgMTUsIDEzXG5dXG5cbnZhciB6ciA9IFtcbiAgNSwgMTQsIDcsIDAsIDksIDIsIDExLCA0LCAxMywgNiwgMTUsIDgsIDEsIDEwLCAzLCAxMixcbiAgNiwgMTEsIDMsIDcsIDAsIDEzLCA1LCAxMCwgMTQsIDE1LCA4LCAxMiwgNCwgOSwgMSwgMixcbiAgMTUsIDUsIDEsIDMsIDcsIDE0LCA2LCA5LCAxMSwgOCwgMTIsIDIsIDEwLCAwLCA0LCAxMyxcbiAgOCwgNiwgNCwgMSwgMywgMTEsIDE1LCAwLCA1LCAxMiwgMiwgMTMsIDksIDcsIDEwLCAxNCxcbiAgMTIsIDE1LCAxMCwgNCwgMSwgNSwgOCwgNywgNiwgMiwgMTMsIDE0LCAwLCAzLCA5LCAxMVxuXVxuXG52YXIgc2wgPSBbXG4gIDExLCAxNCwgMTUsIDEyLCA1LCA4LCA3LCA5LCAxMSwgMTMsIDE0LCAxNSwgNiwgNywgOSwgOCxcbiAgNywgNiwgOCwgMTMsIDExLCA5LCA3LCAxNSwgNywgMTIsIDE1LCA5LCAxMSwgNywgMTMsIDEyLFxuICAxMSwgMTMsIDYsIDcsIDE0LCA5LCAxMywgMTUsIDE0LCA4LCAxMywgNiwgNSwgMTIsIDcsIDUsXG4gIDExLCAxMiwgMTQsIDE1LCAxNCwgMTUsIDksIDgsIDksIDE0LCA1LCA2LCA4LCA2LCA1LCAxMixcbiAgOSwgMTUsIDUsIDExLCA2LCA4LCAxMywgMTIsIDUsIDEyLCAxMywgMTQsIDExLCA4LCA1LCA2XG5dXG5cbnZhciBzciA9IFtcbiAgOCwgOSwgOSwgMTEsIDEzLCAxNSwgMTUsIDUsIDcsIDcsIDgsIDExLCAxNCwgMTQsIDEyLCA2LFxuICA5LCAxMywgMTUsIDcsIDEyLCA4LCA5LCAxMSwgNywgNywgMTIsIDcsIDYsIDE1LCAxMywgMTEsXG4gIDksIDcsIDE1LCAxMSwgOCwgNiwgNiwgMTQsIDEyLCAxMywgNSwgMTQsIDEzLCAxMywgNywgNSxcbiAgMTUsIDUsIDgsIDExLCAxNCwgMTQsIDYsIDE0LCA2LCA5LCAxMiwgOSwgMTIsIDUsIDE1LCA4LFxuICA4LCA1LCAxMiwgOSwgMTIsIDUsIDE0LCA2LCA4LCAxMywgNiwgNSwgMTUsIDEzLCAxMSwgMTFcbl1cblxudmFyIGhsID0gWzB4MDAwMDAwMDAsIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMsIDB4YTk1M2ZkNGVdXG52YXIgaHIgPSBbMHg1MGEyOGJlNiwgMHg1YzRkZDEyNCwgMHg2ZDcwM2VmMywgMHg3YTZkNzZlOSwgMHgwMDAwMDAwMF1cblxuZnVuY3Rpb24gUklQRU1EMTYwICgpIHtcbiAgSGFzaEJhc2UuY2FsbCh0aGlzLCA2NClcblxuICAvLyBzdGF0ZVxuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxuICB0aGlzLl9lID0gMHhjM2QyZTFmMFxufVxuXG5pbmhlcml0cyhSSVBFTUQxNjAsIEhhc2hCYXNlKVxuXG5SSVBFTUQxNjAucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB3b3JkcyA9IEFSUkFZMTZcbiAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgKytqKSB3b3Jkc1tqXSA9IHRoaXMuX2Jsb2NrLnJlYWRJbnQzMkxFKGogKiA0KVxuXG4gIHZhciBhbCA9IHRoaXMuX2EgfCAwXG4gIHZhciBibCA9IHRoaXMuX2IgfCAwXG4gIHZhciBjbCA9IHRoaXMuX2MgfCAwXG4gIHZhciBkbCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlbCA9IHRoaXMuX2UgfCAwXG5cbiAgdmFyIGFyID0gdGhpcy5fYSB8IDBcbiAgdmFyIGJyID0gdGhpcy5fYiB8IDBcbiAgdmFyIGNyID0gdGhpcy5fYyB8IDBcbiAgdmFyIGRyID0gdGhpcy5fZCB8IDBcbiAgdmFyIGVyID0gdGhpcy5fZSB8IDBcblxuICAvLyBjb21wdXRhdGlvblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDgwOyBpICs9IDEpIHtcbiAgICB2YXIgdGxcbiAgICB2YXIgdHJcbiAgICBpZiAoaSA8IDE2KSB7XG4gICAgICB0bCA9IGZuMShhbCwgYmwsIGNsLCBkbCwgZWwsIHdvcmRzW3psW2ldXSwgaGxbMF0sIHNsW2ldKVxuICAgICAgdHIgPSBmbjUoYXIsIGJyLCBjciwgZHIsIGVyLCB3b3Jkc1t6cltpXV0sIGhyWzBdLCBzcltpXSlcbiAgICB9IGVsc2UgaWYgKGkgPCAzMikge1xuICAgICAgdGwgPSBmbjIoYWwsIGJsLCBjbCwgZGwsIGVsLCB3b3Jkc1t6bFtpXV0sIGhsWzFdLCBzbFtpXSlcbiAgICAgIHRyID0gZm40KGFyLCBiciwgY3IsIGRyLCBlciwgd29yZHNbenJbaV1dLCBoclsxXSwgc3JbaV0pXG4gICAgfSBlbHNlIGlmIChpIDwgNDgpIHtcbiAgICAgIHRsID0gZm4zKGFsLCBibCwgY2wsIGRsLCBlbCwgd29yZHNbemxbaV1dLCBobFsyXSwgc2xbaV0pXG4gICAgICB0ciA9IGZuMyhhciwgYnIsIGNyLCBkciwgZXIsIHdvcmRzW3pyW2ldXSwgaHJbMl0sIHNyW2ldKVxuICAgIH0gZWxzZSBpZiAoaSA8IDY0KSB7XG4gICAgICB0bCA9IGZuNChhbCwgYmwsIGNsLCBkbCwgZWwsIHdvcmRzW3psW2ldXSwgaGxbM10sIHNsW2ldKVxuICAgICAgdHIgPSBmbjIoYXIsIGJyLCBjciwgZHIsIGVyLCB3b3Jkc1t6cltpXV0sIGhyWzNdLCBzcltpXSlcbiAgICB9IGVsc2UgeyAvLyBpZiAoaTw4MCkge1xuICAgICAgdGwgPSBmbjUoYWwsIGJsLCBjbCwgZGwsIGVsLCB3b3Jkc1t6bFtpXV0sIGhsWzRdLCBzbFtpXSlcbiAgICAgIHRyID0gZm4xKGFyLCBiciwgY3IsIGRyLCBlciwgd29yZHNbenJbaV1dLCBocls0XSwgc3JbaV0pXG4gICAgfVxuXG4gICAgYWwgPSBlbFxuICAgIGVsID0gZGxcbiAgICBkbCA9IHJvdGwoY2wsIDEwKVxuICAgIGNsID0gYmxcbiAgICBibCA9IHRsXG5cbiAgICBhciA9IGVyXG4gICAgZXIgPSBkclxuICAgIGRyID0gcm90bChjciwgMTApXG4gICAgY3IgPSBiclxuICAgIGJyID0gdHJcbiAgfVxuXG4gIC8vIHVwZGF0ZSBzdGF0ZVxuICB2YXIgdCA9ICh0aGlzLl9iICsgY2wgKyBkcikgfCAwXG4gIHRoaXMuX2IgPSAodGhpcy5fYyArIGRsICsgZXIpIHwgMFxuICB0aGlzLl9jID0gKHRoaXMuX2QgKyBlbCArIGFyKSB8IDBcbiAgdGhpcy5fZCA9ICh0aGlzLl9lICsgYWwgKyBicikgfCAwXG4gIHRoaXMuX2UgPSAodGhpcy5fYSArIGJsICsgY3IpIHwgMFxuICB0aGlzLl9hID0gdFxufVxuXG5SSVBFTUQxNjAucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGNyZWF0ZSBwYWRkaW5nIGFuZCBoYW5kbGUgYmxvY2tzXG4gIHRoaXMuX2Jsb2NrW3RoaXMuX2Jsb2NrT2Zmc2V0KytdID0gMHg4MFxuICBpZiAodGhpcy5fYmxvY2tPZmZzZXQgPiA1Nikge1xuICAgIHRoaXMuX2Jsb2NrLmZpbGwoMCwgdGhpcy5fYmxvY2tPZmZzZXQsIDY0KVxuICAgIHRoaXMuX3VwZGF0ZSgpXG4gICAgdGhpcy5fYmxvY2tPZmZzZXQgPSAwXG4gIH1cblxuICB0aGlzLl9ibG9jay5maWxsKDAsIHRoaXMuX2Jsb2NrT2Zmc2V0LCA1NilcbiAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJMRSh0aGlzLl9sZW5ndGhbMF0sIDU2KVxuICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkxFKHRoaXMuX2xlbmd0aFsxXSwgNjApXG4gIHRoaXMuX3VwZGF0ZSgpXG5cbiAgLy8gcHJvZHVjZSByZXN1bHRcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyA/IEJ1ZmZlci5hbGxvYygyMCkgOiBuZXcgQnVmZmVyKDIwKVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2EsIDApXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fYiwgNClcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9jLCA4KVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2QsIDEyKVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2UsIDE2KVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIHJvdGwgKHgsIG4pIHtcbiAgcmV0dXJuICh4IDw8IG4pIHwgKHggPj4+ICgzMiAtIG4pKVxufVxuXG5mdW5jdGlvbiBmbjEgKGEsIGIsIGMsIGQsIGUsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKGIgXiBjIF4gZCkgKyBtICsgaykgfCAwLCBzKSArIGUpIHwgMFxufVxuXG5mdW5jdGlvbiBmbjIgKGEsIGIsIGMsIGQsIGUsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKChiICYgYykgfCAoKH5iKSAmIGQpKSArIG0gKyBrKSB8IDAsIHMpICsgZSkgfCAwXG59XG5cbmZ1bmN0aW9uIGZuMyAoYSwgYiwgYywgZCwgZSwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoKGIgfCAofmMpKSBeIGQpICsgbSArIGspIHwgMCwgcykgKyBlKSB8IDBcbn1cblxuZnVuY3Rpb24gZm40IChhLCBiLCBjLCBkLCBlLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArICgoYiAmIGQpIHwgKGMgJiAofmQpKSkgKyBtICsgaykgfCAwLCBzKSArIGUpIHwgMFxufVxuXG5mdW5jdGlvbiBmbjUgKGEsIGIsIGMsIGQsIGUsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKGIgXiAoYyB8ICh+ZCkpKSArIG0gKyBrKSB8IDAsIHMpICsgZSkgfCAwXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUklQRU1EMTYwXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbi8vIHByb3RvdHlwZSBjbGFzcyBmb3IgaGFzaCBmdW5jdGlvbnNcbmZ1bmN0aW9uIEhhc2ggKGJsb2NrU2l6ZSwgZmluYWxTaXplKSB7XG4gIHRoaXMuX2Jsb2NrID0gQnVmZmVyLmFsbG9jKGJsb2NrU2l6ZSlcbiAgdGhpcy5fZmluYWxTaXplID0gZmluYWxTaXplXG4gIHRoaXMuX2Jsb2NrU2l6ZSA9IGJsb2NrU2l6ZVxuICB0aGlzLl9sZW4gPSAwXG59XG5cbkhhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGVuYyA9IGVuYyB8fCAndXRmOCdcbiAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgZW5jKVxuICB9XG5cbiAgdmFyIGJsb2NrID0gdGhpcy5fYmxvY2tcbiAgdmFyIGJsb2NrU2l6ZSA9IHRoaXMuX2Jsb2NrU2l6ZVxuICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGhcbiAgdmFyIGFjY3VtID0gdGhpcy5fbGVuXG5cbiAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbGVuZ3RoOykge1xuICAgIHZhciBhc3NpZ25lZCA9IGFjY3VtICUgYmxvY2tTaXplXG4gICAgdmFyIHJlbWFpbmRlciA9IE1hdGgubWluKGxlbmd0aCAtIG9mZnNldCwgYmxvY2tTaXplIC0gYXNzaWduZWQpXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbWFpbmRlcjsgaSsrKSB7XG4gICAgICBibG9ja1thc3NpZ25lZCArIGldID0gZGF0YVtvZmZzZXQgKyBpXVxuICAgIH1cblxuICAgIGFjY3VtICs9IHJlbWFpbmRlclxuICAgIG9mZnNldCArPSByZW1haW5kZXJcblxuICAgIGlmICgoYWNjdW0gJSBibG9ja1NpemUpID09PSAwKSB7XG4gICAgICB0aGlzLl91cGRhdGUoYmxvY2spXG4gICAgfVxuICB9XG5cbiAgdGhpcy5fbGVuICs9IGxlbmd0aFxuICByZXR1cm4gdGhpc1xufVxuXG5IYXNoLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHZhciByZW0gPSB0aGlzLl9sZW4gJSB0aGlzLl9ibG9ja1NpemVcblxuICB0aGlzLl9ibG9ja1tyZW1dID0gMHg4MFxuXG4gIC8vIHplcm8gKHJlbSArIDEpIHRyYWlsaW5nIGJpdHMsIHdoZXJlIChyZW0gKyAxKSBpcyB0aGUgc21hbGxlc3RcbiAgLy8gbm9uLW5lZ2F0aXZlIHNvbHV0aW9uIHRvIHRoZSBlcXVhdGlvbiAobGVuZ3RoICsgMSArIChyZW0gKyAxKSkgPT09IGZpbmFsU2l6ZSBtb2QgYmxvY2tTaXplXG4gIHRoaXMuX2Jsb2NrLmZpbGwoMCwgcmVtICsgMSlcblxuICBpZiAocmVtID49IHRoaXMuX2ZpbmFsU2l6ZSkge1xuICAgIHRoaXMuX3VwZGF0ZSh0aGlzLl9ibG9jaylcbiAgICB0aGlzLl9ibG9jay5maWxsKDApXG4gIH1cblxuICB2YXIgYml0cyA9IHRoaXMuX2xlbiAqIDhcblxuICAvLyB1aW50MzJcbiAgaWYgKGJpdHMgPD0gMHhmZmZmZmZmZikge1xuICAgIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyQkUoYml0cywgdGhpcy5fYmxvY2tTaXplIC0gNClcblxuICAvLyB1aW50NjRcbiAgfSBlbHNlIHtcbiAgICB2YXIgbG93Qml0cyA9IChiaXRzICYgMHhmZmZmZmZmZikgPj4+IDBcbiAgICB2YXIgaGlnaEJpdHMgPSAoYml0cyAtIGxvd0JpdHMpIC8gMHgxMDAwMDAwMDBcblxuICAgIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyQkUoaGlnaEJpdHMsIHRoaXMuX2Jsb2NrU2l6ZSAtIDgpXG4gICAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJCRShsb3dCaXRzLCB0aGlzLl9ibG9ja1NpemUgLSA0KVxuICB9XG5cbiAgdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKVxuICB2YXIgaGFzaCA9IHRoaXMuX2hhc2goKVxuXG4gIHJldHVybiBlbmMgPyBoYXNoLnRvU3RyaW5nKGVuYykgOiBoYXNoXG59XG5cbkhhc2gucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3VwZGF0ZSBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoXG4iLCJ2YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gU0hBIChhbGdvcml0aG0pIHtcbiAgYWxnb3JpdGhtID0gYWxnb3JpdGhtLnRvTG93ZXJDYXNlKClcblxuICB2YXIgQWxnb3JpdGhtID0gZXhwb3J0c1thbGdvcml0aG1dXG4gIGlmICghQWxnb3JpdGhtKSB0aHJvdyBuZXcgRXJyb3IoYWxnb3JpdGhtICsgJyBpcyBub3Qgc3VwcG9ydGVkICh3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0cyknKVxuXG4gIHJldHVybiBuZXcgQWxnb3JpdGhtKClcbn1cblxuZXhwb3J0cy5zaGEgPSByZXF1aXJlKCcuL3NoYScpXG5leHBvcnRzLnNoYTEgPSByZXF1aXJlKCcuL3NoYTEnKVxuZXhwb3J0cy5zaGEyMjQgPSByZXF1aXJlKCcuL3NoYTIyNCcpXG5leHBvcnRzLnNoYTI1NiA9IHJlcXVpcmUoJy4vc2hhMjU2JylcbmV4cG9ydHMuc2hhMzg0ID0gcmVxdWlyZSgnLi9zaGEzODQnKVxuZXhwb3J0cy5zaGE1MTIgPSByZXF1aXJlKCcuL3NoYTUxMicpXG4iLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0wLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBkZXJpdmVkIGZyb20gc2hhMS5qcyBvZiB0aGUgc2FtZSByZXBvc2l0b3J5LlxuICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBTSEEtMCBhbmQgU0hBLTEgaXMganVzdCBhIGJpdHdpc2Ugcm90YXRlIGxlZnRcbiAqIG9wZXJhdGlvbiB3YXMgYWRkZWQuXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBLID0gW1xuICAweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjIHwgMCwgMHhjYTYyYzFkNiB8IDBcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoODApXG5cbmZ1bmN0aW9uIFNoYSAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhLCBIYXNoKVxuXG5TaGEucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweDY3NDUyMzAxXG4gIHRoaXMuX2IgPSAweGVmY2RhYjg5XG4gIHRoaXMuX2MgPSAweDk4YmFkY2ZlXG4gIHRoaXMuX2QgPSAweDEwMzI1NDc2XG4gIHRoaXMuX2UgPSAweGMzZDJlMWYwXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gcm90bDUgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCA1KSB8IChudW0gPj4+IDI3KVxufVxuXG5mdW5jdGlvbiByb3RsMzAgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCAzMCkgfCAobnVtID4+PiAyKVxufVxuXG5mdW5jdGlvbiBmdCAocywgYiwgYywgZCkge1xuICBpZiAocyA9PT0gMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpXG4gIGlmIChzID09PSAyKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpXG4gIHJldHVybiBiIF4gYyBeIGRcbn1cblxuU2hhLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgZm9yICg7IGkgPCA4MDsgKytpKSBXW2ldID0gV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7ICsraikge1xuICAgIHZhciBzID0gfn4oaiAvIDIwKVxuICAgIHZhciB0ID0gKHJvdGw1KGEpICsgZnQocywgYiwgYywgZCkgKyBlICsgV1tqXSArIEtbc10pIHwgMFxuXG4gICAgZSA9IGRcbiAgICBkID0gY1xuICAgIGMgPSByb3RsMzAoYilcbiAgICBiID0gYVxuICAgIGEgPSB0XG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG59XG5cblNoYS5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIwKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EgfCAwLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iIHwgMCwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYyB8IDAsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QgfCAwLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSB8IDAsIDE2KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhXG4iLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0xLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVmVyc2lvbiAyLjFhIENvcHlyaWdodCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDAyLlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgZGV0YWlscy5cbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEsgPSBbXG4gIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMgfCAwLCAweGNhNjJjMWQ2IHwgMFxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg4MClcblxuZnVuY3Rpb24gU2hhMSAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMSwgSGFzaClcblxuU2hhMS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjBcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiByb3RsMSAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDEpIHwgKG51bSA+Pj4gMzEpXG59XG5cbmZ1bmN0aW9uIHJvdGw1IChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgNSkgfCAobnVtID4+PiAyNylcbn1cblxuZnVuY3Rpb24gcm90bDMwIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMzApIHwgKG51bSA+Pj4gMilcbn1cblxuZnVuY3Rpb24gZnQgKHMsIGIsIGMsIGQpIHtcbiAgaWYgKHMgPT09IDApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKVxuICBpZiAocyA9PT0gMikgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKVxuICByZXR1cm4gYiBeIGMgXiBkXG59XG5cblNoYTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDgwOyArK2kpIFdbaV0gPSByb3RsMShXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdKVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7ICsraikge1xuICAgIHZhciBzID0gfn4oaiAvIDIwKVxuICAgIHZhciB0ID0gKHJvdGw1KGEpICsgZnQocywgYiwgYywgZCkgKyBlICsgV1tqXSArIEtbc10pIHwgMFxuXG4gICAgZSA9IGRcbiAgICBkID0gY1xuICAgIGMgPSByb3RsMzAoYilcbiAgICBiID0gYVxuICAgIGEgPSB0XG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG59XG5cblNoYTEucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyMClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hIHwgMCwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiB8IDAsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MgfCAwLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kIHwgMCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UgfCAwLCAxNilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTFcbiIsIi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBXID0gbmV3IEFycmF5KDY0KVxuXG5mdW5jdGlvbiBTaGEyMjQgKCkge1xuICB0aGlzLmluaXQoKVxuXG4gIHRoaXMuX3cgPSBXIC8vIG5ldyBBcnJheSg2NClcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEyMjQsIFNoYTI1NilcblxuU2hhMjI0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHhjMTA1OWVkOFxuICB0aGlzLl9iID0gMHgzNjdjZDUwN1xuICB0aGlzLl9jID0gMHgzMDcwZGQxN1xuICB0aGlzLl9kID0gMHhmNzBlNTkzOVxuICB0aGlzLl9lID0gMHhmZmMwMGIzMVxuICB0aGlzLl9mID0gMHg2ODU4MTUxMVxuICB0aGlzLl9nID0gMHg2NGY5OGZhN1xuICB0aGlzLl9oID0gMHhiZWZhNGZhNFxuXG4gIHJldHVybiB0aGlzXG59XG5cblNoYTIyNC5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDI4KVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lLCAxNilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZiwgMjApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2csIDI0KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMjI0XG4iLCIvKipcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMjU2LCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIDE4MC0yXG4gKiBWZXJzaW9uIDIuMi1iZXRhIENvcHlyaWdodCBBbmdlbCBNYXJpbiwgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwOS5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBLID0gW1xuICAweDQyOEEyRjk4LCAweDcxMzc0NDkxLCAweEI1QzBGQkNGLCAweEU5QjVEQkE1LFxuICAweDM5NTZDMjVCLCAweDU5RjExMUYxLCAweDkyM0Y4MkE0LCAweEFCMUM1RUQ1LFxuICAweEQ4MDdBQTk4LCAweDEyODM1QjAxLCAweDI0MzE4NUJFLCAweDU1MEM3REMzLFxuICAweDcyQkU1RDc0LCAweDgwREVCMUZFLCAweDlCREMwNkE3LCAweEMxOUJGMTc0LFxuICAweEU0OUI2OUMxLCAweEVGQkU0Nzg2LCAweDBGQzE5REM2LCAweDI0MENBMUNDLFxuICAweDJERTkyQzZGLCAweDRBNzQ4NEFBLCAweDVDQjBBOURDLCAweDc2Rjk4OERBLFxuICAweDk4M0U1MTUyLCAweEE4MzFDNjZELCAweEIwMDMyN0M4LCAweEJGNTk3RkM3LFxuICAweEM2RTAwQkYzLCAweEQ1QTc5MTQ3LCAweDA2Q0E2MzUxLCAweDE0MjkyOTY3LFxuICAweDI3QjcwQTg1LCAweDJFMUIyMTM4LCAweDREMkM2REZDLCAweDUzMzgwRDEzLFxuICAweDY1MEE3MzU0LCAweDc2NkEwQUJCLCAweDgxQzJDOTJFLCAweDkyNzIyQzg1LFxuICAweEEyQkZFOEExLCAweEE4MUE2NjRCLCAweEMyNEI4QjcwLCAweEM3NkM1MUEzLFxuICAweEQxOTJFODE5LCAweEQ2OTkwNjI0LCAweEY0MEUzNTg1LCAweDEwNkFBMDcwLFxuICAweDE5QTRDMTE2LCAweDFFMzc2QzA4LCAweDI3NDg3NzRDLCAweDM0QjBCQ0I1LFxuICAweDM5MUMwQ0IzLCAweDRFRDhBQTRBLCAweDVCOUNDQTRGLCAweDY4MkU2RkYzLFxuICAweDc0OEY4MkVFLCAweDc4QTU2MzZGLCAweDg0Qzg3ODE0LCAweDhDQzcwMjA4LFxuICAweDkwQkVGRkZBLCAweEE0NTA2Q0VCLCAweEJFRjlBM0Y3LCAweEM2NzE3OEYyXG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDY0KVxuXG5mdW5jdGlvbiBTaGEyNTYgKCkge1xuICB0aGlzLmluaXQoKVxuXG4gIHRoaXMuX3cgPSBXIC8vIG5ldyBBcnJheSg2NClcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEyNTYsIEhhc2gpXG5cblNoYTI1Ni5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4NmEwOWU2NjdcbiAgdGhpcy5fYiA9IDB4YmI2N2FlODVcbiAgdGhpcy5fYyA9IDB4M2M2ZWYzNzJcbiAgdGhpcy5fZCA9IDB4YTU0ZmY1M2FcbiAgdGhpcy5fZSA9IDB4NTEwZTUyN2ZcbiAgdGhpcy5fZiA9IDB4OWIwNTY4OGNcbiAgdGhpcy5fZyA9IDB4MWY4M2Q5YWJcbiAgdGhpcy5faCA9IDB4NWJlMGNkMTlcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBjaCAoeCwgeSwgeikge1xuICByZXR1cm4geiBeICh4ICYgKHkgXiB6KSlcbn1cblxuZnVuY3Rpb24gbWFqICh4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIHwgKHogJiAoeCB8IHkpKVxufVxuXG5mdW5jdGlvbiBzaWdtYTAgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiAyIHwgeCA8PCAzMCkgXiAoeCA+Pj4gMTMgfCB4IDw8IDE5KSBeICh4ID4+PiAyMiB8IHggPDwgMTApXG59XG5cbmZ1bmN0aW9uIHNpZ21hMSAoeCkge1xuICByZXR1cm4gKHggPj4+IDYgfCB4IDw8IDI2KSBeICh4ID4+PiAxMSB8IHggPDwgMjEpIF4gKHggPj4+IDI1IHwgeCA8PCA3KVxufVxuXG5mdW5jdGlvbiBnYW1tYTAgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiA3IHwgeCA8PCAyNSkgXiAoeCA+Pj4gMTggfCB4IDw8IDE0KSBeICh4ID4+PiAzKVxufVxuXG5mdW5jdGlvbiBnYW1tYTEgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiAxNyB8IHggPDwgMTUpIF4gKHggPj4+IDE5IHwgeCA8PCAxMykgXiAoeCA+Pj4gMTApXG59XG5cblNoYTI1Ni5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuICB2YXIgZiA9IHRoaXMuX2YgfCAwXG4gIHZhciBnID0gdGhpcy5fZyB8IDBcbiAgdmFyIGggPSB0aGlzLl9oIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gIGZvciAoOyBpIDwgNjQ7ICsraSkgV1tpXSA9IChnYW1tYTEoV1tpIC0gMl0pICsgV1tpIC0gN10gKyBnYW1tYTAoV1tpIC0gMTVdKSArIFdbaSAtIDE2XSkgfCAwXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA2NDsgKytqKSB7XG4gICAgdmFyIFQxID0gKGggKyBzaWdtYTEoZSkgKyBjaChlLCBmLCBnKSArIEtbal0gKyBXW2pdKSB8IDBcbiAgICB2YXIgVDIgPSAoc2lnbWEwKGEpICsgbWFqKGEsIGIsIGMpKSB8IDBcblxuICAgIGggPSBnXG4gICAgZyA9IGZcbiAgICBmID0gZVxuICAgIGUgPSAoZCArIFQxKSB8IDBcbiAgICBkID0gY1xuICAgIGMgPSBiXG4gICAgYiA9IGFcbiAgICBhID0gKFQxICsgVDIpIHwgMFxuICB9XG5cbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gIHRoaXMuX2IgPSAoYiArIHRoaXMuX2IpIHwgMFxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gIHRoaXMuX2UgPSAoZSArIHRoaXMuX2UpIHwgMFxuICB0aGlzLl9mID0gKGYgKyB0aGlzLl9mKSB8IDBcbiAgdGhpcy5fZyA9IChnICsgdGhpcy5fZykgfCAwXG4gIHRoaXMuX2ggPSAoaCArIHRoaXMuX2gpIHwgMFxufVxuXG5TaGEyNTYucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgzMilcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSwgMTYpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2YsIDIwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9nLCAyNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5faCwgMjgpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEyNTZcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBTSEE1MTIgPSByZXF1aXJlKCcuL3NoYTUxMicpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIFcgPSBuZXcgQXJyYXkoMTYwKVxuXG5mdW5jdGlvbiBTaGEzODQgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCAxMjgsIDExMilcbn1cblxuaW5oZXJpdHMoU2hhMzg0LCBTSEE1MTIpXG5cblNoYTM4NC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYWggPSAweGNiYmI5ZDVkXG4gIHRoaXMuX2JoID0gMHg2MjlhMjkyYVxuICB0aGlzLl9jaCA9IDB4OTE1OTAxNWFcbiAgdGhpcy5fZGggPSAweDE1MmZlY2Q4XG4gIHRoaXMuX2VoID0gMHg2NzMzMjY2N1xuICB0aGlzLl9maCA9IDB4OGViNDRhODdcbiAgdGhpcy5fZ2ggPSAweGRiMGMyZTBkXG4gIHRoaXMuX2hoID0gMHg0N2I1NDgxZFxuXG4gIHRoaXMuX2FsID0gMHhjMTA1OWVkOFxuICB0aGlzLl9ibCA9IDB4MzY3Y2Q1MDdcbiAgdGhpcy5fY2wgPSAweDMwNzBkZDE3XG4gIHRoaXMuX2RsID0gMHhmNzBlNTkzOVxuICB0aGlzLl9lbCA9IDB4ZmZjMDBiMzFcbiAgdGhpcy5fZmwgPSAweDY4NTgxNTExXG4gIHRoaXMuX2dsID0gMHg2NGY5OGZhN1xuICB0aGlzLl9obCA9IDB4YmVmYTRmYTRcblxuICByZXR1cm4gdGhpc1xufVxuXG5TaGEzODQucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0OClcblxuICBmdW5jdGlvbiB3cml0ZUludDY0QkUgKGgsIGwsIG9mZnNldCkge1xuICAgIEgud3JpdGVJbnQzMkJFKGgsIG9mZnNldClcbiAgICBILndyaXRlSW50MzJCRShsLCBvZmZzZXQgKyA0KVxuICB9XG5cbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2FoLCB0aGlzLl9hbCwgMClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2JoLCB0aGlzLl9ibCwgOClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2NoLCB0aGlzLl9jbCwgMTYpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9kaCwgdGhpcy5fZGwsIDI0KVxuICB3cml0ZUludDY0QkUodGhpcy5fZWgsIHRoaXMuX2VsLCAzMilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2ZoLCB0aGlzLl9mbCwgNDApXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEzODRcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXVxuXG52YXIgVyA9IG5ldyBBcnJheSgxNjApXG5cbmZ1bmN0aW9uIFNoYTUxMiAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDEyOCwgMTEyKVxufVxuXG5pbmhlcml0cyhTaGE1MTIsIEhhc2gpXG5cblNoYTUxMi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYWggPSAweDZhMDllNjY3XG4gIHRoaXMuX2JoID0gMHhiYjY3YWU4NVxuICB0aGlzLl9jaCA9IDB4M2M2ZWYzNzJcbiAgdGhpcy5fZGggPSAweGE1NGZmNTNhXG4gIHRoaXMuX2VoID0gMHg1MTBlNTI3ZlxuICB0aGlzLl9maCA9IDB4OWIwNTY4OGNcbiAgdGhpcy5fZ2ggPSAweDFmODNkOWFiXG4gIHRoaXMuX2hoID0gMHg1YmUwY2QxOVxuXG4gIHRoaXMuX2FsID0gMHhmM2JjYzkwOFxuICB0aGlzLl9ibCA9IDB4ODRjYWE3M2JcbiAgdGhpcy5fY2wgPSAweGZlOTRmODJiXG4gIHRoaXMuX2RsID0gMHg1ZjFkMzZmMVxuICB0aGlzLl9lbCA9IDB4YWRlNjgyZDFcbiAgdGhpcy5fZmwgPSAweDJiM2U2YzFmXG4gIHRoaXMuX2dsID0gMHhmYjQxYmQ2YlxuICB0aGlzLl9obCA9IDB4MTM3ZTIxNzlcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBDaCAoeCwgeSwgeikge1xuICByZXR1cm4geiBeICh4ICYgKHkgXiB6KSlcbn1cblxuZnVuY3Rpb24gbWFqICh4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIHwgKHogJiAoeCB8IHkpKVxufVxuXG5mdW5jdGlvbiBzaWdtYTAgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMjggfCB4bCA8PCA0KSBeICh4bCA+Pj4gMiB8IHggPDwgMzApIF4gKHhsID4+PiA3IHwgeCA8PCAyNSlcbn1cblxuZnVuY3Rpb24gc2lnbWExICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDE0IHwgeGwgPDwgMTgpIF4gKHggPj4+IDE4IHwgeGwgPDwgMTQpIF4gKHhsID4+PiA5IHwgeCA8PCAyMylcbn1cblxuZnVuY3Rpb24gR2FtbWEwICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDEgfCB4bCA8PCAzMSkgXiAoeCA+Pj4gOCB8IHhsIDw8IDI0KSBeICh4ID4+PiA3KVxufVxuXG5mdW5jdGlvbiBHYW1tYTBsICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDEgfCB4bCA8PCAzMSkgXiAoeCA+Pj4gOCB8IHhsIDw8IDI0KSBeICh4ID4+PiA3IHwgeGwgPDwgMjUpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMSAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxOSB8IHhsIDw8IDEzKSBeICh4bCA+Pj4gMjkgfCB4IDw8IDMpIF4gKHggPj4+IDYpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMWwgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMTkgfCB4bCA8PCAxMykgXiAoeGwgPj4+IDI5IHwgeCA8PCAzKSBeICh4ID4+PiA2IHwgeGwgPDwgMjYpXG59XG5cbmZ1bmN0aW9uIGdldENhcnJ5IChhLCBiKSB7XG4gIHJldHVybiAoYSA+Pj4gMCkgPCAoYiA+Pj4gMCkgPyAxIDogMFxufVxuXG5TaGE1MTIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYWggPSB0aGlzLl9haCB8IDBcbiAgdmFyIGJoID0gdGhpcy5fYmggfCAwXG4gIHZhciBjaCA9IHRoaXMuX2NoIHwgMFxuICB2YXIgZGggPSB0aGlzLl9kaCB8IDBcbiAgdmFyIGVoID0gdGhpcy5fZWggfCAwXG4gIHZhciBmaCA9IHRoaXMuX2ZoIHwgMFxuICB2YXIgZ2ggPSB0aGlzLl9naCB8IDBcbiAgdmFyIGhoID0gdGhpcy5faGggfCAwXG5cbiAgdmFyIGFsID0gdGhpcy5fYWwgfCAwXG4gIHZhciBibCA9IHRoaXMuX2JsIHwgMFxuICB2YXIgY2wgPSB0aGlzLl9jbCB8IDBcbiAgdmFyIGRsID0gdGhpcy5fZGwgfCAwXG4gIHZhciBlbCA9IHRoaXMuX2VsIHwgMFxuICB2YXIgZmwgPSB0aGlzLl9mbCB8IDBcbiAgdmFyIGdsID0gdGhpcy5fZ2wgfCAwXG4gIHZhciBobCA9IHRoaXMuX2hsIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkgKz0gMikge1xuICAgIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICAgIFdbaSArIDFdID0gTS5yZWFkSW50MzJCRShpICogNCArIDQpXG4gIH1cbiAgZm9yICg7IGkgPCAxNjA7IGkgKz0gMikge1xuICAgIHZhciB4aCA9IFdbaSAtIDE1ICogMl1cbiAgICB2YXIgeGwgPSBXW2kgLSAxNSAqIDIgKyAxXVxuICAgIHZhciBnYW1tYTAgPSBHYW1tYTAoeGgsIHhsKVxuICAgIHZhciBnYW1tYTBsID0gR2FtbWEwbCh4bCwgeGgpXG5cbiAgICB4aCA9IFdbaSAtIDIgKiAyXVxuICAgIHhsID0gV1tpIC0gMiAqIDIgKyAxXVxuICAgIHZhciBnYW1tYTEgPSBHYW1tYTEoeGgsIHhsKVxuICAgIHZhciBnYW1tYTFsID0gR2FtbWExbCh4bCwgeGgpXG5cbiAgICAvLyBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl1cbiAgICB2YXIgV2k3aCA9IFdbaSAtIDcgKiAyXVxuICAgIHZhciBXaTdsID0gV1tpIC0gNyAqIDIgKyAxXVxuXG4gICAgdmFyIFdpMTZoID0gV1tpIC0gMTYgKiAyXVxuICAgIHZhciBXaTE2bCA9IFdbaSAtIDE2ICogMiArIDFdXG5cbiAgICB2YXIgV2lsID0gKGdhbW1hMGwgKyBXaTdsKSB8IDBcbiAgICB2YXIgV2loID0gKGdhbW1hMCArIFdpN2ggKyBnZXRDYXJyeShXaWwsIGdhbW1hMGwpKSB8IDBcbiAgICBXaWwgPSAoV2lsICsgZ2FtbWExbCkgfCAwXG4gICAgV2loID0gKFdpaCArIGdhbW1hMSArIGdldENhcnJ5KFdpbCwgZ2FtbWExbCkpIHwgMFxuICAgIFdpbCA9IChXaWwgKyBXaTE2bCkgfCAwXG4gICAgV2loID0gKFdpaCArIFdpMTZoICsgZ2V0Q2FycnkoV2lsLCBXaTE2bCkpIHwgMFxuXG4gICAgV1tpXSA9IFdpaFxuICAgIFdbaSArIDFdID0gV2lsXG4gIH1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDE2MDsgaiArPSAyKSB7XG4gICAgV2loID0gV1tqXVxuICAgIFdpbCA9IFdbaiArIDFdXG5cbiAgICB2YXIgbWFqaCA9IG1haihhaCwgYmgsIGNoKVxuICAgIHZhciBtYWpsID0gbWFqKGFsLCBibCwgY2wpXG5cbiAgICB2YXIgc2lnbWEwaCA9IHNpZ21hMChhaCwgYWwpXG4gICAgdmFyIHNpZ21hMGwgPSBzaWdtYTAoYWwsIGFoKVxuICAgIHZhciBzaWdtYTFoID0gc2lnbWExKGVoLCBlbClcbiAgICB2YXIgc2lnbWExbCA9IHNpZ21hMShlbCwgZWgpXG5cbiAgICAvLyB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbal0gKyBXW2pdXG4gICAgdmFyIEtpaCA9IEtbal1cbiAgICB2YXIgS2lsID0gS1tqICsgMV1cblxuICAgIHZhciBjaGggPSBDaChlaCwgZmgsIGdoKVxuICAgIHZhciBjaGwgPSBDaChlbCwgZmwsIGdsKVxuXG4gICAgdmFyIHQxbCA9IChobCArIHNpZ21hMWwpIHwgMFxuICAgIHZhciB0MWggPSAoaGggKyBzaWdtYTFoICsgZ2V0Q2FycnkodDFsLCBobCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBjaGwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBjaGggKyBnZXRDYXJyeSh0MWwsIGNobCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBLaWwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBLaWggKyBnZXRDYXJyeSh0MWwsIEtpbCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBXaWwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBXaWggKyBnZXRDYXJyeSh0MWwsIFdpbCkpIHwgMFxuXG4gICAgLy8gdDIgPSBzaWdtYTAgKyBtYWpcbiAgICB2YXIgdDJsID0gKHNpZ21hMGwgKyBtYWpsKSB8IDBcbiAgICB2YXIgdDJoID0gKHNpZ21hMGggKyBtYWpoICsgZ2V0Q2FycnkodDJsLCBzaWdtYTBsKSkgfCAwXG5cbiAgICBoaCA9IGdoXG4gICAgaGwgPSBnbFxuICAgIGdoID0gZmhcbiAgICBnbCA9IGZsXG4gICAgZmggPSBlaFxuICAgIGZsID0gZWxcbiAgICBlbCA9IChkbCArIHQxbCkgfCAwXG4gICAgZWggPSAoZGggKyB0MWggKyBnZXRDYXJyeShlbCwgZGwpKSB8IDBcbiAgICBkaCA9IGNoXG4gICAgZGwgPSBjbFxuICAgIGNoID0gYmhcbiAgICBjbCA9IGJsXG4gICAgYmggPSBhaFxuICAgIGJsID0gYWxcbiAgICBhbCA9ICh0MWwgKyB0MmwpIHwgMFxuICAgIGFoID0gKHQxaCArIHQyaCArIGdldENhcnJ5KGFsLCB0MWwpKSB8IDBcbiAgfVxuXG4gIHRoaXMuX2FsID0gKHRoaXMuX2FsICsgYWwpIHwgMFxuICB0aGlzLl9ibCA9ICh0aGlzLl9ibCArIGJsKSB8IDBcbiAgdGhpcy5fY2wgPSAodGhpcy5fY2wgKyBjbCkgfCAwXG4gIHRoaXMuX2RsID0gKHRoaXMuX2RsICsgZGwpIHwgMFxuICB0aGlzLl9lbCA9ICh0aGlzLl9lbCArIGVsKSB8IDBcbiAgdGhpcy5fZmwgPSAodGhpcy5fZmwgKyBmbCkgfCAwXG4gIHRoaXMuX2dsID0gKHRoaXMuX2dsICsgZ2wpIHwgMFxuICB0aGlzLl9obCA9ICh0aGlzLl9obCArIGhsKSB8IDBcblxuICB0aGlzLl9haCA9ICh0aGlzLl9haCArIGFoICsgZ2V0Q2FycnkodGhpcy5fYWwsIGFsKSkgfCAwXG4gIHRoaXMuX2JoID0gKHRoaXMuX2JoICsgYmggKyBnZXRDYXJyeSh0aGlzLl9ibCwgYmwpKSB8IDBcbiAgdGhpcy5fY2ggPSAodGhpcy5fY2ggKyBjaCArIGdldENhcnJ5KHRoaXMuX2NsLCBjbCkpIHwgMFxuICB0aGlzLl9kaCA9ICh0aGlzLl9kaCArIGRoICsgZ2V0Q2FycnkodGhpcy5fZGwsIGRsKSkgfCAwXG4gIHRoaXMuX2VoID0gKHRoaXMuX2VoICsgZWggKyBnZXRDYXJyeSh0aGlzLl9lbCwgZWwpKSB8IDBcbiAgdGhpcy5fZmggPSAodGhpcy5fZmggKyBmaCArIGdldENhcnJ5KHRoaXMuX2ZsLCBmbCkpIHwgMFxuICB0aGlzLl9naCA9ICh0aGlzLl9naCArIGdoICsgZ2V0Q2FycnkodGhpcy5fZ2wsIGdsKSkgfCAwXG4gIHRoaXMuX2hoID0gKHRoaXMuX2hoICsgaGggKyBnZXRDYXJyeSh0aGlzLl9obCwgaGwpKSB8IDBcbn1cblxuU2hhNTEyLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoNjQpXG5cbiAgZnVuY3Rpb24gd3JpdGVJbnQ2NEJFIChoLCBsLCBvZmZzZXQpIHtcbiAgICBILndyaXRlSW50MzJCRShoLCBvZmZzZXQpXG4gICAgSC53cml0ZUludDMyQkUobCwgb2Zmc2V0ICsgNClcbiAgfVxuXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9haCwgdGhpcy5fYWwsIDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9iaCwgdGhpcy5fYmwsIDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9jaCwgdGhpcy5fY2wsIDE2KVxuICB3cml0ZUludDY0QkUodGhpcy5fZGgsIHRoaXMuX2RsLCAyNClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2VoLCB0aGlzLl9lbCwgMzIpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9maCwgdGhpcy5fZmwsIDQwKVxuICB3cml0ZUludDY0QkUodGhpcy5fZ2gsIHRoaXMuX2dsLCA0OClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2hoLCB0aGlzLl9obCwgNTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGE1MTJcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiAtMTtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSkgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCcucmVwZWF0KHApO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJy5yZXBlYXQocCArIDEpO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCcucmVwZWF0KHAgKyAyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBmb3IgZWFjaCBidWZmZXJlZCBieXRlIG9mIGEgKHBhcnRpYWwpXG4vLyBjaGFyYWN0ZXIgbmVlZHMgdG8gYmUgYWRkZWQgdG8gdGhlIG91dHB1dC5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnLnJlcGVhdCh0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJ2YXIgaW5kZXhPZiA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcblxudmFyIE9iamVjdF9rZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChPYmplY3Qua2V5cykgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSByZXMucHVzaChrZXkpXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufTtcblxudmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoeHMsIGZuKSB7XG4gICAgaWYgKHhzLmZvckVhY2gpIHJldHVybiB4cy5mb3JFYWNoKGZuKVxuICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbih4c1tpXSwgaSwgeHMpO1xuICAgIH1cbn07XG5cbnZhciBkZWZpbmVQcm9wID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ18nLCB7fSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIG9ialtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cbn0oKSk7XG5cbnZhciBnbG9iYWxzID0gWydBcnJheScsICdCb29sZWFuJywgJ0RhdGUnLCAnRXJyb3InLCAnRXZhbEVycm9yJywgJ0Z1bmN0aW9uJyxcbidJbmZpbml0eScsICdKU09OJywgJ01hdGgnLCAnTmFOJywgJ051bWJlcicsICdPYmplY3QnLCAnUmFuZ2VFcnJvcicsXG4nUmVmZXJlbmNlRXJyb3InLCAnUmVnRXhwJywgJ1N0cmluZycsICdTeW50YXhFcnJvcicsICdUeXBlRXJyb3InLCAnVVJJRXJyb3InLFxuJ2RlY29kZVVSSScsICdkZWNvZGVVUklDb21wb25lbnQnLCAnZW5jb2RlVVJJJywgJ2VuY29kZVVSSUNvbXBvbmVudCcsICdlc2NhcGUnLFxuJ2V2YWwnLCAnaXNGaW5pdGUnLCAnaXNOYU4nLCAncGFyc2VGbG9hdCcsICdwYXJzZUludCcsICd1bmRlZmluZWQnLCAndW5lc2NhcGUnXTtcblxuZnVuY3Rpb24gQ29udGV4dCgpIHt9XG5Db250ZXh0LnByb3RvdHlwZSA9IHt9O1xuXG52YXIgU2NyaXB0ID0gZXhwb3J0cy5TY3JpcHQgPSBmdW5jdGlvbiBOb2RlU2NyaXB0IChjb2RlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNjcmlwdCkpIHJldHVybiBuZXcgU2NyaXB0KGNvZGUpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG59O1xuXG5TY3JpcHQucHJvdG90eXBlLnJ1bkluQ29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgaWYgKCEoY29udGV4dCBpbnN0YW5jZW9mIENvbnRleHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJuZWVkcyBhICdjb250ZXh0JyBhcmd1bWVudC5cIik7XG4gICAgfVxuICAgIFxuICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZiAoIWlmcmFtZS5zdHlsZSkgaWZyYW1lLnN0eWxlID0ge307XG4gICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIFxuICAgIHZhciB3aW4gPSBpZnJhbWUuY29udGVudFdpbmRvdztcbiAgICB2YXIgd0V2YWwgPSB3aW4uZXZhbCwgd0V4ZWNTY3JpcHQgPSB3aW4uZXhlY1NjcmlwdDtcblxuICAgIGlmICghd0V2YWwgJiYgd0V4ZWNTY3JpcHQpIHtcbiAgICAgICAgLy8gd2luLmV2YWwoKSBtYWdpY2FsbHkgYXBwZWFycyB3aGVuIHRoaXMgaXMgY2FsbGVkIGluIElFOlxuICAgICAgICB3RXhlY1NjcmlwdC5jYWxsKHdpbiwgJ251bGwnKTtcbiAgICAgICAgd0V2YWwgPSB3aW4uZXZhbDtcbiAgICB9XG4gICAgXG4gICAgZm9yRWFjaChPYmplY3Rfa2V5cyhjb250ZXh0KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB3aW5ba2V5XSA9IGNvbnRleHRba2V5XTtcbiAgICB9KTtcbiAgICBmb3JFYWNoKGdsb2JhbHMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGNvbnRleHRba2V5XSkge1xuICAgICAgICAgICAgd2luW2tleV0gPSBjb250ZXh0W2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICB2YXIgd2luS2V5cyA9IE9iamVjdF9rZXlzKHdpbik7XG5cbiAgICB2YXIgcmVzID0gd0V2YWwuY2FsbCh3aW4sIHRoaXMuY29kZSk7XG4gICAgXG4gICAgZm9yRWFjaChPYmplY3Rfa2V5cyh3aW4pLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8vIEF2b2lkIGNvcHlpbmcgY2lyY3VsYXIgb2JqZWN0cyBsaWtlIGB0b3BgIGFuZCBgd2luZG93YCBieSBvbmx5XG4gICAgICAgIC8vIHVwZGF0aW5nIGV4aXN0aW5nIGNvbnRleHQgcHJvcGVydGllcyBvciBuZXcgcHJvcGVydGllcyBpbiB0aGUgYHdpbmBcbiAgICAgICAgLy8gdGhhdCB3YXMgb25seSBpbnRyb2R1Y2VkIGFmdGVyIHRoZSBldmFsLlxuICAgICAgICBpZiAoa2V5IGluIGNvbnRleHQgfHwgaW5kZXhPZih3aW5LZXlzLCBrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgY29udGV4dFtrZXldID0gd2luW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvckVhY2goZ2xvYmFscywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gY29udGV4dCkpIHtcbiAgICAgICAgICAgIGRlZmluZVByb3AoY29udGV4dCwga2V5LCB3aW5ba2V5XSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgXG4gICAgcmV0dXJuIHJlcztcbn07XG5cblNjcmlwdC5wcm90b3R5cGUucnVuSW5UaGlzQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZXZhbCh0aGlzLmNvZGUpOyAvLyBtYXliZS4uLlxufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5Jbk5ld0NvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBjdHggPSBTY3JpcHQuY3JlYXRlQ29udGV4dChjb250ZXh0KTtcbiAgICB2YXIgcmVzID0gdGhpcy5ydW5JbkNvbnRleHQoY3R4KTtcblxuICAgIGZvckVhY2goT2JqZWN0X2tleXMoY3R4KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBjb250ZXh0W2tleV0gPSBjdHhba2V5XTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXM7XG59O1xuXG5mb3JFYWNoKE9iamVjdF9rZXlzKFNjcmlwdC5wcm90b3R5cGUpLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGV4cG9ydHNbbmFtZV0gPSBTY3JpcHRbbmFtZV0gPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICB2YXIgcyA9IFNjcmlwdChjb2RlKTtcbiAgICAgICAgcmV0dXJuIHNbbmFtZV0uYXBwbHkocywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB9O1xufSk7XG5cbmV4cG9ydHMuY3JlYXRlU2NyaXB0ID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5TY3JpcHQoY29kZSk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBTY3JpcHQuY3JlYXRlQ29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIGNvcHkgPSBuZXcgQ29udGV4dCgpO1xuICAgIGlmKHR5cGVvZiBjb250ZXh0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3JFYWNoKE9iamVjdF9rZXlzKGNvbnRleHQpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBjb3B5W2tleV0gPSBjb250ZXh0W2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn07XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCIvKipcbiAqIFN1cHBvcnQgbW9kdWxlcyB1c2VkIGJ5IFNrZXRjaFJOTlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogRGVhbHMgd2l0aCBkZWNvbXByZXNzaW5nIGI2NCBtb2RlbHMgdG8gdWludDggYXJyYXlzLlxuICpcbiAqIEBwYXJhbSBiNjRlbmNvZGVkIFN0cmluZyBvZiBiNjQgZW5jb2RlZCBkYXRhLlxuICogQHJldHVybnMgdWludDggdmVyc2lvbiBvZiBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nVG9VaW50OGFycmF5KGI2NGVuY29kZWQ6IHN0cmluZykge1xuICBjb25zdCB1ODogVWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGF0b2IoYjY0ZW5jb2RlZClcbiAgICAuc3BsaXQoXCJcIilcbiAgICAubWFwKChjOiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICAgICAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKTtcbiAgICB9KSk7XG4gIHJldHVybiB1ODtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBiNjQgZGF0YSBpbnRvIGludDE2IGFycmF5IHZlcnNpb24uXG4gKlxuICogQHBhcmFtIGI2NGVuY29kZWQgU3RyaW5nIG9mIGI2NCBlbmNvZGVkIGRhdGEuXG4gKiBAcmV0dXJucyBpbnQxNiB2ZXJzaW9uIG9mIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb0FycmF5KGI2NGVuY29kZWQ6IHN0cmluZykge1xuICBjb25zdCB1OiBVaW50OEFycmF5ID0gc3RyaW5nVG9VaW50OGFycmF5KGI2NGVuY29kZWQpO1xuICBjb25zdCByZXN1bHQ6IEludDE2QXJyYXkgPSBuZXcgSW50MTZBcnJheSh1LmJ1ZmZlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIEZ1bmN0aW9ucyBmb3Igc2FtcGxpbmcgbm9ybWFsIG9yIGJpLW5vcm1hbHNcblxuLy8gUmFuZG9tIG51bWJlcnMgdXRpbCAoZnJvbSBodHRwczovL2dpdGh1Yi5jb20va2FycGF0aHkvcmVjdXJyZW50anMpXG5sZXQgcmV0dXJuViA9IGZhbHNlO1xubGV0IHZWYWwgPSAwLjA7XG5leHBvcnQgZnVuY3Rpb24gZ2F1c3NSYW5kb20oKTogbnVtYmVyIHtcbiAgaWYgKHJldHVyblYpIHtcbiAgICByZXR1cm5WID0gZmFsc2U7XG4gICAgcmV0dXJuIHZWYWw7XG4gIH1cbiAgY29uc3QgdSA9IDIgKiBNYXRoLnJhbmRvbSgpIC0gMTtcbiAgY29uc3QgdiA9IDIgKiBNYXRoLnJhbmRvbSgpIC0gMTtcbiAgY29uc3QgciA9IHUgKiB1ICsgdiAqIHY7XG4gIGlmIChyID09PSAwIHx8IHIgPiAxKSB7XG4gICAgcmV0dXJuIGdhdXNzUmFuZG9tKCk7XG4gIH1cbiAgY29uc3QgYyA9IE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHIpIC8gcik7XG4gIHZWYWwgPSB2ICogYzsgLy8gY2FjaGUgdGhpc1xuICByZXR1cm5WID0gdHJ1ZTtcbiAgcmV0dXJuIHUgKiBjO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRmKGE6IG51bWJlciwgYjogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAoYiAtIGEpICsgYTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByYW5kaShhOiBudW1iZXIsIGI6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoYiAtIGEpICsgYSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmFuZG4obXU6IG51bWJlciwgc3RkOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gbXUgKyBnYXVzc1JhbmRvbSgpICogc3RkO1xufVxuLy8gRnJvbSBodHRwOi8vd3d3Lm1hdGguZ3Jpbi5lZHUvfm1vb3JldC9jb3Vyc2VzL21hdGgzMzYvYml2YXJpYXRlLW5vcm1hbC5odG1sXG5leHBvcnQgZnVuY3Rpb24gYmlyYW5kbihcbiAgbXUxOiBudW1iZXIsXG4gIG11MjogbnVtYmVyLFxuICBzdGQxOiBudW1iZXIsXG4gIHN0ZDI6IG51bWJlcixcbiAgcmhvOiBudW1iZXIpOiBudW1iZXJbXSB7XG4gIGNvbnN0IHoxID0gcmFuZG4oMCwgMSk7XG4gIGNvbnN0IHoyID0gcmFuZG4oMCwgMSk7XG4gIGNvbnN0IHggPSBNYXRoLnNxcnQoMSAtIHJobyAqIHJobykgKiBzdGQxICogejEgKyByaG8gKiBzdGQxICogejIgKyBtdTE7XG4gIGNvbnN0IHkgPSBzdGQyICogejIgKyBtdTI7XG4gIHJldHVybiBbeCwgeV07XG59XG5cbi8qKlxuICogU2FtcGxlIGZyb20gYSBjYXRlZ29yaWFsIGRpc3RyaWJ1dGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FtcGxlU29mdG1heCh6U2FtcGxlOiBudW1iZXJbXSB8IEZsb2F0MzJBcnJheSk6IG51bWJlciB7XG4gIGNvbnN0IHggPSByYW5kZigwLCAxKTtcbiAgY29uc3QgTiA9IHpTYW1wbGUubGVuZ3RoO1xuICBsZXQgYWNjdW11bGF0ZSA9IDA7XG4gIGxldCBpOiBudW1iZXI7XG4gIGZvciAoaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICBhY2N1bXVsYXRlICs9IHpTYW1wbGVbaV07XG4gICAgaWYgKGFjY3VtdWxhdGUgPj0geCkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIGNvbnNvbGUubG9nKCdlcnJvciBzYW1wbGluZyBwaSBpbmRleCcpO1xuICByZXR1cm4gLTE7XG59XG5cbi8vIExlZ2FjeSBSRFAgYWxnb3JpdGhtIGltcGxlbWVudGF0aW9uLCBwb3J0ZWQgb3ZlciB0byBUeXBlU2NyaXB0LlxuXG5leHBvcnQgZnVuY3Rpb24gc2ltcGxpZnlMaW5lKFY6IG51bWJlcltdW10sIHRvbGVyYW5jZT0yLjApOiBudW1iZXJbXVtdIHtcbiAgLypcbiAgZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9hZGFtbWlsbGVyLzgyNjE0OFxuICBWIC4uLiBbW3gxLHkxXSxbeDIseTJdLC4uLl0gcG9seWxpbmVcbiAgdG9sICAuLi4gYXBwcm94aW1hdGlvbiB0b2xlcmFuY2VcbiAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBDb3B5cmlnaHQgMjAwMiwgc29mdFN1cmZlciAod3d3LnNvZnRzdXJmZXIuY29tKVxuICBUaGlzIGNvZGUgbWF5IGJlIGZyZWVseSB1c2VkIGFuZCBtb2RpZmllZCBmb3IgYW55IHB1cnBvc2VcbiAgcHJvdmlkaW5nIHRoYXQgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIGluY2x1ZGVkIHdpdGggaXQuXG4gIFNvZnRTdXJmZXIgbWFrZXMgbm8gd2FycmFudHkgZm9yIHRoaXMgY29kZSwgYW5kIGNhbm5vdCBiZSBoZWxkXG4gIGxpYWJsZSBmb3IgYW55IHJlYWwgb3IgaW1hZ2luZWQgZGFtYWdlIHJlc3VsdGluZyBmcm9tIGl0cyB1c2UuXG4gIFVzZXJzIG9mIHRoaXMgY29kZSBtdXN0IHZlcmlmeSBjb3JyZWN0bmVzcyBmb3IgdGhlaXIgYXBwbGljYXRpb24uXG4gIGh0dHA6Ly9zb2Z0c3VyZmVyLmNvbS9BcmNoaXZlL2FsZ29yaXRobV8wMjA1L2FsZ29yaXRobV8wMjA1Lmh0bVxuICAqL1xuXG4gIGNvbnN0IHRvbCA9IHRvbGVyYW5jZTtcblxuICBmdW5jdGlvbiBkaWZmKHU6IG51bWJlcltdLCB2OiBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgICByZXR1cm4gW3VbMF0gLSB2WzBdLCB1WzFdIC0gdlsxXV07XG4gIH1cbiAgZnVuY3Rpb24gZG90KHU6IG51bWJlcltdLCB2OiBudW1iZXJbXSk6IG51bWJlciB7XG4gICAgcmV0dXJuIHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV07XG4gIH1cbiAgZnVuY3Rpb24gbm9ybTIodjogbnVtYmVyW10pOiBudW1iZXIge1xuICAgIHJldHVybiB2WzBdICogdlswXSArIHZbMV0gKiB2WzFdO1xuICB9XG4gIGZ1bmN0aW9uIGQyKHU6IG51bWJlcltdLCB2OiBudW1iZXJbXSk6IG51bWJlciB7cmV0dXJuIG5vcm0yKGRpZmYodSwgdikpO31cblxuICBmdW5jdGlvbiBzaW1wbGlmeURQKHRvbDogbnVtYmVyLCB2OiBudW1iZXJbXVtdLFxuICAgIGo6IG51bWJlciwgazogbnVtYmVyLCBtazogbnVtYmVyW10pIHtcbiAgICAvKlxuICAgIFRoaXMgaXMgdGhlIERvdWdsYXMtUGV1Y2tlciByZWN1cnNpdmUgc2ltcGxpZmljYXRpb24gcm91dGluZVxuICAgIEl0IGp1c3QgbWFya3MgdmVydGljZXMgdGhhdCBhcmUgcGFydCBvZiB0aGUgc2ltcGxpZmllZCBwb2x5bGluZVxuICAgIGZvciBhcHByb3hpbWF0aW5nIHRoZSBwb2x5bGluZSBzdWJjaGFpbiB2W2pdIHRvIHZba10uXG4gICAgbWtbXSAuLi4gYXJyYXkgb2YgbWFya2VycyBtYXRjaGluZyB2ZXJ0ZXggYXJyYXkgdltdXG4gICAgKi9cbiAgICBpZiAoayA8PSBqICsgMSkgeyAvLyB0aGVyZSBpcyBub3RoaW5nIHRvIHNpbXBsaWZ5XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBhZGVxdWF0ZSBhcHByb3hpbWF0aW9uIGJ5IHNlZ21lbnQgUyBmcm9tIHZbal0gdG8gdltrXVxuICAgIGxldCBtYXhpID0gajsgLy8gaW5kZXggb2YgdmVydGV4IGZhcnRoZXN0IGZyb20gU1xuICAgIGxldCBtYXhkMiA9IDA7IC8vIGRpc3RhbmNlIHNxdWFyZWQgb2YgZmFydGhlc3QgdmVydGV4XG4gICAgY29uc3QgdG9sMiA9IHRvbCAqIHRvbDsgLy8gdG9sZXJhbmNlIHNxdWFyZWRcbiAgICBjb25zdCBTOiBudW1iZXJbXVtdID0gW3Zbal0sIHZba11dOyAvLyBzZWdtZW50IGZyb20gdltqXSB0byB2W2tdXG4gICAgY29uc3QgdTogbnVtYmVyW10gPSBkaWZmKFNbMV0sIFNbMF0pOyAvLyBzZWdtZW50IGRpcmVjdGlvbiB2ZWN0b3JcbiAgICBjb25zdCBjdTogbnVtYmVyID0gbm9ybTIodSk7IC8vIHNlZ21lbnQgbGVuZ3RoIHNxdWFyZWRcbiAgICAvKlxuICAgIHRlc3QgZWFjaCB2ZXJ0ZXggdltpXSBmb3IgbWF4IGRpc3RhbmNlIGZyb20gU1xuICAgIGNvbXB1dGUgdXNpbmcgdGhlIEZlYiAyMDAxIEFsZ29yaXRobSdzIGRpc3RfUG9pbnRfdG9fU2VnbWVudCgpXG4gICAgTm90ZTogdGhpcyB3b3JrcyBpbiBhbnkgZGltZW5zaW9uICgyRCwgM0QsIC4uLilcbiAgICAqL1xuICAgIGxldCB3OiBudW1iZXJbXTsgLy8gdmVjdG9yXG4gICAgbGV0IHBiOiBudW1iZXJbXTsgLy8gcG9pbnQsIGJhc2Ugb2YgcGVycGVuZGljdWxhciBmcm9tIHZbaV0gdG8gU1xuICAgIGxldCBiOiBudW1iZXIsIGN3OiBudW1iZXIsIGR2MjogbnVtYmVyOyAvLyBkdjIgPSBkaXN0YW5jZSB2W2ldIHRvIFMgc3F1YXJlZFxuICAgIGZvciAobGV0IGk6IG51bWJlciA9IGogKyAxOyBpIDwgazsgaSsrKSB7XG4gICAgICAvLyBjb21wdXRlIGRpc3RhbmNlIHNxdWFyZWRcbiAgICAgIHcgPSBkaWZmKHZbaV0sIFNbMF0pO1xuICAgICAgY3cgPSBkb3QodywgdSk7XG4gICAgICBpZiAoY3cgPD0gMCkge1xuICAgICAgICBkdjIgPSBkMih2W2ldLCBTWzBdKTtcbiAgICAgIH0gZWxzZSBpZiAoY3UgPD0gY3cpIHtcbiAgICAgICAgZHYyID0gZDIodltpXSwgU1sxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiID0gY3cgLyBjdTtcbiAgICAgICAgcGIgPSBbU1swXVswXSArIGIgKiB1WzBdLCBTWzBdWzFdICsgYiAqIHVbMV1dO1xuICAgICAgICBkdjIgPSBkMih2W2ldLCBwYik7XG4gICAgICB9XG4gICAgICAvLyB0ZXN0IHdpdGggY3VycmVudCBtYXggZGlzdGFuY2Ugc3F1YXJlZFxuICAgICAgaWYgKGR2MiA8PSBtYXhkMikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIHZbaV0gaXMgYSBuZXcgbWF4IHZlcnRleFxuICAgICAgbWF4aSA9IGk7XG4gICAgICBtYXhkMiA9IGR2MjtcbiAgICB9XG4gICAgaWYgKG1heGQyID4gdG9sMikgeyAvLyBlcnJvciBpcyB3b3JzZSB0aGFuIHRoZSB0b2xlcmFuY2VcbiAgICAgIC8vIHNwbGl0IHRoZSBwb2x5bGluZSBhdCB0aGUgZmFydGhlc3QgdmVydGV4IGZyb20gU1xuICAgICAgbWtbbWF4aV0gPSAxOyAvLyBtYXJrIHZbbWF4aV0gZm9yIHRoZSBzaW1wbGlmaWVkIHBvbHlsaW5lXG4gICAgICAvLyByZWN1cnNpdmVseSBzaW1wbGlmeSB0aGUgdHdvIHN1YnBvbHlsaW5lcyBhdCB2W21heGldXG4gICAgICBzaW1wbGlmeURQKHRvbCwgdiwgaiwgbWF4aSwgbWspOyAvLyBwb2x5bGluZSB2W2pdIHRvIHZbbWF4aV1cbiAgICAgIHNpbXBsaWZ5RFAodG9sLCB2LCBtYXhpLCBrLCBtayk7IC8vIHBvbHlsaW5lIHZbbWF4aV0gdG8gdltrXVxuICAgIH1cbiAgICAvLyBlbHNlIHRoZSBhcHByb3hpbWF0aW9uIGlzIE9LLCBzbyBpZ25vcmUgaW50ZXJtZWRpYXRlIHZlcnRpY2VzXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgbiA9IFYubGVuZ3RoO1xuICBjb25zdCBzVjogbnVtYmVyW11bXSA9IFtdO1xuICBsZXQgaTogbnVtYmVyLCBrOiBudW1iZXIsIG06IG51bWJlciwgcHY6IG51bWJlcjsgLy8gbWlzYyBjb3VudGVyc1xuICBjb25zdCB0b2wyOiBudW1iZXIgPSB0b2wgKiB0b2w7IC8vIHRvbGVyYW5jZSBzcXVhcmVkXG4gIGNvbnN0IHZ0OiBudW1iZXJbXVtdID0gW107IC8vIHZlcnRleCBidWZmZXIsIHBvaW50c1xuICBjb25zdCBtazogbnVtYmVyW10gPSBbXTsgLy8gbWFya2VyIGJ1ZmZlciwgaW50c1xuXG4gIC8vIFNUQUdFIDEuIFZlcnRleCBSZWR1Y3Rpb24gd2l0aGluIHRvbGVyYW5jZSBvZiBwcmlvciB2ZXJ0ZXggY2x1c3RlclxuICB2dFswXSA9IFZbMF07IC8vIHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmdcbiAgZm9yIChpID0gayA9IDEsIHB2ID0gMDsgaSA8IG47IGkrKykge1xuICAgIGlmIChkMihWW2ldLCBWW3B2XSkgPCB0b2wyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdnRbaysrXSA9IFZbaV07XG4gICAgcHYgPSBpO1xuICB9XG4gIGlmIChwdiA8IG4gLSAxKSB7XG4gICAgdnRbaysrXSA9IFZbbiAtIDFdOyAvLyBmaW5pc2ggYXQgdGhlIGVuZFxuICB9XG5cbiAgLy8gU1RBR0UgMi4gIERvdWdsYXMtUGV1Y2tlciBwb2x5bGluZSBzaW1wbGlmaWNhdGlvblxuICBta1swXSA9IG1rW2sgLSAxXSA9IDE7IC8vIG1hcmsgdGhlIGZpcnN0IGFuZCBsYXN0IHZlcnRpY2VzXG4gIHNpbXBsaWZ5RFAodG9sLCB2dCwgMCwgayAtIDEsIG1rKTtcblxuICAvLyBjb3B5IG1hcmtlZCB2ZXJ0aWNlcyB0byB0aGUgb3V0cHV0IHNpbXBsaWZpZWQgcG9seWxpbmVcbiAgZm9yIChpID0gbSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICBpZiAobWtbaV0pIHtcbiAgICAgIHNWW20rK10gPSB2dFtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNWO1xufVxuXG4vKipcbiAqIENsZWFuIHdyYXBwZXIgbWV0aG9kIHRvIHVzZSBSRFAgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaW1wbGlmeUxpbmVzKGxpbmVzOiBudW1iZXJbXVtdW10sXG4gIHRvbGVyYW5jZT86IG51bWJlcik6IG51bWJlcltdW11bXSB7XG4gIGNvbnN0IHJlc3VsdDogbnVtYmVyW11bXVtdID0gW107XG4gIGxldCB0b2wgPSAyLjA7XG4gIGlmICh0b2xlcmFuY2UpIHtcbiAgICB0b2wgPSB0b2xlcmFuY2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdC5wdXNoKHNpbXBsaWZ5TGluZShsaW5lc1tpXSwgdG9sKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGZyb20gcG9seWxpbmVzIHRvIHN0cm9rZS01IGZvcm1hdCB0aGF0IHNrZXRjaC1ybm4gdXNlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZXNUb1N0cm9rZXMocmF3RGF0YTogbnVtYmVyW11bXVtdKTogbnVtYmVyW11bXSB7XG4gIGxldCB4OiBudW1iZXIsIHk6IG51bWJlcjtcbiAgbGV0IHB4ID0gMCwgcHkgPSAwO1xuICBsZXQgZHg6IG51bWJlciwgZHk6IG51bWJlcjtcbiAgbGV0IHBvbjogbnVtYmVyLCBwb2ZmOiBudW1iZXI7XG4gIGNvbnN0IHN0cm9rZTogbnVtYmVyW11bXSA9IFtdO1xuICBsZXQgaTogbnVtYmVyLCBqOiBudW1iZXI7XG4gIGxldCBsZW46IG51bWJlcjtcbiAgbGV0IHA6IG51bWJlcltdO1xuICBmb3IgKGkgPSAwOyBpIDwgcmF3RGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGxlbiA9IHJhd0RhdGFbaV0ubGVuZ3RoO1xuICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgcCA9IHJhd0RhdGFbaV1bal07XG4gICAgICAgIHggPSBwWzBdO1xuICAgICAgICB5ID0gcFsxXTtcbiAgICAgICAgaWYgKGogPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICBwb2ZmID0gMTtcbiAgICAgICAgICBwb24gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvZmYgPSAwO1xuICAgICAgICAgIHBvbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZHggPSB4IC0gcHg7XG4gICAgICAgIGR5ID0geSAtIHB5O1xuICAgICAgICBweCA9IHg7XG4gICAgICAgIHB5ID0geTtcbiAgICAgICAgc3Ryb2tlLnB1c2goW2R4LCBkeSwgcG9uLCBwb2ZmLCAwXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0cm9rZS5wdXNoKFswLCAwLCAwLCAwLCAxXSk7XG4gIHJldHVybiBzdHJva2Uuc2xpY2UoMSk7XG59XG5cbi8qKlxuICogQ29udmVydCB0byBzdHJva2UtNSBmb3JtYXQgdG8gcG9seWxpbmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVUb1N0cm9rZShsaW5lOiBudW1iZXJbXVtdLFxuICBsYXN0UG9pbnQ6IG51bWJlcltdKTogbnVtYmVyW11bXSB7XG4gIGxldCBwb246IG51bWJlciwgcG9mZjogbnVtYmVyO1xuICBjb25zdCBzdHJva2U6IG51bWJlcltdW10gPSBbXTtcbiAgbGV0IGxlbjogbnVtYmVyO1xuICBsZXQgcDogbnVtYmVyW107XG4gIGxldCBkeDogbnVtYmVyLCBkeTogbnVtYmVyO1xuICBsZXQgeDogbnVtYmVyLCB5OiBudW1iZXI7XG4gIGxldCBweDogbnVtYmVyLCBweTogbnVtYmVyO1xuICBsZXQgajogbnVtYmVyO1xuICBweCA9IGxhc3RQb2ludFswXTtcbiAgcHkgPSBsYXN0UG9pbnRbMV07XG4gIGxlbiA9IGxpbmUubGVuZ3RoO1xuICBpZiAobGVuID4gMSkge1xuICAgIGZvciAoaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgcCA9IGxpbmVbal07XG4gICAgICB4ID0gcFswXTtcbiAgICAgIHkgPSBwWzFdO1xuICAgICAgaWYgKGogPT09IGxlbiAtIDEpIHtcbiAgICAgICAgcG9mZiA9IDE7XG4gICAgICAgIHBvbiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb2ZmID0gMDtcbiAgICAgICAgcG9uID0gMTtcbiAgICAgIH1cbiAgICAgIGR4ID0geCAtIHB4O1xuICAgICAgZHkgPSB5IC0gcHk7XG4gICAgICBweCA9IHg7XG4gICAgICBweSA9IHk7XG4gICAgICBzdHJva2UucHVzaChbZHgsIGR5LCBwb24sIHBvZmYsIDBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cm9rZTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcyc7XG5leHBvcnQge3RmfTtcblxuZXhwb3J0ICogZnJvbSAnLi9za2V0Y2hfcm5uJztcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuZXhwb3J0IHtTa2V0Y2hSTk59IGZyb20gJy4vbW9kZWwnO1xuIiwiLyoqXG4gKiBDb3JlIGltcGxlbWVudGF0aW9uIGZvciBSTk4tYmFzZWQgTWFnZW50YSBza2V0Y2ggbW9kZWxzIHN1Y2ggYXMgU2tldGNoUk5OLlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBJbXBvcnRzXG4gKi9cbmltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCAqIGFzIHN1cHBvcnQgZnJvbSAnLi4vY29yZS9za2V0Y2hfc3VwcG9ydCc7XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciBKU09OIHNwZWNpZmljYXRpb24gb2YgYSBgTXVzaWNWQUVgIG1vZGVsLlxuICpcbiAqIEBwcm9wZXJ0eSBtYXhfc2VxX2xlbjogTW9kZWwgdHJhaW5lZCBvbiBkYXRhc2V0IHcvIHRoaXMgbWF4IHNlcXVlbmNlIGxlbmd0aC5cbiAqIEBwcm9wZXJ0eSBtb2RlOiBQcmUtdHJhaW5lZCBtb2RlbHMgaGF2ZSB0aGlzIHBhcmFtZXRlciBmb3IgbGVnYWN5IHJlYXNvbnMuXG4gKiAwIGZvciBWQUUsIDEgZm9yIERlY29kZXIgb25seS4gVGhpcyBtb2RlbCBpcyBEZWNvZGVyIG9ubHkgKG5vdCB1c2VkKS5cbiAqIEBwcm9wZXJ0eSBuYW1lOiBRdWlja0RyYXcgbmFtZSwgbGlrZSBjYXQsIGRvZywgZWxlcGhhbnQsIGV0Y1xuICogQHByb3BlcnR5IHNjYWxlX2ZhY3RvcjogdGhlIGZhY3RvciB0byBjb252ZXJ0IGZyb20gbmV1cmFsLW5ldHdvcmsgc3BhY2UgdG9cbiAqIHBpeGVsIHNwYWNlLiBNb3N0IHByZS10cmFpbmVkIG1vZGVscyBoYXZlIHRoaXMgbnVtYmVyIGJldHdlZW4gODAtMTIwXG4gKiBAcHJvcGVydHkgdmVyc2lvbjogUHJlLXRyYWluZWQgbW9kZWxzIGhhdmUgYSB2ZXJzaW9uIGJldHdlZW4gMS02LCBmb3JcbiAqIHRoZSBwdXJwb3NlIG9mIGV4cGVyaW1lbnRhbCByZXNlYXJjaCBsb2cuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2tldGNoUk5OSW5mbyB7XG4gIG1heF9zZXFfbGVuOiBudW1iZXI7XG4gIG1vZGU6IG51bWJlcjtcbiAgbmFtZTogc3RyaW5nO1xuICBzY2FsZV9mYWN0b3I6IG51bWJlcjtcbiAgdmVyc2lvbjogbnVtYmVyO1xufVxuXG4vKipcbiAqIEludGVyZmFjZSBmb3Igc3BlY2lmaWNhdGlvbiBvZiB0aGUgUHJvYmFiaWxpdHkgRGlzdHJpYnV0aW9uIEZ1bmN0aW9uXG4gKiBvZiBhIHBlbiBzdHJva2UuXG4gKiBcbiAqIFBsZWFzZSByZWZlciB0byBcIkEgTmV1cmFsIFJlcHJlc2VudGF0aW9uIG9mIFNrZXRjaCBEcmF3aW5nc1wiXG4gKiBodHRwczovL2FyeGl2Lm9yZy9hYnMvMTcwNC4wMzQ3N1xuICogXG4gKiBJbiBFcS4zIGlzIGFuIGV4cGxhbmF0aW9uIG9mIGFsbCBvZiB0aGVzZSBwYXJhbWV0ZXJzLlxuICogXG4gKiBCZWxvdyBpcyBhIGJyaWVmIGRlc2NyaXB0aW9uOlxuICogXG4gKiBAcHJvcGVydHkgcGk6IGNhdGVnb3JpYWwgZGlzdHJpYnV0aW9uIGZvciBtaXh0dXJlIG9mIEdhdXNzaWFuXG4gKiBAcHJvcGVydHkgbXVYOiBtZWFuIGZvciB4LWF4aXNcbiAqIEBwcm9wZXJ0eSBtdVk6IG1lYW4gZm9yIHktYXhpc1xuICogQHByb3BlcnR5IHNpZ21hWDogc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHgtYXhpc1xuICogQHByb3BlcnR5IHNpZ21hWTogc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHktYXhpc1xuICogQHByb3BlcnR5IGNvcnI6IGNvcnJlbGF0aW9uIHBhcmFtZXRlciBiZXR3ZWVuIHggYW5kIHlcbiAqIEBwcm9wZXJ0eSBwZW46IGNhdGVnb3JpY2FsIGRpc3RyaWJ1dGlvbiBmb3IgdGhlIDMgcGVuIHN0YXRlc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0cm9rZVBERiB7XG4gIHBpOiBGbG9hdDMyQXJyYXk7XG4gIG11WDogRmxvYXQzMkFycmF5O1xuICBtdVk6IEZsb2F0MzJBcnJheTtcbiAgc2lnbWFYOiBGbG9hdDMyQXJyYXk7XG4gIHNpZ21hWTogRmxvYXQzMkFycmF5O1xuICBjb3JyOiBGbG9hdDMyQXJyYXk7XG4gIHBlbjogRmxvYXQzMkFycmF5O1xufVxuXG4vKipcbiAqIFN0YXRlcyBvZiB0aGUgTFNUTSBDZWxsXG4gKiBcbiAqIExvbmctU2hvcnQgVGVybSBNZW1vcnk6IGZ0cDovL2Z0cC5pZHNpYS5jaC9wdWIvanVlcmdlbi9sc3RtLnBkZlxuICogXG4gKiBAcHJvcGVydHkgYzogbWVtb3J5IFwiY2VsbFwiIG9mIHRoZSBMU1RNLlxuICogQHByb3BlcnR5IGg6IGhpZGRlbiBzdGF0ZSAoYWxzbyB0aGUgb3V0cHV0KSBvZiB0aGUgTFNUTS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMU1RNU3RhdGUge1xuICBjOiBGbG9hdDMyQXJyYXk7XG4gIGg6IEZsb2F0MzJBcnJheTtcbn1cblxuLyoqXG4gKiBNYWluIFNrZXRjaFJOTiBtb2RlbCBjbGFzcy5cbiAqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBkZWNvZGVyIG1vZGVsIGluIGh0dHBzOi8vYXJ4aXYub3JnL2Ficy8xNzA0LjAzNDc3XG4gKiBcbiAqIFRPRE8oaGFyZG1hcnUpOiBtYWtlIGEgXCJiYXRjaFwiIGNvbnRpbnVlU2VxdWVuY2UtbGlrZSBtZXRob2RcbiAqIHRoYXQgcnVucyBmdWxseSBvbiBHUFUuXG4gKi9cbmV4cG9ydCBjbGFzcyBTa2V0Y2hSTk4ge1xuICBwcml2YXRlIGNoZWNrcG9pbnRVUkw6IHN0cmluZztcblxuICBwcml2YXRlIGZvcmdldEJpYXM6IHRmLlNjYWxhcjtcblxuICBwcml2YXRlIGluaXRpYWxpemVkOiBib29sZWFuO1xuXG4gIHB1YmxpYyBpbmZvOiBTa2V0Y2hSTk5JbmZvO1xuICBwdWJsaWMgbnVtVW5pdHM6IG51bWJlcjtcblxuICBwdWJsaWMgcGl4ZWxGYWN0b3I6IG51bWJlcjtcbiAgcHVibGljIHNjYWxlRmFjdG9yOiBudW1iZXI7XG5cbiAgLy8gcmF3IHdlaWdodHMgYW5kIGRpbWVuc2lvbnMgZGlyZWN0bHkgZnJvbSBKU09OXG4gIHByaXZhdGUgd2VpZ2h0czogRmxvYXQzMkFycmF5W107XG4gIHByaXZhdGUgd2VpZ2h0RGltczogbnVtYmVyW11bXTtcblxuICAvLyBUZW5zb3JGbG93LmpzIHdlaWdodCBtYXRyaWNlc1xuICBwcml2YXRlIG91dHB1dEtlcm5lbDogdGYuVGVuc29yMkQ7XG4gIHByaXZhdGUgb3V0cHV0QmlhczogdGYuVGVuc29yMUQ7XG4gIHByaXZhdGUgbHN0bUtlcm5lbDogdGYuVGVuc29yMkQ7XG4gIHByaXZhdGUgbHN0bUJpYXM6IHRmLlRlbnNvcjFEO1xuXG4gIHByaXZhdGUgcmF3VmFyczogdGYuVGVuc29yW107XG5cbiAgcHJpdmF0ZSBOTUlYVFVSRSA9IDIwO1xuXG4gIC8qKlxuICAgKiBgU2tldGNoUk5OYCBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIGNoZWNrcG9pbnRVUkwgUGF0aCB0byB0aGUgY2hlY2twb2ludCBkaXJlY3RvcnkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjaGVja3BvaW50VVJMOiBzdHJpbmcpIHtcbiAgICB0aGlzLmNoZWNrcG9pbnRVUkwgPSBjaGVja3BvaW50VVJMO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgbW9kZWwgaXMgaW50aWFsaXplZC5cbiAgICovXG4gIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZWQ7XG4gIH1cblxuICAvKipcbiAgICogSW5zdGFudGlhdGVzIGNsYXNzIGluZm9ybWF0aW9uIGlucHV0cyBmcm9tIHRoZSBKU09OIG1vZGVsLlxuICAgKiBUT0RPKGhhcmRtYXJ1KTogdG8gYWRkIHN1cHBvcnQgZm9yIG5ldyB0ZmpzIGNoZWNrcG9pbnRzLlxuICAgKi9cbiAgcHJpdmF0ZSBpbnN0YW50aWF0ZUZyb21KU09OKGluZm86IFNrZXRjaFJOTkluZm8sXG4gICAgd2VpZ2h0RGltczogbnVtYmVyW11bXSxcbiAgICB3ZWlnaHRTdHJpbmdzOiBzdHJpbmdbXSkge1xuXG4gICAgdGhpcy5mb3JnZXRCaWFzID0gdGYuc2NhbGFyKDEuMCk7XG4gICAgdGhpcy5pbmZvID0gaW5mbztcbiAgICB0aGlzLnNldFBpeGVsRmFjdG9yKDIuMCk7XG4gICAgdGhpcy53ZWlnaHREaW1zID0gd2VpZ2h0RGltcztcbiAgICB0aGlzLm51bVVuaXRzID0gdGhpcy53ZWlnaHREaW1zWzBdWzBdOyAvLyBzaXplIG9mIExTVE1cbiAgICBsZXQgcmF3V2VpZ2h0czogRmxvYXQzMkFycmF5O1xuICAgIGNvbnN0IG1heFdlaWdodCA9IDEwLjA7XG4gICAgdGhpcy53ZWlnaHRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3ZWlnaHRTdHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByYXdXZWlnaHRzID0gbmV3IEZsb2F0MzJBcnJheShzdXBwb3J0LnN0cmluZ1RvQXJyYXkod2VpZ2h0U3RyaW5nc1tpXSkpO1xuICAgICAgY29uc3QgTjogbnVtYmVyID0gcmF3V2VpZ2h0cy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE47IGorKykge1xuICAgICAgICByYXdXZWlnaHRzW2pdID0gbWF4V2VpZ2h0ICogcmF3V2VpZ2h0c1tqXSAvIDMyNzY3O1xuICAgICAgfVxuICAgICAgdGhpcy53ZWlnaHRzLnB1c2gocmF3V2VpZ2h0cyk7XG4gICAgfVxuICAgIHRoaXMub3V0cHV0S2VybmVsID0gdGYudGVuc29yMmQodGhpcy53ZWlnaHRzWzBdLFxuICAgICAgW3RoaXMud2VpZ2h0RGltc1swXVswXSwgdGhpcy53ZWlnaHREaW1zWzBdWzFdXSk7XG4gICAgdGhpcy5vdXRwdXRCaWFzID0gdGYudGVuc29yMWQodGhpcy53ZWlnaHRzWzFdKTtcbiAgICBjb25zdCBsc3RtS2VybmVsWEggPSB0Zi50ZW5zb3IyZCh0aGlzLndlaWdodHNbMl0sXG4gICAgICBbdGhpcy53ZWlnaHREaW1zWzJdWzBdLCB0aGlzLndlaWdodERpbXNbMl1bMV1dKTtcbiAgICBjb25zdCBsc3RtS2VybmVsSEggPSB0Zi50ZW5zb3IyZCh0aGlzLndlaWdodHNbM10sXG4gICAgICBbdGhpcy53ZWlnaHREaW1zWzNdWzBdLCB0aGlzLndlaWdodERpbXNbM11bMV1dKTtcbiAgICBjb25zdCBheGlzID0gMDtcbiAgICB0aGlzLmxzdG1LZXJuZWwgPSB0Zi5jb25jYXQyZChbbHN0bUtlcm5lbFhILCBsc3RtS2VybmVsSEhdLCBheGlzKTtcbiAgICB0aGlzLmxzdG1CaWFzID0gdGYudGVuc29yMWQodGhpcy53ZWlnaHRzWzRdKTtcblxuICAgIHRoaXMucmF3VmFycyA9IFtcbiAgICAgIHRoaXMub3V0cHV0S2VybmVsLFxuICAgICAgdGhpcy5vdXRwdXRCaWFzLFxuICAgICAgdGhpcy5sc3RtS2VybmVsLFxuICAgICAgdGhpcy5sc3RtQmlhc1xuICAgIF07XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyB2YXJpYWJsZXMgZnJvbSB0aGUgSlNPTiBtb2RlbFxuICAgKi9cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmRpc3Bvc2UoKTtcblxuICAgIGNvbnN0IHZhcnMgPSBhd2FpdCBmZXRjaCh0aGlzLmNoZWNrcG9pbnRVUkwpXG4gICAgICAudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSk7XG5cbiAgICB0aGlzLmluc3RhbnRpYXRlRnJvbUpTT04odmFyc1swXSwgdmFyc1sxXSwgdmFyc1syXSk7XG5cbiAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBjb25zb2xlLmxvZygnSW5pdGlhbGl6ZWQgU2tldGNoUk5OLicpO1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5yYXdWYXJzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmF3VmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnJhd1ZhcnNbaV0uZGlzcG9zZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5yYXdWYXJzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5mb3JnZXRCaWFzKSB7XG4gICAgICB0aGlzLmZvcmdldEJpYXMuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5mb3JnZXRCaWFzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgaW50ZXJuYWwgRVhUUkEgZmFjdG9yIG9mIHRoaXMgbW9kZWwgKHBpeGVsIHRvIG1vZGVsIHNwYWNlKVxuICAgKlxuICAgKiBAcGFyYW0gc2NhbGUgKHRoZSBleHRyYSBzY2FsZSBmYWN0b3IgZm9yIHBpeGVsIHRvIG1vZGVsIHNwYWNlKVxuICAgKlxuICAgKiBAcmV0dXJucyBub3RoaW5nXG4gICAqL1xuICBzZXRQaXhlbEZhY3RvcihzY2FsZTogbnVtYmVyKSB7XG4gICAgLy8gZm9yIGJlc3QgZWZmZWN0LCBzZXQgdG8gMS4wIGZvciBkMyBvciBwYXBlci5qcywgMi4wIGZvciBwNS5qc1xuICAgIHRoaXMucGl4ZWxGYWN0b3IgPSBzY2FsZTtcbiAgICB0aGlzLnNjYWxlRmFjdG9yID0gdGhpcy5pbmZvLnNjYWxlX2ZhY3RvciAvIHRoaXMucGl4ZWxGYWN0b3I7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgUk5OLCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0gc3Ryb2tlIFtkeCwgZHksIHBlbkRvd24sIHBlblVwLCBwZW5FbmRdLlxuICAgKiBAcGFyYW0gc3RhdGUgcHJldmlvdXMgTFNUTVN0YXRlLlxuICAgKlxuICAgKiBAcmV0dXJucyBuZXh0IExTVE1TdGF0ZS5cbiAgICovXG4gIHVwZGF0ZShzdHJva2U6IG51bWJlcltdLCBzdGF0ZTogTFNUTVN0YXRlKSB7XG4gICAgY29uc3Qgb3V0ID0gdGYudGlkeSgoKSA9PiB7XG4gICAgICBjb25zdCBudW1Vbml0cyA9IHRoaXMubnVtVW5pdHM7XG4gICAgICBjb25zdCBzID0gdGhpcy5zY2FsZUZhY3RvcjtcbiAgICAgIGNvbnN0IG5vcm1TdHJva2UgPVxuICAgICAgICBbc3Ryb2tlWzBdL3MsIHN0cm9rZVsxXS9zLCBzdHJva2VbMl0sIHN0cm9rZVszXSwgc3Ryb2tlWzRdXTtcbiAgICAgIGNvbnN0IHggPSB0Zi50ZW5zb3IyZChub3JtU3Ryb2tlLCBbMSwgNV0pO1xuICAgICAgY29uc3QgYyA9IHRmLnRlbnNvcjJkKHN0YXRlLmMsIFsxLCBudW1Vbml0c10pO1xuICAgICAgY29uc3QgaCA9IHRmLnRlbnNvcjJkKHN0YXRlLmgsIFsxLCBudW1Vbml0c10pO1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0Zi5iYXNpY0xTVE1DZWxsKFxuICAgICAgICB0aGlzLmZvcmdldEJpYXMsXG4gICAgICAgIHRoaXMubHN0bUtlcm5lbCxcbiAgICAgICAgdGhpcy5sc3RtQmlhcyxcbiAgICAgICAgeCxcbiAgICAgICAgYyxcbiAgICAgICAgaCk7XG4gICAgICByZXR1cm4gdGYuY29uY2F0KG5ld1N0YXRlLCAxKTtcbiAgICB9KTtcbiAgICBjb25zdCBuZXdDSCA9IG91dC5kYXRhU3luYygpO1xuICAgIG91dC5kaXNwb3NlKCk7XG4gICAgY29uc3QgbmV3QyA9IG5ld0NILnNsaWNlKDAsIHRoaXMubnVtVW5pdHMpO1xuICAgIGNvbnN0IG5ld0ggPSBuZXdDSC5zbGljZSh0aGlzLm51bVVuaXRzLCB0aGlzLm51bVVuaXRzICogMik7XG4gICAgY29uc3QgZmluYWxTdGF0ZTpMU1RNU3RhdGUgPSB7XG4gICAgICBjOiBuZXcgRmxvYXQzMkFycmF5KG5ld0MpLFxuICAgICAgaDogbmV3IEZsb2F0MzJBcnJheShuZXdIKVxuICAgIH07XG4gICAgcmV0dXJuIGZpbmFsU3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgUk5OIG9uIGEgc2VyaWVzIG9mIFN0cm9rZXMsIHJldHVybnMgdGhlIG5leHQgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJva2VzIGxpc3Qgb2YgW2R4LCBkeSwgcGVuRG93biwgcGVuVXAsIHBlbkVuZF0uXG4gICAqIEBwYXJhbSBzdGF0ZSBwcmV2aW91cyBMU1RNU3RhdGUuXG4gICAqIEBwYXJhbSBzdGVwcyAoT3B0aW9uYWwpIG51bWJlciBvZiBzdGVwcyBvZiB0aGUgc3Ryb2tlIHRvIHVwZGF0ZVxuICAgKiAoZGVmYXVsdCBpcyBsZW5ndGggb2Ygc3Ryb2tlcyBsaXN0KVxuICAgKiBcbiAgICpcbiAgICogQHJldHVybnMgdGhlIGZpbmFsIExTVE1TdGF0ZS5cbiAgICovXG4gIHVwZGF0ZVN0cm9rZXMoc3Ryb2tlczogbnVtYmVyW11bXSwgc3RhdGU6IExTVE1TdGF0ZSwgc3RlcHM/OiBudW1iZXIpIHtcbiAgICBjb25zdCBvdXQgPSB0Zi50aWR5KCgpID0+IHtcbiAgICAgIGNvbnN0IG51bVVuaXRzID0gdGhpcy5udW1Vbml0cztcbiAgICAgIGNvbnN0IHMgPSB0aGlzLnNjYWxlRmFjdG9yO1xuICAgICAgbGV0IG5vcm1TdHJva2U6bnVtYmVyW107XG4gICAgICBsZXQgeDogdGYuVGVuc29yMkQ7XG4gICAgICBsZXQgYzogdGYuVGVuc29yMkQ7XG4gICAgICBsZXQgaDogdGYuVGVuc29yMkQ7XG4gICAgICBsZXQgbmV3U3RhdGU6IHRmLlRlbnNvcjJEW107XG4gICAgICBsZXQgbnVtU3RlcHMgPSBzdHJva2VzLmxlbmd0aDtcbiAgICAgIGlmIChzdGVwcykge1xuICAgICAgICBudW1TdGVwcyA9IHN0ZXBzO1xuICAgICAgfVxuICAgICAgYyA9IHRmLnRlbnNvcjJkKHN0YXRlLmMsIFsxLCBudW1Vbml0c10pO1xuICAgICAgaCA9IHRmLnRlbnNvcjJkKHN0YXRlLmgsIFsxLCBudW1Vbml0c10pO1xuICAgICAgZm9yIChsZXQgaT0wO2k8bnVtU3RlcHM7aSsrKSB7XG4gICAgICAgIG5vcm1TdHJva2UgPSBbc3Ryb2tlc1tpXVswXS9zLFxuICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZXNbaV1bMV0vcyxcbiAgICAgICAgICAgICAgICAgICAgICBzdHJva2VzW2ldWzJdLFxuICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZXNbaV1bM10sXG4gICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlc1tpXVs0XV07XG4gICAgICAgIHggPSB0Zi50ZW5zb3IyZChub3JtU3Ryb2tlLCBbMSwgNV0pO1xuICAgICAgICBuZXdTdGF0ZSA9IHRmLmJhc2ljTFNUTUNlbGwoXG4gICAgICAgICAgdGhpcy5mb3JnZXRCaWFzLFxuICAgICAgICAgIHRoaXMubHN0bUtlcm5lbCxcbiAgICAgICAgICB0aGlzLmxzdG1CaWFzLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBoKTtcbiAgICAgICAgYyA9IG5ld1N0YXRlWzBdO1xuICAgICAgICBoID0gbmV3U3RhdGVbMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGYuY29uY2F0KG5ld1N0YXRlLCAxKTtcbiAgICB9KTtcbiAgICBjb25zdCBuZXdDSCA9IG91dC5kYXRhU3luYygpO1xuICAgIG91dC5kaXNwb3NlKCk7XG4gICAgY29uc3QgbmV3QyA9IG5ld0NILnNsaWNlKDAsIHRoaXMubnVtVW5pdHMpO1xuICAgIGNvbnN0IG5ld0ggPSBuZXdDSC5zbGljZSh0aGlzLm51bVVuaXRzLCB0aGlzLm51bVVuaXRzICogMik7XG4gICAgY29uc3QgZmluYWxTdGF0ZTpMU1RNU3RhdGUgPSB7XG4gICAgICBjOiBuZXcgRmxvYXQzMkFycmF5KG5ld0MpLFxuICAgICAgaDogbmV3IEZsb2F0MzJBcnJheShuZXdIKVxuICAgIH07XG4gICAgcmV0dXJuIGZpbmFsU3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gdGhlIFJOTiBzdGF0ZSwgcmV0dXJucyB0aGUgcHJvYmFiaWx0eSBkaXN0cmlidXRpb24gZnVuY3Rpb24gKHBkZilcbiAgICogb2YgdGhlIG5leHQgc3Ryb2tlLiBPcHRpb25hbGx5IGFkanVzdCB0aGUgdGVtcGVyYXR1cmUgb2YgdGhlIHBkZiBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0gc3RhdGUgcHJldmlvdXMgTFNUTVN0YXRlLlxuICAgKiBAcGFyYW0gdGVtcGVyYXR1cmUgKE9wdGlvbmFsKSBmb3IgZHggYW5kIGR5IChkZWZhdWx0IDAuNjUpXG4gICAqIEBwYXJhbSBzb2Z0bWF4VGVtcGVyYXR1cmUgKE9wdGlvbmFsKSBmb3IgUGkgYW5kIFBlbiBkaXNjcmV0ZSBzdGF0ZXNcbiAgICogKGRlZmF1bHQgaXMgdGVtcGVyYXR1cmUgKiAwLjUgKyAwLjUsIHdoaWNoIGlzIGEgbmljZSBoZXVyaXN0aWMuKVxuICAgKlxuICAgKiBAcmV0dXJucyBTdHJva2VQREYgKHBpLCBtdVgsIG11WSwgc2lnbWFYLCBzaWdtYVksIGNvcnIsIHBlbilcbiAgICovXG4gIGdldFBERihzdGF0ZTogTFNUTVN0YXRlLFxuICAgIHRlbXBlcmF0dXJlPTAuNjUsXG4gICAgc29mdG1heFRlbXBlcmF0dXJlPzogbnVtYmVyKSB7XG4gICAgY29uc3QgdGVtcCA9IHRlbXBlcmF0dXJlO1xuICAgIGxldCBkaXNjcmV0ZVRlbXA6IG51bWJlciA9IDAuNSArIHRlbXAgKiAwLjU7IC8vIGdvb2QgaGV1cmlzdGljLlxuICAgIGlmIChzb2Z0bWF4VGVtcGVyYXR1cmUpIHtcbiAgICAgIGRpc2NyZXRlVGVtcCA9IHNvZnRtYXhUZW1wZXJhdHVyZTtcbiAgICB9XG4gICAgY29uc3QgTk9VVCA9IHRoaXMuTk1JWFRVUkU7XG4gICAgY29uc3Qgb3V0ID0gdGYudGlkeSgoKSA9PiB7XG4gICAgICBjb25zdCBudW1Vbml0cyA9IHRoaXMubnVtVW5pdHM7XG4gICAgICBjb25zdCBoID0gdGYudGVuc29yMmQoc3RhdGUuaCwgWzEsIG51bVVuaXRzXSk7XG5cbiAgICAgIGNvbnN0IHNxcnR0ZW1wID0gdGYuc2NhbGFyKE1hdGguc3FydCh0ZW1wKSk7XG4gICAgICBjb25zdCBzb2Z0dGVtcCA9IHRmLnNjYWxhcihkaXNjcmV0ZVRlbXApO1xuXG4gICAgICBjb25zdCB6ID0gdGYuYWRkKHRmLm1hdE11bChoLCB0aGlzLm91dHB1dEtlcm5lbCksIHRoaXMub3V0cHV0QmlhcylcbiAgICAgICAgLnNxdWVlemUoKTtcblxuICAgICAgY29uc3QgW3Jhd1BlbiwgcnN0XSA9IHRmLnNwbGl0KHosIFszLCBOT1VUKjZdKTtcbiAgICAgIGNvbnN0IFtyYXdQaSwgbXUxLCBtdTIsIHJhd1NpZ21hMSwgcmF3U2lnbWEyLCByYXdDb3JyXSA9IHRmLnNwbGl0KHJzdCwgNik7XG4gICAgICBjb25zdCBwZW4gPSB0Zi5zb2Z0bWF4KHJhd1Blbi5kaXYoc29mdHRlbXApKTtcbiAgICAgIGNvbnN0IHBpID0gdGYuc29mdG1heChyYXdQaS5kaXYoc29mdHRlbXApKTtcbiAgICAgIGNvbnN0IHNpZ21hMSA9IHRmLmV4cChyYXdTaWdtYTEpLm11bChzcXJ0dGVtcCk7XG4gICAgICBjb25zdCBzaWdtYTIgPSB0Zi5leHAocmF3U2lnbWEyKS5tdWwoc3FydHRlbXApO1xuICAgICAgY29uc3QgY29yciA9IHRmLnRhbmgocmF3Q29ycik7XG4gICAgICBjb25zdCByZXN1bHQgPSBbcGksIG11MSwgbXUyLCBzaWdtYTEsIHNpZ21hMiwgY29yciwgcGVuXTtcbiAgICAgIC8vIGNvbmNhdCwgYW5kIHRoZW4gdW5wYWNrIGFmdGVyIGRhdGFTeW5jXG4gICAgICByZXR1cm4gdGYuY29uY2F0KHJlc3VsdCk7XG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gb3V0LmRhdGFTeW5jKCk7XG4gICAgb3V0LmRpc3Bvc2UoKTtcbiAgICBjb25zdCBwZGY6U3Ryb2tlUERGID0geyAvLyBub3RlOiBKUyBkb2Vzbid0IGhhdmUgYSBuaWNlIFwic3BsaXRcIiBtZXRob2QuXG4gICAgICBwaTogbmV3IEZsb2F0MzJBcnJheShyZXN1bHQuc2xpY2UoMCwgTk9VVCkpLFxuICAgICAgbXVYOiBuZXcgRmxvYXQzMkFycmF5KHJlc3VsdC5zbGljZSgxKk5PVVQsIDIqTk9VVCkpLFxuICAgICAgbXVZOiBuZXcgRmxvYXQzMkFycmF5KHJlc3VsdC5zbGljZSgyKk5PVVQsIDMqTk9VVCkpLFxuICAgICAgc2lnbWFYOiBuZXcgRmxvYXQzMkFycmF5KHJlc3VsdC5zbGljZSgzKk5PVVQsIDQqTk9VVCkpLFxuICAgICAgc2lnbWFZOiBuZXcgRmxvYXQzMkFycmF5KHJlc3VsdC5zbGljZSg0Kk5PVVQsIDE1Kk5PVVQpKSxcbiAgICAgIGNvcnI6IG5ldyBGbG9hdDMyQXJyYXkocmVzdWx0LnNsaWNlKDUqTk9VVCwgNipOT1VUKSksXG4gICAgICBwZW46IG5ldyBGbG9hdDMyQXJyYXkocmVzdWx0LnNsaWNlKDYqTk9VVCwgNipOT1VUKzMpKVxuICAgIH07XG4gICAgcmV0dXJuIHBkZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB6ZXJvL2luaXRpYWwgc3RhdGUgb2YgdGhlIG1vZGVsXG4gICAqXG4gICAqIEByZXR1cm5zIHplcm8gc3RhdGUgb2YgdGhlIGxzdG06IFtjLCBoXSwgd2hlcmUgYyBhbmQgaCBhcmUgemVybyB2ZWN0b3JzLlxuICAgKi9cbiAgemVyb1N0YXRlKCkge1xuICAgIGNvbnN0IHJlc3VsdDpMU1RNU3RhdGUgPSB7XG4gICAgICBjOiBuZXcgRmxvYXQzMkFycmF5KHRoaXMubnVtVW5pdHMpLFxuICAgICAgaDogbmV3IEZsb2F0MzJBcnJheSh0aGlzLm51bVVuaXRzKVxuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IGNvcHkgb2YgdGhlIHJubiBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gcm5uU3RhdGUgb3JpZ2luYWwgTFNUTVN0YXRlXG4gICAqXG4gICAqIEByZXR1cm5zIGNvcHkgb2YgTFNUTVN0YXRlXG4gICAqL1xuICBjb3B5U3RhdGUocm5uU3RhdGU6IExTVE1TdGF0ZSkge1xuICAgIGNvbnN0IHJlc3VsdDpMU1RNU3RhdGUgPSB7XG4gICAgICBjOiBuZXcgRmxvYXQzMkFycmF5KHJublN0YXRlLmMpLFxuICAgICAgaDogbmV3IEZsb2F0MzJBcnJheShybm5TdGF0ZS5oKVxuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB6ZXJvIGlucHV0IHN0YXRlIG9mIHRoZSBtb2RlbFxuICAgKlxuICAgKiBAcmV0dXJucyBbMCwgMCwgMSwgMCwgMF0uXG4gICAqL1xuICB6ZXJvSW5wdXQoKSB7XG4gICAgcmV0dXJuIFswLCAwLCAxLCAwLCAwXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYW1wbGVzIHRoZSBuZXh0IHBvaW50IG9mIHRoZSBza2V0Y2ggZ2l2ZW4gcGRmIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIHBkZiByZXN1bHQgZnJvbSBnZXRQREYoKSBjYWxsXG4gICAqXG4gICAqIEByZXR1cm5zIFtkeCwgZHksIHBlbkRvd24sIHBlblVwLCBwZW5FbmRdXG4gICAqL1xuICBzYW1wbGUocGRmOiBTdHJva2VQREYpIHtcbiAgICAvLyBwZGYgaXMgYSBTdHJva2VQREYgSW50ZXJmYWNlXG4gICAgLy8gcmV0dXJucyBbeCwgeSwgZW9zXVxuICAgIGNvbnN0IGlkeCA9IHN1cHBvcnQuc2FtcGxlU29mdG1heChwZGYucGkpO1xuICAgIGNvbnN0IG11MSA9IHBkZi5tdVhbaWR4XTtcbiAgICBjb25zdCBtdTIgPSBwZGYubXVZW2lkeF07XG4gICAgY29uc3Qgc2lnbWExID0gcGRmLnNpZ21hWFtpZHhdO1xuICAgIGNvbnN0IHNpZ21hMiA9IHBkZi5zaWdtYVlbaWR4XTtcbiAgICBjb25zdCBjb3JyID0gcGRmLmNvcnJbaWR4XTtcbiAgICBjb25zdCBwZW5JZHggPSBzdXBwb3J0LnNhbXBsZVNvZnRtYXgocGRmLnBlbik7XG4gICAgY29uc3QgcGVuc3RhdGUgPSBbMCwgMCwgMF07XG4gICAgcGVuc3RhdGVbcGVuSWR4XSA9IDE7XG4gICAgY29uc3QgZGVsdGEgPSBzdXBwb3J0LmJpcmFuZG4obXUxLCBtdTIsIHNpZ21hMSwgc2lnbWEyLCBjb3JyKTtcbiAgICBjb25zdCBzdHJva2UgPSBbXG4gICAgICBkZWx0YVswXSAqIHRoaXMuc2NhbGVGYWN0b3IsXG4gICAgICBkZWx0YVsxXSAqIHRoaXMuc2NhbGVGYWN0b3IsXG4gICAgICBwZW5zdGF0ZVswXSxcbiAgICAgIHBlbnN0YXRlWzFdLFxuICAgICAgcGVuc3RhdGVbMl1cbiAgICBdO1xuICAgIHJldHVybiBzdHJva2U7XG4gIH1cblxuICAvKipcbiAgICogU2ltcGxpZmllcyBsaW5lIHVzaW5nIFJEUCBhbGdvcml0aG1cbiAgICpcbiAgICogQHBhcmFtIGxpbmUgbGlzdCBvZiBwb2ludHMgW1t4MCwgeTBdLCBbeDEsIHkxXSwgLi4uXVxuICAgKiBAcGFyYW0gdG9sZXJhbmNlIChPcHRpb25hbCkgZGVmYXVsdCAyLjBcbiAgICpcbiAgICogQHJldHVybnMgc2ltcGlmaWVkIGxpbmUgW1t4MCcsIHkwJ10sIFt4MScsIHkxJ10sIC4uLl1cbiAgICovXG4gIHNpbXBsaWZ5TGluZShsaW5lOiBudW1iZXJbXVtdLCB0b2xlcmFuY2U/OiBudW1iZXIpIHtcbiAgICByZXR1cm4gc3VwcG9ydC5zaW1wbGlmeUxpbmUobGluZSwgdG9sZXJhbmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW1wbGlmaWVzIGxpbmVzIHVzaW5nIFJEUCBhbGdvcml0aG1cbiAgICpcbiAgICogQHBhcmFtIGxpbmUgbGlzdCBvZiBsaW5lcyAoZWFjaCBlbGVtZW50IGlzIFtbeDAsIHkwXSwgW3gxLCB5MV0sIC4uLl0pXG4gICAqIEBwYXJhbSB0b2xlcmFuY2UgKE9wdGlvbmFsKSBkZWZhdWx0IDIuMFxuICAgKlxuICAgKiBAcmV0dXJucyBzaW1waWZpZWQgbGluZXMgKGVhY2ggZWxlbSBpcyBbW3gwJywgeTAnXSwgW3gxJywgeTEnXSwgLi4uXSlcbiAgICovXG4gIHNpbXBsaWZ5TGluZXMobGluZXM6IG51bWJlcltdW11bXSwgdG9sZXJhbmNlPzogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHN1cHBvcnQuc2ltcGxpZnlMaW5lcyhsaW5lcywgdG9sZXJhbmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGZyb20gcG9seWxpbmVzIHRvIHN0cm9rZS01IGZvcm1hdCB0aGF0IHNrZXRjaC1ybm4gdXNlc1xuICAgKlxuICAgKiBAcGFyYW0gbGluZXMgbGlzdCBvZiBwb2ludHMgZWFjaCBlbGVtIGlzIChbW3gwLCB5MF0sIFt4MSwgeTFdLCAuLi5dKVxuICAgKlxuICAgKiBAcmV0dXJucyBzdHJva2UtNSBmb3JtYXQgb2YgdGhlIGxpbmUsIGxpc3Qgb2YgW2R4LCBkeSwgcDAsIHAxLCBwMl1cbiAgICovXG4gIGxpbmVzVG9TdHJva2UobGluZXM6IG51bWJlcltdW11bXSkge1xuICAgIHJldHVybiBzdXBwb3J0LmxpbmVzVG9TdHJva2VzKGxpbmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGZyb20gYSBsaW5lIGZvcm1hdCB0byBzdHJva2UtNVxuICAgKlxuICAgKiBAcGFyYW0gbGluZSBsaXN0IG9mIHBvaW50cyBbW3gwLCB5MF0sIFt4MSwgeTFdLCAuLi5dXG4gICAqIEBwYXJhbSBsYXN0UG9pbnQgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBsYXN0IHBvaW50XG4gICAqXG4gICAqIEByZXR1cm5zIHN0cm9rZS01IGZvcm1hdCBvZiB0aGUgbGluZSwgbGlzdCBvZiBbZHgsIGR5LCBwMCwgcDEsIHAyXVxuICAgKi9cbiAgbGluZVRvU3Ryb2tlKGxpbmU6IG51bWJlcltdW10sIGxhc3RQb2ludDogbnVtYmVyW10pIHtcbiAgICByZXR1cm4gc3VwcG9ydC5saW5lVG9TdHJva2UobGluZSwgbGFzdFBvaW50KTtcbiAgfVxuXG59XG4iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iXSwic291cmNlUm9vdCI6IiJ9