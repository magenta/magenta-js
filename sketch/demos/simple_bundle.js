/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./demos/simple.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./demos/simple.js":
/*!*************************!*\
  !*** ./demos/simple.js ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/index */ "./src/index.ts");
/* harmony import */ var _src_index__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_src_index__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const sketch = function(p) {
  let modelState; // Store the hidden states of rnn's neurons.
  const temperature = 0.45; // Controls the amount of uncertainty of the model.
  let modelLoaded = false;

  let dx, dy; // Offsets of the pen strokes, in pixels.
  let x, y; // Absolute coordinates on the screen of where the pen is.
  let pen = [0,0,0]; // Current pen state, [pen_down, pen_up, pen_end].
  let previousPen = [1, 0, 0]; // Previous pen state.
  const PEN = {DOWN: 0, UP: 1, END: 2};

  // Load the model.
  const model = new _src_index__WEBPACK_IMPORTED_MODULE_0__["SketchRNN"]('https://storage.googleapis.com/quickdraw-models/sketchRNN/large_models/bird.gen.json');


  /*
   * Main p5 code
   */
  p.setup = function() {
    const containerSize = document.getElementById('sketch').getBoundingClientRect();
    // Initialize the canvas.
    const screenWidth = Math.floor(containerSize.width);
    const screenHeight = p.windowHeight / 2;
    p.createCanvas(screenWidth, screenHeight);
    p.frameRate(60);

    model.initialize().then(function() {
      // Initialize the scale factor for the model. Bigger -> large outputs
      model.setPixelFactor(3.0);
      modelLoaded = true;
      restart();
      console.log('SketchRNN model loaded.');
    });
  };

  // Drawing loop.
  p.draw = function() {
    if (!modelLoaded) {
      return;
    }

    // If we finished the previous drawing, start a new one.
    if (previousPen[PEN.END] === 1) {
      restart();
    }

    // New state.
    [dx, dy, ...pen] = sampleNewState();

    // Only draw on the paper if the pen is still touching the paper.
    if (previousPen[PEN.DOWN] == 1) {
      p.line(x, y, x+dx, y+dy); // Draw line connecting prev point to current point.
    }

    // Update the absolute coordinates from the offsets
    x += dx;
    y += dy;

    // Update the previous pen's state to the current one we just sampled.
    previousPen = pen;
  };

  /*
   * Helpers.
   */
  function sampleNewState() {
    // Using the previous pen states, and hidden state, get next hidden state
    // the below line takes the most CPU power, especially for large models.
    modelState = model.update([dx, dy, ...pen], modelState);

    // Get the parameters of the probability distribution (pdf) from hidden state.
    const pdf = model.getPDF(modelState, temperature);

    // Sample the next pen's states from our probability distribution.
    return model.sample(pdf);
  }

  function setupNewDrawing() {
    p.background(255, 255, 255, 255);
    x = p.width / 2.0;
    y = p.height / 3.0;
    const lineColor = p.color(p.random(64, 224), p.random(64, 224), p.random(64, 224));

    p.strokeWeight(3.0);
    p.stroke(lineColor);
  }

  function restart() {
    [dx, dy, ...pen] = model.zeroInput();  // Reset the pen state.
    modelState = model.zeroState();  // Reset the model state.
    setupNewDrawing();
  }
};

new p5(sketch, 'sketch');


/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js ***!
  \**************************************************************************/
/*! exports provided: GraphModel, loadGraphModel, version_converter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GraphModel", function() { return GraphModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadGraphModel", function() { return loadGraphModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version_converter", function() { return version; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var DataType,SaverDef,__assign=function(){return(__assign=Object.assign||function(e){for(var t,a=1,r=arguments.length;a<r;a++)for(var n in t=arguments[a])Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e}).apply(this,arguments)};function __awaiter(e,t,a,r){return new(a||(a=Promise))(function(n,s){function o(e){try{i(r.next(e))}catch(e){s(e)}}function p(e){try{i(r.throw(e))}catch(e){s(e)}}function i(e){e.done?n(e.value):new a(function(t){t(e.value)}).then(o,p)}i((r=r.apply(e,t||[])).next())})}function __generator(e,t){var a,r,n,s,o={label:0,sent:function(){if(1&n[0])throw n[1];return n[1]},trys:[],ops:[]};return s={next:p(0),throw:p(1),return:p(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function p(s){return function(p){return function(s){if(a)throw new TypeError("Generator is already executing.");for(;o;)try{if(a=1,r&&(n=2&s[0]?r.return:s[0]?r.throw||((n=r.return)&&n.call(r),0):r.next)&&!(n=n.call(r,s[1])).done)return n;switch(r=0,n&&(s=[2&s[0],n.value]),s[0]){case 0:case 1:n=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,r=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(n=(n=o.trys).length>0&&n[n.length-1])&&(6===s[0]||2===s[0])){o=0;continue}if(3===s[0]&&(!n||s[1]>n[0]&&s[1]<n[3])){o.label=s[1];break}if(6===s[0]&&o.label<n[1]){o.label=n[1],n=s;break}if(n&&o.label<n[2]){o.label=n[2],o.ops.push(s);break}n[2]&&o.ops.pop(),o.trys.pop();continue}s=t.call(e,o)}catch(e){s=[6,e],r=0}finally{a=n=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,p])}}}function getParamValue(e,t,a,r){var n=t.inputParams[e];if(n&&void 0!==n.inputIndexStart){var s=n.inputIndexStart,o=0===n.inputIndexEnd?void 0:void 0===n.inputIndexEnd?s+1:n.inputIndexEnd;if("tensor"===n.type)return getTensor(t.inputNames[n.inputIndexStart],a,r);if("tensors"===n.type)return t.inputNames.slice(s,o).map(function(e){return getTensor(e,a,r)});var p=Array.prototype.slice.call(getTensor(t.inputNames.slice(s)[0],a,r).dataSync());return"number"===n.type?p[0]:p}var i=t.attrParams[e];return i&&i.value}function getTensor(e,t,a){var r=parseNodeName(e),n=r[0],s=r[1],o=a.currentContextIds.find(function(e){return!!t[getNodeNameWithContextId(n,e)]});return void 0!==o?t[getNodeNameWithContextId(n,o)][s]:void 0}function getTensorsForCurrentContenxt(e,t,a){return t[getNodeNameWithContextId(e,a.currentContextId)]}function getNodeNameAndIndex(e,t){var a=parseNodeName(e),r=a[0],n=a[1];return[getNodeNameWithContextId(r,t&&t.currentContextId),n]}function getNodeNameWithContextId(e,t){return t?e+"-"+t:e}function parseNodeName(e){var t=e.lastIndexOf(":");return-1===t?[e,0]:[e.substring(0,t),Number(e.substring(t+1))]}function split$1(e,t){for(var a=[],r=0;r<e.length;r+=t)a.push(e.slice(r,r+t));return a}!function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(DataType||(DataType={})),function(e){!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(SaverDef||(SaverDef={}));var json=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],arithmetic=Object.freeze({json:json}),json$1=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"clip_value_min",name:"clipValueMin",type:"number"},{tfName:"clip_value_max",name:"clipValueMax",type:"number"}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"clipValueMin",name:"clipValueMin",type:"number",defaultValue:0},{tfName:"clipValueMax",name:"clipValueMax",type:"number",defaultValue:6}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],basicMath=Object.freeze({json:json$1}),json$2=[{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"number"}]}],control=Object.freeze({json:json$2}),json$3=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]}],convolution=Object.freeze({json:json$3}),json$4=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]}],creation=Object.freeze({json:json$4}),json$5=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],dynamic=Object.freeze({json:json$5}),json$6=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]}],evaluation=Object.freeze({json:json$6}),json$7=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],graph=Object.freeze({json:json$7}),json$8=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],image$1=Object.freeze({json:json$8}),json$9=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],logical=Object.freeze({json:json$9}),json$10=[{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],matrices=Object.freeze({json:json$10}),json$11=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],normalization=Object.freeze({json:json$11}),json$12=[{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]}],reduction=Object.freeze({json:json$12}),json$13=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool",notSupported:!0}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],sliceJoin=Object.freeze({json:json$13}),json$14=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],spectral=Object.freeze({json:json$14}),json$15=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]}],transformation=Object.freeze({json:json$15}),CONTROL_FLOW_OPS=["Switch","Merge","Enter","Exit","NextIteration"],DYNAMIC_SHAPE_OPS=["NonMaxSuppressionV2","NonMaxSuppressionV3","Where"],OperationMapper=function(){function e(){var e=[arithmetic,basicMath,control,convolution,creation,dynamic,evaluation,logical,image$1,graph,matrices,normalization,reduction,sliceJoin,spectral,transformation],t=[].concat.apply([],e.map(function(e){return e.json}));this.opMappers=t.reduce(function(e,t){return e[t.tfOpName]=t,e},{})}return Object.defineProperty(e,"Instance",{get:function(){return this._instance||(this._instance=new this)},enumerable:!0,configurable:!0}),e.prototype.isControlFlow=function(e){return CONTROL_FLOW_OPS.some(function(t){return t===e.op})},e.prototype.isDynamicShape=function(e){return DYNAMIC_SHAPE_OPS.some(function(t){return t===e.op})},e.prototype.transformGraph=function(e){var t=this,a=!1,r=!1,n=[],s=[],o=e.node.reduce(function(e,o){return e[o.name]=t.mapNode(o),t.isControlFlow(o)&&(a=!0),t.isDynamicShape(o)&&(r=!0),"Placeholder"===o.op&&n.push(e[o.name]),"Const"===o.op&&s.push(e[o.name]),e},{}),p=[],i=[];return Object.keys(o).forEach(function(e){var t=o[e];t.inputNames.forEach(function(e){var a=getNodeNameAndIndex(e)[0];t.inputs.push(o[a]),o[a].children.push(t)}),0===t.inputs.length&&p.push(t)}),Object.keys(o).forEach(function(e){var t=o[e];0===t.children.length&&i.push(t)}),{nodes:o,inputs:p,outputs:i,weights:s,placeholders:n,withControlFlow:a,withDynamicShape:r}},e.prototype.mapNode=function(e){var t=this,a=this.opMappers[e.op];if(void 0===a)throw new Error("Tensorflow Op is not supported: "+e.op);var r={name:e.name,op:e.op,category:a.category,inputNames:(e.input||[]).map(function(e){return e.startsWith("^")?e.substr(1):e}),inputs:[],children:[],inputParams:{},attrParams:{}};return null==e.attr&&(e.attr={}),null!=a.inputs&&(r.inputParams=a.inputs.reduce(function(e,t){return e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e},{})),null!=a.attrs&&(r.attrParams=a.attrs.reduce(function(a,r){var n=r.type,s=void 0;switch(r.type){case"string":void 0===(s=t.getStringParam(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(s=t.getStringParam(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number":void 0===(s=t.getNumberParam(e.attr,r.tfName,r.defaultValue||0))&&r.tfDeprecatedName&&(s=t.getNumberParam(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number[]":void 0===(s=t.getNumericArrayParam(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(s=t.getNumericArrayParam(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool":void 0===(s=t.getBoolParam(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(s=t.getBoolParam(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape":void 0===(s=t.getTensorShapeParam(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(s=t.getTensorShapeParam(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype":void 0===(s=t.getDtypeParam(e.attr,r.tfName,r.defaultValue))&&r.tfDeprecatedName&&(s=t.getDtypeParam(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error("Unsupported param type: "+r.type+" for op: "+e.op)}return a[r.name]={value:s,type:n},a},{})),r},e.prototype.decodeBase64=function(e){var t=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")},e.prototype.getStringParam=function(e,t,a,r){void 0===r&&(r=!1);var n=e[t];if(void 0!==n){var s=Array.isArray(n.s)?String.fromCharCode.apply(null,n.s):this.decodeBase64(n.s);return r?s:s.toLowerCase()}return a},e.prototype.getBoolParam=function(e,t,a){var r=e[t];return r?r.b:a},e.prototype.getNumberParam=function(e,t,a){var r=e[t]||{},n=r.i?r.i:r.f?r.f:a;return"number"==typeof n?n:parseInt(n,10)},e.prototype.getDtypeParam=function(e,t,a){var r=e[t];if(r&&r.type){var n=r.type;switch("string"==typeof r.type&&(n=DataType[r.type]),n){case DataType.DT_FLOAT:return"float32";case DataType.DT_INT32:return"int32";case DataType.DT_BOOL:return"bool";default:return a}}return a},e.prototype.getTensorShapeParam=function(e,t,a){var r=e[t];if(r&&r.shape){if(r.shape.unknownRank)return;if(null!=r.shape.dim)return r.shape.dim.map(function(e){return"number"==typeof e.size?e.size:parseInt(e.size,10)})}return a},e.prototype.getNumericArrayParam=function(e,t,a){var r=e[t];return r?(r.list.f&&r.list.f.length?r.list.f:r.list.i).map(function(e){return"number"==typeof e?e:parseInt(e,10)}):a},e}(),executeOp=function(e,t,a){switch(e.op){case"BiasAdd":case"Add":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"AddN":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["addN"])(getParamValue("tensors",e,t,a))];case"FloorMod":case"Mod":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mod"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Mul":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"RealDiv":case"Div":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"FloorDiv":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["floorDiv"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Sub":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Minimum":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["minimum"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Maximum":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Pow":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pow"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"SquaredDifference":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squaredDifference"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$1=function(e,t,a){switch(e.op){case"Abs":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(getParamValue("x",e,t,a))];case"Acos":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["acos"])(getParamValue("x",e,t,a))];case"Acosh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["acosh"])(getParamValue("x",e,t,a))];case"Asin":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["asin"])(getParamValue("x",e,t,a))];case"Asinh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["asinh"])(getParamValue("x",e,t,a))];case"Atan":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atan"])(getParamValue("x",e,t,a))];case"Atan2":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atan2"])(getParamValue("x",e,t,a),getParamValue("y",e,t,a))];case"Atanh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atanh"])(getParamValue("x",e,t,a))];case"Ceil":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ceil"])(getParamValue("x",e,t,a))];case"Cos":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cos"])(getParamValue("x",e,t,a))];case"Cosh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cosh"])(getParamValue("x",e,t,a))];case"Elu":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["elu"])(getParamValue("x",e,t,a))];case"Erf":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["erf"])(getParamValue("x",e,t,a))];case"Exp":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["exp"])(getParamValue("x",e,t,a))];case"Expm1":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expm1"])(getParamValue("x",e,t,a))];case"Floor":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["floor"])(getParamValue("x",e,t,a))];case"Log":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(getParamValue("x",e,t,a))];case"Log1p":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log1p"])(getParamValue("x",e,t,a))];case"Neg":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"])(getParamValue("x",e,t,a))];case"Reciprocal":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reciprocal"])(getParamValue("x",e,t,a))];case"Relu":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"])(getParamValue("x",e,t,a))];case"Round":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["round"])(getParamValue("x",e,t,a))];case"Selu":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["selu"])(getParamValue("x",e,t,a))];case"Sigmoid":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sigmoid"])(getParamValue("x",e,t,a))];case"Sin":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sin"])(getParamValue("x",e,t,a))];case"Sign":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sign"])(getParamValue("x",e,t,a))];case"Sinh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sinh"])(getParamValue("x",e,t,a))];case"Softplus":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softplus"])(getParamValue("x",e,t,a))];case"Sqrt":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(getParamValue("x",e,t,a))];case"Square":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["square"])(getParamValue("x",e,t,a))];case"Tanh":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tanh"])(getParamValue("x",e,t,a))];case"Tan":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tan"])(getParamValue("x",e,t,a))];case"Relu6":case"ClipByValue":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(getParamValue("x",e,t,a),getParamValue("clipValueMin",e,t,a),getParamValue("clipValueMax",e,t,a))];case"Rsqrt":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["rsqrt"])(getTensor(e.inputNames[0],t,a))];case"Prod":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["prod"])(getParamValue("x",e,t,a),getParamValue("axes",e,t,a))];case"LeakyRelu":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["leakyRelu"])(getParamValue("x",e,t,a),getParamValue("alpha",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},TensorArray=function(){function e(t,a,r,n,s,o,p){this.name=t,this.dtype=a,this.maxSize=r,this.elementShape=n,this.identicalElementShapes=s,this.dynamicSize=o,this.clearAfterRead=p,this.tensors=[],this.closed_=!1,this.id=e.nextId++}return Object.defineProperty(e.prototype,"closed",{get:function(){return this.closed_},enumerable:!0,configurable:!0}),e.prototype.clearAndClose=function(){this.tensors.forEach(function(e){return e.tensor.dispose()}),this.tensors=[],this.closed_=!0},e.prototype.size=function(){return this.tensors.length},e.prototype.read=function(e){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(e<0||e>=this.tensors.length)throw new Error("Tried to read from index "+e+", but array size is: "+this.tensors.length);var t=this.tensors[e];if(t.cleared)throw new Error("TensorArray "+this.name+": Could not read index "+e+" twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor},e.prototype.readMany=function(e){var t=this;return e.map(function(e){return t.read(e)})},e.prototype.write=function(e,t){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error("Tried to write to index "+e+", but array is not resizeable and size is: "+this.maxSize);var a=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+e+",\n          because the value dtype is "+t.dtype+", but TensorArray dtype is "+this.dtype+".");if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),this.assertShapesMatchAllowUndefinedSize(this.elementShape,t.shape,"TensorArray "+this.name+": Could not write to TensorArray index "+e+"."),a&&a.read)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+e+", because it has already been read.");if(a&&a.written)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+e+", because it has already been written.");a.tensor=t,a.written=!0,this.tensors[e]=a},e.prototype.writeMany=function(e,t){var a=this;if(e.length!==t.length)throw new Error("TensorArray "+this.name+": could not write multiple tensors,because the index size: "+e.length+" is not the same as tensors size: "+t.length+".");e.forEach(function(e,r){return a.write(e,t[r])})},e.prototype.gather=function(e,t){if(t&&t!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but gather requested dtype "+t);if(!e){e=[];for(var a=0;a<this.size();a++)e.push(a)}if(0===e.length)return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor"])([],[0].concat(this.elementShape));var r=this.readMany(e);return this.assertShapesMatchAllowUndefinedSize(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"])(r,0)},e.prototype.concat=function(e){if(e&&e!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but concat requested dtype "+e);if(0===this.size())return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor"])([],[0].concat(this.elementShape));for(var t=[],a=0;a<this.size();a++)t.push(a);var r=this.readMany(t);return this.assertShapesMatchAllowUndefinedSize(this.elementShape,r[0].shape,"TensorArray shape mismatch: tensor array shape ("+this.elementShape+") vs first tensor shape ("+r[0].shape+")"),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"])(r,0)},e.prototype.scatter=function(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+t.dtype);if(e.length!==t.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: "+e.length+" vs. "+t.shape[0]);var a=Math.max.apply(Math,e);if(!this.dynamicSize&&a>=this.maxSize)throw new Error("Max index must be < array size ("+a+"  vs. "+this.maxSize+")");this.writeMany(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"])(t,0))},e.prototype.split=function(e,t){var a=this;if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+t.dtype);var r=0,n=e.map(function(e){return r+=e});if(r!==t.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        "+r+", and tensor's shape is: "+t.shape);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error("TensorArray's size is not equal to the size of lengths ("+this.maxSize+" vs. "+e.length+"), and the TensorArray is not marked as dynamically resizeable");var s=0===r?0:t.size/r,o=[];Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){t=t.reshape([1,r,s]);for(var p=0;p<e.length;++p){var i=[0,0===p?0:n[p-1],0],u=[1,e[p],s];o[p]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice"])(t,i,u).reshape(a.elementShape)}return o});for(var p=[],i=0;i<e.length;i++)p[i]=i;this.writeMany(p,o)},e.prototype.assertShapesMatchAllowUndefinedSize=function(e,t,a){void 0===a&&(a=""),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(this.shapesEqualAllowUndefinedSize(e,t),function(){return a+" Shapes "+e+" and "+t+" must match"})},e.prototype.shapesEqualAllowUndefinedSize=function(e,t){if(e.length!==t.length)return!1;for(var a=0;a<e.length;a++)if(-1!==e[a]&&-1!==t[a]&&e[a]!==t[a])return!1;return!0},e.nextId=0,e}();function executeOp$2(e,t,a){return __awaiter(this,void 0,void 0,function(){var r,n,s,o,p,i,u,m,c,l,d,y,f,h,g,N,x,b,V,P,T,O,v,S,_,w,A,D,E,I,M,C,k,j,z;return __generator(this,function(F){switch(F.label){case 0:switch(e.op){case"LoopCond":return[3,1];case"Switch":return[3,2];case"Merge":return[3,4];case"Enter":return[3,5];case"Exit":return[3,6];case"NextIteration":return[3,7];case"TensorArrayV3":return[3,8];case"TensorArrayWriteV3":return[3,9];case"TensorArrayReadV3":return[3,10];case"TensorArrayGatherV3":return[3,11];case"TensorArrayScatterV3":return[3,12];case"TensorArrayConcatV3":return[3,13];case"TensorArraySplitV3":return[3,14];case"TensorArraySizeV3":return[3,15];case"TensorArrayCloseV3":return[3,16]}return[3,17];case 1:return[2,[getParamValue("pred",e,t,a).clone()]];case 2:return r=getParamValue("pred",e,t,a),n=getParamValue("data",e,t,a),[4,r.data()];case 3:return[2,F.sent()[0]?[void 0,n.clone()]:[n.clone(),void 0]];case 4:return[2,(s=e.inputNames.find(function(e){return void 0!==getTensor(e,t,a)}))?[getTensor(s,t,a).clone()]:void 0];case 5:return o=getParamValue("frameName",e,t,a),p=getParamValue("tensor",e,t,a),a.enterFrame(o),[2,[p.clone()]];case 6:return i=getParamValue("tensor",e,t,a),a.exitFrame(),[2,[i.clone()]];case 7:return u=getParamValue("tensor",e,t,a),a.nextIteration(),[2,[u.clone()]];case 8:return m=getParamValue("size",e,t,a),c=getParamValue("dtype",e,t,a),l=getParamValue("elementShape",e,t,a),d=getParamValue("dynamicSize",e,t,a),y=getParamValue("clearAfterRead",e,t,a),f=getParamValue("identicalElementShapes",e,t,a),h=getParamValue("name",e,t,a),g=new TensorArray(h,c,m,l,f,d,y),a.addTensorArray(g),[2,[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(g.id),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(1)]];case 9:return N=getParamValue("tensorArrayId",e,t,a),x=getParamValue("index",e,t,a),b=getParamValue("tensor",e,t,a),a.getTensorArray(N).write(x,b),[2,[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(1)]];case 10:return V=getParamValue("tensorArrayId",e,t,a),P=getParamValue("index",e,t,a),[2,[a.getTensorArray(V).read(P)]];case 11:return T=getParamValue("tensorArrayId",e,t,a),O=getParamValue("indices",e,t,a),v=getParamValue("dtype",e,t,a),[2,[a.getTensorArray(T).gather(O,v)]];case 12:return S=getParamValue("tensorArrayId",e,t,a),_=getParamValue("indices",e,t,a),w=getParamValue("tensor",e,t,a),a.getTensorArray(S).scatter(_,w),[2,[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(1)]];case 13:return A=getParamValue("tensorArrayId",e,t,a),D=a.getTensorArray(A),E=getParamValue("dtype",e,t,a),[2,[D.concat(E)]];case 14:return I=getParamValue("tensorArrayId",e,t,a),M=getParamValue("tensor",e,t,a),C=getParamValue("lengths",e,t,a),a.getTensorArray(I).split(C,M),[2,[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(1)]];case 15:return k=getParamValue("tensorArrayId",e,t,a),j=a.getTensorArray(k),[2,[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(j.size(),"int32")]];case 16:return z=getParamValue("tensorArrayId",e,t,a),a.getTensorArray(z).clearAndClose(),[2,[]];case 17:throw TypeError("Node type "+e.op+" is not implemented")}})})}var executeOp$3=function(e,t,a){switch(e.op){case"Conv1D":var r=getParamValue("stride",e,t,a),n=getParamValue("pad",e,t,a),s=getParamValue("dataFormat",e,t,a).toUpperCase(),o=getParamValue("dilation",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv1d"])(getParamValue("x",e,t,a),getParamValue("filter",e,t,a),r,n,s,o)];case"Conv2D":r=getParamValue("strides",e,t,a),n=getParamValue("pad",e,t,a),s=getParamValue("dataFormat",e,t,a).toUpperCase();var p=getParamValue("dilations",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"])(getParamValue("x",e,t,a),getParamValue("filter",e,t,a),[r[1],r[2]],n,s,[p[0],p[1]])];case"Conv2DBackpropInput":case"Conv2dTranspose":var i=getParamValue("outputShape",e,t,a);r=getParamValue("strides",e,t,a),n=getParamValue("pad",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2dTranspose"])(getParamValue("x",e,t,a),getParamValue("filter",e,t,a),i,[r[1],r[2]],n)];case"DepthwiseConv2dNative":case"DepthwiseConv2d":r=getParamValue("strides",e,t,a),n=getParamValue("pad",e,t,a),p=getParamValue("dilations",e,t,a),s=getParamValue("dataFormat",e,t,a).toUpperCase();return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthwiseConv2d"])(getParamValue("input",e,t,a),getParamValue("filter",e,t,a),[r[1],r[2]],n,s,[p[0],p[1]])];case"AvgPool":r=getParamValue("strides",e,t,a),n=getParamValue("pad",e,t,a);var u=getParamValue("kernelSize",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["avgPool"])(getParamValue("x",e,t,a),[u[1],u[2]],[r[1],r[2]],n)];case"MaxPool":r=getParamValue("strides",e,t,a),n=getParamValue("pad",e,t,a),u=getParamValue("kernelSize",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maxPool"])(getParamValue("x",e,t,a),[u[1],u[2]],[r[1],r[2]],n)];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$4=function(e,t,a){switch(e.op){case"Fill":var r=getParamValue("shape",e,t,a),n=getParamValue("dtype",e,t,a),s=getParamValue("value",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fill"])(r,s,n)];case"LinSpace":var o=getParamValue("start",e,t,a),p=getParamValue("stop",e,t,a),i=getParamValue("num",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["linspace"])(o,p,i)];case"OneHot":var u=getParamValue("indices",e,t,a),m=getParamValue("depth",e,t,a),c=getParamValue("onValue",e,t,a),l=getParamValue("offValue",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["oneHot"])(u,m,c,l)];case"Ones":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ones"])(getParamValue("shape",e,t,a),getParamValue("dtype",e,t,a))];case"OnesLike":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(getParamValue("x",e,t,a))];case"RandomUniform":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"])(getParamValue("shape",e,t,a),getParamValue("minval",e,t,a),getParamValue("maxval",e,t,a),getParamValue("dtype",e,t,a))];case"Range":o=getParamValue("start",e,t,a);var d=getParamValue("stop",e,t,a),y=getParamValue("step",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["range"])(o,d,y,getParamValue("dtype",e,t,a))];case"TruncatedNormal":r=getParamValue("shape",e,t,a);var f=getParamValue("mean",e,t,a),h=getParamValue("stdDev",e,t,a),g=getParamValue("seed",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["truncatedNormal"])(r,f,h,getParamValue("dtype",e,t,a),g)];case"Zeros":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])(getParamValue("shape",e,t,a),getParamValue("dtype",e,t,a))];case"ZerosLike":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zerosLike"])(getParamValue("x",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}};function executeOp$5(e,t,a){return __awaiter(this,void 0,void 0,function(){var r,n,s,o,p;return __generator(this,function(i){switch(i.label){case 0:switch(e.op){case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":return[3,1];case"Where":return[3,3];case"ListDiff":return[3,5]}return[3,7];case 1:return r=getParamValue("boxes",e,t,a),n=getParamValue("scores",e,t,a),s=getParamValue("maxOutputSize",e,t,a),o=getParamValue("iouThreshold",e,t,a),p=getParamValue("scoreThreshold",e,t,a),[4,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].nonMaxSuppressionAsync(r,n,s,o,p)];case 2:return[2,[i.sent()]];case 3:return[4,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["whereAsync"])(getParamValue("condition",e,t,a))];case 4:return[2,[i.sent()]];case 5:return[4,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["setdiff1dAsync"])(getParamValue("x",e,t,a),getParamValue("y",e,t,a))];case 6:return[2,i.sent()];case 7:throw TypeError("Node type "+e.op+" is not implemented")}})})}var executeOp$6=function(e,t,a){switch(e.op){case"TopKV2":var r=getParamValue("x",e,t,a),n=getParamValue("k",e,t,a),s=getParamValue("sorted",e,t,a),o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["topk"])(r,n,s);return[o.values,o.indices];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$7=function(e,t,a){switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":var r=getParamValue("default",e,t,a);return[getTensor(e.name,t,a)||r];case"Placeholder":return[getTensor(e.name,t,a)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[getParamValue("x",e,t,a).clone()];case"IdentityN":return getParamValue("x",e,t,a).map(function(e){return e.clone()});case"Snapshot":return[getParamValue("x",e,t,a).clone()];case"Shape":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(getParamValue("x",e,t,a).shape,"int32")];case"ShapeN":return getParamValue("x",e,t,a).map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(e.shape)});case"Size":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(getParamValue("x",e,t,a).size,"int32")];case"Rank":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(getParamValue("x",e,t,a).rank,"int32")];case"NoOp":return[];case"Print":var n=getParamValue("x",e,t,a),s=getParamValue("data",e,t,a),o=getParamValue("message",e,t,a),p=getParamValue("summarize",e,t,a);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(var i=0;i<s.length;i++)console.log(Array.prototype.slice.call(s[i].dataSync()).slice(0,p));return[n];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$8=function(e,t,a){switch(e.op){case"ResizeBilinear":var r=getParamValue("images",e,t,a),n=getParamValue("size",e,t,a),s=getParamValue("alignCorners",e,t,a);return[_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].resizeBilinear(r,[n[0],n[1]],s)];case"ResizeNearestNeighbor":r=getParamValue("images",e,t,a),n=getParamValue("size",e,t,a),s=getParamValue("alignCorners",e,t,a);return[_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].resizeNearestNeighbor(r,[n[0],n[1]],s)];case"CropAndResize":var o=getParamValue("image",e,t,a),p=getParamValue("boxes",e,t,a),i=getParamValue("boxInd",e,t,a),u=getParamValue("cropSize",e,t,a),m=getParamValue("method",e,t,a),c=getParamValue("extrapolationValue",e,t,a);return[_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].cropAndResize(o,p,i,u,m,c)];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$9=function(e,t,a){switch(e.op){case"Equal":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equal"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"NotEqual":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["notEqual"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Greater":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greater"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"GreaterEqual":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greaterEqual"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Less":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["less"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"LessEqual":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["lessEqual"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"LogicalAnd":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"LogicalNot":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalNot"])(getParamValue("a",e,t,a))];case"LogicalOr":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalOr"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a))];case"Select":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["where"])(getParamValue("condition",e,t,a),getParamValue("a",e,t,a),getParamValue("b",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$10=function(e,t,a){switch(e.op){case"BatchMatMul":case"MatMul":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["matMul"])(getParamValue("a",e,t,a),getParamValue("b",e,t,a),getParamValue("transposeA",e,t,a),getParamValue("transposeB",e,t,a))];case"Transpose":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(getParamValue("x",e,t,a),getParamValue("perm",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$11=function(e,t,a){switch(e.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm"])(getParamValue("x",e,t,a),getParamValue("mean",e,t,a),getParamValue("variance",e,t,a),getParamValue("offset",e,t,a),getParamValue("scale",e,t,a),getParamValue("epsilon",e,t,a))];case"LRN":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["localResponseNormalization"])(getParamValue("x",e,t,a),getParamValue("radius",e,t,a),getParamValue("bias",e,t,a),getParamValue("alpha",e,t,a),getParamValue("beta",e,t,a))];case"Softmax":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"])(getParamValue("x",e,t,a))];case"LogSoftmax":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logSoftmax"])(getParamValue("x",e,t,a))];case"SparseToDense":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sparseToDense"])(getParamValue("sparseIndices",e,t,a),getParamValue("outputShape",e,t,a),getParamValue("sparseValues",e,t,a),getParamValue("defaultValue",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$12=function(e,t,a){switch(e.op){case"Max":var r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(getParamValue("x",e,t,a),r,n)];case"Mean":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(getParamValue("x",e,t,a),r,n)];case"Min":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["min"])(getParamValue("x",e,t,a),r,n)];case"Sum":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(getParamValue("x",e,t,a),r,n)];case"All":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["all"])(getParamValue("x",e,t,a),r,n)];case"Any":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["any"])(getParamValue("x",e,t,a),r,n)];case"ArgMax":r=getParamValue("axis",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMax"])(getParamValue("x",e,t,a),r)];case"ArgMin":r=getParamValue("axis",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMin"])(getParamValue("x",e,t,a),r)];case"Prod":r=getParamValue("axis",e,t,a),n=getParamValue("keepDims",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["prod"])(getParamValue("x",e,t,a),r,n)];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$13=function(e,t,a){switch(e.op){case"ConcatV2":case"Concat":var r=getParamValue("axis",e,t,a),n=getParamValue("tensors",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"])(n,r)];case"GatherV2":case"Gather":r=getParamValue("axis",e,t,a);var s=getParamValue("x",e,t,a),o=getParamValue("indices",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["gather"])(s,o.asType("int32"),r)];case"ReverseV2":case"Reverse":r=getParamValue("axis",e,t,a),s=getParamValue("x",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse"])(s,r)];case"Slice":var p=getParamValue("begin",e,t,a),i=getParamValue("size",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice"])(getParamValue("x",e,t,a),p,i)];case"StridedSlice":p=getParamValue("begin",e,t,a);var u=getParamValue("end",e,t,a),m=getParamValue("strides",e,t,a),c=getParamValue("beginMask",e,t,a),l=getParamValue("endMask",e,t,a),d=getParamValue("ellipsisMask",e,t,a),y=getParamValue("newAxisMask",e,t,a),f=getParamValue("shrinkAxisMask",e,t,a),h=getParamValue("x",e,t,a);if(1===p.length&&h.shape.length>1)for(var g=1;g<h.shape.length;g++)p.push(0),u.push(h.shape[g]),m.push(m[0]);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stridedSlice"])(h,p,u,m,c,l,d,y,f)];case"Pack":return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=getParamValue("axis",e,t,a),n=getParamValue("tensors",e,t,a),s=n[0].shape,o=n[0].squeeze().shape,p=n.map(function(e){var t=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(e.shape,s);if(!t&&!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(e.squeeze().shape,o))throw new Error("the input tensors shape does not match");return t?e:e.reshape(s)});return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"])(p,r)]});case"Unpack":return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=getParamValue("axis",e,t,a),n=getParamValue("tensor",e,t,a);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"])(n,r)});case"Tile":var N=getParamValue("reps",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tile"])(getParamValue("x",e,t,a),N)];case"Split":case"SplitV":r=getParamValue("axis",e,t,a);var x=getParamValue("numOrSizeSplits",e,t,a);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"])(getParamValue("x",e,t,a),x,r);case"ScatterNd":o=getParamValue("indices",e,t,a);var b=getParamValue("values",e,t,a),V=getParamValue("shape",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scatterND"])(o,b,V)];case"GatherNd":var P=getParamValue("x",e,t,a);o=getParamValue("indices",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["gatherND"])(P,o)];case"SparseToDense":o=getParamValue("sparseIndices",e,t,a),V=getParamValue("outputShape",e,t,a);var T=getParamValue("sparseValues",e,t,a),O=getParamValue("defaultValue",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sparseToDense"])(o,T,V,T.dtype===O.dtype?O:O.asType(T.dtype))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$14=function(e,t,a){switch(e.op){case"FFT":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fft"])(getParamValue("x",e,t,a))];case"IFFT":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ifft"])(getParamValue("x",e,t,a))];case"RFFT":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["rfft"])(getParamValue("x",e,t,a))];case"IRFFT":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["irfft"])(getParamValue("x",e,t,a))];default:throw TypeError("Node type "+e.op+" is not implemented")}},executeOp$15=function(e,t,a){switch(e.op){case"Cast":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cast"])(getParamValue("x",e,t,a),getParamValue("dtype",e,t,a))];case"ExpandDims":var r=getParamValue("axis",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"])(getParamValue("x",e,t,a),r)];case"Squeeze":r=getParamValue("axis",e,t,a);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squeeze"])(getParamValue("x",e,t,a),r)];case"Reshape":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"])(getParamValue("x",e,t,a),getParamValue("shape",e,t,a))];case"PadV2":case"Pad":return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad"])(getParamValue("x",e,t,a),split$1(getParamValue("padding",e,t,a),2),getParamValue("constantValue",e,t,a))];case"SpaceToBatchND":var n=getParamValue("blockShape",e,t,a),s=split$1(getParamValue("paddings",e,t,a),2);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["spaceToBatchND"])(getParamValue("x",e,t,a),n,s)];case"BatchToSpaceND":n=getParamValue("blockShape",e,t,a);var o=split$1(getParamValue("crops",e,t,a),2);return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchToSpaceND"])(getParamValue("x",e,t,a),n,o)];case"DepthToSpace":var p=getParamValue("blockSize",e,t,a),i=getParamValue("dataFormat",e,t,a).toUpperCase();return[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthToSpace"])(getParamValue("x",e,t,a),p,i)];default:throw TypeError("Node type "+e.op+" is not implemented")}};function executeOp$16(e,t,a){var r=function(e,t,a){switch(e.category){case"arithmetic":return executeOp(e,t,a);case"basic_math":return executeOp$1(e,t,a);case"control":return executeOp$2(e,t,a);case"convolution":return executeOp$3(e,t,a);case"creation":return executeOp$4(e,t,a);case"dynamic":return executeOp$5(e,t,a);case"evaluation":return executeOp$6(e,t,a);case"image":return executeOp$8(e,t,a);case"graph":return executeOp$7(e,t,a);case"logical":return executeOp$9(e,t,a);case"matrices":return executeOp$10(e,t,a);case"normalization":return executeOp$11(e,t,a);case"reduction":return executeOp$12(e,t,a);case"slice_join":return executeOp$13(e,t,a);case"spectral":return executeOp$14(e,t,a);case"transformation":return executeOp$15(e,t,a);default:throw TypeError("Node type "+e.op+" is not implemented")}}(e,t,a);return r instanceof Promise?r.then(function(e){return[].concat(e)}):[].concat(r)}var ExecutionContext=function(){function e(e,t){this.weightMap=e,this.tensorArrayMap=t,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}return e.prototype.newFrame=function(e,t){return{id:e,frameName:t,iterationId:0}},Object.defineProperty(e.prototype,"currentContext",{get:function(){return this.contexts},set:function(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"currentContextId",{get:function(){return this._currentContextIds[0]},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"currentContextIds",{get:function(){return this._currentContextIds},enumerable:!0,configurable:!0}),e.prototype.generateCurrentContextIds=function(){for(var e=[],t=0;t<this.contexts.length-1;t++){var a=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(a))}e.push(""),this._currentContextIds=e},e.prototype.contextIdforContexts=function(e){return e?e.map(function(e){return 0===e.id&&0===e.iterationId?"":e.frameName+"-"+e.iterationId}).join("/"):""},e.prototype.enterFrame=function(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))},e.prototype.exitFrame=function(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()},e.prototype.nextIteration=function(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");this.contexts=this.contexts.slice(),this.lastId++;var e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))},e.prototype.getWeight=function(e){return this.weightMap[e]},e.prototype.addTensorArray=function(e){this.tensorArrayMap[e.id]=e},e.prototype.getTensorArray=function(e){return this.tensorArrayMap[e]},e}(),GraphExecutor=function(){function e(e){this.graph=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this.placeholders=e.placeholders,this._outputs=e.outputs,this.compile()}return Object.defineProperty(e.prototype,"weightMap",{get:function(){return this._weightMap},set:function(e){var t=Object.keys(e).map(function(t){return e[t].map(function(e){return e.id})});this.weightIds=[].concat.apply([],t),this._weightMap=e},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"inputs",{get:function(){return this.placeholders.map(function(e){return{name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}})},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"outputs",{get:function(){return this._outputs.map(function(e){return{name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}})},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"inputNodes",{get:function(){return this.placeholders.map(function(e){return e.name})},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"outputNodes",{get:function(){return this.outputs.map(function(e){return e.name})},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"isControlFlowModel",{get:function(){return this.graph.withControlFlow},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"isDynamicShapeModel",{get:function(){return this.graph.withDynamicShape},enumerable:!0,configurable:!0}),e.prototype.compile=function(e){if(!this.graph.withControlFlow&&!this.graph.withDynamicShape){var t=[],a=e||this.graph.placeholders,r=a.map(function(e){return e.name}).sort().join(this.SEPERATOR);if(!this.compiledMap.get(r)){for(var n=a.concat(this.graph.weights),s={};n.length>0;){var o=n.pop();s[o.name]=!0,t.push(o),o.children.forEach(function(e){!s[e.name]&&e.inputNames.every(function(e){var t=getNodeNameAndIndex(e)[0];return s[t]})&&n.push(e)})}this.compiledMap.set(r,t)}}},e.prototype.execute=function(e,t,a){var r=this;void 0===t&&(t=!0);var n=Object.keys(e).sort();this.checkInput(e,t),this.checkInputShapeAndType(e,t),this.compile(n.map(function(e){return r.graph.nodes[e]}));var s=this.calculateOutputs(a);this.checkOutput(this.compiledMap.get(n.join(this.SEPERATOR)),s);var o={};return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=new ExecutionContext(r._weightMap,o),a=__assign({},r.weightMap,e),p=r.getFrozenTensorIds(a),i={},u=r.compiledMap.get(n.join(r.SEPERATOR)),m=0;m<u.length;m++){var c=u[m];if(a[c.name]||(a[c.name]=executeOp$16(c,a,t),r.checkTensorForDisposal(c.name,c,a,t,p,s,i)),s.every(function(e){return!!a[e]}))break}return r.findOutputs(a,t,s)})},e.prototype.getFrozenTensorIds=function(e){var t=[].concat.apply([],Object.keys(e).map(function(t){return e[t]}).map(function(e){return e.map(function(e){return e.id})}));return new Set(t)},e.prototype.checkTensorForDisposal=function(e,t,a,r,n,s,o){"control"!==t.category&&-1===s.indexOf(e)&&(a[e].forEach(function(e){null!=e&&(o[e.id]=(o[e.id]||0)+t.children.length)}),t.inputs.forEach(function(e){if("control"!==e.category){var t=getTensorsForCurrentContenxt(e.name,a,r);null!=t&&t.forEach(function(e){if(e&&!n.has(e.id)){var t=o[e.id];1===t?(e.dispose(),delete o[e.id]):null!=t&&o[e.id]--}})}}))},e.prototype.executeAsync=function(e,t){return __awaiter(this,void 0,void 0,function(){var a,r,n,s,o,p,i,u,m=this;return __generator(this,function(c){switch(c.label){case 0:return this.checkInput(e,!1),this.checkInputShapeAndType(e,!1),a={},r=new ExecutionContext(this._weightMap,a),n=this.calculateOutputs(t),[4,this.executeWithControlFlow(e,r,n)];case 1:return s=c.sent(),o=this.findOutputs(s,r,t),p=Object.keys(o).map(function(e){return o[e].id}),i=Object.keys(e).map(function(t){return e[t].map(function(e){return e.id})}),u=[].concat.apply([],i),Object.keys(s).forEach(function(e){s[e].forEach(function(e){e&&!e.isDisposed&&-1===p.indexOf(e.id)&&-1===u.indexOf(e.id)&&-1===m.weightIds.indexOf(e.id)&&e.dispose()})}),[2,o]}})})},e.prototype.executeWithControlFlow=function(e,t,a){return __awaiter(this,void 0,void 0,function(){var r,n,s,o,p,i,u,m,c=this;return __generator(this,function(l){switch(l.label){case 0:r=Object.keys(e),n=r.map(function(e){return c.graph.nodes[e]}),s=n.concat(this.graph.weights).map(function(e){return{node:e,contexts:t.currentContext}}),o=__assign({},this.weightMap,e),p={},i=this.getFrozenTensorIds(o),u={},l.label=1;case 1:return s.length>0?(m=this.processStack(n,s,t,o,u,i,a,p),[4,Promise.all(m)]):[3,3];case 2:return l.sent(),[3,1];case 3:return[2,o]}})})},e.prototype.processStack=function(e,t,a,r,n,s,o,p){for(var i=this,u=[],m=function(){var m=t.pop();a.currentContext=m.contexts;var l="";if("Enter"===m.node.op&&getParamValue("isConstant",m.node,r,a)&&(l=getNodeNameAndIndex(m.node.name,a)[0]),-1===e.indexOf(m.node)){var d=executeOp$16(m.node,r,a);l||(l=getNodeNameAndIndex(m.node.name,a)[0]);var y=a.currentContext;d instanceof Promise?u.push(d.then(function(e){return r[l]=e,a.currentContext=y,i.checkTensorForDisposal(l,m.node,r,a,s,o,p),i.processChildNodes(m.node,t,a,r,n),e})):(r[l]=d,c.checkTensorForDisposal(l,m.node,r,a,s,o,p),c.processChildNodes(m.node,t,a,r,n))}else c.processChildNodes(m.node,t,a,r,n)},c=this;t.length>0;)m();return u},e.prototype.processChildNodes=function(e,t,a,r,n){e.children.forEach(function(e){var s=getNodeNameAndIndex(e.name,a)[0];n[s]||("Merge"===e.op?e.inputNames.some(function(e){return!!getTensor(e,r,a)})&&(n[s]=!0,t.push({contexts:a.currentContext,node:e})):e.inputNames.every(function(e){return!!getTensor(e,r,a)})&&(n[s]=!0,t.push({contexts:a.currentContext,node:e})))})},e.prototype.calculateOutputs=function(e){return!e||e instanceof Array||(e=[e]),e||this.graph.outputs.map(function(e){return e.name})},e.prototype.findOutputs=function(e,t,a){return this.calculateOutputs(a).reduce(function(a,r){return a[r]=getTensor(r,e,t),a},{})},e.prototype.dispose=function(){var e=this;Object.keys(this.weightMap).forEach(function(t){return e.weightMap[t].forEach(function(e){return e.dispose()})})},e.prototype.checkInputShapeAndType=function(e,t){void 0===t&&(t=!0),this.placeholders.forEach(function(a){var r=e[a.name];if(t||r){var n=r[0];if(a.attrParams.shape&&a.attrParams.shape.value){var s=a.attrParams.shape.value,o=s.length===n.shape.length&&n.shape.every(function(e,t){return-1===s[t]||s[t]===e});_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(o,function(){return"The shape of dict['"+a.name+"'] provided in model.execute(dict) must be ["+s+"], but was ["+n.shape+"]"})}a.attrParams.dtype&&a.attrParams.dtype.value&&_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(n.dtype===a.attrParams.dtype.value,function(){return"The dtype of dict['"+a.name+"'] provided in model.execute(dict) must be "+a.attrParams.dtype.value+", but was "+n.dtype})}})},e.prototype.checkInput=function(e,t){var a=this;void 0===t&&(t=!0);var r=Object.keys(e),n=[],s=[];this.inputNodes.forEach(function(e){-1===r.indexOf(e)&&n.push(e)}),r.forEach(function(e){-1===a.inputNodes.indexOf(e)&&s.push(e)});var o=s.filter(function(e){return!a.graph.nodes[e]});if(n.length>0&&t)throw new Error("The dict provided in model.execute(dict) has the keys ["+r+"], but is missing the required keys: ["+n+"].");if(s.length>0&&t)throw new Error("The dict provided in model.execute(dict) has unused keys: ["+s+"]. Please provide only the following keys: ["+this.inputNodes+"].");if(o.length>0)throw new Error("The dict provided in model.execute(dict) has keys: ["+o+"] not part of model graph.")},e.prototype.checkOutput=function(e,t){var a=e.map(function(e){return e.name}),r=[];if(t.forEach(function(e){var t=parseNodeName(e)[0];-1===a.indexOf(t)&&r.push(t)}),r.length>0)throw new Error("The following outputs are not generated by the execution: ["+r+"].")},e}(),TFHUB_SEARCH_PARAM="?tfjs-format=file",DEFAULT_MODEL_NAME="model.json",GraphModel=function(){function e(e,t){void 0===t&&(t={}),this.modelUrl=e,this.loadOptions=t,this.version="n/a",null==t&&(this.loadOptions={})}return Object.defineProperty(e.prototype,"modelVersion",{get:function(){return this.version},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"inputNodes",{get:function(){return this.executor.inputNodes},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"outputNodes",{get:function(){return this.executor.outputNodes},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"inputs",{get:function(){return this.executor.inputs},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"outputs",{get:function(){return this.executor.outputs},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"weights",{get:function(){return this.executor.weightMap},enumerable:!0,configurable:!0}),e.prototype.findIOHandler=function(){var e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].browserHTTPRequest(e,this.loadOptions);else{var t=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].getLoadHandlers(e,this.loadOptions.onProgress);if(0===t.length)t.push(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error("Found more than one ("+t.length+") load handlers for URL '"+[e]+"'");this.handler=t[0]}},e.prototype.load=function(){return __awaiter(this,void 0,void 0,function(){var e,t,a;return __generator(this,function(r){switch(r.label){case 0:if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");return[4,this.handler.load()];case 1:return e=r.sent(),t=e.modelTopology,this.version=t.versions.producer+"."+t.versions.minConsumer,a=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].decodeWeights(e.weightData,e.weightSpecs),this.executor=new GraphExecutor(OperationMapper.Instance.transformGraph(t)),this.executor.weightMap=this.convertTensorMapToTensorsMap(a),[2,!0]}})})},e.prototype.predict=function(e,t){return this.execute_(e,!0,this.outputNodes)},e.prototype.constructTensorMap=function(e){var t=e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]?[e]:e;if(t.length!==this.inputNodes.length)throw new Error("Input tensor count mismatch,the graph model has "+this.inputNodes.length+" placeholders, while there are "+t.length+" input tensors.");return this.inputNodes.reduce(function(e,a,r){return e[a]=t[r],e},{})},e.prototype.execute=function(e,t){return this.execute_(e,!1,t)},e.prototype.execute_=function(e,t,a){if(void 0===t&&(t=!0),a=a||this.outputNodes,(e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]||Array.isArray(e))&&(e=this.constructTensorMap(e)),this.executor.isControlFlowModel||this.executor.isDynamicShapeModel)throw new Error("The model contains control flow or dynamic shape ops, please use executeAsync method");var r=this.executor.execute(this.convertTensorMapToTensorsMap(e),t,a),n=Object.keys(r);return Array.isArray(a)&&a.length>1?a.map(function(e){return r[e]}):r[n[0]]},e.prototype.executeAsync=function(e,t){return __awaiter(this,void 0,void 0,function(){var a,r;return __generator(this,function(n){switch(n.label){case 0:if(!this.executor.isControlFlowModel&&!this.executor.isDynamicShapeModel)throw new Error("The model does not contain control flow or dynamic shape ops, please use execute method for better performance.");return t=t||this.outputNodes,(e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]||Array.isArray(e))&&(e=this.constructTensorMap(e)),[4,this.executor.executeAsync(this.convertTensorMapToTensorsMap(e),t)];case 1:return a=n.sent(),r=Object.keys(a),[2,Array.isArray(t)&&t.length>1?t.map(function(e){return a[e]}):a[r[0]]]}})})},e.prototype.convertTensorMapToTensorsMap=function(e){return Object.keys(e).reduce(function(t,a){return t[a]=[e[a]],t},{})},e.prototype.dispose=function(){this.executor.dispose()},e}();function loadGraphModel(e,t){return void 0===t&&(t={}),__awaiter(this,void 0,void 0,function(){var a;return __generator(this,function(r){switch(r.label){case 0:if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");return null==t&&(t={}),t.fromTFHub&&null==e.load&&(e.endsWith("/")||(e+="/"),e=""+e+DEFAULT_MODEL_NAME+TFHUB_SEARCH_PARAM),[4,(a=new GraphModel(e,t)).load()];case 1:return r.sent(),[2,a]}})})}var version="1.1.2";
//# sourceMappingURL=tf-converter.esm.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js ***!
  \****************************************************************/
/*! exports provided: AdadeltaOptimizer, AdagradOptimizer, AdamOptimizer, AdamaxOptimizer, DataStorage, ENV, Environment, KernelBackend, MomentumOptimizer, Optimizer, RMSPropOptimizer, Rank, Reduction, SGDOptimizer, Tensor, TensorBuffer, Variable, abs, acos, acosh, add, addN, addStrict, all, any, argMax, argMin, asin, asinh, atan, atan2, atanh, avgPool, backend, basicLSTMCell, batchNorm, batchNorm2d, batchNorm3d, batchNorm4d, batchNormalization, batchNormalization2d, batchNormalization3d, batchNormalization4d, batchToSpaceND, browser, buffer, cast, ceil, clipByValue, clone, complex, concat, concat1d, concat2d, concat3d, concat4d, conv1d, conv2d, conv2dDerFilter, conv2dTranspose, conv3d, cos, cosh, cumsum, customGrad, deprecationWarn, depthToSpace, depthwiseConv2d, disableDeprecationWarnings, dispose, disposeVariables, div, divStrict, dot, dropout, elu, enableDebugMode, enableProdMode, environment, equal, equalStrict, erf, exp, expandDims, expm1, eye, fft, fill, findBackend, findBackendFactory, floor, floorDiv, fused, gather, gatherND, getBackend, grad, grads, greater, greaterEqual, greaterEqualStrict, greaterStrict, hammingWindow, hannWindow, ifft, imag, image, io, irfft, isFinite, isInf, isNaN, keep, leakyRelu, less, lessEqual, lessEqualStrict, lessStrict, linalg, linspace, localResponseNormalization, log, log1p, logSigmoid, logSoftmax, logSumExp, logicalAnd, logicalNot, logicalOr, logicalXor, losses, matMul, math, max, maxPool, maximum, maximumStrict, mean, memory, min, minimum, minimumStrict, mod, modStrict, moments, movingAverage, mul, mulStrict, multiRNNCell, multinomial, neg, nextFrame, norm, notEqual, notEqualStrict, oneHot, ones, onesLike, op, outerProduct, pad, pad1d, pad2d, pad3d, pad4d, pool, pow, powStrict, prelu, print, prod, profile, rand, randomNormal, randomUniform, range, ready, real, reciprocal, registerBackend, relu, removeBackend, reshape, reverse, reverse1d, reverse2d, reverse3d, reverse4d, rfft, round, rsqrt, scalar, scatterND, selu, separableConv2d, serialization, setBackend, setdiff1dAsync, sigmoid, sign, sin, sinh, slice, slice1d, slice2d, slice3d, slice4d, softmax, softplus, spaceToBatchND, sparseToDense, spectral, split, sqrt, square, squaredDifference, squaredDifferenceStrict, squeeze, stack, step, stridedSlice, sub, subStrict, sum, tan, tanh, tensor, tensor1d, tensor2d, tensor3d, tensor4d, tensor5d, tensor6d, tensor_util, test_util, tidy, tile, time, topk, train, transpose, truncatedNormal, unsortedSegmentSum, unstack, util, valueAndGrad, valueAndGrads, variable, variableGrads, version_core, webgl, where, whereAsync, zeros, zerosLike */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process, global, Buffer, setImmediate) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdadeltaOptimizer", function() { return Ah; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdagradOptimizer", function() { return Th; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdamOptimizer", function() { return Dh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdamaxOptimizer", function() { return Oh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataStorage", function() { return Yn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENV", function() { return a; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Environment", function() { return i; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KernelBackend", function() { return Qn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MomentumOptimizer", function() { return Mh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Optimizer", function() { return Ih; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RMSPropOptimizer", function() { return Fh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rank", function() { return vt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Reduction", function() { return ql; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SGDOptimizer", function() { return _h; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tensor", function() { return ft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TensorBuffer", function() { return lt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Variable", function() { return dt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "abs", function() { return Vi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return Gi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acosh", function() { return qi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return qu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addN", function() { return Hu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addStrict", function() { return $u; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "all", function() { return bu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "any", function() { return Cu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "argMax", function() { return Eu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "argMin", function() { return Ru; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return Hi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asinh", function() { return $i; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return ji; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan2", function() { return ju; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atanh", function() { return Ki; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "avgPool", function() { return fu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backend", function() { return $e; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "basicLSTMCell", function() { return Al; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNorm", function() { return _s; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNorm2d", function() { return Ms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNorm3d", function() { return Fs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNorm4d", function() { return Bs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization", function() { return Os; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization2d", function() { return As; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization3d", function() { return Ts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchNormalization4d", function() { return Ds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchToSpaceND", function() { return Ir; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "browser", function() { return vh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return Nr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cast", function() { return Ar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return Xi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipByValue", function() { return Yi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return Tr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "complex", function() { return On; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return lr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat1d", function() { return cr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat2d", function() { return hr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat3d", function() { return pr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat4d", function() { return fr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv1d", function() { return Xs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv2d", function() { return Ys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv2dDerFilter", function() { return Js; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv2dTranspose", function() { return eu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conv3d", function() { return Qs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return Qi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cosh", function() { return Ji; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cumsum", function() { return Dr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "customGrad", function() { return kn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deprecationWarn", function() { return De; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "depthToSpace", function() { return Or; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "depthwiseConv2d", function() { return Zs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disableDeprecationWarnings", function() { return Te; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dispose", function() { return Be; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disposeVariables", function() { return Oe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return Ku; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divStrict", function() { return Xu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return ru; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dropout", function() { return Vl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elu", function() { return gl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableDebugMode", function() { return Ae; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableProdMode", function() { return Ie; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "environment", function() { return l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equal", function() { return Ou; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equalStrict", function() { return _u; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "erf", function() { return Zi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return ts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expandDims", function() { return _r; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expm1", function() { return es; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eye", function() { return Mr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fft", function() { return Fl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fill", function() { return Hn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findBackend", function() { return Ge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findBackendFactory", function() { return qe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return ns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floorDiv", function() { return Yu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fused", function() { return vc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gather", function() { return kl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gatherND", function() { return zl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBackend", function() { return ze; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "grad", function() { return Cn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "grads", function() { return En; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greater", function() { return Mu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterEqual", function() { return Fu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterEqualStrict", function() { return Bu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterStrict", function() { return Pu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hammingWindow", function() { return $l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hannWindow", function() { return Hl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ifft", function() { return Bl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "imag", function() { return Mn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "image", function() { return fc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "io", function() { return hh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "irfft", function() { return Ll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFinite", function() { return ds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isInf", function() { return fs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNaN", function() { return ps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keep", function() { return Pe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "leakyRelu", function() { return yl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "less", function() { return Lu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessEqual", function() { return Wu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessEqualStrict", function() { return Uu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessStrict", function() { return zu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linalg", function() { return ic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linspace", function() { return $n; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "localResponseNormalization", function() { return El; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return rs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log1p", function() { return os; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logSigmoid", function() { return as; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logSoftmax", function() { return Dn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logSumExp", function() { return Su; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalAnd", function() { return hl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalNot", function() { return pl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalOr", function() { return fl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logicalXor", function() { return dl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "losses", function() { return nc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matMul", function() { return nu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "math", function() { return fh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return Nu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maxPool", function() { return pu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maximum", function() { return Qu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maximumStrict", function() { return Ju; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mean", function() { return ku; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "memory", function() { return _e; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return Iu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minimum", function() { return Zu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minimumStrict", function() { return tl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mod", function() { return el; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modStrict", function() { return nl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "moments", function() { return Au; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "movingAverage", function() { return Dl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return rl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mulStrict", function() { return ol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiRNNCell", function() { return Tl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multinomial", function() { return Fr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "neg", function() { return is; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nextFrame", function() { return Wh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "norm", function() { return Rl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notEqual", function() { return Vu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notEqualStrict", function() { return Gu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "oneHot", function() { return Br; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ones", function() { return Gn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onesLike", function() { return Kn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "op", function() { return An; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outerProduct", function() { return ou; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad", function() { return Pr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad1d", function() { return Lr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad2d", function() { return Wr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad3d", function() { return Ur; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pad4d", function() { return zr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pool", function() { return du; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return al; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "powStrict", function() { return il; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prelu", function() { return xl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "print", function() { return kr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prod", function() { return Du; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "profile", function() { return Me; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rand", function() { return Vr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomNormal", function() { return Gr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomUniform", function() { return qr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return jn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ready", function() { return Ue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "real", function() { return _n; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reciprocal", function() { return ss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerBackend", function() { return He; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "relu", function() { return wl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeBackend", function() { return Ve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reshape", function() { return Hr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse", function() { return au; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse1d", function() { return iu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse2d", function() { return su; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse3d", function() { return uu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse4d", function() { return lu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rfft", function() { return Pl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return us; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rsqrt", function() { return ls; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scalar", function() { return Bn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scatterND", function() { return Ml; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "selu", function() { return bl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "separableConv2d", function() { return tu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "serialization", function() { return xh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setBackend", function() { return We; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setdiff1dAsync", function() { return Jr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sigmoid", function() { return cs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sign", function() { return hs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return vs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinh", function() { return ms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return vu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice1d", function() { return mu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice2d", function() { return gu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice3d", function() { return yu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice4d", function() { return xu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "softmax", function() { return Tn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "softplus", function() { return gs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spaceToBatchND", function() { return $r; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sparseToDense", function() { return Ul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spectral", function() { return Wl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "split", function() { return dr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return ys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "square", function() { return xs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDifference", function() { return sl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDifferenceStrict", function() { return ul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squeeze", function() { return jr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stack", function() { return Kr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "step", function() { return ws; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stridedSlice", function() { return Ol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return ll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subStrict", function() { return cl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return Tu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return bs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tanh", function() { return Cs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor", function() { return Fn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor1d", function() { return Pn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor2d", function() { return Ln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor3d", function() { return Wn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor4d", function() { return Un; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor5d", function() { return zn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor6d", function() { return Vn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tensor_util", function() { return It; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "test_util", function() { return Sh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tidy", function() { return Fe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tile", function() { return Xr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "time", function() { return Le; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "topk", function() { return _l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "train", function() { return Ph; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return Cl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "truncatedNormal", function() { return Yr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unsortedSegmentSum", function() { return Il; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstack", function() { return Qr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "util", function() { return Z; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "valueAndGrad", function() { return Rn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "valueAndGrads", function() { return Sn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "variable", function() { return wt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "variableGrads", function() { return Nn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version_core", function() { return Nh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "webgl", function() { return kh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "where", function() { return vl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "whereAsync", function() { return ml; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zeros", function() { return qn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zerosLike", function() { return Xn; });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var t=function(e,n){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])})(e,n)};function e(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}var n=function(){return(n=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var o in e=arguments[n])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t}).apply(this,arguments)};function r(t,e,n,r){return new(n||(n=Promise))(function(o,a){function i(t){try{u(r.next(t))}catch(t){a(t)}}function s(t){try{u(r.throw(t))}catch(t){a(t)}}function u(t){t.done?o(t.value):new n(function(e){e(t.value)}).then(i,s)}u((r=r.apply(t,e||[])).next())})}function o(t,e){var n,r,o,a,i={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return a={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function s(a){return function(s){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,r&&(o=2&a[0]?r.return:a[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,a[1])).done)return o;switch(r=0,o&&(a=[2&a[0],o.value]),a[0]){case 0:case 1:o=a;break;case 4:return i.label++,{value:a[1],done:!1};case 5:i.label++,r=a[1],a=[0];continue;case 7:a=i.ops.pop(),i.trys.pop();continue;default:if(!(o=(o=i.trys).length>0&&o[o.length-1])&&(6===a[0]||2===a[0])){i=0;continue}if(3===a[0]&&(!o||a[1]>o[0]&&a[1]<o[3])){i.label=a[1];break}if(6===a[0]&&i.label<o[1]){i.label=o[1],o=a;break}if(o&&i.label<o[2]){i.label=o[2],i.ops.push(a);break}o[2]&&i.ops.pop(),i.trys.pop();continue}a=e.call(t,i)}catch(t){a=[6,t],r=0}finally{n=o=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,s])}}}var a,i=function(){function t(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}return t.prototype.registerFlag=function(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){var r=this.urlFlags[t];console.warn("Setting feature override from URL "+t+": "+r+"."),this.set(t,r)}},t.prototype.get=function(t){return t in this.flags?this.flags[t]:(this.flags[t]=this.evaluateFlag(t),this.flags[t])},t.prototype.getNumber=function(t){return this.get(t)},t.prototype.getBool=function(t){return this.get(t)},t.prototype.getFlags=function(){return this.flags},Object.defineProperty(t.prototype,"features",{get:function(){return this.flags},enumerable:!0,configurable:!0}),t.prototype.set=function(t,e){if(null==this.flagRegistry[t])throw new Error("Cannot set flag "+t+" as it has not been registered.");this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)},t.prototype.evaluateFlag=function(t){if(null==this.flagRegistry[t])throw new Error("Cannot evaluate flag '"+t+"': no evaluation function found.");return this.flagRegistry[t].evaluationFn()},t.prototype.setFlags=function(t){this.flags=Object.assign({},t)},t.prototype.reset=function(){this.flags={},this.urlFlags={},this.populateURLFlags()},t.prototype.populateURLFlags=function(){var t=this;if(void 0!==this.global&&void 0!==this.global.location&&void 0!==this.global.location.search){var e=s(this.global.location.search);if("tfjsflags"in e)e.tfjsflags.split(",").forEach(function(e){var n=e.split(":"),r=n[0],o=n[1];t.urlFlags[r]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error("Could not parse value flag value "+e+" for flag "+t+".")}(r,o)})}},t}();function s(t){var e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,function(t){for(var n=[],r=1;r<arguments.length;r++)n[r-1]=arguments[r];return function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("=")}),e}function u(t){a=t}var l=Object.freeze({Environment:i,getQueryParams:s,get ENV(){return a},setEnvironmentGlobal:u});function c(t){for(var e=t.length,n=0,r=0;e>0;)r=Math.random()*e|0,n=t[--e],t[e]=t[r],t[r]=n}function h(t,e,n){return Math.max(t,Math.min(e,n))}function p(t){return t%2==0?t:t+1}function f(t){for(var e=0,n=0;n<t.length;n++)e+=t[n];return e}function d(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function v(t,e,n){void 0===n&&(n=""),d(x(t,e),function(){return n+" Shapes "+t+" and "+e+" must match"})}function m(t){d(null!=t,function(){return"The input to the tensor constructor must be a non-null value."})}function g(t,e){if(void 0===e&&(e=[]),null==e&&(e=[]),Array.isArray(t)||_(t))for(var n=0;n<t.length;++n)g(t[n],e);else e.push(t);return e}function y(t){if(0===t.length)return 1;for(var e=t[0],n=1;n<t.length;n++)e*=t[n];return e}function x(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(var n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function w(t){return t%1==0}function b(t){if(null!=Math.tanh)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;var e=Math.exp(2*t);return(e-1)/(e+1)}function C(t){var e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function E(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function R(t,e,n){return void 0===e&&(e=function(t){return 0}),new Promise(function(r,o){var a=0,i=function(){if(t())r();else{var s=e(++a);null!=n&&a>=n?o():setTimeout(i,s)}};i()})}function S(t,e){for(var n=1,r=-1,o=0;o<t.length;++o)if(t[o]>=0)n*=t[o];else if(-1===t[o]){if(-1!==r)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+r+" and dim "+o);r=o}else if(t[o]<0)throw Error("Shapes can not be < 0. Found "+t[o]+" at dim "+o);if(-1===r){if(e>0&&e!==n)throw Error("Size("+e+") must match the product of shape "+t);return t}if(0===n)throw Error("Cannot infer the missing size in ["+t+"] when there are 0 elements");if(e%n!=0)throw Error("The implicit shape can't be a fractional number. Got "+e+" / "+n);var a=t.slice();return a[r]=e/n,a}function N(t,e){var n=e.length;return d((t=null==t?e.map(function(t,e){return e}):[].concat(t)).every(function(t){return t>=-n&&t<n}),function(){return"All values in axis param must be in range [-"+n+", "+n+") but got axis "+t}),d(t.every(function(t){return w(t)}),function(){return"All values in axis param must be integers but got axis "+t}),t.map(function(t){return t<0?n+t:t})}function k(t,e){for(var n=[],r=[],o=null==e?null:N(e,t).sort(),a=0,i=0;i<t.length;++i){if(null!=o){if(o[a]===i&&1!==t[i])throw new Error("Can't squeeze axis "+i+" since its dim '"+t[i]+"' is not 1");(null==o[a]||o[a]>i)&&1===t[i]&&(n.push(t[i]),r.push(i)),o[a]<=i&&a++}1!==t[i]&&(n.push(t[i]),r.push(i))}return{newShape:n,keptDims:r}}function I(t,e){var n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else{if("bool"!==t)throw new Error("Unknown data type "+t);n=new Uint8Array(e)}return n}function A(t,e){var n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error("Unknown data type "+t);n=new Array(e)}return n}function T(t,e,n){if("float32"===e)for(var r=0;r<t.length;r++){var o=t[r];if(isNaN(o)||!isFinite(o))throw Error("The result of the '"+n+"' is "+o+".")}}function D(t,e){for(var n=0;n<t.length;n++){var r=t[n];if(isNaN(r)||!isFinite(r))throw Error("A tensor of type "+e+" being uploaded contains "+r+".")}}function O(t,e){return"complex64"!==e&&(("float32"!==e||"complex64"===t)&&(("int32"!==e||"float32"===t||"complex64"===t)&&("bool"!==e||"bool"!==t)))}function _(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function M(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error("Unknown dtype "+t)}function F(t){if(null==t)return 0;var e=0;return t.forEach(function(t){return e+=2*t.length}),e}function B(t){return"string"==typeof t||t instanceof String}function P(t){return"boolean"==typeof t}function L(t){return"number"==typeof t}function W(t){return Array.isArray(t)?W(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":L(t)?"float32":B(t)?"string":P(t)?"bool":"float32"}function U(t){return!!(t&&t.constructor&&t.call&&t.apply)}function z(t,e){for(var n=e;n<t;++n)if(t%n==0)return n;return t}function V(t){var e=t.length;if(e<2)return[];var n=new Array(e-1);n[e-2]=t[e-1];for(var r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function G(t,e,n){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=g(t)),n&&D(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){for(var r=new Uint8Array(t.length),o=0;o<r.length;++o)0!==Math.round(t[o])&&(r[o]=1);return r}throw new Error("Unknown data type "+e)}function q(t,e){if(0===t.length)return e[0];var n=t.reduce(function(t,e){return t*e});if(0===n)return[];if(n!==e.length)throw new Error("["+t+"] does not match the input size.");return function t(e,n,r){var o=new Array;if(1===n.length)for(var a=n[0],i=0;i<a;i++)o[i]=r[e+i];else{a=n[0];var s=n.slice(1),u=s.reduce(function(t,e){return t*e});for(i=0;i<a;i++)o[i]=t(e+i*u,s,r)}return o}(0,t,e)}function H(t,e){for(var n=$(t,e),r=0;r<n.length;r++)n[r]=1;return n}function $(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error("Unknown data type "+e)}function j(){if("undefined"!=typeof performance)return performance.now();if("undefined"!=typeof process){var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}throw new Error("Cannot measure time in this environment. You should run tf.js in the browser or in Node.js")}function K(t){t.forEach(function(e){d(Number.isInteger(e)&&e>=0,function(){return"Tensor must have a shape comprised of positive integers but got shape ["+t+"]."})})}var X,Y=function(){if(null!=a.global.fetch)return a.global.fetch;if(a.get("IS_NODE"))return Q.fetchImport();throw new Error("Unable to find the fetch() method. Please add your own fetch() function to the global namespace.")},Q={fetchImport:function(){return __webpack_require__(/*! node-fetch */ 0)}};function J(t,e){return null==X&&(X=Y()),X(t,e)}var Z=Object.freeze({shuffle:c,clamp:h,nearestLargerEven:p,sum:f,randUniform:function(t,e){var n=Math.random();return e*n+(1-n)*t},distSquared:function(t,e){for(var n=0,r=0;r<t.length;r++){var o=Number(t[r])-Number(e[r]);n+=o*o}return n},assert:d,assertShapesMatch:v,assertNonNull:m,flatten:g,sizeFromShape:y,isScalarShape:function(t){return 0===t.length},arraysEqual:x,isInt:w,tanh:b,sizeToSquarishShape:C,createShuffledIndices:function(t){for(var e=new Uint32Array(t),n=0;n<t;++n)e[n]=n;return c(e),e},rightPad:E,repeatedTry:R,inferFromImplicitShape:S,parseAxisParam:N,squeezeShape:k,getTypedArrayFromDType:I,getArrayFromDType:A,checkComputationForErrors:T,checkConversionForErrors:D,hasEncodingLoss:O,isTypedArray:_,bytesPerElement:M,bytesFromStringArray:F,isString:B,isBoolean:P,isNumber:L,inferDtype:W,isFunction:U,nearestDivisor:z,computeStrides:V,toTypedArray:G,toNestedArray:q,makeOnesTypedArray:H,makeZerosTypedArray:$,now:j,assertNonNegativeIntegerDimensions:K,getNodeFetch:Q,get systemFetch(){return X},fetch:J}),tt=function(){function t(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new et)}return t.prototype.profileKernel=function(t,e){var n,r=this,o=this.backendTimer.time(function(){n=e()});return(Array.isArray(n)?n:[n]).forEach(function(e){var n=e.dataSync();T(n,e.dtype,t),o.then(function(o){var a="";null!=o.getExtraProfileInfo&&(a=o.getExtraProfileInfo()),r.logger.logKernelProfile(t,e,n,o.kernelMs,a)})}),n},t}(),et=function(){function t(){}return t.prototype.logKernelProfile=function(t,e,n,r,o){var a=E(r+"ms",9),i=E(t,25),s=e.rank,u=e.size,l=E(e.shape.toString(),14);console.log("%c"+i+"\t%c"+a+"\t%c"+s+"D "+l+"\t%c"+u+"\t%c"+o,"font-weight:bold","color:red","color:blue","color: orange","color: green")},t}(),nt=20,rt=3,ot=7;function at(t,e,n,r){var o=V(e),a=function(t,e,n,r){var o=y(e),a=r[r.length-1],i=new Array(a).fill(0),s=e.length,u="complex64"===n?ut(t):t;if(s>1)for(var l=0;l<o/a;l++)for(var c=l*a,h=0;h<a;h++)i[h]=Math.max(i[h],it(u[c+h],0,n).length);return i}(t,e,n,o),i=e.length,s=function t(e,n,r,o,a,i){void 0===i&&(i=!0);var s="complex64"===r?2:1;var u=n[0];var l=n.length;if(0===l){if("complex64"===r){var c=ut(e);return[it(c[0],0,r)]}return"bool"===r?[st(e[0])]:[e[0].toString()]}if(1===l){if(u>nt){var h=rt*s,p=Array.from(e.slice(0,h)),f=Array.from(e.slice(u-rt*s,u));return"complex64"===r&&(p=ut(p),f=ut(f)),["["+p.map(function(t,e){return it(t,a[e],r)}).join(", ")+", ..., "+f.map(function(t,e){return it(t,a[u-rt+e],r)}).join(", ")+"]"]}var d="complex64"===r?ut(e):Array.from(e);return["["+d.map(function(t,e){return it(t,a[e],r)}).join(", ")+"]"]}var v=n.slice(1);var m=o.slice(1);var g=o[0]*s;var y=[];if(u>nt){for(var x=0;x<rt;x++){var w=x*g,b=w+g;y.push.apply(y,t(e.slice(w,b),v,r,m,a,!1))}y.push("...");for(var x=u-rt;x<u;x++){var w=x*g,b=w+g;y.push.apply(y,t(e.slice(w,b),v,r,m,a,x===u-1))}}else for(var x=0;x<u;x++){var w=x*g,b=w+g;y.push.apply(y,t(e.slice(w,b),v,r,m,a,x===u-1))}var C=2===l?",":"";y[0]="["+y[0]+C;for(var x=1;x<y.length-1;x++)y[x]=" "+y[x]+C;var E=",\n";for(var x=2;x<l;x++)E+="\n";y[y.length-1]=" "+y[y.length-1]+"]"+(i?"":E);return y}(t,e,n,o,a),u=["Tensor"];return r&&(u.push("  dtype: "+n),u.push("  rank: "+i),u.push("  shape: ["+e+"]"),u.push("  values:")),u.push(s.map(function(t){return"    "+t}).join("\n")),u.join("\n")}function it(t,e,n){return E(Array.isArray(t)?parseFloat(t[0].toFixed(ot))+" + "+parseFloat(t[1].toFixed(ot))+"j":B(t)?"'"+t+"'":"bool"===n?st(t):parseFloat(t.toFixed(ot)).toString(),e)}function st(t){return 0===t?"false":"true"}function ut(t){for(var e=[],n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}var lt=function(){function t(t,e,n){var r=this;if(this.dtype=e,this.shape=t.slice(),this.size=y(t),null!=n){var o=n.length;d(o===this.size,function(){return"Length of values '"+o+"' does not match the size inferred by the shape '"+r.size+"'."})}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||A(e,this.size),this.strides=V(t)}return t.prototype.set=function(t){for(var e=this,n=[],r=1;r<arguments.length;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),d(n.length===this.rank,function(){return"The number of provided coordinates ("+n.length+") must match the rank ("+e.rank+")"});var o=this.locToIndex(n);this.values[o]=t},t.prototype.get=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];0===t.length&&(t=[0]);for(var n=0,r=0,o=t;r<o.length;r++){var a=o[r];if(a<0||a>=this.shape[n]){var i="Requested out of range element at "+t+".   Buffer shape="+this.shape;throw new Error(i)}n++}for(var s=t[t.length-1],u=0;u<t.length-1;++u)s+=this.strides[u]*t[u];return this.values[s]},t.prototype.locToIndex=function(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];for(var e=t[t.length-1],n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e},t.prototype.indexToLoc=function(t){if(0===this.rank)return[];if(1===this.rank)return[t];for(var e=new Array(this.shape.length),n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e},Object.defineProperty(t.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),t.prototype.toTensor=function(){return ft.make(this.shape,{values:this.values},this.dtype)},t}(),ct=null,ht=null,pt=null;var ft=function(){function t(t,e,n,r,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=y(t),this.strides=V(t),this.dataId=null!=r?r:{},this.id=ct().nextTensorId(),this.rankType=this.rank<5?this.rank.toString():"higher",ct().registerTensor(this,o),null!=n&&ct().write(this.dataId,n)}return t.make=function(e,n,r,o){return new t(e,r,n.values,n.dataId,o)},t.prototype.flatten=function(){return this.throwIfDisposed(),this.as1D()},t.prototype.asScalar=function(){return this.throwIfDisposed(),d(1===this.size,function(){return"The array must have only 1 element."}),this.reshape([])},t.prototype.as1D=function(){return this.throwIfDisposed(),this.reshape([this.size])},t.prototype.as2D=function(t,e){return this.throwIfDisposed(),this.reshape([t,e])},t.prototype.as3D=function(t,e,n){return this.throwIfDisposed(),this.reshape([t,e,n])},t.prototype.as4D=function(t,e,n,r){return this.throwIfDisposed(),this.reshape([t,e,n,r])},t.prototype.as5D=function(t,e,n,r,o){return this.throwIfDisposed(),this.reshape([t,e,n,r,o])},t.prototype.asType=function(t){return this.throwIfDisposed(),ht.cast(this,t)},Object.defineProperty(t.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),t.prototype.buffer=function(){return r(this,void 0,void 0,function(){var t;return o(this,function(e){switch(e.label){case 0:return[4,this.data()];case 1:return t=e.sent(),[2,ht.buffer(this.shape,this.dtype,t)]}})})},t.prototype.bufferSync=function(){return ht.buffer(this.shape,this.dtype,this.dataSync())},t.prototype.array=function(){return r(this,void 0,void 0,function(){var t;return o(this,function(e){switch(e.label){case 0:return[4,this.data()];case 1:return t=e.sent(),[2,q(this.shape,t)]}})})},t.prototype.arraySync=function(){return q(this.shape,this.dataSync())},t.prototype.data=function(){return r(this,void 0,void 0,function(){return o(this,function(t){return this.throwIfDisposed(),[2,ct().read(this.dataId)]})})},t.prototype.dataSync=function(){return this.throwIfDisposed(),ct().readSync(this.dataId)},t.prototype.dispose=function(){this.isDisposed||(ct().disposeTensor(this),this.isDisposedInternal=!0)},Object.defineProperty(t.prototype,"isDisposed",{get:function(){return this.isDisposedInternal},enumerable:!0,configurable:!0}),t.prototype.throwIfDisposed=function(){if(this.isDisposed)throw new Error("Tensor is disposed.")},t.prototype.toFloat=function(){return this.asType("float32")},t.prototype.toInt=function(){return this.asType("int32")},t.prototype.toBool=function(){return this.asType("bool")},t.prototype.print=function(t){return void 0===t&&(t=!1),ht.print(this,t)},t.prototype.reshape=function(t){return this.throwIfDisposed(),ht.reshape(this,t)},t.prototype.reshapeAs=function(t){return this.throwIfDisposed(),this.reshape(t.shape)},t.prototype.expandDims=function(t){return void 0===t&&(t=0),ht.expandDims(this,t)},t.prototype.cumsum=function(t,e,n){return void 0===t&&(t=0),void 0===e&&(e=!1),void 0===n&&(n=!1),ht.cumsum(this,t,e,n)},t.prototype.squeeze=function(t){return this.throwIfDisposed(),ht.squeeze(this,t)},t.prototype.clone=function(){return this.throwIfDisposed(),ht.clone(this)},t.prototype.oneHot=function(t,e,n){return this.throwIfDisposed(),ht.oneHot(this,t,e,n)},t.prototype.toString=function(t){return void 0===t&&(t=!1),at(this.dataSync(),this.shape,this.dtype,t)},t.prototype.tile=function(t){return this.throwIfDisposed(),ht.tile(this,t)},t.prototype.gather=function(t,e){return void 0===e&&(e=0),this.throwIfDisposed(),ht.gather(this,t,e)},t.prototype.matMul=function(t,e,n){return void 0===e&&(e=!1),void 0===n&&(n=!1),this.throwIfDisposed(),ht.matMul(this,t,e,n)},t.prototype.dot=function(t){return this.throwIfDisposed(),ht.dot(this,t)},t.prototype.norm=function(t,e,n){return void 0===t&&(t="euclidean"),void 0===e&&(e=null),void 0===n&&(n=!1),this.throwIfDisposed(),ht.norm(this,t,e,n)},t.prototype.slice=function(t,e){return this.throwIfDisposed(),ht.slice(this,t,e)},t.prototype.reverse=function(t){return this.throwIfDisposed(),ht.reverse(this,t)},t.prototype.concat=function(e,n){return void 0===n&&(n=0),this.throwIfDisposed(),e instanceof t&&(e=[e]),ht.concat([this].concat(e),n)},t.prototype.split=function(t,e){return void 0===e&&(e=0),this.throwIfDisposed(),ht.split(this,t,e)},t.prototype.stack=function(t,e){return void 0===e&&(e=0),ht.stack([this,t],e)},t.prototype.unstack=function(t){return void 0===t&&(t=0),ht.unstack(this,t)},t.prototype.pad=function(t,e){return void 0===e&&(e=0),ht.pad(this,t,e)},t.prototype.batchNormalization=function(t,e,n,r,o){return void 0===n&&(n=.001),pt("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"),this.batchNorm(t,e,o,r,n)},t.prototype.batchNorm=function(t,e,n,r,o){return void 0===o&&(o=.001),this.throwIfDisposed(),ht.batchNorm(this,t,e,n,r,o)},t.prototype.all=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.all(this,t,e)},t.prototype.any=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.any(this,t,e)},t.prototype.logSumExp=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.logSumExp(this,t,e)},t.prototype.sum=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.sum(this,t,e)},t.prototype.prod=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.prod(this,t,e)},t.prototype.mean=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.mean(this,t,e)},t.prototype.min=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.min(this,t,e)},t.prototype.max=function(t,e){return void 0===t&&(t=null),void 0===e&&(e=!1),this.throwIfDisposed(),ht.max(this,t,e)},t.prototype.argMin=function(t){return void 0===t&&(t=null),this.throwIfDisposed(),ht.argMin(this,t)},t.prototype.argMax=function(t){return void 0===t&&(t=null),this.throwIfDisposed(),ht.argMax(this,t)},t.prototype.cast=function(t){return this.throwIfDisposed(),ht.cast(this,t)},t.prototype.add=function(t){return this.throwIfDisposed(),ht.add(this,t)},t.prototype.addStrict=function(t){return this.throwIfDisposed(),ht.addStrict(this,t)},t.prototype.atan2=function(t){return this.throwIfDisposed(),ht.atan2(this,t)},t.prototype.sub=function(t){return this.throwIfDisposed(),ht.sub(this,t)},t.prototype.subStrict=function(t){return this.throwIfDisposed(),ht.subStrict(this,t)},t.prototype.pow=function(t){return this.throwIfDisposed(),ht.pow(this,t)},t.prototype.powStrict=function(t){return this.throwIfDisposed(),ht.powStrict(this,t)},t.prototype.mul=function(t){return this.throwIfDisposed(),ht.mul(this,t)},t.prototype.mulStrict=function(t){return this.throwIfDisposed(),ht.mulStrict(this,t)},t.prototype.div=function(t){return this.throwIfDisposed(),ht.div(this,t)},t.prototype.floorDiv=function(t){return this.throwIfDisposed(),ht.floorDiv(this,t)},t.prototype.divStrict=function(t){return this.throwIfDisposed(),ht.divStrict(this,t)},t.prototype.minimum=function(t){return this.throwIfDisposed(),ht.minimum(this,t)},t.prototype.minimumStrict=function(t){return this.throwIfDisposed(),ht.minimumStrict(this,t)},t.prototype.maximum=function(t){return this.throwIfDisposed(),ht.maximum(this,t)},t.prototype.maximumStrict=function(t){return this.throwIfDisposed(),ht.maximumStrict(this,t)},t.prototype.mod=function(t){return this.throwIfDisposed(),ht.mod(this,t)},t.prototype.modStrict=function(t){return this.throwIfDisposed(),ht.modStrict(this,t)},t.prototype.squaredDifference=function(t){return this.throwIfDisposed(),ht.squaredDifference(this,t)},t.prototype.squaredDifferenceStrict=function(t){return this.throwIfDisposed(),ht.squaredDifferenceStrict(this,t)},t.prototype.transpose=function(t){return this.throwIfDisposed(),ht.transpose(this,t)},t.prototype.notEqual=function(t){return this.throwIfDisposed(),ht.notEqual(this,t)},t.prototype.notEqualStrict=function(t){return this.throwIfDisposed(),ht.notEqualStrict(this,t)},t.prototype.less=function(t){return this.throwIfDisposed(),ht.less(this,t)},t.prototype.lessStrict=function(t){return this.throwIfDisposed(),ht.lessStrict(this,t)},t.prototype.equal=function(t){return this.throwIfDisposed(),ht.equal(this,t)},t.prototype.equalStrict=function(t){return this.throwIfDisposed(),ht.equalStrict(this,t)},t.prototype.lessEqual=function(t){return this.throwIfDisposed(),ht.lessEqual(this,t)},t.prototype.lessEqualStrict=function(t){return this.throwIfDisposed(),ht.lessEqualStrict(this,t)},t.prototype.greater=function(t){return this.throwIfDisposed(),ht.greater(this,t)},t.prototype.greaterStrict=function(t){return this.throwIfDisposed(),ht.greaterStrict(this,t)},t.prototype.greaterEqual=function(t){return this.throwIfDisposed(),ht.greaterEqual(this,t)},t.prototype.greaterEqualStrict=function(t){return this.throwIfDisposed(),ht.greaterEqualStrict(this,t)},t.prototype.logicalAnd=function(t){return this.throwIfDisposed(),ht.logicalAnd(this,t)},t.prototype.logicalOr=function(t){return this.throwIfDisposed(),ht.logicalOr(this,t)},t.prototype.logicalNot=function(){return this.throwIfDisposed(),ht.logicalNot(this)},t.prototype.logicalXor=function(t){return this.throwIfDisposed(),ht.logicalXor(this,t)},t.prototype.where=function(t,e){return this.throwIfDisposed(),ht.where(t,this,e)},t.prototype.neg=function(){return this.throwIfDisposed(),ht.neg(this)},t.prototype.ceil=function(){return this.throwIfDisposed(),ht.ceil(this)},t.prototype.floor=function(){return this.throwIfDisposed(),ht.floor(this)},t.prototype.sign=function(){return this.throwIfDisposed(),ht.sign(this)},t.prototype.isNaN=function(){return this.throwIfDisposed(),ht.isNaN(this)},t.prototype.isInf=function(){return this.throwIfDisposed(),ht.isInf(this)},t.prototype.isFinite=function(){return this.throwIfDisposed(),ht.isFinite(this)},t.prototype.exp=function(){return this.throwIfDisposed(),ht.exp(this)},t.prototype.expm1=function(){return this.throwIfDisposed(),ht.expm1(this)},t.prototype.log=function(){return this.throwIfDisposed(),ht.log(this)},t.prototype.log1p=function(){return this.throwIfDisposed(),ht.log1p(this)},t.prototype.sqrt=function(){return this.throwIfDisposed(),ht.sqrt(this)},t.prototype.rsqrt=function(){return this.throwIfDisposed(),ht.rsqrt(this)},t.prototype.square=function(){return this.throwIfDisposed(),ht.square(this)},t.prototype.reciprocal=function(){return this.throwIfDisposed(),ht.reciprocal(this)},t.prototype.abs=function(){return this.throwIfDisposed(),ht.abs(this)},t.prototype.clipByValue=function(t,e){return this.throwIfDisposed(),ht.clipByValue(this,t,e)},t.prototype.relu=function(){return this.throwIfDisposed(),ht.relu(this)},t.prototype.elu=function(){return this.throwIfDisposed(),ht.elu(this)},t.prototype.selu=function(){return this.throwIfDisposed(),ht.selu(this)},t.prototype.leakyRelu=function(t){return void 0===t&&(t=.2),this.throwIfDisposed(),ht.leakyRelu(this,t)},t.prototype.prelu=function(t){return this.throwIfDisposed(),ht.prelu(this,t)},t.prototype.sigmoid=function(){return this.throwIfDisposed(),ht.sigmoid(this)},t.prototype.logSigmoid=function(){return this.throwIfDisposed(),ht.logSigmoid(this)},t.prototype.softplus=function(){return this.throwIfDisposed(),ht.softplus(this)},t.prototype.zerosLike=function(){return this.throwIfDisposed(),ht.zerosLike(this)},t.prototype.onesLike=function(){return this.throwIfDisposed(),ht.onesLike(this)},t.prototype.sin=function(){return this.throwIfDisposed(),ht.sin(this)},t.prototype.cos=function(){return this.throwIfDisposed(),ht.cos(this)},t.prototype.tan=function(){return this.throwIfDisposed(),ht.tan(this)},t.prototype.asin=function(){return this.throwIfDisposed(),ht.asin(this)},t.prototype.acos=function(){return this.throwIfDisposed(),ht.acos(this)},t.prototype.atan=function(){return this.throwIfDisposed(),ht.atan(this)},t.prototype.sinh=function(){return this.throwIfDisposed(),ht.sinh(this)},t.prototype.cosh=function(){return this.throwIfDisposed(),ht.cosh(this)},t.prototype.tanh=function(){return this.throwIfDisposed(),ht.tanh(this)},t.prototype.asinh=function(){return this.throwIfDisposed(),ht.asinh(this)},t.prototype.acosh=function(){return this.throwIfDisposed(),ht.acosh(this)},t.prototype.atanh=function(){return this.throwIfDisposed(),ht.atanh(this)},t.prototype.erf=function(){return this.throwIfDisposed(),ht.erf(this)},t.prototype.round=function(){return this.throwIfDisposed(),ht.round(this)},t.prototype.step=function(t){return void 0===t&&(t=0),this.throwIfDisposed(),ht.step(this,t)},t.prototype.softmax=function(t){return void 0===t&&(t=-1),this.throwIfDisposed(),ht.softmax(this,t)},t.prototype.logSoftmax=function(t){return void 0===t&&(t=-1),this.throwIfDisposed(),ht.logSoftmax(this,t)},t.prototype.resizeBilinear=function(t,e){return void 0===e&&(e=!1),this.throwIfDisposed(),ht.image.resizeBilinear(this,t,e)},t.prototype.resizeNearestNeighbor=function(t,e){return void 0===e&&(e=!1),this.throwIfDisposed(),ht.image.resizeNearestNeighbor(this,t,e)},t.prototype.conv1d=function(t,e,n,r,o,a){return void 0===r&&(r="NWC"),void 0===o&&(o=1),this.throwIfDisposed(),ht.conv1d(this,t,e,n,r,o,a)},t.prototype.conv2d=function(t,e,n,r,o,a){return void 0===r&&(r="NHWC"),void 0===o&&(o=[1,1]),this.throwIfDisposed(),ht.conv2d(this,t,e,n,r,o,a)},t.prototype.conv2dTranspose=function(t,e,n,r,o){return this.throwIfDisposed(),ht.conv2dTranspose(this,t,e,n,r,o)},t.prototype.depthwiseConv2D=function(t,e,n,r,o,a){return void 0===r&&(r="NHWC"),void 0===o&&(o=[1,1]),this.throwIfDisposed(),ht.depthwiseConv2d(this,t,e,n,r,o,a)},t.prototype.separableConv2d=function(t,e,n,r,o,a){return void 0===o&&(o=[1,1]),void 0===a&&(a="NHWC"),this.throwIfDisposed(),ht.separableConv2d(this,t,e,n,r,o,a)},t.prototype.avgPool=function(t,e,n,r){return this.throwIfDisposed(),ht.avgPool(this,t,e,n,r)},t.prototype.maxPool=function(t,e,n,r){return this.throwIfDisposed(),ht.maxPool(this,t,e,n,r)},t.prototype.localResponseNormalization=function(t,e,n,r){return void 0===t&&(t=5),void 0===e&&(e=1),void 0===n&&(n=1),void 0===r&&(r=.5),ht.localResponseNormalization(this,t,e,n,r)},t.prototype.pool=function(t,e,n,r,o){return this.throwIfDisposed(),ht.pool(this,t,e,n,r,o)},t.prototype.variable=function(t,e,n){return void 0===t&&(t=!0),this.throwIfDisposed(),dt.variable(this,t,e,n)},t.prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),ht.unsortedSegmentSum(this,t,e)},t.prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),ht.batchToSpaceND(this,t,e)},t.prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),ht.spaceToBatchND(this,t,e)},t.prototype.topk=function(t,e){return void 0===t&&(t=1),void 0===e&&(e=!0),this.throwIfDisposed(),ht.topk(this,t,e)},t.prototype.stridedSlice=function(t,e,n,r,o,a,i,s){return void 0===r&&(r=0),void 0===o&&(o=0),void 0===a&&(a=0),void 0===i&&(i=0),void 0===s&&(s=0),this.throwIfDisposed(),ht.stridedSlice(this,t,e,n,r,o,a,i,s)},t.prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),ht.depthToSpace(this,t,e)},t.prototype.fft=function(){return this.throwIfDisposed(),ht.spectral.fft(this)},t.prototype.ifft=function(){return this.throwIfDisposed(),ht.spectral.ifft(this)},t.prototype.rfft=function(){return this.throwIfDisposed(),ht.spectral.rfft(this)},t.prototype.irfft=function(){return this.throwIfDisposed(),ht.spectral.irfft(this)},t}();Object.defineProperty(ft,Symbol.hasInstance,{value:function(t){return!!t&&null!=t.dataId&&null!=t.shape&&null!=t.dtype}});var dt=function(t){function n(e,n,r){void 0===n&&(n=!0);var o=t.call(this,e.shape,e.dtype,null,e.dataId)||this;o.trainable=n,o.name=r,null==o.name&&(o.name=ct().nextVariableId().toString());try{ct().registerVariable(o)}catch(t){throw ct().disposeTensor(o),t}return o}return e(n,t),n.variable=function(t,e,r,o){return void 0===e&&(e=!0),null!=o&&o!==t.dtype&&(t=t.asType(o)),new n(t,e,r)},n.prototype.assign=function(t){if(t.dtype!==this.dtype)throw new Error("dtype of the new value ("+t.dtype+") and previous value ("+this.dtype+") must match");if(!x(t.shape,this.shape))throw new Error("shape of the new value ("+t.shape+") and previous value ("+this.shape+") must match");ct().disposeTensor(this),this.dataId=t.dataId,ct().registerTensor(this)},n}(ft);Object.defineProperty(dt,Symbol.hasInstance,{value:function(t){return t instanceof ft&&null!=t.assign&&t.assign instanceof Function}});var vt,mt,gt,yt,xt,wt=dt.variable;!function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(vt||(vt={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(mt||(mt={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(gt||(gt={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(yt||(yt={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(xt||(xt={}));var bt={float32:yt,int32:mt,bool:gt,complex64:xt};function Ct(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error("Can not upcast "+t+" with "+e)}return bt[t][e]}function Et(t){return Ct(t,"int32")}function Rt(t,e){if(t.dtype===e.dtype)return[t,e];var n=Ct(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function St(t,e){d(t.dtype===e.dtype,function(){return"The dtypes of the first("+t.dtype+") and second("+e.dtype+") input must match"})}function Nt(t){var e=[];return function t(e,n,r){if(null==e)return;if(e instanceof ft)return void n.push(e);if(o=e,!Array.isArray(o)&&"object"!=typeof o)return;var o;var a=e;for(var i in a){var s=a[i];r.has(s)||(r.add(s),t(s,n,r))}}(t,e,new Set),e}var kt,It=Object.freeze({makeTypesMatch:Rt,assertTypesMatch:St,isTensorInList:function(t,e){for(var n=0;n<e.length;n++)if(e[n].id===t.id)return!0;return!1},getTensorsInContainer:Nt}),At=function(){function t(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}return t.prototype.dispose=function(){for(var t in this.registeredVariables)this.registeredVariables[t].dispose()},t}(),Tt=function(){function t(t){this.ENV=t,this.registry={},this.registryFactory={},this.state=new At}return t.prototype.ready=function(){return r(this,void 0,void 0,function(){var t,e,n;return o(this,function(r){switch(r.label){case 0:if(null!=this.pendingBackendInit)return[2,this.pendingBackendInit.then(function(){})];if(null!=this.backendInstance)return[2];t=this.getSortedBackends(),e=0,r.label=1;case 1:return e<t.length?(n=t[e],[4,this.initializeBackend(n).success]):[3,4];case 2:if(r.sent())return this.setBackend(n),[2];r.label=3;case 3:return e++,[3,1];case 4:throw new Error("Could not initialize any backends, all backend initializations failed.")}})})},Object.defineProperty(t.prototype,"backend",{get:function(){if(null!=this.pendingBackendInit)throw new Error("Backend '"+this.backendName+"' has not yet been initialized. Make sure to await tf.ready() before calling other methods");if(null==this.backendInstance){var t=this.initializeBackendsAndReturnBest(),e=t.name;if(t.asyncInit)throw new Error("The highest priority backend '"+e+"' has not yet been initialized. Make sure to await tf.ready() before calling other methods");this.setBackend(e)}return this.backendInstance},enumerable:!0,configurable:!0}),t.prototype.backendNames=function(){return Object.keys(this.registryFactory)},t.prototype.findBackend=function(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;if(this.initializeBackend(t).asyncInit)return null}return this.registry[t]},t.prototype.findBackendFactory=function(t){return t in this.registryFactory?this.registryFactory[t].factory:null},t.prototype.registerBackend=function(t,e,n){return void 0===n&&(n=1),t in this.registryFactory?(console.warn(t+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[t]={factory:e,priority:n},!0)},t.prototype.setBackend=function(t){return r(this,void 0,void 0,function(){var e,n,r;return o(this,function(o){switch(o.label){case 0:if(null==this.registryFactory[t])throw new Error("Backend name '"+t+"' not found in registry");return this.backendName=t,null!=this.registry[t]?[3,4]:(this.backendInstance=null,e=this.initializeBackend(t),n=e.success,e.asyncInit?[4,n]:[3,2]);case 1:return r=o.sent(),[3,3];case 2:r=n,o.label=3;case 3:if(!r)return[2,!1];o.label=4;case 4:return this.backendInstance=this.registry[t],this.profiler=new tt(this.backendInstance),[2,!0]}})})},t.prototype.initializeBackend=function(t){var e=this,n=Dt.registryFactory[t];if(null==n)throw new Error("Cannot initialize backend "+t+", no registration found.");try{var r=n.factory();if(Promise.resolve(r)===r){var o=r.then(function(n){return e.registry[t]=n,e.pendingBackendInit=null,!0}).catch(function(n){return e.pendingBackendInit=null,console.warn("Initialization of backend "+t+" failed"),console.warn(n.stack||n.message),!1});return this.pendingBackendInit=o,{success:o,asyncInit:!0}}return this.registry[t]=r,{success:!0,asyncInit:!1}}catch(e){return console.warn("Initialization of backend "+t+" failed"),console.warn(e.stack||e.message),{success:!1,asyncInit:!1}}},t.prototype.removeBackend=function(t){if(!(t in this.registryFactory))throw new Error(t+" backend not found in registry");t in this.registry&&(this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t]},t.prototype.getSortedBackends=function(){var t=this;if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(function(e,n){return t.registryFactory[n].priority-t.registryFactory[e].priority})},t.prototype.initializeBackendsAndReturnBest=function(){for(var t=this.getSortedBackends(),e=0;e<t.length;e++){var n=t[e],r=this.initializeBackend(n),o=r.success,a=r.asyncInit;if(a||o)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")},t.prototype.moveData=function(t){this.write(t,this.readSync(t))},t.prototype.tidy=function(t,e){var n,r=this,o=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");o=t}return this.scopedRun(function(){return r.startScope(o)},function(){return r.endScope(n)},function(){return(n=e())instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n})},t.prototype.scopedRun=function(t,e,n){t();try{var r=n();return e(),r}catch(t){throw e(),t}},t.prototype.nextTensorId=function(){return t.nextTensorId++},t.prototype.nextVariableId=function(){return t.nextVariableId++},t.prototype.clone=function(t){var e=ft.make(t.shape,{dataId:t.dataId},t.dtype);return this.addTapeNode([t],e,function(t){return[t.toFloat()]}),e},t.prototype.runKernel=function(t,e,n){var r,o=this,a=[],i=this.isTapeOn(),s=null!=this.state.activeScope?this.state.activeScope.name:"",u=function(t){i&&(a=t.map(function(t){return o.keep(o.clone(t))}))},l=this.state.numBytes,c=this.state.numTensors;if(this.scopedRun(function(){return o.state.kernelDepth++},function(){return o.state.kernelDepth--},function(){r=o.ENV.getBool("DEBUG")?o.profiler.profileKernel(s,function(){return t(o.backend,u)}):t(o.backend,u)}),i){var h={id:this.state.nextTapeNodeId++,name:s,inputs:e,outputs:Array.isArray(r)?r:[r],saved:a};null!=n&&(h.gradient=function(t){return n(t,a)}),this.state.activeTape.push(h)}return this.state.profiling&&this.state.activeProfile.kernels.push({name:s,bytesAdded:this.state.numBytes-l,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-c,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(e).map(function(t){return e[t].shape}),outputShape:Array.isArray(r)?r.map(function(t){return t.shape}):r.shape}),r},t.prototype.registerTensor=function(t,e){var n=this.state.tensorInfo.has(t.dataId)?this.state.tensorInfo.get(t.dataId).refCount:0;if(this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++,0===n){this.state.numDataBuffers++;var r=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(r=t.size*M(t.dtype)),this.state.tensorInfo.set(t.dataId,{backend:null!=e?e:this.backend,dtype:t.dtype,shape:t.shape,bytes:r,refCount:0}),this.state.numBytes+=r,null!=e?e.register(t.dataId,t.shape,t.dtype):this.backend.register(t.dataId,t.shape,t.dtype)}this.state.tensorInfo.get(t.dataId).refCount++,t instanceof dt||this.track(t)},t.prototype.registerVariable=function(t){if(null!=this.state.registeredVariables[t.name])throw new Error("Variable with name "+t.name+" was already registered");this.state.registeredVariables[t.name]=t},t.prototype.disposeTensor=function(t){if(this.state.tensorInfo.has(t.dataId)){this.state.numTensors--,"string"===t.dtype&&this.state.numStringTensors--;var e=this.state.tensorInfo.get(t.dataId);e.refCount<=1?("complex64"!==t.dtype&&(this.state.numBytes-=e.bytes),this.state.numDataBuffers--,e.backend.disposeData(t.dataId),this.state.tensorInfo.delete(t.dataId)):this.state.tensorInfo.get(t.dataId).refCount--}},t.prototype.disposeVariables=function(){for(var t in this.state.registeredVariables){var e=this.state.registeredVariables[t];this.disposeTensor(e),delete this.state.registeredVariables[t]}},t.prototype.memory=function(){var t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t},t.prototype.profile=function(t){return r(this,void 0,void 0,function(){var e,n;return o(this,function(r){return this.state.profiling=!0,e=this.state.numBytes,n=this.state.numTensors,this.state.activeProfile.kernels=[],this.state.activeProfile.result=t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max.apply(Math,this.state.activeProfile.kernels.map(function(t){return t.totalBytesSnapshot})),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n,[2,this.state.activeProfile]})})},t.prototype.isTapeOn=function(){return this.state.gradientDepth>0&&0===this.state.kernelDepth},t.prototype.addTapeNode=function(t,e,n){var r={};t.forEach(function(t,e){r[e]=t});var o={id:this.state.nextTapeNodeId++,name:this.state.activeScope.name,inputs:r,outputs:[e],gradient:function(t){var e=n(t),r={};return e.forEach(function(t,e){r[e]=function(){return t}}),r}};this.state.activeTape.push(o)},t.prototype.keep=function(t){return t.kept=!0,t},t.prototype.startTape=function(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++},t.prototype.endTape=function(){this.state.gradientDepth--},t.prototype.startScope=function(t){var e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e},t.prototype.endScope=function(t){for(var e=this,n=Nt(t),r=new Set(n.map(function(t){return t.id})),o=0;o<this.state.activeScope.track.length;o++){var a=this.state.activeScope.track[o];a.kept||r.has(a.id)||a.dispose()}var i=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(function(t){t.kept||t.scopeId!==i.id||e.track(t)})},t.prototype.gradients=function(t,e,n,r){var o=this;if(void 0===r&&(r=!1),d(e.length>0,function(){return"gradients() received an empty list of xs."}),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '"+n.dtype+"'");var a=this.scopedRun(function(){return o.startTape()},function(){return o.endTape()},function(){return o.tidy("forward",t)});d(a instanceof ft,function(){return"The result y returned by f() must be a tensor."});var i=function(t,e,n){for(var r={},o={},a=0;a<e.length;a++)r[e[a].id]=!0;for(a=0;a<t.length;a++){var i=(d=t[a]).inputs;for(var s in i){for(var u=i[s],l=!1,c=0;c<e.length;c++)if(r[u.id]){d.outputs.forEach(function(t){return r[t.id]=!0}),l=!0,o[d.id]=!0;break}if(l)break}}var h={};h[n.id]=!0;var p={};for(a=t.length-1;a>=0;a--)for(i=(d=t[a]).inputs,c=0;c<d.outputs.length;c++)if(h[d.outputs[c].id]){for(var s in i)h[i[s].id]=!0,p[d.id]=!0;break}var f=[];for(a=0;a<t.length;a++){var d;if(o[(d=t[a]).id]&&p[d.id]){var v={};for(var s in d.inputs){var m=d.inputs[s];r[m.id]&&(v[s]=m)}var g=Object.assign({},d);g.inputs=v,g.outputs=d.outputs,f.push(g)}}return f}(this.state.activeTape,e,a);if(!r&&0===i.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",function(){var t,r,s={};s[a.id]=null==n?(t=a.shape,r=H(y(t),"float32"),ft.make(t,{values:r})):n,function(t,e,n){for(var r=function(r){var o=e[r],a=[];if(o.outputs.forEach(function(e){var n=t[e.id];if(null!=n)a.push(n);else{var r=ft.make(e.shape,{values:$(e.size,e.dtype)},e.dtype);a.push(r)}}),null==o.gradient)throw new Error("Cannot compute gradient: gradient function not found for "+o.name+".");var i=o.gradient(1===o.outputs.length?a[0]:a),s=function(e){if(!(e in i))throw new Error("Cannot backprop through input "+e+". Available gradients found: "+Object.keys(i)+".");var r=n(function(){return i[e]()});if("float32"!==r.dtype)throw new Error("Error in gradient for op "+o.name+". The gradient of input "+e+" must have 'float32' dtype, but has '"+r.dtype+"'");var a=o.inputs[e];if(!x(r.shape,a.shape))throw new Error("Error in gradient for op "+o.name+". The gradient of input '"+e+"' has shape '"+r.shape+"', which does not match the shape of the input '"+a.shape+"'");if(null==t[a.id])t[a.id]=r;else{var s=t[a.id];t[a.id]=s.add(r),s.dispose()}};for(var u in o.inputs)s(u)},o=e.length-1;o>=0;o--)r(o)}(s,i,function(t){return o.tidy(t)});var u=e.map(function(t){return s[t.id]});return 0===o.state.gradientDepth&&(o.state.activeTape.forEach(function(t){for(var e in t.saved)t.saved[e].dispose()}),o.state.activeTape=null),{value:a,grads:u}})},t.prototype.customGrad=function(t){var e=this;return d(U(t),function(){return"The f passed in customGrad(f) must be a function."}),function(){for(var n,r=[],o=0;o<arguments.length;o++)r[o]=arguments[o];d(r.every(function(t){return t instanceof ft}),function(){return"The args passed in customGrad(f)(x1, x2,...) must all be tensors"});var a={};return r.forEach(function(t,e){a[e]=t}),e.runKernel(function(e,o){return d((n=t.apply(void 0,r.concat([o]))).value instanceof ft,function(){return"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"}),d(U(n.gradFunc),function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."}),n.value},a,function(t,e){var o=n.gradFunc(t,e),a=Array.isArray(o)?o:[o];d(a.length===r.length,function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."}),d(a.every(function(t){return t instanceof ft}),function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."});var i={};return a.forEach(function(t,e){i[e]=function(){return t}}),i})}},t.prototype.write=function(t,e){var n=this.state.tensorInfo.get(t);if("string"===n.dtype){var r=F(e);this.state.numBytes+=r-n.bytes,n.bytes=r}this.backend!==n.backend&&(n.backend.disposeData(t),n.backend=this.backend,this.backend.register(t,n.shape,n.dtype)),this.backend.write(t,e)},t.prototype.readSync=function(t){return this.state.tensorInfo.get(t).backend.readSync(t)},t.prototype.read=function(t){return this.state.tensorInfo.get(t).backend.read(t)},t.prototype.fromPixels=function(t,e){return this.backend.fromPixels(t,e)},t.prototype.time=function(t){return r(this,void 0,void 0,function(){var e,n;return o(this,function(r){switch(r.label){case 0:return e=j(),[4,this.backend.time(t)];case 1:return(n=r.sent()).wallMs=j()-e,[2,n]}})})},t.prototype.track=function(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t},Object.defineProperty(t.prototype,"registeredVariables",{get:function(){return this.state.registeredVariables},enumerable:!0,configurable:!0}),t.prototype.reset=function(){for(var t in this.state.dispose(),this.ENV.reset(),this.state=new At,this.registry)this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null},t.nextTensorId=0,t.nextVariableId=0,t}();var Dt=function(){var t=function(){if(null==kt){var t=void 0;if("undefined"!=typeof window)t=window;else if("undefined"!=typeof global)t=global;else{if("undefined"==typeof process)throw new Error("Could not find a global object");t=process}kt=t}return kt}();if(null==t._tfengine){var e=new i(t);t._tfengine=new Tt(e)}return u(t._tfengine.ENV),ct=function(){return t._tfengine},t._tfengine}();function Ot(){return"undefined"!=typeof window}a.registerFlag("DEBUG",function(){return!1},function(t){t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),a.registerFlag("IS_BROWSER",function(){return Ot()}),a.registerFlag("IS_NODE",function(){return"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node}),a.registerFlag("IS_CHROME",function(){return"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)}),a.registerFlag("PROD",function(){return!1}),a.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",function(){return!a.getBool("PROD")}),a.registerFlag("DEPRECATION_WARNINGS_ENABLED",function(){return!0}),a.registerFlag("IS_TEST",function(){return!1});var _t={},Mt={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Ft(t){t in _t||(_t[t]=function(t){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");var e=document.createElement("canvas");if(e.addEventListener("webglcontextlost",function(e){e.preventDefault(),delete _t[t]},!1),1===t)return e.getContext("webgl",Mt)||e.getContext("experimental-webgl",Mt);return e.getContext("webgl2",Mt)}(t));var e=_t[t];return e.isContextLost()?(delete _t[t],Ft(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),_t[t])}function Bt(t,e,n){var r=n();return e&&function(t){var e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+Ut(t,e))}(t),r}var Pt=5.96e-8,Lt=65504;function Wt(t){return!!(a.getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||Pt<Math.abs(t)&&Math.abs(t)<Lt)}function Ut(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+e}}function zt(t,e,n){return he(t,e,function(){return t.getExtension(n)},'Extension "'+n+'" not supported on this browser.')}function Vt(t,e,n){var r=he(t,e,function(){return t.createShader(t.VERTEX_SHADER)},"Unable to create vertex WebGLShader.");if(Bt(t,e,function(){return t.shaderSource(r,n)}),Bt(t,e,function(){return t.compileShader(r)}),!1===t.getShaderParameter(r,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(r)),new Error("Failed to compile vertex shader.");return r}function Gt(t,e,n){var r=he(t,e,function(){return t.createShader(t.FRAGMENT_SHADER)},"Unable to create fragment WebGLShader.");if(Bt(t,e,function(){return t.shaderSource(r,n)}),Bt(t,e,function(){return t.compileShader(r)}),!1===t.getShaderParameter(r,t.COMPILE_STATUS))throw function(t,e){var n=$t.exec(e);if(null==n)return console.log("Couldn't parse line number in error: "+e),void console.log(t);for(var r=+n[1],o=t.split("\n"),a=o.length.toString().length+2,i=o.map(function(t,e){return E((e+1).toString(),a)+t}),s=0,u=0;u<i.length;u++)s=Math.max(i[u].length,s);var l=i.slice(0,r-1),c=i.slice(r-1,r),h=i.slice(r);console.log(l.join("\n")),console.log(e.split("\n")[0]),console.log("%c "+E(c[0],s),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join("\n"))}(n,t.getShaderInfoLog(r)),new Error("Failed to compile fragment shader.");return r}var qt,Ht,$t=/ERROR: [0-9]+:([0-9]+):/g;function jt(t,e){return he(t,e,function(){return t.createProgram()},"Unable to create WebGLProgram.")}function Kt(t,e,n){if(Bt(t,e,function(){return t.linkProgram(n)}),!1===t.getProgramParameter(n,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}function Xt(t,e,n){if(Bt(t,e,function(){return t.validateProgram(n)}),!1===t.getProgramParameter(n,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function Yt(t,e,n){var r=he(t,e,function(){return t.createBuffer()},"Unable to create WebGLBuffer");return Bt(t,e,function(){return t.bindBuffer(t.ARRAY_BUFFER,r)}),Bt(t,e,function(){return t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW)}),r}function Qt(t,e,n){var r=he(t,e,function(){return t.createBuffer()},"Unable to create WebGLBuffer");return Bt(t,e,function(){return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,r)}),Bt(t,e,function(){return t.bufferData(t.ELEMENT_ARRAY_BUFFER,n,t.STATIC_DRAW)}),r}function Jt(){return 2===a.getNumber("WEBGL_VERSION")?1:4}function Zt(t,e){return he(t,e,function(){return t.createTexture()},"Unable to create WebGLTexture.")}function te(t,e){var n=a.getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){var r="["+t+"x"+e+"]";throw new Error("Requested texture size "+r+" is invalid.")}if(t>n||e>n){r="["+t+"x"+e+"]";throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+("["+n+"x"+n+"]")+".")}}function ee(t,e){return he(t,e,function(){return t.createFramebuffer()},"Unable to create WebGLFramebuffer.")}function ne(t,e,n,r,o,a,i,s){var u=t.getAttribLocation(n,r);return-1!==u&&(Bt(t,e,function(){return t.bindBuffer(t.ARRAY_BUFFER,o)}),Bt(t,e,function(){return t.vertexAttribPointer(u,a,t.FLOAT,!1,i,s)}),Bt(t,e,function(){return t.enableVertexAttribArray(u)}),!0)}function re(t,e,n,r){pe(t,r),Bt(t,e,function(){return t.activeTexture(t.TEXTURE0+r)}),Bt(t,e,function(){return t.bindTexture(t.TEXTURE_2D,n)})}function oe(t,e,n,r){return he(t,e,function(){return t.getUniformLocation(n,r)},'uniform "'+r+'" not present in program.')}function ae(t,e,n){return t.getUniformLocation(e,n)}function ie(t,e,n,r,o,a){Bt(t,e,function(){return re(t,e,r,a)}),Bt(t,e,function(){return t.uniform1i(o,a)})}function se(t,e,n,r){Bt(t,e,function(){return t.bindFramebuffer(t.FRAMEBUFFER,r)}),Bt(t,e,function(){return t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0)})}function ue(t,e,n){Bt(t,e,function(){return t.bindFramebuffer(t.FRAMEBUFFER,n)}),Bt(t,e,function(){return t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0)})}function le(t){var e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+ce(t,e))}function ce(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+e}}function he(t,e,n,r){var o=Bt(t,e,function(){return n()});if(null==o)throw new Error(r);return o}function pe(t,e){var n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n)throw new Error("textureUnit must be in "+("[gl.TEXTURE0, gl.TEXTURE"+n+"]")+".")}function fe(t,e){return void 0===e&&(e=2),y(t.slice(0,t.length-e))}function de(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function ve(t,e){var n;void 0===e&&(e=!1);var r=a.getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e&&(r*=2,1===(t=t.map(function(e,n){return n>=t.length-2?p(t[n]):t[n]})).length&&(t=[2,t[0]])),2!==t.length){var o=k(t);t=o.newShape}var i=y(t);if(t.length<=1&&i<=r)return[1,i];if(2===t.length&&t[0]<=r&&t[1]<=r)return t;if(3===t.length&&t[0]*t[1]<=r&&t[2]<=r)return[t[0]*t[1],t[2]];if(3===t.length&&t[0]<=r&&t[1]*t[2]<=r)return[t[0],t[1]*t[2]];if(4===t.length&&t[0]*t[1]*t[2]<=r&&t[3]<=r)return[t[0]*t[1]*t[2],t[3]];if(4===t.length&&t[0]<=r&&t[1]*t[2]*t[3]<=r)return[t[0],t[1]*t[2]*t[3]];if(e){var s=fe(t),u=2,l=2;return t.length&&(u=(n=de(t))[0],l=n[1]),C(i=s*(u/2)*(l/2)).map(function(t){return 2*t})}return C(i)}function me(t){return t%2==0}function ge(t,e){if(x(t=t.slice(-2),e=e.slice(-2)))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){var n=t.slice(-1)[0],r=e.slice(-1)[0];if(n===r)return!0;if(me(n)&&me(r)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&me(t[0])&&me(e[0])}function ye(t){if(null==qt){var e=Ft(t);qt=e.getParameter(e.MAX_TEXTURE_SIZE)}return qt}function xe(t){if(null==Ht){var e=Ft(t);Ht=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Ht)}function we(t){if(0===t)return 0;var e=Ft(t);return be(e,"EXT_disjoint_timer_query_webgl2")&&2===t?2:be(e,"EXT_disjoint_timer_query")?1:0}function be(t,e){return null!=t.getExtension(e)}function Ce(t){try{if(null!=Ft(t))return!0}catch(t){return!1}return!1}function Ee(t){if(0===t)return!1;var e=Ft(t);if(1===t){if(!be(e,"OES_texture_float"))return!1}else if(!be(e,"EXT_color_buffer_float"))return!1;return Se(e,t)}function Re(t){if(0===t)return!1;var e=Ft(t);if(1===t){if(!be(e,"OES_texture_float"))return!1;if(!be(e,"WEBGL_color_buffer_float"))return!1}else if(!be(e,"EXT_color_buffer_float"))return!1;return Se(e,t)}function Se(t,e){var n=t.createFramebuffer(),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r);var o=2===e?t.RGBA32F:t.RGBA;t.texImage2D(t.TEXTURE_2D,0,o,1,1,0,t.RGBA,t.FLOAT,null),t.bindFramebuffer(t.FRAMEBUFFER,n),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);var a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(n),a}function Ne(t){return 2===t&&null!=Ft(t).fenceSync}var ke=Object.freeze({callAndCheck:Bt,canBeRepresented:Wt,getWebGLErrorMessage:Ut,getExtensionOrThrow:zt,createVertexShader:Vt,createFragmentShader:Gt,createProgram:jt,linkProgram:Kt,validateProgram:Xt,createStaticVertexBuffer:Yt,createStaticIndexBuffer:Qt,getNumChannels:Jt,createTexture:Zt,validateTextureSize:te,createFramebuffer:ee,bindVertexBufferToProgramAttribute:ne,bindTextureUnit:re,unbindTextureUnit:function(t,e,n){pe(t,n),Bt(t,e,function(){return t.activeTexture(t.TEXTURE0+n)}),Bt(t,e,function(){return t.bindTexture(t.TEXTURE_2D,null)})},getProgramUniformLocationOrThrow:oe,getProgramUniformLocation:ae,bindTextureToProgramUniformSampler:ie,bindCanvasToFramebuffer:function(t,e){Bt(t,e,function(){return t.bindFramebuffer(t.FRAMEBUFFER,null)}),Bt(t,e,function(){return t.viewport(0,0,t.canvas.width,t.canvas.height)}),Bt(t,e,function(){return t.scissor(0,0,t.canvas.width,t.canvas.height)})},bindColorTextureToFramebuffer:se,unbindColorTextureFromFramebuffer:ue,validateFramebuffer:le,getFramebufferErrorMessage:ce,getBatchDim:fe,getRowsCols:de,getTextureShapeFromLogicalShape:ve,isReshapeFree:ge,get MAX_TEXTURE_SIZE(){return qt},get MAX_TEXTURES_IN_SHADER(){return Ht},getWebGLMaxTextureSize:ye,getMaxTexturesInShader:xe,getWebGLDisjointQueryTimerVersion:we,isWebGLVersionEnabled:Ce,isRenderToFloatTextureEnabled:Ee,isDownloadFloatTextureEnabled:Re,isWebGLFenceEnabled:Ne});function Ie(){a.set("PROD",!0)}function Ae(){a.set("DEBUG",!0)}function Te(){a.set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function De(t){a.getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Oe(){Dt.disposeVariables()}function _e(){return Dt.memory()}function Me(t){return Dt.profile(t)}function Fe(t,e){return Dt.tidy(t,e)}function Be(t){Nt(t).forEach(function(t){return t.dispose()})}function Pe(t){return Dt.keep(t)}function Le(t){return Dt.time(t)}function We(t){return Dt.setBackend(t)}function Ue(){return Dt.ready()}function ze(){return Dt.backendName}function Ve(t){Dt.removeBackend(t)}function Ge(t){return Dt.findBackend(t)}function qe(t){return Dt.findBackendFactory(t)}function He(t,e,n){return void 0===n&&(n=1),Dt.registerBackend(t,e,n)}function $e(){return Dt.backend}function je(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];a.getBool("IS_TEST")||console.warn.apply(console,t)}function Ke(t,e,n,r){void 0===r&&(r=!0);var o=[];if(r)(o=o.concat(e.slice(0))).push(t[0]/n),o=o.concat(t.slice(1));else{o=o.concat(t[0]);for(var a=e.length,i=0;i<a;++i)o=o.concat([t[i+1]/e[i],e[i]]);o=o.concat(t.slice(a+1))}return o}function Xe(t,e,n){void 0===n&&(n=!0);var r=[];if(n){r.push(e);for(var o=e+1;o<t;++o)o<=2*e?(r.push(o),r.push(o-(e+1))):r.push(o)}else{var a=[],i=[];for(o=1;o<t;++o)o>=2*e+1||o%2==1?i.push(o):a.push(o);r.push.apply(r,a),r.push(0),r.push.apply(r,i)}return r}function Ye(t,e,n,r){void 0===r&&(r=!0);var o=[];r?o.push(t[0]/n):o.push(t[0]*n);for(var a=1;a<t.length;++a)a<=e.length?r?o.push(e[a-1]*t[a]):o.push(t[a]/e[a-1]):o.push(t[a]);return o}function Qe(t,e){for(var n=[0],r=0;r<e;++r)n.push(t[r][0]);return n}function Je(t,e,n){for(var r=t.slice(0,1),o=0;o<n;++o)r.push(t[o+1]-e[o][0]-e[o][1]);return r}function Ze(t,e){for(var n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function tn(t,e){for(var n=[],r=t.length,o=0;o<r;o++)-1===e.indexOf(o)&&n.push(t[o]);return[n,e.map(function(e){return t[e]})]}function en(t,e){return function(t,e,n){for(var r=t.length+e.length,o=[],a=0,i=0,s=0;s<r;s++)-1===n.indexOf(s)?o.push(t[a++]):o.push(e[i++]);return o}(t,e.map(function(t){return 1}),e)}function nn(t,e,n){d(Ze(e,n),function(){return t+" supports only inner-most axes for now. Got axes "+e+" and rank-"+n+" input."})}function rn(t,e){if(Ze(t,e))return null;for(var n=[],r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach(function(t){return n.push(t)}),n}function on(t){return t.map(function(t,e){return[e,t]}).sort(function(t,e){return t[1]-e[1]}).map(function(t){return t[0]})}function an(t,e){for(var n=[],r=e-t;r<e;++r)n.push(r);return n}function sn(t,e){for(var n=t[0].slice(),r=1;r<t.length;r++)n[e]+=t[r][e];return n}function un(t,e){if(t.rank<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was "+t.rank+".");if(e.rank<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was "+e.rank+".");if("int32"!==e.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was "+e.dtype+".");if(e.shape[e.rank-1]>t.rank)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+e.shape[e.rank-1]+" vs. "+t.rank);if(0===t.size)throw new Error("Requested more than 0 entries, but input is empty. Input shape: "+t.shape+".");for(var n=e.shape,r=n[n.length-1],o=1,a=0;a<n.length-1;++a)o*=n[a];var i=t.shape,s=n.slice();s.pop();var u=1;for(a=r;a<t.rank;++a)u*=i[a],s.push(i[a]);var l=V(t.shape).map(function(t){return t/u}).concat([1]).slice(0,r);return[s,o,u,l]}a.registerFlag("HAS_WEBGL",function(){return a.getNumber("WEBGL_VERSION")>0}),a.registerFlag("WEBGL_VERSION",function(){return Ce(2)?2:Ce(1)?1:0}),a.registerFlag("WEBGL_BUFFER_SUPPORTED",function(){return 2===a.get("WEBGL_VERSION")}),a.registerFlag("WEBGL_CPU_FORWARD",function(){return!1}),a.registerFlag("WEBGL_PACK",function(){return a.getBool("HAS_WEBGL")}),a.registerFlag("WEBGL_PACK_NORMALIZATION",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_PACK_CLIP",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_PACK_DEPTHWISECONV",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_PACK_REDUCE",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_LAZILY_UNPACK",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_CONV_IM2COL",function(){return a.getBool("WEBGL_PACK")}),a.registerFlag("WEBGL_MAX_TEXTURE_SIZE",function(){return ye(a.getNumber("WEBGL_VERSION"))}),a.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",function(){return xe(a.getNumber("WEBGL_VERSION"))}),a.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",function(){var t=a.getNumber("WEBGL_VERSION");return 0===t?0:we(t)}),a.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",function(){return a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&(t=navigator.userAgent||navigator.vendor||window.opera,!(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))));var t}),a.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",function(){return Ee(a.getNumber("WEBGL_VERSION"))}),a.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",function(){return Re(a.getNumber("WEBGL_VERSION"))}),a.registerFlag("WEBGL_FENCE_API_ENABLED",function(){return Ne(a.getNumber("WEBGL_VERSION"))}),a.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",function(){return a.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0}),pt=De;var ln=30;function cn(t){return t<=ln?t:z(t,Math.floor(Math.sqrt(t)))}function hn(t,e,n){if(e.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was "+e.rank+".");if(t.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was "+t.rank+".");if("int32"!==e.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: "+e.dtype);if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: "+n);if(0===n.length){if(0===e.size)throw new Error("Indices specified for empty output. indices shape: "+e.shape);if(0===t.size)throw new Error("Updates specified for empty output. updates shape: "+t.shape)}!function(t,e,n){var r=e.rank>1?e.shape[e.rank-1]:1,o=e.rank>1?e.rank-1:1,a="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+n.shape+", indices.shape: "+e.shape+", shape: "+t+", sliceDim: "+r+", and batchDim: "+o+".";if(n.rank<o)throw new Error(a+" update.rank < "+o+". ");if(t.length<r+(n.rank-o))throw new Error(a+" Output shape length < "+(r+(n.rank-o)));if(n.rank!==o+t.length-r)throw new Error(a+" update.rank != "+(o+t.length-r));for(var i=0;i<o;++i)if(n.shape[i]!==e.shape[i])throw new Error(a+" updates.shape["+i+"] ("+n.shape[i]+") != indices.shape["+i+"] ("+e.shape[i]+").");for(i=0;i<n.rank-o;++i)if(n.shape[i+o]!==t[i+r])throw new Error(a+" updates.shape["+(i+o)+"] ("+n.shape[i+o]+") != shape["+(i+o)+"] ("+t[i+o]+")")}(n,e,t)}function pn(t,e,n){for(var r=e.rank>1?e.shape[e.rank-1]:1,o=n.length,a=1,i=r;i<o;++i)a*=n[i];var s=r<1?1:r;return{sliceRank:r,numUpdates:e.size/s,sliceSize:a,strides:V(n.slice(0,r)).concat([1]),outputSize:y(n)}}function fn(t,e,n,r,o,a,i,s,u){if(void 0===o&&(o=0),void 0===a&&(a=0),void 0===i&&(i=0),void 0===s&&(s=0),void 0===u&&(u=0),0!==i)throw new Error("ellipsis mask is not yet supported");if(0!==s)throw new Error("new axis mask is not yet supported");for(var l=[],c=[],h=[],p=0;p<t.length;p++)l[p]=dn(o,e,r,t,p),c[p]=vn(a,n,r,t,p),u&1<<p&&(c[p]=l[p]+1,h.push(p));var f=new Array(t.length).fill(0);return f=f.map(function(t,e){for(var n=0,o=r[e]||1,a=l[e];!(o>0?a>=c[e]:a<=c[e]);a+=o)n+=1;return n}),[l,f,h]}function dn(t,e,n,r,o){var a=e[o],i=n[o]||1;(t&1<<o||null==a)&&(a=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);var s=r[o];return a<0&&(a+=s),a=h(0,a,s-1)}function vn(t,e,n,r,o){var a=e[o],i=n[o]||1;(t&1<<o||null==a)&&(a=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);var s=r[o];return a<0&&(a+=s),a=i>0?h(0,a,s):h(-1,a,s-1)}function mn(t,e,n){for(var r=n.length,o=0;o<n.length;o++)if(n[o]>1){r=o;break}for(o=r+1;o<n.length;o++)if(e[o]>0||n[o]!==t[o])return!1;return!0}function gn(t,e){for(var n=t.length>0?t[t.length-1]:1,r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function yn(t){var e=t;if(_(t))return[t.length];if(!Array.isArray(t))return[];for(var n=[];Array.isArray(e)||_(e);)n.push(e.length),e=e[0];return Array.isArray(t)&&a.getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&function t(e,n,r){r=r||[];if(!Array.isArray(e)&&!_(e))return void d(0===n.length,function(){return"Element arr["+r.join("][")+"] is a primitive, but should be an array/TypedArray of "+n[0]+" elements"});d(n.length>0,function(){return"Element arr["+r.join("][")+"] should be a primitive, but is an array of "+e.length+" elements"});d(e.length===n[0],function(){return"Element arr["+r.join("][")+"] should have "+n[0]+" elements, but has "+e.length+" elements"});var o=n.slice(1);for(var a=0;a<e.length;++a)t(e[a],o,r.concat(a))}(t,n,[]),n}function xn(t,e,n,r){if(null!=t&&("numeric"!==t&&t!==e||"numeric"===t&&"string"===e))throw new Error("Argument '"+n+"' passed to '"+r+"' must be "+t+" tensor, but got "+e+" tensor")}function wn(t,e,n,r){if(void 0===r&&(r="numeric"),t instanceof ft)return xn(r,t.dtype,e,n),t;var o=W(t);if("string"!==o&&["bool","int32","float32"].indexOf(r)>=0&&(o=r),xn(r,o,e,n),null==t||!_(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t){var i=null==t?"null":t.constructor.name;throw new Error("Argument '"+e+"' passed to '"+n+"' must be a Tensor or TensorLike, but got '"+i+"'")}var s=yn(t);_(t)||Array.isArray(t)||(t=[t]);var u="string"!==o?G(t,o,a.getBool("DEBUG")):g(t);return ft.make(s,{values:u},o)}function bn(t,e,n,r){if(void 0===r&&(r="numeric"),!Array.isArray(t))throw new Error("Argument "+e+" passed to "+n+" must be a `Tensor[]` or `TensorLike[]`");return t.map(function(t,r){return wn(t,e+"["+r+"]",n)},r)}function Cn(t){return d(U(t),function(){return"The f passed in grad(f) must be a function"}),function(e,n){var r=wn(e,"x","tf.grad",null),o=null!=n?wn(n,"dy","tf.grad"):null;return Dt.tidy(function(){var e=Dt.gradients(function(){return t(r)},[r],o),n=e.value,a=e.grads;return null!=o&&v(n.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),In(a),a[0]})}}function En(t){return d(U(t),function(){return"The f passed in grads(f) must be a function"}),function(e,n){d(Array.isArray(e),function(){return"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"});var r=bn(e,"args","tf.grads",null),o=null!=n?wn(n,"dy","tf.grads"):null;return Dt.tidy(function(){var e=Dt.gradients(function(){return t.apply(void 0,r)},r,o),n=e.value,a=e.grads;return null!=o&&v(n.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),In(a),a})}}function Rn(t){return d(U(t),function(){return"The f passed in valueAndGrad(f) must be a function"}),function(e,n){d(e instanceof ft,function(){return"The x passed in valueAndGrad(f)(x) must be a tensor"}),d(null==n||n instanceof ft,function(){return"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"});var r=Dt.gradients(function(){return t(e)},[e],n),o=r.grads,a=r.value;return In(o),{grad:o[0],value:a}}}function Sn(t){return d(U(t),function(){return"The f passed in valueAndGrads(f) must be a function"}),function(e,n){d(Array.isArray(e)&&e.every(function(t){return t instanceof ft}),function(){return"The args passed in valueAndGrads(f)(args) must be array of tensors"}),d(null==n||n instanceof ft,function(){return"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"});var r=Dt.gradients(function(){return t.apply(void 0,e)},e,n);return null!=n&&v(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),In(r.grads),r}}function Nn(t,e){if(d(U(t),function(){return"The f passed in variableGrads(f) must be a function"}),d(null==e||Array.isArray(e)&&e.every(function(t){return t instanceof dt}),function(){return"The varList passed in variableGrads(f, varList) must be an array of variables"}),null==e)for(var n in e=[],Dt.registeredVariables)e.push(Dt.registeredVariables[n]);var r=e.length;d((e=e.filter(function(t){return t.trainable})).length>0,function(){return"variableGrads() expects at least one of the input variables to be trainable, but none of the "+r+" variables is trainable."});var o=Dt.gradients(t,e,null,!0),a=o.value,i=o.grads;d(i.some(function(t){return null!=t}),function(){return"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."}),d(0===a.rank,function(){return"The f passed in variableGrads(f) must return a scalar, but it returned a rank-"+a.rank+" tensor"});var s={};return e.forEach(function(t,e){null!=i[e]&&(s[t.name]=i[e])}),{value:a,grads:s}}function kn(t){return Dt.customGrad(t)}function In(t){if(t.filter(function(t){return null==t}).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}function An(t){var e=Object.keys(t);if(1!==e.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+e.length+" keys.");var n=e[0],r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1));var o=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];Dt.startScope(n);try{var o=r.apply(void 0,t);return o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),Dt.endScope(o),o}catch(t){throw Dt.endScope(null),t}};return Object.defineProperty(o,"name",{value:n,configurable:!0}),o}var Tn=An({softmax_:function(t,e){void 0===e&&(e=-1);var n=wn(t,"logits","softmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank "+n.rank+" and dim was "+e);return kn(function(t,n){var r=t.logSumExp([e],!0),o=t.toFloat().sub(r).exp();return n([o]),{value:o,gradFunc:function(t,n){var r=n[0],o=t.mul(r);return o.sub(o.sum([e],!0).mul(r))}}})(n)}}),Dn=An({logSoftmax_:function(t,e){void 0===e&&(e=-1);var n=wn(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank "+n.rank+" and axis was "+e);return kn(function(t,n){var r=t.max(e,!0),o=t.sub(r),a=o.toFloat().sub(o.exp().sum(e,!0).log());return n([a]),{value:a,gradFunc:function(t,n){var r=n[0].exp();return t.sub(t.sum(e,!0).mul(r))}}})(n)}});var On=An({complex_:function(t,e){var n=wn(t,"real","complex"),r=wn(e,"imag","complex");return v(n.shape,r.shape,"real and imag shapes, "+n.shape+" and "+r.shape+", must match in call to tf.complex()."),Dt.runKernel(function(t){return t.complex(n,r)},{$real:n,$imag:r})}}),_n=An({real_:function(t){var e=wn(t,"input","real");return Dt.runKernel(function(t){return t.real(e)},{$input:e})}}),Mn=An({imag_:function(t){var e=wn(t,"input","imag");return Dt.runKernel(function(t){return t.imag(e)},{$input:e})}});function Fn(t,e,n){if(null==n&&(n=W(t)),"complex64"===n)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!_(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");var r=yn(t);if(null!=e){K(e);var o=y(e),i=y(r);d(o===i,function(){return"Based on the provided shape, ["+e+"], the tensor should have "+o+" values but has "+i});for(var s=0;s<r.length;++s){var u=r[s],l=s!==r.length-1||u!==y(e.slice(s));d(r[s]===e[s]||!l,function(){return"Error creating a new Tensor. Inferred shape ("+r+") does not match the provided shape ("+e+"). "})}}return _(t)||Array.isArray(t)||(t=[t]),e=e||r,t="string"!==n?G(t,n,a.getBool("DEBUG")):g(t),ft.make(e,{values:t},n)}function Bn(t,e){if((_(t)||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");return Fn(t,[],e)}function Pn(t,e){m(t);var n=yn(t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Fn(t,n,e)}function Ln(t,e,n){if(m(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");var r=yn(t);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Fn(t,e=e||r,n)}function Wn(t,e,n){if(m(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");var r=yn(t);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Fn(t,e=e||r,n)}function Un(t,e,n){if(m(t),null!=e&&4!==e.length)throw new Error("tensor4d() requires shape to have four numbers");var r=yn(t);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Fn(t,e=e||r,n)}function zn(t,e,n){if(m(t),null!=e&&5!==e.length)throw new Error("tensor5d() requires shape to have five numbers");var r=yn(t);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Fn(t,e=e||r,n)}function Vn(t,e,n){if(m(t),null!=e&&6!==e.length)throw new Error("tensor6d() requires shape to have six numbers");var r=yn(t);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return Fn(t,e=e||r,n)}function Gn(t,e){if(void 0===e&&(e="float32"),"complex64"===e){var n=Gn(t,"float32"),r=qn(t,"float32");return On(n,r)}var o=H(y(t),e);return ft.make(t,{values:o},e)}function qn(t,e){if(void 0===e&&(e="float32"),"complex64"===e){var n=qn(t,"float32"),r=qn(t,"float32");return On(n,r)}var o=$(y(t),e);return ft.make(t,{values:o},e)}function Hn(t,e,n){return Dt.runKernel(function(r){return r.fill(t,e,n)},{})}function $n(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");return Dt.runKernel(function(r){return r.linspace(t,e,n)},{})}function jn(t,e,n,r){if(void 0===n&&(n=1),void 0===r&&(r="float32"),0===n)throw new Error("Cannot have a step of zero");if(t===e||t<e&&n<0||e<t&&n>1)return qn([0],r);var o=$(Math.abs(Math.ceil((e-t)/n)),r);e<t&&1===n&&(n=-1),o[0]=t;for(var a=1;a<o.length;a++)o[a]=o[a-1]+n;return Pn(o,r)}var Kn=An({onesLike_:function(t){var e=wn(t,"x","onesLike");if("complex64"===e.dtype){var n=Kn(_n(e)),r=Xn(Mn(e));return On(n,r)}return Dt.runKernel(function(t){return t.onesLike(e)},{$x:e},null)}}),Xn=An({zerosLike_:function(t){var e=wn(t,"x","zerosLike");return Dt.runKernel(function(t){return t.zerosLike(e)},{$x:e},null)}}),Yn=function(){function t(t){this.dataMover=t,this.data=new WeakMap}return t.prototype.get=function(t){return this.data.has(t)||this.dataMover.moveData(t),this.data.get(t)},t.prototype.set=function(t,e){this.data.set(t,e)},t.prototype.has=function(t){return this.data.has(t)},t.prototype.delete=function(t){return this.data.delete(t)},t}(),Qn=function(){function t(){}return t.prototype.time=function(t){throw new Error("Not yet implemented.")},t.prototype.read=function(t){throw new Error("Not yet implemented.")},t.prototype.readSync=function(t){throw new Error("Not yet implemented.")},t.prototype.disposeData=function(t){throw new Error("Not yet implemented.")},t.prototype.write=function(t,e){throw new Error("Not yet implemented.")},t.prototype.fromPixels=function(t,e){throw new Error("Not yet implemented.")},t.prototype.register=function(t,e,n){throw new Error("Not yet implemented.")},t.prototype.memory=function(){throw new Error("Not yet implemented.")},t.prototype.floatPrecision=function(){throw new Error("Not yet implemented")},t.prototype.epsilon=function(){return 32===this.floatPrecision()?1e-7:1e-4},t.prototype.batchMatMul=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.fusedBatchMatMul=function(t,e,n,r,o,a){throw new Error("Not yet implemented")},t.prototype.slice=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.stridedSlice=function(t,e,n,r,o,a,i,s,u){throw new Error("Not yet implemented")},t.prototype.unstack=function(t,e){throw new Error("Not yet implemented")},t.prototype.reverse=function(t,e){throw new Error("Not yet implemented")},t.prototype.concat=function(t,e){throw new Error("Not yet implemented")},t.prototype.neg=function(t){throw new Error("Not yet implemented")},t.prototype.add=function(t,e){throw new Error("Not yet implemented")},t.prototype.addN=function(t){throw new Error("Not yet implemented")},t.prototype.subtract=function(t,e){throw new Error("Not yet implemented")},t.prototype.multiply=function(t,e){throw new Error("Not yet implemented")},t.prototype.realDivide=function(t,e){throw new Error("Not yet implemented")},t.prototype.floorDiv=function(t,e){throw new Error("Not yet implemented")},t.prototype.sum=function(t,e){throw new Error("Not yet implemented")},t.prototype.prod=function(t,e){throw new Error("Not yet implemented")},t.prototype.unsortedSegmentSum=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.argMin=function(t,e){throw new Error("Not yet implemented")},t.prototype.argMax=function(t,e){throw new Error("Not yet implemented")},t.prototype.equal=function(t,e){throw new Error("Not yet implemented")},t.prototype.notEqual=function(t,e){throw new Error("Not yet implemented")},t.prototype.less=function(t,e){throw new Error("Not yet implemented")},t.prototype.lessEqual=function(t,e){throw new Error("Not yet implemented")},t.prototype.greater=function(t,e){throw new Error("Not yet implemented")},t.prototype.greaterEqual=function(t,e){throw new Error("Not yet implemented")},t.prototype.logicalNot=function(t){throw new Error("Not yet implemented")},t.prototype.logicalAnd=function(t,e){throw new Error("Not yet implemented")},t.prototype.logicalOr=function(t,e){throw new Error("Not yet implemented")},t.prototype.where=function(t){throw new Error("Not yet implemented")},t.prototype.select=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.topk=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.min=function(t,e){throw new Error("Not yet implemented")},t.prototype.minimum=function(t,e){throw new Error("Not yet implemented")},t.prototype.mod=function(t,e){throw new Error("Not yet implemented")},t.prototype.max=function(t,e){throw new Error("Not yet implemented")},t.prototype.maximum=function(t,e){throw new Error("Not yet implemented")},t.prototype.all=function(t,e){throw new Error("Not yet implemented")},t.prototype.any=function(t,e){throw new Error("Not yet implemented")},t.prototype.squaredDifference=function(t,e){throw new Error("Not yet implemented")},t.prototype.ceil=function(t){throw new Error("Not yet implemented")},t.prototype.floor=function(t){throw new Error("Not yet implemented")},t.prototype.round=function(t){throw new Error("Not yet implemented")},t.prototype.sign=function(t){throw new Error("Not yet implemented")},t.prototype.isNaN=function(t){throw new Error("Not yet implemented")},t.prototype.isInf=function(t){throw new Error("Not yet implemented")},t.prototype.isFinite=function(t){throw new Error("Not yet implemented")},t.prototype.pow=function(t,e){throw new Error("Not yet implemented")},t.prototype.exp=function(t){throw new Error("Not yet implemented")},t.prototype.expm1=function(t){throw new Error("Not yet implemented")},t.prototype.log=function(t){throw new Error("Not yet implemented")},t.prototype.log1p=function(t){throw new Error("Not yet implemented")},t.prototype.sqrt=function(t){throw new Error("Not yet implemented")},t.prototype.rsqrt=function(t){throw new Error("Not yet implemented")},t.prototype.square=function(t){throw new Error("Not yet implemented")},t.prototype.reciprocal=function(t){throw new Error("Not yet implemented")},t.prototype.relu=function(t){throw new Error("Not yet implemented")},t.prototype.prelu=function(t,e){throw new Error("Not yet implemented")},t.prototype.elu=function(t){throw new Error("Not yet implemented")},t.prototype.eluDer=function(t,e){throw new Error("Not yet implemented")},t.prototype.selu=function(t){throw new Error("Not yet implemented")},t.prototype.int=function(t){throw new Error("Not yet implemented")},t.prototype.clip=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.abs=function(t){throw new Error("Not yet implemented")},t.prototype.complexAbs=function(t){throw new Error("Not yet implemented")},t.prototype.sigmoid=function(t){throw new Error("Not yet implemented")},t.prototype.softplus=function(t){throw new Error("Not yet implemented")},t.prototype.sin=function(t){throw new Error("Not yet implemented")},t.prototype.cos=function(t){throw new Error("Not yet implemented")},t.prototype.tan=function(t){throw new Error("Not yet implemented")},t.prototype.asin=function(t){throw new Error("Not yet implemented")},t.prototype.acos=function(t){throw new Error("Not yet implemented")},t.prototype.atan=function(t){throw new Error("Not yet implemented")},t.prototype.atan2=function(t,e){throw new Error("Not yet implemented")},t.prototype.sinh=function(t){throw new Error("Not yet implemented")},t.prototype.cosh=function(t){throw new Error("Not yet implemented")},t.prototype.tanh=function(t){throw new Error("Not yet implemented")},t.prototype.asinh=function(t){throw new Error("Not yet implemented")},t.prototype.acosh=function(t){throw new Error("Not yet implemented")},t.prototype.atanh=function(t){throw new Error("Not yet implemented")},t.prototype.erf=function(t){throw new Error("Not yet implemented")},t.prototype.step=function(t,e){throw new Error("Not yet implemented")},t.prototype.conv2d=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.conv2dDerInput=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.conv2dDerFilter=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.depthwiseConv2D=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.depthwiseConv2DDerInput=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.depthwiseConv2DDerFilter=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.conv3d=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.conv3dDerInput=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.conv3dDerFilter=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.maxPool=function(t,e){throw new Error("Not yet implemented")},t.prototype.maxPoolBackprop=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.avgPool=function(t,e){throw new Error("Not yet implemented")},t.prototype.avgPoolBackprop=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.reshape=function(t,e){throw new Error("Not yet implemented")},t.prototype.cast=function(t,e){throw new Error("Not yet implemented")},t.prototype.tile=function(t,e){throw new Error("Not yet implemented")},t.prototype.pad=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.transpose=function(t,e){throw new Error("Not yet implemented")},t.prototype.gather=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.gatherND=function(t,e){throw new Error("Not yet implemented")},t.prototype.scatterND=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.batchToSpaceND=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.spaceToBatchND=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.resizeBilinear=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.resizeBilinearBackprop=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.resizeNearestNeighbor=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.resizeNearestNeighborBackprop=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.batchNormalization=function(t,e,n,r,o,a){throw new Error("Not yet implemented")},t.prototype.localResponseNormalization4D=function(t,e,n,r,o){throw new Error("Not yet implemented")},t.prototype.LRNGrad=function(t,e,n,r,o,a,i){throw new Error("Not yet implemented")},t.prototype.multinomial=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.oneHot=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.cumsum=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.nonMaxSuppression=function(t,e,n,r,o){throw new Error("Not yet implemented")},t.prototype.fft=function(t){throw new Error("Not yet implemented")},t.prototype.ifft=function(t){throw new Error("Not yet implemented")},t.prototype.complex=function(t,e){throw new Error("Not yet implemented")},t.prototype.real=function(t){throw new Error("Not yet implemented")},t.prototype.imag=function(t){throw new Error("Not yet implemented")},t.prototype.cropAndResize=function(t,e,n,r,o,a){throw new Error("Not yet implemented")},t.prototype.depthToSpace=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.split=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.sparseToDense=function(t,e,n,r){throw new Error("Not yet implemented")},t.prototype.fill=function(t,e,n){throw new Error("Not yet implemented.")},t.prototype.onesLike=function(t){throw new Error("Not yet implemented")},t.prototype.zerosLike=function(t){throw new Error("Not yet implemented")},t.prototype.linspace=function(t,e,n){throw new Error("Not yet implemented")},t.prototype.dispose=function(){throw new Error("Not yet implemented")},t}();function Jn(t,e,n){if("complex64"===e){if("complex64"===t.dtype)return t.clone();var r=qn(t.shape),o=t.toFloat(),a=n.complex(o,r);return r.dispose(),o.dispose(),a}if(!O(t.dtype,e))return ft.make(t.shape,{dataId:t.dataId},e);if("complex64"===t.dtype){var i=n.real(t);a=i.cast(e);return i.dispose(),a}if("int32"===e)return n.int(t);if("bool"===e){var s=Bn(0,t.dtype);a=n.notEqual(t,s);return s.dispose(),a}throw new Error("Error in Cast: unknown dtype argument ("+e+")")}function Zn(t,e){return ft.make(e,{dataId:t.dataId},t.dtype)}function tr(t,e,n){var r=(e-t)/(n-1),o=$(n,"float32");o[0]=t;for(var a=1;a<o.length;a++)o[a]=o[a-1]+r;return Pn(o,"float32")}function er(t,e){if(t.length!==e.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+t.length+", imag: "+e.length+".");for(var n=new Float32Array(2*t.length),r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function nr(t,e){return{real:t[2*e],imag:t[2*e+1]}}function rr(t,e,n,r){t[2*r]=e,t[2*r+1]=n}function or(t,e,n){var r=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(r),imag:Math.sin(r)}}function ar(t,e,n,r,o){for(var a=Array.from(e).map(function(t,e){return{score:t,boxIndex:e}}).filter(function(t){return t.score>o}).sort(function(t,e){return e.score-t.score}),i=[],s=0;s<a.length;s++){var u=a[s],l=u.score,c=u.boxIndex;if(l<o)break;for(var h=!1,p=i.length-1;p>=0;--p){if(ir(t,c,i[p])>=r){h=!0;break}}if(!h&&(i.push(c),i.length>=n))break}return Pn(i,"int32")}function ir(t,e,n){var r=t.subarray(4*e,4*e+4),o=t.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),s=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(o[0],o[2]),c=Math.min(o[1],o[3]),h=Math.max(o[0],o[2]),p=Math.max(o[1],o[3]),f=(s-a)*(u-i),d=(h-l)*(p-c);if(f<=0||d<=0)return 0;var v=Math.max(a,l),m=Math.max(i,c),g=Math.min(s,h),y=Math.min(u,p),x=Math.max(g-v,0)*Math.max(y-m,0);return x/(f+d-x)}function sr(t,e,n){var r=new Array(t.rank).fill(0),o=t.shape.slice();return e.map(function(e){o[n]=e;var a=t.slice(r,o);return r[n]+=e,a})}function ur(t,e,n,r,o){for(var a=e[e.length-1],i=[t.length/a,a],s=i[0],u=i[1],l=I(n,s*r),c=I("int32",s*r),h=0;h<s;h++){for(var p=h*u,f=t.subarray(p,p+u),d=[],v=0;v<f.length;v++)d.push({value:f[v],index:v});d.sort(function(t,e){return e.value-t.value});var m=h*r,g=l.subarray(m,m+r),y=c.subarray(m,m+r);for(v=0;v<r;v++)g[v]=d[v].value,y[v]=d[v].index}var x=e.slice();return x[x.length-1]=r,[Fn(l,x,n),Fn(c,x,"int32")]}var lr=An({concat_:function(t,e){void 0===e&&(e=0),d(t.length>=1,function(){return"Pass at least one tensor to concat"});var n=bn(t,"tensors","concat");e=N(e,n[0].shape)[0];var r=sn(n.map(function(t){return t.shape}),e);if(0===y(r))return Fn([],r);if(1===(n=n.filter(function(t){return t.size>0})).length)return n[0];var o=n.map(function(t){return t.shape});!function(t,e){var n=t[0].length;t.forEach(function(t,e){d(t.length===n,function(){return"Error in concat"+n+"D: rank of tensors["+e+"] must be the same as the rank of the rest ("+n+")"})}),d(e>=0&&e<n,function(){return"Error in concat"+n+"D: axis must be between 0 and "+(n-1)+"."});var r=t[0];t.forEach(function(t,o){for(var a=0;a<n;a++)d(a===e||t[a]===r[a],function(){return"Error in concat"+n+"D: Shape of tensors["+o+"] ("+t+") does not match the shape of the rest ("+r+") along the non-concatenated axis "+o+"."})})}(o,e);var a=n;return Dt.runKernel(function(t){return t.concat(n,e)},a,function(t){var n=o.map(function(t){return t[e]});return dr(t,n,e).map(function(t){return function(){return t}})})}}),cr=An({concat1d_:function(t){return lr(t,0)}}),hr=An({concat2d_:function(t,e){return lr(t,e)}}),pr=An({concat3d_:function(t,e){return lr(t,e)}}),fr=An({concat4d_:function(t,e){return lr(t,e)}}),dr=An({split_:function(t,e,n){void 0===n&&(n=0);var r,o=wn(t,"x","split");return n=N(n,o.shape)[0],"number"==typeof e?(d(o.shape[n]%e==0,function(){return"Number of splits must evenly divide the axis."}),r=new Array(e).fill(o.shape[n]/e)):(d(o.shape[n]===e.reduce(function(t,e){return t+e}),function(){return"The sum of sizes must match the size of the axis dimension."}),r=e),Dt.runKernel(function(t){return t.split(o,r,n)},{$x:o},function(t){return{$x:function(){return lr(t,n)}}})}});"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;function vr(t,e){return t(e={exports:{}},e.exports),e.exports}var mr=vr(function(t){!function(t,e,n){function r(t){var e,n=this,r=(e=4022871197,function(t){t=t.toString();for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(t),n.s0<0&&(n.s0+=1),n.s1-=r(t),n.s1<0&&(n.s1+=1),n.s2-=r(t),n.s2<0&&(n.s2+=1),r=null}function o(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function a(t,e){var n=new r(t),a=e&&e.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+1.1102230246251565e-16*(2097152*i()|0)},i.quick=i,a&&("object"==typeof a&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n(function(){return a}):this.alea=a}(0,t,!1)}),gr=vr(function(t){!function(t,e,n){function r(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function a(t,e){var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&("object"==typeof a&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n(function(){return a}):this.xor128=a}(0,t,!1)}),yr=vr(function(t){!function(t,e,n){function r(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),r==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function a(t,e){var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&("object"==typeof a&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n(function(){return a}):this.xorwow=a}(0,t,!1)}),xr=vr(function(t){!function(t,e,n){function r(t){var e=this;e.next=function(){var t,n,r=e.x,o=e.i;return t=r[o],n=(t^=t>>>7)^t<<24,n^=(t=r[o+1&7])^t>>>10,n^=(t=r[o+3&7])^t>>>3,n^=(t=r[o+4&7])^t<<7,t=r[o+7&7],n^=(t^=t<<13)^t<<9,r[o]=n,e.i=o+1&7,n},function(t,e){var n,r=[];if(e===(0|e))r[0]=e;else for(e=""+e,n=0;n<e.length;++n)r[7&n]=r[7&n]<<15^e.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],t.x=r,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function o(t,e){return e.x=t.x.slice(),e.i=t.i,e}function a(t,e){null==t&&(t=+new Date);var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&(a.x&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n(function(){return a}):this.xorshift7=a}(0,t,!1)}),wr=vr(function(t){!function(t,e,n){function r(t){var e=this;e.next=function(){var t,n,r=e.w,o=e.X,a=e.i;return e.w=r=r+1640531527|0,n=o[a+34&127],t=o[a=a+1&127],n^=n<<13,t^=t<<17,n^=n>>>15,t^=t>>>12,n=o[a]=n^t,e.i=a,n+(r^r>>>16)|0},function(t,e){var n,r,o,a,i,s=[],u=128;for(e===(0|e)?(r=e,e=null):(e+="\0",r=0,u=Math.max(u,e.length)),o=0,a=-32;a<u;++a)e&&(r^=e.charCodeAt((a+32)%e.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(e&&e.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;t.w=i,t.X=s,t.i=o}(e,t)}function o(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function a(t,e){null==t&&(t=+new Date);var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&(a.X&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n(function(){return a}):this.xor4096=a}(0,t,!1)}),br=vr(function(t){!function(t,e,n){function r(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,r=e.d,o=e.a;return t=t<<25^t>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-r|0,e.d=r<<16^n>>>16^o,e.a=o-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var r=0;r<n.length+20;r++)e.b^=0|n.charCodeAt(r),e.next()}function o(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function a(t,e){var n=new r(t),a=e&&e.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},i.int32=n.next,i.quick=i,a&&("object"==typeof a&&o(a,n),i.state=function(){return o(n,{})}),i}e&&e.exports?e.exports=a:n&&n.amd?n(function(){return a}):this.tychei=a}(0,t,!1)}),Cr=vr(function(t){!function(e,n){var r,o=this,a=256,i=6,s="random",u=n.pow(a,i),l=n.pow(2,52),c=2*l,h=a-1;function p(t,h,p){var g=[],y=v(function t(e,n){var r,o=[],a=typeof e;if(n&&"object"==a)for(r in e)try{o.push(t(e[r],n-1))}catch(t){}return o.length?o:"string"==a?e:e+"\0"}((h=1==h?{entropy:!0}:h||{}).entropy?[t,m(e)]:null==t?function(){try{var t;return r&&(t=r.randomBytes)?t=t(a):(t=new Uint8Array(a),(o.crypto||o.msCrypto).getRandomValues(t)),m(t)}catch(t){var n=o.navigator,i=n&&n.plugins;return[+new Date,o,i,o.screen,m(e)]}}():t,3),g),x=new f(g),w=function(){for(var t=x.g(i),e=u,n=0;t<l;)t=(t+n)*a,e*=a,n=x.g(1);for(;t>=c;)t/=2,e/=2,n>>>=1;return(t+n)/e};return w.int32=function(){return 0|x.g(4)},w.quick=function(){return x.g(4)/4294967296},w.double=w,v(m(x.S),e),(h.pass||p||function(t,e,r,o){return o&&(o.S&&d(o,x),t.state=function(){return d(x,{})}),r?(n[s]=t,e):t})(w,y,"global"in h?h.global:this==n,h.state)}function f(t){var e,n=t.length,r=this,o=0,i=r.i=r.j=0,s=r.S=[];for(n||(t=[n++]);o<a;)s[o]=o++;for(o=0;o<a;o++)s[o]=s[i=h&i+t[o%n]+(e=s[o])],s[i]=e;(r.g=function(t){for(var e,n=0,o=r.i,i=r.j,s=r.S;t--;)e=s[o=h&o+1],n=n*a+s[h&(s[o]=s[i=h&i+e])+(s[i]=e)];return r.i=o,r.j=i,n})(a)}function d(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function v(t,e){for(var n,r=t+"",o=0;o<r.length;)e[h&o]=h&(n^=19*e[h&o])+r.charCodeAt(o++);return m(e)}function m(t){return String.fromCharCode.apply(0,t)}if(n["seed"+s]=p,v(n.random(),e),t.exports){t.exports=p;try{r=__webpack_require__(/*! crypto */ "./node_modules/crypto-browserify/index.js")}catch(t){}}}([],Math)});Cr.alea=mr,Cr.xor128=gr,Cr.xorwow=yr,Cr.xorshift7=xr,Cr.xor4096=wr,Cr.tychei=br;var Er=Cr.alea,Rr=function(){function t(t,e,n,r,o){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);var a=o||Math.random();this.random=Er(a.toString())}return t.prototype.nextValue=function(){if(!isNaN(this.nextVal)){var t=this.nextVal;return this.nextVal=NaN,t}for(var e,n,r=!1;!r;){var o=void 0,a=void 0,i=void 0;do{i=(o=2*this.random()-1)*o+(a=2*this.random()-1)*a}while(i>=1||0===i);var s=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*o*s,n=this.mean+this.stdDev*a*s,this.truncated&&!this.isValidTruncated(e)||(r=!0)}return this.truncated&&!this.isValidTruncated(n)||(this.nextVal=this.convertValue(n)),this.convertValue(e)},t.prototype.convertValue=function(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)},t.prototype.isValidTruncated=function(t){return t<=this.upper&&t>=this.lower},t}(),Sr=function(){function t(t,e,n,r){void 0===t&&(t=0),void 0===e&&(e=1),void 0===r&&(r=Math.random());var o=this;if(this.canReturnFloat=function(){return null==o.dtype||"float32"===o.dtype},this.min=t,this.range=e-t,this.dtype=n,!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between "+t+" - "+e+" <= 1 and dtype is not float");this.random=Er(r.toString())}return t.prototype.convertValue=function(t){return this.canReturnFloat()?t:Math.round(t)},t.prototype.nextValue=function(){return this.convertValue(this.min+this.range*this.random())},t}();function Nr(t,e,n){return void 0===e&&(e="float32"),e=e||"float32",K(t),new lt(t,e,n)}function kr(t,e){void 0===e&&(e=!1),console.log(t.toString(e))}var Ir=An({batchToSpaceND_:function(t,e,n){var r=wn(t,"x","batchToSpaceND"),o=e.reduce(function(t,e){return t*e});return d(r.rank>=1+e.length,function(){return"input rank is "+r.rank+" but should be > than blockShape.length "+e.length}),d(n.length===e.length,function(){return"crops.length is "+n.length+" but should be equal to blockShape.length  "+e.length}),d(r.shape[0]%o==0,function(){return"input tensor batch is "+r.shape[0]+" but is not divisible by the product of the elements of blockShape "+e.join(" * ")+" === "+o}),Dt.runKernel(function(t){return t.batchToSpaceND(r,e,n)},{$x:r},function(t){return{$x:function(){return t.spaceToBatchND(e,n)}}})}}),Ar=An({cast_:function(t,e){var n=wn(t,"x","cast");return Dt.runKernel(function(t){return t.cast(n,e)},{$x:n},function(t){return{$x:function(){return t.clone()}}})}}),Tr=An({clone_:function(t){var e=wn(t,"x","clone",null);return Dt.runKernel(function(t){return ft.make(e.shape,{dataId:e.dataId},e.dtype)},{$x:e},function(t){return{$x:function(){return t.toFloat()}}})}}),Dr=An({cumsum_:function(t,e,n,r){void 0===e&&(e=0),void 0===n&&(n=!1),void 0===r&&(r=!1);var o=wn(t,"x","cumsum"),a=rn([e|=0],o.rank),i=o;null!=a&&(i=o.transpose(a));var s=an(1,o.rank)[0],u=Dt.runKernel(function(t){return t.cumsum(i,s,n,r)},{permutedX:i},function(t){return{permutedX:function(){return t.cumsum(e,n,!r)}}});return null!=a&&(u=u.transpose(a)),u}}),Or=An({depthToSpace_:function(t,e,n){void 0===n&&(n="NHWC");var r=wn(t,"x","depthToSpace"),o="NHWC"===n?r.shape[1]:r.shape[2],a="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];return d(o*e>=0,function(){return"Negative dimension size caused by overflow when multiplying\n      "+o+" and "+e+"  for depthToSpace with input shape\n      "+r.shape}),d(a*e>=0,function(){return"Negative dimension size caused by overflow when multiplying\n      "+a+" and "+e+" for depthToSpace with input shape\n          "+r.shape}),d(i%(e*e)==0,function(){return"Dimension size must be evenly divisible by "+e*e+" but is "+i+" for depthToSpace with input shape "+r.shape}),Dt.runKernel(function(t){return t.depthToSpace(r,e,n)},{$x:r})}}),_r=An({expandDims_:function(t,e){void 0===e&&(e=0);var n=wn(t,"x","expandDims");d(e<=n.rank,function(){return"Axis must be <= rank of the tensor"});var r=n.shape.slice();return e<0&&(d(-(n.rank+1)<=e,function(){return"Axis must be in the interval ["+-(n.rank+1)+", "+n.rank+"]"}),e=n.rank+e+1),r.splice(e,0,1),Hr(n,r)}}),Mr=An({eye_:function(t,e,n,r){void 0===r&&(r="float32"),null==e&&(e=t);for(var o=Nr([t,e],r),a=t<=e?t:e,i=0;i<a;++i)o.set(1,i,i);var s=o.toTensor().as2D(t,e);if(null==n)return s;if(1===n.length)return Xr(_r(s,0),[n[0],1,1]);if(2===n.length)return Xr(_r(_r(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return Xr(_r(_r(_r(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D batchShapes, but received "+n.length+"D.")}}),Fr=An({multinomial_:function(t,e,n,r){void 0===r&&(r=!1);var o=wn(t,"logits","multinomial"),a=o.size,i=o.rank;if(a<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+a+".");if(i>2)throw new Error("Rank of probabilities must be 1 or 2, but is "+i);n=n||Math.random();var s=1===i?o.as2D(1,-1):o,u=Dt.runKernel(function(t){return t.multinomial(s,r,e,n)},{logits2D:s});return 1===i?u.as1D():u}}),Br=An({oneHot_:function(t,e,n,r){if(void 0===n&&(n=1),void 0===r&&(r=0),e<2)throw new Error("Error in oneHot: depth must be >=2, but it is "+e);var o=wn(t,"indices","oneHot","int32"),a=o.shape.concat([e]);return o=o.flatten(),Dt.runKernel(function(t){return t.oneHot(o,e,n,r)},{$indices:o},function(t){return{$indices:function(){return qn(o.shape,"float32")}}}).reshape(a)}}),Pr=An({pad_:function(t,e,n){void 0===n&&(n=0);var r=wn(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");var o=e.map(function(t){return t[0]});return Dt.runKernel(function(t){return t.pad(r,e,n)},{$x:r},function(t){return{$x:function(){return t.slice(o,r.shape)}}})}}),Lr=An({pad1d_:function(t,e,n){return void 0===n&&(n=0),d(2===e.length,function(){return"Invalid number of paddings. Must be length of 2."}),Pr(t,[e],n)}}),Wr=An({pad2d_:function(t,e,n){return void 0===n&&(n=0),d(2===e.length&&2===e[0].length&&2===e[1].length,function(){return"Invalid number of paddings. Must be length of 2 each."}),Pr(t,e,n)}}),Ur=An({pad3d_:function(t,e,n){return void 0===n&&(n=0),d(3===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length,function(){return"Invalid number of paddings. Must be length of 2 each."}),Pr(t,e,n)}}),zr=An({pad4d_:function(t,e,n){return void 0===n&&(n=0),d(4===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length&&2===e[3].length,function(){return"Invalid number of paddings. Must be length of 2 each."}),Pr(t,e,n)}}),Vr=An({rand_:function(t,e,n){var r=y(t),o=null;if(null==n||"float32"===n)o=new Float32Array(r);else if("int32"===n)o=new Int32Array(r);else{if("bool"!==n)throw new Error("Unknown data type "+n);o=new Uint8Array(r)}for(var a=0;a<r;a++)o[a]=e();return ft.make(t,{values:o},n)}}),Gr=An({randomNormal_:function(t,e,n,r,o){if(void 0===e&&(e=0),void 0===n&&(n=1),null!=r&&"bool"===r)throw new Error("Unsupported data type "+r);for(var a=new Rr(e,n,r,!1,o),i=Nr(t,r),s=0;s<i.values.length;s++)i.values[s]=a.nextValue();return i.toTensor()}}),qr=An({randomUniform_:function(t,e,n,r,o){void 0===e&&(e=0),void 0===n&&(n=1),void 0===r&&(r="float32");for(var a=Nr(t,r),i=new Sr(e,n,null,o),s=0;s<a.values.length;s++)a.values[s]=i.nextValue();return a.toTensor()}}),Hr=An({reshape_:function(t,e){var n=wn(t,"x","reshape",null);return e=S(e,n.size),d(n.size===y(e),function(){return"new shape and old shape must have the same number of elements."}),Dt.runKernel(function(t){return t.reshape(n,e)},{$x:n},function(t){return{$x:function(){return t.reshape(n.shape)}}})}}),$r=An({spaceToBatchND_:function(t,e,n){var r=wn(t,"x","spaceToBatchND");return d(r.rank>=1+e.length,function(){return"input rank "+r.rank+" should be > than [blockShape] "+e.length}),d(n.length===e.length,function(){return"paddings.shape[0] "+n.length+" must be equal to [blockShape] "+e.length}),d(r.shape.reduce(function(t,r,o){return o>0&&o<=e.length?t&&(r+n[o-1][0]+n[o-1][1])%e[o-1]==0:t},!0),function(){return"input spatial dimensions "+r.shape.slice(1)+" with paddings "+n.toString()+" must be divisible by blockShapes "+e.toString()}),Dt.runKernel(function(t){return t.spaceToBatchND(r,e,n)},{$x:r},function(t){return{$x:function(){return t.batchToSpaceND(e,n)}}})}}),jr=An({squeeze_:function(t,e){var n=wn(t,"x","squeeze");return Hr(n,k(n.shape,e).newShape)}}),Kr=An({stack_:function(t,e){void 0===e&&(e=0);var n=bn(t,"tensors","stack");if(d(n.length>=1,function(){return"Pass at least one tensor to tf.stack"}),1===n.length)return n[0].expandDims(e);var r=n[0].rank,o=n[0].shape,a=n[0].dtype;d(e<=r,function(){return"Axis must be <= rank of the tensor"}),n.forEach(function(t){v(o,t.shape,"All tensors passed to stack must have matching shapes")}),n.forEach(function(t){d(a===t.dtype,function(){return"All tensors passed to stack must have matching dtypes"})});var i=n.map(function(t){return t.expandDims(e)});return lr(i,e)}}),Xr=An({tile_:function(t,e){var n=wn(t,"x","tile");return d(n.rank===e.length,function(){return"Error in transpose: rank of input "+n.rank+" must match length of reps "+e+"."}),Dt.runKernel(function(t,r){var o=t.tile(n,e);return r([n]),o},{$x:n},function(t,n){var r=n[0];return{$x:function(){var n=Xn(r);if(1===r.rank)for(var o=0;o<e[0];++o)n=n.add(t.slice([o*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(o=0;o<e[0];++o)for(var a=0;a<e[1];++a)n=n.add(t.slice([o*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(o=0;o<e[0];++o)for(a=0;a<e[1];++a)for(var i=0;i<e[2];++i)n=n.add(t.slice([o*r.shape[0],a*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+r.rank+" tensors yet.");for(o=0;o<e[0];++o)for(a=0;a<e[1];++a)for(i=0;i<e[2];++i)for(var s=0;s<e[3];++s)n=n.add(t.slice([o*r.shape[0],a*r.shape[1],i*r.shape[2],s*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return n}}})}}),Yr=An({truncatedNormal_:function(t,e,n,r,o){if(void 0===e&&(e=0),void 0===n&&(n=1),null!=r&&"bool"===r)throw new Error("Unsupported data type "+r);for(var a=new Rr(e,n,r,!0,o),i=Nr(t,r),s=0;s<i.values.length;s++)i.values[s]=a.nextValue();return i.toTensor()}}),Qr=An({unstack_:function(t,e){void 0===e&&(e=0),e=e||0;var n=wn(t,"x","unstack");return d(e>=-n.shape.length&&e<n.shape.length,function(){return"Axis = "+e+" is not in [-"+n.shape.length+", "+n.shape.length+")"}),e<0&&(e+=n.shape.length),Dt.runKernel(function(t){return t.unstack(n,e)},{$x:n},function(t){return{$x:function(){return Kr(t,e)}}})}}),Jr=function(t,e){return r(this,void 0,void 0,function(){var n,r,a,i,s,u,l,c,h,p;return o(this,function(o){switch(o.label){case 0:return n=wn(t,"x","setdiff1d"),r=wn(e,"y","setdiff1d"),d(n.dtype===r.dtype,function(){return"x and y should have the same dtype, but got x ("+n.dtype+") and y ("+r.dtype+")."}),d(1===n.rank,function(){return"x should be 1D tensor, but got x ("+n.shape+")."}),d(1===r.rank,function(){return"y should be 1D tensor, but got y ("+r.shape+")."}),[4,n.data()];case 1:return a=o.sent(),[4,r.data()];case 2:for(i=o.sent(),s=new Set(i),u=0,h=0;h<a.length;h++)s.has(a[h])||u++;for(l=new lt([u],n.dtype),c=new lt([u],"int32"),h=0,p=0;h<a.length;h++)s.has(a[h])||(l.values[p]=a[h],c.values[p]=h,p++);return[2,[l.toTensor(),c.toTensor()]]}})})};function Zr(t,e){for(var n=[],r=0;r<e.length;r++)e[r]&&n.push(r);var o=Nr(t,"int32"),a=Nr([n.length,t.length],"int32");for(r=0;r<n.length;r++){var i=o.indexToLoc(n[r]),s=r*t.length;a.values.set(i,s)}return a.toTensor()}var to=function(){return function(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map(function(t,e){return"T"+e});var n=[];this.variableNames.forEach(function(t){n.push("float v"+t+" = get"+t+"AtOutCoords();")});var r=this.variableNames.map(function(t){return"v"+t}).join(" + ");this.userCode="\n      void main() {\n        "+n.join("\n        ")+"\n\n        float result = "+r+";\n        setOutput(result);\n      }\n    "}}(),eo=function(){return function(t,e){this.outputShape=[],this.usesPackedTextures=!0,this.outputShape=t,this.variableNames=e.map(function(t,e){return"T"+e});var n=[];this.variableNames.forEach(function(t){n.push("vec4 v"+t+" = get"+t+"AtOutCoords();")});var r=this.variableNames.map(function(t){return"v"+t}).join(" + ");this.userCode="\n      void main() {\n        "+n.join("\n        ")+"\n\n        vec4 result = "+r+";\n        setOutput(result);\n      }\n    "}}(),no=function(){return function(t,e,n){this.variableNames=["A"];var r=t.windowSize,o=t.batchSize,a=t.inSize,i=Math.ceil(a/r);n||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i];var s="max"===e?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+r+";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < "+r+"; i++) {\n          int inIdx = "+u+";\n          float candidate = getA(batch, inIdx);\n          if (candidate "+s+" bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    "}}();function ro(t,e){return["x","y","z","w","u","v"].slice(0,e).map(function(e){return t+"."+e})}function oo(t,e){return 1===e?[t]:ro(t,e)}function ao(t,e){for(var n=t.length,r=[],o=0;o<n;o++){var a=n-1-o,i=t[a]||1;(e[e.length-1-o]||1)>1&&1===i&&r.unshift(a)}return r}function io(t,e){for(var n=[],r=0;r<e.length;r++){var o=t[t.length-r-1],a=e.length-r-1,i=e[a];(null==o||1===o&&i>1)&&n.unshift(a)}return n}function so(t,e){for(var n=[],r=Math.max(t.length,e.length),o=0;o<r;o++){var a=t[t.length-o-1];null==a&&(a=1);var i=e[e.length-o-1];if(null==i&&(i=1),1===a)n.unshift(i);else if(1===i)n.unshift(a);else{if(a!==i)throw Error("Operands could not be broadcast together with shapes "+t+" and "+e+".");n.unshift(a)}}return n}function uo(){var t,e,n,r,o,i,s,u,l,c;return 2===a.getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",r="in",o="texture",i="outputColor",s="out vec4 outputColor;",u="\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 0. || val == 0.) ? false : true;\n      }\n    ",l="\n      const float INFINITY = uintBitsToFloat(uint(0x7f800000));\n    ",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",r="varying",o="texture2D",i="gl_FragColor",s="",u="\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:o,output:i,defineOutput:s,defineSpecialNaN:u,defineSpecialInf:l,defineRound:c}}function lo(t,e,n){void 0===n&&(n="index");var r=V(e);return r.map(function(e,o){return"int "+t[o]+" = "+n+" / "+e+"; "+(o===r.length-1?"int "+t[o+1]+" = "+n+" - "+t[o]+" * "+e:"index -= "+t[o]+" * "+e)+";"}).join("")}function co(t){return 1===t.length?""+t[0]:"vec"+t.length+"("+t.join(",")+")"}function ho(t,e,n,r){var o=[];t.forEach(function(t){var e=y(t.shapeInfo.logicalShape);t.shapeInfo.isUniform?o.push("uniform float "+t.name+(e>1?"["+e+"]":"")+";"):(o.push("uniform sampler2D "+t.name+";"),o.push("uniform int offset"+t.name+";"))});var a,i,s=o.join("\n"),u=t.map(function(t){return function(t,e,n){void 0===n&&(n=!1);var r="";r+=n?fo(t):po(t);var o=t.shapeInfo.logicalShape,a=e.logicalShape;o.length<=a.length&&(r+=n?function(t,e){var n,r=t.name,o=r.charAt(0).toUpperCase()+r.slice(1),a="get"+o+"AtOutCoords",i=t.shapeInfo.logicalShape.length,s=e.logicalShape.length,u=ao(t.shapeInfo.logicalShape,e.logicalShape),l=bo(s),c=s-i,h=["x","y","z","w","u","v"];n=0===i?"":s<2&&u.length>=1?"coords = 0;":u.map(function(t){return"coords."+h[t+c]+" = 0;"}).join("\n");var p="";p=s<2&&i>0?"coords":t.shapeInfo.logicalShape.map(function(t,e){return"coords."+h[e+c]}).join(", ");var f="return outputValue;",d=1===y(t.shapeInfo.logicalShape),v=1===y(e.logicalShape);if(1!==i||d||v){if(d&&!v)f=1===s?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(u.length){var m=i-2,g=i-1;u.indexOf(m)>-1&&u.indexOf(g)>-1?f="return vec4(outputValue.x);":u.indexOf(m)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":u.indexOf(g)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 "+a+"() {\n      "+l+" coords = getOutputCoords();\n      "+n+"\n      vec4 outputValue = get"+o+"("+p+");\n      "+f+"\n    }\n  "}(t,e):function(t,e){var n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),o="get"+r+"AtOutCoords",a=e.texShape,i=t.shapeInfo.texShape,s=t.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!t.shapeInfo.isUniform&&s===u&&null==t.shapeInfo.flatOffset&&x(i,a))return"\n      float "+o+"() {\n        return sampleTexture("+n+", resultUV);\n      }\n    ";var l,c=bo(u),h=ao(t.shapeInfo.logicalShape,e.logicalShape),p=u-s,f=["x","y","z","w","u","v"];l=0===s?"":u<2&&h.length>=1?"coords = 0;":h.map(function(t){return"coords."+f[t+p]+" = 0;"}).join("\n");var d="";d=u<2&&s>0?"coords":t.shapeInfo.logicalShape.map(function(t,e){return"coords."+f[e+p]}).join(", ");return"\n    float "+o+"() {\n      "+c+" coords = getOutputCoords();\n      "+l+"\n      return get"+r+"("+d+");\n    }\n  "}(t,e));return r}(t,e,r)}).join("\n"),l=e.texShape,c=uo(),h=function(t){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return "+t.texture2D+"(textureSampler, uv).r;\n    }\n  "}(c),p=function(t){return t.version+"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    "+t.varyingFs+" vec2 resultUV;\n    "+t.defineOutput+"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    #define isnan(value) isnan_custom(value)\n    "+t.defineSpecialNaN+"\n    bvec4 isnan_custom(vec4 val) {\n      return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n    }\n\n    "+t.defineSpecialInf+"\n    "+t.defineRound+"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    "+vo+"\n    "+mo+"\n    "+go+"\n  "}(c);return e.isPacked?(a=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e){var n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(1===n[0])return"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * "+n[1]+".0);\n      }\n    ";if(1===n[1])return"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * "+n[0]+".0);\n      }\n    ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      return resTexRC.x * "+n[1]+" + resTexRC.y;\n    }\n  "}(0,e);case 2:return function(t,e){var n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(x(t,e))return"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2("+n[0]+", "+n[1]+"));\n      }\n    ";var r=Math.ceil(t[1]/2);return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n      int r = 2 * (index / "+r+");\n      int c = imod(index, "+r+") * 2;\n\n      return ivec2(r, c);\n    }\n  "}(t,e);case 3:return n=t,r=e,o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],a=Math.ceil(n[2]/2),i=a*Math.ceil(n[1]/2),"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+o[0]+", "+o[1]+"));\n      int index = resTexRC.x * "+o[1]+" + resTexRC.y;\n\n      int b = index / "+i+";\n      index -= b * "+i+";\n\n      int r = 2 * (index / "+a+");\n      int c = imod(index, "+a+") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";default:return function(t,e){for(var n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[t.length-1]/2),o=r*Math.ceil(t[t.length-2]/2),a=o,i="",s="b, r, c",u=2;u<t.length-1;u++)a*=t[t.length-u-1],i="\n      int b"+u+" = index / "+a+";\n      index -= b"+u+" * "+a+";\n    "+i,s="b"+u+", "+s;return"\n    ivec"+t.length+" getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n\n      "+i+"\n\n      int b = index / "+o+";\n      index -= b * "+o+";\n\n      int r = 2 * (index / "+r+");\n      int c = imod(index, "+r+") * 2;\n\n      return ivec"+t.length+"("+s+");\n    }\n  "}(t,e)}var n,r,o,a,i}(e.logicalShape,l),i=function(t){return"\n    void setOutput(vec4 val) {\n      "+t.output+" = val;\n    }\n  "}(c)):(a=function(t,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e){if(1===e[0])return"\n      int getOutputCoords() {\n        return int(resultUV.x * "+e[1]+".0);\n      }\n    ";if(1===e[1])return"\n      int getOutputCoords() {\n        return int(resultUV.y * "+e[0]+".0);\n      }\n    ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+e[0]+", "+e[1]+"));\n      return resTexRC.x * "+e[1]+" + resTexRC.y;\n    }\n  "}(0,e);case 2:return function(t,e){if(x(t,e))return"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2("+e[0]+", "+e[1]+"));\n      }\n    ";if(1===t[1])return"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+e[0]+", "+e[1]+"));\n        int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";if(1===t[0])return"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2("+e[0]+", "+e[1]+"));\n        int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+e[0]+", "+e[1]+"));\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n      int r = index / "+t[1]+";\n      int c = index - r * "+t[1]+";\n      return ivec2(r, c);\n    }\n  "}(t,e);case 3:return n=e,r=lo(["r","c","d"],t),"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2("+n[0]+", "+n[1]+"));\n      int index = resTexRC.x * "+n[1]+" + resTexRC.y;\n      "+r+"\n      return ivec3(r, c, d);\n    }\n  ";case 4:return function(t,e){var n=lo(["r","c","d","d2"],t);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+e[0]+", "+e[1]+"));\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n      "+n+"\n      return ivec4(r, c, d, d2);\n    }\n  "}(t,e);case 5:return function(t,e){var n=lo(["r","c","d","d2","d3"],t);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2("+e[0]+",\n                             "+e[1]+"));\n\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n\n      "+n+"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  "}(t,e);case 6:return function(t,e){var n=lo(["r","c","d","d2","d3","d4"],t);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2("+e[0]+", "+e[1]+"));\n      int index = resTexRC.x * "+e[1]+" + resTexRC.y;\n\n      "+n+"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  "}(t,e);default:throw new Error(t.length+"-D output sampling is not yet supported")}var n,r}(e.logicalShape,l),i=function(t){return"\n    void setOutput(float val) {\n      "+t.output+" = vec4(val, 0, 0, 0);\n    }\n  "}(c)),r&&(p+=yo),[p,h,i,s,a,u,n].join("\n")}function po(t){var e=t.shapeInfo.logicalShape;switch(e.length){case 0:return function(t){var e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return"float "+n+"() {return "+e+";}";var r=t.shapeInfo.texShape,o=r[0],a=r[1];if(1===o&&1===a)return"\n      float "+n+"() {\n        return sampleTexture("+e+", halfCR);\n      }\n    ";var i=t.shapeInfo.texShape,s=i[0],u=i[1],l=xo(e);return"\n    float "+n+"() {\n      vec2 uv = uvFromFlat("+s+", "+u+", "+l+");\n      return sampleTexture("+e+", uv);\n    }\n  "}(t);case 1:return function(t){var e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return"\n      float "+n+"(int index) {\n        "+wo(t)+"\n      }\n    ";var r=t.shapeInfo.texShape,o=r[0],a=r[1];if(1===a&&1===o)return"\n      float "+n+"(int index) {\n        return sampleTexture("+e+", halfCR);\n      }\n    ";var i=xo(e);if(1===a)return"\n      float "+n+"(int index) {\n        vec2 uv = vec2(0.5, (float(index + "+i+") + 0.5) / "+o+".0);\n        return sampleTexture("+e+", uv);\n      }\n    ";if(1===o)return"\n      float "+n+"(int index) {\n        vec2 uv = vec2((float(index + "+i+") + 0.5) / "+a+".0, 0.5);\n        return sampleTexture("+e+", uv);\n      }\n    ";return"\n    float "+n+"(int index) {\n      vec2 uv = uvFromFlat("+o+", "+a+", index + "+i+");\n      return sampleTexture("+e+", uv);\n    }\n  "}(t);case 2:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t.shapeInfo.texShape;if(null!=o&&x(e,o)){var a=o[0],i=o[1];return"\n    float "+r+"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2("+i+".0, "+a+".0);\n      return sampleTexture("+n+", uv);\n    }\n  "}var s=k(e),u=s.newShape,l=s.keptDims,c=u;if(c.length<e.length){var h=Co(t,c);return"\n      "+po(h)+"\n      float "+r+"(int row, int col) {\n        return "+r+"("+Eo(["row","col"],l)+");\n      }\n    "}if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2("+e[1]+", 1)));\n        "+wo(t)+"\n      }\n    ";var p=o[0],f=o[1],d=xo(n);if(1===f)return"\n    float "+r+"(int row, int col) {\n      float index = dot(vec3(row, col, "+d+"), vec3("+e[1]+", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / "+p+".0);\n      return sampleTexture("+n+", uv);\n    }\n  ";if(1===p)return"\n    float "+r+"(int row, int col) {\n      float index = dot(vec3(row, col, "+d+"), vec3("+e[1]+", 1, 1));\n      vec2 uv = vec2((index + 0.5) / "+f+".0, 0.5);\n      return sampleTexture("+n+", uv);\n    }\n  ";return"\n  float "+r+"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * "+e[1]+" + col + "+d+";\n    vec2 uv = uvFromFlat("+p+", "+f+", index);\n    return sampleTexture("+n+", uv);\n  }\n"}(t);case 3:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e[1]*e[2],a=e[2],i=k(e),s=i.newShape,u=i.keptDims,l=s;if(l.length<e.length){var c=Co(t,l);return"\n        "+po(c)+"\n        float "+r+"(int row, int col, int depth) {\n          return "+r+"("+Eo(["row","col","depth"],u)+");\n        }\n      "}if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3("+o+", "+a+", 1)));\n        "+wo(t)+"\n      }\n    ";var h=t.shapeInfo.texShape,p=h[0],f=h[1],d=t.shapeInfo.flatOffset;if(f===o&&null==d)return"\n        float "+r+"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2("+a+", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2("+f+".0, "+p+".0);\n          return sampleTexture("+n+", uv);\n        }\n      ";if(f===a&&null==d)return"\n    float "+r+"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2("+e[1]+", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+f+".0, "+p+".0);\n      return sampleTexture("+n+", uv);\n    }\n  ";var v=xo(n);return"\n      float "+r+"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * "+o+" + col * "+a+" + depth + "+v+";\n        vec2 uv = uvFromFlat("+p+", "+f+", index);\n        return sampleTexture("+n+", uv);\n      }\n  "}(t);case 4:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e[3],a=e[2]*o,i=e[1]*a,s=k(e),u=s.newShape,l=s.keptDims;if(u.length<e.length){var c=Co(t,u);return"\n      "+po(c)+"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        return "+r+"("+Eo(["row","col","depth","depth2"],l)+");\n      }\n    "}if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4("+i+", "+a+", "+o+", 1)));\n        "+wo(t)+"\n      }\n    ";var h=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,f=p[0],d=p[1];if(d===i&&null==h)return"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3("+a+", "+o+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+d+".0, "+f+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";if(d===o&&null==h)return"\n      float "+r+"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3("+e[1]*e[2]+", "+e[2]+", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+d+".0, "+f+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";var v=xo(n);return"\n    float "+r+"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+i+" + col * "+a+" +\n          depth * "+o+" + depth2;\n      vec2 uv = uvFromFlat("+f+", "+d+", index + "+v+");\n      return sampleTexture("+n+", uv);\n    }\n  "}(t);case 5:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e[4],a=e[3]*o,i=e[2]*a,s=e[1]*i,u=k(e),l=u.newShape,c=u.keptDims;if(l.length<e.length){var h=Co(t,l);return"\n      "+po(h)+"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        return "+r+"("+Eo(["row","col","depth","depth2","depth3"],c)+");\n      }\n    "}if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+s+", "+i+", "+a+", "+o+")) +\n          depth3;\n        "+wo(t)+"\n      }\n    ";var p=t.shapeInfo.flatOffset,f=t.shapeInfo.texShape,d=f[0],v=f[1];if(v===s&&null==p)return"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4("+i+", "+a+", "+o+", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+v+".0, "+d+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";if(v===o&&null==p)return"\n      float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4("+e[1]*e[2]*e[3]+",\n               "+e[2]*e[3]+", "+e[3]+", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+v+".0, "+d+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";var m=xo(n);return"\n    float "+r+"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+s+" + col * "+i+" + depth * "+a+" +\n          depth2 * "+o+" + depth3 + "+m+";\n      vec2 uv = uvFromFlat("+d+", "+v+", index);\n      return sampleTexture("+n+", uv);\n    }\n  "}(t);case 6:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=k(e),a=o.newShape,i=o.keptDims;if(a.length<e.length){var s=Co(t,a);return"\n      "+po(s)+"\n      float "+r+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return "+r+"("+Eo(["row","col","depth","depth2","depth3","depth4"],i)+");\n      }\n    "}var u=e[5],l=e[4]*u,c=e[3]*l,h=e[2]*c,p=e[1]*h;if(t.shapeInfo.isUniform)return"\n      float "+r+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4("+p+", "+h+", "+c+", "+l+")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2("+u+", 1)));\n        "+wo(t)+"\n      }\n    ";var f=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,v=d[0],m=d[1];if(m===p&&null==f)return"\n      float "+r+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4("+h+", "+c+", "+l+", "+u+")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2("+m+".0, "+v+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";if(m===u&&null==f)return"\n      float "+r+"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4("+e[1]*e[2]*e[3]*e[4]+",\n               "+e[2]*e[3]*e[4]+",\n               "+e[3]*e[4]+",\n               "+e[4]+")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2("+m+".0, "+v+".0);\n        return sampleTexture("+n+", uv);\n      }\n    ";var g=xo(n);return"\n    float "+r+"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * "+p+" + col * "+h+" + depth * "+c+" +\n          depth2 * "+l+" + depth3 * "+u+" + depth4 + "+g+";\n      vec2 uv = uvFromFlat("+v+", "+m+", index);\n      return sampleTexture("+n+", uv);\n    }\n  "}(t);default:throw new Error(e.length+"-D input sampling is not yet supported")}}function fo(t){var e,n,r;switch(t.shapeInfo.logicalShape.length){case 0:return e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=uo(),"\n    vec4 "+n+"() {\n      return "+r.texture2D+"("+e+", halfCR);\n    }\n  ";case 1:return function(t){var e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t.shapeInfo.texShape,o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],a=uo();return"\n    vec4 "+n+"(int index) {\n      vec2 uv = packedUVfrom1D(\n        "+o[0]+", "+o[1]+", index);\n      return "+a.texture2D+"("+e+", uv);\n    }\n  "}(t);case 2:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t.shapeInfo.texShape,a=o[0],i=o[1],s=uo();if(null!=o&&x(e,o))return"\n      vec4 "+r+"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2("+i+".0, "+a+".0);\n\n        return "+s.texture2D+"("+n+", uv);\n      }\n    ";var u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],l=Math.ceil(e[1]/2);return"\n    vec4 "+r+"(int row, int col) {\n      vec2 uv = packedUVfrom2D("+l+", "+u[0]+", "+u[1]+", row, col);\n      return "+s.texture2D+"("+n+", uv);\n    }\n  "}(t);case 3:return function(t){var e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===e[0]){var i=e.slice(1),s=Co(t,i);return"\n        "+fo(s)+"\n        vec4 "+r+"(int b, int row, int col) {\n          return "+r+"("+Eo(["b","row","col"],[1,2])+");\n        }\n      "}var u=a[0],l=a[1],c=Math.ceil(e[2]/2),h=c*Math.ceil(e[1]/2),p=uo();return"\n    vec4 "+r+"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        "+u+", "+l+", "+h+", "+c+", b, row, col);\n      return "+p.texture2D+"("+n+", uv);\n    }\n  "}(t);default:return function(t){for(var e=t.shapeInfo.logicalShape,n=e.length,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),a=t.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],s=i[0],u=i[1],l=Math.ceil(e[n-1]/2),c=l*Math.ceil(e[n-2]/2),h="int b, int row, int col",p="b * "+c+" + (row / 2) * "+l+" + (col / 2)",f=2;f<n-1;f++)h="int b"+f+", "+h,c*=e[n-f-1],p="b"+f+" * "+c+" + "+p;var d=uo();return"\n    vec4 "+o+"("+h+") {\n      int index = "+p+";\n      int texR = index / "+u+";\n      int texC = index - texR * "+u+";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+u+", "+s+");\n      return "+d.texture2D+"("+r+", uv);\n    }\n  "}(t)}}var vo="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",mo="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",go="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",yo="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function xo(t){return"offset"+t}function wo(t){var e=t.name,n=y(t.shapeInfo.logicalShape);return n<2?"return "+e+";":"\n    for (int i = 0; i < "+n+"; i++) {\n      if (i == index) {\n        return "+e+"[i];\n      }\n    }\n  "}function bo(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error("GPU for rank "+t+" is not yet supported")}function Co(t,e){var n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function Eo(t,e){return e.map(function(e){return t[e]}).join(", ")}var Ro=function(){return function(t,e,n,r){this.variableNames=["A"],this.usesPackedTextures=!0,d(t.length>2,function(){return"Packed arg"+(n.charAt(0).toUpperCase()+n.slice(1))+" supports only inputs with rank above 2."});var o=t[t.length-1],a=Math.ceil(o/e);this.outputShape=t.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");var i,s,u=this.outputShape,l=u.length,c=bo(l),h=oo("coords",l);if(1===a){var p=bo(s=l+1);i="\n        "+p+" sourceLocR = "+p+"("+h.join()+", 0);\n        ++"+h[l-1]+";\n        "+p+" sourceLocG = "+p+"("+h.join()+", 0);\n        ++"+h[l-2]+";\n        "+p+" sourceLocA = "+p+"("+h.join()+", 0);\n        --"+h[l-1]+";\n        "+p+" sourceLocB = "+p+"("+h.join()+", 0);\n        --"+h[l-2]+";"}else s=l,i="\n        "+c+" sourceLocR = coords;\n        ++"+h[l-1]+";\n        "+c+" sourceLocG = coords;\n        ++"+h[l-2]+";\n        "+c+" sourceLocA = coords;\n        --"+h[l-1]+";\n        "+c+" sourceLocB = coords;\n        --"+h[l-2]+";";var f=["x","y","z","w","u","v"].slice(0,s),v="."+f[s-1],m=f.map(function(t){return"int "+t}),g=oo("sourceLocR",s-1).concat("inIdx.r"),y=oo("sourceLocG",s-1).concat("inIdx.g"),x=oo("sourceLocB",s-1).concat("inIdx.b"),w=oo("sourceLocA",s-1).concat("inIdx.a"),b="max"===n?"greaterThan":"lessThan",C=r?"":"\n          inIdx = round(vec4(getBestIndicesAChannel("+g.join()+"),\n                             getBestIndicesAChannel("+y.join()+"),\n                             getBestIndicesAChannel("+x.join()+"),\n                             getBestIndicesAChannel("+w.join()+")));",E="vec4(\n            getAChannel("+g.join()+"),\n            hasNextCol ? getAChannel("+y.join()+") : 0.,\n            hasNextRow ? getAChannel("+x.join()+") : 0.,\n            hasNextRow && hasNextCol ? getAChannel("+w.join()+") : 0.)",R=r?"":"\n      float getBestIndicesAChannel("+m.join()+") {\n        return getChannel(getBestIndicesA("+f.join()+"),\n                                          vec2("+f.slice(-2).join()+"));\n      }";this.userCode="\n      float getAChannel("+m.join()+") {\n        return getChannel(getA("+f.join()+"),\n                               vec2("+f.slice(-2).join()+"));\n      }\n      "+R+"\n      void main() {\n        "+c+" coords = getOutputCoords();\n        bool hasNextCol = "+h[l-1]+" < "+(u[l-1]-1)+";\n        bool hasNextRow = "+h[l-2]+" < "+(u[l-2]-1)+";\n        "+i+"\n        ivec4 srcIdx = ivec4(sourceLocR"+v+", sourceLocG"+v+",\n          sourceLocB"+v+", sourceLocA"+v+") * "+e+";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = "+E+";\n\n        for (int i = 0; i < "+e+"; i++) {\n          inIdx = srcIdx;\n          "+C+"\n          vec4 candidate = "+E+";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4("+b+"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    "}}(),So=function(){return function(t){this.variableNames=["dy"],this.outputShape=t.inShape;var e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,o=t.strideWidth,a=t.dilationHeight,i=t.dilationWidth,s=t.effectiveFilterHeight,u=t.effectiveFilterWidth,l=s-1-t.padInfo.top,c=u-1-t.padInfo.left,h=1/(e*n);this.userCode="\n      const ivec2 pads = ivec2("+l+", "+c+");\n      const float avgMultiplier = float("+h+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+s+";\n            wR += "+a+") {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+t.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+u+";\n            wC+= "+i+") {\n            float dyC = float(dyCCorner + wC) / "+o+".0;\n\n            if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),No=function(){return function(t,e,n,r,o,a){this.outputShape=[],this.variableNames=["x","mean","variance"],so(t,e),so(t,n);var i="0.0";null!=r&&(so(t,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");var s="1.0";null!=o&&(so(t,o),this.variableNames.push("scale"),s="getScaleAtOutCoords()"),this.outputShape=t,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = "+i+";\n        float scale = "+s+";\n        float inv = scale * inversesqrt(variance + float("+a+"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    "}}(),ko=function(){return function(t,e,n,r,o,a){this.usesPackedTextures=!0,this.variableNames=["x","mean","variance"],so(t,e),so(t,n);var i="vec4(0.0)";null!=r&&(so(t,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");var s="vec4(1.0)";null!=o&&(so(t,o),this.variableNames.push("scale"),s="getScaleAtOutCoords()"),this.outputShape=t,this.userCode="\n      void main() {\n        vec4 offset = "+i+";\n        vec4 scale = "+s+";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4("+a+"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    "}}(),Io="return areal * breal - aimag * bimag;",Ao="return areal * bimag + aimag * breal;",To=function(){return function(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=so(e,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        "+t+"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    "}}(),Do="return a + b;",Oo="return a - b;",_o="return a * b;",Mo=function(){return function(t,e,n){this.variableNames=["A","B"],this.outputShape=so(e,n),this.userCode="\n      float binaryOperation(float a, float b) {\n        "+t+"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    "}}(),Fo=function(){return function(t,e,n,r){void 0===r&&(r=!1),this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.usesPackedTextures=!0,this.outputShape=so(e,n);var o=this.outputShape.length,a="";if(r)if(0===o||1===y(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(a="\n          "+bo(o)+" coords = getOutputCoords();\n        ",1===o)a+="\n            result.y = (coords + 1) >= "+this.outputShape[0]+" ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";else{var i=oo("coords",o);a+="\n            bool nextRowOutOfBounds =\n              ("+i[o-2]+" + 1) >= "+this.outputShape[o-2]+";\n            bool nextColOutOfBounds =\n              ("+i[o-1]+" + 1) >= "+this.outputShape[o-1]+";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        "+t+"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        "+a+"\n\n        setOutput(result);\n      }\n    "}}(),Bo=function(){function t(t){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      uniform float min;\n      uniform float max;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, min, max));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t,e){var n=this;return function(r,o){null==n.minLoc&&(n.minLoc=r.getUniformLocationNoThrow(o,"min"),n.maxLoc=r.getUniformLocationNoThrow(o,"max")),r.gl.uniform1f(n.minLoc,t),r.gl.uniform1f(n.maxLoc,e)}},t}(),Po=function(){function t(t){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=t,this.userCode="\n      uniform float min;\n      uniform float max;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(min), vec4(max)));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t,e){var n=this;return function(r,o){null==n.minLoc&&(n.minLoc=r.getUniformLocationNoThrow(o,"min"),n.maxLoc=r.getUniformLocationNoThrow(o,"max")),r.gl.uniform1f(n.minLoc,t),r.gl.uniform1f(n.maxLoc,e)}},t}(),Lo=function(){return function(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}(),Wo=function(){return function(t){this.outputShape=[],this.outputShape=sn(t,1),this.variableNames=t.map(function(t,e){return"T"+e});var e=new Array(t.length-1);e[0]=t[0][1];for(var n=1;n<e.length;n++)e[n]=e[n-1]+t[n][1];var r=["if (yC < "+e[0]+") setOutput(getT0(yR, yC));"];for(n=1;n<e.length;n++){var o=e[n-1];r.push("else if (yC < "+e[n]+") setOutput(getT"+n+"(yR, yC-"+o+"));")}var a=e.length,i=e[e.length-1];r.push("else setOutput(getT"+a+"(yR, yC-"+i+"));"),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        "+r.join("\n        ")+"\n      }\n    "}}(),Uo=function(){return function(t,e){this.usesPackedTextures=!0,this.outputShape=[],this.outputShape=sn(t,e);var n=this.outputShape,r=n.length,o=bo(r),a=oo("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map(function(t,e){return"T"+e});var s=new Array(t.length-1);s[0]=t[0][e];for(var u=1;u<s.length;u++)s[u]=s[u-1]+t[u][e];var l=i[e],c="vec2("+i.slice(-2).join()+")",h=i.join(),p="if ("+l+" < "+s[0]+")\n          return getChannel(getT0("+h+"), "+c+");";for(u=1;u<s.length;u++){var f=s[u-1];p+="\n        else if ("+l+" < "+s[u]+") {\n          "+l+" -= "+f+";\n          return getChannel(getT"+u+"("+h+"), "+c+");\n        }"}var d=s.length;p+="\n        else {\n          "+l+" -= "+s[s.length-1]+";\n          return getChannel(getT"+d+"("+h+"), "+c+");\n        }",this.userCode="\n      float getValue("+i.map(function(t){return"int "+t})+") {\n        "+p+"\n      }\n\n      void main() {\n        "+o+" coords = getOutputCoords();\n        vec4 result = vec4(getValue("+a+"), 0., 0., 0.);\n        if (++"+a[r-1]+" < "+n[r-1]+") {\n          result.g = getValue("+a+");\n        }\n        if (++"+a[r-2]+" < "+n[r-2]+") {\n          result.a = getValue("+a+");\n        }\n        if ("+a[r-2]+" < "+n[r-2]+" &&\n            --"+a[r-1]+" < "+n[r-1]+") {\n          result.b = getValue("+a+");\n        }\n        setOutput(result);\n      }\n    "}}(),zo=function(){return function(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;var e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,o=t.padInfo.left;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+t.batchSize+"; b++) {\n          for (int yR = 0; yR < "+t.outHeight+"; yR++) {\n            int xR = wR + yR * "+e+" - "+r+";\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+t.outWidth+"; yC++) {\n              int xC = wC + yC * "+n+" - "+o+";\n\n              if (xC < 0 || xC >= "+t.inWidth+") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Vo=function(){return function(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;var e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,o=t.strideWidth,a=e-1-t.padInfo.top,i=n-1-t.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2("+a+", "+i+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+e+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+t.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+e+" - 1 - wR;\n\n          for (int wC = 0; wC < "+n+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+o+".0;\n\n            if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+n+" - 1 - wC;\n\n            for (int d2 = 0; d2 < "+t.outChannels+"; d2++) {\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Go=function(){return function(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;var e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,o=t.padInfo.front,a=t.padInfo.top,i=t.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < "+t.batchSize+"; b++) {\n          for (int yF = 0; yF < "+t.outDepth+"; yF++) {\n            int xF = wF + yF * "+e+" - "+o+";\n\n            if (xF < 0 || xF >= "+t.inDepth+") {\n              continue;\n            }\n\n            for (int yR = 0; yR < "+t.outHeight+"; yR++) {\n              int xR = wR + yR * "+n+" - "+a+";\n\n              if (xR < 0 || xR >= "+t.inHeight+") {\n                continue;\n              }\n\n              for (int yC = 0; yC < "+t.outWidth+"; yC++) {\n                int xC = wC + yC * "+r+" - "+i+";\n\n                if (xC < 0 || xC >= "+t.inWidth+") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),qo=function(){return function(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;var e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,o=t.strideDepth,a=t.strideHeight,i=t.strideWidth,s=e-1-t.padInfo.front,u=n-1-t.padInfo.top,l=r-1-t.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3("+s+", "+u+", "+l+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < "+e+"; wF++) {\n          float dyF = float(dyFCorner + wF) / "+o+".0;\n\n          if (dyF < 0.0 || dyF >= "+t.outDepth+".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = "+e+" - 1 - wF;\n\n          for (int wR = 0; wR < "+n+"; wR++) {\n            float dyR = float(dyRCorner + wR) / "+a+".0;\n\n            if (dyR < 0.0 || dyR >= "+t.outHeight+".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = "+n+" - 1 - wR;\n\n            for (int wC = 0; wC < "+r+"; wC++) {\n              float dyC = float(dyCCorner + wC) / "+i+".0;\n\n              if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = "+r+" - 1 - wC;\n\n              for (int d2 = 0; d2 < "+t.outChannels+"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Ho=function(){return function(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;var e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,o=t.padInfo.left,a=t.outChannels/t.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * "+a+" + dm;\n\n        float dotProd = 0.0;\n\n        // TODO: Vec4 over the batch size\n        for (int b = 0; b < "+t.batchSize+"; b++) {\n          for (int yR = 0; yR < "+t.outHeight+"; yR++) {\n            int xR = wR + yR * "+e+" - "+r+";\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int yC = 0; yC < "+t.outWidth+"; yC++) {\n              int xC = wC + yC * "+n+" - "+o+";\n\n              if (xC < 0 || xC >= "+t.inWidth+") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),$o=function(){return function(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;var e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,o=t.strideWidth,a=e-1-t.padInfo.top,i=n-1-t.padInfo.left,s=t.outChannels/t.inChannels;this.userCode="\n      const ivec2 pads = ivec2("+a+", "+i+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < "+e+"; wR++) {\n          float dyR = float(dyRCorner + wR) / "+r+".0;\n\n          if (dyR < 0.0 || dyR >= "+t.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = "+e+" - 1 - wR;\n\n          for (int wC = 0; wC < "+n+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+o+".0;\n\n            if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = "+n+" - 1 - wC;\n\n            // TODO: Vec4 over the channelMul\n            for (int dm = 0; dm < "+s+"; dm++) {\n              int d2 = d1 * "+s+" + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),jo=function(){return function(t){this.variableNames=["x","W"],this.outputShape=t.outShape;var e=t.padInfo.top,n=t.padInfo.left,r=t.strideHeight,o=t.strideWidth,a=t.dilationHeight,i=t.dilationWidth,s=t.filterHeight,u=t.filterWidth,l=4*Math.floor(t.inChannels/4),c=t.inChannels%4;this.userCode="\n      const ivec2 strides = ivec2("+r+", "+o+");\n      const ivec2 pads = ivec2("+e+", "+n+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+s+"; wR++) {\n          int xR = xRCorner + wR * "+a+";\n\n          if (xR < 0 || xR >= "+t.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+u+"; wC++) {\n            int xC = xCCorner + wC * "+i+";\n\n            if (xC < 0 || xC >= "+t.inWidth+") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < "+l+"; d1 += 4) {\n              vec4 xValues = vec4(\n                getX(batch, xR, xC, d1),\n                getX(batch, xR, xC, d1 + 1),\n                getX(batch, xR, xC, d1 + 2),\n                getX(batch, xR, xC, d1 + 3)\n              );\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              dotProd += dot(xValues, wValues);\n            }\n\n            if ("+(1===c)+") {\n              dotProd +=\n                getX(batch, xR, xC, "+l+") *\n                getW(wR, wC, "+l+", d2);\n            } else if ("+(2===c)+") {\n              vec2 xValues = vec2(\n                getX(batch, xR, xC, "+l+"),\n                getX(batch, xR, xC, "+l+" + 1)\n              );\n              vec2 wValues = vec2(\n                getW(wR, wC, "+l+", d2),\n                getW(wR, wC, "+l+" + 1, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            } else if ("+(3===c)+") {\n              vec3 xValues = vec3(\n                getX(batch, xR, xC, "+l+"),\n                getX(batch, xR, xC, "+l+" + 1),\n                getX(batch, xR, xC, "+l+" + 2)\n              );\n              vec3 wValues = vec3(\n                getW(wR, wC, "+l+", d2),\n                getW(wR, wC, "+l+" + 1, d2),\n                getW(wR, wC, "+l+" + 2, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Ko=function(){return function(t){this.variableNames=["x","W"],this.outputShape=t.outShape;var e=t.padInfo.front,n=t.padInfo.top,r=t.padInfo.left,o=t.strideDepth,a=t.strideHeight,i=t.strideWidth,s=t.dilationDepth,u=t.dilationHeight,l=t.dilationWidth,c=t.filterDepth,h=t.filterHeight,p=t.filterWidth,f=4*Math.floor(t.inChannels/4),d=t.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3("+o+", "+a+", "+i+");\n      const ivec3 pads = ivec3("+e+", "+n+", "+r+");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < "+c+"; wF++) {\n          int xF = xFCorner + wF * "+s+";\n\n          if (xF < 0 || xF >= "+t.inDepth+") {\n            continue;\n          }\n\n          for (int wR = 0; wR < "+h+"; wR++) {\n            int xR = xRCorner + wR * "+u+";\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+p+"; wC++) {\n              int xC = xCCorner + wC * "+l+";\n\n              if (xC < 0 || xC >= "+t.inWidth+") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < "+f+"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if ("+(1===d)+") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, "+f+") *\n                  getW(wF, wR, wC, "+f+", d2);\n              } else if ("+(2===d)+") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, "+f+"),\n                  getX(batch, xF, xR, xC, "+f+" + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, "+f+", d2),\n                  getW(wF, wR, wC, "+f+" + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if ("+(3===d)+") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, "+f+"),\n                  getX(batch, xF, xR, xC, "+f+" + 1),\n                  getX(batch, xF, xR, xC, "+f+" + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, "+f+", d2),\n                  getW(wF, wR, wC, "+f+" + 1, d2),\n                  getW(wF, wR, wC, "+f+" + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Xo=function(){return function(t){this.variableNames=["x","W"],this.outputShape=t.outShape;var e=t.inHeight,n=t.inWidth,r=t.padInfo.top,o=t.padInfo.left,a=t.strideHeight,i=t.strideWidth,s=t.dilationHeight,u=t.dilationWidth,l=t.filterHeight,c=t.filterWidth,h=t.outChannels/t.inChannels;this.userCode="\n      const ivec2 strides = ivec2("+a+", "+i+");\n      const ivec2 pads = ivec2("+r+", "+o+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / "+h+";\n        int q = d2 - d1 * "+h+";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < "+l+"; wR++) {\n          int xR = xRCorner + wR * "+s+";\n\n          if (xR < 0 || xR >= "+e+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+c+"; wC++) {\n            int xC = xCCorner + wC * "+u+";\n\n            if (xC < 0 || xC >= "+n+") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),Yo=function(){return function(t){this.variableNames=["x","W"],this.usesPackedTextures=!0,this.outputShape=t.outShape;for(var e=t.inHeight,n=t.inWidth,r=t.padInfo.top,o=t.padInfo.left,a=t.strideHeight,i=t.strideWidth,s=t.dilationHeight,u=t.dilationWidth,l=t.filterHeight,c=t.filterWidth,h=c,f="int xR; int xC; int xCOffset;",d=0;d<l;d++)for(var v=0;v<c;v++)f+="\n          vec4 xTexelR"+d+"C"+2*v+" = vec4(0.);\n          vec4 wR"+d+"C"+v+" = vec4(0.);\n          vec4 xR"+d+"C"+v+" = vec4(0.);";for(d=0;d<l;d++)for(var m=0;m<h;m++){if(f+="\n          xR = xRCorner + "+d*s+";\n          xC = xCCorner + "+(v=2*m)*u+";\n        ",1===i){if(v<c&&(f+=o%2==1?"\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < "+e+" && xCOffset >= 0 && xCOffset < "+n+") {\n                  xTexelR"+d+"C"+v+" = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+d+"C"+v+" = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < "+e+" && xCOffset >= 0 && xCOffset < "+n+") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n                  xR"+d+"C"+v+" = vec4(previous.zw, xTexelR"+d+"C"+v+".xy);\n                } else {\n                  xR"+d+"C"+v+" = vec4(0, 0, xTexelR"+d+"C"+v+".xy);\n                }\n              ":"\n                if(xR >= 0 && xR < "+e+" && xC >= 0 && xC < "+n+") {\n                  xTexelR"+d+"C"+v+" = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR"+d+"C"+v+" = vec4(0.);\n                }\n\n                xR"+d+"C"+v+" = xTexelR"+d+"C"+v+";\n              ",v+1<c)){var g=o%2==0?p(u):u;u%2==0&&o%2==1||u%2!=0&&o%2!=1?(f+="\n                  xCOffset = xC + "+o%2+" + "+g+";\n\n                  if(xR >= 0 && xR < "+e+" &&\n                    xCOffset >= 0 && xCOffset < "+n+") {\n                    xTexelR"+d+"C"+(v+2)+" = getX(batch, xR, xCOffset, d1);\n                  }\n                ",u>1&&(f+="\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < "+e+" &&\n                      xCOffset >= 0 && xCOffset < "+n+") {\n                      xTexelR"+d+"C"+v+" = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR"+d+"C"+v+" = vec4(0.);\n                    }\n                  "),f+="\n                  xR"+d+"C"+(v+1)+" = vec4(\n                    xTexelR"+d+"C"+v+".zw, xTexelR"+d+"C"+(v+2)+".xy);\n                "):f+="\n                  xCOffset = xC + "+g+";\n\n                  if(xR >= 0 && xR < "+e+" &&\n                    xCOffset >= 0 && xCOffset < "+n+") {\n                    xTexelR"+d+"C"+(v+2)+" = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR"+d+"C"+(v+1)+" = xTexelR"+d+"C"+(v+2)+";\n                "}}else v<c&&(f+="\n              if(xR >= 0 && xR < "+e+") {\n            ",o%2==1?(f+="\n                xCOffset = xC + 1 - "+i+";\n                if(xCOffset >= 0 && xCOffset < "+n+") {\n                  xTexelR"+d+"C"+v+" = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+d+"C"+v+" = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < "+n+") {\n                  xTexelR"+d+"C"+(v+2)+" = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR"+d+"C"+(v+2)+" = vec4(0.);\n                }\n\n                xR"+d+"C"+v+" = vec4(\n                  xTexelR"+d+"C"+v+".zw, xTexelR"+d+"C"+(v+2)+".zw);\n              ",v+1<c&&(f+="\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + "+i+";\n                  if(xCOffset >= 0 && xCOffset < "+n+") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR"+d+"C"+(v+1)+" = vec4(xTexelR"+d+"C"+(v+2)+".xy, final.xy);\n                ")):(f+="\n                if(xC >= 0 && xC < "+n+") {\n                  xTexelR"+d+"C"+v+" = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR"+d+"C"+v+" = vec4(0.);\n                }\n\n                xCOffset = xC + "+i+";\n                if(xCOffset >= 0 && xCOffset < "+n+") {\n                  xTexelR"+d+"C"+(v+2)+" = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR"+d+"C"+(v+2)+" = vec4(0.);\n                }\n\n                xR"+d+"C"+v+" = vec4(\n                  xTexelR"+d+"C"+v+".xy, xTexelR"+d+"C"+(v+2)+".xy);\n              ",v+1<c&&(f+="\n                  xR"+d+"C"+(v+1)+" = vec4(\n                    xTexelR"+d+"C"+v+".zw, xTexelR"+d+"C"+(v+2)+".zw);\n                ")),f+="}");v<c&&(f+="\n            vec4 wTexelR"+d+"C"+v+" = getW("+d+", "+v+", d1, q);\n            wR"+d+"C"+v+" = vec4(wTexelR"+d+"C"+v+".xz, wTexelR"+d+"C"+v+".xz);\n          ",v+1<c&&(f+="\n              vec4 wTexelR"+d+"C"+(v+1)+" = getW("+d+", "+(v+1)+", d1, q);\n              wR"+d+"C"+(v+1)+" =\n                vec4(wTexelR"+d+"C"+(v+1)+".xz, wTexelR"+d+"C"+(v+1)+".xz);"))}for(d=0;d<l;d++)for(v=0;v<c;v++)f+="result += xR"+d+"C"+v+" * wR"+d+"C"+v+";";this.userCode="\n      const ivec2 strides = ivec2("+a+", "+i+");\n      const ivec2 pads = ivec2("+r+", "+o+");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 result = vec4(0.);\n\n        "+f+"\n\n        setOutput(result);\n      }\n    "}}(),Qo=function(){return function(t,e,n,r,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];var a=t[0],i=t[1],s=t[2],u=t[3],l=e[0],c=n[0],h=n[1];this.outputShape=[l,c,h,u];var p="bilinear"===r?1:0,f=[i-1+".0",s-1+".0"],d=f[0],v=f[1],m=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio","y1*"+d+" + float(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+d],g=m[0],y=m[1],x=m[2],w=h>1?[""+(s-1)/(h-1),"(x2-x1) * width_ratio","x1*"+v+" + float(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+v],b=w[0],C=w[1],E=w[2];this.userCode="\n      const float height_ratio = float("+g+");\n      const float width_ratio = float("+b+");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= "+a+") {\n          return;\n        }\n\n        float height_scale = "+y+";\n        float width_scale = "+C+";\n\n        float in_y = "+x+";\n        if( in_y < 0.0 || in_y > "+d+" ) {\n          setOutput(float("+o+"));\n          return;\n        }\n        float in_x = "+E+";\n        if( in_x < 0.0 || in_x > "+v+" ) {\n          setOutput(float("+o+"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if("+p+" == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    "}}(),Jo=function(){return function(t,e,n){this.variableNames=["x"],this.outputShape=t;var r=t.length,o=t[t.length-1],a=n?"<":">";this.userCode="\n      int getIndex(int i) {\n        "+(n?"return "+o+" -i - 1;":"return i;")+"\n      }\n\n      void main() {\n        "+bo(r)+" coords = getOutputCoords();\n        int end = "+Zo(r,"coords")+";\n        float val = 0.0;\n        for (int i = "+o+" - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx "+a+" end) {\n            continue;\n          }\n          if (idx == end && "+e+") {\n            continue;\n          }\n          "+Zo(r,"coords")+" = idx;\n          val += getX("+function(t,e){if(1===t)return""+e;if(2===t)return e+".x, "+e+".y";if(3===t)return e+".x, "+e+".y, "+e+".z";if(4===t)return e+".x, "+e+".y, "+e+".z, "+e+".w";throw Error("Cumulative sum for rank "+t+" is not yet supported")}(r,"coords")+");\n        }\n        setOutput(val);\n      }\n    "}}();function Zo(t,e){if(1===t)return""+e;if(2===t)return e+".y";if(3===t)return e+".z";if(4===t)return e+".w";throw Error("Cumulative sum for rank "+t+" is not yet supported")}var ta=function(){function t(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = "+this.getHeightCoordString()+";\n      int w = "+this.getWidthCoordString()+";\n      int d = "+this.getDepthCoordString()+";\n\n      int in_h = h / "+e+";\n      int offset_h = imod(h, "+e+");\n      int in_w = w / "+e+";\n      int offset_w = imod(w, "+e+");\n      int offset_d = (offset_h * "+e+" + offset_w) *\n        "+this.getOutputDepthSize()+";\n      int in_d = d + offset_d;\n\n      float result = "+this.getInputSamplingString()+";\n      setOutput(result);\n    }\n  "}return t.prototype.getHeightCoordString=function(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"},t.prototype.getWidthCoordString=function(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"},t.prototype.getDepthCoordString=function(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"},t.prototype.getOutputDepthSize=function(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]},t.prototype.getInputSamplingString=function(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"},t}(),ea=function(){return function(t){this.variableNames=["A"];var e=uo();this.outputShape=t,this.userCode="\n      const float FLOAT_MAX = 1.70141184e38;\n      const float FLOAT_MIN = 1.17549435e-38;\n\n      lowp vec4 encode_float(highp float v) {\n        if (isnan(v)) {\n          return vec4(255, 255, 255, 255);\n        }\n\n        highp float av = abs(v);\n\n        if(av < FLOAT_MIN) {\n          return vec4(0.0, 0.0, 0.0, 0.0);\n        } else if(v > FLOAT_MAX) {\n          return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n        } else if(v < -FLOAT_MAX) {\n          return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n        }\n\n        highp vec4 c = vec4(0,0,0,0);\n\n        highp float e = floor(log2(av));\n        highp float m = exp2(fract(log2(av))) - 1.0;\n\n        c[2] = floor(128.0 * m);\n        m -= c[2] / 128.0;\n        c[1] = floor(32768.0 * m);\n        m -= c[1] / 32768.0;\n        c[0] = floor(8388608.0 * m);\n\n        highp float ebias = e + 127.0;\n        c[3] = floor(ebias / 2.0);\n        ebias -= c[3] * 2.0;\n        c[2] += floor(ebias) * 128.0;\n\n        c[3] += 128.0 * step(0.0, -v);\n\n        return c / 255.0;\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        "+e.output+" = encode_float(x);\n      }\n    "}}(),na="return real * expR - imag * expI;",ra="return real * expI + imag * expR;",oa=function(){return function(t,e,n){this.variableNames=["real","imag"];var r=e[1];this.outputShape=e;var o=n?"2.0 * "+Math.PI:"-2.0 * "+Math.PI,a=n?r+".0":"1.0";this.userCode="\n      const float exponentMultiplier = "+o+";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        "+t+"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float("+r+");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < "+r+"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / "+a+";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    "}}(),aa=function(){function t(t,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t){var e=this;return function(n,r){null==e.valueLoc&&(e.valueLoc=n.getUniformLocationNoThrow(r,"value")),n.gl.uniform1f(e.valueLoc,t)}},t}(),ia=function(){return function(t){this.variableNames=["A"];var e=uo(),n=t[0],r=t[1];this.outputShape=t,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2("+r+".0, "+n+".0);\n\n        vec4 values = "+e.texture2D+"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    "}}(),sa=function(){return function(t,e,n){this.variableNames=["A","indices"];var r=t.slice();r[n]=e,this.outputShape=r,this.rank=r.length;var o=bo(this.rank),a=function(t,e){var n=t.length;if(n>4)throw Error("Gather for rank "+n+" is not yet supported");if(1===n)return"int(getIndices(resRC))";for(var r=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],a=0;a<t.length;a++)a===e?o.push("int(getIndices("+r[a]+"))"):o.push(""+r[a]);return o.join()}(t,n);this.userCode="\n      void main() {\n        "+o+" resRC = getOutputCoords();\n        setOutput(getA("+a+"));\n      }\n    "}}();var ua,la,ca=function(){return function(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;var r=bo(e.length),o=bo(n.length),a=this.sliceDim>1?"strides[j]":"strides";this.userCode="\n        "+r+" strides = "+r+"("+this.strides+");\n         void main() {\n          "+o+" coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < "+this.sliceDim+"; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * "+a+";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      "}}();function ha(t,e){return[e,t]}function pa(t,e){return t*e}function fa(t,e,n){var r=function(t,e){if(t%e!=0)throw new Error("unpackedSize ("+t+") must be a multiple of "+e);return t/e}(t.length,n);if(e.length<r)throw new Error("matrix length ("+e.length+") must be >= "+r);for(var o=0,a=0;a<t.length;a+=n)e[o++]=t[a]}function da(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function va(t,e){var n=da(t,e);return n[0]*n[1]*4}function ma(t,e,n,r,o){var a=n*r;if(o.length<a)throw new Error("matrix length ("+o.length+") must be >= "+a);for(var i=r%2==1,s=n%2==1,u=Math.floor(r/2),l=Math.floor(n/2),c=Math.ceil(r/2),h=c*Math.ceil(n/2),f=p(n)*p(r),d=0;d<e;d++){for(var v=d*n*r,m=d*f,g=i?4:0,y=r+(i?1:0),x=m,w=v,b=v+r,C=0;C<l;++C){for(var E=0;E<u;++E)o[w++]=t[x++],o[w++]=t[x++],o[b++]=t[x++],o[b++]=t[x++];x+=g,w+=y,b+=y}if(i){x=m+4*(c-1);var R=v+r-1;for(g=4*c,y=2*r,C=0;C<l;++C)o[R]=t[x],o[R+r]=t[x+2],x+=g,R+=y}if(s){for(x=m+4*(h-c),R=v+(n-1)*r,E=0;E<u;++E)o[R++]=t[x++],o[R++]=t[x++],x+=2;i&&(o[v+n*r-1]=t[x])}}return o}function ga(t,e){var n=uo();return Vt(t,e,n.version+"\n    precision highp float;\n    "+n.attribute+" vec3 clipSpacePos;\n    "+n.attribute+" vec2 uv;\n    "+n.varyingVs+" vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }")}function ya(t,e){return Yt(t,e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function xa(t,e){return Qt(t,e,new Uint16Array([0,1,2,2,1,3]))}function wa(t,e){var n,r,o,i,s,u,l,c,h=t;return 2===a.getNumber("WEBGL_VERSION")?(n=h.R32F,r=h.R16F,o=h.RGBA16F,i=h.RGBA32F,s=h.RED,u=4,l=1,c=h.HALF_FLOAT):(n=t.RGBA,r=t.RGBA,o=t.RGBA,i=h.RGBA,s=t.RGBA,u=4,l=4,c=null!=e?e.HALF_FLOAT_OES:null),{internalFormatFloat:n,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:s,downloadTextureFormat:t.RGBA,downloadUnpackNumChannels:u,defaultNumChannels:l,textureTypeHalfFloat:c}}function ba(t,e,n,r,o,a,i){te(n,r);var s=Zt(t,e),u=t.TEXTURE_2D;return Bt(t,e,function(){return t.bindTexture(u,s)}),Bt(t,e,function(){return t.texParameteri(u,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)}),Bt(t,e,function(){return t.texParameteri(u,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)}),Bt(t,e,function(){return t.texParameteri(u,t.TEXTURE_MIN_FILTER,t.NEAREST)}),Bt(t,e,function(){return t.texParameteri(u,t.TEXTURE_MAG_FILTER,t.NEAREST)}),Bt(t,e,function(){return t.texImage2D(u,0,o,n,r,0,a,i,null)}),Bt(t,e,function(){return t.bindTexture(t.TEXTURE_2D,null)}),s}function Ca(t,e,n,r,o){var a=ha(n,r);return ba(t,e,a[0],a[1],o.internalFormatFloat,o.textureFormatFloat,t.FLOAT)}function Ea(t,e,n,r,o){var a=ha(n,r);return ba(t,e,a[0],a[1],o.internalFormatHalfFloat,o.textureFormatFloat,o.textureTypeHalfFloat)}function Ra(t,e,n,r,o){var a=ha(n,r);return ba(t,e,a[0],a[1],t.RGBA,t.RGBA,t.UNSIGNED_BYTE)}function Sa(t,e,n,r,o){var a=da(n,r);return ba(t,e,a[0],a[1],o.internalFormatPackedFloat,t.RGBA,t.FLOAT)}function Na(t,e,n,r,o){var a=da(n,r);return ba(t,e,a[0],a[1],o.internalFormatPackedHalfFloat,t.RGBA,o.textureTypeHalfFloat)}function ka(t,e,n,r){return Bt(t,e,function(){return t.bindBuffer(t.ARRAY_BUFFER,r)}),ne(t,e,n,"clipSpacePos",r,3,20,0)&&ne(t,e,n,"uv",r,2,20,12)}function Ia(t,e,n,r){Bt(t,e,function(){return t.bindTexture(t.TEXTURE_2D,n)}),Bt(t,e,function(){return t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,r)}),Bt(t,e,function(){return t.bindTexture(t.TEXTURE_2D,null)})}function Aa(t,e,n,r,o,a,i){te(r,o),Bt(t,e,function(){return t.bindTexture(t.TEXTURE_2D,n)}),Bt(t,e,function(){return t.texSubImage2D(t.TEXTURE_2D,0,0,0,r,o,i,t.FLOAT,a)}),Bt(t,e,function(){return t.bindTexture(t.TEXTURE_2D,null)})}function Ta(t,e,n,r,o,a,i,s){var u,l=ha(r,o),c=l[0],h=l[1],p=r*o;1===s.defaultNumChannels&&p===a.length?u=a:function(t,e,n){var r=pa(t.length,n);if(e.length<r)throw new Error("unpackedArray length ("+e.length+") must be >= "+r);for(var o=0,a=0;a<t.length;++a)e[o]=t[a],o+=n}(a,u=new Float32Array(p*i),i),Aa(t,e,n,c,h,u,s.textureFormatFloat)}function Da(t,e,n,r,o,a,i,s,u,l){var c=da(i,s),h=c[0],f=c[1],d=new Float32Array(va(i,s));!function(t,e,n,r,o){for(var a=r%2==1,i=n%2==1,s=Math.floor(r/2),u=Math.floor(n/2),l=Math.ceil(r/2),c=l*Math.ceil(n/2),h=p(n)*p(r),f=0;f<e;f++){for(var d=f*n*r,v=f*h,m=a?4:0,g=r,y=v,x=0;x<u;++x){for(var w=2*x*r,b=0;b<s;++b){var C=d+w+2*b;o[y]=t[C],o[y+1]=t[C+1],o[y+2]=t[C+g],o[y+3]=t[C+g+1],y+=4}y+=m}if(a){C=d+r-1,y=v+4*(l-1);var E=2*r;for(m=4*l,x=0;x<u;++x)o[y]=t[C],o[y+2]=t[C+r],C+=E,y+=m}if(i){for(C=d+(n-1)*r,y=v+4*(c-l),b=0;b<s;++b)o[y++]=t[C++],o[y++]=t[C++],y+=2;a&&i&&(o[v+h-4]=t[C])}}}(u,r,o,a,d),Aa(t,e,n,h,f,d,t.RGBA)}function Oa(t,e,n,r,o){var a=t.createBuffer();Bt(t,e,function(){return t.bindBuffer(t.PIXEL_PACK_BUFFER,a)});var i=4*pa(n*r,o.downloadUnpackNumChannels);return Bt(t,e,function(){return t.bufferData(t.PIXEL_PACK_BUFFER,i,t.STREAM_READ)}),Bt(t,e,function(){return t.readPixels(0,0,r,n,t.RGBA,t.FLOAT,0)}),Bt(t,e,function(){return t.bindBuffer(t.PIXEL_PACK_BUFFER,null)}),a}function _a(t,e,n,r,o){var a=t,i=new Float32Array(pa(n*r,o.downloadUnpackNumChannels));a.bindBuffer(a.PIXEL_PACK_BUFFER,e),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,i),a.bindBuffer(a.PIXEL_PACK_BUFFER,null);var s=new Float32Array(n*r);return fa(i,s,o.downloadUnpackNumChannels),s}function Ma(t,e,n,r,o){var a=ha(n,r),i=a[0],s=a[1],u=new Float32Array(pa(n*r,o.downloadUnpackNumChannels));Bt(t,e,function(){return t.readPixels(0,0,i,s,o.downloadTextureFormat,t.FLOAT,u)});var l=new Float32Array(n*r);return fa(u,l,o.downloadUnpackNumChannels),l}function Fa(t,e,n,r,o){var a=ha(n,r),i=a[0],s=a[1],u=new Uint8Array(pa(n*r,4));return Bt(t,e,function(){return t.readPixels(0,0,i,s,o.downloadTextureFormat,t.UNSIGNED_BYTE,u)}),new Float32Array(u.buffer)}function Ba(t,e,n,r,o,a,i,s){var u=t,l=new Float32Array(va(a,i));u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null);var c=new Float32Array(y([n,r,o]));return ma(l,n,r,o,c),c}function Pa(t,e,n,r,o,a,i,s){var u=da(a,i),l=u[0],c=u[1],h=new Float32Array(va(a,i));Bt(t,e,function(){return t.readPixels(0,0,l,c,t.RGBA,t.FLOAT,h)});var p=new Float32Array(y([n,r,o]));return ma(h,n,r,o,p)}!function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(ua||(ua={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(la||(la={}));var La=Object.freeze({createVertexShader:ga,createVertexBuffer:ya,createIndexBuffer:xa,getTextureConfig:wa,createFloat32MatrixTexture:Ca,createFloat16MatrixTexture:Ea,createUnsignedBytesMatrixTexture:Ra,createPackedMatrixTexture:Sa,createFloat16PackedMatrixTexture:Na,bindVertexProgramAttributeStreams:ka,uploadPixelDataToTexture:Ia,uploadMatrixToTexture:Ta,uploadMatrixToPackedTexture:Da,createBufferFromOutputTexture:Oa,downloadFloat32MatrixFromBuffer:_a,downloadFloat32MatrixFromOutputTexture:Ma,downloadByteEncodedFloatMatrixFromOutputTexture:Fa,downloadPackedMatrixFromBuffer:Ba,downloadMatrixFromPackedOutputTexture:Pa}),Wa=function(){function t(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];var e=a.getNumber("WEBGL_VERSION");null!=t?(this.gl=t,function(t,e){_t[t]=e}(e,t)):this.gl=Ft(e),1===a.getNumber("WEBGL_VERSION")?(this.textureFloatExtension=zt(this.gl,this.debug,"OES_texture_float"),this.colorBufferFloatExtension=this.gl.getExtension("WEBGL_color_buffer_float"),a.getBool("WEBGL_RENDER_FLOAT32_ENABLED")||(this.textureHalfFloatExtension=zt(this.gl,this.debug,"OES_texture_half_float"),this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float"))):this.colorBufferFloatExtension=zt(this.gl,this.debug,"EXT_color_buffer_float"),this.vertexBuffer=ya(this.gl,this.debug),this.indexBuffer=xa(this.gl,this.debug),this.framebuffer=ee(this.gl,this.debug),this.textureConfig=wa(this.gl,this.textureHalfFloatExtension)}return Object.defineProperty(t.prototype,"debug",{get:function(){return a.getBool("DEBUG")},enumerable:!0,configurable:!0}),t.prototype.dispose=function(){var t=this;if(!this.disposed){null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");var e=this.gl;Bt(e,this.debug,function(){return e.finish()}),Bt(e,this.debug,function(){return e.bindFramebuffer(e.FRAMEBUFFER,null)}),Bt(e,this.debug,function(){return e.deleteFramebuffer(t.framebuffer)}),Bt(e,this.debug,function(){return e.bindBuffer(e.ARRAY_BUFFER,null)}),Bt(e,this.debug,function(){return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)}),Bt(e,this.debug,function(){return e.deleteBuffer(t.indexBuffer)}),this.disposed=!0}},t.prototype.createFloat32MatrixTexture=function(t,e){return this.throwIfDisposed(),Ca(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.createFloat16MatrixTexture=function(t,e){return this.throwIfDisposed(),Ea(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.createUnsignedBytesMatrixTexture=function(t,e){return this.throwIfDisposed(),Ra(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.uploadPixelDataToTexture=function(t,e){this.throwIfDisposed(),Ia(this.gl,this.debug,t,e)},t.prototype.createFloat16PackedMatrixTexture=function(t,e){return this.throwIfDisposed(),Na(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.createPackedMatrixTexture=function(t,e){return this.throwIfDisposed(),Sa(this.gl,this.debug,t,e,this.textureConfig)},t.prototype.deleteMatrixTexture=function(t){var e=this;this.throwIfDisposed(),this.outputTexture===t&&(ue(this.gl,this.debug,this.framebuffer),this.outputTexture=null),Bt(this.gl,this.debug,function(){return e.gl.deleteTexture(t)})},t.prototype.uploadMatrixToTexture=function(t,e,n,r){this.throwIfDisposed();var o=Jt();return Ta(this.gl,this.debug,t,e,n,r,o,this.textureConfig)},t.prototype.uploadMatrixToPackedTexture=function(t,e,n,r,o,a,i){return this.throwIfDisposed(),Da(this.gl,this.debug,t,e,n,r,o,a,i,this.textureConfig)},t.prototype.downloadFloat32MatrixFromOutputTexture=function(t,e,n){var r=this;return this.downloadMatrixDriver(t,function(){return Ma(r.gl,r.debug,e,n,r.textureConfig)})},t.prototype.downloadByteEncodedFloatMatrixFromOutputTexture=function(t,e,n){var r=this;return this.downloadMatrixDriver(t,function(){return Fa(r.gl,r.debug,e,n,r.textureConfig)})},t.prototype.downloadPackedMatrixFromBuffer=function(t,e,n,r,o,a){return Ba(this.gl,t,e,n,r,o,a,this.textureConfig)},t.prototype.downloadFloat32MatrixFromBuffer=function(t,e,n){return _a(this.gl,t,e,n,this.textureConfig)},t.prototype.createBufferFromTexture=function(t,e,n){this.bindTextureToFrameBuffer(t);var r=Oa(this.gl,this.debug,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r},t.prototype.createAndWaitForFence=function(){var t=this.createFence(this.gl);return this.pollFence(t)},t.prototype.createFence=function(t){var e,n,r=this;if(a.getBool("WEBGL_FENCE_API_ENABLED")){var o=t,i=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=function(){var t=o.clientWaitSync(i,0,0);return t===o.ALREADY_SIGNALED||t===o.CONDITION_SATISFIED},e=i}else a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=function(){return r.isQueryAvailable(e,a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}):n=function(){return!0};return{query:e,isFencePassed:n}},t.prototype.downloadMatrixFromPackedTexture=function(t,e,n,r,o,a){var i=this;return this.downloadMatrixDriver(t,function(){return Pa(i.gl,i.debug,e,n,r,o,a,i.textureConfig)})},t.prototype.createProgram=function(t){this.throwIfDisposed();var e=this.gl,n=Gt(e,this.debug,t),r=ga(e,this.debug),o=jt(e,this.debug);return Bt(e,this.debug,function(){return e.attachShader(o,r)}),Bt(e,this.debug,function(){return e.attachShader(o,n)}),Kt(e,this.debug,o),this.debug&&Xt(e,this.debug,o),this.vertexAttrsAreBound||(this.setProgram(o),this.vertexAttrsAreBound=ka(e,this.debug,this.program,this.vertexBuffer)),o},t.prototype.deleteProgram=function(t){var e=this;this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&Bt(this.gl,this.debug,function(){return e.gl.deleteProgram(t)})},t.prototype.setProgram=function(t){var e=this;this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&Xt(this.gl,this.debug,this.program),Bt(this.gl,this.debug,function(){return e.gl.useProgram(t)})},t.prototype.getUniformLocation=function(t,e,n){return void 0===n&&(n=!0),this.throwIfDisposed(),n?oe(this.gl,this.debug,t,e):ae(this.gl,t,e)},t.prototype.getAttributeLocation=function(t,e){var n=this;return this.throwIfDisposed(),Bt(this.gl,this.debug,function(){return n.gl.getAttribLocation(t,e)})},t.prototype.getUniformLocationNoThrow=function(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)},t.prototype.setInputMatrixTexture=function(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),ie(this.gl,this.debug,this.program,t,e,n)},t.prototype.setOutputMatrixTexture=function(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)},t.prototype.setOutputPackedMatrixTexture=function(t,e,n){this.throwIfDisposed();var r=da(e,n),o=r[0],a=r[1];this.setOutputMatrixTextureDriver(t,o,a)},t.prototype.setOutputMatrixWriteRegion=function(t,e,n,r){this.setOutputMatrixWriteRegionDriver(n,t,r,e)},t.prototype.setOutputPackedMatrixWriteRegion=function(t,e,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")},t.prototype.debugValidate=function(){null!=this.program&&Xt(this.gl,this.debug,this.program),le(this.gl)},t.prototype.executeProgram=function(){this.throwIfDisposed(),this.throwIfNoProgram();var t=this.gl;this.debug&&this.debugValidate(),Bt(t,this.debug,function(){return t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)})},t.prototype.blockUntilAllProgramsCompleted=function(){var t=this;this.throwIfDisposed(),Bt(this.gl,this.debug,function(){return t.gl.finish()})},t.prototype.getQueryTimerExtension=function(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=zt(this.gl,this.debug,2===a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension},t.prototype.getQueryTimerExtensionWebGL2=function(){return this.getQueryTimerExtension()},t.prototype.getQueryTimerExtensionWebGL1=function(){return this.getQueryTimerExtension()},t.prototype.beginQuery=function(){if(2===a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}var r=this.getQueryTimerExtensionWebGL1(),o=r.createQueryEXT();return r.beginQueryEXT(r.TIME_ELAPSED_EXT,o),o},t.prototype.endQuery=function(){if(2!==a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}else{var e=this.gl,n=this.getQueryTimerExtensionWebGL2();e.endQuery(n.TIME_ELAPSED_EXT)}},t.prototype.waitForQueryAndGetTime=function(t){return r(this,void 0,void 0,function(){var e=this;return o(this,function(n){switch(n.label){case 0:return[4,R(function(){return e.disposed||e.isQueryAvailable(t,a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})];case 1:return n.sent(),[2,this.getQueryTime(t,a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))]}})})},t.prototype.getQueryTime=function(t,e){if(0===e)return null;if(2===e){var n=this.gl;return n.getQueryParameter(t,n.QUERY_RESULT)/1e6}var r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6},t.prototype.isQueryAvailable=function(t,e){if(0===e)return!0;if(2===e){var n=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=n.getQueryParameter(t,n.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}o=(r=this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint},t.prototype.pollFence=function(t){var e=this;return new Promise(function(n){e.addItemToPoll(function(){return t.isFencePassed()},function(){return n()})})},t.prototype.pollItems=function(){for(var t=function(t){for(var e=0;e<t.length;++e){var n=t[e]();if(!n)break}return e-1}(this.itemsToPoll.map(function(t){return t.isDoneFn})),e=0;e<=t;++e){(0,this.itemsToPoll[e].resolveFn)()}this.itemsToPoll=this.itemsToPoll.slice(t+1)},t.prototype.addItemToPoll=function(t,e){var n=this;this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||R(function(){return n.pollItems(),0===n.itemsToPoll.length})},t.prototype.bindTextureToFrameBuffer=function(t){this.throwIfDisposed(),se(this.gl,this.debug,t,this.framebuffer),this.debug&&le(this.gl)},t.prototype.unbindTextureToFrameBuffer=function(){null!=this.outputTexture?(se(this.gl,this.debug,this.outputTexture,this.framebuffer),this.debug&&le(this.gl)):ue(this.gl,this.debug,this.framebuffer)},t.prototype.downloadMatrixDriver=function(t,e){this.bindTextureToFrameBuffer(t);var n=e();return this.unbindTextureToFrameBuffer(),n},t.prototype.setOutputMatrixTextureDriver=function(t,e,n){this.throwIfDisposed();var r=this.gl;se(r,this.debug,t,this.framebuffer),this.debug&&le(r),this.outputTexture=t,Bt(r,this.debug,function(){return r.viewport(0,0,e,n)}),Bt(r,this.debug,function(){return r.scissor(0,0,e,n)})},t.prototype.setOutputMatrixWriteRegionDriver=function(t,e,n,r){var o=this;this.throwIfDisposed(),Bt(this.gl,this.debug,function(){return o.gl.scissor(t,e,n,r)})},t.prototype.throwIfDisposed=function(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")},t.prototype.throwIfNoProgram=function(){if(null==this.program)throw new Error("No GPU program is currently set.")},t}();function Ua(t,e){if(t.length!==e.length)throw Error("Binary was compiled with "+t.length+" inputs, but was executed with "+e.length+" inputs");t.forEach(function(t,n){var r=t.logicalShape,o=e[n],a=o.shape;if(!x(r,a))throw Error("Binary was compiled with different shapes than the current args. Shapes "+r+" and "+a+" must match");if(!t.isUniform||!o.isUniform){var i=t.texShape,s=o.isUniform?null:o.texData.texShape;if(!x(i,s))throw Error("Binary was compiled with different texture shapes than the current args. Shape "+i+" and "+s+" must match")}})}var za=function(){return function(t,e,n){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=t;var r=n.filterWidth,o=n.inChannels,a=n.strideWidth,i=n.strideHeight,s=n.padInfo,u=n.outWidth,l=n.dilationWidth,c=n.dilationHeight,h=s.left,p=s.top,f=o*r,d=uo();this.userCode="\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            int blockIndex = rc.y + col;\n            int pos = rc.x + row;\n\n            if(blockIndex >= "+t[1]+" || pos >= "+t[0]+") continue;\n\n            int offsetY = int(blockIndex / ("+u+")) * "+i+" - "+p+";\n            int d0 = offsetY + "+c+" * (pos / "+f+");\n\n            if(d0 >= "+e[0]+" || d0 < 0) continue;\n\n            int offsetX = int(mod(float(blockIndex), "+u+".) * "+a+". - "+h+".);\n            int d1 = offsetX + "+l+" * (int(mod(float(pos), "+f+".) / "+o+".));\n\n            if(d1 >= "+e[1]+" || d1 < 0) continue;\n\n            vec2 innerDims = vec2(d1, int(mod(float(pos), "+o+".)));\n            result[row * 2 + col] = getChannel(getA(d0, int(innerDims.x),\n                                              int(innerDims.y)), innerDims);\n          }\n        }\n\n        "+d.output+" = result;\n      }\n    "}}(),Va=function(){return function(t,e,n,r,o){this.variableNames=["x"],this.outputShape=[];var a,i=e,s=t[3]-1;this.outputShape=t;var u="float("+n+") + float("+r+") * sum";a=.5===o?"inversesqrt("+u+")":1===o?"1.0/("+u+")":"exp(log("+u+") * float(-"+o+"));",this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -"+i+"; j <= "+i+"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  "+s+") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * "+a+";\n        setOutput(val);\n      }\n    "}}(),Ga=function(){return function(t,e,n,r,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=r,this.beta=o,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < "+this.depth+"; ++d) {\n          int depthBegin = int(max(0.0, float(d - "+e+")));\n          int depthEnd = int(min(float("+this.depth+"),\n              float(d + "+e+" + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = "+this.depth+";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float("+r+") * norm + float("+n+");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float("+r+")\n                * float("+o+")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * "+o+");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    "}}(),qa=function(){return function(t,e,n,r,o){this.variableNames=["x"],this.outputShape=[],this.usesPackedTextures=!0;var a,i=e,s=t[3]-1;this.outputShape=t;var u="float("+n+") + float("+r+") * sum";a=.5===o?"inversesqrt("+u+")":1===o?"1.0/("+u+")":"exp(log("+u+") * float(-"+o+"));",this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < "+this.outputShape[3]+";\n        bool hasNextRow = c < "+this.outputShape[2]+";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - "+i+";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - "+i+"; j <= "+i+"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2("+s+"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * "+a+";\n        setOutput(result);\n      }\n    "}}(),Ha=function(){return function(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;var e=t.strideHeight,n=t.strideWidth,r=t.dilationHeight,o=t.effectiveFilterHeight,a=t.effectiveFilterWidth,i=o-1-t.padInfo.top,s=a-1-t.padInfo.left,u=o*a-1;this.userCode="\n      const ivec2 pads = ivec2("+i+", "+s+");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < "+o+";\n          wR += "+r+") {\n          float dyR = float(dyRCorner + wR) / "+e+".0;\n\n          if (dyR < 0.0 || dyR >= "+t.outHeight+".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < "+a+"; wC++) {\n            float dyC = float(dyCCorner + wC) / "+n+".0;\n\n            if (dyC < 0.0 || dyC >= "+t.outWidth+".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = "+u+" - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * "+a+" + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    "}}(),$a=function(){return function(t,e,n,r,o,a){void 0===n&&(n=!1),void 0===r&&(r=!1),void 0===o&&(o=!1),void 0===a&&(a=null),this.variableNames=["matrixA","matrixB"],this.usesPackedTextures=!0,this.outputShape=e;var i=n?t[1]:t[2],s=Math.ceil(i/2),u=n?"i * 2, rc.y":"rc.y, i * 2",l=r?"rc.z, i * 2":"i * 2, rc.z",c=n?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],p="",f="";a&&(p="vec4 activation(vec4 x) {\n        "+a+"\n      }",f="result = activation(result);");var d=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),this.userCode="\n      "+p+"\n\n      const float sharedDimension = "+s+".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < "+s+"; i++) {\n          vec4 a = getMatrixA(rc.x, "+u+");\n          vec4 b = getMatrixB(rc.x, "+l+");\n\n          result += ("+c[0]+" * "+h[0]+") + ("+c[1]+" * "+h[1]+");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        "+d+"\n\n        "+f+"\n\n        setOutput(result);\n      }\n    "}}(),ja=function(){function t(t,e,n){this.variableNames=["probs"],this.outputShape=[t,n],this.userCode="\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < "+(e-1)+"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float("+(e-1)+"));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t){var e=this;return function(n,r){null==e.seedLoc&&(e.seedLoc=n.getUniformLocation(r,"seed")),n.gl.uniform1f(e.seedLoc,t)}},t}(),Ka=function(){return function(t,e,n,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float("+r+"), float("+n+"),\n                      float(index == coords.y)));\n      }\n    "}}(),Xa=function(){return function(t){this.variableNames=["A"],this.isPackShader=!0,this.outputShape=t;var e=t.length;if(0===e)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{var n=oo("rc",e),r=bo(e),o=function(t,e,n){if(1===t)return"rc > "+e[0];for(var r="",o=t-2;o<t;o++)r+=n[o]+" >= "+e[o],o<t-1&&(r+="||");return r}(e,t,n),a=function(t,e,n,r){if(1===t)return"";var o=r.slice(-2);return"\n    int r = "+o[0]+";\n    int c = "+o[1]+";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= "+e+";\n    bool rEdge = rp1 >= "+n+";\n  "}(e,t[t.length-1],t[t.length-2],n),i=function(t,e){var n=t.length,r=function(t,e){for(var n=[],r=0;r<=1;r++)for(var o=0;o<=1;o++){for(var a=(0===r?"r":"rp1")+", "+(0===o?"c":"cp1"),i=2;i<t;i++)a=e[e.length-1-i]+","+a;n.push(a)}return n}(n,e);return 1===n?"getA(rc),\n            rc + 1 >= "+t[0]+" ? 0. : getA(rc + 1),\n            0, 0":"getA("+r[0]+"),\n          cEdge ? 0. : getA("+r[1]+"),\n          rEdge ? 0. : getA("+r[2]+"),\n          rEdge || cEdge ? 0. : getA("+r[3]+")"}(t,n);this.userCode="\n        void main() {\n          "+r+" rc = getOutputCoords();\n\n          if("+o+") {\n            setOutput(vec4(0));\n          } else {\n            "+a+"\n\n            setOutput(vec4("+i+"));\n          }\n        }\n      "}}}();var Ya=function(){return function(t,e,n){this.variableNames=["x"],this.outputShape=e.map(function(e,n){return e[0]+t[n]+e[1]});var r=t.length,o=bo(r),a=e.map(function(t){return t[0]}).join(","),i=e.map(function(e,n){return e[0]+t[n]}).join(","),s=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?"\n      "+o+" start = "+o+"("+a+");\n      "+o+" end = "+o+"("+i+");\n\n      void main() {\n        "+o+" outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float("+n+"));\n        } else {\n          "+o+" coords = outC - start;\n          setOutput(getX("+s+"));\n        }\n      }\n    ":"\n        int start = "+a+";\n        int end = "+i+";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float("+n+"));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      "}}(),Qa=function(){return function(t,e,n){this.variableNames=["x"],this.usesPackedTextures=!0,this.outputShape=e.map(function(e,n){return e[0]+t[n]+e[1]});for(var r=t.length,o=bo(r),a=e.map(function(t){return t[0]}).join(","),i=e.map(function(e,n){return e[0]+t[n]}).join(","),s=oo("rc",r),u=oo("source",r),l=s[r-1]+" < "+this.outputShape[r-1],c=1===r?"source":"vec2("+u.slice(-2).join()+")",h=[o+" rc = outputLoc;",s[r-1]+" += 1;\n       if("+l+") {\n      ",1===r?"":"}\n       rc = outputLoc;\n       "+s[r-2]+" += 1;\n       if("+s[r-2]+" < "+this.outputShape[r-2]+") {",1===r?"":"  "+s[r-1]+" += 1;\n         if("+l+") {"],p=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",f="",d=0,v=1===r?2:4;d<v;d++)f+="\n        "+h[d]+"\n        if ("+p+") {\n          result["+d+"] = float("+n+");\n        } else {\n          "+o+" source = rc - start;\n          result["+d+"] = getChannel(getX("+u.join()+"), "+c+");\n        }\n      ";f+=1===r?"} ":"}}",this.userCode="\n      const "+o+" start = "+o+"("+a+");\n      const "+o+" end = "+o+"("+i+");\n\n      void main() {\n        "+o+" outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        "+f+"\n        setOutput(result);\n      }\n    "}}(),Ja=function(){return function(t,e,n){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");var r=t.filterWidth,o=t.strideHeight,a=t.strideWidth,i=t.dilationHeight,s=t.dilationWidth,u=t.effectiveFilterHeight,l=t.effectiveFilterWidth,c=t.padInfo.top,h=t.padInfo.left;this.outputShape=t.outShape;var p="avg"===e,f="0.0";if(p||(f="-1.0 / 1e-20"),n)this.userCode="\n        const ivec2 strides = ivec2("+o+", "+a+");\n        const ivec2 pads = ivec2("+c+", "+h+");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < "+u+";\n              wR += "+i+") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= "+t.inHeight+") {\n              continue;\n            }\n\n            for (int wC = 0; wC < "+l+";\n                wC += "+s+") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= "+t.inWidth+") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * "+l+" + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";else{var d=e+"("+e+"("+e+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===e&&(d="avgValue / count");var v=4*Math.floor(r/4),m=r%4,g="\n      if ("+p+") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";this.userCode="\n      const ivec2 strides = ivec2("+o+", "+a+");\n      const ivec2 pads = ivec2("+c+", "+h+");\n      const float initializationValue = "+f+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= "+t.inWidth+") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4("+f+");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < "+u+";\n            wR += "+i+") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= "+t.inHeight+") {\n            continue;\n          }\n\n          for (int wC = 0; wC < "+v+"; wC += 4) {\n            int xC = xCCorner + wC * "+s+";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+s+", d),\n              getValue(batch, xR, xC + 2 * "+s+", d),\n              getValue(batch, xR, xC + 3 * "+s+", d)\n            );\n\n            "+g+"\n          }\n\n          int xC = xCCorner + "+v+";\n          if ("+(1===m)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            "+g+"\n          } else if ("+(2===m)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+s+", d),\n              initializationValue,\n              initializationValue\n            );\n\n            "+g+"\n          } else if ("+(3===m)+") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + "+s+", d),\n              getValue(batch, xR, xC + 2 * "+s+", d),\n              initializationValue\n            );\n\n            "+g+"\n          }\n        }\n        setOutput("+d+");\n      }\n    "}}}(),Za=function(){return function(t,e){this.variableNames=["x"];var n=t.windowSize,r=t.batchSize,o=t.inSize,a=Math.ceil(o/n);this.outputShape=[r,a];var i="0.0",s="";"prod"===e?i="1.0":"min"===e?(i="1.0 / 1e-20",s="min"):"max"===e&&(i="-1.0 / 1e-20",s="max");var u=e+"("+e+"("+e+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===e?u="sumValue":"prod"===e?u="prodValue":"all"===e?u="allValue":"any"===e&&(u="anyValue");var l=4*Math.floor(n/4),c=n%4,h="\n      if ("+("sum"===e)+") {\n        sumValue += dot(values, ones);\n      } else if ("+("prod"===e)+") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = "+s+"(values, minMaxValue);\n      }\n    ",p="vec4";"all"===e?(i="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===e&&(i="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");var f="";o%n>0&&(f="\n        if (inIdx < 0 || inIdx >= "+o+") {\n          return initializationValue;\n        }\n      "),this.userCode="\n      const float initializationValue = "+i+";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        "+f+"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * "+n+";\n\n        vec4 minMaxValue = vec4("+i+");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < "+l+"; i += 4) {\n          int inIdx = inOffset + i;\n          "+p+" values = "+p+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          "+h+"\n        }\n\n        int inIdx = inOffset + "+l+";\n        if ("+(1===c)+") {\n          "+p+" values = "+p+"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          "+h+"\n        } else if ("+(2===c)+") {\n          "+p+" values = "+p+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          "+h+"\n        } else if ("+(3===c)+") {\n          "+p+" values = "+p+"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          "+h+"\n        }\n        setOutput("+u+");\n      }\n    "}}(),ti=function(){return function(t,e){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=t;for(var n="",r=0;r<4;r++){var o="thisRC = rc;";r%2==1&&(o+="thisRC.z += 1;"),r>1&&(o+="thisRC.y += 1;"),n+="\n        "+o+"\n        "+(r>0?"if(thisRC.y < rows && thisRC.z < cols){":"")+"\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result["+r+"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        "+(r>0?"}":"")+"\n      "}this.userCode="\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      "+lo(["r","c","d"],e)+"\n      return ivec3(r, c, d);\n    }\n  \n      "+function(t){return"\n    int getFlatIndex(ivec3 coords) {\n      return round("+function(t,e){if(t.length!==e.length)throw new Error("Vectors to be dotted must be of the same length -got "+t.length+" and "+e.length);for(var n=[],r=Math.floor(t.length/4),o=t.length%4,a=0;a<r;a++){var i=t.slice(4*a,4*a+4),s=e.slice(4*a,4*a+4);n.push(co(i)+", "+co(s))}return 0!==o&&(i=t.slice(4*r),s=e.slice(4*r),1===i.length&&(i=i.map(function(t){return"float("+t+")"}),s=s.map(function(t){return"float("+t+")"})),n.push(co(i)+", "+co(s))),n.map(function(t,e){return"dot("+t+")"}).join("+")}(["coords.x","coords.y","coords.z"],V(t).map(function(t){return t.toString()}).concat(["1."]))+");\n    }\n  "}(t)+"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = "+t[1]+";\n        int cols = "+t[2]+";\n\n        "+n+"\n\n        setOutput(result);\n      }\n    "}}();var ei=function(){return function(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;var r=e.shape,o=r[1],a=r[2],i=t.shape,s=i[1],u=i[2],l=[n&&s>1?o-1:o,n&&u>1?a-1:a],c=[n&&s>1?s-1:s,n&&u>1?u-1:u],h=l[0]/c[0],p=l[1]/c[1],f=1/h,d=1/p,v=2*Math.ceil(f)+2,m=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+h+");\n        const float widthScale = float("+p+");\n\n        const float invHeightScale = float("+f+");\n        const float invWidthScale = float("+d+");\n\n        const int winHeight = int("+v+");\n        const int winWidth = int("+m+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+s+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+u+") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), "+(o-1)+".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), "+(a-1)+".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "}}(),ni=function(){return function(t,e,n,r){this.variableNames=["A"],this.outputShape=[];var o=t[0],a=t[1],i=t[2],s=t[3];this.outputShape=[o,e,n,s];var u=[r&&e>1?a-1:a,r&&n>1?i-1:i],l=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+u[0]/l[0]+",\n          "+u[1]/l[1]+");\n      const vec2 inputShapeRC = vec2("+a+".0, "+i+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    "}}(),ri=function(){return function(t,e,n,r){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=[];var o=t[0],a=t[1],i=t[2],s=t[3];this.outputShape=[o,e,n,s];var u=[r&&e>1?a-1:a,r&&n>1?i-1:i],l=[r&&e>1?e-1:e,r&&n>1?n-1:n];this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          "+u[0]/l[0]+",\n          "+u[1]/l[1]+",\n          "+u[1]/l[1]+");\n      const vec3 inputShapeRC = vec3("+a+".0, "+i+".0,\n                                     "+i+".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n        \n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < "+(s-1)+"; \n        bool hasNextRow = coords.z < "+(n-1)+";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    "}}(),oi=function(){return function(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;var r=e.shape,o=r[1],a=r[2],i=t.shape,s=i[1],u=i[2],l=[n&&s>1?o-1:o,n&&u>1?a-1:a],c=[n&&s>1?s-1:s,n&&u>1?u-1:u],h=l[0]/c[0],p=l[1]/c[1],f=1/h,d=1/p,v=2*Math.ceil(f)+2,m=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float("+h+");\n        const float widthScale = float("+p+");\n\n        const float invHeightScale = float("+f+");\n        const float invWidthScale = float("+d+");\n\n        const int winHeight = int("+v+");\n        const int winWidth = int("+m+");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= "+s+") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= "+u+") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float("+l[0]+") *\n                (float(dyR) / float("+c[0]+"));\n\n            float sourceFracCol =\n                float("+l[1]+") *\n                  (float(dyC) / float("+c[1]+"));\n\n            int sourceNearestRow = int(min(\n                float(int("+o+") - 1),\n                "+n+" ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int("+a+") - 1),\n                "+n+" ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    "}}(),ai=function(){return function(t,e,n,r){this.variableNames=["A"],this.outputShape=[];var o=t[0],a=t[1],i=t[2],s=t[3];this.outputShape=[o,e,n,s];var u=[r&&e>1?a-1:a,r&&n>1?i-1:i],l=[r&&e>1?e-1:e,r&&n>1?n-1:n],c=r?"0.5":"0.0";this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          "+u[0]/l[0]+",\n          "+u[1]/l[1]+");\n      const vec2 inputShapeRC = vec2("+a+".0, "+i+".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + "+c+")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    "}}(),ii=function(){return function(t,e){this.variableNames=["x"];var n=t.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-"+n+" tensor is not yet supported");if(this.outputShape=t,1!==n){var r=t.map(function(n,r){return function(n){return-1!==e.indexOf(n)&&1!==t[n]?t[n]+" - coords["+n+"] - 1":"coords["+n+"]"}(r)}).join(","),o=bo(n);this.userCode="\n      void main() {\n        "+o+" coords = getOutputCoords();\n        setOutput(getX("+r+"));\n      }\n    "}else this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX("+t[0]+" - coord - 1));\n        }\n      "}}(),si=function(){return function(t,e){this.variableNames=["x"],this.usesPackedTextures=!0;var n=t.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-"+n+" tensor is not yet supported");this.outputShape=t;var r=oo("rc",n),o=r[n-1]+" + 1 < "+this.outputShape[n-1],a=r[n-2]+" + 1 < "+this.outputShape[n-2],i=bo(n);function s(n){var r=t.map(function(r,o){return function(n,r){return-1!==e.indexOf(n)&&1!==t[n]?t[n]+" - "+r[n]+" - 1":""+r[n]}(o,n)});return"getChannel(getX("+r.join(",")+"), vec2("+r.slice(-2).join(",")+"))"}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX("+t[0]+" - rc - 1),\n            "+t[0]+" - rc - 1);\n          if("+o+"){\n              result.g = getChannel(getX("+t[0]+" - (rc  + 1) - 1),\n                "+t[0]+" - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      ":"\n        void main() {\n          "+i+" rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = "+function(t){return s(t)}(r.slice())+";\n          if("+o+"){\n            result.g = "+function(t){return t[n-1]="("+t[n-1]+" + 1)",s(t)}(r.slice())+";\n          }\n          if("+a+") {\n            result.b = "+function(t){return t[n-2]="("+t[n-2]+" + 1)",s(t)}(r.slice())+";\n            if("+o+") {\n              result.a = "+function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",s(t)}(r.slice())+";\n            }\n          }\n          setOutput(result);\n        }\n    "}}(),ui=function(){return function(t,e,n,r,o,a,i){void 0===i&&(i=!0),this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;var s=bo(o.length),u=bo(a.length),l="";1===n?l="i":2===n&&(l="i, j");var c="getIndices("+l+")",h="";1===r?h="i":2===r&&(h="i, coords[1]");var p="getUpdates("+h+")",f=e>1?"strides[j]":"strides";this.userCode="\n        "+s+" strides = "+s+"("+o+");\n\n        void main() {\n          "+u+" coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < "+t+"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < "+e+"; j++) {\n              int index = round("+c+");\n              flattenedIndex += index * "+f+";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += "+p+";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      "}}(),li=function(){return function(t,e){this.variableNames=["x","segmentIds"];var n=t.windowSize,r=t.batchSize,o=t.inSize,a=t.numSegments,i=a*Math.ceil(o/n);this.outputShape=[r,i];var s=4*Math.floor(n/4),u=n%4,l="\n        sumValue += dot(values, segFilter);\n    ",c="";o%n>0&&(c="\n        if (inIdx < 0 || inIdx >= "+o+") {\n          return initializationValue;\n        }\n      ");var h="";o%n>0&&(h="\n        if (inIdx < 0 || inIdx >= "+o+") {\n          return -1.0;\n        }\n      "),this.userCode="\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        "+c+"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        "+h+"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          "+a+")) * float("+n+"));\n        int currentSeg = int(mod(float(outIdx), float("+a+")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < "+s+"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          "+l+"\n        }\n\n        int inIdx = inOffset + "+s+";\n        if ("+(1===u)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          "+l+"\n        } else if ("+(2===u)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          "+l+"\n        } else if ("+(3===u)+") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          "+l+"\n        }\n        setOutput(sumValue);\n      }\n    "}}(),ci=function(){return function(t,e,n){var r,o;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error("Where for rank "+n+" is not yet supported");if(1===n)o="resRC",r="resRC";else{for(var a=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],s=[],u=0;u<e.length;u++)s.push(""+a[u]),u<t&&i.push(""+a[u]);r=i.join(),o=s.join()}var l=bo(n);this.userCode="\n      void main() {\n        "+l+" resRC = getOutputCoords();\n        float cVal = getC("+r+");\n        if (cVal >= 1.0) {\n          setOutput(getA("+o+"));\n        } else {\n          setOutput(getB("+o+"));\n        }\n      }\n    "}}(),hi=function(){function t(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;var e,n=bo(this.rank),r="uniform int start["+this.rank+"];",o=function(t){if(1===t)return"sourceLoc";if(t<=6)return pi.slice(0,t).map(function(t){return"sourceLoc."+t}).join(",");throw Error("Slicing for rank "+t+" is not yet supported")}(this.rank);e="\n        "+n+" sourceLoc;\n        "+n+" coords = getOutputCoords();\n        "+t.map(function(t,e){return"sourceLoc."+pi[e]+" = start["+e+"] + coords."+pi[e]+";"}).join("\n")+"\n      ",this.userCode="\n      "+r+"\n      void main() {\n        "+e+"\n        setOutput(getSource("+o+"));\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t){var e=this;if(t.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+t.length+")");return function(n,r){null==e.startLoc&&(e.startLoc=n.getUniformLocationNoThrow(r,"start"),null==e.startLoc)||n.gl.uniform1iv(e.startLoc,t)}},t}(),pi=["x","y","z","w","u","v"];var fi=function(){function t(t){this.variableNames=["source"],this.usesPackedTextures=!0,this.outputShape=t,this.rank=t.length;var e=bo(this.rank),n=oo("coords",this.rank),r=oo("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":"vec2("+r.slice(-2).join()+")",a="getChannel(getSource("+r.join()+"), "+o+")",i="\n      result.x = "+a+";\n      if (++"+n[this.rank-1]+" < "+t[this.rank-1]+") {\n        ++"+r[this.rank-1]+";\n        result.y = "+a+";\n        --"+r[this.rank-1]+";\n      }\n    ",s=1===this.rank?"":"\n      --"+n[this.rank-1]+";\n      if (++"+n[this.rank-2]+" < "+t[this.rank-2]+") {\n        ++"+r[this.rank-2]+";\n        result.z = "+a+";\n        if (++"+n[this.rank-1]+" < "+t[this.rank-1]+") {\n          ++"+r[this.rank-1]+";\n          result.w = "+a+";\n        }\n      }\n    ",u=this.rank<=4?"sourceLoc = coords +\n            "+e+"("+t.map(function(t,e){return"start["+e+"]"}).join()+");":t.map(function(t,e){return r[e]+" = "+n[e]+" + start["+e+"];"}).join("\n");this.userCode="\n      uniform int start["+this.rank+"];\n      void main() {\n        "+e+" coords = getOutputCoords();\n        "+e+" sourceLoc;\n        "+u+" \n        vec4 result = vec4(0.);\n        "+i+"\n        "+s+"\n        setOutput(result);\n      }\n    "}return t.prototype.getCustomSetupFunc=function(t){var e=this;if(t.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+t.length+")");return function(n,r){null==e.startLoc&&(e.startLoc=n.getUniformLocationNoThrow(r,"start"),null==e.startLoc)||n.gl.uniform1iv(e.startLoc,t)}},t}(),di=function(){return function(t,e,n,r){this.variableNames=["x"];var o=n.filter(function(t,e){return-1===r.indexOf(e)});this.outputShape=o;var a=n.length,i=bo(n.length),s=bo(o.length),u="";if(1===a)u="coords * strides + begin";else{var l=0;u=n.map(function(t,e){return-1===r.indexOf(e)?(l++,1===o.length?"coords * strides["+e+"] + begin["+e+"]":"coords["+(l-1)+"] * strides["+e+"] + begin["+e+"]"):"begin["+e+"]"}).join(",")}this.userCode="\n      "+i+" begin = "+i+"("+t+");\n      "+i+" strides = "+i+"("+e+");\n\n      void main() {\n        "+s+" coords = getOutputCoords();\n        setOutput(getX("+u+"));\n      }\n    "}}(),vi=function(){function t(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}return t.prototype.acquireTexture=function(t,e,n){var r,o=mi(e,n),a=gi(t,o,n);if(a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]),this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this.log();var i=this.freeTextures[a].shift();return this.usedTextures[a].push(i),i}return this.numUsedTextures++,this.log(),o===la.PACKED_2X2_FLOAT32?r=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):o===la.PACKED_2X2_FLOAT16?r=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):o===la.UNPACKED_FLOAT32?r=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):o===la.UNPACKED_FLOAT16?r=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):o===la.PACKED_4X1_UNSIGNED_BYTE&&(r=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[a].push(r),r},t.prototype.releaseTexture=function(t,e,n,r){if(null!=this.freeTextures){var o=gi(e,mi(n,r),r);o in this.freeTextures||(this.freeTextures[o]=[]),this.freeTextures[o].push(t),this.numFreeTextures++,this.numUsedTextures--;var a=this.usedTextures[o],i=a.indexOf(t);if(i<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(i,1),this.log()}},t.prototype.log=function(){if(this.logEnabled){var t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",this.numFreeTextures+" / "+this.numUsedTextures,"("+t+")")}},t.prototype.getNumUsedTextures=function(){return this.numUsedTextures},t.prototype.getNumFreeTextures=function(){return this.numFreeTextures},t.prototype.dispose=function(){var t=this;if(null!=this.freeTextures){for(var e in this.freeTextures)this.freeTextures[e].forEach(function(e){t.gpgpu.deleteMatrixTexture(e)});for(var e in this.usedTextures)this.usedTextures[e].forEach(function(e){t.gpgpu.deleteMatrixTexture(e)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0}},t}();function mi(t,e){if(t===ua.UPLOAD)return e?la.PACKED_2X2_FLOAT32:la.UNPACKED_FLOAT32;if(t===ua.RENDER||null==t)return e?a.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?la.PACKED_2X2_FLOAT32:la.PACKED_2X2_FLOAT16:a.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?la.UNPACKED_FLOAT32:la.UNPACKED_FLOAT16;if(t===ua.DOWNLOAD||t===ua.PIXELS)return la.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+t)}function gi(t,e,n){return t[0]+"_"+t[1]+"_"+e+"_"+n}var yi=function(){return function(t,e){this.variableNames=["A"];for(var n=new Array(t.length),r=0;r<n.length;r++)n[r]=t[r]*e[r];this.outputShape=n,this.rank=n.length;var o=bo(this.rank),a=function(t){var e=t.length;if(e>5)throw Error("Tile for rank "+e+" is not yet supported");if(1===e)return"imod(resRC, "+t[0]+")";for(var n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[],o=0;o<t.length;o++)r.push("imod("+n[o]+", "+t[o]+")");return r.join()}(t);this.userCode="\n      void main() {\n        "+o+" resRC = getOutputCoords();\n        setOutput(getA("+a+"));\n      }\n    "}}();var xi=function(){return function(t,e){this.variableNames=["A"];for(var n=new Array(t.length),r=0;r<n.length;r++)n[r]=t[e[r]];this.outputShape=n,this.rank=n.length;var o=bo(this.rank),a=function(t){var e=t.length;if(e>6)throw Error("Transpose for rank "+e+" is not yet supported");for(var n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e),o=0;o<t.length;o++)r[t[o]]=n[o];return r.join()}(e);this.userCode="\n    void main() {\n      "+o+" resRC = getOutputCoords();\n      setOutput(getA("+a+"));\n    }\n    "}}();var wi=function(){return function(t,e){this.variableNames=["A"],this.usesPackedTextures=!0;for(var n=new Array(t.length),r=0;r<n.length;r++)n[r]=t[e[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank "+this.rank+" is not yet supported.");var o=bo(this.rank),a=ro("rc",this.rank),i=new Array(this.rank);for(r=0;r<e.length;r++)i[e[r]]=a[r];var s="vec2("+i.slice(-2).join()+")",u="++"+a[this.rank-1]+" < "+n[this.rank-1],l="getChannel(getA("+i.join()+"), "+s+")";this.userCode="\n    void main() {\n      "+o+" rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = "+l+";\n      if("+u+") {\n        result[1] = "+l+";\n      }\n      --"+a[this.rank-1]+";\n      if(++"+a[this.rank-2]+" < "+n[this.rank-2]+") {\n        result[2] = "+l+";\n        if("+u+") {\n          result[3] = "+l+";\n        }\n      }  \n      setOutput(result);\n    }\n    "}}(),bi=1.7580993408473768,Ci=1.0507009873554805,Ei=function(){return function(t,e){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      float unaryOperation(float x) {\n        "+e+"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "}}(),Ri="if (isnan(x)) return x;",Si="return x;",Ni=Ri+"\n  return (x < 0.0) ? 0.0 : x;\n",ki="\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = "+bi+";\n  float scale = "+Ci+";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";var Ii="return exp(x);",Ai=Ri+"\n  return sin(x);\n",Ti=Ri+"\n  return cos(x);\n",Di=Ri+"\n  return atan(x);\n",Oi=Ri+"\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));",_i=Ri+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;",Mi="return x;",Fi="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Bi=function(){return function(t,e){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=t,this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        "+e+"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    "}}(),Pi=function(){return function(t){this.variableNames=["A"],this.usesPackedTextures=!0,this.outputShape=t;var e=t.length,n=oo("rc",e),r=bo(e),o=function(t,e){if(1===t)return"rc";for(var n="",r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}(e,n),a=n.slice(-2),i=e<=1?"rc":"vec2("+a.join(",")+")";this.userCode="\n      void main() {\n        "+r+" rc = getOutputCoords();\n        vec4 packedInput = getA("+o+");\n\n        setOutput(getChannel(packedInput, "+i+"));\n      }\n    "}}(),Li={};var Wi=600;var Ui=function(){function t(t){if(this.gpgpu=t,this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.warnedAboutMemory=!1,this.disposed=!1,!a.getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==t){var e=Ft(a.getNumber("WEBGL_VERSION"));this.binaryCache=(n=a.getNumber("WEBGL_VERSION"))in Li?Li[n]:(Li[n]={},Li[n]),this.gpgpu=new Wa(e),this.canvas=e.canvas,this.gpgpuCreatedLocally=!0}else this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=t.gl.canvas;var n;this.textureManager=new vi(this.gpgpu),this.numMBBeforeWarning=null==a.global.screen?1024:a.global.screen.height*a.global.screen.width*window.devicePixelRatio*Wi/1024/1024,this.texData=new Yn(Dt)}return t.prototype.register=function(t,e,n){if(this.texData.has(t))throw new Error("Data buffer is already registered");this.texData.set(t,{shape:e,dtype:n})},t.prototype.fromPixels=function(t,e){if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");var n=[t.height,t.width],r=[t.height,t.width,e];if(a.getBool("IS_BROWSER")){if(!(t instanceof HTMLVideoElement||t instanceof HTMLImageElement||t instanceof HTMLCanvasElement||t instanceof ImageData))throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or ImageData, but was "+t.constructor.name);if(t instanceof HTMLVideoElement){if(null==this.fromPixels2DContext){if("complete"!==document.readyState)throw new Error("The DOM is not ready yet. Please call tf.browser.fromPixels() once the DOM is ready. One way to do that is to add an event listener for `DOMContentLoaded` on the document object");this.fromPixels2DContext=document.createElement("canvas").getContext("2d")}this.fromPixels2DContext.canvas.width=t.width,this.fromPixels2DContext.canvas.height=t.height,this.fromPixels2DContext.drawImage(t,0,0,t.width,t.height),t=this.fromPixels2DContext.canvas}}var o=this.makeTensorHandle(n,"int32");this.texData.get(o.dataId).usage=ua.PIXELS,this.gpgpu.uploadPixelDataToTexture(this.getTexture(o.dataId),t);var i=new ia(r),s=this.compileAndRun(i,[o]);return this.disposeData(o.dataId),s},t.prototype.makeTensorHandle=function(t,e){var n={};return this.register(n,t,e),{dataId:n,shape:t,dtype:e}},t.prototype.write=function(t,e){if(null==e)throw new Error("MathBackendWebGL.write(): values can not be null");if(a.getBool("DEBUG"))for(var n=0;n<e.length;n++){var r=e[n];if(!Wt(r))throw Error("The value "+r+" cannot be represented on this device.")}var o=this.texData.get(t);if("complex64"===o.dtype)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.releaseGPUData(t),o.usage=ua.UPLOAD,o.values=e},t.prototype.readSync=function(t){var e=this.texData.get(t),n=e.values,r=e.dtype,o=e.complexTensors,a=e.slice,i=e.shape;if(null!=a){var s=new Ei(i,"return x;"),u=this.compileAndRun(s,[{dataId:t,shape:i,dtype:r}]),l=this.readSync(u.dataId);return u.dispose(),l}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===r)return n;var c,h,p=null!=this.activeTimers;(p&&(c=performance.now()),"complex64"===r)?h=er(o.real.dataSync(),o.imag.dataSync()):h=this.getValuesFromTexture(t);return p&&(this.downloadWaitMs+=performance.now()-c),this.convertAndCacheOnCPU(t,h)},t.prototype.read=function(t){return r(this,void 0,void 0,function(){var e,n,r,i,s,u,l,c,h,p,f,d,v,m,g,x,w,b,C,E,R,S,N,k,I,A,T,D;return o(this,function(o){switch(o.label){case 0:if(this.pendingRead.has(t))return r=this.pendingRead.get(t),[2,new Promise(function(t){return r.push(t)})];if(i=this.texData.get(t),s=i.texture,u=i.values,l=i.texShape,c=i.isPacked,h=i.shape,p=i.slice,f=i.dtype,d=i.complexTensors,null!=p)return v=new Ei(h,"return x;"),m=this.compileAndRun(v,[{dataId:t,shape:h,dtype:f}]),g=this.read(m.dataId),m.dispose(),[2,g];if(null!=u)return[2,this.convertAndCacheOnCPU(t)];if(this.pendingRead.set(t,[]),!a.getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===a.getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");return x=null,"complex64"===f?[3,2]:(w=l[1],b=l[0],c&&(e=da(l[0],l[1]),w=e[0],b=e[1]),a.get("WEBGL_BUFFER_SUPPORTED")&&(x=this.gpgpu.createBufferFromTexture(s,b,w)),[4,this.gpgpu.createAndWaitForFence()]);case 1:o.sent(),o.label=2;case 2:return"complex64"!==f?[3,4]:[4,Promise.all([d.real.data(),d.imag.data()])];case 3:return E=o.sent(),R=E[0],S=E[1],C=er(R,S),[3,5];case 4:null==x?C=this.getValuesFromTexture(t):(N=y(h),c?(k=fe(h),I=1,A=1,h.length&&(n=de(h),I=n[0],A=n[1]),C=this.gpgpu.downloadPackedMatrixFromBuffer(x,k,I,A,l[0],l[1]).subarray(0,N)):C=this.gpgpu.downloadFloat32MatrixFromBuffer(x,l[0],l[1]).subarray(0,N)),o.label=5;case 5:return T=this.convertAndCacheOnCPU(t,C),D=this.pendingRead.get(t),this.pendingRead.delete(t),D.forEach(function(t){return t(T)}),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)),[2,T]}})})},t.prototype.getValuesFromTexture=function(t){var e,n=this,r=this.texData.get(t),o=r.shape,i=r.dtype,s=r.texture,u=r.texShape,l=y(o);if(a.getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){if(this.texData.get(t).isPacked){var c=fe(o),h=1,p=1;return o.length&&(h=(e=de(o))[0],p=e[1]),this.gpgpu.downloadMatrixFromPackedTexture(s,c,h,p,u[0],u[1]).subarray(0,l)}return this.gpgpu.downloadFloat32MatrixFromOutputTexture(s,u[0],u[1]).subarray(0,l)}var f=this.makeTensorHandle(o,"float32");f.size=y(o),this.texData.get(f.dataId).usage=ua.DOWNLOAD;var d=Fe(function(){var e=new ea(o);return n.compileAndRun(e,[{shape:o,dtype:i,dataId:t}],f,null)}),v=this.texData.get(d.dataId),m=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(v.texture,v.texShape[0],v.texShape[1]).subarray(0,l);return this.disposeData(f.dataId),m},t.prototype.time=function(t){return r(this,void 0,void 0,function(){var e,n,r,a,i,s,u;return o(this,function(o){switch(o.label){case 0:return e=this.activeTimers,n=[],r=!1,null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,t(),a=g(this.activeTimers.map(function(t){return t.query})).filter(function(t){return null!=t}),i=g(this.activeTimers.map(function(t){return t.name})).filter(function(t){return null!=t}),this.activeTimers=e,r&&(this.programTimersStack=null),[4,Promise.all(a)];case 1:return s=o.sent(),u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:f(s),getExtraProfileInfo:function(){return s.map(function(t,e){return{name:i[e],ms:t}}).map(function(t){return t.name+": "+t.ms}).join(", ")},wallMs:null},this.uploadWaitMs=0,this.downloadWaitMs=0,[2,u]}})})},t.prototype.memory=function(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU}},t.prototype.startTimer=function(){return a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?this.gpgpu.beginQuery():{startMs:performance.now(),endMs:null}},t.prototype.endTimer=function(t){return a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(this.gpgpu.endQuery(),t):(t.endMs=performance.now(),t)},t.prototype.getQueryTime=function(t){return r(this,void 0,void 0,function(){var e;return o(this,function(n){return a.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?[2,this.gpgpu.waitForQueryAndGetTime(t)]:[2,(e=t).endMs-e.startMs]})})},t.prototype.disposeData=function(t){if(!this.pendingDisposal.has(t))if(this.pendingRead.has(t))this.pendingDisposal.add(t);else if(this.texData.has(t)){this.releaseGPUData(t);var e=this.texData.get(t).complexTensors;null!=e&&(e.real.dispose(),e.imag.dispose()),this.texData.delete(t)}},t.prototype.releaseGPUData=function(t){var e=this.texData.get(t),n=e.texture,r=e.dtype,o=e.texShape,a=e.usage,i=e.isPacked,s=e.slice,u=s&&s.origDataId||t,l=this.dataRefCount.get(u);l>1?this.dataRefCount.set(u,l-1):(this.dataRefCount.delete(u),null!=n&&(this.numBytesInGPU-=this.computeBytes(o,r),this.textureManager.releaseTexture(n,o,a,i)));var c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null},t.prototype.getTexture=function(t){return this.uploadToGPU(t),this.texData.get(t).texture},t.prototype.getCPUBackend=function(){return a.getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=Dt.findBackend("cpu")),this.cpuBackend):null},t.prototype.shouldExecuteOnCPU=function(t,e){var n=this;return void 0===e&&(e=128),null!=this.getCPUBackend()&&t.every(function(t){return null==n.texData.get(t.dataId).texture&&t.size<e})},t.prototype.getGPGPUContext=function(){return this.gpgpu},t.prototype.getCanvas=function(){return this.canvas},t.prototype.complex=function(t,e){var n=this.makeOutputArray(t.shape,"complex64");return this.texData.get(n.dataId).complexTensors={real:Dt.keep(t.clone()),imag:Dt.keep(e.clone())},n},t.prototype.real=function(t){return this.texData.get(t.dataId).complexTensors.real.clone()},t.prototype.imag=function(t){return this.texData.get(t.dataId).complexTensors.imag.clone()},t.prototype.slice=function(t,e,n){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.slice(t,e,n);var r=this.texData.get(t.dataId).isPacked,o=mn(t.shape,e,n);if(r||!o){var i=a.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fi(n):new hi(n),s=i.getCustomSetupFunc(e);return this.compileAndRun(i,[t],null,s)}return this.uploadToGPU(t.dataId),this.shallowSlice(t,e,n)},t.prototype.shallowSlice=function(t,e,n){var r=this.texData.get(t.dataId),o=ft.make(n,{},t.dtype,this),a=this.texData.get(o.dataId);Object.assign(a,r),a.shape=n,a.dtype=t.dtype;var i=gn(e,t.strides);r.slice&&(i+=r.slice.flatOffset),a.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||t.dataId};var s=this.dataRefCount.get(a.slice.origDataId)||1;return this.dataRefCount.set(a.slice.origDataId,s+1),o},t.prototype.stridedSlice=function(t,e,n,r,o,a,i,s,u){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.stridedSlice(t,e,n,r,o,a,i,s,u);var l=fn(t.shape,e,n,r,o,a,i,s,u),c=l[0],h=l[1],p=l[2],f=h.filter(function(t,e){return-1===p.indexOf(e)});if(f.some(function(t){return 0===t}))return Fn([],f);var d=new di(c,r,h,p);return this.compileAndRun(d,[t])},t.prototype.reverse=function(t,e){var n=a.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new si(t.shape,e):new ii(t.shape,e);return this.compileAndRun(n,[t])},t.prototype.concat=function(t,e){if(this.shouldExecuteOnCPU(t))return this.cpuBackend.concat(t,e);if(1===t.length)return t[0];if(t.length>a.getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){var n=Math.floor(t.length/2),r=this.concat(t.slice(0,n),e),o=this.concat(t.slice(n),e);return this.concat([r,o],e)}if(a.getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].rank>1){var i=new Uo(t.map(function(t){return t.shape}),e);return this.compileAndRun(i,t)}var s=sn(t.map(function(t){return t.shape}),e),u=t.map(function(t){return t.as2D(-1,y(t.shape.slice(e)))}),l=new Wo(u.map(function(t){return t.shape}));return this.compileAndRun(l,u).reshape(s)},t.prototype.neg=function(t){var e=new Ei(t.shape,"return -x;");return this.compileAndRun(e,[t])},t.prototype.batchMatMul=function(t,e,n,r){var o=n?t.shape[2]:t.shape[1],a=r?e.shape[1]:e.shape[2],i=n?t.shape[1]:t.shape[2],s=t.shape[0];if((1===o||1===a)&&i>1e3){n&&(t=t.transpose([0,2,1])),r&&(e=e.transpose([0,2,1]));var u=1===a?t:t.as3D(s,i,1),l=1===a?2:1,c=1===a?e.as3D(s,1,i):e;return this.multiply(u,c).sum(l,!0)}var h=Ct(t.dtype,e.dtype),p=new $a(t.shape,[s,o,a],n,r),f=this.makePackedTensor(p.outputShape,h);return this.compileAndRun(p,[t,e],f)},t.prototype.fusedBatchMatMul=function(t,e,n,r,o,a){var i=n?t.shape[2]:t.shape[1],s=r?e.shape[1]:e.shape[2],u=t.shape[0],l=Ct(t.dtype,e.dtype),c=new $a(t.shape,[u,i,s],n,r,!!o,a?function(t,e){if(void 0===e&&(e=!1),"linear"===t)return e?Mi:Si;if("relu"===t)return e?Fi:Ni;throw new Error("Activation "+t+" has not been implemented for the WebGL backend.")}(a,!0):null),h=this.makePackedTensor(c.outputShape,l),p=[t,e];return o&&p.push(o),this.compileAndRun(c,p,h)},t.prototype.multiply=function(t,e){if("complex64"===t.dtype){var n=this.texData.get(t.dataId),r=this.texData.get(e.dataId),o=new To(Io,t.shape,e.shape),i=new To(Ao,t.shape,e.shape),s=[this.makeComplexComponentTensorHandle(t,n.complexTensors.real),this.makeComplexComponentTensorHandle(t,n.complexTensors.imag),this.makeComplexComponentTensorHandle(e,r.complexTensors.real),this.makeComplexComponentTensorHandle(e,r.complexTensors.imag)],u=this.compileAndRun(o,s),l=this.compileAndRun(i,s),c=this.complex(u,l);return u.dispose(),l.dispose(),c}if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.multiply(t,e);if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,_o,t.dtype);var h=new Mo(_o,t.shape,e.shape),p=this.makeOutputArray(h.outputShape,t.dtype);return this.compileAndRun(h,[t,e],p)},t.prototype.batchNormalization=function(t,e,n,r,o,i){var s=[t,e,n],u=null;null!=i&&(u=i.shape,s.push(i));var l=null;if(null!=o&&(l=o.shape,s.push(o)),a.getBool("WEBGL_PACK_NORMALIZATION")){var c=new ko(t.shape,e.shape,n.shape,u,l,r);return this.compileAndRun(c,s)}var h=new No(t.shape,e.shape,n.shape,u,l,r);return this.compileAndRun(h,s)},t.prototype.localResponseNormalization4D=function(t,e,n,r,o){var i=a.getBool("WEBGL_PACK_NORMALIZATION")?new qa(t.shape,e,n,r,o):new Va(t.shape,e,n,r,o);return this.compileAndRun(i,[t])},t.prototype.LRNGrad=function(t,e,n,r,o,a,i){var s=new Ga(e.shape,r,o,a,i);return this.compileAndRun(s,[e,n,t])},t.prototype.tile=function(t,e){var n=new yi(t.shape,e);return this.compileAndRun(n,[t])},t.prototype.pad=function(t,e,n){var r=a.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Qa(t.shape,e,n):new Ya(t.shape,e,n);return this.compileAndRun(r,[t])},t.prototype.transpose=function(t,e){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.transpose(t,e);var n=a.getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new wi(t.shape,e):new xi(t.shape,e);return this.compileAndRun(n,[t])},t.prototype.gather=function(t,e,n){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.gather(t,e,n);var r=new sa(t.shape,e.size,n);return this.compileAndRun(r,[t,e])},t.prototype.batchToSpaceND=function(t,e,n){d(t.rank<=4,function(){return"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"});var r=e.reduce(function(t,e){return t*e}),o=Ke(t.shape,e,r),a=Xe(o.length,e.length),i=Ye(t.shape,e,r),s=Qe(n,e.length),u=Je(i,n,e.length);return t.reshape(o).transpose(a).reshape(i).slice(s,u)},t.prototype.spaceToBatchND=function(t,e,n){d(t.rank<=4,function(){return"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"});var r=e.reduce(function(t,e){return t*e}),o=[[0,0]];o.push.apply(o,n);for(var a=1+e.length;a<t.shape.length;++a)o.push([0,0]);var i=t.pad(o),s=Ke(i.shape,e,r,!1),u=Xe(s.length,e.length,!1),l=Ye(i.shape,e,r,!1);return i.reshape(s).transpose(u).reshape(l)},t.prototype.reduce=function(t,e,n){var r=t.shape[0],o=t.shape[1],a=cn(o),i=new Za({windowSize:a,inSize:o,batchSize:r},e),s=i.outputShape,u=s[0],l=s[1],c=this.makeOutputArray([u,l],n);return this.compileAndRun(i,[t],c),1===c.shape[1]?c:this.reduce(c,e,n)},t.prototype.argReduce=function(t,e,n){void 0===n&&(n=null);var r=t.shape[0],o=t.shape[1];null!=n&&(r=n.shape[0],o=n.shape[1]);var a=cn(o),i=new no({windowSize:a,inSize:o,batchSize:r},e,null==n),s=i.outputShape,u=s[0],l=s[1],c=this.makeOutputArray([u,l],"int32"),h=[t];return null!=n&&h.push(n),this.compileAndRun(i,h,c),1===c.shape[1]?c:this.argReduce(t,e,c)},t.prototype.argReducePacked=function(t,e,n){void 0===n&&(n=null);var r=null!=n?n.shape:t.shape,o=cn(r[r.length-1]),a=new Ro(r,o,e,null==n),i=this.makePackedTensor(a.outputShape,"int32"),s=null==n?[t]:[t,n];return this.compileAndRun(a,s,i),i.rank===t.rank?this.argReducePacked(t,e,i):i},t.prototype.sum=function(t,e){nn("sum",e,t.rank);var n=tn(t.shape,e),r=n[0],o=y(n[1]),a=t.as2D(-1,o),i=Et(t.dtype);return this.reduce(a,"sum",i).reshape(r)},t.prototype.prod=function(t,e){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.prod(t,e);var n=tn(t.shape,e),r=n[0],o=y(n[1]),a=t.as2D(-1,o),i=Et(t.dtype);return this.reduce(a,"prod",i).reshape(r)},t.prototype.unsortedSegmentSum=function(t,e,n){var r=0,o=rn([r],t.rank),a=t;null!=o&&(a=t.transpose(o),r=an(1,t.rank)[0]);var i=function(t,e,n){for(var r=[],o=t.length,a=0;a<o;a++)a!==e?r.push(t[a]):r.push(n);return r}(a.shape,r,n),s=y([a.shape[r]]),u=a.as2D(-1,s),l=Et(t.dtype),c=this.segOpCompute(u,"unsortedSegmentSum",e,l,n).reshape(i);return null!=o&&(c=c.transpose(on(o))),c},t.prototype.segOpCompute=function(t,e,n,r,o){var a=t.shape[0],i=t.shape[1],s=function(t,e){var n,r=!1;for(t<=ln?(n=t,r=!0):n=z(t,Math.floor(Math.sqrt(t)));!r;)n>e||n===t?r=!0:n=z(t,n+1);return n}(i,o),u=new li({windowSize:s,inSize:i,batchSize:a,numSegments:o},e),l=u.outputShape,c=l[0],h=l[1],p=this.makeOutputArray([c,h],r);return this.compileAndRun(u,[t,n],p),p.shape[1]===o?p:(n=jn(0,o).tile([i/s]),this.segOpCompute(p,e,n,r,o))},t.prototype.argMinMaxReduce=function(t,e,n){var r=[e];if(nn("arg"+n.charAt(0).toUpperCase()+n.slice(1),r,t.rank),!a.getBool("WEBGL_PACK_REDUCE")||t.rank<=2){var o=tn(t.shape,r),i=o[0],s=y(o[1]),u=t.as2D(-1,s);return this.argReduce(u,n).reshape(i)}return this.argReducePacked(t,n)},t.prototype.argMin=function(t,e){return this.argMinMaxReduce(t,e,"min")},t.prototype.argMax=function(t,e){return this.argMinMaxReduce(t,e,"max")},t.prototype.cumsum=function(t,e,n,r){if(e!==t.rank-1)throw new Error("WebGL cumsum shader expects an inner-most axis="+(t.rank-1)+" but got axis="+e);var o=new Jo(t.shape,n,r);return this.compileAndRun(o,[t])},t.prototype.equal=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(equal(a, b));\n","bool");var n=new Mo("return float(a == b);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.notEqual=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(notEqual(a, b));\n","bool");var n=new Mo("return float(a != b);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.less=function(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.less(t,e);if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(lessThan(a, b));\n","bool");var n=new Mo("return float(a < b);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.lessEqual=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(lessThanEqual(a, b));\n","bool");var n=new Mo("return float(a <= b);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.greater=function(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.greater(t,e);if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(greaterThan(a, b));\n","bool");var n=new Mo("return float(a > b);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.greaterEqual=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(greaterThanEqual(a, b));\n","bool");var n=new Mo("return float(a >= b);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.logicalNot=function(t){var e=new Ei(t.shape,"return float(!(x >= 1.0));");return this.compileAndRun(e,[t])},t.prototype.logicalAnd=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n","bool");var n=new Mo("return float(a >= 1.0 && b >= 1.0);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.logicalOr=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n","bool");var n=new Mo("return float(a >= 1.0 || b >= 1.0);",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"bool");return this.compileAndRun(n,[t,e],r)},t.prototype.select=function(t,e,n){var r=new ci(t.rank,e.shape,e.rank),o=this.makeOutputArray(r.outputShape,Ct(e.dtype,n.dtype));return this.compileAndRun(r,[t,e,n],o)},t.prototype.where=function(t){je("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");var e=t.dataSync();return Zr(t.shape,e)},t.prototype.topk=function(t,e,n){return ur(t.dataSync(),t.shape,t.dtype,e)},t.prototype.min=function(t,e){nn("min",e,t.rank);var n=tn(t.shape,e),r=n[0],o=y(n[1]),a=t.as2D(-1,o);return this.reduce(a,"min",a.dtype).reshape(r)},t.prototype.minimum=function(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.minimum(t,e);var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Mo("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])},t.prototype.mod=function(t,e){var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Mo("if (b == 0.0) return NAN;\n  return mod(a, b);",t.shape,e.shape);return this.compileAndRun(n,[t,e])},t.prototype.max=function(t,e){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.max(t,e);nn("max",e,t.rank);var n=tn(t.shape,e),r=n[0],o=y(n[1]),a=t.as2D(-1,o);return this.reduce(a,"max",a.dtype).reshape(r)},t.prototype.maximum=function(t,e){if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.maximum(t,e);var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Mo("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])},t.prototype.all=function(t,e){nn("all",e,t.rank);var n=tn(t.shape,e),r=n[0],o=y(n[1]),a=t.as2D(-1,o);return this.reduce(a,"all",a.dtype).reshape(r)},t.prototype.any=function(t,e){nn("any",e,t.rank);var n=tn(t.shape,e),r=n[0],o=y(n[1]),a=t.as2D(-1,o);return this.reduce(a,"any",a.dtype).reshape(r)},t.prototype.squaredDifference=function(t,e){var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo("return (a - b) * (a - b);",t.shape,e.shape):new Mo("return (a - b) * (a - b);",t.shape,e.shape);return this.compileAndRun(n,[t,e])},t.prototype.realDivide=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS")){return this.packedBinaryOp(t,e,"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(b.x == 0.0) {\n    result.x = NAN;\n  } else if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(b.y == 0.0) {\n    result.y = NAN;\n  } else if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(b.z == 0.0) {\n    result.z = NAN;\n  } else if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(b.w == 0.0) {\n    result.w = NAN;\n  } else if(a.w == b.w) {\n    result.w = 1.;\n  }\n  \n  return result;\n","float32",!0)}var n=new Mo("\nif (b == 0.0) {\n  return NAN;\n} \nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"float32");return this.compileAndRun(n,[t,e],r)},t.prototype.floorDiv=function(t,e){if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n","int32");var n=new Mo("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",t.shape,e.shape),r=this.makeOutputArray(n.outputShape,"int32");return this.compileAndRun(n,[t,e],r)},t.prototype.add=function(t,e){if("complex64"===t.dtype&&"complex64"===e.dtype)return this.complexSeparableBinaryOp(t,e,Do);if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.add(t,e);var n=Ct(t.dtype,e.dtype);if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,Do,n);var r=new Mo(Do,t.shape,e.shape),o=this.makeOutputArray(r.outputShape,n);return this.compileAndRun(r,[t,e],o)},t.prototype.packedBinaryOp=function(t,e,n,r,o){void 0===o&&(o=!1);var a=new Fo(n,t.shape,e.shape,o),i=this.makePackedTensor(a.outputShape,r);return this.compileAndRun(a,[t,e],i)},t.prototype.complexSeparableBinaryOp=function(t,e,n){var r=this,o=this.texData.get(t.dataId),a=this.texData.get(e.dataId),i=[[o.complexTensors.real,a.complexTensors.real],[o.complexTensors.imag,a.complexTensors.imag]].map(function(o){var a=o[0],i=o[1],s=r.makeComplexComponentTensorHandle(t,a),u=r.makeComplexComponentTensorHandle(e,i),l=new Mo(n,t.shape,e.shape),c=r.makeOutputArray(l.outputShape,Ct(a.dtype,i.dtype));return r.compileAndRun(l,[s,u],c)}),s=i[0],u=i[1],l=this.complex(s,u);return s.dispose(),u.dispose(),l},t.prototype.makeComplexComponentTensorHandle=function(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}},t.prototype.addN=function(t){if(1===t.length)return t[0];if(t.length>a.get("WEBGL_MAX_TEXTURES_IN_SHADER")){var e=Math.floor(t.length/2),n=this.addN(t.slice(0,e)),r=this.addN(t.slice(e));return this.addN([n,r])}var o=t.map(function(t){return t.dtype}).reduce(function(t,e){return Ct(t,e)}),i=t.map(function(t){return t.shape}),s=a.getBool("WEBGL_PACK"),u=s?new eo(t[0].shape,i):new to(t[0].shape,i),l=s?this.makePackedTensor(u.outputShape,o):this.makeOutputArray(u.outputShape,o);return this.compileAndRun(u,t,l)},t.prototype.subtract=function(t,e){if("complex64"===t.dtype&&"complex64"===e.dtype)return this.complexSeparableBinaryOp(t,e,Oo);if(this.shouldExecuteOnCPU([t,e]))return this.cpuBackend.subtract(t,e);var n=Ct(t.dtype,e.dtype);if(a.getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,Oo,t.dtype);var r=new Mo(Oo,t.shape,e.shape),o=this.makeOutputArray(r.outputShape,n);return this.compileAndRun(r,[t,e],o)},t.prototype.pow=function(t,e){var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS"),r=n?new Fo("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Mo("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",t.shape,e.shape),o=Ct(t.dtype,e.dtype),i=n?this.makePackedTensor(r.outputShape,o):this.makeOutputArray(r.outputShape,o);return this.compileAndRun(r,[t,e],i)},t.prototype.ceil=function(t){var e=new Ei(t.shape,"return ceil(x);");return this.compileAndRun(e,[t])},t.prototype.floor=function(t){var e=new Ei(t.shape,"return floor(x);");return this.compileAndRun(e,[t])},t.prototype.sign=function(t){var e=new Ei(t.shape,"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");return this.compileAndRun(e,[t])},t.prototype.isNaN=function(t){var e=new Ei(t.shape,"return float(isnan(x));"),n=this.makeOutputArray(e.outputShape,"bool");return this.compileAndRun(e,[t],n)},t.prototype.isInf=function(t){var e=new Ei(t.shape,"return float(isinf(x));"),n=this.makeOutputArray(e.outputShape,"bool");return this.compileAndRun(e,[t],n)},t.prototype.isFinite=function(t){var e=new Ei(t.shape,"return float(!isnan(x) && !isinf(x));"),n=this.makeOutputArray(e.outputShape,"bool");return this.compileAndRun(e,[t],n)},t.prototype.round=function(t){var e=new Ei(t.shape,"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");return this.compileAndRun(e,[t])},t.prototype.exp=function(t){var e;return e=a.getBool("WEBGL_PACK")?new Bi(t.shape,Ii):new Ei(t.shape,Ii),this.compileAndRun(e,[t])},t.prototype.expm1=function(t){var e=new Ei(t.shape,"return exp(x) - 1.0;");return this.compileAndRun(e,[t])},t.prototype.log=function(t){var e;return e=a.getBool("WEBGL_PACK")?new Bi(t.shape,"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n"):new Ei(t.shape,"if (x < 0.0) return NAN;\n  return log(x);"),this.compileAndRun(e,[t])},t.prototype.log1p=function(t){var e=new Ei(t.shape,"return log(1.0 + x);");return this.compileAndRun(e,[t])},t.prototype.sqrt=function(t){var e=new Ei(t.shape,"return sqrt(x);");return this.compileAndRun(e,[t])},t.prototype.rsqrt=function(t){if(this.shouldExecuteOnCPU([t]))return this.cpuBackend.rsqrt(t);var e=new Ei(t.shape,"return inversesqrt(x);");return this.compileAndRun(e,[t])},t.prototype.square=function(t){var e=new Ei(t.shape,"return x * x;");return this.compileAndRun(e,[t])},t.prototype.reciprocal=function(t){var e=new Ei(t.shape,"return 1.0 / x;");return this.compileAndRun(e,[t])},t.prototype.relu=function(t){var e;return e=a.getBool("WEBGL_PACK")?new Bi(t.shape,Fi):new Ei(t.shape,Ni),this.compileAndRun(e,[t])},t.prototype.prelu=function(t,e){var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo("\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",t.shape,e.shape):new Mo("return (a < 0.) ? b * a : a;",t.shape,e.shape);return this.compileAndRun(n,[t,e])},t.prototype.elu=function(t){var e=new Ei(t.shape,"return (x >= 0.0) ? x : (exp(x) - 1.0);");return this.compileAndRun(e,[t])},t.prototype.eluDer=function(t,e){var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",t.shape,e.shape):new Mo("return (b >= 1.0) ? a : a * (b + 1.0);",t.shape,e.shape);return this.compileAndRun(n,[t,e])},t.prototype.selu=function(t){var e=new Ei(t.shape,ki);return this.compileAndRun(e,[t])},t.prototype.int=function(t){var e=new Ei(t.shape,"return float(int(x));"),n=this.makeOutputArray(e.outputShape,"int32");return this.compileAndRun(e,[t],n)},t.prototype.clip=function(t,e,n){var r,o=(r=a.getBool("WEBGL_PACK_CLIP")?new Po(t.shape):new Bo(t.shape)).getCustomSetupFunc(e,n);return this.compileAndRun(r,[t],null,o)},t.prototype.abs=function(t){var e=new Ei(t.shape,"return abs(x);");return this.compileAndRun(e,[t])},t.prototype.complexAbs=function(t){var e=this.texData.get(t.dataId),n=new Lo(t.shape),r=[this.makeComplexComponentTensorHandle(t,e.complexTensors.real),this.makeComplexComponentTensorHandle(t,e.complexTensors.imag)];return this.compileAndRun(n,r)},t.prototype.sigmoid=function(t){var e=new Ei(t.shape,"return 1.0 / (1.0 + exp(-1.0 * x));");return this.compileAndRun(e,[t])},t.prototype.softplus=function(t){var e=new Ei(t.shape,"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");return this.compileAndRun(e,[t])},t.prototype.sin=function(t){var e=new Ei(t.shape,Ai);return this.compileAndRun(e,[t])},t.prototype.cos=function(t){var e=new Ei(t.shape,Ti);return this.compileAndRun(e,[t])},t.prototype.tan=function(t){var e=new Ei(t.shape,"return tan(x);");return this.compileAndRun(e,[t])},t.prototype.asin=function(t){var e=new Ei(t.shape,"return asin(x);");return this.compileAndRun(e,[t])},t.prototype.acos=function(t){var e=new Ei(t.shape,"return acos(x);");return this.compileAndRun(e,[t])},t.prototype.atan=function(t){var e=new Ei(t.shape,Di);return this.compileAndRun(e,[t])},t.prototype.atan2=function(t,e){var n=a.getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fo("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",t.shape,e.shape):new Mo("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",t.shape,e.shape);return this.compileAndRun(n,[t,e])},t.prototype.sinh=function(t){var e=new Ei(t.shape,"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])},t.prototype.cosh=function(t){var e=new Ei(t.shape,"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");return this.compileAndRun(e,[t])},t.prototype.tanh=function(t){var e=new Ei(t.shape,"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");return this.compileAndRun(e,[t])},t.prototype.asinh=function(t){var e=new Ei(t.shape,"return log(x + sqrt(x * x + 1.0));");return this.compileAndRun(e,[t])},t.prototype.acosh=function(t){var e=new Ei(t.shape,Oi);return this.compileAndRun(e,[t])},t.prototype.atanh=function(t){var e=new Ei(t.shape,_i);return this.compileAndRun(e,[t])},t.prototype.erf=function(t){var e=new Ei(t.shape,'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float t = 1.0 / (1.0 + p * x);\n  return 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x);\n');return this.compileAndRun(e,[t])},t.prototype.step=function(t,e){var n=new Ei(t.shape,function(t){return void 0===t&&(t=0),Ri+"\n    return x > 0.0 ? 1.0 : float("+t+");\n  "}(e));return this.compileAndRun(n,[t])},t.prototype.conv2dByMatMul=function(t,e,n){var r=t.shape,o=this.texData.get(t.dataId),i=n.inChannels,s=r[0]*r[1]*r[2],u=n.outChannels,l=(1===s||1===u)&&i>1e3,c=r[2]%2!=0&&!!o.isPacked;if(l||!a.getBool("WEBGL_LAZILY_UNPACK")||!a.getBool("WEBGL_PACK_BINARY_OPERATIONS")||!c){var h=this.reshape(t,[1,r[0]*r[1]*r[2],n.inChannels]),p=this.reshape(e,[1,n.inChannels,n.outChannels]);return this.reshape(this.batchMatMul(h,p,!1,!1),n.outShape)}var f=ft.make([1,r[0]*r[1]*(r[2]+1),n.inChannels],{dataId:t.dataId},t.dtype,this),v=o.shape;o.shape=o.shape.slice(),o.shape[o.shape.length-2]++,d(ge(o.shape,f.shape),function(){return"packed reshape "+o.shape+" to "+f.shape+" isn't free"});var m=this.reshape(e,[1,n.inChannels,n.outChannels]),g=this.batchMatMul(f,m,!1,!1),y=this.texData.get(g.dataId);return d(y.isPacked,function(){return"batchMatMul result is expected to be packed"}),o.shape=v,y.shape=n.outShape,ft.make(n.outShape,{dataId:g.dataId},g.dtype,this)},t.prototype.conv2dWithIm2Row=function(t,e,n){var r=n.filterWidth,o=n.filterHeight,a=n.inChannels,i=n.outWidth,s=n.outHeight,u=r*o*a,l=s*i,c=[u,l],h=t.squeeze([0]),p=e.reshape([1,u,-1]),f=new za(c,h.shape,n),d=this.compileAndRun(f,[h]).reshape([1,c[0],c[1]]),v=new $a(d.shape,[1,l,n.outChannels],!0,!1);return this.compileAndRun(v,[d,p]).reshape([1,s,i,n.outChannels])},t.prototype.conv2d=function(t,e,n){if(1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type))return this.conv2dByMatMul(t,e,n);if(a.getBool("WEBGL_CONV_IM2COL")&&1===t.shape[0])return this.conv2dWithIm2Row(t,e,n);var r=new jo(n);return this.compileAndRun(r,[t,e])},t.prototype.conv2dDerInput=function(t,e,n){var r=new Vo(n);return this.compileAndRun(r,[t,e])},t.prototype.conv2dDerFilter=function(t,e,n){var r=new zo(n);return this.compileAndRun(r,[t,e])},t.prototype.depthwiseConv2D=function(t,e,n){var r;return a.getBool("WEBGL_PACK_DEPTHWISECONV")&&n.strideWidth<=2&&n.outChannels/n.inChannels==1?(r=new Yo(n),this.compileAndRun(r,[t,e],this.makePackedTensor(n.outShape,t.dtype))):(r=new Xo(n),this.compileAndRun(r,[t,e]))},t.prototype.depthwiseConv2DDerInput=function(t,e,n){var r=new $o(n);return this.compileAndRun(r,[t,e])},t.prototype.depthwiseConv2DDerFilter=function(t,e,n){var r=new Ho(n);return this.compileAndRun(r,[t,e])},t.prototype.conv3d=function(t,e,n){var r=new Ko(n);return this.compileAndRun(r,[t,e])},t.prototype.conv3dDerInput=function(t,e,n){var r=new qo(n);return this.compileAndRun(r,[t,e])},t.prototype.conv3dDerFilter=function(t,e,n){var r=new Go(n);return this.compileAndRun(r,[t,e])},t.prototype.maxPool=function(t,e){var n=new Ja(e,"max",!1),r=this.makeOutputArray(n.outputShape,t.dtype);return this.compileAndRun(n,[t],r)},t.prototype.avgPool=function(t,e){var n=new Ja(e,"avg",!1),r=this.makeOutputArray(n.outputShape,"float32");return this.compileAndRun(n,[t],r)},t.prototype.maxPoolBackprop=function(t,e,n,r){var o=new Ja(r,"max",!0),a=this.compileAndRun(o,[e]),i=new Ha(r),s=this.makeOutputArray(i.outputShape,e.dtype),u=this.compileAndRun(i,[t,a],s);return a.dispose(),u},t.prototype.avgPoolBackprop=function(t,e,n){var r=new So(n),o=this.makeOutputArray(r.outputShape,e.dtype);return this.compileAndRun(r,[t],o)},t.prototype.cast=function(t,e){return Jn(t,e,this)},t.prototype.unstack=function(t,e){for(var n=t.shape[e],r=new Array(t.rank-1),o=0,a=0;a<t.rank;a++)a!==e&&(r[o++]=t.shape[a]);var i=new Array(t.rank).fill(0),s=t.shape.slice();s[e]=1;var u=new Array(n);for(a=0;a<u.length;a++)i[e]=a,u[a]=this.slice(t,i,s).reshape(r);return u},t.prototype.reshape=function(t,e){var n=this.texData.get(t.dataId);return!n.isPacked||ge(t.shape,e)||null!==n.texture&&ge(n.shape,e)?Zn(t,e):this.packedReshape(t,e)},t.prototype.resizeBilinear=function(t,e,n,r){var o=a.getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ri(t.shape,e,n,r):new ni(t.shape,e,n,r);return this.compileAndRun(o,[t])},t.prototype.resizeBilinearBackprop=function(t,e,n){var r=new ei(t,e,n);return this.compileAndRun(r,[t])},t.prototype.resizeNearestNeighbor=function(t,e,n,r){var o=new ai(t.shape,e,n,r);return this.compileAndRun(o,[t])},t.prototype.resizeNearestNeighborBackprop=function(t,e,n){var r=new oi(t,e,n);return this.compileAndRun(r,[t])},t.prototype.multinomial=function(t,e,n,r){var o=e?t:Tn(t),a=o.shape[0],i=o.shape[1],s=new ja(a,i,n),u=this.makeOutputArray(s.outputShape,"int32"),l=s.getCustomSetupFunc(r);return this.compileAndRun(s,[o],u,l)},t.prototype.oneHot=function(t,e,n,r){var o=new Ka(t.size,e,n,r);return this.compileAndRun(o,[t])},t.prototype.nonMaxSuppression=function(t,e,n,r,o){return je("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"),ar(t.dataSync(),e.dataSync(),n,r,o)},t.prototype.cropAndResize=function(t,e,n,r,o,a){var i=new Qo(t.shape,e.shape,r,o,a);return this.compileAndRun(i,[t,e,n])},t.prototype.depthToSpace=function(t,e,n){d(e>1,function(){return"blockSize should be > 1 for depthToSpace, but was: "+e});var r=t.shape[0],o="NHWC"===n?t.shape[1]:t.shape[2],a="NHWC"===n?t.shape[2]:t.shape[3],i="NHWC"===n?t.shape[3]:t.shape[1],s=o*e,u=a*e,l=i/(e*e),c=new ta("NHWC"===n?[r,s,u,l]:[r,l,s,u],e,n);return this.compileAndRun(c,[t])},t.prototype.split=function(t,e,n){return sr(t,e,n)},t.prototype.scatterND=function(t,e,n){var r=pn(0,t,n),o=r.sliceRank,a=r.numUpdates,i=r.sliceSize,s=r.strides,u=r.outputSize,l=[u/i,i],c=t.reshape([a,o]),h=e.reshape([a,i]);if(0===u)return Zn(Fn([]),n);var p=Bn(0),f=new ui(a,o,c.rank,h.rank,s,l);return this.compileAndRun(f,[h,c,p]).reshape(n)},t.prototype.sparseToDense=function(t,e,n,r){var o=pn(0,t,n),a=o.sliceRank,i=o.numUpdates,s=o.strides,u=o.outputSize,l=new ui(i,a,t.rank,e.rank,s,[u,1],!1);return this.compileAndRun(l,[e,t,r]).reshape(n)},t.prototype.fft=function(t){return this.fftImpl(t,!1)},t.prototype.ifft=function(t){return this.fftImpl(t,!0)},t.prototype.fftImpl=function(t,e){var n=this.texData.get(t.dataId),r=new oa(na,t.shape,e),o=new oa(ra,t.shape,e),a=[this.makeComplexComponentTensorHandle(t,n.complexTensors.real),this.makeComplexComponentTensorHandle(t,n.complexTensors.imag)],i=this.compileAndRun(r,a),s=this.compileAndRun(o,a),u=this.complex(i,s).as2D(t.shape[0],t.shape[1]);return i.dispose(),s.dispose(),u},t.prototype.gatherND=function(t,e){var n=e.shape,r=n[n.length-1],o=un(t,e),a=o[0],i=o[1],s=o[2],u=o[3],l=e.reshape([i,r]),c=t.reshape([t.size/s,s]),h=new ca(r,u,[i,s]);return this.compileAndRun(h,[c,l]).reshape(a)},t.prototype.fill=function(t,e,n){if("string"===(n=n||W(e))){var r=A(n,y(t));return r.fill(e),ft.make(t,{values:r},n)}var o=new aa(t,e),a=o.getCustomSetupFunc(e),i=this.makeOutputArray(t,n);return this.compileAndRun(o,[],i,a)},t.prototype.onesLike=function(t){if("string"===t.dtype)throw new Error("onesLike is not supported under string dtype");return this.fill(t.shape,1,t.dtype)},t.prototype.zerosLike=function(t){return this.fill(t.shape,"string"===t.dtype?"":0,t.dtype)},t.prototype.linspace=function(t,e,n){return tr(t,e,n)},t.prototype.makeOutputArray=function(t,e){return ft.make(t,{},e,this)},t.prototype.makePackedTensor=function(t,e){var n=ft.make(t,{},e,this);return this.texData.get(n.dataId).isPacked=!0,n},t.prototype.unpackTensor=function(t){var e=new Pi(t.shape);return this.compileAndRun(e,[t],ft.make(e.outputShape,{},t.dtype,this))},t.prototype.packTensor=function(t){var e=new Xa(t.shape);return this.compileAndRun(e,[t],this.makePackedTensor(t.shape,t.dtype))},t.prototype.packedReshape=function(t,e){var n=t.reshape([fe(t.shape)].concat(de(t.shape))),r=[fe(e)].concat(de(e)),o=new ti(r,n.shape);return this.compileAndRun(o,[n]).reshape(e)},t.prototype.compileAndRun=function(t,e,n,r){var o=this;if(null==n&&(n=t.usesPackedTextures?this.makePackedTensor(t.outputShape,e[0].dtype):this.makeOutputArray(t.outputShape,e[0].dtype)),0===n.size)return this.texData.get(n.dataId).values=I(n.dtype,0),n;var i=e.map(function(e){if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");var n=o.texData.get(e.dataId);if(null==n.texture){if(!t.usesPackedTextures&&y(e.shape)<=a.getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.usesPackedTextures&&(n.isPacked=!0,n.shape=e.shape)}else if(!!n.isPacked!=!!t.usesPackedTextures)e=n.isPacked?o.unpackTensor(e):o.packTensor(e),n=o.texData.get(e.dataId);else if(n.isPacked&&!ge(n.shape,e.shape)){var r=e,i=e.shape;e.shape=n.shape,e=o.packedReshape(e,i),n=o.texData.get(e.dataId),r.shape=i}return o.uploadToGPU(e.dataId),{shape:e.shape,texData:n,isUniform:!1}});this.uploadToGPU(n.dataId);var s,u={shape:n.shape,texData:this.texData.get(n.dataId),isUniform:!1},l=function(t,e,n){var r="";e.concat(n).forEach(function(t){var e=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0,n=t.isUniform?"uniform":t.texData.texShape;r+=t.shape+"_"+n+"_"+e});var o=t.userCode,a=t.constructor.name;return a+="_"+r+"_"+o}(t,i,u),c=this.getAndSaveBinary(l,function(){return function(t,e,n,r){var o=e.userCode,i=n.map(function(t,n){var r={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(r.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:r}}),s=i.map(function(t){return t.shapeInfo}),u={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},l=ho(i,u,o,e.usesPackedTextures),c=t.createProgram(l),h=null,p=t.getUniformLocation(c,"NAN",!1);1===a.getNumber("WEBGL_VERSION")&&(h=t.getUniformLocation(c,"INFINITY",!1));for(var f={},d=0;d<e.variableNames.length;d++){var v=e.variableNames[d];f[v]=t.getUniformLocation(c,v,!1),f["offset"+v]=t.getUniformLocation(c,"offset"+v,!1)}return{program:e,source:l,webGLProgram:c,uniformLocations:f,inShapeInfos:s,outShapeInfo:u,infLoc:h,nanLoc:p}}(o.gpgpu,t,i,u)}),h=null!=this.activeTimers;return h&&(s=this.startTimer()),function(t,e,n,r,o){Ua(e.inShapeInfos,n),Ua([e.outShapeInfo],[r]);var i=r.texData.texture,s=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(i,s[0],s[1]):t.setOutputMatrixTexture(i,s[0],s[1]),t.setProgram(e.webGLProgram),1===a.getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach(function(n,r){var o=e.program.variableNames[r],a=e.uniformLocations[o],i=e.uniformLocations["offset"+o];if(null!=a)if(n.isUniform)if(y(n.shape)<2)t.gl.uniform1f(a,n.uniformValues[0]);else{var s=n.uniformValues;s instanceof Float32Array||(s=new Float32Array(s)),t.gl.uniform1fv(a,s)}else null!=n.texData.slice&&null!=i&&t.gl.uniform1i(i,n.texData.slice.flatOffset),t.setInputMatrixTexture(n.texData.texture,a,r)}),null!=o&&o(t,e.webGLProgram),t.executeProgram()}(this.gpgpu,c,i,u,r),h&&(s=this.endTimer(s),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(s)})),a.getBool("WEBGL_LAZILY_UNPACK")||!this.texData.get(n.dataId).isPacked||t.isPackShader?n:this.unpackTensor(n)},t.prototype.getAndSaveBinary=function(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]},t.prototype.getTextureManager=function(){return this.textureManager},t.prototype.dispose=function(){this.disposed||(this.textureManager.dispose(),this.canvas.remove(),null!=this.fromPixels2DContext&&this.fromPixels2DContext.canvas.remove(),this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)},t.prototype.floatPrecision=function(){var t=this;return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Fe(function(){var e=a.getBool("DEBUG");a.set("DEBUG",!1);var n=t.abs(Bn(1e-8)).dataSync()[0];return a.set("DEBUG",e),n>0?32:16})),this.floatPrecisionValue},t.prototype.epsilon=function(){return 32===this.floatPrecision()?1e-7:1e-4},t.prototype.uploadToGPU=function(t){var e,n=this.texData.get(t),r=n.shape,o=n.dtype,a=n.values,i=n.texture,s=n.usage,u=n.isPacked;if(null==i){var l,c=null!=this.activeTimers;c&&(l=performance.now());var h=ve(r,u);n.texShape=h;var p=this.acquireTexture(h,s,o,u);if(n.texture=p,null!=a){if(u){var f=fe(r),d=1,v=1;r.length&&(d=(e=de(r))[0],v=e[1]),this.gpgpu.uploadMatrixToPackedTexture(p,f,d,v,h[0],h[1],zi(a))}else this.gpgpu.uploadMatrixToTexture(p,h[0],h[1],zi(a));n.values=null,c&&(this.uploadWaitMs+=performance.now()-l)}}},t.prototype.convertAndCacheOnCPU=function(t,e){var n=this.texData.get(t),r=n.dtype;return this.releaseGPUData(t),n.usage=ua.UPLOAD,null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){for(var n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length),r=0;r<n.length;++r)n[r]=Math.round(t[r]);return n}throw new Error("Unknown dtype "+e)}(e,r)),n.values},t.prototype.acquireTexture=function(t,e,n,r){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){var o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: "+o+" MB, most likely due to a memory leak")}return this.textureManager.acquireTexture(t,e,r)},t.prototype.computeBytes=function(t,e){return t[0]*t[1]*M(e)},t}();function zi(t){return t instanceof Float32Array?t:new Float32Array(t)}Ot()&&Dt.registerBackend("webgl",function(){return new Ui},2);var Vi=An({abs_:function(t){var e=wn(t,"x","abs");return"complex64"===e.dtype?Dt.runKernel(function(t){return t.complexAbs(e)},{$x:e}):Dt.runKernel(function(t,n){var r=t.abs(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mul(n.toFloat().step(-1))}}})}}),Gi=An({acos_:function(t){var e=wn(t,"x","acos");return Dt.runKernel(function(t,n){var r=t.acos(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.divStrict(Bn(1).sub(n.toFloat().square()).sqrt()).neg()}}})}}),qi=An({acosh_:function(t){var e=wn(t,"x","acosh");return Dt.runKernel(function(t,n){var r=t.acosh(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.divStrict(n.toFloat().square().sub(1).sqrt())}}})}}),Hi=An({asin_:function(t){var e=wn(t,"x","asin");return Dt.runKernel(function(t,n){var r=t.asin(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.divStrict(Bn(1).sub(n.toFloat().square()).sqrt())}}})}}),$i=An({asinh_:function(t){var e=wn(t,"x","asinh");return Dt.runKernel(function(t,n){var r=t.asinh(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.divStrict(Bn(1).add(n.toFloat().square()).sqrt())}}})}}),ji=An({atan_:function(t){var e=wn(t,"x","atan");return Dt.runKernel(function(t,n){var r=t.atan(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(n.toFloat().square().add(1))}}})}}),Ki=An({atanh_:function(t){var e=wn(t,"x","atanh");return Dt.runKernel(function(t,n){var r=t.atanh(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(Bn(1).sub(n.toFloat().square()))}}})}}),Xi=An({ceil_:function(t){var e=wn(t,"x","ceil");return Dt.runKernel(function(t){return t.ceil(e)},{$x:e},function(t){return{$x:function(){return Xn(t)}}})}}),Yi=An({clipByValue_:function(t,e,n){var r=wn(t,"x","clipByValue");return d(e<=n,function(){return"Error in clip: min ("+e+") must be less than or equal to max ("+n+")."}),Dt.runKernel(function(t,o){var a=t.clip(r,e,n);return o([r]),a},{$x:r},function(t,r){var o=r[0];return{$x:function(){return t.where(o.greaterEqual(e).logicalAnd(o.lessEqual(n)),Xn(t))}}})}}),Qi=An({cos_:function(t){var e=wn(t,"x","cos");return Dt.runKernel(function(t,n){var r=t.cos(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return n.toFloat().sin().neg().mul(t)}}})}}),Ji=An({cosh_:function(t){var e=wn(t,"x","cosh");return Dt.runKernel(function(t,n){var r=t.cosh(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return n.toFloat().sinh().mulStrict(t)}}})}}),Zi=An({erf_:function(t){var e=wn(t,"x","erf");return d("int32"===e.dtype||"float32"===e.dtype,function(){return"Input dtype must be `int32` or `float32`."}),"int32"===e.dtype&&(e=e.toFloat()),Dt.runKernel(function(t,n){var r=t.erf(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mul(n.square().neg().exp().mul(2/Math.sqrt(Math.PI)))}}})}}),ts=An({exp_:function(t){var e=wn(t,"x","exp");return Dt.runKernel(function(t,n){var r=t.exp(e);return n([r]),r},{$x:e},function(t,e){return{$x:function(){return t.mulStrict(e[0])}}})}}),es=An({expm1_:function(t){var e=wn(t,"x","expm1");return Dt.runKernel(function(t,n){var r=t.expm1(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mul(n.exp())}}})}}),ns=An({floor_:function(t){var e=wn(t,"x","floor");return Dt.runKernel(function(t){return t.floor(e)},{$x:e},function(t){return{$x:function(){return Xn(t)}}})}}),rs=An({log_:function(t){var e=wn(t,"x","log");return Dt.runKernel(function(t,n){var r=t.log(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(n.toFloat())}}})}}),os=An({log1p_:function(t){var e=wn(t,"x","log1p");return Dt.runKernel(function(t,n){var r=t.log1p(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(n.add(1))}}})}}),as=An({logSigmoid_:function(t){var e=wn(t,"x","logSigmoid");return Dt.runKernel(function(t,n){var r=t.softplus(e.neg()).neg();return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mul(n.neg().sigmoid())}}})}}),is=An({neg_:function(t){var e=wn(t,"x","neg");return Dt.runKernel(function(t){return t.neg(e)},{$x:e},function(t){return{$x:function(){return t.neg()}}})}}),ss=An({reciprocal_:function(t){var e=wn(t,"x","reciprocal");return Dt.runKernel(function(t,n){var r=t.reciprocal(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(n.square().neg())}}})}}),us=An({round_:function(t){var e=wn(t,"x","round");return Dt.runKernel(function(t){return t.round(e)},{$x:e},function(t){return{$x:function(){return Xn(t)}}})}}),ls=An({rsqrt_:function(t){var e=wn(t,"x","rsqrt");return Dt.runKernel(function(t,n){var r=t.rsqrt(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(n.pow(1.5).mul(2)).neg()}}})}}),cs=An({sigmoid_:function(t){var e=wn(t,"x","sigmoid");return Dt.runKernel(function(t,n){var r=t.sigmoid(e);return n([r]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mul(n.mul(Bn(1).sub(n)))}}})}}),hs=An({sign_:function(t){var e=wn(t,"x","sign");return Dt.runKernel(function(t){return t.sign(e)},{$x:e},function(t){return{$x:function(){return Xn(t)}}})}}),ps=An({isNaN_:function(t){var e=wn(t,"x","isNaN");return Dt.runKernel(function(t){return t.isNaN(e)},{$x:e},function(t){return{$x:function(){return Xn(t)}}})}}),fs=An({isInf_:function(t){var e=wn(t,"x","isInf");return Dt.runKernel(function(t){return t.isInf(e)},{$x:e},function(t){return{$x:function(){return Xn(t)}}})}}),ds=An({isFinite_:function(t){var e=wn(t,"x","isFinite");return Dt.runKernel(function(t){return t.isFinite(e)},{$x:e},function(t){return{$x:function(){return Xn(t)}}})}}),vs=An({sin_:function(t){var e=wn(t,"x","sin");return Dt.runKernel(function(t,n){var r=t.sin(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return n.toFloat().cos().mul(t)}}})}}),ms=An({sinh_:function(t){var e=wn(t,"x","sinh");return Dt.runKernel(function(t,n){var r=t.sinh(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return n.toFloat().cosh().mulStrict(t)}}})}}),gs=An({softplus_:function(t){var e=wn(t,"x","softplus");return Dt.runKernel(function(t,n){var r=t.softplus(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mul(n.sigmoid())}}})}}),ys=An({sqrt_:function(t){var e=wn(t,"x","sqrt");return Dt.runKernel(function(t,n){var r=t.sqrt(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(n.toFloat().sqrt().mul(2))}}})}}),xs=An({square_:function(t){var e=wn(t,"x","square");return Dt.runKernel(function(t,n){return n([e]),t.square(e)},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mul(n.toFloat().mul(2))}}})}}),ws=An({step_:function(t,e){void 0===e&&(e=0);var n=wn(t,"x","step");return Dt.runKernel(function(t){return t.step(n,e)},{$x:n},function(t){return{$x:function(){return Xn(t)}}})}}),bs=An({tan_:function(t){var e=wn(t,"x","tan");return Dt.runKernel(function(t,n){var r=t.tan(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.div(n.cos().square())}}})}}),Cs=An({tanh_:function(t){var e=wn(t,"x","tanh");return Dt.runKernel(function(t,n){var r=t.tanh(e);return n([r]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return Bn(1).sub(n.square()).mulStrict(t)}}})}});function Es(t,e,n,r,o,a){var i,s,u=wn(t,"x","batchNorm"),l=wn(e,"mean","batchNorm"),c=wn(n,"variance","batchNorm");return null!=o&&(i=wn(o,"scale","batchNorm")),null!=r&&(s=wn(r,"offset","batchNorm")),d(2===u.rank,function(){return"Error in batchNorm3D: x must be rank 3 but got rank "+u.rank+"."}),d(2===l.rank||1===l.rank,function(){return"Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank "+l.rank+"."}),d(2===c.rank||1===c.rank,function(){return"Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank "+c.rank+"."}),null!=i&&d(2===i.rank||1===i.rank,function(){return"Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank "+i.rank+"."}),null!=s&&d(2===s.rank||1===s.rank,function(){return"Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank "+s.rank+"."}),Ns(u,l,c,s,i,a)}function Rs(t,e,n,r,o,a){var i,s,u=wn(t,"x","batchNorm"),l=wn(e,"mean","batchNorm"),c=wn(n,"variance","batchNorm");return null!=o&&(i=wn(o,"scale","batchNorm")),null!=r&&(s=wn(r,"offset","batchNorm")),d(3===u.rank,function(){return"Error in batchNorm3D: x must be rank 3 but got rank "+u.rank+"."}),d(3===l.rank||1===l.rank,function(){return"Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank "+l.rank+"."}),d(3===c.rank||1===c.rank,function(){return"Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank "+c.rank+"."}),null!=i&&d(3===i.rank||1===i.rank,function(){return"Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank "+i.rank+"."}),null!=s&&d(3===s.rank||1===s.rank,function(){return"Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank "+s.rank+"."}),Ns(u,l,c,s,i,a)}function Ss(t,e,n,r,o,a){var i,s,u=wn(t,"x","batchNorm"),l=wn(e,"mean","batchNorm"),c=wn(n,"variance","batchNorm");return null!=o&&(i=wn(o,"scale","batchNorm")),null!=r&&(s=wn(r,"offset","batchNorm")),d(4===u.rank,function(){return"Error in batchNorm4D: x must be rank 4 but got rank "+u.rank+"."}),d(4===l.rank||1===l.rank,function(){return"Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank "+l.rank+"."}),d(4===c.rank||1===c.rank,function(){return"Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank "+c.rank+"."}),null!=i&&d(4===i.rank||1===i.rank,function(){return"Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank "+i.rank+"."}),null!=s&&d(4===s.rank||1===s.rank,function(){return"Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank "+s.rank+"."}),Ns(u,l,c,s,i,a)}function Ns(t,e,n,r,o,a){null==a&&(a=.001);var i,s,u,l=wn(t,"x","batchNorm"),c=wn(e,"mean","batchNorm"),h=wn(n,"variance","batchNorm");null!=o&&(i=wn(o,"scale","batchNorm")),null!=r&&(s=wn(r,"offset","batchNorm")),d(c.rank===h.rank,function(){return"Batch normalization gradient requires mean and variance to have equal ranks."}),d(null==s||c.rank===s.rank,function(){return"Batch normalization gradient requires mean and offset to have equal ranks."}),d(null==i||c.rank===i.rank,function(){return"Batch normalization gradient requires mean and scale to have equal ranks."}),u=0===l.rank||1===l.rank?l.as4D(1,1,1,l.size):2===l.rank?l.as4D(1,1,l.shape[0],l.shape[1]):3===l.rank?l.as4D(1,l.shape[0],l.shape[1],l.shape[2]):l;return Dt.runKernel(function(t,e){var n=t.batchNormalization(u,ks(c),ks(h),a,ks(i),ks(s));return e([l,c,h,i]),n},{$x:l,$mean:c,$variance:h,$scale:i,$offset:s},function(t,e){var n=e[0],r=e[1],o=e[2],i=e[3],s=null==i?Bn(1):i,l=io(r.shape,u.shape),c=[];if(1===r.rank){for(var h=0;h<u.shape.length-1;++h)c.push(u.shape[h]);c.push(1)}var p=n.sub(r),f=t.mul(s),d=ls(o.add(Bn(a))),v=d.mul(d).mul(d).mul(Bn(-.5));return{$x:function(){return 1===r.rank?t.mul(Xr(d.as4D(1,1,1,r.shape[0]),c)).mul(s).reshape(n.shape):t.mul(d).mul(s).reshape(n.shape)},$mean:function(){var t=d.mul(Bn(-1)).mul(f);return 1===r.rank&&(t=t.sum(l)),t.reshape(r.shape)},$variance:function(){var t=v.mul(p).mul(f);return 1===r.rank&&(t=t.sum(l)),t.reshape(r.shape)},$scale:function(){var e=p.mul(d),n=t.mul(e);return 1===r.rank&&(n=n.sum(l)),n.reshape(r.shape)},$offset:function(){var e=t;return 1===r.rank&&(e=e.sum(l)),e.reshape(r.shape)}}}).reshape(l.shape)}function ks(t){return null==t?null:0===t.rank?t.as1D():1===t.rank?t:2===t.rank?t.as4D(1,1,t.shape[0],t.shape[1]):3===t.rank?t.as4D(1,t.shape[0],t.shape[1],t.shape[2]):t}function Is(){De("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon")}var As=An({batchNormalization2d_:function(t,e,n,r,o,a){return void 0===r&&(r=.001),Is(),Es(t,e,n,a,o,r)}}),Ts=An({batchNormalization3d_:function(t,e,n,r,o,a){return void 0===r&&(r=.001),Is(),Rs(t,e,n,a,o,r)}}),Ds=An({batchNormalization4d_:function(t,e,n,r,o,a){return void 0===r&&(r=.001),Is(),Ss(t,e,n,a,o,r)}}),Os=An({batchNormalization_:function(t,e,n,r,o,a){return void 0===r&&(r=.001),Is(),Ns(t,e,n,a,o,r)}}),_s=An({batchNorm_:Ns}),Ms=An({batchNorm2d_:Es}),Fs=An({batchNorm3d_:Rs}),Bs=An({batchNorm4d_:Ss});function Ps(t,e,n,r,o,a,i){void 0===i&&(i="channelsLast");var s,u=Us(e),l=u[0],c=u[1];if("channelsLast"===i)s=[l,c,t[3],t[3]];else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat "+i);s=[l,c,t[1],t[1]]}return Ls(t,s,n,r,o,a,!1,i)}function Ls(t,e,n,r,o,a,i,s){void 0===i&&(i=!1),void 0===s&&(s="channelsLast");var u=[-1,-1,-1,-1],l=u[0],c=u[1],h=u[2],p=u[3];if("channelsLast"===s)l=t[0],c=t[1],h=t[2],p=t[3];else{if("channelsFirst"!==s)throw new Error("Unknown dataFormat "+s);l=t[0],p=t[1],c=t[2],h=t[3]}var f,v=e[0],m=e[1],g=e[3],y=Us(n),x=y[0],b=y[1],C=Us(r),E=C[0],R=C[1],S=Vs(v,E),N=Vs(m,R),k=function(t,e,n,r,o,a,i,s){var u,l,c;if("number"==typeof t){var h=0===t?"VALID":"NUMBER";u={top:t,bottom:t,left:t,right:t,type:h};var p=function(t,e,n,r,o,a){null==o&&(o=function(t,e,n,r){void 0===r&&(r=1);var o=Vs(e,r);return Math.floor((t[0]*(n-1)-n+o)/2)}(t,e,r));var i=t[0],s=t[1],u=Gs((i-e+2*o)/r+1,a);d(w(u),function(){return"The output # of rows ("+u+") must be an integer. Change the stride and/or zero pad parameters"});var l=Gs((s-e+2*o)/r+1,a);return d(w(l),function(){return"The output # of columns ("+l+") must be an integer. Change the stride and/or zero pad parameters"}),[u,l,n]}([e,n,1],a,1,r,t,s);l=p[0],c=p[1]}else if("same"===t){l=Math.ceil(e/r),c=Math.ceil(n/o);var f=Math.max(0,(l-1)*r+a-e),v=Math.max(0,(c-1)*o+i-n),m=Math.floor(f/2),g=f-m,y=Math.floor(v/2),x=v-y;u={top:m,bottom:g,left:y,right:x,type:"SAME"}}else{if("valid"!==t)throw Error("Unknown padding parameter: "+t);u={top:0,bottom:0,left:0,right:0,type:"VALID"},l=Math.ceil((e-a+1)/r),c=Math.ceil((n-i+1)/o)}return{padInfo:u,outHeight:l,outWidth:c}}(o,c,h,x,b,S,N,a),I=k.padInfo,A=k.outHeight,T=k.outWidth,D=i?g*p:g;return"channelsFirst"===s?f=[l,D,A,T]:"channelsLast"===s&&(f=[l,A,T,D]),{batchSize:l,dataFormat:s,inHeight:c,inWidth:h,inChannels:p,outHeight:A,outWidth:T,outChannels:D,padInfo:I,strideHeight:x,strideWidth:b,filterHeight:v,filterWidth:m,effectiveFilterHeight:S,effectiveFilterWidth:N,dilationHeight:E,dilationWidth:R,inShape:t,outShape:f,filterShape:e}}function Ws(t,e,n,r,o,a,i){void 0===a&&(a=!1),void 0===i&&(i="channelsLast");var s=[-1,-1,-1,-1,-1],u=s[0],l=s[1],c=s[2],h=s[3],p=s[4];if("channelsLast"===i)u=t[0],l=t[1],c=t[2],h=t[3],p=t[4];else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat "+i);u=t[0],p=t[1],l=t[2],c=t[3],h=t[4]}var f,d=e[0],v=e[1],m=e[2],g=e[4],y=zs(n),x=y[0],w=y[1],b=y[2],C=zs(r),E=C[0],R=C[1],S=C[2],N=function(t,e,n,r,o,a,i,s,u,l){var c,h,p,f;if("same"===t){h=Math.ceil(e/o),p=Math.ceil(n/a),f=Math.ceil(r/i);var d=(h-1)*o+s-e,v=(p-1)*a+u-n,m=(f-1)*i+l-r,g=Math.floor(d/2),y=d-g,x=Math.floor(v/2),w=v-x,b=Math.floor(m/2),C=m-b;c={top:x,bottom:w,left:b,right:C,front:g,back:y,type:"SAME"}}else{if("valid"!==t)throw Error("Unknown padding parameter: "+t);c={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},h=Math.ceil((e-s+1)/o),p=Math.ceil((n-u+1)/a),f=Math.ceil((r-l+1)/i)}return{padInfo:c,outDepth:h,outHeight:p,outWidth:f}}(o,l,c,h,x,w,b,Vs(d,E),Vs(v,R),Vs(m,S)),k=N.padInfo,I=N.outDepth,A=N.outHeight,T=N.outWidth,D=a?g*p:g;return"channelsFirst"===i?f=[u,D,I,A,T]:"channelsLast"===i&&(f=[u,I,A,T,D]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:c,inWidth:h,inChannels:p,outDepth:I,outHeight:A,outWidth:T,outChannels:D,padInfo:k,strideDepth:x,strideHeight:w,strideWidth:b,filterDepth:d,filterHeight:v,filterWidth:m,dilationDepth:E,dilationHeight:R,dilationWidth:S,inShape:t,outShape:f,filterShape:e}}function Us(t){return"number"==typeof t?[t,t]:t}function zs(t){return"number"==typeof t?[t,t,t]:t}function Vs(t,e){return e<=1?t:t+(t-1)*(e-1)}function Gs(t,e){if(!e)return t;switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error("Unknown roundingMode "+e)}}function qs(t){var e=Us(t),n=e[0],r=e[1];return 1===n&&1===r}function Hs(t,e){return qs(t)||qs(e)}function $s(t,e,n,r,o,a){d(t.length===e.rank,function(){return"Length of inShape ("+t.length+") and rank of dy ("+e.rank+") must match"});var i=t,s=e,u=!1;3===e.rank&&(u=!0,s=e.as4D(1,e.shape[0],e.shape[1],e.shape[2]),i=[1,t[0],t[1],t[2]]);var l=i[3],c=s.shape[3];d(4===i.length,function(){return"Error in conv2dDerInput: inShape must be length 4, but got length "+i.length+"."}),d(4===s.rank,function(){return"Error in conv2dDerInput: dy must be rank 4, but got rank "+s.rank}),d(4===n.rank,function(){return"Error in conv2dDerInput: filter must be rank 4, but got rank "+n.rank}),d(l===n.shape[2],function(){return"Error in conv2dDerInput: depth of input ("+l+") must match input depth for filter "+n.shape[2]+"."}),d(c===n.shape[3],function(){return"Error in conv2dDerInput: depth of output ("+c+") must match output depth for filter "+n.shape[3]+"."}),null!=a&&d(w(o),function(){return"Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+o+"."});var h=Ls(i,n.shape,r,1,o,a),p=Dt.runKernel(function(t,e){var r=t.conv2dDerInput(s,n,h);return e([n,s]),r},{dy4D:s,filter:n},function(t,e){var n=e[0],i=e[1];return{dy4D:function(){return Ys(t,n,r,o,"NHWC",1,a)},filter:function(){return Js(t,i,n.shape,r,o,a)}}});return u?p.as3D(p.shape[1],p.shape[2],p.shape[3]):p}function js(t,e,n,r,o,a){var i=t;3===t.rank&&(i=t.as4D(1,t.shape[0],t.shape[1],t.shape[2]));var s=e;3===s.rank&&(s=e.as4D(1,e.shape[0],e.shape[1],e.shape[2])),d(4===i.rank,function(){return"Error in conv2dDerFilter: input must be rank 4, but got shape "+i.shape+"."}),d(4===s.rank,function(){return"Error in conv2dDerFilter: dy must be rank 4, but got shape "+s.shape+"."}),d(4===n.length,function(){return"Error in conv2dDerFilter: filterShape must be length 4, but got "+n+"."}),d(i.shape[3]===n[2],function(){return"Error in conv2dDerFilter: depth of input "+i.shape[3]+") must match input depth in filter ("+n[2]+"."}),d(s.shape[3]===n[3],function(){return"Error in conv2dDerFilter: depth of dy ("+s.shape[3]+") must match output depth for filter ("+n[3]+")."}),null!=a&&d(w(o),function(){return"Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+o+"."});var u=Ls(i.shape,n,r,1,o,a);return Dt.runKernel(function(t){return t.conv2dDerFilter(i,s,u)},{x4D:i,dy4D:s})}function Ks(t){var e=function(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}(t),n=e[0],r=e[1],o=e[2];return 1===n&&1===r&&1===o}var Xs=An({conv1d_:function(t,e,n,r,o,a,i){void 0===o&&(o="NWC"),void 0===a&&(a=1);var s=wn(t,"x","conv1d"),u=wn(e,"filter","conv1d"),l=s,c=!1;2===s.rank&&(c=!0,l=s.as3D(1,s.shape[0],s.shape[1])),d(3===l.rank,function(){return"Error in conv1d: input must be rank 3, but got rank "+l.rank+"."}),d(3===u.rank,function(){return"Error in conv1d: filter must be rank 3, but got rank "+u.rank+"."}),null!=i&&d(w(r),function(){return"Error in conv1d: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+r+"."}),d(l.shape[2]===u.shape[1],function(){return"Error in conv1d: depth of input ("+l.shape[2]+") must match input depth for filter "+u.shape[1]+"."}),d(Hs(n,a),function(){return"Error in conv1D: Either stride or dilation must be 1. Got stride "+n+" and dilation '"+a+"'"}),d("NWC"===o,function(){return"Error in conv1d: got dataFormat of "+o+" but only NWC is currently supported."});var h=u.as4D(1,u.shape[0],u.shape[1],u.shape[2]),p=l.as4D(l.shape[0],1,l.shape[1],l.shape[2]),f=Ys(p,h,[1,n],r,"NHWC",[1,a],i);return c?f.as2D(f.shape[2],f.shape[3]):f.as3D(f.shape[0],f.shape[2],f.shape[3])}}),Ys=An({conv2d_:function(t,e,n,r,o,a,i){void 0===o&&(o="NHWC"),void 0===a&&(a=[1,1]);var s=wn(t,"x","conv2d"),u=wn(e,"filter","conv2d"),l=s,c=!1;3===s.rank&&(c=!0,l=s.as4D(1,s.shape[0],s.shape[1],s.shape[2])),d(4===l.rank,function(){return"Error in conv2d: input must be rank 4, but got rank "+l.rank+"."}),d(4===u.rank,function(){return"Error in conv2d: filter must be rank 4, but got rank "+u.rank+"."}),null!=i&&d(w(r),function(){return"Error in conv2d: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+r+"."}),d(l.shape[3]===u.shape[2],function(){return"Error in conv2d: depth of input ("+l.shape[3]+") must match input depth for filter "+u.shape[2]+"."}),d(Hs(n,a),function(){return"Error in conv2D: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+a+"'"}),d("NHWC"===o,function(){return"Error in conv2d: got dataFormat of "+o+" but only NHWC is currently supported."});var h=Ls(l.shape,u.shape,n,a,r,i),p=Dt.runKernel(function(t,e){var n=t.conv2d(l,u,h);return e([u,l]),n},{x:l,$filter:u},function(t,e){var o=e,i=o[0],s=o[1];return d(qs(a),function(){return"Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+a+"'"}),{x:function(){return $s(s.shape,t,i,n,r)},$filter:function(){return js(s,t,i.shape,n,r)}}});return c?p.as3D(p.shape[1],p.shape[2],p.shape[3]):p}}),Qs=An({conv3d_:function(t,e,n,r,o,a){void 0===o&&(o="NDHWC"),void 0===a&&(a=[1,1,1]);var i=wn(t,"x","conv3d"),s=wn(e,"filter","conv3d"),u=i,l=!1;4===i.rank&&(l=!0,u=i.as5D(1,i.shape[0],i.shape[1],i.shape[2],i.shape[3])),d(5===u.rank,function(){return"Error in conv3d: input must be rank 5, but got rank "+u.rank+"."}),d(5===s.rank,function(){return"Error in conv3d: filter must be rank 5, but got rank "+s.rank+"."}),d(u.shape[4]===s.shape[3],function(){return"Error in conv3d: depth of input ("+u.shape[4]+") must match input depth for filter "+s.shape[3]+"."}),d(function(t,e){return Ks(t)||Ks(e)}(n,a),function(){return"Error in conv3D: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+a+"'"}),d("NDHWC"===o,function(){return"Error in conv3d: got dataFormat of "+o+" but only NDHWC is currently supported."});var c=Ws(u.shape,s.shape,n,a,r),h=Dt.runKernel(function(t,e){var n=t.conv3d(u,s,c);return e([u,s]),n},{x:u,$filter:s},function(t,e){d(Ks(a),function(){return"Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+a+"'"});var o=e[0],i=e[1];return{x:function(){return function(t,e,n,r,o){d(t.length===e.rank,function(){return"Length of inShape ("+t.length+") and rank of dy ("+e.rank+") must match"});var a=t,i=e,s=!1;4===e.rank&&(s=!0,i=e.as5D(1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]),a=[1,t[0],t[1],t[2],t[3]]);var u=a[4],l=i.shape[4];d(5===a.length,function(){return"Error in conv3dDerInput: inShape must be length 5, but got length "+a.length+"."}),d(5===i.rank,function(){return"Error in conv3dDerInput: dy must be rank 5, but got rank "+i.rank}),d(5===n.rank,function(){return"Error in conv3dDerInput: filter must be rank 5, but got rank "+n.rank}),d(u===n.shape[3],function(){return"Error in conv3dDerInput: depth of input ("+u+") must match input depth for filter "+n.shape[3]+"."}),d(l===n.shape[4],function(){return"Error in conv3dDerInput: depth of output ("+l+") must match output depth for filter "+n.shape[4]+"."});var c=Ws(a,n.shape,r,1,o),h=Dt.runKernel(function(t){return t.conv3dDerInput(i,n,c)},{dy5D:i});return s?h.as4D(h.shape[1],h.shape[2],h.shape[3],h.shape[4]):h}(o.shape,t,i,n,r)},$filter:function(){return function(t,e,n,r,o){var a=t;4===t.rank&&(a=t.as5D(1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]));var i=e;4===i.rank&&(i=e.as5D(1,e.shape[0],e.shape[1],e.shape[2],e.shape[3])),d(5===a.rank,function(){return"Error in conv3dDerFilter: input must be rank 5, but got shape "+a.shape+"."}),d(5===i.rank,function(){return"Error in conv3dDerFilter: dy must be rank 5, but got shape "+i.shape+"."}),d(5===n.length,function(){return"Error in conv3dDerFilter: filterShape must be length 5, but got "+n+"."}),d(a.shape[4]===n[3],function(){return"Error in conv3dDerFilter: depth of input "+a.shape[4]+") must match input depth in filter ("+n[3]+"."}),d(i.shape[4]===n[4],function(){return"Error in conv3dDerFilter: depth of dy ("+i.shape[4]+") must match output depth for filter ("+n[4]+")."});var s=Ws(a.shape,n,r,1,o);return Dt.runKernel(function(t){return t.conv3dDerFilter(a,i,s)},{x5D:a,dy5D:i})}(o,t,i.shape,n,r)}}});return l?h.as4D(h.shape[1],h.shape[2],h.shape[3],h.shape[4]):h}}),Js=An({conv2dDerFilter_:js}),Zs=An({depthwiseConv2d_:function(t,e,n,r,o,a,i){void 0===o&&(o="NHWC"),void 0===a&&(a=[1,1]);var s=wn(t,"x","depthwiseConv2d"),u=wn(e,"filter","depthwiseConv2d"),l=s,c=!1;3===s.rank&&(c=!0,l=s.as4D(1,s.shape[0],s.shape[1],s.shape[2])),d(4===l.rank,function(){return"Error in depthwiseConv2d: input must be rank 4, but got rank "+l.rank+"."}),d(4===u.rank,function(){return"Error in depthwiseConv2d: filter must be rank 4, but got rank "+u.rank+"."}),d(l.shape[3]===u.shape[2],function(){return"Error in depthwiseConv2d: number of input channels ("+l.shape[3]+") must match the inChannels dimension in filter "+u.shape[2]+"."}),null==a&&(a=[1,1]),d(Hs(n,a),function(){return"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+a+"'"}),null!=i&&d(w(r),function(){return"Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode "+i+" but got pad "+r+"."});var h=Ls(l.shape,u.shape,n,a,r,i,!0),p=Dt.runKernel(function(t,e){var n=t.depthwiseConv2D(l,u,h);return e([l,u]),n},{x:l,$filter:u},function(t,e){d(qs(a),function(){return"Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+a+"'"});var n=e[0],r=e[1];return{x:function(){return function(t,e,n,r){var o=e,a=!1;3===e.rank&&(a=!0,o=e.as4D(1,e.shape[0],e.shape[1],e.shape[2]));var i=Dt.runKernel(function(t){return t.depthwiseConv2DDerInput(o,n,r)},{dy4D:o});return a?i.as3D(i.shape[1],i.shape[2],i.shape[3]):i}(n.shape,t,r,h)},$filter:function(){return function(t,e,n,r){var o=t;3===t.rank&&(o=t.as4D(1,t.shape[0],t.shape[1],t.shape[2]));var a=e;return 3===a.rank&&(a=e.as4D(1,e.shape[0],e.shape[1],e.shape[2])),Dt.runKernel(function(t){return t.depthwiseConv2DDerFilter(o,a,r)},{x4D:o,dy4D:a})}(n,t,r.shape,h)}}});return c?p.as3D(p.shape[1],p.shape[2],p.shape[3]):p}}),tu=An({separableConv2d_:function(t,e,n,r,o,a,i){void 0===a&&(a=[1,1]),void 0===i&&(i="NHWC");var s=wn(t,"x","separableConv2d"),u=wn(e,"depthwiseFilter","separableConv2d"),l=wn(n,"pointwiseFilter","separableConv2d"),c=s,h=!1;if(3===s.rank&&(h=!0,c=s.as4D(1,s.shape[0],s.shape[1],s.shape[2])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");d(4===c.rank,function(){return"Error in separableConv2d: input must be rank 4, but got rank "+c.rank+"."}),d(4===u.rank,function(){return"Error in separableConv2d: depthwise filter must be rank 4, but got rank "+u.rank+"."}),d(4===l.rank,function(){return"Error in separableConv2d: pointwise filter must be rank 4, but got rank "+u.rank+"."}),d(1===l.shape[0],function(){return"Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got "+l.shape[0]+"."}),d(1===l.shape[1],function(){return"Error in separableConv2d: the second dimension of pointwise filter must be 1, but got "+l.shape[1]+"."});var p=u.shape[2],f=u.shape[3];d(l.shape[2]===p*f,function(){return"Error in separableConv2d: the third dimension of pointwise filter must be "+p*f+", but got "+l.shape[2]+"."});var v=Zs(c,u,r,o,i,a),m=Ys(v,l,1,"valid",i);return h?m.as3D(m.shape[1],m.shape[2],m.shape[3]):m}}),eu=An({conv2dTranspose_:function(t,e,n,r,o,a){return $s(n,wn(t,"x","conv2dTranspose"),wn(e,"filter","conv2dTranspose"),r,o,a)}});var nu=An({matMul_:function(t,e,n,r){var o;void 0===n&&(n=!1),void 0===r&&(r=!1);var a=wn(t,"a","matMul"),i=wn(e,"b","matMul");o=Rt(a,i),a=o[0],i=o[1];var s=n?a.shape[a.rank-2]:a.shape[a.rank-1],u=r?i.shape[i.rank-1]:i.shape[i.rank-2],l=n?a.shape[a.rank-1]:a.shape[a.rank-2],c=r?i.shape[i.rank-2]:i.shape[i.rank-1],h=a.shape.slice(0,-2),p=i.shape.slice(0,-2),f=y(h),v=y(p);d(a.rank>=2&&i.rank>=2&&a.rank===i.rank,function(){return"Error in matMul: inputs must have the same rank of at least 2, got ranks "+a.rank+" and "+i.rank+"."}),d(x(h,p),function(){return"Error in matMul: outer dimensions ("+h+") and ("+p+") of Tensors with shapes "+a.shape+" and "+i.shape+" must match."}),d(s===u,function(){return"Error in matMul: inner shapes ("+s+") and ("+u+") of Tensors with shapes "+a.shape+" and "+i.shape+" and transposeA="+n+" and transposeB="+r+" must match."});var m=a.shape.slice(0,-2).concat([l,c]),g=n?a.as3D(f,s,l):a.as3D(f,l,s),w=r?i.as3D(v,c,u):i.as3D(v,u,c);return Dt.runKernel(function(t,e){var o=t.batchMatMul(g,w,n,r);return e([g,w]),o},{$a:g,$b:w},function(t,e){var o=e,a=o[0],i=o[1];return n||r?!n&&r?{$a:function(){return t.matMul(i,!1,!1)},$b:function(){return t.matMul(a,!0,!1)}}:n&&!r?{$a:function(){return i.matMul(t,!1,!0)},$b:function(){return a.matMul(t,!1,!1)}}:{$a:function(){return i.matMul(t,!0,!0)},$b:function(){return t.matMul(a,!0,!0)}}:{$a:function(){return t.matMul(i,!1,!0)},$b:function(){return a.matMul(t,!0,!1)}}}).reshape(m)}}),ru=An({dot_:function(t,e){var n=wn(t,"t1","dot"),r=wn(e,"t2","dot");d(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),function(){return"Error in dot: inputs must all be rank 1 or 2, but got ranks "+n.rank+" and "+r.rank+"."});var o=1===n.rank?n.size:n.shape[1],a=1===r.rank?r.size:r.shape[0];return d(o===a,function(){return"Error in dot: inner dimensions of inputs must match, but got "+o+" and "+a+"."}),1===n.rank&&1===r.rank?n.as2D(1,-1).matMul(r.as2D(-1,1)).asScalar():1===n.rank&&2===r.rank?n.as2D(1,-1).matMul(r.as2D(r.shape[0],r.shape[1])).as1D():2===n.rank&&1===r.rank?n.matMul(r.as2D(-1,1)).as1D():n.matMul(r.as2D(r.shape[0],r.shape[1]))}}),ou=An({outerProduct_:function(t,e){var n=wn(t,"v1","outerProduct"),r=wn(e,"v2","outerProduct");return d(1===n.rank&&1===r.rank,function(){return"Error in outerProduct: inputs must be rank 1, but got ranks "+n.rank+" and "+r.rank+"."}),n.as2D(-1,1).matMul(r.as2D(1,-1))}});var au=An({reverse_:function(t,e){var n=wn(t,"x","reverse");if(0===n.rank)return n.clone();var r=N(e,n.shape);return Dt.runKernel(function(t){return t.reverse(n,r)},{$x:n},function(t){return{$x:function(){return t.reverse(r)}}}).reshapeAs(n)}}),iu=An({reverse1d_:function(t){var e=wn(t,"x","reverse");return d(1===e.rank,function(){return"Error in reverse1D: x must be rank 1 but got rank "+e.rank+"."}),au(e,0)}}),su=An({reverse2d_:function(t,e){var n=wn(t,"x","reverse");return d(2===n.rank,function(){return"Error in reverse2D: x must be rank 2 but got rank "+n.rank+"."}),au(n,e)}}),uu=An({reverse3d_:function(t,e){var n=wn(t,"x","reverse");return d(3===n.rank,function(){return"Error in reverse3D: x must be rank 3 but got rank "+n.rank+"."}),au(n,e)}}),lu=An({reverse4d_:function(t,e){var n=wn(t,"x","reverse");return d(4===n.rank,function(){return"Error in reverse4D: x must be rank 4 but got rank "+n.rank+"."}),au(n,e)}});function cu(t,e,n,r,o,a){var i=wn(t,"x","maxPool"),s=i,u=!1;3===i.rank&&(u=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),null==r&&(r=[1,1]),d(4===s.rank,function(){return"Error in maxPool: input must be rank 4 but got rank "+s.rank+"."}),d(Hs(n,r),function(){return"Error in maxPool: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+r+"'"}),null!=a&&d(w(o),function(){return"Error in maxPool: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+o+"."});var l=Ps(s.shape,e,n,r,o,a),c=Dt.runKernel(function(t,e){var n=t.maxPool(s,l);return e([s,n]),n},{x:s},function(t,a){var i=a[0],s=a[1];return{x:function(){return function(t,e,n,r,o,a,i,s){var u=wn(t,"dy","maxPoolBackprop"),l=wn(e,"input","maxPoolBackprop"),c=wn(n,"output","maxPoolBackprop");d(l.rank===u.rank,function(){return"Rank of input ("+l.rank+") does not match rank of dy ("+u.rank+")"}),null==a&&(a=[1,1]),d(Hs(o,a),function(){return"Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides "+o+" and dilations '"+a+"'"}),d(4===u.rank,function(){return"Error in maxPoolBackprop: dy must be rank 4 but got rank "+u.rank+"."}),d(4===l.rank,function(){return"Error in maxPoolBackprop: input must be rank 4 but got rank "+l.rank+"."}),null!=s&&d(w(i),function(){return"Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode "+s+" but got pad "+i+"."});var h=Ps(l.shape,r,o,a,i,s);return Dt.runKernel(function(t){return t.maxPoolBackprop(u,l,c,h)},{$dy:u,$input:l})}(t,i,s,e,n,r,o)}}});return u?c.as3D(c.shape[1],c.shape[2],c.shape[3]):c}function hu(t,e,n,r,o,a){var i=wn(t,"x","avgPool","float32");null==r&&(r=[1,1]),d(Hs(n,r),function(){return"Error in avgPool: Either strides or dilations must be 1. Got strides "+n+" and dilations '"+r+"'"});var s=i,u=!1;3===i.rank&&(u=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),d(4===s.rank,function(){return"Error in avgPool: x must be rank 4 but got rank "+s.rank+"."}),null!=a&&d(w(o),function(){return"Error in avgPool: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+o+"."});var l=Ps(s.shape,e,n,r,o,a),c=Dt.runKernel(function(t){return t.avgPool(s,l)},{x:s},function(t){return{x:function(){return function(t,e,n,r,o,a){var i=wn(t,"dy","avgPoolBackprop"),s=wn(e,"input","avgPoolBackprop");d(s.rank===i.rank,function(){return"Rank of input ("+s.rank+") does not match rank of dy ("+i.rank+")"}),null==o&&(o=[1,1]),d(Hs(r,o),function(){return"Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides "+r+" and dilations '"+o+"'"});var u=s,l=i,c=!1;3===s.rank&&(c=!0,u=s.as4D(1,s.shape[0],s.shape[1],s.shape[2]),l=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),d(4===l.rank,function(){return"Error in avgPoolBackprop: dy must be rank 4 but got rank "+l.rank+"."}),d(4===u.rank,function(){return"Error in avgPoolBackprop: input must be rank 4 but got rank "+u.rank+"."});var h=Ps(u.shape,n,r,o,a),p=Dt.runKernel(function(t){return t.avgPoolBackprop(l,u,h)},{dy4D:l,input4D:u});return c?p.as3D(p.shape[1],p.shape[2],p.shape[3]):p}(t,s,e,n,r,o)}}});return c=c.cast(i.dtype),u?c.as3D(c.shape[1],c.shape[2],c.shape[3]):c}var pu=An({maxPool_:function(t,e,n,r,o){return cu(t,e,n,1,r,o)}}),fu=An({avgPool_:function(t,e,n,r,o){return hu(t,e,n,1,r,o)}}),du=An({pool_:function(t,e,n,r,o,a){null==o&&(o=[1,1]),null==a&&(a=1),0===r&&(r="valid");var i=wn(t,"x","maxPool"),s=i,u=!1;3===i.rank&&(u=!0,s=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),d(Hs(a,o),function(){return"Error in pool: Either strides or dilations must be 1. Got strides "+a+" and dilations '"+o+"'"});var l,c=Ps(s.shape,e,a,o,r),h=[c.dilationHeight,c.dilationWidth];l="same"===r?function(t,e){var n=t.map(function(t,n){return t+(t-1)*(e[n]-1)}).map(function(t){return t-1}),r=n.map(function(t){return Math.floor(t/2)}),o=n.map(function(t,e){return t-r[e]});return n.map(function(t,e){return[r[e],o[e]]})}([c.filterHeight,c.filterWidth],h):[[0,0],[0,0]];var p=1===h[0]&&1===h[1],f=function(t,e,n){var r=n.map(function(t){return t[0]}),o=n.map(function(t){return t[1]}),a=t.concat(r,o),i=e.map(function(t,e){return(t-a[e]%t)%t}),s=o.map(function(t,e){return t+i[e]}),u=e.map(function(t,e){return[r[e],s[e]]}),l=e.map(function(t,e){return[0,i[e]]});return[u,l]}([c.inHeight,c.inWidth],h,l),v=f[0],m=f[1],g=p?r:"valid",y=p?s:$r(s,h,v),x=("avg"===n?function(){return hu(y,e,a,1,g)}:function(){return cu(y,e,a,1,g)})(),w=p?x:Ir(x,h,m);return u?w.as3D(w.shape[1],w.shape[2],w.shape[3]):w}});var vu=An({slice_:function(t,e,n){var r,o,a=wn(t,"x","slice");if(0===a.rank)throw new Error("Slicing scalar is not possible");r="number"==typeof e?[e].concat(new Array(a.rank-1).fill(0)):e.length<a.rank?e.concat(new Array(a.rank-e.length).fill(0)):e.slice(),o=(o=null==n?new Array(a.rank).fill(-1):"number"==typeof n?[n].concat(new Array(a.rank-1).fill(-1)):n.length<a.rank?n.concat(new Array(a.rank-n.length).fill(-1)):n).map(function(t,e){return t>=0?t:(d(-1===t,function(){return"Bad value in size"}),a.shape[e]-r[e])}),function(t,e,n){d(t.rank===e.length,function(){return"Error in slice"+t.rank+"D: Length of begin "+e+" must match the rank of the array ("+t.rank+")."}),d(t.rank===n.length,function(){return"Error in slice"+t.rank+"D: Length of size "+n+" must match the rank of the array ("+t.rank+")."});for(var r=function(r){d(e[r]+n[r]<=t.shape[r],function(){return"Error in slice"+t.rank+"D: begin["+r+"] + size["+r+"] ("+(e[r]+n[r])+") would overflow input.shape["+r+"] ("+t.shape[r]+")"})},o=0;o<t.rank;++o)r(o)}(a,r,o);var i=a.shape;return Dt.runKernel(function(t){return t.slice(a,r,o)},{$x:a},function(t){for(var e=[],n=0;n<t.rank;n++)e.push([r[n],i[n]-r[n]-o[n]]);return{$x:function(){return t.pad(e)}}})}}),mu=An({slice1d_:function(t,e,n){var r=wn(t,"x","slice1d");return d(1===r.rank,function(){return"slice1d expects a rank-1 tensor, but got a rank-"+r.rank+" tensor"}),vu(r,[e],[n])}}),gu=An({slice2d_:function(t,e,n){var r=wn(t,"x","slice2d");return d(2===r.rank,function(){return"slice2d expects a rank-2 tensor, but got a rank-"+r.rank+" tensor"}),vu(r,e,n)}}),yu=An({slice3d_:function(t,e,n){var r=wn(t,"x","slice3d");return d(3===r.rank,function(){return"slice3d expects a rank-3 tensor, but got a rank-"+r.rank+" tensor"}),vu(r,e,n)}}),xu=An({slice4d_:function(t,e,n){var r=wn(t,"x","slice4d");return d(4===r.rank,function(){return"slice4d expects a rank-4 tensor, but got a rank-"+r.rank+" tensor"}),vu(r,e,n)}});function wu(t,e,n,r,o){return e.rank<n.rank&&(e=e.reshape(en(e.shape,r))),t.rank<n.rank&&(t=t.reshape(en(t.shape,r))),{$x:function(){var r=t.mul(n.equal(e).cast(t.dtype));return null==o?r:r.transpose(o)}}}var bu=An({all_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","all","bool"),o=N(e,r.shape),a=o,i=rn(a,r.rank);null!=i&&(r=r.transpose(i),a=an(a.length,r.rank));var s=Dt.runKernel(function(t){return t.all(r,a)},{$x:r});if(n){var u=en(s.shape,o);return s.reshape(u)}return s}}),Cu=An({any_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","any","bool"),o=N(e,r.shape),a=o,i=rn(a,r.rank);null!=i&&(r=r.transpose(i),a=an(a.length,r.rank));var s=Dt.runKernel(function(t){return t.any(r,a)},{$x:r});if(n){var u=en(s.shape,o);return s.reshape(u)}return s}}),Eu=An({argMax_:function(t,e){void 0===e&&(e=0);var n=wn(t,"x","argMax");null==e&&(e=0);var r=N(e,n.shape),o=rn(r,n.rank);return null!=o&&(n=n.transpose(o),r=an(r.length,n.rank)),Dt.runKernel(function(t,e){var o=t.argMax(n,r[0]);return e([n]),o},{$x:n},function(t,e){var n=e[0];return{$x:function(){return Xn(n)}}})}}),Ru=An({argMin_:function(t,e){void 0===e&&(e=0);var n=wn(t,"x","argMin");null==e&&(e=0);var r=N(e,n.shape),o=rn(r,n.rank);return null!=o&&(n=n.transpose(o),r=an(r.length,n.rank)),Dt.runKernel(function(t,e){var o=t.argMin(n,r[0]);return e([n]),o},{$x:n},function(t,e){var n=e[0];return{$x:function(){return Xn(n)}}})}}),Su=An({logSumExp_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","logSumExp"),o=N(e,r.shape),a=r.max(o,!0),i=r.sub(a).exp().sum(o).log(),s=a.reshape(i.shape).add(i);if(n){var u=en(s.shape,o);return s.reshape(u)}return s}}),Nu=An({max_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","max"),o=r,a=N(e,r.shape),i=a,s=rn(i,r.rank);null!=s&&(r=r.transpose(s),i=an(i.length,r.rank));var u=Dt.runKernel(function(t,e){var n=t.max(r,i);return e([o,n]),n},{$x:r},function(t,e){return wu(t,e[1],e[0],a,s)});if(n){var l=en(u.shape,a);u=u.reshape(l)}return u}}),ku=An({mean_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","mean"),o=N(e,r.shape),a=y(tn(r.shape,o)[1]);return kn(function(t){var r=Bn(a);return{value:(r.dtype===t.dtype?t:t.cast(r.dtype)).div(r).sum(e,n),gradFunc:function(e){var n=t.shape.slice();return o.forEach(function(t){n[t]=1}),e.reshape(n).mul(Gn(t.shape,"float32")).div(a)}}})(r)}}),Iu=An({min_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","min"),o=r,a=N(e,r.shape),i=a,s=rn(i,r.rank);null!=s&&(r=r.transpose(s),i=an(i.length,r.rank));var u=Dt.runKernel(function(t,e){var n=t.min(r,i);return e([o,n]),n},{$x:r},function(t,e){return wu(t,e[1],e[0],a,s)});if(n){var l=en(u.shape,a);u=u.reshape(l)}return u}}),Au=An({moments_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=N(e,(t=wn(t,"x","moments")).shape),o=t.mean(r,n),a=o.shape;n||(a=en(o.shape,r));var i=t.toFloat().sub(o.reshape(a)).square();return{mean:o,variance:i.mean(r,n)}}}),Tu=An({sum_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","sum");"bool"===r.dtype&&(r=r.toInt());var o=N(e,r.shape);return kn(function(t){var e=rn(o,t.rank),r=o,a=t;null!=e&&(a=t.transpose(e),r=an(r.length,t.rank));var i=Dt.runKernel(function(t){return t.sum(a,r)},{permutedX:a});if(n){var s=en(i.shape,o);i=i.reshape(s)}return{value:i,gradFunc:function(e){var n=t.shape.slice();return o.forEach(function(t){n[t]=1}),e.reshape(n).mul(Gn(t.shape,"float32"))}}})(r)}}),Du=An({prod_:function(t,e,n){void 0===e&&(e=null),void 0===n&&(n=!1);var r=wn(t,"x","prod");"bool"===r.dtype&&(r=r.toInt());var o=N(e,r.shape),a=rn(o,r.rank),i=o,s=r;null!=a&&(s=r.transpose(a),i=an(i.length,r.rank));var u=Dt.runKernel(function(t){return t.prod(s,i)},{permutedX:s});if(n){var l=en(u.shape,o);u=u.reshape(l)}return u}});var Ou=An({equal_:function(t,e){var n,r=wn(t,"a","equal"),o=wn(e,"b","equal");return n=Rt(r,o),r=n[0],o=n[1],so(r.shape,o.shape),Dt.runKernel(function(t){return t.equal(r,o)},{$a:r,$b:o})}}),_u=An({equalStrict_:function(t,e){var n=wn(t,"a","equalStrict"),r=wn(e,"b","equalStrict");return v(n.shape,r.shape,"Error in equalStrict: "),n.equal(r)}}),Mu=An({greater_:function(t,e){var n,r=wn(t,"a","greater"),o=wn(e,"b","greater");return n=Rt(r,o),r=n[0],o=n[1],so(r.shape,o.shape),Dt.runKernel(function(t){return t.greater(r,o)},{$a:r,$b:o})}}),Fu=An({greaterEqual_:function(t,e){var n,r=wn(t,"a","greaterEqual"),o=wn(e,"b","greaterEqual");return n=Rt(r,o),r=n[0],o=n[1],so(r.shape,o.shape),Dt.runKernel(function(t,e){var n=t.greaterEqual(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){return Xn(n)},$b:function(){return Xn(r)}}})}}),Bu=An({greaterEqualStrict_:function(t,e){var n=wn(t,"a","greaterEqualStrict"),r=wn(e,"b","greaterEqualStrict");return v(n.shape,r.shape,"Error in greaterEqualStrict: "),n.greaterEqual(r)}}),Pu=An({greaterStrict_:function(t,e){var n=wn(t,"a","greaterStrict"),r=wn(e,"b","greaterStrict");return v(n.shape,r.shape,"Error in greaterStrict: "),n.greater(r)}}),Lu=An({less_:function(t,e){var n,r=wn(t,"a","less"),o=wn(e,"b","less");return n=Rt(r,o),r=n[0],o=n[1],so(r.shape,o.shape),Dt.runKernel(function(t){return t.less(r,o)},{$a:r,$b:o})}}),Wu=An({lessEqual_:function(t,e){var n,r=wn(t,"a","lessEqual"),o=wn(e,"b","lessEqual");return n=Rt(r,o),r=n[0],o=n[1],so(r.shape,o.shape),Dt.runKernel(function(t){return t.lessEqual(r,o)},{$a:r,$b:o})}}),Uu=An({lessEqualStrict_:function(t,e){var n=wn(t,"a","lessEqualStrict"),r=wn(e,"b","lessEqualStrict");return v(n.shape,r.shape,"Error in lessEqualStrict: "),n.lessEqual(r)}}),zu=An({lessStrict_:function(t,e){var n=wn(t,"a","lessStrict"),r=wn(e,"b","lessStrict");return v(n.shape,r.shape,"Error in lessStrict: "),n.less(r)}}),Vu=An({notEqual_:function(t,e){var n,r=wn(t,"a","notEqual"),o=wn(e,"b","notEqual");return n=Rt(r,o),r=n[0],o=n[1],so(r.shape,o.shape),Dt.runKernel(function(t){return t.notEqual(r,o)},{$a:r,$b:o})}}),Gu=An({notEqualStrict_:function(t,e){var n=wn(t,"a","notEqualStrict"),r=wn(e,"b","notEqualStrict");return v(n.shape,r.shape,"Error in notEqualStrict: "),n.notEqual(r)}});var qu=An({add_:function(t,e){var n,r=wn(t,"a","add"),o=wn(e,"b","add");n=Rt(r,o),r=n[0],o=n[1];var a=so(r.shape,o.shape);return Dt.runKernel(function(t){return t.add(r,o)},{$a:r,$b:o},function(t){return{$a:function(){var e=t,n=io(r.shape,a);return n.length>0&&(e=e.sum(n)),e.reshape(r.shape)},$b:function(){var e=t,n=io(o.shape,a);return n.length>0&&(e=e.sum(n)),e.reshape(o.shape)}}})}}),Hu=An({addN_:function(t){d(Array.isArray(t),function(){return"The argument passed to tf.addN() must be a list of tensors"}),d(t.length>=1,function(){return"Must pass at least one tensor to tf.addN(), but got "+t.length});var e=t.map(function(t,e){return wn(t,"tensors"+e,"addN")}),n=e[0];e.forEach(function(t){if(t.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(function(t){if(!x(t.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});var r=e;return Dt.runKernel(function(t){return t.addN(e)},r,function(t){var n={};return e.forEach(function(e,r){n[r]=function(){return t.clone()}}),n})}}),$u=An({addStrict_:function(t,e){var n=wn(t,"a","addStrict"),r=wn(e,"b","addStrict");return v(n.shape,r.shape,"Error in addStrict: "),n.add(r)}}),ju=An({atan2_:function(t,e){var n,r=wn(t,"a","atan2"),o=wn(e,"b","atan2");n=Rt(r,o),r=n[0],o=n[1];var a=so(r.shape,o.shape);return Dt.runKernel(function(t,e){var n=t.atan2(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){var e=qu(n.square(),r.square()),o=t.mul(r.div(e)),i=io(n.shape,a);return i.length>0&&(o=o.sum(i)),o.reshape(n.shape)},$b:function(){var e=qu(n.square(),r.square()),o=is(t.mul(n.div(e))),i=io(r.shape,a);return i.length>0&&(o=o.sum(i)),o.reshape(r.shape)}}})}}),Ku=An({div_:function(t,e){var n,r=wn(t,"a","div"),o=wn(e,"b","div");if(n=Rt(r,o),r=n[0],o=n[1],"int32"===r.dtype&&"int32"===o.dtype)return Yu(r,o);var a=so(r.shape,o.shape);return Dt.runKernel(function(t,e){var n=t.realDivide(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){var e=t.div(r.toFloat()),o=io(n.shape,a);return o.length>0?e.sum(o).reshape(n.shape):e},$b:function(){var e=t.mul(n.toFloat()),o=io(r.shape,a);o.length>0&&(e=e.sum(o).reshape(r.shape));var i=r.square();return e.div(i.toFloat()).neg()}}})}}),Xu=An({divStrict_:function(t,e){var n=wn(t,"a","div"),r=wn(e,"b","div");return v(n.shape,r.shape,"Error in divideStrict: "),n.div(r)}}),Yu=An({floorDiv_:function(t,e){var n,r=wn(t,"a","floorDiv"),o=wn(e,"b","floorDiv");n=Rt(r,o),r=n[0],o=n[1];var a=so(r.shape,o.shape);return Dt.runKernel(function(t,e){var n=t.floorDiv(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){var e=t.div(r.toFloat()),o=io(n.shape,a);return o.length>0?e.sum(o).reshape(n.shape):e},$b:function(){var e=t.mul(n.toFloat()),o=io(r.shape,a);o.length>0&&(e=e.sum(o).reshape(r.shape));var i=r.square();return e.div(i.toFloat()).neg()}}})}}),Qu=An({maximum_:function(t,e){var n,r=wn(t,"a","maximum"),o=wn(e,"b","maximum");return n=Rt(r,o),r=n[0],o=n[1],"bool"===r.dtype&&(r=r.toInt(),o=o.toInt()),so(r.shape,o.shape),Dt.runKernel(function(t,e){var n=t.maximum(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){return t.mul(n.greaterEqual(r).toFloat())},$b:function(){return t.mul(n.less(r).toFloat())}}})}}),Ju=An({maximumStrict_:function(t,e){var n=wn(t,"a","maximumStrict"),r=wn(e,"b","maximumStrict");return v(n.shape,r.shape,"Error in maximumStrict: "),n.maximum(r)}}),Zu=An({minimum_:function(t,e){var n,r=wn(t,"a","minimum"),o=wn(e,"b","minimum");return n=Rt(r,o),r=n[0],o=n[1],"bool"===r.dtype&&(r=r.toInt(),o=o.toInt()),so(r.shape,o.shape),Dt.runKernel(function(t,e){var n=t.minimum(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){return t.mul(n.lessEqual(r).toFloat())},$b:function(){return t.mul(n.greater(r).toFloat())}}})}}),tl=An({minimumStrict_:function(t,e){var n=wn(t,"a","minimumStrict"),r=wn(e,"b","minimumStrict");return v(n.shape,r.shape,"Error in minimumStrict: "),n.minimum(r)}}),el=An({mod_:function(t,e){var n,r=wn(t,"a","mod"),o=wn(e,"b","mod");n=Rt(r,o),r=n[0],o=n[1];var a=so(r.shape,o.shape);return Dt.runKernel(function(t,e){var n=t.mod(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){var e=io(n.shape,a);return e.length>0?t.sum(e).reshape(n.shape):t},$b:function(){var e=t.mul(n.div(r).floor().neg()),o=io(r.shape,a);return o.length>0?e.sum(o).reshape(r.shape):e}}})}}),nl=An({modStrict_:function(t,e){var n=wn(t,"a","modStrict"),r=wn(e,"b","modStrict");return v(n.shape,r.shape,"Error in modStrict: "),n.mod(r)}}),rl=An({mul_:function(t,e){var n,r=wn(t,"a","mul"),o=wn(e,"b","mul");n=Rt(r,o),r=n[0],o=n[1];var a=so(r.shape,o.shape);return Dt.runKernel(function(t,e){var n=t.multiply(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1];return{$a:function(){var e=t.mul(r.toFloat()),o=io(n.shape,a);return o.length>0?e.sum(o).reshape(n.shape):e},$b:function(){var e=t.mul(n.toFloat()),o=io(r.shape,a);return o.length>0?e.sum(o).reshape(r.shape):e}}})}}),ol=An({mulStrict_:function(t,e){var n=wn(t,"a","mul"),r=wn(e,"b","mul");return v(n.shape,r.shape,"Error in multiplyStrict: "),n.mul(r)}}),al=An({pow_:function(t,e){var n=wn(t,"base","pow"),r=wn(e,"exp","pow"),o=so(n.shape,r.shape);return t=n.cast(Ct(n.dtype,r.dtype)),e=r.cast(Ct(n.dtype,r.dtype)),Dt.runKernel(function(t,e){var o=t.pow(n,r);return e([n,r,o]),o},{$base:n,$exp:r},function(t,e){var n=e[0],r=e[1],a=e[2];return{$base:function(){var e=r.toFloat(),a=t.mul(e.mul(n.pow(e.sub(Bn(1))))),i=io(n.shape,o);return i.length>0&&(a=a.sum(i)),a.reshape(n.shape)},$exp:function(){var e=n.greater(0),i=n.log().where(e,Xn(n)),s=t.mul(a.mul(i)),u=io(r.shape,o);return u.length>0&&(s=s.sum(u)),s.reshape(r.shape)}}})}}),il=An({powStrict_:function(t,e){return v(t.shape,e.shape,"Error in powStrict: "),t.pow(e)}}),sl=An({squaredDifference_:function(t,e){var n,r=wn(t,"a","squaredDifference"),o=wn(e,"b","squaredDifference");return n=Rt(r,o),r=n[0],o=n[1],so(r.shape,o.shape),Dt.runKernel(function(t,e){var n=t.squaredDifference(r,o);return e([r,o]),n},{$a:r,$b:o},function(t,e){var n=e[0],r=e[1],o=Bn(2);return{$a:function(){return t.mul(n.sub(r).mul(o))},$b:function(){return t.mul(r.sub(n).mul(o))}}})}}),ul=An({squaredDifferenceStrict_:function(t,e){var n=wn(t,"a","squaredDifferenceStrict"),r=wn(e,"b","squaredDifferenceStrict");return v(n.shape,r.shape,"Error in squaredDifferenceStrict: "),n.squaredDifference(r)}}),ll=An({sub_:function(t,e){var n,r=wn(t,"a","sub"),o=wn(e,"b","sub");n=Rt(r,o),r=n[0],o=n[1];var a=so(r.shape,o.shape);return Dt.runKernel(function(t){return t.subtract(r,o)},{$a:r,$b:o},function(t){return{$a:function(){var e=t,n=io(r.shape,a);return n.length>0&&(e=e.sum(n)),e.reshape(r.shape)},$b:function(){var e=t,n=io(o.shape,a);return n.length>0&&(e=e.sum(n)),e.neg().reshape(o.shape)}}})}}),cl=An({subStrict_:function(t,e){var n=wn(t,"a","subStrict"),r=wn(e,"b","subStrict");return v(n.shape,r.shape,"Error in subStrict: "),n.sub(r)}});var hl=An({logicalAnd_:function(t,e){var n=wn(t,"a","logicalAnd","bool"),r=wn(e,"b","logicalAnd","bool");return so(n.shape,r.shape),Dt.runKernel(function(t){return t.logicalAnd(n,r)},{$a:n,$b:r})}}),pl=An({logicalNot_:function(t){var e=wn(t,"x","logicalNot","bool");return Dt.runKernel(function(t){return t.logicalNot(e)},{$x:e})}}),fl=An({logicalOr_:function(t,e){var n=wn(t,"a","logicalOr","bool"),r=wn(e,"b","logicalOr","bool");return so(n.shape,r.shape),Dt.runKernel(function(t){return t.logicalOr(n,r)},{$a:n,$b:r})}}),dl=An({logicalXor_:function(t,e){var n=wn(t,"a","logicalXor","bool"),r=wn(e,"b","logicalXor","bool");return so(n.shape,r.shape),fl(t,e).logicalAnd(hl(t,e).logicalNot())}}),vl=An({where_:function(t,e,n){var r=wn(e,"a","where"),o=wn(n,"b","where"),a=wn(t,"condition","where","bool");return v(r.shape,o.shape,"Error in where: "),1===a.rank?d(a.shape[0]===r.shape[0],function(){return"The first dimension of `a` must match the size of `condition`."}):v(a.shape,o.shape,"Error in where: "),Dt.runKernel(function(t,e){var n=t.select(a,r,o);return e([a]),n},{$condition:a,$a:r,$b:o},function(t,e){var n=e[0];return{$condition:function(){return Xn(n).toFloat()},$a:function(){return t.mul(n.cast(t.dtype))},$b:function(){return t.mul(n.logicalNot().cast(t.dtype))}}})}}),ml=function(t){return r(this,void 0,void 0,function(){var e,n,r;return o(this,function(o){switch(o.label){case 0:return[4,(e=wn(t,"condition","whereAsync","bool")).data()];case 1:return n=o.sent(),r=Zr(e.shape,n),t!==e&&e.dispose(),[2,r]}})})};var gl=An({elu_:function(t){var e=wn(t,"x","elu");return Dt.runKernel(function(t,n){var r=t.elu(e);return n([r]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return Dt.runKernel(function(e){return e.eluDer(t,n)},{dy:t,y:n})}}})}}),yl=An({leakyRelu_:function(t,e){void 0===e&&(e=.2);var n=wn(t,"x","leakyRelu");return Qu(Bn(e).mul(n),n)}}),xl=An({prelu_:function(t,e){var n=wn(t,"x","prelu"),r=wn(e,"alpha","prelu");return Dt.runKernel(function(t,e){var o=t.prelu(n,r);return e([n,r]),o},{$x:n,$alpha:r},function(t,e){var n=e[0],r=e[1],o=n.greater(0);return{$x:function(){return vl(o,t,t.mul(r))},$alpha:function(){var e=vl(o,Xn(t),t.mul(n)),a=io(r.shape,t.shape);return a.length>0&&(e=e.sum(a)),e.reshape(r.shape)}}})}}),wl=An({relu_:function(t){var e=wn(t,"x","relu");return"bool"===e.dtype?e.toInt():Dt.runKernel(function(t,n){var r=t.relu(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){return t.mulStrict(n.step().toFloat())}}})}}),bl=An({selu_:function(t){var e=wn(t,"x","selu");return Dt.runKernel(function(t,n){var r=t.selu(e);return n([e]),r},{$x:e},function(t,e){var n=e[0];return{$x:function(){var e=n.greater(Bn(0)),r=Bn(bi),o=Bn(Ci),a=t.mul(o),i=t.mul(r).mul(n.toFloat().exp());return vl(e,a,i)}}})}});var Cl=An({transpose_:function(t,e){var n=wn(t,"x","transpose");return null==e&&(e=n.shape.map(function(t,e){return e}).reverse()),d(n.rank===e.length,function(){return"Error in transpose: rank of input "+n.rank+" must match length of perm "+e+"."}),e.forEach(function(t){d(t>=0&&t<n.rank,function(){return"All entries in 'perm' must be between 0 and "+(n.rank-1)+" but got "+e})}),n.rank<=1?n.clone():Dt.runKernel(function(t){return t.transpose(n,e)},{$x:n},function(t){var n=on(e);return{$x:function(){return t.transpose(n)}}})}});var El=An({localResponseNormalization_:function(t,e,n,r,o){void 0===e&&(e=5),void 0===n&&(n=1),void 0===r&&(r=1),void 0===o&&(o=.5);var a=wn(t,"x","localResponseNormalization");d(4===a.rank||3===a.rank,function(){return"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank "+a.rank+"."}),d(w(e),function(){return"Error in localResponseNormalization: depthRadius must be an integer but got depthRadius "+e+"."});var i=a,s=!1;3===a.rank&&(s=!0,i=a.as4D(1,a.shape[0],a.shape[1],a.shape[2]));var u=Dt.runKernel(function(t,a){var s=t.localResponseNormalization4D(i,e,n,r,o);return a([i,s]),s},{x4D:i},function(t,a){var i=a[0],s=a[1];return{x4D:function(){return Dt.runKernel(function(a){return a.LRNGrad(t,i,s,e,n,r,o)},{})}}});return s?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}});var Rl=An({norm_:function(t,e,n,r){void 0===e&&(e="euclidean"),void 0===n&&(n=null),void 0===r&&(r=!1);var o=function t(e,n,r){if(void 0===r&&(r=null),0===e.rank)return e.abs();if(1!==e.rank&&null===r)return t(e.reshape([-1]),n,r);if(1===e.rank||"number"==typeof r||Array.isArray(r)&&1===r.length){if(1===n)return e.abs().sum(r);if(n===1/0)return e.abs().max(r);if(n===-1/0)return e.abs().min(r);if("euclidean"===n||2===n)return e.abs().pow(Bn(2,"int32")).sum(r).sqrt();throw new Error("Error in norm: invalid ord value: "+n)}if(Array.isArray(r)&&2===r.length){if(1===n)return e.abs().sum(r[0]).max(r[1]-1);if(n===1/0)return e.abs().sum(r[1]).max(r[0]);if(n===-1/0)return e.abs().sum(r[1]).min(r[0]);if("fro"===n||"euclidean"===n)return e.square().sum(r).sqrt();throw new Error("Error in norm: invalid ord value: "+n)}throw new Error("Error in norm: invalid axis: "+r)}(t=wn(t,"x","norm"),e,n),a=o.shape;if(r){var i=N(n,t.shape);a=en(o.shape,i)}return o.reshape(a)}});function Sl(t,e){for(var n=[],r=t;r<e;++r)n.push(r);return n}function Nl(t){for(var e=[],n=0;n<t.length;++n)for(var r=0;r<t[n].length;++r)e.push(t[n][r]);return e}var kl=An({gather_:function(t,e,n){void 0===n&&(n=0);var r=wn(t,"x","gather"),o=wn(e,"indices","gather","int32");n=N(n,r.shape)[0];var a=function(t,e,n){for(var r=t.shape[n],o=[],a=1,i=1,s=0;s<n;s++)o.push(t.shape[s]),a*=t.shape[s];for(s=0;s<e.rank;s++)o.push(e.shape[s]);for(s=n+1;s<t.rank;s++)o.push(t.shape[s]),i*=t.shape[s];return{batchSize:a,sliceSize:i,dimSize:r,outputShape:o}}(r,o,n);return Dt.runKernel(function(t,e){var a=t.gather(r,o.flatten(),n);return e([o]),a},{$x:r},function(t,e){var o=e[0];return{$x:function(){var e=r.shape,a=o.size,i=e.slice(0,n),s=i.length,u=e.slice(n,e.length).slice(1),l=u.length,c=Sl(0,s),h=Sl(s+1,s+1+l),p=Nl([i,[a],u]),f=t.reshape(p),d=o.reshape([a]),v=Nl([[s],c,h]),m=f.transpose(v),g=Il(m,d,r.shape[n]),y=on(v);return g=g.transpose(y)}}}).reshape(a.outputShape)}}),Il=An({unsortedSegmentSum_:function(t,e,n){var r=wn(t,"x","unsortedSegmentSum"),o=wn(e,"segmentIds","unsortedSegmentSum","int32");return d(w(n),function(){return"numSegments must be of dtype int"}),Dt.runKernel(function(t,e){var a=t.unsortedSegmentSum(r,o,n);return e([o]),a},{$x:r},function(t,e){var n=e[0];return{$x:function(){return function(t,e){for(var n=Qu(e,Xn(e)),r=kl(t,n),o=Fu(e,Bn(0,"int32")),a=r.rank-o.rank,i=0;i<a;++i)o=_r(o,i+1);o=hl(o,Gn(r.shape,"bool"));var s=Xn(r);return vl(o,r,s)}(t,n)}}})}});var Al=An({basicLSTMCell_:function(t,e,n,r,o,a){var i=wn(t,"forgetBias","basicLSTMCell"),s=wn(e,"lstmKernel","basicLSTMCell"),u=wn(n,"lstmBias","basicLSTMCell"),l=wn(r,"data","basicLSTMCell"),c=wn(o,"c","basicLSTMCell"),h=wn(a,"h","basicLSTMCell"),p=l.concat(h,1).matMul(s).add(u),f=p.shape[0],d=p.shape[1]/4,v=[f,d],m=p.slice([0,0],v),g=p.slice([0,d],v),y=p.slice([0,2*d],v),x=p.slice([0,3*d],v),w=m.sigmoid().mulStrict(g.tanh()).addStrict(c.mulStrict(i.add(y).sigmoid())),b=w.tanh().mulStrict(x.sigmoid());return[w,b]}}),Tl=An({multiRNNCell_:function(t,e,n,r){for(var o=wn(e,"data","multiRNNCell"),a=bn(n,"c","multiRNNCell"),i=bn(r,"h","multiRNNCell"),s=o,u=[],l=0;l<t.length;l++){var c=t[l](s,a[l],i[l]);u.push(c[0]),u.push(c[1]),s=c[1]}var h=[],p=[];for(l=0;l<u.length;l+=2)h.push(u[l]),p.push(u[l+1]);return[h,p]}});var Dl=An({movingAverage_:function(t,e,n,r,o){void 0===o&&(o=!0);var a=wn(t,"v","movingAverage"),i=wn(e,"x","movingAverage"),s=wn(n,"decay","movingAverage");St(a,i),d(x(a.shape,i.shape),function(){return"Shape mismatch in v and x"});var u=Bn(1),l=u.sub(s),c=i.sub(a).mul(l);if(o){d(null!=r,function(){return"When using zeroDebias: true, step is required."});var h=wn(r,"step","movingAverage");c=c.div(u.sub(al(s,h)))}return a.add(c)}});var Ol=An({stridedSlice_:function(t,e,n,r,o,a,i,s,u){if(void 0===o&&(o=0),void 0===a&&(a=0),void 0===i&&(i=0),void 0===s&&(s=0),void 0===u&&(u=0),0!==i)throw new Error("ellipsis mask is not yet supported");if(0!==s)throw new Error("new axis mask is not yet supported");var l=wn(t,"x","stridedSlice");if(r.every(function(t){return 1===t})){var c=fn(l.shape,e,n,r,o,a,i,s,u),h=c[0],p=c[1],f=c[2],d=p.filter(function(t,e){return-1===f.indexOf(e)});return vu(l,h,p).reshape(d)}return Dt.runKernel(function(t){return t.stridedSlice(l,e,n,r,o,a,i,s,u)},{$x:l})}});var _l=An({topk_:function(t,e,n){void 0===e&&(e=1),void 0===n&&(n=!0);var r=wn(t,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");var o=r.shape[r.shape.length-1];if(e>o)throw new Error("'k' passed to topk() must be <= the last dimension ("+o+") but got "+e);var a=Dt.runKernel(function(t){return t.topk(r,e,n)},{$x:r});return{values:a[0],indices:a[1]}}});var Ml=An({scatterND_:function(t,e,n){var r=wn(t,"indices","scatterND","int32"),o=wn(e,"updates","scatterND");return hn(o,r,n),Dt.runKernel(function(t){return t.scatterND(r,o,n)},{$indices:r,$updates:o})}});var Fl=An({fft_:function(t){d("complex64"===t.dtype,function(){return"The dtype for tf.spectral.fft() must be complex64 but got "+t.dtype+"."});var e=t.shape[t.shape.length-1],n=t.size/e,r=t.as2D(n,e);return Dt.runKernel(function(t){return t.fft(r)},{input:t}).reshape(t.shape)}}),Bl=An({ifft_:function(t){d("complex64"===t.dtype,function(){return"The dtype for tf.spectral.ifft() must be complex64 but got "+t.dtype+"."});var e=t.shape[t.shape.length-1],n=t.size/e,r=t.as2D(n,e);return Dt.runKernel(function(t){return t.ifft(r)},{input:t}).reshape(t.shape)}}),Pl=An({rfft_:function(t){d("float32"===t.dtype,function(){return"The dtype for rfft() must be real value but got "+t.dtype});var e=t.shape[t.shape.length-1],n=t.size/e,r=t.zerosLike(),o=On(t,r).as2D(n,e),a=Fl(o),i=Math.floor(e/2)+1,s=_n(a),u=Mn(a),l=s.split([i,e-i],s.shape.length-1),c=u.split([i,e-i],u.shape.length-1),h=t.shape.slice();return h[t.shape.length-1]=i,On(l[0],c[0]).reshape(h)}}),Ll=An({irfft_:function(t){var e=t.shape[t.shape.length-1],n=t.size/e;if(e<=2){var r=t.as2D(n,e),o=Bl(r);return _n(o)}var a=[n,2*(e-1)],i=_n(t).as2D(n,e),s=Mn(t).as2D(n,e),u=i.slice([0,1],[n,e-2]).reverse(1),l=s.slice([0,1],[n,e-2]).reverse(1).mul(Bn(-1)),c=i.concat(u,1),h=s.concat(l,1);return r=On(c,h).as2D(a[0],a[1]),o=Bl(r),_n(o)}}),Wl=Object.freeze({fft:Fl,ifft:Bl,rfft:Pl,irfft:Ll});var Ul=An({sparseToDense_:function(t,e,n,r){void 0===r&&(r=0);var o=wn(t,"sparseIndices","sparseToDense","int32"),a=wn(e,"sparseValues","sparseToDense"),i=wn(r,"defaultValue","sparseToDense",a.dtype);return function(t,e,n,r){if("int32"!==t.dtype)throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was "+t.dtype+".");if(t.rank>2)throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape "+t.shape+".");var o=t.rank>0?t.shape[0]:1,a=t.rank>1?t.shape[1]:1;if(n.length!==a)throw new Error("outputShape has incorrect number of elements:, "+n.length+", should be: "+a+".");var i=e.size;if(0!==e.rank&&(1!==e.rank||i!==o))throw new Error("sparseValues has incorrect shape "+e.shape+", should be [] or ["+o+"]");if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(o,a,n,i),Dt.runKernel(function(t){return t.sparseToDense(o,a,n,i)},{$sparseIndices:o,$sparseValues:a,$defaultValue:i})}});var zl=An({gatherND_:function(t,e){var n=wn(e,"indices","gatherND","int32"),r=wn(t,"x","gatherND");return Dt.runKernel(function(t){return t.gatherND(r,n)},{$x:r,$indices:n})}});var Vl=An({dropout_:function(t,e,n,r){if(null!=n&&!x(t.shape,n))throw new Error("Non-default noise shape is not implemented yet: "+JSON.stringify(n));var o=qr(t.shape,0,1,"float32",r).greater(e);return o=o.div(ll(1,e)),t.mul(o)}});function Gl(t,e,n){for(var r=1-t%2,o=new Float32Array(t),a=0;a<t;++a){var i=2*Math.PI*a/(t+r-1);o[a]=e-n*Math.cos(i)}return Pn(o,"float32")}var ql,Hl=An({hannWindow_:function(t){return Gl(t,.5,.5)}}),$l=An({hammingWindow_:function(t){return Gl(t,.54,.46)}});!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(ql||(ql={}));var jl=An({absoluteDifference_:function(t,e,n,r){void 0===r&&(r=ql.SUM_BY_NONZERO_WEIGHTS);var o=wn(t,"labels","absoluteDifference"),a=wn(e,"predictions","absoluteDifference"),i=null;null!=n&&(i=wn(n,"weights","absoluteDifference")),v(o.shape,a.shape,"Error in absoluteDifference: ");var s=o.sub(a).abs();return Kl(s,i,r)}}),Kl=An({computeWeightedLoss_:function(t,e,n){void 0===n&&(n=ql.SUM_BY_NONZERO_WEIGHTS);var r=wn(t,"losses","computeWeightedLoss"),o=null;null!=e&&(o=wn(e,"weights","computeWeightedLoss"));var a=null==o?r:r.mul(o);if(n===ql.NONE)return a;if(n===ql.SUM)return a.sum();if(n===ql.MEAN){if(null==o)return a.mean();var i=r.size/o.size,s=a.sum().div(o.sum());return i>1?s.div(Bn(i)):s}if(n===ql.SUM_BY_NONZERO_WEIGHTS){if(null==o)return a.sum().div(Bn(r.size));var u=o.mul(Gn(r.shape)).notEqual(Bn(0)).sum().toFloat();return a.sum().div(u)}throw Error("Unknown reduction: "+n)}}),Xl=An({cosineDistance_:function(t,e,n,r,o){void 0===o&&(o=ql.SUM_BY_NONZERO_WEIGHTS);var a=wn(t,"labels","cosineDistance"),i=wn(e,"predictions","cosineDistance"),s=null;null!=r&&(s=wn(r,"weights","cosineDistance")),v(a.shape,i.shape,"Error in cosineDistance: ");var u=Bn(1).sub(a.mul(i).sum(n,!0));return Kl(u,s,o)}}),Yl=An({hingeLoss_:function(t,e,n,r){void 0===r&&(r=ql.SUM_BY_NONZERO_WEIGHTS);var o=wn(t,"labels","hingeLoss"),a=wn(e,"predictions","hingeLoss"),i=null;null!=n&&(i=wn(n,"weights","hingeLoss")),v(o.shape,a.shape,"Error in hingeLoss: ");var s=Bn(1);o=Bn(2).mul(o).sub(s);var u=s.sub(o.mul(a)).relu();return Kl(u,i,r)}}),Ql=An({huberLoss_:function(t,e,n,r,o){void 0===r&&(r=1),void 0===o&&(o=ql.SUM_BY_NONZERO_WEIGHTS);var a=wn(t,"labels","huberLoss"),i=wn(e,"predictions","huberLoss"),s=null;null!=n&&(s=wn(n,"weights","huberLoss")),v(a.shape,i.shape,"Error in huberLoss: ");var u=Bn(r),l=i.sub(a).abs(),c=Zu(l,u),h=l.sub(c),p=Bn(.5).mul(c.square()).add(u.mul(h));return Kl(p,s,o)}}),Jl=An({logLoss_:function(t,e,n,r,o){void 0===r&&(r=1e-7),void 0===o&&(o=ql.SUM_BY_NONZERO_WEIGHTS);var a=wn(t,"labels","logLoss"),i=wn(e,"predictions","logLoss"),s=null;null!=n&&(s=wn(n,"weights","logLoss")),v(a.shape,i.shape,"Error in logLoss: ");var u=Bn(1),l=Bn(r),c=a.mul(i.add(l).log()).neg().sub(u.sub(a).mul(u.sub(i).add(l).log()));return Kl(c,s,o)}}),Zl=An({meanSquaredError_:function(t,e,n,r){void 0===r&&(r=ql.SUM_BY_NONZERO_WEIGHTS);var o=wn(t,"labels","meanSquaredError"),a=wn(e,"predictions","meanSquaredError"),i=null;null!=n&&(i=wn(n,"weights","meanSquaredError")),v(o.shape,a.shape,"Error in meanSquaredError: ");var s=o.squaredDifference(a);return Kl(s,i,r)}}),tc=An({sigmoidCrossEntropy_:function(t,e,n,r,o){void 0===r&&(r=0),void 0===o&&(o=ql.SUM_BY_NONZERO_WEIGHTS);var a=wn(t,"multiClassLabels","sigmoidCrossEntropy"),i=wn(e,"logits","sigmoidCrossEntropy"),s=null;if(null!=n&&(s=wn(n,"weights","sigmoidCrossEntropy")),v(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){var u=Bn(r),l=Bn(1),c=Bn(.5);a=a.mul(l.sub(u)).add(c.mul(u))}var h=function(t,e){var n=wn(t,"labels","sigmoidCrossEntropyWithLogits"),r=wn(e,"logits","sigmoidCrossEntropyWithLogits");v(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");var o=r.relu(),a=r.mul(n),i=r.abs().neg().exp().log1p();return o.sub(a).add(i)}(a,i);return Kl(h,s,o)}}),ec=An({softmaxCrossEntropy_:function(t,e,n,r,o){void 0===r&&(r=0),void 0===o&&(o=ql.SUM_BY_NONZERO_WEIGHTS);var a=wn(t,"onehotLabels","softmaxCrossEntropy"),i=wn(e,"logits","softmaxCrossEntropy"),s=null;if(null!=n&&(s=wn(n,"weights","softmaxCrossEntropy")),v(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){var u=Bn(r),l=Bn(1),c=Bn(a.shape[1]);a=a.mul(l.sub(u)).add(u.div(c))}var h=function(t,e,n){if(void 0===n&&(n=-1),-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank "+e.rank+" and dim was "+n);return kn(function(t,e,r){var o=e.logSumExp([n],!0),a=e.toFloat().sub(o);return r([t,a]),{value:a.mul(t).neg().sum([n]),gradFunc:function(t,e){var r=e[0],o=e[1],a=en(t.shape,[n]);return[t.reshape(a).mul(r.toFloat().sub(o.exp())),t.reshape(a).mul(o.exp().sub(r.toFloat()))]}}})(t,e)}(a,i);return Kl(h,s,o)}}),nc=Object.freeze({get Reduction(){return ql},absoluteDifference:jl,computeWeightedLoss:Kl,cosineDistance:Xl,hingeLoss:Yl,huberLoss:Ql,logLoss:Jl,meanSquaredError:Zl,sigmoidCrossEntropy:tc,softmaxCrossEntropy:ec});function rc(t,e){return void 0===e&&(e=!1),Dt.tidy(function(){if(2!==t.shape.length)throw new Error("qr2d() requires a 2D Tensor, but got a "+t.shape.length+"D Tensor.");for(var n=t.shape[0],r=t.shape[1],o=Mr(n),a=t.clone(),i=Ln([[1]],[1,1]),s=i.clone(),u=n>=r?r:n,l=function(t){var e,u=a,l=s,c=o;e=Dt.tidy(function(){var e=a.slice([t,t],[n-t,1]),u=e.norm(),l=a.slice([t,t],[1,1]),c=l.sign().neg(),h=l.sub(c.mul(u)),p=e.div(h);s=1===p.shape[0]?i.clone():i.concat(p.slice([1,0],[p.shape[0]-1,p.shape[1]]),0);var f=c.matMul(h).div(u).neg(),d=a.slice([t,0],[n-t,r]),v=f.mul(s);a=0===t?d.sub(v.matMul(s.transpose().matMul(d))):a.slice([0,0],[t,r]).concat(d.sub(v.matMul(s.transpose().matMul(d))),0);var m=o.slice([0,t],[n,o.shape[1]-t]);return o=0===t?m.sub(m.matMul(s).matMul(v.transpose())):o.slice([0,0],[n,t]).concat(m.sub(m.matMul(s).matMul(v.transpose())),1),[s,a,o]}),s=e[0],a=e[1],o=e[2],Be([u,l,c])},c=0;c<u;++c)l(c);return!e&&n>r&&(o=o.slice([0,0],[n,r]),a=a.slice([0,0],[r,r])),[o,a]})}var oc=An({gramSchmidt_:function(t){var e;if(Array.isArray(t)){e=!1,d(null!=t&&t.length>0,function(){return"Gram-Schmidt process: input must not be null, undefined, or empty"});for(var n=t[0].shape[0],r=function(e){d(t[e].shape[0]===n,function(){return"Gram-Schmidt: Non-unique lengths found in the input vectors: ("+t[e].shape[0]+" vs. "+n+")"})},o=1;o<t.length;++o)r(o)}else e=!0,t=dr(t,t.shape[0],0).map(function(t){return jr(t,[0])});d(t.length<=t[0].shape[0],function(){return"Gram-Schmidt: Number of vectors ("+t.length+") exceeds number of dimensions ("+t[0].shape[0]+")."});var a=[],i=t,s=function(t){a.push(Dt.tidy(function(){var e=i[t];if(t>0)for(var n=0;n<t;++n){var r=Tu(a[n].mulStrict(e)).mul(a[n]);e=e.sub(r)}return e.div(Rl(e,"euclidean"))}))};for(o=0;o<t.length;++o)s(o);return e?Kr(a,0):a}}),ac=An({qr_:function(t,e){if(void 0===e&&(e=!1),t.rank<2)throw new Error("qr() requires input tensor to have a rank >= 2, but got rank "+t.rank);if(2===t.rank)return rc(t,e);var n=t.shape.slice(0,t.shape.length-2).reduce(function(t,e){return t*e}),r=Qr(t.reshape([n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),o=[],a=[];return r.forEach(function(t){var n=rc(t,e),r=n[0],i=n[1];o.push(r),a.push(i)}),[Kr(o,0).reshape(t.shape),Kr(a,0).reshape(t.shape)]}}),ic=Object.freeze({gramSchmidt:oc,qr:ac});function sc(t,e,n,r,o){null==r&&(r=.5),null==o&&(o=Number.NEGATIVE_INFINITY);var a=t.shape[0];return n=Math.min(n,a),d(0<=r&&r<=1,function(){return"iouThreshold must be in [0, 1], but was '"+r+"'"}),d(2===t.rank,function(){return"boxes must be a 2D tensor, but was of rank '"+t.rank+"'"}),d(4===t.shape[1],function(){return"boxes must have 4 columns, but 2nd dimension was "+t.shape[1]}),d(1===e.rank,function(){return"scores must be a 1D tensor"}),d(e.shape[0]===a,function(){return"scores has incompatible shape with boxes. Expected "+a+", but was "+e.shape[0]}),{maxOutputSize:n,iouThreshold:r,scoreThreshold:o}}var uc=An({resizeBilinear_:function(t,e,n){void 0===n&&(n=!1);var r=wn(t,"images","resizeBilinear");d(3===r.rank||4===r.rank,function(){return"Error in resizeBilinear: x must be rank 3 or 4, but got rank "+r.rank+"."}),d(2===e.length,function(){return"Error in resizeBilinear: new shape must 2D, but got shape "+e+"."});var o=r,a=!1;3===r.rank&&(a=!0,o=r.as4D(1,r.shape[0],r.shape[1],r.shape[2]));var i=e[0],s=e[1],u=Dt.runKernel(function(t,e){return e([o]),t.resizeBilinear(o,i,s,n)},{batchImages:o},function(t,e){return{batchImages:function(){return Dt.runKernel(function(r){return r.resizeBilinearBackprop(t,e[0],n)},{})}}});return a?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}}),lc=An({resizeNearestNeighbor_:function(t,e,n){void 0===n&&(n=!1);var r=wn(t,"images","resizeNearestNeighbor");d(3===r.rank||4===r.rank,function(){return"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank "+r.rank+"."}),d(2===e.length,function(){return"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+e+"."}),d("float32"===r.dtype||"int32"===r.dtype,function(){return"`images` must have `int32` or `float32` as dtype"});var o=r,a=!1;3===r.rank&&(a=!0,o=r.as4D(1,r.shape[0],r.shape[1],r.shape[2]));var i=e[0],s=e[1],u=Dt.runKernel(function(t,e){return e([o]),t.resizeNearestNeighbor(o,i,s,n)},{batchImages:o},function(t,e){return{batchImages:function(){return Dt.runKernel(function(r){return r.resizeNearestNeighborBackprop(t,e[0],n)},{})}}});return a?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}}),cc=An({nonMaxSuppression_:function(t,e,n,r,o){void 0===r&&(r=.5),void 0===o&&(o=Number.NEGATIVE_INFINITY);var a=wn(t,"boxes","nonMaxSuppression"),i=wn(e,"scores","nonMaxSuppression"),s=sc(a,i,n,r,o);return n=s.maxOutputSize,r=s.iouThreshold,o=s.scoreThreshold,Dt.runKernel(function(t){return t.nonMaxSuppression(a,i,n,r,o)},{$boxes:a})}}),hc=function(t,e,n,a,i){return void 0===a&&(a=.5),void 0===i&&(i=Number.NEGATIVE_INFINITY),r(this,void 0,void 0,function(){var r,s,u,l,c,h;return o(this,function(o){switch(o.label){case 0:return r=wn(t,"boxes","nonMaxSuppressionAsync"),s=wn(e,"scores","nonMaxSuppressionAsync"),u=sc(r,s,n,a,i),n=u.maxOutputSize,a=u.iouThreshold,i=u.scoreThreshold,[4,r.data()];case 1:return l=o.sent(),[4,s.data()];case 2:return c=o.sent(),h=ar(l,c,n,a,i),r!==t&&r.dispose(),s!==e&&s.dispose(),[2,h]}})})},pc=An({cropAndResize_:function(t,e,n,r,o,a){var i=wn(t,"image","cropAndResize","float32"),s=wn(e,"boxes","cropAndResize","float32"),u=wn(n,"boxInd","cropAndResize","int32");o=o||"bilinear",a=a||0;var l=s.shape[0];return d(4===i.rank,function(){return"Error in cropAndResize: image must be rank 4,but got rank "+i.rank+"."}),d(2===s.rank&&4===s.shape[1],function(){return"Error in cropAndResize: boxes must be have size ["+l+",4] but had shape "+s.shape+"."}),d(1===u.rank&&u.shape[0]===l,function(){return"Error in cropAndResize: boxInd must be have size ["+l+"] but had shape "+s.shape+"."}),d(2===r.length,function(){return"Error in cropAndResize: cropSize must be of length 2, but got length "+r.length+"."}),d(r[0]>=1&&r[1]>=1,function(){return"cropSize must be atleast [1,1], but was "+r}),d("bilinear"===o||"nearest"===o,function(){return"method must be bilinear or nearest, but was "+o}),Dt.runKernel(function(t,e){return t.cropAndResize(i,s,u,r,o,a)},{$image:i,$boxes:s})}}),fc=Object.freeze({resizeBilinear:uc,resizeNearestNeighbor:lc,nonMaxSuppression:cc,nonMaxSuppressionAsync:hc,cropAndResize:pc});var dc=An({matMul_:function(t,e,n,r,o,a){var i;void 0===n&&(n=!1),void 0===r&&(r=!1),void 0===a&&(a="linear");var s=wn(t,"a","fused matMul"),u=wn(e,"b","fused matMul");i=Rt(s,u),s=i[0],u=i[1];var l=n?s.shape[s.rank-2]:s.shape[s.rank-1],c=r?u.shape[u.rank-1]:u.shape[u.rank-2],h=n?s.shape[s.rank-1]:s.shape[s.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=s.shape.slice(0,-2),v=u.shape.slice(0,-2),m=y(f),g=y(v);d(s.rank>=2&&u.rank>=2&&s.rank===u.rank,function(){return"Error in fused matMul: inputs must have the same rank of at least 2, got ranks "+s.rank+" and "+u.rank+"."}),d(x(f,v),function(){return"Error in fused matMul: outer dimensions ("+f+") and ("+v+") of Tensors with shapes "+s.shape+" and "+u.shape+" must match."}),d(l===c,function(){return"Error in fused matMul: inner shapes ("+l+") and ("+c+") of Tensors with shapes "+s.shape+" and "+u.shape+" and transposeA="+n+" and transposeB="+r+" must match."});var w,b=s.shape.slice(0,-2).concat([h,p]),C=n?s.as3D(m,l,h):s.as3D(m,h,l),E=r?u.as3D(g,p,c):u.as3D(g,c,p);null!=o&&so(b,(w=Rt(w=wn(o,"bias","fused matMul"),s)[0]).shape);var R={$a:C,$b:E};return null!=o&&(R.$bias=w),Dt.runKernel(function(t,e){var o=t.fusedBatchMatMul(C,E,n,r,w,a);return e([C,E,o]),o},R,function(t,e){var i,s=e[0],u=e[1],l=e[2];if(null==a||"linear"===a)i=t;else{if("relu"!==a)throw new Error("Gradient for activation "+a+" has not been implemented yet.");i=t.mul(l.step())}var c={};return null!=o&&(c={$bias:function(){var t=i,e=io(w.shape,i.shape);return e.length>0&&(t=t.sum(e)),t.reshape(w.shape)}}),n||r?!n&&r?Object.assign({$a:function(){return i.matMul(u,!1,!1)},$b:function(){return i.matMul(s,!0,!1)}},c):n&&!r?Object.assign({$a:function(){return u.matMul(i,!1,!0)},$b:function(){return s.matMul(i,!1,!1)}},c):Object.assign({$a:function(){return u.matMul(i,!0,!0)},$b:function(){return i.matMul(s,!0,!0)}},c):Object.assign({$a:function(){return i.matMul(u,!1,!0)},$b:function(){return s.matMul(i,!0,!1)}},c)}).reshape(b)}}),vc=Object.freeze({matMul:dc}),mc=Object.freeze({image:fc,linalg:ic,losses:nc,spectral:Wl,fused:vc,op:An,batchNormalization2d:As,batchNormalization3d:Ts,batchNormalization4d:Ds,batchNormalization:Os,batchNorm:_s,batchNorm2d:Ms,batchNorm3d:Fs,batchNorm4d:Bs,complex:On,real:_n,imag:Mn,concat:lr,concat1d:cr,concat2d:hr,concat3d:pr,concat4d:fr,split:dr,conv1d:Xs,conv2d:Ys,conv3d:Qs,conv2dDerFilter:Js,depthwiseConv2d:Zs,separableConv2d:tu,conv2dTranspose:eu,matMul:nu,dot:ru,outerProduct:ou,reverse:au,reverse1d:iu,reverse2d:su,reverse3d:uu,reverse4d:lu,maxPool:pu,avgPool:fu,pool:du,slice:vu,slice1d:mu,slice2d:gu,slice3d:yu,slice4d:xu,abs:Vi,acos:Gi,acosh:qi,asin:Hi,asinh:$i,atan:ji,atanh:Ki,ceil:Xi,clipByValue:Yi,cos:Qi,cosh:Ji,erf:Zi,exp:ts,expm1:es,floor:ns,log:rs,log1p:os,logSigmoid:as,neg:is,reciprocal:ss,round:us,rsqrt:ls,sigmoid:cs,sign:hs,isNaN:ps,isInf:fs,isFinite:ds,sin:vs,sinh:ms,softplus:gs,sqrt:ys,square:xs,step:ws,tan:bs,tanh:Cs,all:bu,any:Cu,argMax:Eu,argMin:Ru,logSumExp:Su,max:Nu,mean:ku,min:Iu,moments:Au,sum:Tu,prod:Du,equal:Ou,equalStrict:_u,greater:Mu,greaterEqual:Fu,greaterEqualStrict:Bu,greaterStrict:Pu,less:Lu,lessEqual:Wu,lessEqualStrict:Uu,lessStrict:zu,notEqual:Vu,notEqualStrict:Gu,add:qu,addN:Hu,addStrict:$u,atan2:ju,div:Ku,divStrict:Xu,floorDiv:Yu,maximum:Qu,maximumStrict:Ju,minimum:Zu,minimumStrict:tl,mod:el,modStrict:nl,mul:rl,mulStrict:ol,pow:al,powStrict:il,squaredDifference:sl,squaredDifferenceStrict:ul,sub:ll,subStrict:cl,elu:gl,leakyRelu:yl,prelu:xl,relu:wl,selu:bl,logicalAnd:hl,logicalNot:pl,logicalOr:fl,logicalXor:dl,where:vl,whereAsync:ml,buffer:Nr,print:kr,batchToSpaceND:Ir,cast:Ar,clone:Tr,cumsum:Dr,depthToSpace:Or,expandDims:_r,eye:Mr,multinomial:Fr,oneHot:Br,pad:Pr,pad1d:Lr,pad2d:Wr,pad3d:Ur,pad4d:zr,rand:Vr,randomNormal:Gr,randomUniform:qr,reshape:Hr,spaceToBatchND:$r,squeeze:jr,stack:Kr,tile:Xr,truncatedNormal:Yr,unstack:Qr,setdiff1dAsync:Jr,fill:Hn,linspace:$n,ones:Gn,range:jn,scalar:Bn,tensor:Fn,tensor1d:Pn,tensor2d:Ln,tensor3d:Wn,tensor4d:Un,tensor5d:zn,tensor6d:Vn,zeros:qn,onesLike:Kn,zerosLike:Xn,transpose:Cl,softmax:Tn,logSoftmax:Dn,localResponseNormalization:El,norm:Rl,gather:kl,unsortedSegmentSum:Il,basicLSTMCell:Al,multiRNNCell:Tl,movingAverage:Dl,stridedSlice:Ol,topk:_l,scatterND:Ml,fft:Fl,ifft:Bl,rfft:Pl,irfft:Ll,sparseToDense:Ul,gatherND:zl,dropout:Vl,hannWindow:Hl,hammingWindow:$l});var gc=function(){function t(){this.blockSize=48,this.firstUse=!0,a.get("IS_BROWSER")&&(this.fromPixels2DContext=document.createElement("canvas").getContext("2d")),this.data=new Yn(Dt)}return t.prototype.register=function(t,e,n){if(this.firstUse&&(this.firstUse=!1,a.get("IS_NODE")&&je("\n============================\nHi there . Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================\n")),this.data.has(t))throw new Error("Data buffer is already registered");this.data.set(t,{dtype:n})},t.prototype.write=function(t,e){if(null==e)throw new Error("MathBackendCPU.write(): values can not be null");this.data.get(t).values=e},t.prototype.fromPixels=function(t,e){if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");var n,r;if(a.get("IS_NODE")&&null==t.getContext)throw new Error("When running in node, pixels must be an HTMLCanvasElement like the one returned by the `canvas` npm package");if(null!=t.getContext)n=t.getContext("2d").getImageData(0,0,t.width,t.height).data;else if(t instanceof ImageData)n=t.data;else{if(!(t instanceof HTMLImageElement||t instanceof HTMLVideoElement))throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or ImageData, but was "+t.constructor.name);if(null==this.fromPixels2DContext)throw new Error("Can't read pixels from HTMLImageElement outside the browser.");this.fromPixels2DContext.canvas.width=t.width,this.fromPixels2DContext.canvas.height=t.height,this.fromPixels2DContext.drawImage(t,0,0,t.width,t.height),n=this.fromPixels2DContext.getImageData(0,0,t.width,t.height).data}if(4===e)r=new Int32Array(n);else{var o=t.width*t.height;r=new Int32Array(o*e);for(var i=0;i<o;i++)for(var s=0;s<e;++s)r[i*e+s]=n[4*i+s]}return Wn(r,[t.height,t.width,e],"int32")},t.prototype.read=function(t){return r(this,void 0,void 0,function(){return o(this,function(e){return[2,this.readSync(t)]})})},t.prototype.readSync=function(t){var e=this.data.get(t),n=e.dtype,r=e.complexTensors;return"complex64"===n?er(r.real.dataSync(),r.imag.dataSync()):this.data.get(t).values},t.prototype.disposeData=function(t){if(this.data.has(t)){var e=this.data.get(t).complexTensors;null!=e&&(e.real.dispose(),e.imag.dispose()),this.data.delete(t)}},t.prototype.time=function(t){return r(this,void 0,void 0,function(){var e;return o(this,function(n){return e=j(),t(),[2,{kernelMs:j()-e}]})})},t.prototype.memory=function(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}},t.prototype.complex=function(t,e){var n=ft.make(t.shape,{},"complex64");return this.data.get(n.dataId).complexTensors={real:Dt.keep(t.clone()),imag:Dt.keep(e.clone())},n},t.prototype.real=function(t){return this.data.get(t.dataId).complexTensors.real.clone()},t.prototype.imag=function(t){return this.data.get(t.dataId).complexTensors.imag.clone()},t.prototype.assertNotComplex=function(t,e){Array.isArray(t)||(t=[t]),t.forEach(function(t){null!=t&&d("complex64"!==t.dtype,function(){return e+" does not support complex64 tensors."})})},t.prototype.slice=function(t,e,n){if(this.assertNotComplex(t,"slice"),mn(t.shape,e,n)){var r=gn(e,t.strides),o=y(n);return Fn(t.dataSync().subarray(r,r+o),n,t.dtype)}for(var a=Nr(n,t.dtype),i=t.bufferSync(),s=0;s<a.size;++s){var u=a.indexToLoc(s).map(function(t,n){return t+e[n]});a.values[s]=i.get.apply(i,u)}return a.toTensor()},t.prototype.stridedSlice=function(t,e,n,r,o,a,i,s,u){this.assertNotComplex(t,"stridedSlice");var l=fn(t.shape,e,n,r,o,a,i,s,u),c=l[0],h=l[1],p=l[2],f=h.filter(function(t,e){return-1===p.indexOf(e)});if(f.some(function(t){return 0===t}))return Fn([],f);for(var d=Nr(h,t.dtype),v=t.bufferSync(),m=0;m<d.size;m++){for(var g=d.indexToLoc(m),y=new Array(g.length),x=0;x<y.length;x++)y[x]=g[x]*r[x]+c[x];d.set.apply(d,[v.get.apply(v,y)].concat(g))}return d.toTensor().reshape(f)},t.prototype.unstack=function(t,e){for(var n=t.shape[e],r=new Array(t.rank-1),o=0,a=0;a<t.rank;a++)a!==e&&(r[o++]=t.shape[a]);var i=new Array(t.rank).fill(0),s=t.shape.slice();s[e]=1;var u=new Array(n);for(a=0;a<u.length;a++)i[e]=a,u[a]=this.slice(t,i,s).reshape(r);return u},t.prototype.reverse=function(t,e){this.assertNotComplex(t,"reverse");for(var n=Nr(t.shape,t.dtype),r=t.bufferSync(),o=function(o){var a=n.indexToLoc(o),i=a.slice();e.forEach(function(e){return i[e]=t.shape[e]-1-i[e]}),n.set.apply(n,[r.get.apply(r,i)].concat(a))},a=0;a<n.size;a++)o(a);return n.toTensor()},t.prototype.concat=function(t,e){this.assertNotComplex(t,"concat");var n=t.map(function(t){var n=y(t.shape.slice(e));return t.as2D(-1,n)}),r=sn(n.map(function(t){return t.shape}),1),o=Nr(r,t[0].dtype).values;if(1===n[0].shape[0]){var a=0;n.forEach(function(t){o.set(t.dataSync(),a),a+=t.size})}else{var i=0;n.forEach(function(t){for(var e=t.dataSync(),n=0,a=0;a<t.shape[0];++a)for(var s=a*r[1]+i,u=0;u<t.shape[1];++u)o[s+u]=e[n++];i+=t.shape[1]})}var s=sn(t.map(function(t){return t.shape}),e);return Fn(o,s,t[0].dtype)},t.prototype.neg=function(t){return this.assertNotComplex(t,"neg"),this.multiply(Bn(-1),t)},t.prototype.add=function(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),function(t,e,n,r){return{real:t+n,imag:e+r}}):this.broadcastedBinaryOp(t,e,Ct(t.dtype,e.dtype),function(t,e){return t+e})},t.prototype.addN=function(t){this.assertNotComplex(t,"addN");for(var e=t.map(function(t){return t.dataSync()}),n=Nr(t[0].shape,t[0].dtype),r=n.values,o=0;o<t.length;o++)for(var a=e[o],i=0;i<r.length;i++)r[i]+=a[i];return n.toTensor()},t.prototype.subtract=function(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),function(t,e,n,r){return{real:t-n,imag:e-r}}):this.broadcastedBinaryOp(t,e,Ct(t.dtype,e.dtype),function(t,e){return t-e})},t.prototype.pow=function(t,e){return this.assertNotComplex([t,e],"pow"),this.broadcastedBinaryOp(t,e,t.dtype,function(t,e){return Math.pow(t,e)})},t.prototype.batchMatMul=function(t,e,n,r){this.assertNotComplex([t,e],"matMul");for(var o=n?t.shape[1]:t.shape[2],a=n?t.shape[2]:t.shape[1],i=r?e.shape[1]:e.shape[2],s=t.shape[0],u=t.dataSync(),l=e.dataSync(),c=n?[t.strides[0],1,t.strides[1]]:[t.strides[0],t.strides[1],1],h=c[0],p=c[1],f=c[2],d=r?[1,e.strides[1],e.strides[0]]:[e.strides[1],1,e.strides[0]],v=d[0],m=d[1],g=d[2],y=a*i,x=Nr([s,a,i],t.dtype),w=x.values,b=this.blockSize,C=0;C<s;C++)for(var E=0;E<a;E+=b)for(var R=0;R<i;R+=b)for(var S=0;S<o;S+=b)for(var N=Math.min(E+b,a),k=Math.min(R+b,i),I=Math.min(S+b,o),A=E;A<N;A++)for(var T=R;T<k;T++){for(var D=0,O=S;O<I;O++)D+=u[C*h+A*p+O*f]*l[O*v+T*m+C*g];w[C*y+(A*i+T)]+=D}return x.toTensor()},t.prototype.fusedBatchMatMul=function(t,e,n,r,o,a){var i=this.batchMatMul(t,e,n,r);return o&&(i=this.add(i,o)),a&&(i=function(t,e,n){if("linear"===e)return t.linear(n);if("relu"===e)return t.relu(n);throw new Error("Activation "+e+" has not been implemented for the CPU backend.")}(this,a,i)),i},t.prototype.multiply=function(t,e){return"complex64"===t.dtype||"complex64"===e.dtype?this.broadcastedBinaryComplexOp(t.cast("complex64"),e.cast("complex64"),function(t,e,n,r){return{real:t*n-e*r,imag:t*r+e*n}}):this.broadcastedBinaryOp(t,e,Ct(t.dtype,e.dtype),function(t,e){return t*e})},t.prototype.realDivide=function(t,e){this.assertNotComplex([t,e],"realDivide");return this.broadcastedBinaryOp(t,e,"float32",function(t,e){return t/e})},t.prototype.floorDiv=function(t,e){this.assertNotComplex([t,e],"floorDiv");return this.broadcastedBinaryOp(t,e,"int32",function(t,e){return Math.floor(t/e)})},t.prototype.sum=function(t,e){this.assertNotComplex(t,"sum"),nn("sum",e,t.rank);for(var n=tn(t.shape,e),r=n[0],o=n[1],a=qn(r,Ct(t.dtype,"int32")),i=y(o),s=a.dataSync(),u=t.dataSync(),l=0;l<s.length;++l){for(var c=l*i,h=0,p=0;p<i;++p)h+=u[c+p];s[l]=h}return a},t.prototype.prod=function(t,e){this.assertNotComplex(t,"sum");for(var n=tn(t.shape,e),r=n[0],o=n[1],a=qn(r,Ct(t.dtype,"int32")),i=y(o),s=a.dataSync(),u=t.dataSync(),l=0;l<s.length;++l){for(var c=l*i,h=1,p=0;p<i;++p)h*=u[c+p];s[l]=h}return a},t.prototype.unsortedSegmentSum=function(t,e,n){this.assertNotComplex(t,"unsortedSegmentSum");for(var r=[],o=t.rank-e.rank,a=0;a<o;++a)e=e.expandDims(a+1);for(a=0;a<n;++a){var i=Bn(a,"int32"),s=Ou(i,e).asType("float32").mul(t).sum(0);r.push(s)}return Kr(r)},t.prototype.argMin=function(t,e){this.assertNotComplex(t,"argMin");var n=[e];nn("argMin",n,t.rank);for(var r=tn(t.shape,n),o=r[0],a=r[1],i=qn(o,"int32"),s=y(a),u=i.dataSync(),l=t.dataSync(),c=0;c<u.length;++c){for(var h=c*s,p=l[h],f=0,d=0;d<s;++d){var v=l[h+d];v<p&&(p=v,f=d)}u[c]=f}return i},t.prototype.argMax=function(t,e){this.assertNotComplex(t,"argMax");var n=[e];nn("argMax",n,t.rank);for(var r=tn(t.shape,n),o=r[0],a=r[1],i=qn(o,"int32"),s=y(a),u=i.dataSync(),l=t.dataSync(),c=0;c<u.length;++c){for(var h=c*s,p=l[h],f=0,d=0;d<s;++d){var v=l[h+d];v>p&&(p=v,f=d)}u[c]=f}return i},t.prototype.cumsum=function(t,e,n,r){if(this.assertNotComplex(t,"cumsum"),e!==t.rank-1)throw new Error("backend.cumsum in CPU expects an inner-most axis="+(t.rank-1)+" but got axis="+e);for(var o=Ct(t.dtype,"int32"),a=qn(t.shape,o),i=a.dataSync(),s=t.dataSync(),u=t.shape[t.rank-1],l=r?function(t,e){return t+u-e-1}:function(t,e){return t+e},c=0;c<s.length;c+=u)for(var h=0;h<u;h++){var p=l(c,h);if(0===h)i[p]=n?0:s[p];else{var f=l(c,h-1);i[p]=n?s[f]+i[f]:s[p]+i[f]}}return a},t.prototype.equal=function(t,e){return this.assertNotComplex([t,e],"equal"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t===e?1:0})},t.prototype.notEqual=function(t,e){return this.assertNotComplex([t,e],"notEqual"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t!==e?1:0})},t.prototype.less=function(t,e){return this.assertNotComplex([t,e],"less"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t<e?1:0})},t.prototype.lessEqual=function(t,e){return this.assertNotComplex([t,e],"lessEqual"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t<=e?1:0})},t.prototype.greater=function(t,e){return this.assertNotComplex([t,e],"greater"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t>e?1:0})},t.prototype.greaterEqual=function(t,e){return this.assertNotComplex([t,e],"greaterEqual"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t>=e?1:0})},t.prototype.logicalNot=function(t){this.assertNotComplex(t,"logicalNot");for(var e=t.dataSync(),n=new Uint8Array(e.length),r=0;r<e.length;++r)n[r]=e[r]?0:1;return ft.make(t.shape,{values:n},"bool")},t.prototype.logicalAnd=function(t,e){return this.assertNotComplex([t,e],"logicalAnd"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t&&e})},t.prototype.logicalOr=function(t,e){return this.assertNotComplex([t,e],"logicalOr"),this.broadcastedBinaryOp(t,e,"bool",function(t,e){return t||e})},t.prototype.select=function(t,e,n){this.assertNotComplex([t,e,n],"select");for(var r=t.dataSync(),o=e.dataSync(),a=n.dataSync(),i=qn(e.shape,Ct(e.dtype,n.dtype)),s=i.dataSync(),u=0,l=0===t.rank||t.rank>1||1===e.rank?1:e.shape[1],c=0;c<r.length;c++)for(var h=0;h<l;h++)1===r[c]?s[u++]=o[c]:s[u++]=a[c];return i},t.prototype.where=function(t){this.assertNotComplex([t],"where");var e=t.dataSync();return Zr(t.shape,e)},t.prototype.topk=function(t,e,n){return this.assertNotComplex(t,"topk"),ur(t.dataSync(),t.shape,t.dtype,e)},t.prototype.min=function(t,e){this.assertNotComplex(t,"min"),nn("min",e,t.rank);for(var n=tn(t.shape,e),r=n[0],o=n[1],a=qn(r,t.dtype),i=y(o),s=a.dataSync(),u=t.dataSync(),l=0;l<s.length;++l){for(var c=l*i,h=u[c],p=0;p<i;++p){var f=u[c+p];f<h&&(h=f)}s[l]=h}return a},t.prototype.minimum=function(t,e){return this.assertNotComplex([t,e],"minimum"),this.broadcastedBinaryOp(t,e,t.dtype,function(t,e){return Math.min(t,e)})},t.prototype.mod=function(t,e){return this.assertNotComplex([t,e],"mod"),this.broadcastedBinaryOp(t,e,t.dtype,function(t,e){var n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e})},t.prototype.max=function(t,e){this.assertNotComplex(t,"max"),nn("max",e,t.rank);for(var n=tn(t.shape,e),r=n[0],o=n[1],a=qn(r,t.dtype),i=y(o),s=a.dataSync(),u=t.dataSync(),l=0;l<s.length;++l){for(var c=l*i,h=u[c],p=0;p<i;++p){var f=u[c+p];f>h&&(h=f)}s[l]=h}return a},t.prototype.maximum=function(t,e){return this.assertNotComplex([t,e],"maximum"),this.broadcastedBinaryOp(t,e,t.dtype,function(t,e){return Math.max(t,e)})},t.prototype.all=function(t,e){this.assertNotComplex(t,"all"),nn("all",e,t.rank);for(var n=tn(t.shape,e),r=n[0],o=n[1],a=qn(r,t.dtype),i=y(o),s=a.dataSync(),u=t.dataSync(),l=0;l<s.length;++l){for(var c=l*i,h=u[c],p=0;p<i;++p){var f=u[c+p];h=h&&f}s[l]=h}return a},t.prototype.any=function(t,e){this.assertNotComplex(t,"any"),nn("any",e,t.rank);for(var n=tn(t.shape,e),r=n[0],o=n[1],a=qn(r,t.dtype),i=y(o),s=a.dataSync(),u=t.dataSync(),l=0;l<s.length;++l){for(var c=l*i,h=u[c],p=0;p<i;++p){var f=u[c+p];h=h||f}s[l]=h}return a},t.prototype.squaredDifference=function(t,e){return this.assertNotComplex([t,e],"squaredDifference"),this.broadcastedBinaryOp(t,e,t.dtype,function(t,e){var n=t-e;return n*n})},t.prototype.ceil=function(t){this.assertNotComplex(t,"ceil");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=Math.ceil(e[r]);return ft.make(t.shape,{values:n})},t.prototype.floor=function(t){this.assertNotComplex(t,"floor");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=Math.floor(e[r]);return ft.make(t.shape,{values:n})},t.prototype.sign=function(t){this.assertNotComplex(t,"x");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r)e[r]<0?n[r]=-1:e[r]>0?n[r]=1:n[r]=0;return ft.make(t.shape,{values:n})},t.prototype.isNaN=function(t){this.assertNotComplex(t,"x");for(var e=t.dataSync(),n=new Uint8Array(e.length),r=0;r<e.length;++r)Number.isNaN(e[r])&&(n[r]=1);return ft.make(t.shape,{values:n},"bool")},t.prototype.isInf=function(t){this.assertNotComplex(t,"x");for(var e=t.dataSync(),n=new Uint8Array(e.length),r=0;r<e.length;++r)Math.abs(e[r])===1/0&&(n[r]=1);return ft.make(t.shape,{values:n},"bool")},t.prototype.isFinite=function(t){this.assertNotComplex(t,"x");for(var e=t.dataSync(),n=new Uint8Array(e.length),r=0;r<e.length;++r)Number.isFinite(e[r])&&(n[r]=1);return ft.make(t.shape,{values:n},"bool")},t.prototype.round=function(t){this.assertNotComplex(t,"round");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=Math.floor(e[r]);e[r]-o<.5?n[r]=Math.floor(e[r]):e[r]-o>.5?n[r]=Math.ceil(e[r]):n[r]=o%2==0?o:o+1}return ft.make(t.shape,{values:n})},t.prototype.exp=function(t){this.assertNotComplex(t,"exp");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=Math.exp(e[r]);return ft.make(t.shape,{values:n})},t.prototype.expm1=function(t){this.assertNotComplex(t,"expm1");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=Math.expm1(e[r]);return ft.make(t.shape,{values:n})},t.prototype.log=function(t){this.assertNotComplex(t,"log");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=Math.log(o)}return ft.make(t.shape,{values:n})},t.prototype.log1p=function(t){this.assertNotComplex(t,"log1p");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=Math.log1p(o)}return ft.make(t.shape,{values:n})},t.prototype.sqrt=function(t){this.assertNotComplex(t,"sqrt");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=Math.sqrt(o)}return ft.make(t.shape,{values:n})},t.prototype.rsqrt=function(t){this.assertNotComplex(t,"rsqrt");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=1/Math.sqrt(o)}return ft.make(t.shape,{values:n})},t.prototype.square=function(t){this.assertNotComplex(t,"square");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r){var o=e[r];n[r]=o*o}return ft.make(t.shape,{values:n})},t.prototype.reciprocal=function(t){this.assertNotComplex(t,"reciprocal");for(var e=t.dataSync(),n=new Float32Array(e.length),r=0;r<e.length;++r)n[r]=1/e[r];return ft.make(t.shape,{values:n})},t.prototype.linear=function(t){return t},t.prototype.relu=function(t){this.assertNotComplex(t,"relu");for(var e=qn(t.shape,t.dtype),n=e.dataSync(),r=t.dataSync(),o=0;o<r.length;++o)n[o]=Math.max(0,r[o]);return e},t.prototype.prelu=function(t,e){return this.assertNotComplex([t,e],"prelu"),this.broadcastedBinaryOp(t,e,t.dtype,function(t,e){return t<0?e*t:t})},t.prototype.elu=function(t){this.assertNotComplex(t,"elu");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r){var o=n[r];e[r]=o>=0?o:Math.exp(o)-1}return ft.make(t.shape,{values:e})},t.prototype.eluDer=function(t,e){this.assertNotComplex([t,e],"eluDer");for(var n=new Float32Array(e.size),r=e.dataSync(),o=t.dataSync(),a=0;a<r.length;++a){var i=r[a];n[a]=i>=1?o[a]:o[a]*(i+1)}return ft.make(e.shape,{values:n})},t.prototype.selu=function(t){this.assertNotComplex(t,"selu");for(var e=bi,n=Ci,r=new Float32Array(t.size),o=t.dataSync(),a=0;a<o.length;++a){var i=o[a];r[a]=i>=0?n*i:e*(Math.exp(i)-1)}return ft.make(t.shape,{values:r})},t.prototype.clip=function(t,e,n){this.assertNotComplex(t,"clip");for(var r=new Float32Array(t.size),o=t.dataSync(),a=0;a<o.length;++a){var i=o[a];r[a]=i>n?n:i<e?e:i}return ft.make(t.shape,{values:r})},t.prototype.abs=function(t){for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.abs(n[r]);return ft.make(t.shape,{values:e})},t.prototype.complexAbs=function(t){for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<t.size;++r){var o=n[2*r],a=n[2*r+1];e[r]=Math.hypot(o,a)}return ft.make(t.shape,{values:e})},t.prototype.int=function(t){this.assertNotComplex(t,"int");for(var e=new Int32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=n[r];return ft.make(t.shape,{values:e},"int32")},t.prototype.sigmoid=function(t){this.assertNotComplex(t,"sigmoid");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=1/(1+Math.exp(-n[r]));return ft.make(t.shape,{values:e})},t.prototype.softplus=function(t){this.assertNotComplex(t,"softplus");for(var e=Math.log(1.1920928955078125e-7)+2,n=new Float32Array(t.size),r=t.dataSync(),o=0;o<r.length;++o){var a=r[o]>-e,i=r[o]<e,s=Math.exp(r[o]),u=void 0;u=i?s:a?r[o]:Math.log(1+s),n[o]=u}return ft.make(t.shape,{values:n})},t.prototype.sin=function(t){this.assertNotComplex(t,"sin");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.sin(n[r]);return ft.make(t.shape,{values:e})},t.prototype.cos=function(t){this.assertNotComplex(t,"cos");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.cos(n[r]);return ft.make(t.shape,{values:e})},t.prototype.tan=function(t){this.assertNotComplex(t,"tan");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.tan(n[r]);return ft.make(t.shape,{values:e})},t.prototype.asin=function(t){this.assertNotComplex(t,"asin");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.asin(n[r]);return ft.make(t.shape,{values:e})},t.prototype.acos=function(t){this.assertNotComplex(t,"acos");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.acos(n[r]);return ft.make(t.shape,{values:e})},t.prototype.atan=function(t){this.assertNotComplex(t,"atan");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.atan(n[r]);return ft.make(t.shape,{values:e})},t.prototype.atan2=function(t,e){return this.assertNotComplex([t,e],"atan2"),this.broadcastedBinaryOp(t,e,t.dtype,function(t,e){return Math.atan2(t,e)})},t.prototype.sinh=function(t){this.assertNotComplex(t,"sinh");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.sinh(n[r]);return ft.make(t.shape,{values:e})},t.prototype.cosh=function(t){this.assertNotComplex(t,"cosh");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.cosh(n[r]);return ft.make(t.shape,{values:e})},t.prototype.tanh=function(t){this.assertNotComplex(t,"tanh");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=b(n[r]);return ft.make(t.shape,{values:e})},t.prototype.asinh=function(t){this.assertNotComplex(t,"asinh");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.asinh(n[r]);return ft.make(t.shape,{values:e})},t.prototype.acosh=function(t){this.assertNotComplex(t,"acosh");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.acosh(n[r]);return ft.make(t.shape,{values:e})},t.prototype.atanh=function(t){this.assertNotComplex(t,"atanh");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r)e[r]=Math.atanh(n[r]);return ft.make(t.shape,{values:e})},t.prototype.erf=function(t){this.assertNotComplex(t,"erf");for(var e=new Float32Array(t.size),n=t.dataSync(),r=0;r<n.length;++r){var o=n[r],a=1/(1+.3275911*o);e[r]=1-((((1.061405429*a-1.453152027)*a+1.421413741)*a-.284496736)*a+.254829592)*a*Math.exp(-o*o)}return ft.make(t.shape,{values:e})},t.prototype.step=function(t,e){void 0===e&&(e=0),this.assertNotComplex(t,"step");for(var n=new Float32Array(t.size),r=t.dataSync(),o=0;o<r.length;++o){var a=r[o];isNaN(a)?n[o]=NaN:n[o]=a>0?1:e}return ft.make(t.shape,{values:n})},t.prototype.conv2d=function(t,e,n){this.assertNotComplex([t,e],"conv2d");for(var r=n.filterHeight,o=n.filterWidth,a=n.dilationHeight,i=n.dilationWidth,s=n.padInfo.left,u=n.padInfo.top,l=Nr(n.outShape,t.dtype),c=t.dataSync(),h=e.dataSync(),p=l.values,f=0;f<n.batchSize;++f)for(var d=f*t.strides[0],v=f*l.strides[0],m=0;m<n.outHeight;++m)for(var g=v+m*l.strides[1],y=m*n.strideHeight-s,x=0;x<r;x++){var w=y+x*a;if(!(w<0||w>=n.inHeight))for(var b=x*e.strides[0],C=d+w*t.strides[1],E=0;E<n.outWidth;++E)for(var R=g+E*n.outChannels,S=E*n.strideWidth-u,N=0;N<o;N++){var k=S+N*i;if(!(k<0||k>=n.inWidth))for(var I=b+N*e.strides[1],A=C+k*n.inChannels,T=I,D=0;D<n.inChannels;++D){for(var O=c[A+D],_=0;_<n.outChannels;++_)p[R+_]+=O*h[T+_];T+=n.outChannels}}}return l.toTensor()},t.prototype.conv3d=function(t,e,n){for(var r=n.filterDepth,o=n.filterHeight,a=n.filterWidth,i=n.dilationDepth,s=n.dilationHeight,u=n.dilationWidth,l=n.padInfo.front,c=n.padInfo.left,h=n.padInfo.top,p=Nr(n.outShape,t.dtype),f=t.dataSync(),d=e.dataSync(),v=p.values,m=0;m<n.batchSize;++m)for(var g=m*t.strides[0],y=m*p.strides[0],x=0;x<n.outDepth;++x)for(var w=y+x*p.strides[1],b=x*n.strideDepth-l,C=0;C<r;C++){var E=b+C*i;if(!(E<0||E>=n.inDepth))for(var R=C*e.strides[0],S=g+E*t.strides[1],N=0;N<n.outHeight;++N)for(var k=w+N*p.strides[2],I=N*n.strideHeight-h,A=0;A<o;A++){var T=I+A*s;if(!(T<0||T>=n.inHeight))for(var D=R+A*e.strides[1],O=S+T*t.strides[2],_=0;_<n.outWidth;++_)for(var M=k+_*n.outChannels,F=_*n.strideWidth-c,B=0;B<a;B++){var P=F+B*u;if(!(P<0||P>=n.inWidth))for(var L=D+B*e.strides[2],W=O+P*n.inChannels,U=L,z=0;z<n.inChannels;++z){for(var V=f[W+z],G=0;G<n.outChannels;++G)v[M+G]+=V*d[U+G];U+=n.outChannels}}}}return p.toTensor()},t.prototype.conv2dDerInput=function(t,e,n){this.assertNotComplex([t,e],"conv2dDerInput");for(var r=Nr(n.inShape,"float32"),o=r.values,a=r.strides,i=a[0],s=a[1],u=a[2],l=t.dataSync(),c=t.strides,h=c[0],p=c[1],f=c[2],d=e.dataSync(),v=e.strides,m=v[0],g=v[1],y=v[2],x=n.batchSize,w=n.filterHeight,b=n.filterWidth,C=n.inChannels,E=n.inHeight,R=n.inWidth,S=n.outChannels,N=n.outHeight,k=n.outWidth,I=n.strideHeight,A=n.strideWidth,T=w-1-n.padInfo.top,D=b-1-n.padInfo.left,O=0;O<x;++O)for(var _=0;_<C;++_)for(var M=0;M<E;++M)for(var F=M-T,B=Math.max(0,Math.ceil(F/I)),P=Math.min(N,(w+F)/I),L=0;L<R;++L){for(var W=L-D,U=Math.max(0,Math.ceil(W/A)),z=Math.min(k,(b+W)/A),V=0,G=B;G<P;++G)for(var q=G*I-F,H=U;H<z;++H)for(var $=h*O+p*G+f*H,j=m*(w-1-q)+g*(b-1-(H*A-W))+y*_,K=0;K<S;++K){V+=l[$+K]*d[j+K]}o[i*O+s*M+u*L+_]=V}return r.toTensor()},t.prototype.conv3dDerInput=function(t,e,n){for(var r=Nr(n.inShape,"float32"),o=r.values,a=r.strides,i=a[0],s=a[1],u=a[2],l=a[3],c=t.dataSync(),h=t.strides,p=h[0],f=h[1],d=h[2],v=h[3],m=e.dataSync(),g=e.strides,y=g[0],x=g[1],w=g[2],b=g[3],C=n.batchSize,E=n.filterDepth,R=n.filterHeight,S=n.filterWidth,N=n.inChannels,k=n.inDepth,I=n.inHeight,A=n.inWidth,T=n.outChannels,D=n.outDepth,O=n.outHeight,_=n.outWidth,M=n.strideDepth,F=n.strideHeight,B=n.strideWidth,P=E-1-n.padInfo.front,L=R-1-n.padInfo.top,W=S-1-n.padInfo.left,U=0;U<C;++U)for(var z=0;z<N;++z)for(var V=0;V<k;++V)for(var G=V-P,q=Math.max(0,Math.ceil(G/M)),H=Math.min(D,(E+G)/M),$=0;$<I;++$)for(var j=$-L,K=Math.max(0,Math.ceil(j/F)),X=Math.min(O,(R+j)/F),Y=0;Y<A;++Y){for(var Q=Y-W,J=Math.max(0,Math.ceil(Q/B)),Z=Math.min(_,(S+Q)/B),tt=0,et=q;et<H;++et)for(var nt=et*M-G,rt=K;rt<X;++rt)for(var ot=rt*F-j,at=J;at<Z;++at)for(var it=p*U+f*et+d*rt+v*at,st=y*(E-1-nt)+x*(R-1-ot)+w*(S-1-(at*B-Q))+b*z,ut=0;ut<T;++ut){tt+=c[it+ut]*m[st+ut]}o[i*U+s*V+u*$+l*Y+z]=tt}return r.toTensor()},t.prototype.conv2dDerFilter=function(t,e,n){this.assertNotComplex([t,e],"conv2dDerFilter");for(var r=n.strideHeight,o=n.strideWidth,a=n.filterHeight,i=n.filterWidth,s=Nr(n.filterShape,"float32"),u=n.padInfo.left,l=n.padInfo.top,c=t.bufferSync(),h=e.bufferSync(),p=0;p<a;++p)for(var f=Math.max(0,Math.ceil((l-p)/r)),d=Math.min(n.outHeight,(n.inHeight+l-p)/r),v=0;v<i;++v)for(var m=Math.max(0,Math.ceil((u-v)/o)),g=Math.min(n.outWidth,(n.inWidth+u-v)/o),y=0;y<n.inChannels;++y)for(var x=0;x<n.outChannels;++x){for(var w=0,b=0;b<n.batchSize;++b)for(var C=f;C<d;++C)for(var E=p+C*r-l,R=m;R<g;++R){var S=v+R*o-u;w+=c.get(b,E,S,y)*h.get(b,C,R,x)}s.set(w,p,v,y,x)}return s.toTensor()},t.prototype.conv3dDerFilter=function(t,e,n){for(var r=n.strideDepth,o=n.strideHeight,a=n.strideWidth,i=n.filterDepth,s=n.filterHeight,u=n.filterWidth,l=Nr(n.filterShape,"float32"),c=l.values,h=l.strides,p=h[0],f=h[1],d=h[2],v=h[3],m=e.dataSync(),g=e.strides,y=g[0],x=g[1],w=g[2],b=g[3],C=t.dataSync(),E=t.strides,R=E[0],S=E[1],N=E[2],k=E[3],I=n.padInfo.front,A=n.padInfo.left,T=n.padInfo.top,D=0;D<i;++D)for(var O=Math.max(0,Math.ceil((I-D)/r)),_=Math.min(n.outDepth,(n.inDepth+I-D)/r),M=D*p,F=0;F<s;++F)for(var B=Math.max(0,Math.ceil((T-F)/o)),P=Math.min(n.outHeight,(n.inHeight+T-F)/o),L=F*f+M,W=0;W<u;++W)for(var U=Math.max(0,Math.ceil((A-W)/a)),z=Math.min(n.outWidth,(n.inWidth+A-W)/a),V=W*d+L,G=0;G<n.inChannels;++G)for(var q=G*v+V,H=0;H<n.outChannels;++H){for(var $=0,j=0;j<n.batchSize;++j)for(var K=j*R,X=j*y,Y=O;Y<_;++Y)for(var Q=(D+Y*r-I)*S+K,J=Y*x+X,Z=B;Z<P;++Z)for(var tt=(F+Z*o-T)*N+Q,et=Z*w+J,nt=U;nt<z;++nt){var rt=nt*b+et;$+=C[(W+nt*a-A)*k+tt+G]*m[rt+H]}c[q+H]=$}return l.toTensor()},t.prototype.depthwiseConv2D=function(t,e,n){this.assertNotComplex([t,e],"depthwiseConv2D");for(var r=n.filterHeight,o=n.filterWidth,a=n.dilationHeight,i=n.dilationWidth,s=n.padInfo.left,u=n.padInfo.top,l=n.outChannels/n.inChannels,c=Nr(n.outShape,t.dtype),h=t.dataSync(),p=e.dataSync(),f=c.values,d=0;d<n.batchSize;++d)for(var v=d*t.strides[0],m=d*c.strides[0],g=0;g<n.outHeight;++g)for(var y=m+g*c.strides[1],x=g*n.strideHeight-s,w=0;w<r;++w){var b=x+w*a;if(!(b<0||b>=n.inHeight))for(var C=w*e.strides[0],E=v+b*t.strides[1],R=0;R<n.outWidth;++R)for(var S=y+R*c.strides[2],N=R*n.strideWidth-u,k=0;k<o;++k){var I=N+k*i;if(!(I<0||I>=n.inWidth))for(var A=C+k*e.strides[1],T=E+I*n.inChannels,D=S,O=A,_=0;_<n.inChannels;++_){for(var M=h[T+_],F=0;F<l;++F)f[D+F]+=M*p[O+F];D+=l,O+=l}}}return c.toTensor()},t.prototype.depthwiseConv2DDerInput=function(t,e,n){this.assertNotComplex([t,e],"depthwiseConv2DDerInput");for(var r=Nr(n.inShape,"float32"),o=r.values,a=r.strides,i=a[0],s=a[1],u=a[2],l=t.dataSync(),c=t.strides,h=c[0],p=c[1],f=c[2],d=e.dataSync(),v=e.strides,m=v[0],g=v[1],y=v[2],x=n.batchSize,w=n.filterHeight,b=n.filterWidth,C=n.inChannels,E=n.inHeight,R=n.inWidth,S=n.outChannels,N=n.outHeight,k=n.outWidth,I=n.strideHeight,A=n.strideWidth,T=w-1-n.padInfo.top,D=b-1-n.padInfo.left,O=S/C,_=0;_<x;++_)for(var M=0;M<C;++M)for(var F=0;F<E;++F)for(var B=F-T,P=Math.max(0,Math.ceil(B/I)),L=Math.min(N,(w+B)/I),W=0;W<R;++W){for(var U=W-D,z=Math.max(0,Math.ceil(U/A)),V=Math.min(k,(b+U)/A),G=0,q=P;q<L;++q)for(var H=q*I-B,$=z;$<V;++$)for(var j=h*_+p*q+f*$,K=m*(w-1-H)+g*(b-1-($*A-U))+y*M,X=0;X<O;++X){G+=l[j+(M*O+X)]*d[K+X]}o[i*_+s*F+u*W+M]=G}return r.toTensor()},t.prototype.depthwiseConv2DDerFilter=function(t,e,n){this.assertNotComplex([t,e],"depthwiseConv2DDerFilter");for(var r=n.strideHeight,o=n.strideWidth,a=n.filterHeight,i=n.filterWidth,s=Nr(n.filterShape,"float32"),u=n.padInfo.left,l=n.padInfo.top,c=n.outChannels/n.inChannels,h=t.bufferSync(),p=e.bufferSync(),f=0;f<a;++f)for(var d=Math.max(0,Math.ceil((l-f)/r)),v=Math.min(n.outHeight,(n.inHeight+l-f)/r),m=0;m<i;++m)for(var g=Math.max(0,Math.ceil((u-m)/o)),y=Math.min(n.outWidth,(n.inWidth+u-m)/o),x=0;x<n.outChannels;++x){for(var w=Math.trunc(x/c),b=x%c,C=0,E=0;E<n.batchSize;++E)for(var R=d;R<v;++R)for(var S=f+R*r-l,N=g;N<y;++N){var k=m+N*o-u;C+=h.get(E,S,k,w)*p.get(E,R,N,x)}s.set(C,f,m,w,b)}return s.toTensor()},t.prototype.tile=function(t,e){this.assertNotComplex(t,"tile");for(var n=new Array(t.rank),r=0;r<n.length;r++)n[r]=t.shape[r]*e[r];var o=Nr(n,t.dtype),a=t.bufferSync();for(r=0;r<o.values.length;++r){for(var i=o.indexToLoc(r),s=new Array(t.rank),u=0;u<s.length;u++)s[u]=i[u]%t.shape[u];var l=a.locToIndex(s);o.values[r]=a.values[l]}return o.toTensor()},t.prototype.pad=function(t,e,n){this.assertNotComplex(t,"pad");var r=e.map(function(e,n){return e[0]+t.shape[n]+e[1]}),o=e.map(function(t){return t[0]}),a=t.bufferSync(),i=Nr(r,t.dtype);0!==n&&i.values.fill(n);for(var s=0;s<t.size;s++){var u=a.indexToLoc(s),l=u.map(function(t,e){return t+o[e]});i.set.apply(i,[a.get.apply(a,u)].concat(l))}return i.toTensor()},t.prototype.transpose=function(t,e){this.assertNotComplex(t,"transpose");for(var n=new Array(t.rank),r=0;r<n.length;r++)n[r]=t.shape[e[r]];var o=t.dataSync(),a=Nr(n,t.dtype),i=t.bufferSync();for(r=0;r<t.size;++r){for(var s=i.indexToLoc(r),u=new Array(s.length),l=0;l<u.length;l++)u[l]=s[e[l]];var c=a.locToIndex(u);a.values[c]=o[r]}return a.toTensor()},t.prototype.gather=function(t,e,n){this.assertNotComplex([t,e],"gather");var r=t.shape.slice(),o=e.dataSync();r[n]=o.length;for(var a=Nr(r,t.dtype),i=t.bufferSync(),s=0;s<a.size;++s){var u=a.indexToLoc(s),l=u.slice();l[n]=o[u[n]];var c=i.locToIndex(l);a.values[s]=i.values[c]}return a.toTensor()},t.prototype.batchToSpaceND=function(t,e,n){this.assertNotComplex([t],"batchToSpaceND");var r=e.reduce(function(t,e){return t*e}),o=Ke(t.shape,e,r),a=Xe(o.length,e.length),i=Ye(t.shape,e,r),s=Qe(n,e.length),u=Je(i,n,e.length);return t.reshape(o).transpose(a).reshape(i).slice(s,u)},t.prototype.spaceToBatchND=function(t,e,n){this.assertNotComplex([t],"spaceToBatchND");var r=e.reduce(function(t,e){return t*e}),o=[[0,0]];o.push.apply(o,n);for(var a=1+e.length;a<t.shape.length;++a)o.push([0,0]);var i=t.pad(o),s=Ke(i.shape,e,r,!1),u=Xe(s.length,e.length,!1),l=Ye(i.shape,e,r,!1);return i.reshape(s).transpose(u).reshape(l)},t.prototype.pool=function(t,e,n){this.assertNotComplex(t,"pool");for(var r=e.strideHeight,o=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,s=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=e.padInfo.top,c=e.padInfo.left,h="max"===n?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,p=t.dataSync(),f=Nr(e.outShape,t.dtype),d=f.values,v=e.outShape[1]*e.outShape[2]*e.outShape[3],m=e.outShape[2]*e.outShape[3],g=e.outShape[3],y=0;y<e.batchSize;++y)for(var x=y*v,w=y*t.strides[0],b=0;b<e.inChannels;++b)for(var C=0;C<e.outHeight;++C)for(var E=C*r-l,R=Math.max(0,E),S=Math.min(e.inHeight,s+E),N=x+C*m,k=0;k<e.outWidth;++k){for(var I=k*o-c,A=Math.max(0,I),T=Math.min(e.inWidth,u+I),D=h,O=0,_=0,M=R;M<S;M+=a){for(var F=w+M*t.strides[1],B=A;B<T;B+=i){var P=p[F+B*t.strides[2]+b];"max"===n&&P>D?D=P:"avg"===n&&(O+=P,_++)}if(isNaN(D))break}d[N+k*g+b]="avg"===n?O/_:D}return f.toTensor()},t.prototype.maxPool=function(t,e){return this.pool(t,e,"max")},t.prototype.maxPoolPositions=function(t,e){for(var n=Nr(e.outShape,"int32"),r=e.strideHeight,o=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,s=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=e.padInfo.top,c=e.padInfo.left,h=t.bufferSync(),p=0;p<e.batchSize;++p)for(var f=0;f<e.inChannels;++f)for(var d=0;d<e.outHeight;++d){for(var v=d*r-l,m=v;m<0;)m+=a;for(var g=Math.min(e.inHeight,s+v),y=0;y<e.outWidth;++y){for(var x=y*o-c,w=x;w<0;)w+=i;for(var b=Math.min(e.inWidth,u+x),C=Number.NEGATIVE_INFINITY,E=-1,R=m;R<g;R+=a)for(var S=R-v,N=w;N<b;N+=i){var k=N-x,I=h.get(p,R,N,f);I>C&&(C=I,E=S*u+k)}n.set(E,p,d,y,f)}}return n.toTensor()},t.prototype.maxPoolBackprop=function(t,e,n,r){this.assertNotComplex([e,n],"maxPoolBackprop");for(var o=this.maxPoolPositions(e,r),a=r.strideHeight,i=r.strideWidth,s=r.dilationHeight,u=r.dilationWidth,l=r.effectiveFilterHeight,c=r.effectiveFilterWidth,h=c-1-r.padInfo.left,p=l-1-r.padInfo.top,f=Nr(e.shape,"float32"),d=o.bufferSync(),v=t.bufferSync(),m=0;m<r.batchSize;++m)for(var g=0;g<r.inChannels;++g)for(var y=0;y<r.inHeight;++y)for(var x=0;x<r.inWidth;++x){for(var w=y-p,b=x-h,C=0,E=0;E<l;E+=s){var R=(w+E)/a;if(!(R<0||R>=r.outHeight||Math.floor(R)!==R))for(var S=0;S<c;S+=u){var N=(b+S)/i;if(!(N<0||N>=r.outWidth||Math.floor(N)!==N)){var k=l*c-1-d.get(m,R,N,g)===E*c+S?1:0;if(0!==k)C+=v.get(m,R,N,g)*k}}}f.set(C,m,y,x,g)}return f.toTensor()},t.prototype.avgPoolBackprop=function(t,e,n){this.assertNotComplex([t,e],"avgPoolBackprop");for(var r=n.strideHeight,o=n.strideWidth,a=n.filterHeight,i=n.filterWidth,s=n.dilationHeight,u=n.dilationWidth,l=n.effectiveFilterHeight,c=n.effectiveFilterWidth,h=c-1-n.padInfo.left,p=l-1-n.padInfo.top,f=Nr(e.shape,"float32"),d=1/(a*i),v=t.bufferSync(),m=0;m<n.batchSize;++m)for(var g=0;g<n.inChannels;++g)for(var y=0;y<n.inHeight;++y)for(var x=0;x<n.inWidth;++x){for(var w=y-p,b=x-h,C=0,E=0;E<l;E+=s){var R=(w+E)/r;if(!(R<0||R>=n.outHeight||Math.floor(R)!==R))for(var S=0;S<c;S+=u){var N=(b+S)/o;if(!(N<0||N>=n.outWidth||Math.floor(N)!==N))C+=v.get(m,R,N,g)}}f.set(C*d,m,y,x,g)}return f.toTensor()},t.prototype.cast=function(t,e){return Jn(t,e,this)},t.prototype.reshape=function(t,e){return Zn(t,e)},t.prototype.avgPool=function(t,e){return this.assertNotComplex(t,"avgPool"),this.pool(t,e,"avg").toFloat()},t.prototype.resizeBilinear=function(t,e,n,r){this.assertNotComplex(t,"resizeBilinear");for(var o=t.shape,a=o[0],i=o[1],s=o[2],u=o[3],l=t.dataSync(),c=new Float32Array(y([a,e,n,u])),h=[r&&e>1?i-1:i,r&&n>1?s-1:s],p=[r&&e>1?e-1:e,r&&n>1?n-1:n],f=0,d=h[0]/p[0],v=h[1]/p[1],m=0;m<a;m++)for(var g=0;g<e;g++)for(var x=d*g,w=Math.floor(x),b=x-w,C=Math.min(i-1,Math.ceil(x)),E=m*t.strides[0]+w*t.strides[1],R=m*t.strides[0]+C*t.strides[1],S=0;S<n;S++)for(var N=v*S,k=Math.floor(N),I=N-k,A=Math.min(s-1,Math.ceil(N)),T=E+k*t.strides[2],D=R+k*t.strides[2],O=E+ +A*t.strides[2],_=R+A*t.strides[2],M=0;M<u;M++){var F=l[T+M],B=l[D+M],P=F+(l[O+M]-F)*I,L=P+(B+(l[_+M]-B)*I-P)*b;c[f++]=L}return Fn(c,[a,e,n,u])},t.prototype.resizeBilinearBackprop=function(t,e,n){this.assertNotComplex([t,e],"resizeBilinearBackprop");for(var r=e.shape,o=r[0],a=r[1],i=r[2],s=r[3],u=t.shape,l=u[1],c=u[2],h=new Float32Array(o*a*i*s),p=[n&&l>1?a-1:a,n&&c>1?i-1:i],f=[n&&l>1?l-1:l,n&&c>1?c-1:c],d=p[0]/f[0],v=p[1]/f[1],m=t.dataSync(),g=0,y=0;y<o;y++)for(var x=y*e.strides[0],w=0;w<l;w++)for(var b=w*d,C=Math.floor(b),E=Math.min(Math.ceil(b),a-1),R=x+C*e.strides[1],S=x+E*e.strides[1],N=b-C,k=1-N,I=0;I<c;I++)for(var A=I*v,T=Math.floor(A),D=Math.min(Math.ceil(A),i-1),O=A-T,_=1-O,M=R+T*e.strides[2],F=R+D*e.strides[2],B=S+T*e.strides[2],P=S+D*e.strides[2],L=k*_,W=k*O,U=N*_,z=N*O,V=0;V<s;V++){var G=m[g++];h[M+V]+=G*L,h[F+V]+=G*W,h[B+V]+=G*U,h[P+V]+=G*z}return Un(h,[o,i,a,s],e.dtype)},t.prototype.resizeNearestNeighbor=function(t,e,n,r){this.assertNotComplex(t,"resizeNearestNeighbor");for(var o=t.shape,a=o[0],i=o[1],s=o[2],u=o[3],l=t.dataSync(),c=new Float32Array(a*e*n*u),h=[r&&e>1?i-1:i,r&&n>1?s-1:s],p=[r&&e>1?e-1:e,r&&n>1?n-1:n],f=h[0]/p[0],d=h[1]/p[1],v=0,m=0;m<a;m++)for(var g=m*t.strides[0],y=0;y<e;y++)for(var x=f*y,w=g+Math.min(i-1,r?Math.round(x):Math.floor(x))*t.strides[1],b=0;b<n;b++)for(var C=d*b,E=w+Math.min(s-1,r?Math.round(C):Math.floor(C))*t.strides[2],R=0;R<u;R++){var S=l[E+R];c[v++]=S}return Fn(c,[a,e,n,u],t.dtype)},t.prototype.resizeNearestNeighborBackprop=function(t,e,n){this.assertNotComplex([t,e],"resizeNearestNeighborBackprop");for(var r=e.shape,o=r[0],a=r[1],i=r[2],s=r[3],u=t.shape,l=u[1],c=u[2],h=new Float32Array(o*a*i*s),p=t.dataSync(),f=[n&&l>1?a-1:a,n&&c>1?i-1:i],d=[n&&l>1?l-1:l,n&&c>1?c-1:c],v=f[0]/d[0],m=f[1]/d[1],g=1/v,y=1/m,x=2*Math.ceil(g)+2,w=2*Math.ceil(y)+2,b=0;b<o;b++)for(var C=b*e.strides[0],E=0;E<a;E++)for(var R=C+E*e.strides[1],S=Math.floor(E*g),N=Math.floor(S-x/2),k=0;k<i;k++)for(var I=R+k*e.strides[2],A=Math.floor(k*y),T=Math.floor(A-w/2),D=0;D<s;D++){for(var O=0,_=0;_<x;_++){var M=_+N;if(!(M<0||M>=l)){var F=C+M*t.strides[1],B=M*v;if(E===Math.min(a-1,n?Math.round(B):Math.floor(B)))for(var P=0;P<w;P++){var L=P+T;if(!(L<0||L>=c)){var W=F+L*t.strides[2],U=L*m;k===Math.min(i-1,n?Math.round(U):Math.floor(U))&&(O+=p[W+D])}}}}h[I+D]=O}return Un(h,e.shape,e.dtype)},t.prototype.batchNormalization=function(t,e,n,r,o,a){this.assertNotComplex([t,e,n,o,a],"batchNorm");for(var i=t.dataSync(),s=e.dataSync(),u=n.dataSync(),l=o?o.dataSync():new Float32Array([1]),c=a?a.dataSync():new Float32Array([0]),h=new Float32Array(i.length),p=c.length,f=l.length,d=u.length,v=s.length,m=0,g=0,y=0,x=0,w=0;w<i.length;++w)h[w]=c[m++]+(i[w]-s[g++])*l[y++]/Math.sqrt(u[x++]+r),m>=p&&(m=0),g>=v&&(g=0),y>=f&&(y=0),x>=d&&(x=0);return Un(h,t.shape)},t.prototype.localResponseNormalization4D=function(t,e,n,r,o){this.assertNotComplex(t,"localResponseNormalization4D");var a=t.shape[3],i=a-1,s=t.dataSync(),u=t.size,l=new Float32Array(u);function c(t){for(var n=t%a,r=t-n+Math.max(0,n-e),o=t-n+Math.min(n+e,i),u=0;r<=o;r++){var l=s[r];u+=l*l}return u}for(var h=0;h<u;h++){var p=c(h),f=s[h]*Math.pow(n+r*p,-o);l[h]=f}return Un(l,t.shape)},t.prototype.LRNGrad=function(t,e,n,r,o,a,i){this.assertNotComplex(t,"LRNGrad");for(var s=t.shape[3],u=t.dataSync(),l=e.dataSync(),c=n.dataSync(),h=new Float32Array(t.size),p=t.size,f=0;f<p;f++){for(var d=f%s,v=f-d+Math.max(0,d-r),m=f-d+Math.min(s,d+r+1),g=0,y=v;y<m;y++)g+=Math.pow(l[y],2);g=a*g+o;for(y=v;y<m;y++){var x=-2*a*i*l[y]*c[f]/g;f===y&&(x+=Math.pow(g,-i)),x*=u[f],h[y]+=x}}return Un(h,t.shape)},t.prototype.multinomial=function(t,e,n,r){this.assertNotComplex(t,"multinomial");for(var o=e?t:Tn(t),a=o.shape[0],i=o.shape[1],s=qn([a,n],"int32"),u=s.dataSync(),l=o.dataSync(),c=0;c<a;++c){var h=c*i,p=new Float32Array(i-1);p[0]=l[h];for(var f=1;f<p.length;++f)p[f]=p[f-1]+l[h+f];for(var d=Er(r.toString()),v=c*n,m=0;m<n;++m){var g=d();u[v+m]=p.length;for(var y=0;y<p.length;y++)if(g<p[y]){u[v+m]=y;break}}}return s},t.prototype.oneHot=function(t,e,n,r){this.assertNotComplex(t,"oneHot");var o=new Float32Array(t.size*e);o.fill(r);for(var a=t.dataSync(),i=0;i<t.size;++i)a[i]>=0&&a[i]<e&&(o[i*e+a[i]]=n);return Ln(o,[t.size,e],"int32")},t.prototype.nonMaxSuppression=function(t,e,n,r,o){return this.assertNotComplex(t,"nonMaxSuppression"),ar(t.dataSync(),e.dataSync(),n,r,o)},t.prototype.fft=function(t){return this.fftBatch(t,!1)},t.prototype.ifft=function(t){return this.fftBatch(t,!0)},t.prototype.fftBatch=function(t,e){for(var n=t.shape[0],r=t.shape[1],o=Nr(t.shape,"float32"),a=Nr(t.shape,"float32"),i=_n(t).as2D(n,r),s=Mn(t).as2D(n,r),u=0;u<n;u++)for(var l=i.slice([u,0],[1,r]),c=s.slice([u,0],[1,r]),h=On(l,c),p=this.fftImpl(h,e).dataSync(),f=0;f<r;f++){var d=nr(p,f);o.values[u*r+f]=d.real,a.values[u*r+f]=d.imag}return On(o.toTensor(),a.toTensor()).as2D(n,r)},t.prototype.fftImpl=function(t,e){var n=t.as1D(),r=n.size;if(this.isExponentOf2(r)){var o=this.fftRadix2(n,r,e).as2D(t.shape[0],t.shape[1]);return e&&(o=On(_n(o).div(Bn(r)),Mn(o).div(Bn(r)))),o}var a=t.dataSync(),i=function(t){for(var e=new Float32Array(t.length/2),n=new Float32Array(t.length/2),r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}(this.fourierTransformByMatmul(a,r,e));return On(i.real,i.imag).as2D(t.shape[0],t.shape[1])},t.prototype.isExponentOf2=function(t){return 0==(t&t-1)},t.prototype.fftRadix2=function(t,e,n){if(1===e)return t;var r=t.dataSync(),o=e/2,a=function(t){for(var e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e),o=0;o<t.length;o+=4)n[Math.floor(o/4)]=t[o],r[Math.floor(o/4)]=t[o+1];return{real:n,imag:r}}(r),i=On(a.real,a.imag).as1D(),s=function(t){for(var e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e),o=2;o<t.length;o+=4)n[Math.floor(o/4)]=t[o],r[Math.floor(o/4)]=t[o+1];return{real:n,imag:r}}(r),u=On(s.real,s.imag).as1D();i=this.fftRadix2(i,o,n),u=this.fftRadix2(u,o,n);var l=function(t,e){for(var n=new Float32Array(t/2),r=new Float32Array(t/2),o=0;o<Math.ceil(t/2);o++){var a=(e?2:-2)*Math.PI*(o/t);n[o]=Math.cos(a),r[o]=Math.sin(a)}return{real:n,imag:r}}(e,n),c=On(l.real,l.imag).mul(u),h=i.add(c),p=i.sub(c),f=_n(h).concat(_n(p)),d=Mn(h).concat(Mn(p));return On(f,d).as1D()},t.prototype.fourierTransformByMatmul=function(t,e,n){for(var r=new Float32Array(2*e),o=0;o<e;o++){for(var a=0,i=0,s=0;s<e;s++){var u=or(o*s,e,n),l=nr(t,s);a+=l.real*u.real-l.imag*u.imag,i+=l.real*u.imag+l.imag*u.real}n&&(a/=e,i/=e),rr(r,a,i,o)}return r},t.prototype.depthToSpace=function(t,e,n){d("NHWC"===n,function(){return"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+n}),d(e>1,function(){return"blockSize should be > 1 for depthToSpace, but was: "+e});for(var r=t.shape[0],o=t.shape[1],a=t.shape[2],i=t.shape[3],s=o*e,u=a*e,l=i/(e*e),c=t.dataSync(),h=new Float32Array(r*s*u*l),p=0,f=0;f<r;++f)for(var v=0;v<s;++v)for(var m=Math.floor(v/e),g=v%e,y=0;y<u;++y)for(var x=Math.floor(y/e),w=(g*e+y%e)*l,b=0;b<l;++b){var C=b+w+i*(x+a*(m+o*f));h[p++]=c[C]}return Un(h,[r,s,u,l])},t.prototype.broadcastedBinaryOp=function(t,e,n,r){var o=so(t.shape,e.shape),a=Nr(o,n),i=t.dataSync(),s=e.dataSync(),u=ao(t.shape,o),l=ao(e.shape,o),c=a.values;if(u.length+l.length===0)for(var h=0;h<c.length;++h)c[h]=r(i[h%i.length],s[h%s.length]);else{var p=t.bufferSync(),f=e.bufferSync(),d=function(n){var o=a.indexToLoc(n),h=o.slice(-t.rank);u.forEach(function(t){return h[t]=0});var d=p.locToIndex(h),v=o.slice(-e.rank);l.forEach(function(t){return v[t]=0});var m=f.locToIndex(v);c[n]=r(i[d],s[m])};for(h=0;h<c.length;++h)d(h)}return a.toTensor()},t.prototype.broadcastedBinaryComplexOp=function(t,e,n){var r=so(t.shape,e.shape),o=Nr(r,"float32"),a=Nr(r,"float32"),i=t.dataSync(),s=e.dataSync(),u=ao(t.shape,r),l=ao(e.shape,r),c=o.values,h=a.values;if(u.length+l.length===0)for(var p=0;p<c.length;p++){var f=p%i.length,d=p%s.length,v=n(i[2*f],i[2*f+1],s[2*d],s[2*d+1]);c[p]=v.real,h[p]=v.imag}else{var m=this.data.get(t.dataId).complexTensors.real.bufferSync(),g=this.data.get(e.dataId).complexTensors.real.bufferSync(),y=function(r){var a=o.indexToLoc(r),p=a.slice(-t.rank);u.forEach(function(t){return p[t]=0});var f=m.locToIndex(p),d=a.slice(-e.rank);l.forEach(function(t){return d[t]=0});var v=g.locToIndex(d),y=n(i[2*f],i[2*f+1],s[2*v],s[2*v+1]);c[r]=y.real,h[r]=y.imag};for(p=0;p<c.length;p++)y(p)}return this.complex(o.toTensor(),a.toTensor())},t.prototype.split=function(t,e,n){return sr(t,e,n)},t.prototype.dispose=function(){},t.prototype.floatPrecision=function(){return 32},t.prototype.epsilon=function(){return 1e-7},t.prototype.cropAndResize=function(t,e,n,r,o,a){for(var i=t.shape,s=i[0],u=i[1],l=i[2],c=i[3],h=e.shape[0],p=r[0],f=r[1],d=Nr([h,p,f,c],t.dtype),v=e.dataSync(),m=n.dataSync(),g=t.dataSync(),y=t.strides,x=d.strides,w=0;w<h;w++){var b=4*w,C=v[b],E=v[b+1],R=v[b+2],S=v[b+3],N=m[w];if(!(N>=s))for(var k=p>1?(R-C)*(u-1)/(p-1):0,I=f>1?(S-E)*(l-1)/(f-1):0,A=0;A<p;A++){var T=p>1?C*(u-1)+A*k:.5*(C+R)*(u-1);if(T<0||T>u-1)for(var D=0;D<f;D++)for(var O=0;O<c;O++){var _=O+D*x[2]+A*x[1]+w*x[0];d.values[_]=a}else if("bilinear"===o){var M=Math.floor(T),F=Math.ceil(T),B=T-M;for(D=0;D<f;D++){if((H=f>1?E*(l-1)+D*I:.5*(E+S)*(l-1))<0||H>l-1)for(O=0;O<c;O++){_=O+D*x[2]+A*x[1]+w*x[0];d.values[_]=a}else{var P=Math.floor(H),L=Math.ceil(H),W=H-P;for(O=0;O<c;O++){var U=g[_=O+P*y[2]+M*y[1]+N*y[0]],z=g[_=O+L*y[2]+M*y[1]+N*y[0]],V=g[_=O+P*y[2]+F*y[1]+N*y[0]],G=U+(z-U)*W,q=V+(g[_=O+L*y[2]+F*y[1]+N*y[0]]-V)*W;_=O+D*x[2]+A*x[1]+w*x[0],d.values[_]=G+(q-G)*B}}}}else for(D=0;D<f;++D){var H;if((H=f>1?E*(l-1)+D*I:.5*(E+S)*(l-1))<0||H>l-1)for(O=0;O<c;O++){_=O+D*x[2]+A*x[1]+w*x[0];d.values[_]=a}else{var $=Math.round(H),j=Math.round(T);for(O=0;O<c;O++){var K=O+$*y[2]+j*y[1]+N*y[0],X=O+D*x[2]+A*x[1]+w*x[0];d.values[X]=g[K]}}}}}return d.toTensor()},t.prototype.sparseToDense=function(t,e,n,r){var o=pn(0,t,n),a=o.sliceRank,i=o.numUpdates,s=o.sliceSize,u=o.strides,l=o.outputSize;return this.scatter(t,e,n,l,s,i,a,u,r,!1)},t.prototype.gatherND=function(t,e){var n=e.shape,r=n[n.length-1],o=un(t,e),a=o[0],i=o[1],s=o[2],u=o[3];if(0===i)return Fn([],a,t.dtype);for(var l=new lt([i,s],t.dtype),c=e.dataSync(),h=t.dataSync(),p=0;p<i;p++){for(var f=[],d=0,v=0;v<r;v++){var m=c[p*r+v];d+=m*u[v],f.push(m)}if(d<0||d>=t.size/s)throw new Error("Invalid indices: "+f+" does not index into "+t.shape);for(var g=0;g<s;g++)l.values[p*s+g]=h[d*s+g]}return l.toTensor().reshape(a)},t.prototype.scatterND=function(t,e,n){var r=pn(0,t,n),o=r.sliceRank,a=r.numUpdates,i=r.sliceSize,s=r.strides,u=r.outputSize,l=Bn(0);return this.scatter(t,e,n,u,i,a,o,s,l,!0)},t.prototype.fill=function(t,e,n){var r=A(n=n||W(e),y(t));return r.fill(e),ft.make(t,{values:r},n)},t.prototype.onesLike=function(t){if("string"===t.dtype)throw new Error("onesLike is not supported for string tensors");return this.fill(t.shape,1,t.dtype)},t.prototype.zerosLike=function(t){var e=A(t.dtype,y(t.shape));return ft.make(t.shape,{values:e},t.dtype)},t.prototype.linspace=function(t,e,n){return tr(t,e,n)},t.prototype.scatter=function(t,e,n,r,o,a,i,s,u,l){var c=[r/o,o],h=t.dataSync(),p=e.dataSync();if(0===r)return Fn([],n,e.dtype);var f=new lt(c,e.dtype);f.values.fill(u.dataSync()[0]);for(var d=0;d<a;d++){for(var v=[],m=0,g=0;g<i;g++){var y=h[d*i+g];v.push(y),m+=y*s[g]}if(m<0||m>=r/o)throw new Error("Invalid indices: "+v+" does not index into "+n);for(var x=0;x<o;x++)l?f.values[m*o+x]+=p[d*o+x]:f.values[m*o+x]=0===e.rank?p[0]:p[d*o+x]}return f.toTensor().reshape(n)},t}();Dt.registerBackend("cpu",function(){return new gc},1);var yc={float32:4,int32:4,uint16:2,uint8:1,bool:1};function xc(t,e){for(var n={},r=0,o=function(e){var o=e.name,a=e.dtype,i=e.shape,s=y(i),u=void 0;if("quantization"in e){var l=e.quantization;if("uint8"!==l.dtype&&"uint16"!==l.dtype)throw new Error("Weight "+e.name+" has unknown quantization dtype "+l.dtype+". Supported quantization dtypes are: 'uint8' and 'uint16'.");var c=yc[l.dtype],h=t.slice(r,r+s*c),p="uint8"===l.dtype?new Uint8Array(h):new Uint16Array(h);if("float32"===a)u=Float32Array.from(p,function(t){return t*l.scale+l.min});else{if("int32"!==a)throw new Error("Unsupported dtype in weight '"+o+"': "+a);u=Int32Array.from(p,function(t){return Math.round(t*l.scale+l.min)})}r+=s*c}else{var f=yc[a];h=t.slice(r,r+s*f);if("float32"===a)u=new Float32Array(h);else if("int32"===a)u=new Int32Array(h);else{if("bool"!==a)throw new Error("Unsupported dtype in weight '"+o+"': "+a);u=new Uint8Array(h)}r+=s*f}var d=void 0;if("float32"===a)d=Fn(u,i,"float32");else if("int32"===a)d=Fn(u,i,"int32");else{if("bool"!==a)throw new Error("Unsupported dtype in weight '"+o+"': "+a);d=Fn(u,i,"bool")}n[o]=d},a=0,i=e;a<i.length;a++){o(i[a])}return n}function wc(t){if(null===t)throw new Error("Invalid input value: "+JSON.stringify(t));var e=0,n=[];t.forEach(function(t){if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: "+t.constructor.name)});var r=new Uint8Array(e),o=0;return n.forEach(function(t){r.set(new Uint8Array(t.buffer),o),o+=t.byteLength}),r.buffer}var bc="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function Cc(t){return bc?Buffer.byteLength(t):new Blob([t]).size}function Ec(t){var e=0;t.forEach(function(t){e+=t.byteLength});var n=new Uint8Array(e),r=0;return t.forEach(function(t){n.set(new Uint8Array(t),r),r+=t.byteLength}),n.buffer}function Rc(t){for(t=t.trim();t.endsWith("/");)t=t.slice(0,t.length-1);var e=t.split("/");return e[e.length-1]}function Sc(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:Cc(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:Cc(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}var Nc=function(){function t(){this.saveRouters=[],this.loadRouters=[]}return t.getInstance=function(){return null==t.instance&&(t.instance=new t),t.instance},t.registerSaveRouter=function(e){t.getInstance().saveRouters.push(e)},t.registerLoadRouter=function(e){t.getInstance().loadRouters.push(e)},t.getSaveHandlers=function(e){return t.getHandlers(e,"save")},t.getLoadHandlers=function(e,n){return t.getHandlers(e,"load",n)},t.getHandlers=function(e,n,r){var o=[];return("load"===n?t.getInstance().loadRouters:t.getInstance().saveRouters).forEach(function(t){var n=t(e,r);null!==n&&o.push(n)}),o},t}(),kc="://",Ic=function(){function t(){this.managers={}}return t.getInstance=function(){return null==t.instance&&(t.instance=new t),t.instance},t.registerManager=function(e,n){d(null!=e,function(){return"scheme must not be undefined or null."}),e.endsWith(kc)&&(e=e.slice(0,e.indexOf(kc))),d(e.length>0,function(){return"scheme must not be an empty string."});var r=t.getInstance();d(null==r.managers[e],function(){return"A model store manager is already registered for scheme '"+e+"'."}),r.managers[e]=n},t.getManager=function(t){var e=this.getInstance().managers[t];if(null==e)throw new Error("Cannot find model manager for scheme '"+t+"'");return e},t.getSchemes=function(){return Object.keys(this.getInstance().managers)},t}();function Ac(t){if(-1===t.indexOf(kc))throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+Ic.getSchemes().join(","));return{scheme:t.split(kc)[0],path:t.split(kc)[1]}}function Tc(t,e,n){return void 0===n&&(n=!1),r(this,void 0,void 0,function(){var r,a,i,s,u,l,c,h,p;return o(this,function(o){switch(o.label){case 0:return d(t!==e,function(){return"Old path and new path are the same: '"+t+"'"}),d((r=Nc.getLoadHandlers(t)).length>0,function(){return"Copying failed because no load handler is found for source URL "+t+"."}),d(r.length<2,function(){return"Copying failed because more than one ("+r.length+") load handlers for source URL "+t+"."}),a=r[0],d((i=Nc.getSaveHandlers(e)).length>0,function(){return"Copying failed because no save handler is found for destination URL "+e+"."}),d(i.length<2,function(){return"Copying failed because more than one ("+r.length+") save handlers for destination URL "+e+"."}),s=i[0],u=Ac(t).scheme,l=Ac(t).path,c=u===Ac(t).scheme,[4,a.load()];case 1:return h=o.sent(),n&&c?[4,Ic.getManager(u).removeModel(l)]:[3,3];case 2:o.sent(),o.label=3;case 3:return[4,s.save(h)];case 4:return p=o.sent(),!n||c?[3,6]:[4,Ic.getManager(u).removeModel(l)];case 5:o.sent(),o.label=6;case 6:return[2,p.modelArtifactsInfo]}})})}var Dc="models_store",Oc="model_info_store";function _c(){if(!a.getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");var t=window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Mc(t){var e=t.result;e.createObjectStore(Dc,{keyPath:"modelPath"}),e.createObjectStore(Oc,{keyPath:"modelPath"})}var Fc=function(){function t(t){if(this.indexedDB=_c(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}return t.prototype.save=function(t){return r(this,void 0,void 0,function(){return o(this,function(e){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return[2,this.databaseAction(this.modelPath,t)]})})},t.prototype.load=function(){return r(this,void 0,void 0,function(){return o(this,function(t){return[2,this.databaseAction(this.modelPath)]})})},t.prototype.databaseAction=function(t,e){var n=this;return new Promise(function(t,r){var o=n.indexedDB.open("tensorflowjs",1);o.onupgradeneeded=function(){return Mc(o)},o.onsuccess=function(){var a=o.result;if(null==e){var i=a.transaction(Dc,"readonly"),s=i.objectStore(Dc).get(n.modelPath);s.onsuccess=function(){if(null==s.result)return a.close(),r(new Error("Cannot find model with path '"+n.modelPath+"' in IndexedDB."));t(s.result.modelArtifacts)},s.onerror=function(t){return a.close(),r(s.error)},i.oncomplete=function(){return a.close()}}else{var u,l=Sc(e),c=a.transaction(Oc,"readwrite"),h=c.objectStore(Oc),p=h.put({modelPath:n.modelPath,modelArtifactsInfo:l});p.onsuccess=function(){var o=(u=a.transaction(Dc,"readwrite")).objectStore(Dc).put({modelPath:n.modelPath,modelArtifacts:e,modelArtifactsInfo:l});o.onsuccess=function(){return t({modelArtifactsInfo:l})},o.onerror=function(t){var e=(h=c.objectStore(Oc)).delete(n.modelPath);e.onsuccess=function(){return a.close(),r(o.error)},e.onerror=function(t){return a.close(),r(o.error)}}},p.onerror=function(t){return a.close(),r(p.error)},c.oncomplete=function(){null==u?a.close():u.oncomplete=function(){return a.close()}}}},o.onerror=function(t){return r(o.error)}})},t.URL_SCHEME="indexeddb://",t}(),Bc=function(t){return a.getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Fc.URL_SCHEME)?(e=t.slice(Fc.URL_SCHEME.length),new Fc(e)):null;var e};Nc.registerSaveRouter(Bc),Nc.registerLoadRouter(Bc);var Pc=function(){function t(){this.indexedDB=_c()}return t.prototype.listModels=function(){return r(this,void 0,void 0,function(){var t=this;return o(this,function(e){return[2,new Promise(function(e,n){var r=t.indexedDB.open("tensorflowjs",1);r.onupgradeneeded=function(){return Mc(r)},r.onsuccess=function(){var t=r.result,o=t.transaction(Oc,"readonly"),a=o.objectStore(Oc).getAll();a.onsuccess=function(){for(var t={},n=0,r=a.result;n<r.length;n++){var o=r[n];t[o.modelPath]=o.modelArtifactsInfo}e(t)},a.onerror=function(e){return t.close(),n(a.error)},o.oncomplete=function(){return t.close()}},r.onerror=function(t){return n(r.error)}})]})})},t.prototype.removeModel=function(t){return r(this,void 0,void 0,function(){var e=this;return o(this,function(n){var r;return t=(r=t).startsWith(Fc.URL_SCHEME)?r.slice(Fc.URL_SCHEME.length):r,[2,new Promise(function(n,r){var o=e.indexedDB.open("tensorflowjs",1);o.onupgradeneeded=function(){return Mc(o)},o.onsuccess=function(){var e,a=o.result,i=a.transaction(Oc,"readwrite"),s=i.objectStore(Oc),u=s.get(t);u.onsuccess=function(){if(null==u.result)return a.close(),r(new Error("Cannot find model with path '"+t+"' in IndexedDB."));var o=s.delete(t),i=function(){var o=(e=a.transaction(Dc,"readwrite")).objectStore(Dc).delete(t);o.onsuccess=function(){return n(u.result.modelArtifactsInfo)},o.onerror=function(t){return r(u.error)}};o.onsuccess=i,o.onerror=function(t){return i(),a.close(),r(u.error)}},u.onerror=function(t){return a.close(),r(u.error)},i.oncomplete=function(){null==e?a.close():e.oncomplete=function(){return a.close()}}},o.onerror=function(t){return r(o.error)}})]})})},t}();if(a.getBool("IS_BROWSER"))try{Ic.registerManager(Fc.URL_SCHEME,new Pc)}catch(t){}var Lc="/",Wc="tensorflowjs_models",Uc="info",zc="model_topology",Vc="weight_specs",Gc="weight_data",qc="model_metadata";function Hc(t){return{info:[Wc,t,Uc].join(Lc),topology:[Wc,t,zc].join(Lc),weightSpecs:[Wc,t,Vc].join(Lc),weightData:[Wc,t,Gc].join(Lc),modelMetadata:[Wc,t,qc].join(Lc)}}function $c(t){var e=t.split(Lc);if(e.length<3)throw new Error("Invalid key format: "+t);return e.slice(1,e.length-1).join(Lc)}var jc=function(){function t(t){if(!a.getBool("IS_BROWSER")||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=Hc(this.modelPath)}return t.prototype.save=function(t){return r(this,void 0,void 0,function(){var e,n,r;return o(this,function(o){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),r=Sc(t);try{return this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,(a=t.weightData,bc?Buffer.from(a).toString("base64"):btoa(String.fromCharCode.apply(null,new Uint8Array(a))))),this.LS.setItem(this.keys.modelMetadata,JSON.stringify({format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy})),[2,{modelArtifactsInfo:r}]}catch(t){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error("Failed to save model '"+this.modelPath+"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes="+r.modelTopologyBytes+", weightSpecsBytes="+r.weightSpecsBytes+", weightDataBytes="+r.weightDataBytes+".")}var a;return[2]})})},t.prototype.load=function(){return r(this,void 0,void 0,function(){var t,e,n,r,a,i,s;return o(this,function(o){if(null==(t=JSON.parse(this.LS.getItem(this.keys.info))))throw new Error("In local storage, there is no model with name '"+this.modelPath+"'");if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");if(e={},null==(n=JSON.parse(this.LS.getItem(this.keys.topology))))throw new Error("In local storage, the topology of model '"+this.modelPath+"' is missing.");if(e.modelTopology=n,null==(r=JSON.parse(this.LS.getItem(this.keys.weightSpecs))))throw new Error("In local storage, the weight specs of model '"+this.modelPath+"' are missing.");if(e.weightSpecs=r,null!=(a=this.LS.getItem(this.keys.modelMetadata))&&(i=JSON.parse(a),e.format=i.format,e.generatedBy=i.generatedBy,e.convertedBy=i.convertedBy),null==(s=this.LS.getItem(this.keys.weightData)))throw new Error("In local storage, the binary weight values of model '"+this.modelPath+"' are missing.");return e.weightData=function(t){if(bc){var e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}for(var n=atob(t),r=new Uint8Array(n.length),o=0;o<n.length;++o)r.set([n.charCodeAt(o)],o);return r.buffer}(s),[2,e]})})},t.URL_SCHEME="localstorage://",t}(),Kc=function(t){return a.getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(jc.URL_SCHEME)?(e=t.slice(jc.URL_SCHEME.length),new jc(e)):null;var e};Nc.registerSaveRouter(Kc),Nc.registerLoadRouter(Kc);var Xc=function(){function t(){d(a.getBool("IS_BROWSER"),function(){return"Current environment is not a web browser"}),d(void 0!==window.localStorage,function(){return"Current browser does not appear to support localStorage"}),this.LS=window.localStorage}return t.prototype.listModels=function(){return r(this,void 0,void 0,function(){var t,e,n,r,a,i;return o(this,function(o){for(t={},e=Wc+Lc,n=Lc+Uc,r=0;r<this.LS.length;++r)(a=this.LS.key(r)).startsWith(e)&&a.endsWith(n)&&(i=$c(a),t[i]=JSON.parse(this.LS.getItem(a)));return[2,t]})})},t.prototype.removeModel=function(t){return r(this,void 0,void 0,function(){var e,n;return o(this,function(r){var o;if(t=(o=t).startsWith(jc.URL_SCHEME)?o.slice(jc.URL_SCHEME.length):o,e=Hc(t),null==this.LS.getItem(e.info))throw new Error("Cannot find model at path '"+t+"'");return n=JSON.parse(this.LS.getItem(e.info)),this.LS.removeItem(e.info),this.LS.removeItem(e.topology),this.LS.removeItem(e.weightSpecs),this.LS.removeItem(e.weightData),[2,n]})})},t}();if(a.getBool("IS_BROWSER"))try{Ic.registerManager(jc.URL_SCHEME,new Xc)}catch(t){}var Yc="model",Qc=".json",Jc=".weights.bin";function Zc(t){return new Promise(function(t){return setTimeout(t)}).then(t)}var th=function(){function t(e){if(!a.getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(t.URL_SCHEME)&&(e=e.slice(t.URL_SCHEME.length)),null!=e&&0!==e.length||(e=Yc),this.modelTopologyFileName=e+Qc,this.weightDataFileName=e+Jc}return t.prototype.save=function(t){return r(this,void 0,void 0,function(){var e,n,r,a,i,s;return o(this,function(o){switch(o.label){case 0:if(e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"})),!(t.modelTopology instanceof ArrayBuffer))return[3,1];throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");case 1:return n=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:n},a=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),(i=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor).download=this.modelTopologyFileName,i.href=a,[4,Zc(function(){return i.dispatchEvent(new MouseEvent("click"))})];case 2:return o.sent(),null==t.weightData?[3,4]:((s=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor).download=this.weightDataFileName,s.href=e,[4,Zc(function(){return s.dispatchEvent(new MouseEvent("click"))})]);case 3:o.sent(),o.label=4;case 4:return[2,{modelArtifactsInfo:Sc(t)}]}})})},t.URL_SCHEME="downloads://",t}(),eh=function(){function t(t){if(null==t||t.length<1)throw new Error("When calling browserFiles, at least 1 file is required, but received "+t);this.files=t}return t.prototype.load=function(){return r(this,void 0,void 0,function(){var t,e,n=this;return o(this,function(r){return t=this.files[0],e=this.files.slice(1),[2,new Promise(function(r,o){var a=new FileReader;a.onload=function(a){var i=JSON.parse(a.target.result),s=i.modelTopology;if(null!=s){0===e.length&&r({modelTopology:s});var u=i.weightsManifest;if(null!=u){var l;try{l=n.checkManifestAndWeightFiles(u,e)}catch(t){return void o(t)}var c=[],h=[],p=[];u.forEach(function(t){t.paths.forEach(function(t){h.push(t),p.push(null)}),c.push.apply(c,t.weights)}),u.forEach(function(t){t.paths.forEach(function(t){var e=new FileReader;e.onload=function(e){var n=e.target.result,o=h.indexOf(t);p[o]=n,-1===p.indexOf(null)&&r({modelTopology:s,weightSpecs:c,weightData:Ec(p)})},e.onerror=function(e){return o("Failed to weights data from file of path '"+t+"'.")},e.readAsArrayBuffer(l[t])})})}else o(new Error("weightManifest field is missing from file "+t.name))}else o(new Error("modelTopology field is missing from file "+t.name))},a.onerror=function(e){return o("Failed to read model topology and weights manifest JSON from file '"+t.name+"'. BrowserFiles supports loading Keras-style tf.Model artifacts only.")},a.readAsText(t)})]})})},t.prototype.checkManifestAndWeightFiles=function(t,e){for(var n=[],r=e.map(function(t){return Rc(t.name)}),o={},a=0,i=t;a<i.length;a++){i[a].paths.forEach(function(t){var a=Rc(t);if(-1!==n.indexOf(a))throw new Error("Duplicate file basename found in weights manifest: '"+a+"'");if(n.push(a),-1===r.indexOf(a))throw new Error("Weight file with basename '"+a+"' is not provided.");o[t]=e[r.indexOf(a)]})}if(n.length!==e.length)throw new Error("Mismatch in the number of files in weights manifest ("+n.length+") and the number of weight files provided ("+e.length+").");return o},t}();function nh(t,e,n,r){!function(t){d(null!=t&&Array.isArray(t)&&t.length>0,function(){return"promises must be a none empty array"})}(t),function(t,e){d(t>=0&&t<=1,function(){return"Progress fraction must be in range [0, 1], but got startFraction "+t}),d(e>=0&&e<=1,function(){return"Progress fraction must be in range [0, 1], but got endFraction "+e}),d(e>=t,function(){return"startFraction must be no more than endFraction, but got startFraction "+t+" and endFraction "+e})}(n=null==n?0:n,r=null==r?1:r);var o=0;return Promise.all(t.map(function(a){return a.then(function(a){var i=n+ ++o/t.length*(r-n);return e(i),a}),a}))}function rh(t,e){return r(this,void 0,void 0,function(){var n,r,a,i,s,u,l,c,h;return o(this,function(o){switch(o.label){case 0:return null==e&&(e={}),n=null==e.fetchFunc?J:e.fetchFunc,r=t.map(function(t){return n(t,e.requestInit)}),a=0,i=.5,null!=e.onProgress?[3,2]:[4,Promise.all(r)];case 1:return s=o.sent(),[3,4];case 2:return[4,nh(r,e.onProgress,a,i)];case 3:s=o.sent(),o.label=4;case 4:return u=s.map(function(t){return t.arrayBuffer()}),l=.5,c=1,null!=e.onProgress?[3,6]:[4,Promise.all(u)];case 5:return h=o.sent(),[3,8];case 6:return[4,nh(u,e.onProgress,l,c)];case 7:h=o.sent(),o.label=8;case 8:return[2,h]}})})}function oh(t){var e=this;return function(n,a,i){return void 0===a&&(a=""),r(e,void 0,void 0,function(){var e,r,s,u,l,c,h,p,f,d;return o(this,function(o){switch(o.label){case 0:if(e=n.map(function(){return!1}),r={},s=null!=i?i.map(function(){return!1}):[],u=[],n.forEach(function(t,n){var o=0;t.weights.forEach(function(t){var a="quantization"in t?t.quantization.dtype:t.dtype,l=yc[a]*y(t.shape),c=function(){e[n]=!0,null==r[n]&&(r[n]=[]),r[n].push({manifestEntry:t,groupOffset:o,sizeBytes:l})};null!=i?i.forEach(function(e,n){e===t.name&&(c(),s[n]=!0)}):c(),u.push(t.name),o+=l})}),!s.every(function(t){return t}))throw l=i.filter(function(t,e){return!s[e]}),new Error("Could not find weights in manifest with names: "+l.join(", ")+". \nManifest JSON has weights with names: "+u.join(", ")+".");return c=e.reduce(function(t,e,n){return e&&t.push(n),t},[]),h=[],c.forEach(function(t){n[t].paths.forEach(function(t){var e=a+(a.endsWith("/")?"":"/")+t;h.push(e)})}),[4,t(h)];case 1:return p=o.sent(),f={},d=0,c.forEach(function(t){for(var e=n[t].paths.length,o=0,a=0;a<e;a++)o+=p[d+a].byteLength;for(var i=new ArrayBuffer(o),s=new Uint8Array(i),u=0,l=0;l<e;l++){var c=new Uint8Array(p[d+l]);s.set(c,u),u+=c.byteLength}r[t].forEach(function(t){var e=xc(i.slice(t.groupOffset,t.groupOffset+t.sizeBytes),[t.manifestEntry]);for(var n in e)f[n]=e[n]}),d+=e}),[2,f]}})})}}Nc.registerSaveRouter(function(t){return a.getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(th.URL_SCHEME)?(e=t.slice(th.URL_SCHEME.length),void 0===e&&(e="model"),new th(e)):null;var e});var ah=function(){function t(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,null!=e.fetchFunc?(d("function"==typeof e.fetchFunc,function(){return"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"}),this.fetch=e.fetchFunc):this.fetch=J,d(null!=t&&t.length>0,function(){return"URL path for http must not be null, undefined or empty."}),Array.isArray(t)&&d(2===t.length,function(){return"URL paths for http must have a length of 2, (actual length is "+t.length+")."}),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}return t.prototype.save=function(t){return r(this,void 0,void 0,function(){var e,n,r,a;return o(this,function(o){switch(o.label){case 0:if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");return(e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit)).body=new FormData,n=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:n},e.body.append("model.json",new Blob([JSON.stringify(r)],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin"),[4,this.fetch(this.path,e)];case 1:if((a=o.sent()).ok)return[2,{modelArtifactsInfo:Sc(t),responses:[a]}];throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+a.status+".")}})})},t.prototype.load=function(){return r(this,void 0,void 0,function(){var t,e,n,r,a,i,s,u;return o(this,function(o){switch(o.label){case 0:return[4,this.fetch(this.path,this.requestInit)];case 1:if(!(t=o.sent()).ok)throw new Error("Request to "+this.path+" failed with status code "+t.status+". Please verify this URL points to the model JSON of the model to load.");o.label=2;case 2:return o.trys.push([2,4,,5]),[4,t.json()];case 3:return e=o.sent(),[3,5];case 4:throw o.sent(),n="Failed to parse model JSON of response from "+this.path+".",this.path.endsWith(".pb")?n+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":n+=" Please make sure the server is serving valid JSON for this request.",new Error(n);case 5:if(r=e.modelTopology,a=e.weightsManifest,null==r&&null==a)throw new Error("The JSON from HTTP path "+this.path+" contains neither model topology or manifest for weights.");return null==a?[3,7]:[4,this.loadWeights(a)];case 6:u=o.sent(),i=u[0],s=u[1],o.label=7;case 7:return[2,{modelTopology:r,weightSpecs:i,weightData:s}]}})})},t.prototype.loadWeights=function(t){return r(this,void 0,void 0,function(){var e,n,r,a,i,s,u,l,c,h,p;return o(this,function(o){switch(o.label){case 0:for(e=Array.isArray(this.path)?this.path[1]:this.path,n=function(t){var e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),o=n>e?t.substring(n):"";return[r+"/",o]}(e),r=n[0],a=n[1],i=this.weightPathPrefix||r,s=[],u=0,l=t;u<l.length;u++)c=l[u],s.push.apply(s,c.weights);return h=[],t.forEach(function(t){t.paths.forEach(function(t){h.push(i+t+a)})}),[4,rh(h,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress})];case 1:return p=o.sent(),[2,[s,Ec(p)]]}})})},t.URL_SCHEME_REGEX=/^https?:\/\//,t}();function ih(t){return null!=t.match(ah.URL_SCHEME_REGEX)}var sh=function(t,e){return(Array.isArray(t)?t.every(function(t){return ih(t)}):ih(t))?uh(t,{onProgress:e}):null};function uh(t,e){return new ah(t,e)}Nc.registerSaveRouter(sh),Nc.registerLoadRouter(sh);var lh=function(){function t(t,e,n){this.modelTopology=t,this.weightSpecs=e,this.weightData=n}return t.prototype.load=function(){return r(this,void 0,void 0,function(){var t;return o(this,function(e){return t={},null!=this.modelTopology&&(t=n({modelTopology:this.modelTopology},t)),null!=this.weightSpecs&&this.weightSpecs.length>0&&(t=n({weightSpecs:this.weightSpecs},t)),null!=this.weightData&&this.weightData.byteLength>0&&(t=n({weightData:this.weightData},t)),[2,t]})})},t}(),ch=function(){function t(t){this.saveHandler=t}return t.prototype.save=function(t){return r(this,void 0,void 0,function(){return o(this,function(e){return[2,this.saveHandler(t)]})})},t}();var hh=Object.freeze({browserFiles:function(t){return new eh(t)},browserHTTPRequest:function(t,e){return uh(t,e)},concatenateArrayBuffers:Ec,decodeWeights:xc,encodeWeights:function(t){return r(this,void 0,void 0,function(){var e,n,r,a;return o(this,function(o){switch(o.label){case 0:for(r in e=[],n=[],t){if("float32"!==(a=t[r]).dtype&&"int32"!==a.dtype&&"bool"!==a.dtype)throw new Error("Unsupported dtype in weight '"+r+"': "+a.dtype);e.push({name:r,shape:a.shape,dtype:a.dtype}),n.push(a.data())}return[4,Promise.all(n)];case 1:return[2,{data:wc(o.sent()),specs:e}]}})})},fromMemory:function(t,e,n){return new lh(t,e,n)},getLoadHandlers:function(t,e){return Nc.getLoadHandlers(t)},getModelArtifactsInfoForJSON:Sc,getSaveHandlers:function(t){return Nc.getSaveHandlers(t)},http:uh,isHTTPScheme:ih,loadWeights:function(t,e,n,a){return void 0===e&&(e=""),r(this,void 0,void 0,function(){return o(this,function(r){return[2,oh(function(t){return rh(t,{requestInit:a})})(t,e,n)]})})},registerLoadRouter:function(t){return Nc.registerLoadRouter(t)},registerSaveRouter:function(t){return Nc.registerSaveRouter(t)},weightsLoaderFactory:oh,withSaveHandler:function(t){return new ch(t)},copyModel:function(t,e){return r(this,void 0,void 0,function(){return o(this,function(n){return[2,Tc(t,e,!1)]})})},listModels:function(){return r(this,void 0,void 0,function(){var t,e,n,r,a,i,s;return o(this,function(o){switch(o.label){case 0:t=Ic.getSchemes(),e={},n=0,r=t,o.label=1;case 1:return n<r.length?(a=r[n],[4,Ic.getManager(a).listModels()]):[3,4];case 2:for(s in i=o.sent())e[a+kc+s]=i[s];o.label=3;case 3:return n++,[3,1];case 4:return[2,e]}})})},moveModel:function(t,e){return r(this,void 0,void 0,function(){return o(this,function(n){return[2,Tc(t,e,!0)]})})},removeModel:function(t){return r(this,void 0,void 0,function(){var e;return o(this,function(n){return e=Ac(t),[2,Ic.getManager(e.scheme).removeModel(e.path)]})})}});var ph=An({confusionMatrix_:function(t,e,n){var r=wn(t,"labels","confusionMatrix"),o=wn(e,"predictions","confusionMatrix");d(null==n||n>0&&Number.isInteger(n),function(){return"If provided, numClasses must be a positive integer, but got "+n}),d(1===r.rank,function(){return"Expected the rank of labels to be 1, but got "+r.rank}),d(1===o.rank,function(){return"Expected the rank of predictions to be 1, but got "+o.rank}),d(r.shape[0]===o.shape[0],function(){return"Mismatch in the number of examples: "+r.shape[0]+" vs. "+o.shape[0]+". Labels and predictions should have the same number of elements."}),d(n>0&&Number.isInteger(n),function(){return"numClasses is required to be a positive integer, but got "+n});var a=Br(r.asType("int32"),n),i=Br(o.asType("int32"),n);return a.transpose().matMul(i).asType("int32")}}),fh=Object.freeze({confusionMatrix:ph});var dh=An({fromPixels_:function(t,e){if(void 0===e&&(e=3),e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");return Dt.fromPixels(t,e)}}),vh=Object.freeze({toPixels:function(t,e){return r(this,void 0,void 0,function(){var n,r,a,i,s,u,l,c,h,p,f,d,v,m,g,y,x,w,b,C,E,R,S;return o(this,function(o){switch(o.label){case 0:if(n=wn(t,"img","toPixels"),t instanceof ft||(n=n.toInt()),2!==n.rank&&3!==n.rank)throw new Error("toPixels only supports rank 2 or 3 tensors, got rank "+n.rank+".");if(r=n.shape.slice(0,2),a=r[0],i=r[1],(s=2===n.rank?1:n.shape[2])>4||2===s)throw new Error("toPixels only supports depth of size 1, 3 or 4 but got "+s);return[4,n.data()];case 1:return u=o.sent(),l=n.min(),c=n.max(),[4,Promise.all([l.data(),c.data()])];case 2:if(h=o.sent(),p=h[0],f=h[1],d=p[0],v=f[0],l.dispose(),c.dispose(),"float32"===n.dtype){if(d<0||v>1)throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range ["+d+" - "+v+"].")}else{if("int32"!==n.dtype)throw new Error("Unsupported type for toPixels: "+n.dtype+". Please use float32 or int32 tensors.");if(d<0||v>255)throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range ["+d+" - "+v+"].")}for(m="float32"===n.dtype?255:1,g=new Uint8ClampedArray(i*a*4),y=0;y<a*i;++y)x=void 0,w=void 0,b=void 0,C=void 0,1===s?(x=u[y]*m,w=u[y]*m,b=u[y]*m,C=255):3===s?(x=u[3*y]*m,w=u[3*y+1]*m,b=u[3*y+2]*m,C=255):4===s&&(x=u[4*y]*m,w=u[4*y+1]*m,b=u[4*y+2]*m,C=u[4*y+3]*m),g[0+(E=4*y)]=Math.round(x),g[E+1]=Math.round(w),g[E+2]=Math.round(b),g[E+3]=Math.round(C);return null!=e&&(e.width=i,e.height=a,R=e.getContext("2d"),S=new ImageData(g,i,a),R.putImageData(S,0,0)),n!==t&&n.dispose(),[2,g]}})})},fromPixels:dh}),mh=function(){function t(){}return t.prototype.getClassName=function(){return this.constructor.className},t.fromConfig=function(t,e){return new t(e)},t}(),gh=function(){function t(){this.classNameMap={}}return t.getMap=function(){return null==t.instance&&(t.instance=new t),t.instance},t.register=function(e){t.getMap().classNameMap[e.className]=[e,e.fromConfig]},t}();function yh(t){d(null!=t.className,function(){return"Class being registered does not have the static className property defined."}),d("string"==typeof t.className,function(){return"className is required to be a string, but got type "+typeof t.className}),d(t.className.length>0,function(){return"Class being registered has an empty-string as its className, which is disallowed."}),gh.register(t)}var xh=Object.freeze({Serializable:mh,SerializationMap:gh,registerClass:yh}),wh=.001,bh=.1;function Ch(){return 32===Dt.backend.floatPrecision()?wh:bh}function Eh(t,e,n){var r=!0;if((_(t)||_(e))&&(r=!1),_(t)&&_(e)&&(r=!0),r){var o=t.constructor.name,a=e.constructor.name;if(o!==a)throw new Error("Arrays are of different type. Actual: "+o+". Expected: "+a)}if(Array.isArray(t)&&Array.isArray(e)){var i=yn(t),s=yn(e);if(!x(i,s))throw new Error("Arrays have different shapes. Actual: ["+i+"]. Expected: ["+s+"]")}var u=_(t)?t:g(t),l=_(e)?e:g(e);if(u.length!==l.length)throw new Error("Arrays have different lengths actual: "+u.length+" vs expected: "+l.length+".\nActual:   "+u+".\nExpected: "+l+".");for(var c=0;c<l.length;++c){var h=u[c],p=l[c];if(!n(h,p))throw new Error("Arrays differ: actual["+c+"] = "+h+", expected["+c+"] = "+p+".\nActual:   "+u+".\nExpected: "+l+".")}}function Rh(t,e,n){return!isFinite(t)&&!isFinite(e)||!(isNaN(t)||isNaN(e)||Math.abs(t-e)>n)}var Sh=Object.freeze({TEST_EPSILON_FLOAT16:bh,expectArraysClose:function(t,e,n){return null==n&&(n=Ch()),Eh(t,e,function(t,e){return Rh(t,e,n)})},testEpsilon:Ch,expectPromiseToFail:function(t,e){t().then(function(){return e.fail()},function(){return e()})},expectArraysEqual:function(t,e){var n="string"==typeof e||"number"==typeof e||"boolean"==typeof e?[e]:e;return B(t)||B(t[0])||B(e)||B(e[0])?Eh(t,n,function(t,e){return t==e}):Eh(t,e,function(t,e){return Rh(t,e,0)})},expectNumbersClose:function(t,e,n){if(null==n&&(n=Ch()),!Rh(t,e,n))throw new Error("Numbers differ: actual === "+t+", expected === "+e)},expectValuesInRange:function(t,e,n){for(var r=0;r<t.length;r++)if(t[r]<e||t[r]>n)throw new Error("Value out of range:"+t[r]+" low: "+e+", high: "+n)},expectArrayBuffersEqual:function(t,e){expect(new Float32Array(t)).toEqual(new Float32Array(e))}}),Nh="1.1.2",kh=Object.freeze({gpgpu_util:La,webgl_util:ke,MathBackendWebGL:Ui,GPGPUContext:Wa}),Ih=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return e(n,t),n.prototype.minimize=function(t,e,n){void 0===e&&(e=!1);var r=this.computeGradients(t,n),o=r.value,a=r.grads;return this.applyGradients(a),Object.keys(a).forEach(function(t){return a[t].dispose()}),e?o:(o.dispose(),null)},n.prototype.computeGradients=function(t,e){return Nn(t,e)},n.prototype.dispose=function(){},n}(mh);Object.defineProperty(Ih,Symbol.hasInstance,{value:function(t){return null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients}});var Ah=function(t){function n(e,n,r){void 0===r&&(r=null);var o=t.call(this)||this;return o.learningRate=e,o.rho=n,o.epsilon=r,o.accumulatedGrads={},o.accumulatedUpdates={},null==r&&(o.epsilon=Dt.backend.epsilon()),o}return e(n,t),n.prototype.applyGradients=function(t){var e=this,n=function(n){var o=Dt.registeredVariables[n];if(null==r.accumulatedGrads[n]){Fe(function(){e.accumulatedGrads[n]=Xn(o).variable(!1)})}if(null==r.accumulatedUpdates[n]){Fe(function(){e.accumulatedUpdates[n]=Xn(o).variable(!1)})}var a=t[n],i=r.accumulatedGrads[n],s=r.accumulatedUpdates[n];Fe(function(){var t=i.mul(e.rho).add(a.square().mul(1-e.rho)),r=s.add(e.epsilon).sqrt().div(i.add(e.epsilon).sqrt()).mul(a),u=s.mul(e.rho).add(r.square().mul(1-e.rho));e.accumulatedGrads[n].assign(t),e.accumulatedUpdates[n].assign(u);var l=r.mul(-e.learningRate).add(o);o.assign(l)})},r=this;for(var o in t)n(o)},n.prototype.dispose=function(){var t=this;null!=this.accumulatedUpdates&&(Object.keys(this.accumulatedUpdates).forEach(function(e){return t.accumulatedUpdates[e].dispose()}),Object.keys(this.accumulatedGrads).forEach(function(e){return t.accumulatedGrads[e].dispose()}))},n.prototype.getConfig=function(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}},n.fromConfig=function(t,e){return new t(e.learningRate,e.rho,e.epsilon)},n.className="AdadeltaOptimizer",n}(Ih);yh(Ah);var Th=function(t){function n(e,n){void 0===n&&(n=.1);var r=t.call(this)||this;return r.learningRate=e,r.initialAccumulatorValue=n,r.accumulatedGrads={},r}return e(n,t),n.prototype.applyGradients=function(t){var e=this,n=function(n){var o=Dt.registeredVariables[n];if(null==r.accumulatedGrads[n]){Fe(function(){e.accumulatedGrads[n]=Hn(o.shape,e.initialAccumulatorValue).variable(!1)})}var a=t[n],i=r.accumulatedGrads[n];Fe(function(){var t=i.add(a.square());e.accumulatedGrads[n].assign(t);var r=a.div(t.add(Dt.backend.epsilon()).sqrt()).mul(-e.learningRate).add(o);o.assign(r)})},r=this;for(var o in t)n(o)},n.prototype.dispose=function(){var t=this;null!=this.accumulatedGrads&&Object.keys(this.accumulatedGrads).forEach(function(e){return t.accumulatedGrads[e].dispose()})},n.prototype.getConfig=function(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}},n.fromConfig=function(t,e){return new t(e.learningRate,e.initialAccumulatorValue)},n.className="AdagradOptimizer",n}(Ih);yh(Th);var Dh=function(t){function n(e,n,r,o){void 0===o&&(o=null);var a=t.call(this)||this;return a.learningRate=e,a.beta1=n,a.beta2=r,a.epsilon=o,a.accumulatedFirstMoment={},a.accumulatedSecondMoment={},Fe(function(){a.accBeta1=Bn(n).variable(),a.accBeta2=Bn(r).variable()}),null==o&&(a.epsilon=Dt.backend.epsilon()),a}return e(n,t),n.prototype.applyGradients=function(t){var e=this;Fe(function(){var n=ll(1,e.accBeta1),r=ll(1,e.accBeta2);for(var o in t){var a=Dt.registeredVariables[o];if(null==e.accumulatedFirstMoment[o]){var i=!1;e.accumulatedFirstMoment[o]=Xn(a).variable(i)}if(null==e.accumulatedSecondMoment[o]){i=!1;e.accumulatedSecondMoment[o]=Xn(a).variable(i)}var s=t[o],u=e.accumulatedFirstMoment[o],l=e.accumulatedSecondMoment[o],c=u.mul(e.beta1).add(s.mul(1-e.beta1)),h=l.mul(e.beta2).add(s.square().mul(1-e.beta2)),p=c.div(n),f=h.div(r);e.accumulatedFirstMoment[o].assign(c),e.accumulatedSecondMoment[o].assign(h);var d=p.div(f.sqrt().add(e.epsilon)).mul(-e.learningRate).add(a);a.assign(d)}e.accBeta1.assign(e.accBeta1.mul(e.beta1)),e.accBeta2.assign(e.accBeta2.mul(e.beta2))})},n.prototype.dispose=function(){var t=this;this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Object.keys(this.accumulatedFirstMoment).forEach(function(e){return t.accumulatedFirstMoment[e].dispose()}),null!=this.accumulatedSecondMoment&&Object.keys(this.accumulatedSecondMoment).forEach(function(e){return t.accumulatedSecondMoment[e].dispose()})},n.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}},n.fromConfig=function(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)},n.className="AdamOptimizer",n}(Ih);yh(Dh);var Oh=function(t){function n(e,n,r,o,a){void 0===o&&(o=null),void 0===a&&(a=0);var i=t.call(this)||this;return i.learningRate=e,i.beta1=n,i.beta2=r,i.epsilon=o,i.decay=a,i.accumulatedFirstMoment={},i.accumulatedWeightedInfNorm={},Fe(function(){i.iteration=Bn(0).variable(),i.accBeta1=Bn(n).variable()}),null==o&&(i.epsilon=Dt.backend.epsilon()),i}return e(n,t),n.prototype.applyGradients=function(t){var e=this;Fe(function(){var n=ll(1,e.accBeta1),r=Ku(-e.learningRate,e.iteration.mul(e.decay).add(1));for(var o in t){var a=Dt.registeredVariables[o];if(null==e.accumulatedFirstMoment[o]){var i=!1;e.accumulatedFirstMoment[o]=Xn(a).variable(i)}if(null==e.accumulatedWeightedInfNorm[o]){i=!1;e.accumulatedWeightedInfNorm[o]=Xn(a).variable(i)}var s=t[o],u=e.accumulatedFirstMoment[o],l=e.accumulatedWeightedInfNorm[o],c=u.mul(e.beta1).add(s.mul(1-e.beta1)),h=l.mul(e.beta2),p=s.abs(),f=h.maximum(p);e.accumulatedFirstMoment[o].assign(c),e.accumulatedWeightedInfNorm[o].assign(f);var d=r.div(n).mul(c.div(f.add(e.epsilon))).add(a);a.assign(d)}e.iteration.assign(e.iteration.add(1)),e.accBeta1.assign(e.accBeta1.mul(e.beta1))})},n.prototype.dispose=function(){var t=this;this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Object.keys(this.accumulatedFirstMoment).forEach(function(e){return t.accumulatedFirstMoment[e].dispose()}),null!=this.accumulatedWeightedInfNorm&&Object.keys(this.accumulatedWeightedInfNorm).forEach(function(e){return t.accumulatedWeightedInfNorm[e].dispose()})},n.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}},n.fromConfig=function(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)},n.className="AdamaxOptimizer",n}(Ih);yh(Oh);var _h=function(t){function n(e){var n=t.call(this)||this;return n.learningRate=e,n.setLearningRate(e),n}return e(n,t),n.prototype.applyGradients=function(t){var e=this;Object.keys(t).forEach(function(n){var r=t[n],o=Dt.registeredVariables[n];Fe(function(){var t=e.c.mul(r).add(o);o.assign(t)})})},n.prototype.setLearningRate=function(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=Pe(Bn(-t))},n.prototype.dispose=function(){this.c.dispose()},n.prototype.getConfig=function(){return{learningRate:this.learningRate}},n.fromConfig=function(t,e){return new t(e.learningRate)},n.className="SGDOptimizer",n}(Ih);yh(_h);var Mh=function(t){function n(e,n,r){void 0===r&&(r=!1);var o=t.call(this,e)||this;return o.learningRate=e,o.momentum=n,o.useNesterov=r,o.m=Bn(o.momentum),o.accumulations={},o}return e(n,t),n.prototype.applyGradients=function(t){var e=this,n=function(n){var o=Dt.registeredVariables[n];if(null==r.accumulations[n]){Fe(function(){e.accumulations[n]=Xn(o).variable(!1)})}var a=r.accumulations[n],i=t[n];Fe(function(){var t,r=e.m.mul(a).add(i);t=e.useNesterov?e.c.mul(i.add(r.mul(e.m))).add(o):e.c.mul(r).add(o),e.accumulations[n].assign(r),o.assign(t)})},r=this;for(var o in t)n(o)},n.prototype.dispose=function(){if(t.prototype.dispose.call(this),this.m.dispose(),null!=this.accumulations)for(var e in this.accumulations)this.accumulations[e].dispose()},n.prototype.setMomentum=function(t){this.momentum=t},n.prototype.getConfig=function(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}},n.fromConfig=function(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)},n.className="MomentumOptimizer",n}(_h);yh(Mh);var Fh=function(t){function n(e,n,r,o,a){void 0===n&&(n=.9),void 0===r&&(r=0),void 0===o&&(o=null),void 0===a&&(a=!1);var i=t.call(this)||this;return i.learningRate=e,i.decay=n,i.momentum=r,i.epsilon=o,i.accumulatedMeanSquares={},i.accumulatedMeanGrads={},i.accumulatedMoments={},i.centered=a,null==o&&(i.epsilon=Dt.backend.epsilon()),i}return e(n,t),n.prototype.applyGradients=function(t){var e=this,n=function(n){var o=Dt.registeredVariables[n];if(null==r.accumulatedMeanSquares[n]){Fe(function(){e.accumulatedMeanSquares[n]=Xn(o).variable(!1)})}if(null==r.accumulatedMeanGrads[n]&&r.centered){Fe(function(){e.accumulatedMeanGrads[n]=Xn(o).variable(!1)})}if(null==r.accumulatedMoments[n]){Fe(function(){e.accumulatedMoments[n]=Xn(o).variable(!1)})}var a=r.accumulatedMeanSquares[n],i=r.accumulatedMeanGrads[n],s=r.accumulatedMoments[n],u=t[n];Fe(function(){var t=a.mul(e.decay).add(u.square().mul(1-e.decay));if(e.centered){var r=i.mul(e.decay).add(u.mul(1-e.decay)),l=s.mul(e.momentum).add(u.mul(e.learningRate).div(t.sub(r.square().add(e.epsilon)).sqrt()));e.accumulatedMeanSquares[n].assign(t),e.accumulatedMeanGrads[n].assign(r),e.accumulatedMoments[n].assign(l);var c=o.sub(l);o.assign(c)}else{var h=a.mul(e.decay).add(u.square().mul(1-e.decay));l=s.mul(e.momentum).add(u.mul(e.learningRate).div(h.add(e.epsilon).sqrt()));e.accumulatedMeanSquares[n].assign(h),e.accumulatedMoments[n].assign(l);c=o.sub(l);o.assign(c)}})},r=this;for(var o in t)n(o)},n.prototype.dispose=function(){var t=this;null!=this.accumulatedMeanSquares&&Object.keys(this.accumulatedMeanSquares).forEach(function(e){return t.accumulatedMeanSquares[e].dispose()}),null!=this.accumulatedMeanGrads&&this.centered&&Object.keys(this.accumulatedMeanGrads).forEach(function(e){return t.accumulatedMeanGrads[e].dispose()}),null!=this.accumulatedMoments&&Object.keys(this.accumulatedMoments).forEach(function(e){return t.accumulatedMoments[e].dispose()})},n.prototype.getConfig=function(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}},n.fromConfig=function(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)},n.className="RMSPropOptimizer",n}(Ih);yh(Fh);var Bh=function(){function t(){}return t.sgd=function(t){return new _h(t)},t.momentum=function(t,e,n){return void 0===n&&(n=!1),new Mh(t,e,n)},t.rmsprop=function(t,e,n,r,o){return void 0===e&&(e=.9),void 0===n&&(n=0),void 0===r&&(r=null),void 0===o&&(o=!1),new Fh(t,e,n,r,o)},t.adam=function(t,e,n,r){return void 0===t&&(t=.001),void 0===e&&(e=.9),void 0===n&&(n=.999),void 0===r&&(r=null),new Dh(t,e,n,r)},t.adadelta=function(t,e,n){return void 0===t&&(t=.001),void 0===e&&(e=.95),void 0===n&&(n=null),new Ah(t,e,n)},t.adamax=function(t,e,n,r,o){return void 0===t&&(t=.002),void 0===e&&(e=.9),void 0===n&&(n=.999),void 0===r&&(r=null),void 0===o&&(o=0),new Oh(t,e,n,r,o)},t.adagrad=function(t,e){return void 0===e&&(e=.1),new Th(t,e)},t}(),Ph={sgd:Bh.sgd,momentum:Bh.momentum,adadelta:Bh.adadelta,adagrad:Bh.adagrad,rmsprop:Bh.rmsprop,adamax:Bh.adamax,adam:Bh.adam},Lh="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:function(t){return t()};function Wh(){return new Promise(function(t){return Lh(function(){return t()})})}ht=mc;
//# sourceMappingURL=tf-core.esm.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/timers-browserify/main.js */ "./node_modules/node-libs-browser/node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-data/dist/tf-data.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-data/dist/tf-data.esm.js ***!
  \****************************************************************/
/*! exports provided: array, Dataset, zip, CSVDataset, TextLineDataset, csv, func, generator, webcam, FileDataSource, URLDataSource, version_data */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, process, Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "array", function() { return array; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Dataset", function() { return Dataset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return zip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSVDataset", function() { return CSVDataset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextLineDataset", function() { return TextLineDataset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csv", function() { return csv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "func", function() { return func; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generator", function() { return generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "webcam", function() { return webcam; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileDataSource", function() { return FileDataSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "URLDataSource", function() { return URLDataSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version_data", function() { return version; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var extendStatics=function(t,e){return(extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var r in e)e.hasOwnProperty(r)&&(t[r]=e[r])})(t,e)};function __extends(t,e){function r(){this.constructor=t}extendStatics(t,e),t.prototype=null===e?Object.create(e):(r.prototype=e.prototype,new r)}function __awaiter(t,e,r,n){return new(r||(r=Promise))(function(i,o){function a(t){try{s(n.next(t))}catch(t){o(t)}}function u(t){try{s(n.throw(t))}catch(t){o(t)}}function s(t){t.done?i(t.value):new r(function(e){e(t.value)}).then(a,u)}s((n=n.apply(t,e||[])).next())})}function __generator(t,e){var r,n,i,o,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:u(0),throw:u(1),return:u(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function u(o){return function(u){return function(o){if(r)throw new TypeError("Generator is already executing.");for(;a;)try{if(r=1,n&&(i=2&o[0]?n.return:o[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,o[1])).done)return i;switch(n=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return a.label++,{value:o[1],done:!1};case 5:a.label++,n=o[1],o=[0];continue;case 7:o=a.ops.pop(),a.trys.pop();continue;default:if(!(i=(i=a.trys).length>0&&i[i.length-1])&&(6===o[0]||2===o[0])){a=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){a.label=o[1];break}if(6===o[0]&&a.label<i[1]){a.label=i[1],i=o;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(o);break}i[2]&&a.ops.pop(),a.trys.pop();continue}o=e.call(t,a)}catch(t){o=[6,t],n=0}finally{r=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,u])}}}var commonjsGlobal="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function unwrapExports(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}function createCommonjsModule(t,e){return t(e={exports:{}},e.exports),e.exports}var alea=createCommonjsModule(function(t){!function(t,e,r){function n(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function i(t,e){var r=new function(t){var e,r=this,n=(e=4022871197,function(t){t=t.toString();for(var r=0;r<t.length;r++){var n=.02519603282416938*(e+=t.charCodeAt(r));n-=e=n>>>0,e=(n*=e)>>>0,e+=4294967296*(n-=e)}return 2.3283064365386963e-10*(e>>>0)});r.next=function(){var t=2091639*r.s0+2.3283064365386963e-10*r.c;return r.s0=r.s1,r.s1=r.s2,r.s2=t-(r.c=0|t)},r.c=1,r.s0=n(" "),r.s1=n(" "),r.s2=n(" "),r.s0-=n(t),r.s0<0&&(r.s0+=1),r.s1-=n(t),r.s1<0&&(r.s1+=1),r.s2-=n(t),r.s2<0&&(r.s2+=1),n=null}(t),i=e&&e.state,o=r.next;return o.int32=function(){return 4294967296*r.next()|0},o.double=function(){return o()+1.1102230246251565e-16*(2097152*o()|0)},o.quick=o,i&&("object"==typeof i&&n(i,r),o.state=function(){return n(r,{})}),o}e&&e.exports?e.exports=i:r&&r.amd?r(function(){return i}):this.alea=i}(0,t,!1)}),xor128=createCommonjsModule(function(t){!function(t,e,r){function n(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function i(t,e){var r=new function(t){var e=this,r="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:r+=t;for(var n=0;n<r.length+64;n++)e.x^=0|r.charCodeAt(n),e.next()}(t),i=e&&e.state,o=function(){return(r.next()>>>0)/4294967296};return o.double=function(){do{var t=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=r.next,o.quick=o,i&&("object"==typeof i&&n(i,r),o.state=function(){return n(r,{})}),o}e&&e.exports?e.exports=i:r&&r.amd?r(function(){return i}):this.xor128=i}(0,t,!1)}),xorwow=createCommonjsModule(function(t){!function(t,e,r){function n(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function i(t,e){var r=new function(t){var e=this,r="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:r+=t;for(var n=0;n<r.length+64;n++)e.x^=0|r.charCodeAt(n),n==r.length&&(e.d=e.x<<10^e.x>>>4),e.next()}(t),i=e&&e.state,o=function(){return(r.next()>>>0)/4294967296};return o.double=function(){do{var t=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=r.next,o.quick=o,i&&("object"==typeof i&&n(i,r),o.state=function(){return n(r,{})}),o}e&&e.exports?e.exports=i:r&&r.amd?r(function(){return i}):this.xorwow=i}(0,t,!1)}),xorshift7=createCommonjsModule(function(t){!function(t,e,r){function n(t,e){return e.x=t.x.slice(),e.i=t.i,e}function i(t,e){null==t&&(t=+new Date);var r=new function(t){var e=this;e.next=function(){var t,r,n=e.x,i=e.i;return t=n[i],r=(t^=t>>>7)^t<<24,r^=(t=n[i+1&7])^t>>>10,r^=(t=n[i+3&7])^t>>>3,r^=(t=n[i+4&7])^t<<7,t=n[i+7&7],r^=(t^=t<<13)^t<<9,n[i]=r,e.i=i+1&7,r},function(t,e){var r,n=[];if(e===(0|e))n[0]=e;else for(e=""+e,r=0;r<e.length;++r)n[7&r]=n[7&r]<<15^e.charCodeAt(r)+n[r+1&7]<<13;for(;n.length<8;)n.push(0);for(r=0;r<8&&0===n[r];++r);for(8==r?n[7]=-1:n[r],t.x=n,t.i=0,r=256;r>0;--r)t.next()}(e,t)}(t),i=e&&e.state,o=function(){return(r.next()>>>0)/4294967296};return o.double=function(){do{var t=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=r.next,o.quick=o,i&&(i.x&&n(i,r),o.state=function(){return n(r,{})}),o}e&&e.exports?e.exports=i:r&&r.amd?r(function(){return i}):this.xorshift7=i}(0,t,!1)}),xor4096=createCommonjsModule(function(t){!function(t,e,r){function n(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function i(t,e){null==t&&(t=+new Date);var r=new function(t){var e=this;e.next=function(){var t,r,n=e.w,i=e.X,o=e.i;return e.w=n=n+1640531527|0,r=i[o+34&127],t=i[o=o+1&127],r^=r<<13,t^=t<<17,r^=r>>>15,t^=t>>>12,r=i[o]=r^t,e.i=o,r+(n^n>>>16)|0},function(t,e){var r,n,i,o,a,u=[],s=128;for(e===(0|e)?(n=e,e=null):(e+="\0",n=0,s=Math.max(s,e.length)),i=0,o=-32;o<s;++o)e&&(n^=e.charCodeAt((o+32)%e.length)),0===o&&(a=n),n^=n<<10,n^=n>>>15,n^=n<<4,n^=n>>>13,o>=0&&(a=a+1640531527|0,i=0==(r=u[127&o]^=n+a)?i+1:0);for(i>=128&&(u[127&(e&&e.length||0)]=-1),i=127,o=512;o>0;--o)n=u[i+34&127],r=u[i=i+1&127],n^=n<<13,r^=r<<17,n^=n>>>15,r^=r>>>12,u[i]=n^r;t.w=a,t.X=u,t.i=i}(e,t)}(t),i=e&&e.state,o=function(){return(r.next()>>>0)/4294967296};return o.double=function(){do{var t=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=r.next,o.quick=o,i&&(i.X&&n(i,r),o.state=function(){return n(r,{})}),o}e&&e.exports?e.exports=i:r&&r.amd?r(function(){return i}):this.xor4096=i}(0,t,!1)}),tychei=createCommonjsModule(function(t){!function(t,e,r){function n(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function i(t,e){var r=new function(t){var e=this,r="";e.next=function(){var t=e.b,r=e.c,n=e.d,i=e.a;return t=t<<25^t>>>7^r,r=r-n|0,n=n<<24^n>>>8^i,i=i-t|0,e.b=t=t<<20^t>>>12^r,e.c=r=r-n|0,e.d=n<<16^r>>>16^i,e.a=i-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):r+=t;for(var n=0;n<r.length+20;n++)e.b^=0|r.charCodeAt(n),e.next()}(t),i=e&&e.state,o=function(){return(r.next()>>>0)/4294967296};return o.double=function(){do{var t=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},o.int32=r.next,o.quick=o,i&&("object"==typeof i&&n(i,r),o.state=function(){return n(r,{})}),o}e&&e.exports?e.exports=i:r&&r.amd?r(function(){return i}):this.tychei=i}(0,t,!1)}),seedrandom=createCommonjsModule(function(t){!function(e,r){var n,i=this,o=256,a=6,u="random",s=r.pow(o,a),c=r.pow(2,52),l=2*c,f=o-1;function h(t,h,v){var y=[],_=d(function t(e,r){var n,i=[],o=typeof e;if(r&&"object"==o)for(n in e)try{i.push(t(e[n],r-1))}catch(t){}return i.length?i:"string"==o?e:e+"\0"}((h=1==h?{entropy:!0}:h||{}).entropy?[t,m(e)]:null==t?function(){try{var t;return n&&(t=n.randomBytes)?t=t(o):(t=new Uint8Array(o),(i.crypto||i.msCrypto).getRandomValues(t)),m(t)}catch(t){var r=i.navigator,a=r&&r.plugins;return[+new Date,i,a,i.screen,m(e)]}}():t,3),y),w=new function(t){var e,r=t.length,n=this,i=0,a=n.i=n.j=0,u=n.S=[];r||(t=[r++]);for(;i<o;)u[i]=i++;for(i=0;i<o;i++)u[i]=u[a=f&a+t[i%r]+(e=u[i])],u[a]=e;(n.g=function(t){for(var e,r=0,i=n.i,a=n.j,u=n.S;t--;)e=u[i=f&i+1],r=r*o+u[f&(u[i]=u[a=f&a+e])+(u[a]=e)];return n.i=i,n.j=a,r})(o)}(y),g=function(){for(var t=w.g(a),e=s,r=0;t<c;)t=(t+r)*o,e*=o,r=w.g(1);for(;t>=l;)t/=2,e/=2,r>>>=1;return(t+r)/e};return g.int32=function(){return 0|w.g(4)},g.quick=function(){return w.g(4)/4294967296},g.double=g,d(m(w.S),e),(h.pass||v||function(t,e,n,i){return i&&(i.S&&p(i,w),t.state=function(){return p(w,{})}),n?(r[u]=t,e):t})(g,_,"global"in h?h.global:this==r,h.state)}function p(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function d(t,e){for(var r,n=t+"",i=0;i<n.length;)e[f&i]=f&(r^=19*e[f&i])+n.charCodeAt(i++);return m(e)}function m(t){return String.fromCharCode.apply(0,t)}if(r["seed"+u]=h,d(r.random(),e),t.exports){t.exports=h;try{n=__webpack_require__(/*! crypto */ "./node_modules/crypto-browserify/index.js")}catch(t){}}else 0}([],Math)});seedrandom.alea=alea,seedrandom.xor128=xor128,seedrandom.xorwow=xorwow,seedrandom.xorshift7=xorshift7,seedrandom.xor4096=xor4096,seedrandom.tychei=tychei;var seedrandom$1=seedrandom,seedrandom_1=seedrandom$1.alea;function deepMapInternal(t,e,r,n){if(void 0===r&&(r=new Map),void 0===n&&(n=new Set),null==t)return null;if(n.has(t))throw new Error("Circular references are not supported.");if(r.has(t))return r.get(t);var i=e(t);if(i.recurse&&null!==i.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(i.recurse){if(isIterable(t)){var o=Array.isArray(t)?[]:{};for(var a in n.add(t),t){var u=deepMapInternal(t[a],e,r,n);o[a]=u}return n.delete(t),o}throw new Error("Can't recurse into non-iterable type: "+t)}return r.set(t,i.value),i.value}function deepZip(t,e){return void 0===e&&(e=zipToList),deepZipInternal(t,e)}function deepZipInternal(t,e,r){void 0===r&&(r=new Set);var n=t[0];if(r.has(n))throw new Error("Circular references are not supported.");var i=e(t);if(i.recurse&&null!==i.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(i.recurse){if(isIterable(n)){var o=Array.isArray(n)?[]:{};r.add(n);var a=function(n){var i=deepZipInternal(t.map(function(t){return t[n]}),e,r);o[n]=i};for(var u in n)a(u);return r.delete(n),o}throw new Error("Can't recurse into non-iterable type: "+n)}return i.value}function zipToList(t){return null===t?null:isIterable(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}function deepMapAndAwaitAll(t,e){return __awaiter(this,void 0,void 0,function(){var r,n,i,o,a,u;return __generator(this,function(s){switch(s.label){case 0:r=new Map,deepMapInternal(t,e,r),n=0,i=Array.from(r.keys()),s.label=1;case 1:return n<i.length?(o=i[n],(a=r.get(o))instanceof Promise?[4,a]:[3,3]):[3,4];case 2:u=s.sent(),r.set(o,u),s.label=3;case 3:return n++,[3,1];case 4:return[2,deepMapInternal(t,e,r)]}})})}function isIterable(t){return null!=t&&(Array.isArray(t)||"object"==typeof t&&!(t instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]))}function canTensorify(t){return null==t||isPrimitive(t)||Array.isArray(t)||"object"==typeof t&&t instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]||_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].isTypedArray(t)}function isPrimitive(t){return null===t||"object"!=typeof t&&"function"!=typeof t}var RingBuffer=function(){function t(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}return t.prototype.wrap=function(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity},t.prototype.get=function(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]},t.prototype.set=function(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e},t.prototype.length=function(){var t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t},t.prototype.isFull=function(){return this.length()===this.capacity},t.prototype.isEmpty=function(){return 0===this.length()},t.prototype.push=function(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)},t.prototype.pushAll=function(t){for(var e=0,r=t;e<r.length;e++){var n=r[e];this.push(n)}},t.prototype.pop=function(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);var t=this.get(this.end);return this.set(this.end,void 0),t},t.prototype.unshift=function(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)},t.prototype.shift=function(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");var t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t},t.prototype.shuffleExcise=function(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");var e=this.wrap(this.begin+t),r=this.get(e);return this.set(e,this.pop()),r},t}(),GrowingRingBuffer=function(t){function e(){return t.call(this,e.INITIAL_CAPACITY)||this}return __extends(e,t),e.prototype.isFull=function(){return!1},e.prototype.push=function(e){t.prototype.isFull.call(this)&&this.expand(),t.prototype.push.call(this,e)},e.prototype.unshift=function(e){t.prototype.isFull.call(this)&&this.expand(),t.prototype.unshift.call(this,e)},e.prototype.expand=function(){for(var t=2*this.capacity,e=new Array(t),r=this.length(),n=0;n<r;n++)e[n]=this.get(this.wrap(this.begin+n));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r},e.INITIAL_CAPACITY=32,e}(RingBuffer);function iteratorFromItems(t){return new ArrayIterator(t)}function iteratorFromFunction(t){return new FunctionCallIterator(t)}function iteratorFromConcatenated(t,e){return new ChainedIterator(t,e)}function iteratorFromZipped(t,e){return void 0===e&&(e=ZipMismatchMode.FAIL),new ZipIterator(t,e)}var ZipMismatchMode,LazyIterator=function(){function t(){}return t.prototype.toArray=function(){return __awaiter(this,void 0,void 0,function(){var t,e;return __generator(this,function(r){switch(r.label){case 0:return t=[],[4,this.next()];case 1:e=r.sent(),r.label=2;case 2:return e.done?[3,4]:(t.push(e.value),[4,this.next()]);case 3:return e=r.sent(),[3,2];case 4:return[2,t]}})})},t.prototype.toArrayForTest=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r;return __generator(this,function(n){switch(n.label){case 0:return t=this.prefetch(100),e=[],[4,t.next()];case 1:r=n.sent(),n.label=2;case 2:return r.done?[3,4]:(e.push(r.value),[4,t.next()]);case 3:return r=n.sent(),[3,2];case 4:return[2,e]}})})},t.prototype.resolveFully=function(){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(e){switch(e.label){case 0:return[4,this.next()];case 1:t=e.sent(),e.label=2;case 2:return t.done?[3,4]:[4,this.next()];case 3:return t=e.sent(),[3,2];case 4:return[2]}})})},t.prototype.resolveWhile=function(t){return __awaiter(this,void 0,void 0,function(){var e,r;return __generator(this,function(n){switch(n.label){case 0:return[4,this.next()];case 1:e=n.sent(),r=t(e.value),n.label=2;case 2:return e.done||!r?[3,4]:[4,this.next()];case 3:return e=n.sent(),r=t(e.value),[3,2];case 4:return[2]}})})},t.prototype.handleErrors=function(t){return new ErrorHandlingLazyIterator(this,t)},t.prototype.filter=function(t){return new FilterIterator(this,t)},t.prototype.map=function(t){return new MapIterator(this,t)},t.prototype.mapAsync=function(t){return new AsyncMapIterator(this,t)},t.prototype.serialMapAsync=function(t){return new AsyncMapIterator(this,t).serial()},t.prototype.flatmap=function(t){return new FlatmapIterator(this,t)},t.prototype.forEachAsync=function(t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2,this.map(t).resolveFully()]})})},t.prototype.serialForEach=function(t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2,this.serialMapAsync(t).resolveWhile(function(t){return!0===t})]})})},t.prototype.rowMajorBatch=function(t,e){return void 0===e&&(e=!0),new RowMajorBatchIterator(this,t,e)},t.prototype.columnMajorBatch=function(t,e,r){return void 0===e&&(e=!0),void 0===r&&(r=zipToList),this.rowMajorBatch(t,e).map(function(t){return deepZip(t,r)})},t.prototype.concatenate=function(t,e){return new ChainedIterator(iteratorFromItems([this,t]),e)},t.prototype.take=function(t){return t<0||null==t?this:new TakeIterator(this,t)},t.prototype.skip=function(t){return t<0||null==t?this:new SkipIterator(this,t)},t.prototype.prefetch=function(t){return new PrefetchIterator(this,t)},t.prototype.shuffle=function(t,e){return new ShuffleIterator(this,t,e)},t.prototype.serial=function(){return new SerialIterator(this)},t}(),ArrayIterator=function(t){function e(e){var r=t.call(this)||this;return r.items=e,r.trav=0,r}return __extends(e,t),e.prototype.summary=function(){return"Array of "+this.items.length+" items"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t,e;return __generator(this,function(r){return this.trav>=this.items.length?[2,{value:null,done:!0}]:(t=this.items[this.trav],e=t instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clone"])(t):t,this.trav++,[2,{value:e,done:!1}])})})},e}(LazyIterator),FunctionCallIterator=function(t){function e(e){var r=t.call(this)||this;return r.nextFn=e,r}return __extends(e,t),e.prototype.summary=function(){return"Function call"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){try{return[2,this.nextFn()]}catch(t){throw t.message="Error thrown while iterating through a dataset: "+t.message,t}return[2]})})},e}(LazyIterator),SerialIterator=function(t){function e(e){var r=t.call(this)||this;return r.upstream=e,r.lastRead=Promise.resolve({value:null,done:!1}),r}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Serial"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(e){return this.lastRead=this.lastRead.then(function(){return t.serialNext()}),[2,this.lastRead]})})},e.prototype.serialNext=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return[2,this.upstream.next()]})})},e}(LazyIterator),SkipIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.maxCount=r,n.count=0,n.lastRead=Promise.resolve({value:null,done:!1}),n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Skip"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(e){return this.lastRead=this.lastRead.then(function(){return t.serialNext()}),[2,this.lastRead]})})},e.prototype.serialNext=function(){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(e){switch(e.label){case 0:return this.count++<this.maxCount?[4,this.upstream.next()]:[3,2];case 1:return(t=e.sent()).done?[2,t]:(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(t.value),[3,0]);case 2:return[2,this.upstream.next()]}})})},e}(LazyIterator),TakeIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.maxCount=r,n.count=0,n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Take"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return this.count++>=this.maxCount?[2,{value:null,done:!0}]:[2,this.upstream.next()]})})},e}(LazyIterator),RowMajorBatchIterator=function(t){function e(e,r,n){void 0===n&&(n=!0);var i=t.call(this)||this;return i.upstream=e,i.batchSize=r,i.enableSmallLastBatch=n,i.lastRead=Promise.resolve({value:null,done:!1}),i}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> RowMajorBatch"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(e){return this.lastRead=this.lastRead.then(function(){return t.serialNext()}),[2,this.lastRead]})})},e.prototype.serialNext=function(){return __awaiter(this,void 0,void 0,function(){var t,e;return __generator(this,function(r){switch(r.label){case 0:t=[],r.label=1;case 1:return t.length<this.batchSize?[4,this.upstream.next()]:[3,3];case 2:return(e=r.sent()).done?this.enableSmallLastBatch&&t.length>0?[2,{value:t,done:!1}]:[2,{value:null,done:!0}]:(t.push(e.value),[3,1]);case 3:return[2,{value:t,done:!1}]}})})},e}(LazyIterator),FilterIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.predicate=r,n.lastRead=Promise.resolve({value:null,done:!1}),n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Filter"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(e){return this.lastRead=this.lastRead.then(function(){return t.serialNext()}),[2,this.lastRead]})})},e.prototype.serialNext=function(){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(e){switch(e.label){case 0:return[4,this.upstream.next()];case 1:return(t=e.sent()).done||this.predicate(t.value)?[2,t]:(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(t.value),[3,0]);case 2:return[2]}})})},e}(LazyIterator),MapIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.transform=r,n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Map"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r,n,i,o,a;return __generator(this,function(u){switch(u.label){case 0:return[4,this.upstream.next()];case 1:if((t=u.sent()).done)return[2,{value:null,done:!0}];for(e=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].getTensorsInContainer(t.value),r=this.transform(t.value),n=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].getTensorsInContainer(r),i=0,o=e;i<o.length;i++)a=o[i],_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].isTensorInList(a,n)||a.dispose();return[2,{value:r,done:!1}]}})})},e}(LazyIterator),ErrorHandlingLazyIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.handler=r,n.count=0,n.lastRead=Promise.resolve({value:null,done:!1}),n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> handleErrors"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(e){return this.lastRead=this.lastRead.then(function(){return t.serialNext()}),[2,this.lastRead]})})},e.prototype.serialNext=function(){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(e){switch(e.label){case 0:e.label=1;case 1:return e.trys.push([1,3,,4]),[4,this.upstream.next()];case 2:return[2,e.sent()];case 3:return t=e.sent(),this.handler(t)?[3,4]:[2,{value:null,done:!0}];case 4:return[3,0];case 5:return[2]}})})},e}(LazyIterator),AsyncMapIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.transform=r,n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> AsyncMap"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r,n,i,o,a;return __generator(this,function(u){switch(u.label){case 0:return[4,this.upstream.next()];case 1:return(t=u.sent()).done?[2,{value:null,done:!0}]:(e=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].getTensorsInContainer(t.value),[4,this.transform(t.value)]);case 2:for(r=u.sent(),n=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].getTensorsInContainer(r),i=0,o=e;i<o.length;i++)a=o[i],_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].isTensorInList(a,n)||a.dispose();return[2,{value:r,done:!1}]}})})},e}(LazyIterator),OneToManyIterator=function(t){function e(){var e=t.call(this)||this;return e.outputQueue=new GrowingRingBuffer,e.lastRead=Promise.resolve({value:null,done:!1}),e}return __extends(e,t),e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(e){return this.lastRead=this.lastRead.then(function(){return t.serialNext()}),[2,this.lastRead]})})},e.prototype.serialNext=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return 0!==this.outputQueue.length()?[3,2]:[4,this.pump()];case 1:return t.sent()?[3,0]:[2,{value:null,done:!0}];case 2:return[2,{value:this.outputQueue.shift(),done:!1}]}})})},e}(LazyIterator),FlatmapIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.transform=r,n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Flatmap"},e.prototype.pump=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r,n,i,o,a;return __generator(this,function(u){switch(u.label){case 0:return[4,this.upstream.next()];case 1:if((t=u.sent()).done)return[2,!1];for(e=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].getTensorsInContainer(t.value),r=this.transform(t.value),n=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].getTensorsInContainer(r),this.outputQueue.pushAll(r),i=0,o=e;i<o.length;i++)a=o[i],_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"].isTensorInList(a,n)||a.dispose();return[2,!0]}})})},e}(OneToManyIterator),ChainedIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.baseErrorHandler=r,n.lastRead=null,n.iterator=null,n.moreIterators=e,n}return __extends(e,t),e.prototype.summary=function(){return"TODO: fill in upstream of chained summaries -> Chained"},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return this.lastRead=this.readFromChain(this.lastRead),[2,this.lastRead]})})},e.prototype.readFromChain=function(t){return __awaiter(this,void 0,void 0,function(){var e,r;return __generator(this,function(n){switch(n.label){case 0:return[4,t];case 1:return n.sent(),null!=this.iterator?[3,3]:[4,this.moreIterators.next()];case 2:if((e=n.sent()).done)return[2,{value:null,done:!0}];this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler)),n.label=3;case 3:return[4,this.iterator.next()];case 4:return(r=n.sent()).done?(this.iterator=null,[2,this.readFromChain(t)]):[2,r]}})})},e}(LazyIterator);!function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"}(ZipMismatchMode||(ZipMismatchMode={}));var ZipIterator=function(t){function e(e,r){void 0===r&&(r=ZipMismatchMode.FAIL);var n=t.call(this)||this;return n.iterators=e,n.mismatchMode=r,n.count=0,n.currentPromise=null,n}return __extends(e,t),e.prototype.summary=function(){return"{TODO: fill in upstream of zip summaries} -> Zip"},e.prototype.nextState=function(t){return __awaiter(this,void 0,void 0,function(){function e(t){return t instanceof LazyIterator?{value:t.next().then(function(t){return r++,t.done&&n++,t.value}),recurse:!1}:{value:null,recurse:!0}}var r,n,i;return __generator(this,function(o){switch(o.label){case 0:return[4,t];case 1:return o.sent(),r=0,n=0,[4,deepMapAndAwaitAll(this.iterators,e)];case 2:if(i=o.sent(),r===n)return[2,{value:null,done:!0}];if(n>0)switch(this.mismatchMode){case ZipMismatchMode.FAIL:throw new Error("Zipped streams should have the same length. Mismatched at element "+this.count+".");case ZipMismatchMode.SHORTEST:return[2,{value:null,done:!0}];case ZipMismatchMode.LONGEST:}return this.count++,[2,{value:i,done:!1}]}})})},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return this.currentPromise=this.nextState(this.currentPromise),[4,this.currentPromise];case 1:return[2,t.sent()]}})})},e}(LazyIterator),PrefetchIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.bufferSize=r,n.buffer=new RingBuffer(r),n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Prefetch"},e.prototype.refill=function(){for(;!this.buffer.isFull();){var t=this.upstream.next();this.buffer.push(t)}},e.prototype.next=function(){return this.refill(),this.buffer.shift()},e}(LazyIterator),ShuffleIterator=function(t){function e(e,r,n){var i=t.call(this,e,r)||this;return i.upstream=e,i.windowSize=r,i.upstreamExhausted=!1,i.random=seedrandom_1(n||_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].now().toString()),i.lastRead=Promise.resolve({value:null,done:!1}),i}return __extends(e,t),e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t=this;return __generator(this,function(e){return this.lastRead=this.lastRead.then(function(){return t.serialNext()}),[2,this.lastRead]})})},e.prototype.randomInt=function(t){return Math.floor(this.random()*t)},e.prototype.chooseIndex=function(){return this.randomInt(this.buffer.length())},e.prototype.serialNext=function(){return __awaiter(this,void 0,void 0,function(){var t,e;return __generator(this,function(r){switch(r.label){case 0:this.upstreamExhausted||this.refill(),r.label=1;case 1:return this.buffer.isEmpty()?[3,3]:(t=this.chooseIndex(),[4,this.buffer.shuffleExcise(t)]);case 2:return(e=r.sent()).done?(this.upstreamExhausted=!0,[3,1]):(this.refill(),[2,e]);case 3:return[2,{value:null,done:!0}]}})})},e}(PrefetchIterator),Dataset=function(){function t(){this.size=null}return t.prototype.batch=function(t,e){var r=this;void 0===e&&(e=!0);var n=this;return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(t>0,function(){return"batchSize needs to be positive, but it is\n      "+t}),datasetFromIteratorFn(function(){return __awaiter(r,void 0,void 0,function(){return __generator(this,function(r){switch(r.label){case 0:return[4,n.iterator()];case 1:return[2,r.sent().columnMajorBatch(t,e,deepBatchConcat)]}})})},this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t))},t.prototype.concatenate=function(t){var e=this,r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){var e,n;return __generator(this,function(i){switch(i.label){case 0:return[4,r.iterator()];case 1:return n=(e=i.sent()).concatenate,[4,t.iterator()];case 2:return[2,n.apply(e,[i.sent()])]}})})},this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null)},t.prototype.filter=function(t){var e=this,r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,r.iterator()];case 1:return[2,e.sent().filter(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return t(e)})})]}})})},this.size===1/0?1/0:null)},t.prototype.forEachAsync=function(t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,this.iterator()];case 1:return[2,e.sent().forEachAsync(t)]}})})},t.prototype.forEach=function(t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["deprecationWarn"])("dataset.forEach() is deprecated and will be removed. Please use dataset.forEachAsync() instead"),[2,this.forEachAsync(t)]})})},t.prototype.map=function(t){var e=this,r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,r.iterator()];case 1:return[2,e.sent().map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return t(e)})})]}})})},this.size)},t.prototype.mapAsync=function(t){var e=this,r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,r.iterator()];case 1:return[2,e.sent().mapAsync(t)]}})})},this.size)},t.prototype.prefetch=function(t){var e=this;if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");var r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,r.iterator()];case 1:return[2,e.sent().prefetch(t)]}})})},this.size)},t.prototype.repeat=function(t){var e=this,r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){var e=this;return __generator(this,function(n){return[2,iteratorFromConcatenated(iteratorFromFunction(function(){return __awaiter(e,void 0,void 0,function(){var t;return __generator(this,function(e){switch(e.label){case 0:return t={},[4,r.iterator()];case 1:return[2,(t.value=e.sent(),t.done=!1,t)]}})})}).take(t))]})})},null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null)},t.prototype.skip=function(t){var e=this,r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,r.iterator()];case 1:return[2,e.sent().skip(t)]}})})},null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null)},t.prototype.shuffle=function(t,e,r){var n=this;if(void 0===r&&(r=!0),null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting bufferSize to the dataset size ("+this.size+" elements)");var i=this,o=seedrandom_1(e||_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].now().toString());return datasetFromIteratorFn(function(){return __awaiter(n,void 0,void 0,function(){var e;return __generator(this,function(n){switch(n.label){case 0:return e=o.int32(),r&&(e+=o.int32()),[4,i.iterator()];case 1:return[2,n.sent().shuffle(t,e.toString())]}})})},this.size)},t.prototype.take=function(t){var e=this,r=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,r.iterator()];case 1:return[2,e.sent().take(t)]}})})},null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null)},t.prototype.toArray=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return[4,this.iterator()];case 1:return[2,t.sent().toArray()]}})})},t.prototype.toArrayForTest=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return[4,this.iterator()];case 1:return[2,t.sent().toArrayForTest()]}})})},t.MAX_BUFFER_SIZE=1e4,t}();function datasetFromIteratorFn(t,e){return void 0===e&&(e=null),new(function(r){function n(){var t=null!==r&&r.apply(this,arguments)||this;return t.size=e,t}return __extends(n,r),n.prototype.iterator=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2,t()]})})},n}(Dataset))}function array(t){var e=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(e){return[2,iteratorFromItems(t)]})})},t.length)}function zip(t){var e,r=this;if(!isIterable(t))throw new Error("The argument to zip() must be an object or array.");if(Array.isArray(t))for(var n=0;n<t.length;n++)e=null==e?t[n].size:Math.min(e,t[n].size);else if(t instanceof Object)for(var i in t)e=null==e?t[i].size:Math.min(e,t[i].size);return datasetFromIteratorFn(function(){return __awaiter(r,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return[4,deepMapAndAwaitAll(t,function(t){if(t instanceof Dataset)return{value:t.iterator(),recurse:!1};if(isIterable(t))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")})];case 1:return[2,iteratorFromZipped(e.sent(),ZipMismatchMode.SHORTEST)]}})})},e)}function deepBatchConcat(t){return null===t?null:canTensorify(t[0])?{value:batchConcat(t),recurse:!1}:{value:null,recurse:!0}}function batchConcat(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"])(t):Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor"])(t)}var TextLineDataset=function(t){function e(e){var r=t.call(this)||this;return r.input=e,r}return __extends(e,t),e.prototype.iterator=function(){return __awaiter(this,void 0,void 0,function(){var t,e;return __generator(this,function(r){switch(r.label){case 0:return[4,this.input.iterator()];case 1:return t=r.sent(),e=t.decodeUTF8(),[2,e.split("\n")]}})})},e}(Dataset),CODE_QUOTE='"',STATE_OUT=Symbol("out"),STATE_FIELD=Symbol("field"),STATE_QUOTE=Symbol("quote"),STATE_QUOTE_AFTER_QUOTE=Symbol("quoteafterquote"),STATE_WITHIN_QUOTE_IN_QUOTE=Symbol("quoteinquote"),CSVDataset=function(t){function e(e,r){var n=t.call(this)||this;return n.input=e,n.hasHeader=!0,n.fullColumnNames=null,n.columnNamesValidated=!1,n.columnConfigs=null,n.configuredColumnsOnly=!1,n.delimiter=",",n.delimWhitespace=!1,n.base=new TextLineDataset(e),r||(r={}),n.hasHeader=!1!==r.hasHeader,n.fullColumnNames=r.columnNames,n.columnConfigs=r.columnConfigs,n.configuredColumnsOnly=r.configuredColumnsOnly,r.delimWhitespace?(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null==r.delimiter,function(){return"Delimiter should not be provided when delimWhitespace is true."}),n.delimWhitespace=!0,n.delimiter=" "):n.delimiter=r.delimiter?r.delimiter:",",n}return __extends(e,t),e.prototype.columnNames=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return this.columnNamesValidated?[3,2]:[4,this.setColumnNames()];case 1:t.sent(),t.label=2;case 2:return[2,this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames]}})})},e.prototype.setColumnNames=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r,n,i,o,a=this;return __generator(this,function(u){switch(u.label){case 0:return[4,this.maybeReadHeaderLine()];case 1:if(t=u.sent(),!this.fullColumnNames&&!t)throw new Error("Column names must be provided if there is no header line.");if(this.fullColumnNames&&t&&_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(t.length===this.fullColumnNames.length,function(){return"The length of provided columnNames ("+a.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+t.length.toString()+")."}),this.fullColumnNames||(this.fullColumnNames=t),e=this.fullColumnNames.reduce(function(t,e){return t[e]=t[e]+1||1,t},{}),r=Object.keys(e).filter(function(t){return e[t]>1}),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(0===r.length,function(){return"Duplicate column names found: "+r.toString()}),this.columnConfigs)for(n=0,i=Object.keys(this.columnConfigs);n<i.length;n++)if(o=i[n],-1===this.fullColumnNames.indexOf(o))throw new Error('The key "'+o+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").");return this.columnNamesValidated=!0,[2]}})})},e.prototype.maybeReadHeaderLine=function(){return __awaiter(this,void 0,void 0,function(){var t,e;return __generator(this,function(r){switch(r.label){case 0:return this.hasHeader?[4,this.base.iterator()]:[3,3];case 1:return[4,r.sent().next()];case 2:if((t=r.sent()).done)throw new Error("No data was found for CSV parsing.");return e=t.value,[2,this.parseRow(e,!1)];case 3:return[2,null]}})})},e.prototype.iterator=function(){return __awaiter(this,void 0,void 0,function(){var t,e=this;return __generator(this,function(r){switch(r.label){case 0:return this.columnNamesValidated?[3,2]:[4,this.setColumnNames()];case 1:r.sent(),r.label=2;case 2:return[4,this.base.iterator()];case 3:return t=r.sent(),this.hasHeader&&(t=t.skip(1)),[2,t.map(function(t){return e.makeDataElement(t)})]}})})},e.prototype.makeDataElement=function(t){for(var e=this.parseRow(t),r={},n={},i=0;i<this.fullColumnNames.length;i++){var o=this.fullColumnNames[i],a=this.columnConfigs?this.columnConfigs[o]:null;if(!this.configuredColumnsOnly||a){var u=e[i],s=null;if(""===u)if(a&&void 0!==a.default)s=a.default;else{if(a&&(a.required||a.isLabel))throw new Error("Required column "+o+" is empty in this line: "+t);s=void 0}else{var c=Number(u);if(isNaN(c))s=a&&"bool"===a.dtype?this.getBoolean(u):u;else if(a&&a.dtype)switch(a.dtype){case"float32":s=c;break;case"int32":s=Math.floor(c);break;case"bool":s=this.getBoolean(u);break;default:s=c}else s=c}a&&a.isLabel?n[o]=s:r[o]=s}}return 0===Object.keys(n).length?r:{xs:r,ys:n}},e.prototype.getBoolean=function(t){return"1"===t||"true"===t.toLowerCase()?1:0},e.prototype.parseRow=function(t,e){void 0===e&&(e=!0);for(var r=[],n=0,i=t.length,o=STATE_OUT,a=0;a<i;a++)switch(o){case STATE_OUT:switch(t.charAt(a)){case CODE_QUOTE:n=a+1,o=STATE_QUOTE;break;case this.delimiter:if(n=a+1," "===this.delimiter&&this.delimWhitespace)break;r.push(""),o=STATE_OUT;break;default:o=STATE_FIELD,n=a}break;case STATE_FIELD:switch(t.charAt(a)){case this.delimiter:r.push(t.substring(n,a)),o=STATE_OUT,n=a+1}break;case STATE_QUOTE:switch(t.charAt(a)){case CODE_QUOTE:o=STATE_QUOTE_AFTER_QUOTE}break;case STATE_QUOTE_AFTER_QUOTE:switch(t.charAt(a)){case this.delimiter:r.push(t.substring(n,a-1)),o=STATE_OUT,n=a+1;break;case CODE_QUOTE:o=STATE_QUOTE;break;default:o=STATE_WITHIN_QUOTE_IN_QUOTE}break;case STATE_WITHIN_QUOTE_IN_QUOTE:switch(t.charAt(a)){case CODE_QUOTE:o=STATE_QUOTE}}if(o===STATE_QUOTE_AFTER_QUOTE?r.push(t.substring(n,i-1)):r.push(t.substring(n)),e&&r.length!==this.fullColumnNames.length)throw new Error("Invalid row in csv file. Should have "+this.fullColumnNames.length+" elements in a row, but got "+r);return r},e}(Dataset),environment=createCommonjsModule(function(t,e){Object.defineProperty(e,"__esModule",{value:!0});var r=function(){function t(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}return t.prototype.registerFlag=function(t,e,r){if(this.flagRegistry[t]={evaluationFn:e,setHook:r},null!=this.urlFlags[t]){var n=this.urlFlags[t];console.warn("Setting feature override from URL "+t+": "+n+"."),this.set(t,n)}},t.prototype.get=function(t){return t in this.flags?this.flags[t]:(this.flags[t]=this.evaluateFlag(t),this.flags[t])},t.prototype.getNumber=function(t){return this.get(t)},t.prototype.getBool=function(t){return this.get(t)},t.prototype.getFlags=function(){return this.flags},Object.defineProperty(t.prototype,"features",{get:function(){return this.flags},enumerable:!0,configurable:!0}),t.prototype.set=function(t,e){if(null==this.flagRegistry[t])throw new Error("Cannot set flag "+t+" as it has not been registered.");this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)},t.prototype.evaluateFlag=function(t){if(null==this.flagRegistry[t])throw new Error("Cannot evaluate flag '"+t+"': no evaluation function found.");return this.flagRegistry[t].evaluationFn()},t.prototype.setFlags=function(t){this.flags=Object.assign({},t)},t.prototype.reset=function(){this.flags={},this.urlFlags={},this.populateURLFlags()},t.prototype.populateURLFlags=function(){var t=this;if(void 0!==this.global&&void 0!==this.global.location&&void 0!==this.global.location.search){var e=n(this.global.location.search);if("tfjsflags"in e)e.tfjsflags.split(",").forEach(function(e){var r=e.split(":"),n=r[0],i=r[1];t.urlFlags[n]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error("Could not parse value flag value "+e+" for flag "+t+".")}(n,i)})}},t}();function n(t){var e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,function(t){for(var r=[],n=1;n<arguments.length;n++)r[n-1]=arguments[n];return function(t,e,r){t[decodeURIComponent(e)]=decodeURIComponent(r||"")}(e,r[0],r[1]),r.join("=")}),e}e.Environment=r,e.getQueryParams=n,e.setEnvironmentGlobal=function(t){e.ENV=t}});unwrapExports(environment);var environment_1=environment.Environment,environment_2=environment.getQueryParams,environment_3=environment.ENV,environment_4=environment.setEnvironmentGlobal,util$1=createCommonjsModule(function(t,e){function r(t){for(var e=t.length,r=0,n=0;e>0;)n=Math.random()*e|0,r=t[--e],t[e]=t[n],t[n]=r}function n(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function i(t,e){if(void 0===e&&(e=[]),null==e&&(e=[]),Array.isArray(t)||c(t))for(var r=0;r<t.length;++r)i(t[r],e);else e.push(t);return e}function o(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(var r=0;r<t.length;r++)if(t[r]!==e[r])return!1;return!0}function a(t){return t%1==0}function u(t,e){var r=e.length;return n((t=null==t?e.map(function(t,e){return e}):[].concat(t)).every(function(t){return t>=-r&&t<r}),function(){return"All values in axis param must be in range [-"+r+", "+r+") but got axis "+t}),n(t.every(function(t){return a(t)}),function(){return"All values in axis param must be integers but got axis "+t}),t.map(function(t){return t<0?r+t:t})}function s(t,e){for(var r=0;r<t.length;r++){var n=t[r];if(isNaN(n)||!isFinite(n))throw Error("A tensor of type "+e+" being uploaded contains "+n+".")}}function c(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function l(t){return"string"==typeof t||t instanceof String}function f(t){return"boolean"==typeof t}function h(t){return"number"==typeof t}function p(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error("Unknown data type "+e)}Object.defineProperty(e,"__esModule",{value:!0}),e.shuffle=r,e.clamp=function(t,e,r){return Math.max(t,Math.min(e,r))},e.nearestLargerEven=function(t){return t%2==0?t:t+1},e.sum=function(t){for(var e=0,r=0;r<t.length;r++)e+=t[r];return e},e.randUniform=function(t,e){var r=Math.random();return e*r+(1-r)*t},e.distSquared=function(t,e){for(var r=0,n=0;n<t.length;n++){var i=Number(t[n])-Number(e[n]);r+=i*i}return r},e.assert=n,e.assertShapesMatch=function(t,e,r){void 0===r&&(r=""),n(o(t,e),function(){return r+" Shapes "+t+" and "+e+" must match"})},e.assertNonNull=function(t){n(null!=t,function(){return"The input to the tensor constructor must be a non-null value."})},e.flatten=i,e.sizeFromShape=function(t){if(0===t.length)return 1;for(var e=t[0],r=1;r<t.length;r++)e*=t[r];return e},e.isScalarShape=function(t){return 0===t.length},e.arraysEqual=o,e.isInt=a,e.tanh=function(t){if(null!=Math.tanh)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;var e=Math.exp(2*t);return(e-1)/(e+1)},e.sizeToSquarishShape=function(t){var e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]},e.createShuffledIndices=function(t){for(var e=new Uint32Array(t),n=0;n<t;++n)e[n]=n;return r(e),e},e.rightPad=function(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)},e.repeatedTry=function(t,e,r){return void 0===e&&(e=function(t){return 0}),new Promise(function(n,i){var o=0,a=function(){if(t())n();else{var u=e(++o);null!=r&&o>=r?i():setTimeout(a,u)}};a()})},e.inferFromImplicitShape=function(t,e){for(var r=1,n=-1,i=0;i<t.length;++i)if(t[i]>=0)r*=t[i];else if(-1===t[i]){if(-1!==n)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+n+" and dim "+i);n=i}else if(t[i]<0)throw Error("Shapes can not be < 0. Found "+t[i]+" at dim "+i);if(-1===n){if(e>0&&e!==r)throw Error("Size("+e+") must match the product of shape "+t);return t}if(0===r)throw Error("Cannot infer the missing size in ["+t+"] when there are 0 elements");if(e%r!=0)throw Error("The implicit shape can't be a fractional number. Got "+e+" / "+r);var o=t.slice();return o[n]=e/r,o},e.parseAxisParam=u,e.squeezeShape=function(t,e){for(var r=[],n=[],i=null==e?null:u(e,t).sort(),o=0,a=0;a<t.length;++a){if(null!=i){if(i[o]===a&&1!==t[a])throw new Error("Can't squeeze axis "+a+" since its dim '"+t[a]+"' is not 1");(null==i[o]||i[o]>a)&&1===t[a]&&(r.push(t[a]),n.push(a)),i[o]<=a&&o++}1!==t[a]&&(r.push(t[a]),n.push(a))}return{newShape:r,keptDims:n}},e.getTypedArrayFromDType=function(t,e){var r=null;if(null==t||"float32"===t)r=new Float32Array(e);else if("int32"===t)r=new Int32Array(e);else{if("bool"!==t)throw new Error("Unknown data type "+t);r=new Uint8Array(e)}return r},e.getArrayFromDType=function(t,e){var r=null;if(null==t||"float32"===t)r=new Float32Array(e);else if("int32"===t)r=new Int32Array(e);else if("bool"===t)r=new Uint8Array(e);else{if("string"!==t)throw new Error("Unknown data type "+t);r=new Array(e)}return r},e.checkComputationForErrors=function(t,e,r){if("float32"===e)for(var n=0;n<t.length;n++){var i=t[n];if(isNaN(i)||!isFinite(i))throw Error("The result of the '"+r+"' is "+i+".")}},e.checkConversionForErrors=s,e.hasEncodingLoss=function(t,e){return!("complex64"===e||"float32"===e&&"complex64"!==t||"int32"===e&&"float32"!==t&&"complex64"!==t||"bool"===e&&"bool"===t)},e.isTypedArray=c,e.bytesPerElement=function(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error("Unknown dtype "+t)},e.bytesFromStringArray=function(t){if(null==t)return 0;var e=0;return t.forEach(function(t){return e+=2*t.length}),e},e.isString=l,e.isBoolean=f,e.isNumber=h,e.inferDtype=function t(e){return Array.isArray(e)?t(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array?"int32":h(e)?"float32":l(e)?"string":f(e)?"bool":"float32"},e.isFunction=function(t){return!!(t&&t.constructor&&t.call&&t.apply)},e.nearestDivisor=function(t,e){for(var r=e;r<t;++r)if(t%r==0)return r;return t},e.computeStrides=function(t){var e=t.length;if(e<2)return[];var r=new Array(e-1);r[e-2]=t[e-1];for(var n=e-3;n>=0;--n)r[n]=r[n+1]*t[n+1];return r},e.toTypedArray=function(t,e,r){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=i(t)),r&&s(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){for(var n=new Uint8Array(t.length),o=0;o<n.length;++o)0!==Math.round(t[o])&&(n[o]=1);return n}throw new Error("Unknown data type "+e)},e.toNestedArray=function(t,e){if(0===t.length)return e[0];var r=t.reduce(function(t,e){return t*e});if(0===r)return[];if(r!==e.length)throw new Error("["+t+"] does not match the input size.");return function t(e,r,n){var i=new Array;if(1===r.length)for(var o=r[0],a=0;a<o;a++)i[a]=n[e+a];else{o=r[0];var u=r.slice(1),s=u.reduce(function(t,e){return t*e});for(a=0;a<o;a++)i[a]=t(e+a*s,u,n)}return i}(0,t,e)},e.makeOnesTypedArray=function(t,e){for(var r=p(t,e),n=0;n<r.length;n++)r[n]=1;return r},e.makeZerosTypedArray=p,e.now=function(){if("undefined"!=typeof performance)return performance.now();if("undefined"!=typeof process){var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}throw new Error("Cannot measure time in this environment. You should run tf.js in the browser or in Node.js")},e.assertNonNegativeIntegerDimensions=function(t){t.forEach(function(e){n(Number.isInteger(e)&&e>=0,function(){return"Tensor must have a shape comprised of positive integers but got shape ["+t+"]."})})};var d=function(){if(null!=environment.ENV.global.fetch)return environment.ENV.global.fetch;if(environment.ENV.get("IS_NODE"))return e.getNodeFetch.fetchImport();throw new Error("Unable to find the fetch() method. Please add your own fetch() function to the global namespace.")};e.getNodeFetch={fetchImport:function(){return __webpack_require__(/*! node-fetch */ 5)}},e.fetch=function(t,r){return null==e.systemFetch&&(e.systemFetch=d()),e.systemFetch(t,r)}});unwrapExports(util$1);var util_1=util$1.shuffle,util_2=util$1.clamp,util_3=util$1.nearestLargerEven,util_4=util$1.sum,util_5=util$1.randUniform,util_6=util$1.distSquared,util_7=util$1.assert,util_8=util$1.assertShapesMatch,util_9=util$1.assertNonNull,util_10=util$1.flatten,util_11=util$1.sizeFromShape,util_12=util$1.isScalarShape,util_13=util$1.arraysEqual,util_14=util$1.isInt,util_15=util$1.tanh,util_16=util$1.sizeToSquarishShape,util_17=util$1.createShuffledIndices,util_18=util$1.rightPad,util_19=util$1.repeatedTry,util_20=util$1.inferFromImplicitShape,util_21=util$1.parseAxisParam,util_22=util$1.squeezeShape,util_23=util$1.getTypedArrayFromDType,util_24=util$1.getArrayFromDType,util_25=util$1.checkComputationForErrors,util_26=util$1.checkConversionForErrors,util_27=util$1.hasEncodingLoss,util_28=util$1.isTypedArray,util_29=util$1.bytesPerElement,util_30=util$1.bytesFromStringArray,util_31=util$1.isString,util_32=util$1.isBoolean,util_33=util$1.isNumber,util_34=util$1.inferDtype,util_35=util$1.isFunction,util_36=util$1.nearestDivisor,util_37=util$1.computeStrides,util_38=util$1.toTypedArray,util_39=util$1.toNestedArray,util_40=util$1.makeOnesTypedArray,util_41=util$1.makeZerosTypedArray,util_42=util$1.now,util_43=util$1.assertNonNegativeIntegerDimensions,util_44=util$1.getNodeFetch,util_45=util$1.systemFetch,util_46=util$1.fetch,WebcamIterator=function(t){function e(e,r){var n=t.call(this)||this;if(n.webcamVideoElement=e,n.webcamConfig=r,n.isClosed=!0,n.resize=!1,n.needToResize())if(n.resize=!0,n.cropSize=[n.webcamConfig.resizeHeight,n.webcamConfig.resizeWidth],n.cropBoxInd=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])([0],"int32"),n.webcamConfig.centerCrop){var i=1*n.webcamConfig.resizeWidth/n.webcamVideoElement.width,o=1*n.webcamConfig.resizeHeight/n.webcamVideoElement.height,a=(1-i)/2,u=(1-o)/2,s=a+i,c=o+u;n.cropBox=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor2d"])([u,a,c,s],[1,4])}else n.cropBox=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor2d"])([0,0,1,1],[1,4]);return n}return __extends(e,t),e.prototype.summary=function(){return"webcam"},e.create=function(t,r){return void 0===r&&(r={}),__awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(i){switch(i.label){case 0:if(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].get("IS_NODE"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!r.resizeWidth||!r.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=r.resizeWidth,t.height=r.resizeHeight}return[4,(n=new e(t,r)).start()];case 1:return i.sent(),[2,n]}})})},e.prototype.start=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r=this;return __generator(this,function(n){switch(n.label){case 0:this.webcamConfig.facingMode&&util_7("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,function(){return"Invalid webcam facing mode: "+r.webcamConfig.facingMode+". Please provide 'user' or 'environment'"}),n.label=1;case 1:return n.trys.push([1,3,,4]),t=this,[4,navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})];case 2:return t.stream=n.sent(),[3,4];case 3:throw(e=n.sent()).message="Error thrown while initializing video stream: "+e.message,e;case 4:if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,[2,new Promise(function(t){r.webcamVideoElement.onloadedmetadata=function(){t()}})]}})})},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(e){if(this.isClosed)return[2,{value:null,done:!0}];try{t=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["browser"].fromPixels(this.webcamVideoElement)}catch(t){throw new Error("Error thrown converting video to pixels: "+JSON.stringify(t))}if(!this.resize)return[2,{value:t,done:!1}];try{return[2,{value:this.cropAndResizeFrame(t),done:!1}]}catch(t){throw new Error("Error thrown cropping the video: "+t.message)}return[2]})})},e.prototype.needToResize=function(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)},e.prototype.cropAndResizeFrame=function(t){var e,r=t.toFloat().expandDims(0),n=(e=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"].cropAndResize(r,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear")).shape;return e.reshape(n.slice(1))},e.prototype.capture=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return[4,this.next()];case 1:return[2,t.sent().value]}})})},e.prototype.stop=function(){this.stream.getTracks().forEach(function(t){return t.stop()});try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0},e.prototype.toArray=function(){throw new Error("Can not convert infinite video stream to array.")},e}(LazyIterator),DataSource=function(){return function(){}}(),StringIterator=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return __extends(e,t),e.prototype.split=function(t){return new SplitIterator(this,t)},e}(LazyIterator),SplitIterator=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.impl=new SplitIteratorImpl(e,r),n}return __extends(e,t),e.prototype.summary=function(){return this.impl.summary()},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return[2,this.impl.next()]})})},e}(StringIterator),SplitIteratorImpl=function(t){function e(e,r){var n=t.call(this)||this;return n.upstream=e,n.separator=r,n.carryover="",n}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Split('"+this.separator+"')"},e.prototype.pump=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r,n,i;return __generator(this,function(o){switch(o.label){case 0:return[4,this.upstream.next()];case 1:if((t=o.sent()).done)return""===this.carryover?[2,!1]:(this.outputQueue.push(this.carryover),this.carryover="",[2,!0]);for((e=t.value.split(this.separator))[0]=this.carryover+e[0],r=0,n=e.slice(0,-1);r<n.length;r++)i=n[r],this.outputQueue.push(i);return this.carryover=e[e.length-1],[2,!0]}})})},e}(OneToManyIterator),ByteChunkIterator=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return __extends(e,t),e.prototype.decodeUTF8=function(){return new Utf8Iterator(this)},e}(LazyIterator),Utf8Iterator=function(t){function e(e){var r=t.call(this)||this;return r.upstream=e,r.impl=new Utf8IteratorImpl(e),r}return __extends(e,t),e.prototype.summary=function(){return this.impl.summary()},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return[2,this.impl.next()]})})},e}(StringIterator),Utf8IteratorImpl=function(t){function e(e){var r=t.call(this)||this;if(r.upstream=e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].get("IS_BROWSER"))r.decoder=new TextDecoder("utf-8");else{var n=__webpack_require__(/*! string_decoder */ 6).StringDecoder;r.decoder=new n("utf8")}return r}return __extends(e,t),e.prototype.summary=function(){return this.upstream.summary()+" -> Utf8"},e.prototype.pump=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r;return __generator(this,function(n){switch(n.label){case 0:return[4,this.upstream.next()];case 1:return(t=n.sent()).done?[2,!1]:(e=t.value,r=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].get("IS_BROWSER")?this.decoder.decode(e,{stream:!0}):this.decoder.write(Buffer.from(e.buffer)),this.outputQueue.push(r),[2,!0])}})})},e}(OneToManyIterator),FileChunkIterator=function(t){function e(e,r){void 0===r&&(r={});var n=t.call(this)||this;return n.file=e,n.options=r,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(e instanceof Uint8Array||!!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),function(){return"FileChunkIterator only supports File, Blob and Uint8Array right now."}),n.offset=r.offset||0,n.chunkSize=r.chunkSize||1048576,n}return __extends(e,t),e.prototype.summary=function(){return"FileChunks "+this.file},e.prototype.next=function(){return __awaiter(this,void 0,void 0,function(){var t,e,r=this;return __generator(this,function(n){switch(n.label){case 0:return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?[2,{value:null,done:!0}]:(t=new Promise(function(t,e){var n=r.offset+r.chunkSize;if(r.file instanceof Uint8Array)t(new Uint8Array(r.file.slice(r.offset,n)));else{var i=new FileReader;i.onload=function(r){var n=i.result;if(n instanceof ArrayBuffer&&(n=new Uint8Array(n)),!(n instanceof Uint8Array))return e(new TypeError("FileReader returned unknown type."));t(n)},i.onabort=function(t){return e(new Error("Aborted"))},i.onerror=function(t){return e(new Error(t.type))};var o=r.file.slice(r.offset,n);i.readAsArrayBuffer(o)}r.offset=n}),e={},[4,t]);case 1:return[2,(e.value=n.sent(),e.done=!1,e)]}})})},e}(ByteChunkIterator);function urlChunkIterator(t,e){return void 0===e&&(e={}),__awaiter(this,void 0,void 0,function(){var r,n,i,o;return __generator(this,function(a){switch(a.label){case 0:return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].get("IS_BROWSER")?[4,fetch(t)]:[3,5];case 1:return(r=a.sent()).ok?[4,r.blob()]:[3,3];case 2:return n=a.sent(),[2,new FileChunkIterator(n,e)];case 3:throw new Error(r.statusText);case 4:return[3,9];case 5:if(i=__webpack_require__(/*! node-fetch */ 5),"string"!=typeof t)throw new Error("URL must be a string. Request objects are not supported in the node.js environment yet.");return[4,i(t)];case 6:return(r=a.sent()).ok?[4,r.buffer()]:[3,8];case 7:return o=a.sent(),[2,new FileChunkIterator(o,e)];case 8:throw new Error(r.statusText);case 9:return[2]}})})}function isLocalPath(t){return"string"==typeof t&&"file://"===t.substr(0,7)}var FileDataSource=function(t){function e(e,r){void 0===r&&(r={});var n=t.call(this)||this;return n.input=e,n.options=r,n}return __extends(e,t),e.prototype.iterator=function(){return __awaiter(this,void 0,void 0,function(){var t;return __generator(this,function(e){return isLocalPath(this.input)&&_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"].get("IS_NODE")&&(t=__webpack_require__(/*! fs */ 7),this.input=t.readFileSync(this.input.substr(7))),[2,new FileChunkIterator(this.input,this.options)]})})},e}(DataSource),URLDataSource=function(t){function e(e,r){void 0===r&&(r={});var n=t.call(this)||this;return n.url=e,n.fileOptions=r,n}return __extends(e,t),e.prototype.iterator=function(){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){return isLocalPath(this.url)?[2,new FileDataSource(this.url,this.fileOptions).iterator()]:[2,urlChunkIterator(this.url,this.fileOptions)]})})},e}(DataSource);function csv(t,e){return void 0===e&&(e={}),new CSVDataset(new URLDataSource(t),e)}function func(t){var e=this,r=iteratorFromFunction(t);return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){return __generator(this,function(t){return[2,r]})})})}function generator(t){var e=this;return datasetFromIteratorFn(function(){return __awaiter(e,void 0,void 0,function(){var e;return __generator(this,function(r){switch(r.label){case 0:return[4,t()];case 1:return e=r.sent(),[2,iteratorFromFunction(function(){return e.next()})]}})})})}function webcam(t,e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(r){return[2,WebcamIterator.create(t,e)]})})}var version="1.1.2";
//# sourceMappingURL=tf-data.esm.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@tensorflow/tfjs-layers/dist/tf-layers.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-layers/dist/tf-layers.esm.js ***!
  \********************************************************************/
/*! exports provided: constraints, initializers, layers, metrics, models, regularizers, CallbackList, CustomCallback, History, Callback, callbacks, EarlyStopping, InputSpec, SymbolicTensor, LayersModel, input, loadLayersModel, model, registerCallbackConstructor, sequential, RNN, Sequential, LayerVariable, version_layers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "constraints", function() { return exports_constraints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initializers", function() { return exports_initializers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "layers", function() { return exports_layers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "metrics", function() { return exports_metrics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "models", function() { return exports_models; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "regularizers", function() { return exports_regularizers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CallbackList", function() { return CallbackList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomCallback", function() { return CustomCallback; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "History", function() { return History; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Callback", function() { return Callback; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "callbacks", function() { return callbacks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EarlyStopping", function() { return EarlyStopping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InputSpec", function() { return InputSpec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SymbolicTensor", function() { return SymbolicTensor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayersModel", function() { return LayersModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "input", function() { return input; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadLayersModel", function() { return loadLayersModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "model", function() { return model; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerCallbackConstructor", function() { return registerCallbackConstructor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sequential", function() { return sequential; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RNN", function() { return RNN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sequential", function() { return Sequential; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LayerVariable", function() { return LayerVariable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version_layers", function() { return version; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var extendStatics=function(e,t){return(extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(e,t)};function __extends(e,t){function n(){this.constructor=e}extendStatics(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}var _epsilon,__assign=function(){return(__assign=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var i in t=arguments[n])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)};function __awaiter(e,t,n,r){return new(n||(n=Promise))(function(i,a){function o(e){try{l(r.next(e))}catch(e){a(e)}}function s(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){e.done?i(e.value):new n(function(t){t(e.value)}).then(o,s)}l((r=r.apply(e,t||[])).next())})}function __generator(e,t){var n,r,i,a,o={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return a={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function s(a){return function(s){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,r&&(i=2&a[0]?r.return:a[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,a[1])).done)return i;switch(r=0,i&&(a=[2&a[0],i.value]),a[0]){case 0:case 1:i=a;break;case 4:return o.label++,{value:a[1],done:!1};case 5:o.label++,r=a[1],a=[0];continue;case 7:a=o.ops.pop(),o.trys.pop();continue;default:if(!(i=(i=o.trys).length>0&&i[i.length-1])&&(6===a[0]||2===a[0])){o=0;continue}if(3===a[0]&&(!i||a[1]>i[0]&&a[1]<i[3])){o.label=a[1];break}if(6===a[0]&&o.label<i[1]){o.label=i[1],i=a;break}if(i&&o.label<i[2]){o.label=i[2],o.ops.push(a);break}i[2]&&o.ops.pop(),o.trys.pop();continue}a=t.call(e,o)}catch(e){a=[6,e],r=0}finally{n=i=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,s])}}}function epsilon(){return null==_epsilon&&(_epsilon=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["backend"])().epsilon()),_epsilon}function imageDataFormat(){return"channelsLast"}var AttributeError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error),RuntimeError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error),ValueError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error),NotImplementedError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error),AssertionError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error),IndexError=function(e){function t(n){var r=e.call(this,n)||this;return Object.setPrototypeOf(r,t.prototype),r}return __extends(t,e),t}(Error);function pyListRepeat(e,t){if(Array.isArray(e)){for(var n=[],r=0;r<t;r++)n=n.concat(e);return n}return(n=new Array(t)).fill(e),n}function assert(e,t){if(!e)throw new AssertionError(t)}function count(e,t){for(var n=0,r=0,i=e;r<i.length;r++){i[r]===t&&n++}return n}function singletonOrArray(e){return 1===e.length?e[0]:e}function toList(e){return Array.isArray(e)?e:[e]}function toSnakeCase(e){var t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function toCamelCase(e){return e.length<=1?e:-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,function(e,t){return t.toUpperCase()})}var _GLOBAL_CUSTOM_OBJECTS={};function serializeKerasObject(e){if(null===e||void 0===e)return null;var t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function convertNDArrayScalarsInConfig(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach(function(e){return convertNDArrayScalarsInConfig(e)});else for(var t=0,n=Object.keys(e);t<n.length;t++){var r=n[t],i=e[r];null!=i&&"object"==typeof i&&(Array.isArray(i)||"ndarray"!==i.type||"number"!=typeof i.value?convertNDArrayScalarsInConfig(i):e[r]=i.value)}}function deserializeKerasObject(e,t,n,r,i){var a,o,s;if(void 0===t&&(t={}),void 0===n&&(n={}),void 0===r&&(r="object"),void 0===i&&(i=!1),"string"==typeof e){var l=e,u=void 0;if(l in n)u=n[l];else if(l in _GLOBAL_CUSTOM_OBJECTS)u=_GLOBAL_CUSTOM_OBJECTS[l];else if(null==(u=t[l]))throw new ValueError("Unknown "+r+": "+e+". This may be due to one of the following reasons:\n1. The "+r+" is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom "+r+" is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");return u}var c=e;if(null==c.className||null==c.config)throw new ValueError(r+": Improper config format: "+JSON.stringify(c)+".\n'className' and 'config' must set.");var p=c.className,h=void 0,d=void 0;if(p in n?(h=(a=n[p])[0],d=a[1]):p in _GLOBAL_CUSTOM_OBJECTS?(h=(o=_GLOBAL_CUSTOM_OBJECTS.className)[0],d=o[1]):p in t&&(h=(s=t[p])[0],d=s[1]),null==h)throw new ValueError("Unknown "+r+": "+p+". This may be due to one of the following reasons:\n1. The "+r+" is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom "+r+" is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().");if(null!=d){for(var f={},g=0,m=Object.keys(_GLOBAL_CUSTOM_OBJECTS);g<m.length;g++){f[S=m[g]]=_GLOBAL_CUSTOM_OBJECTS[S]}for(var y=0,v=Object.keys(n);y<v.length;y++){f[S=v[y]]=n[S]}c.config.customObjects=f;for(var b=__assign({},_GLOBAL_CUSTOM_OBJECTS),w=0,z=Object.keys(n);w<z.length;w++){var S=z[w];_GLOBAL_CUSTOM_OBJECTS[S]=n[S]}convertNDArrayScalarsInConfig(c.config);var I=d(h,c.config,n,i);return _GLOBAL_CUSTOM_OBJECTS=__assign({},b),I}b=__assign({},_GLOBAL_CUSTOM_OBJECTS);for(var A=0,_=Object.keys(n);A<_.length;A++){S=_[A];_GLOBAL_CUSTOM_OBJECTS[S]=n[S]}I=new h(c.config);return _GLOBAL_CUSTOM_OBJECTS=__assign({},b),I}function numberCompare(e,t){return e<t?-1:e>t?1:0}function reverseNumberCompare(e,t){return-1*numberCompare(e,t)}function unique(e){if(null==e)return e;for(var t=[],n=0,r=e;n<r.length;n++){var i=r[n];-1===t.indexOf(i)&&t.push(i)}return t}function isObjectEmpty(e){if(null==e)throw new ValueError("Invalid value in obj: "+JSON.stringify(e));for(var t in e)if(e.hasOwnProperty(t))return!1;return!0}function checkStringTypeUnionValue(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new ValueError(n+" is not a valid "+t+".  Valid values are "+e+" or null/undefined.")}function checkArrayTypeAndLength(e,t,n,r){return void 0===n&&(n=0),void 0===r&&(r=1/0),assert(n>=0),assert(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(function(e){return typeof e===t})}function assertPositiveInteger(e,t){Array.isArray(e)?(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(e.length>0,function(){return t+" is unexpectedly an empty array."}),e.forEach(function(e,n){return assertPositiveInteger(e,"element "+(n+1)+" of "+t)})):_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(Number.isInteger(e)&&e>0,function(){return"Expected "+t+" to be a positive integer, but got "+formatAsFriendlyString(e)+"."})}function formatAsFriendlyString(e){return null===e?"null":Array.isArray(e)?"["+e.map(function(e){return formatAsFriendlyString(e)}).join(",")+"]":"string"==typeof e?'"'+e+'"':""+e}function debounce(e,t){var n,r=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].now();return function(){for(var i=[],a=0;a<arguments.length;a++)i[a]=arguments[a];var o=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].now();return o-r<t?n:(r=o,n=e.apply(void 0,i))}}function calcL2Norms(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mulStrict"])(e,e),t,!0))})}var Constraint=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.getConfig=function(){return{}},t}(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].Serializable),MaxNorm=function(e){function t(t){var n=e.call(this)||this;return n.defaultMaxValue=2,n.defaultAxis=0,n.maxValue=null!=t.maxValue?t.maxValue:n.defaultMaxValue,n.axis=null!=t.axis?t.axis:n.defaultAxis,n}return __extends(t,e),t.prototype.apply=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=calcL2Norms(e,t.axis),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(n,0,t.maxValue);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(r,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(epsilon(),n)))})},t.prototype.getConfig=function(){return{maxValue:this.maxValue,axis:this.axis}},t.className="MaxNorm",t}(Constraint);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(MaxNorm);var UnitNorm=function(e){function t(t){var n=e.call(this)||this;return n.defaultAxis=0,n.axis=null!=t.axis?t.axis:n.defaultAxis,n}return __extends(t,e),t.prototype.apply=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(epsilon(),calcL2Norms(e,t.axis)))})},t.prototype.getConfig=function(){return{axis:this.axis}},t.className="UnitNorm",t}(Constraint);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(UnitNorm);var NonNeg=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"])(e)},t.className="NonNeg",t}(Constraint);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(NonNeg);var MinMaxNorm=function(e){function t(t){var n=e.call(this)||this;return n.defaultMinValue=0,n.defaultMaxValue=1,n.defaultRate=1,n.defaultAxis=0,n.minValue=null!=t.minValue?t.minValue:n.defaultMinValue,n.maxValue=null!=t.maxValue?t.maxValue:n.defaultMaxValue,n.rate=null!=t.rate?t.rate:n.defaultRate,n.axis=null!=t.axis?t.axis:n.defaultAxis,n}return __extends(t,e),t.prototype.apply=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=calcL2Norms(e,t.axis),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(t.rate,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(n,t.minValue,t.maxValue)),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(1-t.rate,n));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(r,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(epsilon(),n)))})},t.prototype.getConfig=function(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}},t.className="MinMaxNorm",t}(Constraint);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(MinMaxNorm);var CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function serializeConstraint(e){return serializeKerasObject(e)}function deserializeConstraint(e,t){return void 0===t&&(t={}),deserializeKerasObject(e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].SerializationMap.getMap().classNameMap,t,"constraint")}function getConstraint(e){return null==e?null:"string"==typeof e?deserializeConstraint({className:e in CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP?CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[e]:e,config:{}}):e instanceof Constraint?e:deserializeConstraint(e)}function maxNorm(e){return new MaxNorm(e)}function unitNorm(e){return new UnitNorm(e)}function nonNeg(){return new NonNeg}function minMaxNorm(e){return new MinMaxNorm(e)}var exports_constraints=Object.freeze({maxNorm:maxNorm,unitNorm:unitNorm,nonNeg:nonNeg,minMaxNorm:minMaxNorm}),VALID_DATA_FORMAT_VALUES=["channelsFirst","channelsLast"],VALID_PADDING_MODE_VALUES=["valid","same","causal"],VALID_POOL_MODE_VALUES=["max","avg"],VALID_BIDIRECTIONAL_MERGE_MODES=["sum","mul","concat","ave"],nameMap=new Map;function checkDataFormat(e){checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES,"DataFormat",e)}function checkPaddingMode(e){checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES,"PaddingMode",e)}function checkPoolMode(e){checkStringTypeUnionValue(VALID_POOL_MODE_VALUES,"PoolMode",e)}var _nameScopeStack=[],_nameScopeDivider="/";function nameScope(e,t){_nameScopeStack.push(e);try{var n=t();return _nameScopeStack.pop(),n}catch(e){throw _nameScopeStack.pop(),e}}function currentNameScopePrefix(){return 0===_nameScopeStack.length?"":_nameScopeStack.join(_nameScopeDivider)+_nameScopeDivider}function getScopedTensorName(e){if(!isValidTensorName(e))throw new Error("Not a valid tensor name: '"+e+"'");return currentNameScopePrefix()+e}function getUniqueTensorName(e){if(!isValidTensorName(e))throw new Error("Not a valid tensor name: '"+e+"'");nameMap.has(e)||nameMap.set(e,0);var t=nameMap.get(e);if(nameMap.set(e,nameMap.get(e)+1),t>0){var n=e+"_"+t;return nameMap.set(n,1),n}return e}var tensorNameRegex=new RegExp(/^[A-Za-z][-A-Za-z0-9\._\/]*$/);function isValidTensorName(e){return!!e.match(tensorNameRegex)}function isInteger(e){return e===parseInt(e.toString(),10)}function arrayProd(e,t,n){null==t&&(t=0),null==n&&(n=e.length);for(var r=1,i=t;i<n;++i)r*=e[i];return r}function toArray1D(e){return e=Array.isArray(e)?new Float32Array(e):e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(e)}function min$1(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["min"])(toArray1D(e)).dataSync()[0]}function max$1(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(toArray1D(e)).dataSync()[0]}function range(e,t){if(t<e)throw new ValueError("end ("+t+") < begin ("+e+") is forbidden.");for(var n=[],r=e;r<t;++r)n.push(r);return n}function cast$1(e,t){return e.asType(t)}function expandDims$1(e,t){void 0===t&&(t=-1);var n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),e.reshape(n)}function repeat(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(2!==e.shape.length)throw new ValueError("repeat() expects a rank-2 tensor, but received a rank-"+e.shape.length+" tensor.");return tile$1(expandDims$1(e,1),[1,t,1])})}function flatten(e){var t=[arrayProd(e.shape)];return e.reshape(t)}function batchFlatten(e){if(e.rank<=1)throw new ValueError("batchFlatten requires a minimum rank of 2. Got rank: "+e.rank+".");var t=[e.shape[0],arrayProd(e.shape,1)];return e.reshape(t)}function sliceAlongFirstAxis(e,t,n){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){switch(e.rank){case 1:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice1d"])(e,t,n);case 2:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice2d"])(e,[t,0],[n,e.shape[1]]);case 3:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice3d"])(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice4d"])(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);default:throw new ValueError("sliceAlongFirstAxis() received an unsupported tensor rank: "+e.rank)}})}function sliceAlongLastAxis(e,t,n){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){switch(e.rank){case 1:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice1d"])(e,t,n);case 2:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice2d"])(e,[0,t],[e.shape[0],n]);case 3:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice3d"])(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice4d"])(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new ValueError("sliceAlongLastAxis() received an unsupported tensor rank: "+e.rank)}})}function sliceAlongAxis(e,t,n,r){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){switch(e.rank){case 1:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice1d"])(e,t,n);case 2:switch(r){case 1:return sliceAlongFirstAxis(e,t,n);case 2:return sliceAlongLastAxis(e,t,n);default:throw new ValueError("The axis is not within the rank of the tensor "+r)}case 3:switch(r){case 1:return sliceAlongFirstAxis(e,t,n);case 2:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice3d"])(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return sliceAlongLastAxis(e,t,n);default:throw new ValueError("The axis is not within the rank of the tensor "+r)}case 4:switch(r){case 1:return sliceAlongFirstAxis(e,t,n);case 2:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice4d"])(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice4d"])(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return sliceAlongLastAxis(e,t,n);default:throw new ValueError("The axis is not within the rank of the tensor "+r)}default:throw new ValueError("sliceAlongLastAxis() received an unsupported tensor rank: "+e.rank)}})}function concatenate(e,t){var n;return void 0===t&&(t=-1),t<0&&(t=0!==(n=e[0].rank)?n:0),t===e[0].rank&&(t=-1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"])(e,t)}function concatAlongFirstAxis(e,t){switch(e.rank){case 1:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat1d"])([e,t]);case 2:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat2d"])([e,t],0);case 3:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat3d"])([e,t],0);case 4:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat4d"])([e,t],0);default:throw new ValueError("concatAlongFirstAxis() received an unsupported tensor rank: "+e.rank)}}function tile$1(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new ValueError("The length of input n ("+t.length+") does not match the number of dimensions in input x ("+e.rank+")");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tile"])(e,t)}function randomNormal$1(e,t,n,r,i){return void 0===t&&(t=0),void 0===n&&(n=1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomNormal"])(e,t,n,r,i)}function dot(e,t,n,r){if(e.rank<2||t.rank<2)throw new NotImplementedError("dot requires both inputs to be rank >= 2 but got x shape = "+e.shape+" and y shape = "+t.shape);if(t.rank>=3&&(s=e.shape.slice(-1)[0])!==(c=t.shape.slice(-2)[0]))throw new NotImplementedError("If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = "+e.shape+" and  y shape = "+t.shape);if(2===e.rank&&2===t.rank){var i=!1,a=!1;return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fused"].matMul(e,t,i,a,r?reshapeBias(e.rank,r,imageDataFormat()):null,n)}var o=e.shape.slice(),s=o.pop();e=e.reshape([-1,s]);var l=t.shape.slice(),u=l.pop(),c=l.pop(),p=l.concat([u]),h=Array.from({length:t.rank},function(e,n){return 0===n?t.rank-2:n<=t.rank-2?n-1:n});t=t.transpose(h).reshape([c,-1]);var d=o.concat(p);i=!1,a=!1;return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fused"].matMul(e,t,i,a,r?reshapeBias(e.rank,r,imageDataFormat()):null,n).reshape(d)}function gather$1(e,t,n){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return t=Array.isArray(t)?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(t,"int32"):t.toInt(),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["gather"])(e,t,n)})}function square(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mulStrict"])(e,e)}function reshapeBias(e,t,n){var r=t.shape;if(1!==t.rank&&t.rank!==e)throw new ValueError("Unexpected bias dimensions: "+t.rank+"; expected it to be 1 or "+e);if(5===e){if("channelsFirst"===n)return 1===r.length?t.reshape([1,r[0],1,1,1]):t.reshape([1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?t.reshape([1,1,1,1,r[0]]):t.reshape([1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?t.reshape([1,r[0],1,1]):t.reshape([1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?t.reshape([1,1,1,r[0]]):t.reshape([1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?t.reshape([1,r[0],1]):t.reshape([1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?t.reshape([1,1,r[0]]):t.reshape([1].concat(r))}else if(e<3)return t;throw new ValueError("Unsupported input rank by biasAdd: "+t.rank)}function biasAdd(e,t,n){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return null==n&&(n=imageDataFormat()),checkDataFormat(n),e.add(reshapeBias(e.rank,t,n))})}function elu$1(e,t){if(void 0===t&&(t=1),1!==t)throw new NotImplementedError("Support for alpha values other than 1 ("+t+") is not implemented yet.");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["elu"])(e)}function softsign(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(e).add(1))})}function dropout(e,t,n,r){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null!=n&&!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(e.shape,n))throw new NotImplementedError("Non-default noise shape is not implemented yet: "+JSON.stringify(n));if(null!=r)throw new NotImplementedError("seed is not implemented for dropout yet.");var i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["step"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(-t,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"])(e.shape,0,1,"float32")));return i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(1/(1-t),i),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,i)})}function hardSigmoid(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(.5,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(.2,e));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,0,1)})}function inTrainPhase(e,t,n){return void 0===n&&(n=!1),n?e():t()}var VALID_FAN_MODE_VALUES=["fanIn","fanOut","fanAvg"],VALID_DISTRIBUTION_VALUES=["normal","uniform","truncatedNormal"];function checkFanMode(e){checkStringTypeUnionValue(VALID_FAN_MODE_VALUES,"FanMode",e)}function checkDistribution(e){checkStringTypeUnionValue(VALID_DISTRIBUTION_VALUES,"Distribution",e)}var Initializer=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.fromConfigUsesCustomObjects=function(){return!1},t.prototype.getConfig=function(){return{}},t}(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].Serializable),Zeros=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])(e,t)},t.className="Zeros",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Zeros);var Ones=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ones"])(e,t)},t.className="Ones",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Ones);var Constant=function(e){function t(t){var n=e.call(this)||this;if("object"!=typeof t)throw new ValueError("Expected argument of type ConstantConfig but got "+t);if(void 0===t.value)throw new ValueError("config must have value set but got "+t);return n.value=t.value,n}return __extends(t,e),t.prototype.apply=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(n.value),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ones"])(e,t))})},t.prototype.getConfig=function(){return{value:this.value}},t.className="Constant",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Constant);var RandomUniform=function(e){function t(t){var n=e.call(this)||this;return n.DEFAULT_MINVAL=-.05,n.DEFAULT_MAXVAL=.05,n.minval=t.minval||n.DEFAULT_MINVAL,n.maxval=t.maxval||n.DEFAULT_MAXVAL,n.seed=t.seed,n}return __extends(t,e),t.prototype.apply=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"])(e,this.minval,this.maxval,t)},t.prototype.getConfig=function(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}},t.className="RandomUniform",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(RandomUniform);var RandomNormal=function(e){function t(t){var n=e.call(this)||this;return n.DEFAULT_MEAN=0,n.DEFAULT_STDDEV=.05,n.mean=t.mean||n.DEFAULT_MEAN,n.stddev=t.stddev||n.DEFAULT_STDDEV,n.seed=t.seed,n}return __extends(t,e),t.prototype.apply=function(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new NotImplementedError("randomNormal does not support dType "+t+".");return randomNormal$1(e,this.mean,this.stddev,t,this.seed)},t.prototype.getConfig=function(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}},t.className="RandomNormal",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(RandomNormal);var TruncatedNormal=function(e){function t(t){var n=e.call(this)||this;return n.DEFAULT_MEAN=0,n.DEFAULT_STDDEV=.05,n.mean=t.mean||n.DEFAULT_MEAN,n.stddev=t.stddev||n.DEFAULT_STDDEV,n.seed=t.seed,n}return __extends(t,e),t.prototype.apply=function(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new NotImplementedError("truncatedNormal does not support dType "+t+".");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["truncatedNormal"])(e,this.mean,this.stddev,t,this.seed)},t.prototype.getConfig=function(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}},t.className="TruncatedNormal",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(TruncatedNormal);var Identity=function(e){function t(t){var n=e.call(this)||this;return n.gain=null!=t.gain?t.gain:1,n}return __extends(t,e),t.prototype.apply=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(2!==e.length||e[0]!==e[1])throw new ValueError("Identity matrix initializer can only be used for 2D square matrices.");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(n.gain,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["eye"])(e[0]))})},t.prototype.getConfig=function(){return{gain:this.gain}},t.className="Identity",t}(Initializer);function computeFans(e,t){var n,r;if(void 0===t&&(t="channelsLast"),checkDataFormat(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){var i=arrayProd(e,2);n=e[1]*i,r=e[0]*i}else if("channelsLast"===t){i=arrayProd(e,0,e.length-2);n=e[e.length-2]*i,r=e[e.length-1]*i}}else{var a=arrayProd(e);n=Math.sqrt(a),r=Math.sqrt(a)}return[n,r]}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Identity);var VarianceScaling=function(e){function t(t){var n=e.call(this)||this;if(t.scale<0)throw new ValueError("scale must be a positive float. Got: "+t.scale);return n.scale=null==t.scale?1:t.scale,n.mode=null==t.mode?"fanIn":t.mode,checkFanMode(n.mode),n.distribution=null==t.distribution?"normal":t.distribution,checkDistribution(n.distribution),n.seed=t.seed,n}return __extends(t,e),t.prototype.apply=function(e,t){var n=computeFans(e),r=n[0],i=n[1],a=this.scale;if("fanIn"===this.mode?a/=Math.max(1,r):"fanOut"===this.mode?a/=Math.max(1,i):a/=Math.max(1,(r+i)/2),"normal"===this.distribution){var o=Math.sqrt(a);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new NotImplementedError(this.getClassName()+" does not support dType "+t+".");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["truncatedNormal"])(e,0,o,t,this.seed)}var s=Math.sqrt(3*a);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"])(e,-s,s,t)},t.prototype.getConfig=function(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}},t.className="VarianceScaling",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(VarianceScaling);var GlorotUniform=function(e){function t(t){return e.call(this,{scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="GlorotUniform",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlorotUniform);var GlorotNormal=function(e){function t(t){return e.call(this,{scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="GlorotNormal",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlorotNormal);var HeNormal=function(e){function t(t){return e.call(this,{scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="HeNormal",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(HeNormal);var HeUniform=function(e){function t(t){return e.call(this,{scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="HeUniform",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(HeUniform);var LeCunNormal=function(e){function t(t){return e.call(this,{scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="LeCunNormal",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LeCunNormal);var LeCunUniform=function(e){function t(t){return e.call(this,{scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})||this}return __extends(t,e),t.prototype.getClassName=function(){return VarianceScaling.className},t.className="LeCunNormal",t}(VarianceScaling);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LeCunUniform);var Orthogonal=function(e){function t(t){var n=e.call(this)||this;if(n.DEFAULT_GAIN=1,n.gain=null==t.gain?n.DEFAULT_GAIN:t.gain,n.seed=t.seed,null!=n.seed)throw new NotImplementedError("Random seed is not implemented for Orthogonal Initializer yet.");return n}return __extends(t,e),t.prototype.apply=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(2!==e.length)throw new NotImplementedError("The Orthogonal Initializer does not support non-2D shapes yet.");e[0]*e[1]>2e3&&console.warn("Orthogonal initializer is being called on a matrix with more than 2000 ("+e[0]*e[1]+") elements: Slowness may result.");var t=randomNormal$1(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32"),r=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["linalg"].gramSchmidt(t);return e[0]>e[1]&&(r=r.transpose()),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(n.gain,r)})},t.prototype.getConfig=function(){return{gain:this.gain,seed:this.seed}},t.className="Orthogonal",t}(Initializer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Orthogonal);var INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function deserializeInitializer(e,t){return void 0===t&&(t={}),deserializeKerasObject(e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].SerializationMap.getMap().classNameMap,t,"initializer")}function serializeInitializer(e){return serializeKerasObject(e)}function getInitializer(e){if("string"==typeof e){var t=e in INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP?INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[e]:e;if("GlorotNormal"===t)return new GlorotNormal;if("GlorotUniform"===t)return new GlorotUniform;if("HeNormal"===t)return new HeNormal;if("HeUniform"===t)return new HeUniform;if("LeCunNormal"===t)return new LeCunNormal;if("LeCunUniform"===t)return new LeCunUniform;var n={};return n.className=t,n.config={},deserializeInitializer(n)}return e instanceof Initializer?e:deserializeInitializer(e)}function zeros$1(){return new Zeros}function ones$1(){return new Ones}function constant(e){return new Constant(e)}function randomUniform$1(e){return new RandomUniform(e)}function randomNormal$2(e){return new RandomNormal(e)}function truncatedNormal$1(e){return new TruncatedNormal(e)}function identity(e){return new Identity(e)}function varianceScaling(e){return new VarianceScaling(e)}function glorotUniform(e){return new GlorotUniform(e)}function glorotNormal(e){return new GlorotNormal(e)}function heNormal(e){return new HeNormal(e)}function heUniform(e){return new HeUniform(e)}function leCunNormal(e){return new LeCunNormal(e)}function leCunUniform(e){return new LeCunUniform(e)}function orthogonal(e){return new Orthogonal(e)}var exports_initializers=Object.freeze({zeros:zeros$1,ones:ones$1,constant:constant,randomUniform:randomUniform$1,randomNormal:randomNormal$2,truncatedNormal:truncatedNormal$1,identity:identity,varianceScaling:varianceScaling,glorotUniform:glorotUniform,glorotNormal:glorotNormal,heNormal:heNormal,heUniform:heUniform,leCunNormal:leCunNormal,leCunUniform:leCunUniform,orthogonal:orthogonal}),_nextUniqueTensorId=0;function getNextUniqueTensorId(){return _nextUniqueTensorId++}var _uidPrefixes={};function getUid(e){return void 0===e&&(e=""),e in _uidPrefixes||(_uidPrefixes[e]=0),_uidPrefixes[e]+=1,e+_uidPrefixes[e].toString()}function isArrayOfShapes(e){return Array.isArray(e)&&Array.isArray(e[0])}function normalizeShapeList(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function getExactlyOneTensor(e){var t;if(Array.isArray(e)){if(1!==e.length)throw new ValueError("Expected Tensor length to be 1; got "+e.length);t=e[0]}else t=e;return t}function getExactlyOneShape(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return(e=e)[0];throw new ValueError("Expected exactly 1 Shape; got "+e.length)}return e}function countParamsInWeights(e){for(var t=0,n=0,r=e;n<r.length;n++){var i=r[n];0===i.shape.length?t+=1:t+=i.shape.reduce(function(e,t){return e*t})}return t}var DEFAULT_VARIABLE_NAME_PREFIX="Variable",LayerVariable=function(){function e(e,t,n,r,i){void 0===t&&(t="float32"),void 0===n&&(n=DEFAULT_VARIABLE_NAME_PREFIX),void 0===r&&(r=!0),void 0===i&&(i=null),this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=getNextUniqueTensorId(),n=null==n?DEFAULT_VARIABLE_NAME_PREFIX:n,this.originalName=getScopedTensorName(n),this.name=getUniqueTensorName(this.originalName),this.trainable_=r,this.constraint=i,this.val=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["variable"])(e,this.trainable_,this.name,this.dtype)}return e.prototype.read=function(){return this.assertNotDisposed(),this.val},e.prototype.write=function(e){return this.assertNotDisposed(),checkShapesMatch(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this},e.prototype.dispose=function(){this.assertNotDisposed(),this.val.dispose()},e.prototype.assertNotDisposed=function(){if(this.val.isDisposed)throw new Error("LayersVariable "+this.name+" is already disposed.")},Object.defineProperty(e.prototype,"trainable",{get:function(){return this.trainable_},set:function(e){this.trainable_=e,this.val.trainable=e},enumerable:!0,configurable:!0}),e}();function checkShapesMatch(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function batchGetValue(e){return e.map(function(e){return e.read()})}function batchSetValue(e){e.forEach(function(e){e[0].write(e[1])})}var InputSpec=function(){return function(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}(),SymbolicTensor=function(){return function(e,t,n,r,i,a,o){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=i,this.outputTensorIndex=o,this.id=getNextUniqueTensorId(),null!=a&&(this.originalName=getScopedTensorName(a),this.name=getUniqueTensorName(this.originalName)),this.rank=t.length}}(),_nextNodeID=0,Node=function(){function e(e,t){this.callArgs=t,this.id=_nextNodeID++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(var n=0,r=e.inboundLayers;n<r.length;n++){var i=r[n];null!=i&&i.outboundNodes.push(this)}e.outboundLayer.inboundNodes.push(this)}return e.prototype.getConfig=function(){for(var e=[],t=0,n=this.inboundLayers;t<n.length;t++){var r=n[t];null!=r?e.push(r.name):e.push(null)}return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}},e}(),_nextLayerID=0,Layer=function(e){function t(t){var n=e.call(this)||this;n._callHook=null,n._addedWeightNames=[],n._stateful=!1,n.id=_nextLayerID++,n.activityRegularizer=null,n.inputSpec=null,n.supportsMasking=!1,n._trainableWeights=[],n._nonTrainableWeights=[],n._losses=[],n._updates=[],n._built=!1,n.inboundNodes=[],n.outboundNodes=[];var r=t.name;if(!r){var i=n.getClassName();r=toSnakeCase(i)+"_"+getUid(i)}if(n.name=r,n.trainable_=null==t.trainable||t.trainable,n.updatable=null==t.updatable||t.updatable,null!=t.inputShape||null!=t.batchInputShape){var a=void 0;if(null!=t.batchInputShape)a=t.batchInputShape;else if(null!=t.inputShape){var o=null;null!=t.batchSize&&(o=t.batchSize),a=[o].concat(t.inputShape)}n.batchInputShape=a;var s=t.dtype;null==s&&(s=t.inputDType),null==s&&(s="float32"),n.dtype=s}return null!=t.weights?n.initialWeights=t.weights:n.initialWeights=null,n._refCount=null,n.fastWeightInitDuringBuild=!1,n}return __extends(t,e),t.nodeKey=function(e,t){return e.name+"_ib-"+t.toString()},t.prototype.getNodeAtIndex=function(e,t){if(0===this.inboundNodes.length)throw new RuntimeError("The layer has never been called and thus has no defined "+t+".");if(this.inboundNodes.length<=e)throw new ValueError("Asked to get "+t+" at node "+e+", but the layer has only "+this.inboundNodes.length+" inbound nodes.");return this.inboundNodes[e]},t.prototype.getInputAt=function(e){return singletonOrArray(this.getNodeAtIndex(e,"input").inputTensors)},t.prototype.getOutputAt=function(e){return singletonOrArray(this.getNodeAtIndex(e,"output").outputTensors)},Object.defineProperty(t.prototype,"input",{get:function(){if(this.inboundNodes.length>1)throw new AttributeError("Layer "+this.name+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new AttributeError("Layer "+this.name+" is not connected, no input to return.");return singletonOrArray(this.getNodeAtIndex(0,"input").inputTensors)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"output",{get:function(){if(0===this.inboundNodes.length)throw new AttributeError("Layer "+this.name+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new AttributeError("Layer "+this.name+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return singletonOrArray(this.getNodeAtIndex(0,"output").outputTensors)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"losses",{get:function(){return this._losses},enumerable:!0,configurable:!0}),t.prototype.calculateLosses=function(){return this.losses.map(function(e){return e()})},Object.defineProperty(t.prototype,"updates",{get:function(){return this._updates},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"built",{get:function(){return this._built},set:function(e){this._built=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"trainable",{get:function(){return this.trainable_},set:function(e){this._trainableWeights.forEach(function(t){return t.trainable=e}),this.trainable_=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"trainableWeights",{get:function(){return this.trainable_?this._trainableWeights.filter(function(e){return e.trainable}):[]},set:function(e){this._trainableWeights=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){return this.trainable?this._trainableWeights.filter(function(e){return!e.trainable}).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)},set:function(e){this._nonTrainableWeights=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"weights",{get:function(){return this.trainableWeights.concat(this.nonTrainableWeights)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"stateful",{get:function(){return this._stateful},enumerable:!0,configurable:!0}),t.prototype.resetStates=function(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")},t.prototype.assertInputCompatibility=function(e){if(e=toList(e),null!=this.inputSpec&&0!==this.inputSpec.length){var t=toList(this.inputSpec);if(e.length!==t.length)throw new ValueError("Layer "+this.name+" expects "+t.length+" inputs, but it received "+e.length+" input tensors. Input received: "+e);for(var n=0;n<e.length;n++){var r=e[n],i=t[n];if(null!=i){var a=r.rank;if(null!=i.ndim&&a!==i.ndim)throw new ValueError("Input "+n+" is incompatible with layer "+this.name+": expected ndim="+i.ndim+", found ndim="+a);if(null!=i.maxNDim&&a>i.maxNDim)throw new ValueError("Input "+n+" is incompatible with layer "+this.name+": expected max_ndim="+i.maxNDim+", found ndim="+a);if(null!=i.minNDim&&a<i.minNDim)throw new ValueError("Input "+n+" is incompatible with layer "+this.name+": expected min_ndim="+i.minNDim+", found ndim="+a+".");if(null!=i.dtype&&r.dtype!==i.dtype)throw new ValueError("Input "+n+" is incompatible with layer "+this.name+" : expected dtype="+i.dtype+", found dtype="+r.dtype+".");if(i.axes){var o=r.shape;for(var s in i.axes){var l=Number(s),u=i.axes[s],c=l>=0?o[l]:o[o.length+l];if(null!=u&&-1===[u,null].indexOf(c))throw new ValueError("Input "+n+" is incompatible with layer "+this.name+": expected axis "+l+" of input shape to have value "+u+" but got shape "+o+".")}}if(null!=i.shape)for(var p=0;p<i.shape.length;++p){var h=i.shape[p],d=r.shape[p];if(null!=h&&null!=d&&h!==d)throw new ValueError("Input "+n+" is incompatible with layer "+this.name+": expected shape="+i.shape+", found shape="+r.shape+".")}}}}},t.prototype.call=function(e,t){return e},t.prototype.invokeCallHook=function(e,t){null!=this._callHook&&this._callHook(e,t)},t.prototype.setCallHook=function(e){this._callHook=e},t.prototype.clearCallHook=function(){this._callHook=null},t.prototype.apply=function(e,t){var n=this;t=t||{},this.assertNotDisposed();for(var r=toList(e),i=!0,a=0,o=r;a<o.length;a++){if(!(o[a]instanceof SymbolicTensor)){i=!1;break}}for(var s=!0,l=0,u=r;l<u.length;l++){if(u[l]instanceof SymbolicTensor){s=!1;break}}if(i===s)throw new ValueError("Arguments to apply() must be all SymbolicTensors or all Tensors");return nameScope(this.name,function(){if(!n.built){n.assertInputCompatibility(e);for(var i=[],a=0,o=toList(e);a<o.length;a++){var l=o[a];i.push(l.shape)}n.build(singletonOrArray(i)),n.built=!0,n.initialWeights&&n.setWeights(n.initialWeights),null===n._refCount&&s&&(n._refCount=1)}if(n.assertInputCompatibility(e),s){for(var u=[],c=0,p=toList(g=n.call(e,t));c<p.length;c++){var h=p[c];-1!==r.indexOf(h)&&(h=h.clone()),u.push(h)}if(g=singletonOrArray(u),null!=n.activityRegularizer)throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return g}var d=collectInputShape(e),f=n.computeOutputShape(d),g=void 0,m=guessOutputDType(e);if(n.warnOnIncompatibleInputShape(Array.isArray(e)?d[0]:d),g=null!=f&&f.length>0&&Array.isArray(f[0])?f.map(function(r,i){return new SymbolicTensor(m,r,n,toList(e),t,n.name,i)}):new SymbolicTensor(m,f,n,toList(e),t,n.name),n.addInboundNode(e,g,null,null,d,f,t),n._refCount++,null!=n.activityRegularizer)throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return g})},t.prototype.warnOnIncompatibleInputShape=function(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+JSON.stringify(e)+") does not match that of the batchInputShape ("+JSON.stringify(this.batchInputShape)+") of the layer "+this.name);else{var t=!1;this.batchInputShape.forEach(function(n,r){null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)}),t&&console.warn("The shape of the input tensor ("+JSON.stringify(e)+") does not match the expectation of layer "+this.name+": "+JSON.stringify(this.batchInputShape))}},Object.defineProperty(t.prototype,"outputShape",{get:function(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new AttributeError("The layer "+this.name+" has never been called and thus has no defined output shape.");for(var e=[],t=0,n=this.inboundNodes;t<n.length;t++){var r=n[t],i=JSON.stringify(r.outputShapes);-1===e.indexOf(i)&&e.push(i)}if(1===e.length){var a=this.inboundNodes[0].outputShapes;return Array.isArray(a)&&Array.isArray(a[0])&&1===a.length?a[0]:a}throw new AttributeError("The layer "+this.name+' has multiple inbound nodes with different output shapes. Hence the notion of "outut shape" is ill-defined for the layer.')},enumerable:!0,configurable:!0}),t.prototype.countParams=function(){if(!this.built)throw new RuntimeError("You tried to call countParams() on "+this.name+", but the layer is not built yet. Build it first by calling build(batchInputShape).");return countParamsInWeights(this.weights)},t.prototype.build=function(e){this.built=!0},t.prototype.getWeights=function(e){return void 0===e&&(e=!1),batchGetValue(e?this.trainableWeights:this.weights)},t.prototype.setWeights=function(e){var t=this;Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=t.weights;if(n.length!==e.length)throw new ValueError('You called setWeights(weights) on layer "'+t.name+'" with a weight list of length '+e.length+", but the layer was expecting "+n.length+" weights. Provided weights: "+e+"...");if(0!==n.length){for(var r=[],i=batchGetValue(n),a=0;a<i.length;++a){var o=i[a],s=n[a],l=e[a];if(!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(o.shape,l.shape))throw new ValueError("Layer weight shape "+o.shape+" not compatible with provided weight shape "+l.shape);r.push([s,l])}batchSetValue(r)}})},t.prototype.addWeight=function(e,t,n,r,i,a,o){if(-1!==this._addedWeightNames.indexOf(e))throw new ValueError("Duplicate weight name "+e+" for layer "+this.name);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=getInitializer("zeros"));var s=r.apply(t,n),l=new LayerVariable(s,n,e,a,o);return s.dispose(),null!=i&&this.addLoss(function(){return i.apply(l.read())}),null==a&&(a=!0),a?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l},t.prototype.setFastWeightInitDuringBuild=function(e){this.fastWeightInitDuringBuild=e},t.prototype.addLoss=function(e){var t;null==e||Array.isArray(e)&&0===e.length||(e=toList(e),void 0!==this._losses&&null!==this._losses&&(t=this.losses).push.apply(t,e))},t.prototype.computeOutputShape=function(e){return e},t.prototype.computeMask=function(e,t){var n=this;if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError("Layer "+this.name+" does not support masking, but was passed an inputMask.");t.forEach(function(e){if(null!=e)throw new TypeError("Layer "+n.name+" does not support masking, but was passed an inputMask.")})}return null}return t},t.prototype.addInboundNode=function(e,t,n,r,i,a,o){void 0===o&&(o=null);var s=toList(e);t=toList(t),n=toList(n),r=toList(r),i=normalizeShapeList(i),a=normalizeShapeList(a);for(var l=[],u=[],c=[],p=0,h=s;p<h.length;p++){var d=h[p];l.push(d.sourceLayer),u.push(d.nodeIndex),c.push(d.tensorIndex)}new Node({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:s,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:i,outputShapes:a},o);for(var f=0;f<t.length;f++)t[f].sourceLayer=this,t[f].nodeIndex=this.inboundNodes.length-1,t[f].tensorIndex=f},t.prototype.getConfig=function(){var e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e},t.prototype.disposeWeights=function(){return this.weights.forEach(function(e){return e.dispose()}),this.weights.length},t.prototype.assertNotDisposed=function(){if(0===this._refCount)throw new Error("Layer '"+this.name+"' is already disposed.")},t.prototype.dispose=function(){if(!this.built)throw new Error("Cannot dispose Layer "+this.name+" because it has not been built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer "+this.name+" because it has not been used yet.");this.assertNotDisposed();var e=0;return 0==--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}},t}(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].Serializable);function collectInputShape(e){for(var t=[],n=0,r=e=toList(e);n<r.length;n++){var i=r[n];t.push(i.shape)}return singletonOrArray(t)}function guessOutputDType(e){return"float32"}function getSourceInputs(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];var r=t.inboundNodes[n];if(0===r.inboundLayers.length)return r.inputTensors;for(var i=[],a=0;a<r.inboundLayers.length;a++)for(var o=0,s=getSourceInputs(r.inputTensors[a],r.inboundLayers[a],r.nodeIndices[a]);o<s.length;o++){var l=s[o];-1===i.indexOf(l)&&i.push(l)}return i}var ModelLoggingVerbosity,InputLayer=function(e){function t(t){var n=e.call(this,{dtype:t.dtype,name:null!=t.name?t.name:getUid("input").toString()})||this;if(null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),n.trainable=!1,n.built=!0,n.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new ValueError("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");var r=t.batchInputShape;if(null==r){if(null==t.inputShape)throw new ValueError("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new ValueError("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");var i=t.dtype||"float32";n.batchInputShape=r,n.dtype=i,n.inputSpec=[{shape:r}];var a=new SymbolicTensor(n.dtype,n.batchInputShape,n,[],{},n.name);return a.nodeIndex=0,a.tensorIndex=0,new Node({outboundLayer:n,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]}),n}return __extends(t,e),t.prototype.apply=function(e,t){throw new ValueError("Cannot pass any input to an InputLayer's apply() method. InputLayer name: "+this.name)},t.prototype.dispose=function(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}},t.prototype.getConfig=function(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}},t.className="InputLayer",t}(Layer);function Input(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new ValueError("Please provide either a `shape` or `batchShape` argument to Input, but not both.");var t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));var n=e.dtype;return null==n&&(n="float32"),new InputLayer({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function resolveScalarsInLogs(e){return __awaiter(this,void 0,void 0,function(){var t,n,r,i,a,o,s,l;return __generator(this,function(u){switch(u.label){case 0:if(null==e)return[2];for(i in t=[],n=[],r=[],e)"number"!=typeof(a=e[i])&&(o=a,t.push(o.data()),n.push(i),r.push(o));return t.length>0?[4,Promise.all(t)]:[3,2];case 1:for(s=u.sent(),l=0;l<s.length;++l)e[n[l]]=s[l][0];Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r),u.label=2;case 2:return[2]}})})}function disposeTensorsInLogs(e){if(null!=e)for(var t in e){var n=e[t];"number"!=typeof n&&n.dispose()}}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(InputLayer),function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(ModelLoggingVerbosity||(ModelLoggingVerbosity={}));var DEFAULT_YIELD_EVERY_MS=125,BaseCallback=function(){function e(){this.validationData=null}return e.prototype.setParams=function(e){this.params=e},e.prototype.onEpochBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.onBatchBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.onBatchEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.onTrainBegin=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.onTrainEnd=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return[2]})})},e.prototype.setModel=function(e){},e}(),CallbackList=function(){function e(e,t){void 0===t&&(t=10),null==e&&(e=[]),this.callbacks=e,this.queueLength=t}return e.prototype.append=function(e){this.callbacks.push(e)},e.prototype.setParams=function(e){for(var t=0,n=this.callbacks;t<n.length;t++){n[t].setParams(e)}},e.prototype.setModel=function(e){for(var t=0,n=this.callbacks;t<n.length;t++){n[t].setModel(e)}},e.prototype.onEpochBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r;return __generator(this,function(i){switch(i.label){case 0:null==t&&(t={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onEpochBegin(e,t)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}})})},e.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r;return __generator(this,function(i){switch(i.label){case 0:null==t&&(t={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onEpochEnd(e,t)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}})})},e.prototype.onBatchBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r;return __generator(this,function(i){switch(i.label){case 0:null==t&&(t={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onBatchBegin(e,t)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}})})},e.prototype.onBatchEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r;return __generator(this,function(i){switch(i.label){case 0:null==t&&(t={}),n=0,r=this.callbacks,i.label=1;case 1:return n<r.length?[4,r[n].onBatchEnd(e,t)]:[3,4];case 2:i.sent(),i.label=3;case 3:return n++,[3,1];case 4:return[2]}})})},e.prototype.onTrainBegin=function(e){return __awaiter(this,void 0,void 0,function(){var t,n;return __generator(this,function(r){switch(r.label){case 0:null==e&&(e={}),t=0,n=this.callbacks,r.label=1;case 1:return t<n.length?[4,n[t].onTrainBegin(e)]:[3,4];case 2:r.sent(),r.label=3;case 3:return t++,[3,1];case 4:return[2]}})})},e.prototype.onTrainEnd=function(e){return __awaiter(this,void 0,void 0,function(){var t,n;return __generator(this,function(r){switch(r.label){case 0:null==e&&(e={}),t=0,n=this.callbacks,r.label=1;case 1:return t<n.length?[4,n[t].onTrainEnd(e)]:[3,4];case 2:r.sent(),r.label=3;case 3:return t++,[3,1];case 4:return[2]}})})},e}(),BaseLogger=function(e){function t(){return e.call(this)||this}return __extends(t,e),t.prototype.onEpochBegin=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return this.seen=0,this.totals={},[2]})})},t.prototype.onBatchEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var e,n,r,i,a=this;return __generator(this,function(o){for(i in null==t&&(t={}),e=null==t.size?0:t.size,this.seen+=e,n=function(n){var i=t[n];if("number"==typeof i)r.totals.hasOwnProperty(n)||(r.totals[n]=0),r.totals[n]=r.totals[n]+i*e;else{var o=void 0;n in r.totals?o=r.totals[n]:r.totals[n]=0,r.totals[n]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(a.totals[n],Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(i,e))}),null!=o&&o.dispose()}},r=this,t)n(i);return[2]})})},t.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var e,n,r,i,a,o=this;return __generator(this,function(s){if(null!=t)for(e=function(e){if(null==n.totals[e])return"continue";"number"==typeof n.totals[e]?t[e]=n.totals[e]/n.seen:Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){t[e]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(1,o.seen),o.totals[e]),o.totals[e].dispose(),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(t[e])})},n=this,r=0,i=this.params.metrics;r<i.length;r++)a=i[r],e(a);return[2]})})},t}(BaseCallback),History=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.onTrainBegin=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return this.epoch=[],this.history={},[2]})})},t.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(r){for(n in null==t&&(t={}),this.epoch.push(e),t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n]);return[2]})})},t.prototype.syncData=function(){return __awaiter(this,void 0,void 0,function(){var e,t,n,r,i,a,o,s,l;return __generator(this,function(u){switch(u.label){case 0:for(r in e=[],t=[],n=[],this.history)for(i=this.history[r],a=0;a<i.length;++a)"number"!=typeof i[a]&&(o=i[a],e.push(o.data()),t.push(r),n.push(a));return[4,Promise.all(e)];case 1:for(s=u.sent(),l=0;l<s.length;++l)this.history[t[l]][n[l]].dispose(),this.history[t[l]][n[l]]=s[l][0];return[2]}})})},t}(BaseCallback),CustomCallback=function(e){function t(t,n){var r=e.call(this)||this;if(r.currentEpoch=0,r.yieldEvery=n||"auto","auto"===r.yieldEvery&&(r.yieldEvery=DEFAULT_YIELD_EVERY_MS),"never"===r.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].isNumber(r.yieldEvery)&&(r.maybeWait=debounce(r.maybeWait.bind(r),r.yieldEvery)),r.trainBegin=t.onTrainBegin,r.trainEnd=t.onTrainEnd,r.epochBegin=t.onEpochBegin,r.epochEnd=t.onEpochEnd,r.batchBegin=t.onBatchBegin,r.batchEnd=t.onBatchEnd,r.yield=t.onYield,r}return __extends(t,e),t.prototype.maybeWait=function(e,t,n){return __awaiter(this,void 0,void 0,function(){var r;return __generator(this,function(i){switch(i.label){case 0:return r=[],null==this.yield?[3,2]:[4,resolveScalarsInLogs(n)];case 1:i.sent(),r.push(this.yield(e,t,n)),i.label=2;case 2:return r.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["nextFrame"])()),[4,Promise.all(r)];case 3:return i.sent(),[2]}})})},t.prototype.onEpochBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){switch(n.label){case 0:return this.currentEpoch=e,null==this.epochBegin?[3,3]:[4,resolveScalarsInLogs(t)];case 1:return n.sent(),[4,this.epochBegin(e,t)];case 2:n.sent(),n.label=3;case 3:return[2]}})})},t.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(r){switch(r.label){case 0:return n=[],null==this.epochEnd?[3,2]:[4,resolveScalarsInLogs(t)];case 1:r.sent(),n.push(this.epochEnd(e,t)),r.label=2;case 2:return"epoch"===this.yieldEvery&&n.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["nextFrame"])()),[4,Promise.all(n)];case 3:return r.sent(),[2]}})})},t.prototype.onBatchBegin=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){switch(n.label){case 0:return null==this.batchBegin?[3,3]:[4,resolveScalarsInLogs(t)];case 1:return n.sent(),[4,this.batchBegin(e,t)];case 2:n.sent(),n.label=3;case 3:return[2]}})})},t.prototype.onBatchEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(r){switch(r.label){case 0:return n=[],null==this.batchEnd?[3,2]:[4,resolveScalarsInLogs(t)];case 1:r.sent(),n.push(this.batchEnd(e,t)),r.label=2;case 2:return"batch"===this.yieldEvery?n.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["nextFrame"])()):_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),[4,Promise.all(n)];case 3:return r.sent(),[2]}})})},t.prototype.onTrainBegin=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return null==this.trainBegin?[3,3]:[4,resolveScalarsInLogs(e)];case 1:return t.sent(),[4,this.trainBegin(e)];case 2:t.sent(),t.label=3;case 3:return[2]}})})},t.prototype.onTrainEnd=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(t){switch(t.label){case 0:return null==this.trainEnd?[3,3]:[4,resolveScalarsInLogs(e)];case 1:return t.sent(),[4,this.trainEnd(e)];case 2:t.sent(),t.label=3;case 3:return[2]}})})},t}(BaseCallback);function standardizeCallbacks(e,t){return null==e&&(e={}),e instanceof BaseCallback?[e]:Array.isArray(e)&&e[0]instanceof BaseCallback?e:toList(e).map(function(e){return new CustomCallback(e,t)})}var CallbackConstructorRegistry=function(){function e(){}return e.registerCallbackConstructor=function(t,n){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(t>=0&&Number.isInteger(t),function(){return"Verbosity level is expected to be an integer >= 0, but got "+t}),e.checkForDuplicate(n),null==e.constructors[t]&&(e.constructors[t]=[]),e.constructors[t].push(n)},e.checkForDuplicate=function(t){for(var n in e.constructors){e.constructors[+n].forEach(function(e){if(e===t)throw new ValueError("Duplicate callback constructor.")})}},e.clear=function(){e.constructors={}},e.createCallbacks=function(t){var n=[];for(var r in e.constructors){var i=+r;t>=i&&n.push.apply(n,e.constructors[i])}return n.map(function(e){return new e})},e.constructors={},e}();function configureCallbacks(e,t,n,r,i,a,o,s,l){var u=new History,c=[new BaseLogger].concat(CallbackConstructorRegistry.createCallbacks(t));null!=e&&c.push.apply(c,e),c.push(u);var p=new CallbackList(c);return p.setParams({epochs:n,initialEpoch:r,samples:i,steps:a,batchSize:o,verbose:t,doValidation:s,metrics:l}),{callbackList:p,history:u}}function l2Normalize(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){"float32"!==e.dtype&&(e=e.asType("float32"));var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(square(e),t,!0),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fill"])(n.shape,epsilon()),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(n,r));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(e,i)})}function meanSquaredError(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(square(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(t,e)),-1)})}function meanAbsoluteError(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(t,e)),-1)})}function meanAbsolutePercentageError(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(e,t),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(e),epsilon(),Number.MAX_VALUE),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(n,r));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(100,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(i,-1))})}function meanSquaredLogarithmicError(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,epsilon(),Number.MAX_VALUE),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(1,n)),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(e,epsilon(),Number.MAX_VALUE),a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(1,i));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(square(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(r,a)),-1)})}function squaredHinge(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(0,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(1,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,t)));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(square(n),-1)})}function hinge(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(0,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(1,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,t)));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(n,-1)})}function categoricalHinge(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,t),-1),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(1,e),t),-1);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(0,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(1,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(r,n)))})}function logcosh(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Math.log(2),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(t,e),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(r,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softplus"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(-2,r))),n);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(i,-1)})}function categoricalCrossentropy(e,t,n){return void 0===n&&(n=!1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"])(t);else{var r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(t,t.shape.length-1,!0);t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(t,r)}return t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,epsilon(),1-epsilon()),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e.toFloat(),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(t)),t.shape.length-1))})}function sparseCategoricalCrossentropy(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["floor"])(flatten(e)).toInt(),r=(t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,epsilon(),1-epsilon())).shape;return categoricalCrossentropy(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["oneHot"])(n,r[r.length-1]).reshape(r),t,!1)})}function sigmoidCrossEntropyWithLogits(e,t){if(!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(e.shape,t.shape))throw new ValueError("logits and labels must have the same shape, but got shapes "+JSON.stringify(e.shape)+" and "+JSON.stringify(t.shape));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=t.relu(),r=t.abs().neg();return n.sub(t.mul(e)).add(r.exp().log1p())})}function binaryCrossentropy(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n;return n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,epsilon(),1-epsilon()),n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(n,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(1,n))),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(sigmoidCrossEntropyWithLogits(e,n),-1)})}function kullbackLeiblerDivergence(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(e,epsilon(),1),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(t,epsilon(),1);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(n,r))),-1)})}function poisson(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(epsilon(),t));return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"])(t,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,n)),-1)})}function cosineProximity(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=l2Normalize(e,-1),r=l2Normalize(t,-1),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(n,r);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(i,-1))})}function get(e){var t={meanSquaredError:meanSquaredError,meanAbsoluteError:meanAbsoluteError,meanAbsolutePercentageError:meanAbsolutePercentageError,meanSquaredLogarithmicError:meanSquaredLogarithmicError,squaredHinge:squaredHinge,hinge:hinge,categoricalHinge:categoricalHinge,logcosh:logcosh,categoricalCrossentropy:categoricalCrossentropy,sparseCategoricalCrossentropy:sparseCategoricalCrossentropy,binaryCrossentropy:binaryCrossentropy,kullbackLeiblerDivergence:kullbackLeiblerDivergence,poisson:poisson,cosineProximity:cosineProximity};if("string"==typeof e){if(e in t)return t[e];var n="Unknown loss "+e;throw e.toLowerCase().includes("softmaxcrossentropy")&&(n="Unknown loss "+e+'. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new ValueError(n)}return e}function binaryAccuracy(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(.5,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(t)),r=cast$1(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greater"])(t,n),e.dtype);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equal"])(e,r),-1)})}function categoricalAccuracy(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return cast$1(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equal"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMax"])(e,-1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMax"])(t,-1)),"float32")})}function truePositives(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"])(e.equal(1),t.equal(1)).sum().cast("float32")})}function falseNegatives(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"])(e.equal(1),t.equal(0)).sum().cast("float32")})}function falsePositives(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"])(e.equal(0),t.equal(1)).sum().cast("float32")})}function precision(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=truePositives(e,t),r=falsePositives(e,t),i=n.add(r);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["where"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greater"])(i,0),n.div(i),0).cast("float32")})}function recall(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=truePositives(e,t),r=falseNegatives(e,t),i=n.add(r);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["where"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greater"])(i,0),n.div(i),0).cast("float32")})}function binaryCrossentropy$1(e,t){return binaryCrossentropy(e,t)}function sparseCategoricalAccuracy(e,t){return e.rank===t.rank&&(e=e.squeeze([e.rank-1])),(t=t.argMax(-1)).dtype!==e.dtype&&(t=t.asType(e.dtype)),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equal"])(e,t).asType("float32")}var mse$1=meanSquaredError,MSE$1=meanSquaredError,mae$1=meanAbsoluteError,MAE$1=meanAbsoluteError,mape$1=meanAbsolutePercentageError,MAPE$1=meanAbsolutePercentageError,categoricalCrossentropy$1=categoricalCrossentropy,cosine$1=cosineProximity,sparseCategoricalCrossentropy$1=sparseCategoricalCrossentropy;function get$1(e){var t={binaryAccuracy:binaryAccuracy,categoricalAccuracy:categoricalAccuracy,precision:precision,categoricalCrossentropy:categoricalCrossentropy$1,sparseCategoricalCrossentropy:sparseCategoricalCrossentropy$1,mse:mse$1,MSE:MSE$1,mae:mae$1,MAE:MAE$1,mape:mape$1,MAPE:MAPE$1,cosine:cosine$1};if("string"==typeof e&&e in t)return t[e];if("string"!=typeof e&&null!=e)return e;throw new ValueError("Unknown metric "+e)}function getOptimizer(e){var t={Adagrad:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].adagrad(.01)},Adadelta:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].adadelta(1,.95,epsilon())},Adam:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].adam(.001,.9,.999,epsilon())},Adamax:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].adamax(.002,.9,.999,epsilon(),0)},RMSProp:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].rmsprop(.001,.9,0,epsilon())},SGD:function(){return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"].sgd(.01)}};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new ValueError("Unknown Optimizer "+e)}function printSummary(e,t,n,r){void 0===r&&(r=console.log);var i,a=isModelSequentialLike(e),o=["Layer (type)","Output shape","Param #"];if(a?(t=t||65,n=n||[.45,.85,1]):(t=t||98,n=n||[.33,.55,.67,1]),n[n.length-1]<=1&&(n=n.map(function(e){return Math.floor(t*e)})),!a)for(var s in o.push("Receives inputs"),i=[],e.nodesByDepth)i.push.apply(i,e.nodesByDepth[s]);r("_".repeat(t)),printRow(o,n,r),r("=".repeat(t));for(var l=e.layers,u=0;u<l.length;++u)a?printLayerSummary(l[u],n,r):printLayerSummaryWithConnections(l[u],n,i,r),r((u===l.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();var c=countTrainableParams(e),p=countParamsInWeights(e.nonTrainableWeights);r("Total params: "+(c+p)),r("Trainable params: "+c),r("Non-trainable params: "+p),r("_".repeat(t))}function countTrainableParams(e){return null!=e.collectedTrainableWeights?countParamsInWeights(e.collectedTrainableWeights):countParamsInWeights(e.trainableWeights)}function isModelSequentialLike(e){var t=!0,n=[],r=[];for(var i in e.nodesByDepth)n.push(e.nodesByDepth[i]);for(var a=0,o=n;a<o.length;a++){var s=o[a];if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){t=!1;break}r.push.apply(r,s)}if(t)for(var l=0,u=e.layers;l<u.length;l++){for(var c=!1,p=0,h=u[l].inboundNodes;p<h.length;p++){var d=h[p];if(-1!==r.indexOf(d)){if(c){t=!1;break}c=!0}}if(!t)break}return t}function printRow(e,t,n){void 0===n&&(n=console.log);for(var r="",i=0;i<e.length;++i)i>0&&(r=r.slice(0,r.length-1)+" "),r=(r+=e[i]).slice(0,t[i]),r+=" ".repeat(t[i]-r.length);n(r)}function printLayerSummary(e,t,n){var r;try{r=JSON.stringify(e.outputShape)}catch(e){r="multiple"}printRow([e.name+" ("+e.getClassName()+")",r,e.countParams().toString()],t,n)}function printLayerSummaryWithConnections(e,t,n,r){var i;try{i=JSON.stringify(e.outputShape)}catch(e){i="multiple"}for(var a=[],o=0,s=e.inboundNodes;o<s.length;o++){var l=s[o];if(!(null!=n&&n.length>0&&-1===n.indexOf(l)))for(var u=0;u<l.inboundLayers.length;++u){var c=l.inboundLayers[u].name,p=l.nodeIndices[u],h=l.tensorIndices[u];a.push(c+"["+p+"]["+h+"]")}}var d=e.name,f=e.getClassName(),g=0===a.length?"":a[0];printRow([d+" ("+f+")",i,e.countParams().toString(),g],t,r);for(u=1;u<a.length;++u)printRow(["","","",a[u]],t,r)}var version="1.1.2";function deserialize(e,t,n){return void 0===t&&(t={}),void 0===n&&(n=!1),deserializeKerasObject(e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].SerializationMap.getMap().classNameMap,t,"layer",n)}function isArrayItemInputOrOutputName(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function convertPythonicToTs(e,t){if(null===e)return null;if("string"==typeof e)return toCamelCase(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){for(var n=[],r=e.length,i=0;i<r;++i){var a=e[i];isArrayItemInputOrOutputName(t,i,a)?n.push(a):n.push(convertPythonicToTs(a,t))}return n}for(var o={},s=0,l=Object.keys(e);s<l.length;s++){var u=l[s],c=e[u];if("name"===u&&"string"==typeof c)o[u]=c;else{var p=toCamelCase(u);o[p]=convertPythonicToTs(c,p)}}return o}function convertTsToPythonic(e,t){if(null===e||void 0===e)return null;if("string"==typeof e)return toSnakeCase(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){for(var n=[],r=e.length,i=0;i<r;++i){var a=e[i];isArrayItemInputOrOutputName(t,i,a)?n.push(a):n.push(convertTsToPythonic(a,t))}return n}for(var o={},s=0,l=Object.keys(e);s<l.length;s++){var u=l[s],c=e[u],p=toSnakeCase(u);o[p]="name"!==u&&"className"!==u||"string"!=typeof c?convertTsToPythonic(c,u):c}return o}function assertFeedCompatibility(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cast"])(t,e.dtype)}catch(n){throw new ValueError("The dtype of the feed ("+t.dtype+") can not be cast to the dtype of the key '"+e.name+"' ("+e.dtype+").")}}var FeedDict=function(){function e(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof e)for(var n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(null==t)return;for(var r=0,i=t;r<i.length;r++){var a=i[r];this.add(a.key,a.value)}}}return e.prototype.add=function(e,t,n){if(null!=this.id2Value[e.id])throw new ValueError("Duplicate key: name="+e.name+", id="+e.id);return this.id2Value[e.id]=assertFeedCompatibility(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this},e.prototype.addFeed=function(e){this.add(e.key,e.value)},e.prototype.hasKey=function(e){return null!=this.id2Value[e.id]},e.prototype.names=function(){return Object.keys(this.name2Id)},e.prototype.getValue=function(e){if(e instanceof SymbolicTensor){if(null==this.id2Value[e.id])throw new ValueError("Nonexistent key: "+e.name);return this.id2Value[e.id]}var t=this.name2Id[e];if(null==t)throw new ValueError("Feed dict has no SymbolicTensor name: "+e);return this.id2Value[t]},e.prototype.getMask=function(e){if(e instanceof SymbolicTensor){if(null==this.id2Value[e.id])throw new ValueError("Nonexistent key: "+e.name);return this.id2Mask[e.id]}var t=this.name2Id[e];if(null==t)throw new ValueError("Feed dict has no SymbolicTensor name: "+e);return this.id2Mask[t]},e.prototype.disposeMasks=function(){null!=this.id2Mask&&Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(this.id2Mask)},e}(),cachedSorted={},cachedRecipientCounts={};function execute(e,t,n,r){for(var i=null!=n&&n.training,a=Array.isArray(e),o=a?e:[e],s=o.map(function(e){return e.name}),l=[],u=t.names(),c=0,p=s;c<p.length;c++){var h=p[c];-1!==u.indexOf(h)?l.push(t.getValue(h)):l.push(null)}null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);var d,f,g=s.join(",")+"|"+t.names().join(",");if(null==cachedSorted[g]){var m=getTopologicalSortAndRecipientCounts(o,t);d=m.sorted,f=m.recipientCounts,cachedSorted[g]=d,cachedRecipientCounts[g]=f}d=cachedSorted[g],f={},i||Object.assign(f,cachedRecipientCounts[g]);for(var y=new FeedDict(t),v=0;v<d.length;++v){if(null!=r){var b=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["memory"])().numTensors;b>r.maxNumTensors&&(r.maxNumTensors=b),b<r.minNumTensors&&(r.minNumTensors=b)}var w=d[v],z=w.sourceLayer;if(!(z instanceof InputLayer)){for(var S=[],I=[],A=[],_=!1,C=0,N=w.inputs;C<N.length;C++){var E=N[C],k=y.getValue(E),L=y.getMask(E);S.push(k),I.push(L),null!=L&&(_=!0),i||(f[E.name]--,0!==f[E.name]||t.hasKey(E)||-1!==s.indexOf(E.name)||k.isDisposed||!0===E.sourceLayer.stateful||A.push(k))}_&&((n=n||{}).mask=I[0]);var x=toList(z.apply(S,n)),T=null;z.supportsMasking&&(T=z.computeMask(S,I));for(var D=getNodeOutputs(w),O=Array.isArray(D)?D:[D],R=0;R<O.length;++R){y.hasKey(O[R])||y.add(O[R],x[R],Array.isArray(T)?T[0]:T);var M=s.indexOf(O[R].name);-1!==M&&(l[M]=x[R])}i||Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(A)}}return y.disposeMasks(),a?l:l[0]}function getTopologicalSortAndRecipientCounts(e,t){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=e&&e.length>0,function(){return"Expected at least one fetch, got none"});var n=[],r={};if(1===e.length){var i=getTopologicalSortAndRecipientCountsForOneFetch(e[0],t);n=i.sorted,r=i.recipientMap}else for(var a=new Set,o=0,s=e;o<s.length;o++){for(var l=getTopologicalSortAndRecipientCountsForOneFetch(s[o],t),u=l.sorted,c=l.recipientMap,p=0,h=u;p<h.length;p++){var d=h[p];a.has(d.name)||(n.push(d),a.add(d.name))}var f=function(e){null==r[e]&&(r[e]=new Set),c[e].forEach(function(t){return r[e].add(t)})};for(var g in c)f(g)}return{sorted:n,recipientCounts:recipientMap2Counts(r)}}function recipientMap2Counts(e){var t={};for(var n in e)t[n]=e[n].size;return t}function getTopologicalSortAndRecipientCountsForOneFetch(e,t){for(var n=new Set,r=[],i={},a=0,o=t.names();a<o.length;a++){var s=o[a];n.add(s)}var l=[],u=[];for(l.push(e);l.length>0;){var c=l[l.length-1];if(n.has(c.name))l.pop();else{var p=u[u.length-1]===l.length-1;if(0===c.inputs.length||p)l.pop(),r.push(c),n.add(c.name),p&&u.pop();else{u.push(l.length-1);for(var h=0,d=c.inputs;h<d.length;h++){var f=d[h];null==i[f.name]&&(i[f.name]=new Set),i[f.name].add(c.name),n.has(f.name)||l.push(f)}}}}return{sorted:r,recipientMap:i}}function getNodeOutputs(e){var t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{for(var n=null,r=0;r<e.sourceLayer.inboundNodes.length;++r)for(var i=0,a=e.sourceLayer.inboundNodes[r].outputTensors;i<a.length;i++){if(a[i].id===e.id){n=r;break}}t=e.sourceLayer.getOutputAt(n)}return t}var Container=function(e){function t(n){var r=e.call(this,{})||this;if(r.containerNodes=new Set,r.name=n.name,null==r.name){var i=r.getClassName().toLowerCase();r.name=getUid(i)}if(r.supportsMasking=!1,r.trainable_=!0,r.updatable=!0,Array.isArray(n.inputs)?r.inputs=n.inputs.slice():r.inputs=[n.inputs],Array.isArray(n.outputs)?r.outputs=n.outputs.slice():r.outputs=[n.outputs],unique(r.inputs).length!==r.inputs.length)throw new ValueError("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+r.inputs.map(function(e){return e.name}));unique(r.outputs).length!==r.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+r.outputs.map(function(e){return e.name})),r.inputLayers=[],r.inputLayersNodeIndices=[],r.inputLayersTensorIndices=[],r.outputLayers=[],r.outputLayersNodeIndices=[],r.outputLayersTensorIndices=[],r.layers=[];for(var a=0,o=r.outputs;a<o.length;a++){var s=(C=o[a]).sourceLayer,l=C.nodeIndex,u=C.tensorIndex;r.outputLayers.push(s),r.outputLayersNodeIndices.push(l),r.outputLayersTensorIndices.push(u)}for(var c=0,p=r.inputs;c<p.length;c++){s=(C=p[c]).sourceLayer,l=C.nodeIndex,u=C.tensorIndex;assert(0===l,"input layer has >1 nodes"),assert(0===u,"input layer has >1 tensors"),r.inputLayers.push(s),r.inputLayersNodeIndices.push(l),r.inputLayersTensorIndices.push(u)}r.inputNames=[],r.outputNames=[],r.feedInputShapes=[],r.feedInputNames=[],r.feedOutputNames=[];for(var h=0;h<r.inputLayers.length;h++){if(!((s=r.inputLayers[h])instanceof InputLayer))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. Received inputs: "+n.inputs+". Input "+h+" (0-based) originates from layer type "+s.getClassName()+".");r.inputNames.push(s.name),r.feedInputShapes.push(s.batchInputShape),r.feedInputNames.push(s.name)}for(var d=0,f=r.outputLayers;d<f.length;d++){s=f[d];r.outputNames.push(s.name)}r.internalInputShapes=r.inputs.map(function(e){return e.shape}),r.internalOutputShapes=r.outputs.map(function(e){return e.shape});for(var g={},m={},y={},v={},b={},w=[],z=function(e,n,i,a,o,s){null!=a&&null!=o&&null!=s||(a=e.sourceLayer,o=e.nodeIndex,s=e.tensorIndex);var l=a.inboundNodes[o];if(-1!==i.indexOf(l))throw new RuntimeError("The tensor "+e.name+' at layer "'+a.name+'" is part of a cycle.');if(-1===n.indexOf(l)){r.containerNodes.add(t.nodeKey(a,o)),a.id in b||(b[a.id]=Object.keys(b).length),-1===i.indexOf(l)&&i.push(l);for(var u=l.inboundLayers.length,c=0;c<u;c++){var p=l.inputTensors[c],h=l.inboundLayers[c],d=l.nodeIndices[c],f=l.tensorIndices[c];z(p,n,i,h,d,f)}for(n.push(l);i.indexOf(l)>=0;)i.splice(i.indexOf(l),1);w.push(l)}},S=[],I=[],A=0,_=r.outputs;A<_.length;A++){var C=_[A];z(C,S,I)}for(var N=0,E=w.slice().reverse();N<E.length;N++){m[(K=E[N]).id]=K,K.id in g||(g[K.id]=0);var k=g[K.id],L=null==y[K.outboundLayer.id]?0:y[K.outboundLayer.id];k=Math.max(k,L),y[K.outboundLayer.id]=k,v[K.outboundLayer.id]=K.outboundLayer,g[K.id]=k;for(h=0;h<K.inboundLayers.length;h++){var x=K.inboundLayers[h],T=(l=K.nodeIndices[h],x.inboundNodes[l]),D=null==g[T.id]?0:g[T.id];g[T.id]=Math.max(k+1,D),m[T.id]=T}}var O={};for(var R in g){(k=g[R])in O||(O[k]=[]),O[k].push(m[R])}var M={};for(var P in y){(k=y[P])in M||(M[k]=[]),M[k].push(v[P])}var F=Object.keys(M).map(function(e){return parseInt(e,10)}).sort(reverseNumberCompare);r.layers=[];for(var V=0,B=F;V<B.length;V++){var U=M[k=B[V]];U.sort(function(e,t){var n=b[e.id],r=b[t.id];return n<r?-1:n>r?1:0});for(var j=0,W=U;j<W.length;j++){s=W[j];r.layers.push(s)}}r.layersByDepth=M,F=Object.keys(O).map(function(e){return parseInt(e,10)}).sort(reverseNumberCompare);for(var $=r.inputs.slice(),q=[],G=0,H=F;G<H.length;G++)for(var J=0,Z=O[k=H[G]];J<Z.length;J++){var K;if(null!=(s=(K=Z[J]).outboundLayer)){for(var Y=0,X=K.inputTensors;Y<X.length;Y++){C=X[Y];if(-1===$.indexOf(C))throw new RuntimeError("Graph disconnected: cannot obtain value for tensor "+C+' at layer "'+s.name+'". The following previous layers were accessed without issue: '+q)}for(var Q=0,ee=K.outputTensors;Q<ee.length;Q++){C=ee[Q];$.push(C)}q.push(s.name)}}r.nodesByDepth=O;for(var te=r.layers.map(function(e){return e.name}),ne=function(e){var t=te.filter(function(t){return t===e}).length;if(1!==t)throw new RuntimeError('The name "'+e+'" is used '+t+" times in the model. All layer names should be unique. Layer names: "+JSON.stringify(te))},re=0,ie=te;re<ie.length;re++){ne(ie[re])}return r.outboundNodes=[],r.inboundNodes=[],new Node({outboundLayer:r,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:r.inputs,outputTensors:r.outputs,inputMasks:r.inputs.map(function(e){return null}),outputMasks:r.outputs.map(function(e){return null}),inputShapes:r.inputs.map(function(e){return e.shape}),outputShapes:r.outputs.map(function(e){return e.shape})}),r.built=!0,r._refCount=1,r}return __extends(t,e),t.prototype.assertNotDisposed=function(){if(0===this._refCount)throw new Error("Container '"+this.name+"' is already disposed.")},t.prototype.dispose=function(){this.assertNotDisposed();var e={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount)for(var t=0,n=this.layers;t<n.length;t++){var r=n[t];e.numDisposedVariables+=r.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e},Object.defineProperty(t.prototype,"trainable",{get:function(){return this.trainable_},set:function(e){this.layers.forEach(function(t){t._trainableWeights.forEach(function(t){return t.trainable=e})}),this.trainable_=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"trainableWeights",{get:function(){if(this._trainableWeights.length>0)throw new ValueError("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];for(var e=[],t=0,n=this.layers;t<n.length;t++){var r=n[t];e=e.concat(r.trainableWeights)}return e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){for(var e=[],t=0,n=this.layers;t<n.length;t++){var r=n[t];e.push.apply(e,r.nonTrainableWeights)}if(!this.trainable){for(var i=[],a=0,o=this.layers;a<o.length;a++){r=o[a];i.push.apply(i,r.trainableWeights)}return i.concat(e)}return e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"weights",{get:function(){return this.trainableWeights.concat(this.nonTrainableWeights)},enumerable:!0,configurable:!0}),t.prototype.loadWeights=function(e,t){void 0===t&&(t=!0);for(var n={},r=0,i=0,a=this.layers;i<a.length;i++)for(var o=0,s=a[i].weights;o<s.length;o++){var l=s[o];if(null!=n[l.originalName])throw new ValueError("Duplicate weight name: "+l.originalName);n[l.originalName]=l,r++}var u=[];for(var c in e){if(null!=n[c])u.push([n[c],e[c]]);else if(t)throw new ValueError("Provided weight data has no target variable: "+c);delete n[c]}if(t){var p=[];for(var h in n)p.push(h);if(p.length>0)throw new ValueError(p.length+" of "+r+" weights are not set: "+p)}batchSetValue(u)},t.prototype.updatedConfig=function(){var e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion="tfjs-layers "+version,t.backend="TensorFlow.js",t},t.prototype.toJSON=function(e,t){void 0===t&&(t=!0);var n=convertTsToPythonic(this.updatedConfig());return t?JSON.stringify(n):n},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){e=toList(e);for(var r=new FeedDict,i=0;i<n.inputs.length;++i)r.add(n.inputs[i],e[i]);return execute(n.outputs,r,t)})},t.prototype.computeMask=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r;return e=toList(e),r=null==t?pyListRepeat(null,e.length):toList(t),n.runInternalGraph(e,r)[1]})},t.prototype.computeOutputShape=function(e){var t=normalizeShapeList(e);if(t.length!==this.inputLayers.length)throw new ValueError("Invalid inputShape argument "+e+": model has "+this.inputLayers.length+" tensor inputs.");for(var n={},r=0;r<t.length;r++){var i=this.inputLayers[r],a=t[r];n[I=i.name+"_0_0"]=a}var o=Object.keys(this.nodesByDepth).map(function(e){return parseInt(e,10)}).sort(reverseNumberCompare);if(o.length>1)for(var s=0,l=o;s<l.length;s++)for(var u=l[s],c=0,p=this.nodesByDepth[u];c<p.length;c++){var h=p[c];i=h.outboundLayer;if(-1===this.inputLayers.map(function(e){return e.id}).indexOf(i.id)){for(var d=[],f=0;f<h.inboundLayers.length;f++){var g=h.inboundLayers[f],m=h.nodeIndices[f],y=h.tensorIndices[f],v=n[I=g.name+"_"+m+"_"+y];d.push(v)}var b=normalizeShapeList(i.computeOutputShape(singletonOrArray(d))),w=i.inboundNodes.indexOf(h);for(f=0;f<b.length;f++){n[I=i.name+"_"+w+"_"+f]=b[f]}}}var z=[],S=[];for(r=0;r<this.outputLayers.length;r++){i=this.outputLayers[r],w=this.outputLayersNodeIndices[r],y=this.outputLayersTensorIndices[r];var I=i.name+"_"+w+"_"+y;S.push(I)}for(r=0;r<S.length;r++){var A=S[r];assert(A in n),z.push(n[A])}return singletonOrArray(z)},t.prototype.runInternalGraph=function(e,t){null==t&&(t=pyListRepeat(null,e.length));for(var n={},r=0;r<this.inputs.length;++r){var i=this.inputs[r],a=e[r],o=t[r];n[i.id]=[a,o]}for(var s=0,l=Object.keys(this.nodesByDepth).map(function(e){return parseInt(e,10)}).sort(reverseNumberCompare);s<l.length;s++)for(var u=l[s],c=0,p=this.nodesByDepth[u];c<p.length;c++){for(var h=p[c],d=h.outboundLayer,f=h.inputTensors,g=h.outputTensors,m=new Array,y=0,v=f;y<v.length;y++){(i=v[y]).id in n&&m.push(n[i.id])}if(m.length===f.length){var b={},w=void 0,z=void 0,S=void 0,I=void 0;if(null!=h.callArgs&&(b=h.callArgs),1===m.length){var A=m[0],_=A[0],C=A[1];null==b.mask&&(b.mask=C),S=toList(d.call(_,b)),I=toList(d.computeMask(_,C)),w=[_],z=[C]}else w=m.map(function(e){return e[0]}),z=m.map(function(e){return e[1]}),null==b.mask&&(b.mask=z),S=toList(d.call(w,b)),I=toList(d.computeMask(w,z));if(d.activityRegularizer)throw new NotImplementedError("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(r=0;r<g.length;++r){i=g[r],a=S[r],o=I[r];n[i.id]=[a,o]}}}for(var N=[],E=[],k=[],L=0,x=this.outputs;L<x.length;L++){assert((i=x[L]).id in n,"Could not compute output "+i.name+" : "+i.id);var T=n[i.id],D=T[0];o=T[1];k.push(D.shape),N.push(D),E.push(o)}return[N,E,k]},t.prototype.buildNodeConversionMap=function(e){for(var n,r={},i=0,a=this.layers;i<a.length;i++){var o=a[i];n=o instanceof t?1:0;for(var s=0;s<o.inboundNodes.length;s++){var l=t.nodeKey(o,s);this.containerNodes.has(l)&&(r[l]=n,n+=1)}}return r},t.prototype.getLayer=function(e,t){if(null!=t){if(this.layers.length<=t)throw new ValueError("Was asked to retrieve layer at index "+t+", but model only has "+this.layers.length+" layer(s).");return this.layers[t]}if(null==e)throw new ValueError("Provide either a layer name or layer index");for(var n=0,r=this.layers;n<r.length;n++){var i=r[n];if(i.name===e)return i}throw new ValueError("No such layer: "+e)},t.prototype.calculateLosses=function(){var e=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var n=[],r=0,i=e.layers;r<i.length;r++)for(var a=i[r],o=0;o<a.inboundNodes.length;++o){var s=t.nodeKey(a,o);e.containerNodes.has(s)&&n.push.apply(n,a.calculateLosses())}return n})},t.prototype.getConfig=function(){for(var e={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[],i=0,a=this.layers;i<a.length;i++){for(var o=(w=a[i]).getClassName(),s=w.getConfig(),l=[],u=0;u<w.inboundNodes.length;u++){var c=w.inboundNodes[u],p=t.nodeKey(w,u),h={};if(this.containerNodes.has(p)){if(c.callArgs)try{JSON.stringify(c.callArgs),h=c.callArgs}catch(e){console.warn("Layer "+w.name+" was passed non-serializable keyword arguments: "+c.callArgs+". They will not be included in the serialized model (and thus will be missing at deserialization time)."),h={}}if(c.inboundLayers.length>0){for(var d=[],f=0;f<c.inboundLayers.length;f++){var g=c.inboundLayers[f],m=c.nodeIndices[f],y=c.tensorIndices[f];null==(S=n[t.nodeKey(g,m)])&&(S=0),d.push([g.name,S,y,h])}l.push(d)}}}var v={};v.name=w.name,v.className=o,v.config=s,v.inboundNodes=l,r.push(v)}e.layers=r;var b=[];for(f=0;f<this.inputLayers.length;f++){var w=this.inputLayers[f];m=this.inputLayersNodeIndices[f],p=t.nodeKey(w,m);if(this.containerNodes.has(p)){null!==(S=n[p])&&void 0!==S||(S=0);y=this.inputLayersTensorIndices[f];b.push([w.name,S,y])}}e.inputLayers=b;var z=[];for(f=0;f<this.outputLayers.length;f++){w=this.outputLayers[f],m=this.outputLayersNodeIndices[f],p=t.nodeKey(w,m);if(this.containerNodes.has(p)){var S;null!==(S=n[p])&&void 0!==S||(S=0);y=this.outputLayersTensorIndices[f];z.push([w.name,S,y])}}return e.outputLayers=z,e},t.fromConfig=function(e,t,n,r){void 0===n&&(n={}),void 0===r&&(r=!1);var i={},a={};function o(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function s(e,t){for(var n,r=[],a=0,s=t;a<s.length;a++){var l=s[a],u=l[0],c=l[1],p=l[2];if(n=null==l[3]?{}:l[3],!(u in i))return void o(e,t);var h=i[u];if(h.inboundNodes.length<=c)return void o(e,t);var d=h.inboundNodes[c];r.push(d.outputTensors[p])}r.length>0&&e.apply(singletonOrArray(r),n)}function l(e){var n=e.name,a=deserialize(e,null!=t.customObjects?t.customObjects:{});a.setFastWeightInitDuringBuild(r),i[n]=a,e.inboundNodes.forEach(function(e){if(!(e instanceof Array))throw new ValueError("Corrupted configuration, expected array for nodeData: "+e);o(a,e)})}for(var u=t.name,c=t.layers,p=0,h=c;p<h.length;p++){l(g=h[p])}for(;!isObjectEmpty(a);)for(var d=0,f=c;d<f.length;d++){var g=f[d];if((k=i[g.name]).name in a){var m=a[k.name];delete a[k.name];for(var y=0,v=m;y<v.length;y++){s(k,v[y])}}}for(var b=[],w=[],z=0,S=t.inputLayers;z<S.length;z++){var I=(g=S[z])[0],A=g[1],_=g[2];assert(I in i);var C=(k=i[I]).inboundNodes[A].outputTensors;b.push(C[_])}for(var N=0,E=t.outputLayers;N<E.length;N++){I=(g=E[N])[0],A=g[1],_=g[2];assert(I in i);var k;C=(k=i[I]).inboundNodes[A].outputTensors;w.push(C[_])}return new e({inputs:b,outputs:w,name:u})},Object.defineProperty(t.prototype,"stateful",{get:function(){if(this._stateful)throw new ValueError("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(var e=0,t=this.layers;e<t.length;e++){if(t[e].stateful)return!0}return!1},enumerable:!0,configurable:!0}),t.prototype.resetStates=function(){var e=this;Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){e.layers.forEach(function(e){e.stateful&&e.resetStates()})})},t}(Layer),DEFAULT_VALIDATION_BATCH_SIZE=32;function standardizeDataIteratorOutput(e,t){var n,r,i=t;n=i.xs,r=i.ys,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=n&&null!=r,function(){return"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+t});var a=flattenTensorOrArrayOrMap("input",e.inputNames,n),o=flattenTensorOrArrayOrMap("output",e.outputNames,r),s=a[0].shape[0];_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(a.length===e.inputs.length,function(){return"LayersModel has "+e.inputs.length+" inputs, but the dataset provides "+a.length+" inputs.  (Expected input keys: "+JSON.stringify(e.inputNames)+")"}),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(o.length===e.outputs.length,function(){return"LayersModel has "+e.outputs.length+" outputs, but the dataset provides "+o.length+" outputs.  (Expected output keys: "+JSON.stringify(e.outputNames)+")"});var l=function(t){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(a[t].shape[0]===s,function(){return"Batch size mismatch: input "+e.inputNames[t]+" has "+a[t].shape[0]+"; expected  "+s+" based on input "+e.inputNames[0]+"."})};for(var u in a)l(u);var c=function(t){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(o[t].shape[0]===s,function(){return"Batch size mismatch: output "+e.outputNames[t]+" has "+o[t].shape[0]+"; expected  "+s+" based on input "+e.inputNames[0]+"."})};for(var p in o)c(p);return a.concat(o)}function flattenTensorOrArrayOrMap(e,t,n){if(n instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"])return[n];if(Array.isArray(n))return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(n.length===t.length,function(){return"Received an array of "+n.length+" Tensors, but expected "+t.length+" to match the "+e+" keys "+t+"."}),n;for(var r=[],i=0,a=t;i<a.length;i++){var o=a[i];if(null==n[o])throw new ValueError("The feature data generated by the dataset lacks the required "+e+" key '"+o+"'.");r.push(n[o])}return r}function standardizeTensorValidationData(e){if(3===e.length)throw new NotImplementedError("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}function fitDataset(e,t,n){return __awaiter(this,void 0,void 0,function(){var r,i,a,o,s,l,u,c,p,h,d,f,g,m,y,v,b,w,z,S,I,A,_,C,N,E,k;return __generator(this,function(L){switch(L.label){case 0:if(r=null!=n.batchesPerEpoch,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=e.optimizer,function(){return"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."}),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=n,function(){return"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."}),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),function(){return"For fitDataset(), config.epochs is expected to be a positive integer, but got "+n.epochs}),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),function(){return"For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got "+n.batchesPerEpoch}),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null==n.validationSplit,function(){return"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."}),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0,L.label=1;case 1:return L.trys.push([1,,22,23]),i=null!=n.validationData,a=void 0,o=void 0,i&&(isDatasetObject(n.validationData)?_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),function(){return"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got "+n.validationBatches}):(s=standardizeTensorValidationData(n.validationData),a=s.xs,o=s.ys)),l=e.makeTrainFunction(),u=e.getDedupedMetricsNames(),c=void 0,c=i?u.slice().concat(u.map(function(e){return"val_"+e})):u.slice(),p=standardizeCallbacks(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,d=configureCallbacks(p,h,n.epochs,null,null,getStepsPerEpoch(t,n),null,i,c),f=d.callbackList,g=d.history,f.setModel(e),e.history=g,[4,f.onTrainBegin()];case 2:return L.sent(),e.stopTraining_=!1,m=null==n.initialEpoch?0:n.initialEpoch,[4,t.iterator()];case 3:y=L.sent(),L.label=4;case 4:return m<n.epochs?(v={},[4,f.onEpochBegin(m)]):[3,19];case 5:return L.sent(),b=0,w=0,r?[3,7]:[4,t.iterator()];case 6:y=L.sent(),L.label=7;case 7:return!r||b<n.batchesPerEpoch?[4,y.next()]:[3,17];case 8:return z=L.sent(),r&&z.done?(console.warn("You provided `batchesPerEpoch` as "+n.batchesPerEpoch+", but your dataset iterator ran out of data after "+b+" batches; interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset."),[3,17]):null==z.value?[3,11]:(S=standardizeDataIteratorOutput(e,z.value),(I={}).batch=w,I.size=S[0].shape[0],[4,f.onBatchBegin(w,I)]);case 9:for(L.sent(),A=l(S),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(S),k=0;k<u.length;++k)_=u[k],C=A[k],I[_]=C,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(C);return[4,f.onBatchEnd(w,I)];case 10:L.sent(),disposeTensorsInLogs(I),w++,b++,L.label=11;case 11:return(r?b>=n.batchesPerEpoch:z.done)?i?(N=void 0,isDatasetObject(n.validationData)?(E=toList,[4,e.evaluateDataset(n.validationData,{batches:n.validationBatches})]):[3,13]):[3,15]:[3,16];case 12:return N=E.apply(void 0,[L.sent()]),[3,14];case 13:N=toList(e.evaluate(a,o,{batchSize:null==n.validationBatchSize?DEFAULT_VALIDATION_BATCH_SIZE:n.validationBatchSize,verbose:0})),L.label=14;case 14:for(k=0;k<e.metricsNames.length;++k)v["val_"+e.metricsNames[k]]=N[k];L.label=15;case 15:return[3,17];case 16:return e.stopTraining_?[3,17]:[3,7];case 17:return[4,f.onEpochEnd(m,v)];case 18:return L.sent(),m++,e.stopTraining_?[3,19]:[3,4];case 19:return[4,f.onTrainEnd()];case 20:return L.sent(),[4,e.history.syncData()];case 21:return L.sent(),[2,e.history];case 22:return e.isTraining=!1,[7];case 23:return[2]}})})}function getStepsPerEpoch(e,t){var n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function isDatasetObject(e){return"function"==typeof e.iterator}function isLazyIteratorObject(e){return"function"==typeof e.next}function evaluateDataset(e,t,n){return __awaiter(this,void 0,void 0,function(){var r,i,a,o,s,l,u,c,p,h;return __generator(this,function(d){switch(d.label){case 0:if(r=null!=(n=n||{}).batches,i=e.testFunction,a=[],n.verbose>0)throw new NotImplementedError("Verbose mode is not implemented yet.");return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(!r||n.batches>0&&Number.isInteger(n.batches),function(){return"Test loop expects `batches` to be a positive integer, but received "+JSON.stringify(n.batches)}),isLazyIteratorObject(t)?(s=t,[3,3]):[3,1];case 1:return[4,t.iterator()];case 2:s=d.sent(),d.label=3;case 3:o=s,l=0,u=0,c=function(){var t;return __generator(this,function(s){switch(s.label){case 0:return[4,o.next()];case 1:return t=s.sent(),a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(t.value){var n=standardizeDataIteratorOutput(e,t.value),r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return i(n)});if(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(n),0===u)for(var o=0;o<r.length;++o)a.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(0));var s=n[0].shape[0],c=function(e){var t=r[e],n=a[e];a[e]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(a[e],Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(s,t))}),u>0&&Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(n)};for(o=0;o<r.length;++o)c(o);Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r),l+=s,++u}return a}),t.done?(r&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` batches (in this case, "+n.batches+" batches). You may need to use the repeat() function when building your dataset."),[2,"break"]):[2]}})},d.label=4;case 4:return!r||u<n.batches?[5,c()]:[3,6];case 5:return"break"===d.sent()?[3,6]:[3,4];case 6:for(p=0;p<a.length;++p)h=a[p],a[p]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(a[p],l),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(h);return[2,singletonOrArray(a)]}})})}function checkBatchSize(e){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(e>0&&Number.isInteger(e),function(){return"batchSize is required to be a positive integer, but got "+e})}function sliceArrays(e,t,n){return null==e?[null]:Array.isArray(e)?e.map(function(e){return sliceAlongFirstAxis(e,t,n-t)}):sliceAlongFirstAxis(e,t,n-t)}function sliceArraysByIndices(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return null==e?null:Array.isArray(e)?e.map(function(e){return sliceArraysByIndices(e,t)}):gather$1(e,"int32"===t.dtype?t:t.toInt())})}function makeBatches(e,t){for(var n=[],r=0,i=null;r<e;)(i=r+t)>=e&&(i=e),n.push([r,i]),r=i;return n}function fitLoop(e,t,n,r,i,a,o,s,l,u,c,p,h,d,f){return __awaiter(this,void 0,void 0,function(){var g,m,y,v,b,w,z,S;return __generator(this,function(I){switch(I.label){case 0:if(null==i&&(i=32),null==a&&(a=1),null==c&&(c=!0),null==h&&(h=0),g=!1,null!=l&&null!=u&&(g=!0),null!=f&&(g=!0,null==d))throw new ValueError("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");return null!=(m=e.checkNumSamples(n,i,d,"steps_per_epoch"))&&(y=range(0,m)),null==o&&(o=1),v=configureCallbacks(s,o,a,h,m,d,i,g,p),b=v.callbackList,w=v.history,b.setModel(e),e.history=w,[4,b.onTrainBegin()];case 1:I.sent(),e.stopTraining_=!1,z=function(a){var o,s,p,h,f;return __generator(this,function(v){switch(v.label){case 0:return[4,b.onEpochBegin(a)];case 1:if(v.sent(),o={},null==d)return[3,2];throw new NotImplementedError("stepsPerEpoch mode is not implemented yet.");case 2:if("batch"===c)throw new NotImplementedError("batch shuffling is not implemneted yet");c&&_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].shuffle(y),s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(y),p=makeBatches(m,i),h=function(a){var c;return __generator(this,function(h){switch(h.label){case 0:return c={},[4,b.onBatchBegin(a,c)];case 1:return h.sent(),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var h=p[a][0],d=p[a][1],f=sliceAlongFirstAxis(s,h,d-h);c.batch=a,c.size=d-h;for(var m=sliceArraysByIndices(n,f),y=t(m),v=0;v<r.length;++v){var b=r[v],w=y[v];c[b]=w,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(w)}if(a===p.length-1&&g){var z=e.testLoop(l,u,i);for(v=0;v<r.length;++v){b=r[v],w=z[v];Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(w),o["val_"+b]=w}}}),[4,b.onBatchEnd(a,c)];case 2:return h.sent(),disposeTensorsInLogs(c),e.stopTraining_?[2,"break"]:[2]}})},f=0,v.label=3;case 3:return f<p.length?[5,h(f)]:[3,6];case 4:if("break"===v.sent())return[3,6];v.label=5;case 5:return++f,[3,3];case 6:s.dispose(),v.label=7;case 7:return[4,b.onEpochEnd(a,o)];case 8:return v.sent(),e.stopTraining_?[2,"break"]:[2]}})},S=h,I.label=2;case 2:return S<a?[5,z(S)]:[3,5];case 3:if("break"===I.sent())return[3,5];I.label=4;case 4:return++S,[3,2];case 5:return[4,b.onTrainEnd()];case 6:return I.sent(),[4,e.history.syncData()];case 7:return I.sent(),[2,e.history]}})})}function fitTensors(e,t,n,r){return void 0===r&&(r={}),__awaiter(this,void 0,void 0,function(){var i,a,o,s,l,u,c,p,h,d,f,g,m,y,v,b,w,z,S;return __generator(this,function(I){switch(I.label){case 0:if(e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0,I.label=1;case 1:if(I.trys.push([1,,3,4]),checkBatchSize(c=null==r.batchSize?32:r.batchSize),p=e.standardizeUserData(t,n,!1,c),i=p[0],a=p[1],h=!1,d=void 0,null!=r.validationData&&r.validationData.length>0){if(h=!0,2!==r.validationData.length)throw 3===r.validationData.length?new NotImplementedError("validationData including sample weights is not supported yet."):new ValueError("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+r.validationData+" is invalid.");o=r.validationData[0],s=r.validationData[1],f=e.standardizeUserData(o,s,!0,c),l=f[0],u=f[1],d=l.concat(u)}else null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1?(h=!0,g=Math.floor(i[0].shape[0]*(1-r.validationSplit)),m=i[0].shape[0],l=sliceArrays(i,g,m),i=sliceArrays(i,0,g),u=sliceArrays(a,g,m),a=sliceArrays(a,0,g),d=l.concat(u)):null!=r.validationSteps&&(h=!0);return y=i.concat(a),e.checkTrainableWeightsConsistency(),v=e.makeTrainFunction(),b=e.getDedupedMetricsNames(),w=void 0,z=void 0,h?(e.makeTestFunction(),w=e.testFunction,z=b.slice().concat(b.map(function(e){return"val_"+e}))):(w=null,d=[],z=b.slice()),S=standardizeCallbacks(r.callbacks,r.yieldEvery),[4,fitLoop(e,v,y,b,c,r.epochs,r.verbose,S,w,d,r.shuffle,z,r.initialEpoch,null,null)];case 2:return[2,I.sent()];case 3:return e.isTraining=!1,disposeNewTensors(i,t),disposeNewTensors(a,n),disposeNewTensors(l,o),disposeNewTensors(u,s),[7];case 4:return[2]}})})}function ensureTensorsRank2OrHigher(e){var t=[];e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]&&(e=[e]);for(var n=0;n<e.length;++n){var r=e[n];if(1===r.rank)t.push(expandDims$1(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function disposeNewTensors(e,t){if(null!=e){var n=[];if(t instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"])n.push(t.id);else if(Array.isArray(t))t.forEach(function(e){return n.push(e.id)});else if(null!=t)for(var r in t){var i=t[r];n.push(i.id)}var a=[];if(e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"])-1===n.indexOf(e.id)&&a.push(e);else if(Array.isArray(e))e.forEach(function(e){-1===n.indexOf(e.id)&&a.push(e)});else if(null!=e)for(var o in e){var s=e[o];-1===n.indexOf(s.id)&&a.push(s)}a.forEach(function(e){e.isDisposed||e.dispose()})}}function isDataTensor(e){return e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]}function isDataArray(e){return Array.isArray(e)}function isDataDict(e){return!isDataTensor(e)&&!isDataArray(e)}function standardizeInputData(e,t,n,r,i){if(void 0===r&&(r=!0),void 0===i&&(i=""),null==t||0===t.length){if(null!=e){var a=!1;if(isDataArray(e)&&e.length>0)a=!0;else if(isDataDict(e)){for(var o in e)if(e.hasOwnProperty(o)){a=!0;break}}else a=!0;if(a)throw new ValueError("Error when checking model "+i+" expected no data, but got "+e)}return[]}if(null==e)return t.map(function(e){return null});var s;if(isDataDict(e)){e=e,s=[];for(var l=0,u=t;l<u.length;l++){var c=u[l];if(null==e[c])throw new ValueError('No data provided for "'+c+'". Need data for each key in: '+t);s.push(e[c])}}else if(isDataArray(e)){if((e=e).length!==t.length)throw new ValueError("Error when checking model "+i+": the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see "+t.length+" Tensor(s), but instead got the following list of Tensor(s): "+e);s=e}else{if(e=e,t.length>1)throw new ValueError("The model "+i+" expects "+t.length+" Tensor(s), but only received one Tensor. Found: Tensor with shape "+e.shape);s=[e]}if(s=ensureTensorsRank2OrHigher(s),null!=n)for(var p=0;p<t.length;++p)if(null!=n[p]){var h=s[p];if(h.shape.length!==n[p].length)throw new ValueError("Error when checking "+i+": expected "+t[p]+" to have "+n[p].length+" dimension(s). but got array with shape "+h.shape);for(var d=0;d<n[p].length;++d)if(0!==d||r){var f=h.shape[d],g=n[p][d];if(null!=g&&g>=0&&f!==g)throw new ValueError("Error when checking "+i+": expected "+t[p]+" to have shape ["+n[p]+"], but got array with shape ["+h.shape+"].")}}return s}function checkArrayLengths(e,t,n){var r=unique(e.map(function(e){return e.shape[0]}));r.sort();var i=unique(t.map(function(e){return e.shape[0]}));if(i.sort(),r.length>1)throw new ValueError("All input Tensors (x) should have the same number of samples. Got array shapes: "+JSON.stringify(e.map(function(e){return e.shape})));if(i.length>1)throw new ValueError("All target Tensors (y) should have the same number of samples. Got array shapes: "+JSON.stringify(t.map(function(e){return e.shape})));if(r.length>0&&i.length>0&&!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(r,i))throw new ValueError("Input Tensors should have the same number of samples as target Tensors. Found "+r[0]+" input sample(s) and "+i[0]+" target sample(s).")}function checkLossAndTargetCompatibility(e,t,n){for(var r=[meanSquaredError,binaryCrossentropy,categoricalCrossentropy],i=0;i<e.length;++i){var a=e[i],o=t[i],s=n[i];if(null!=o){if(o===categoricalCrossentropy&&1===a.shape[a.shape.length-1])throw new ValueError("You are passing a target array of shape "+a.shape+" while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==r.indexOf(o))for(var l=a.shape.slice(1),u=s.slice(1),c=0;c<l.length;++c){var p=l[c],h=u[c];if(null!=h&&p!==h)throw new ValueError("A target Tensor with shape "+a.shape+" was passed for an output of shape "+s+", while using a loss function that expects targets to have the same shape as the output.")}}}}function checkInputData(e,t,n,r,i){var a;if(void 0===r&&(r=!0),void 0===i&&(i=""),Array.isArray(e)){if(e.length!==t.length)throw new ValueError("Error when checking model "+i+": the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see "+t.length+" Tensor(s), but instead got "+e.length+" Tensors(s).");a=e}else{if(t.length>1)throw new ValueError("The model expects "+t.length+" "+i+" Tensors, but only received one Tensor. Found: array with shape "+JSON.stringify(e.shape)+".");a=[e]}if(null!=n)for(var o=0;o<t.length;++o)if(null!=n[o]){var s=a[o];if(s.shape.length!==n[o].length)throw new ValueError("Error when checking "+i+": expected "+t[o]+" to have "+n[o].length+" dimension(s), but got array with shape "+JSON.stringify(s.shape));for(var l=0;l<n[o].length;++l)if(0!==l||r){var u=s.shape[l],c=n[o][l];if(null!=c&&c!==u)throw new ValueError("Error when checking "+i+": expected "+t[o]+" to have shape "+JSON.stringify(n[o])+" but got array with shape "+JSON.stringify(s.shape)+".")}}}function collectMetrics(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map(function(e){return[]});if(Array.isArray(e))return t.map(function(t){return e});if(null!=e){for(var n=[],r=0,i=t;r<i.length;r++){var a=i[r],o=e.hasOwnProperty(a)?e[a]:[];Array.isArray(o)||(o=[o]),n.push(o)}return n}throw new TypeError("Type of metrics argument not understood. Expected an Array or Object, found: "+e)}var LAYERS_MODEL_FORMAT_NAME="layers-model",LayersModel=function(e){function t(t){var n=e.call(this,t)||this;return n.isTraining=!1,n}return __extends(t,e),t.prototype.summary=function(e,t,n){if(void 0===n&&(n=console.log),!this.built)throw new ValueError("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");printSummary(this,e,t,n)},t.prototype.compile=function(e){var t=this;if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=getOptimizer(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Optimizer"]))throw new ValueError("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}var n=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new ValueError("When passing an Array as loss, it should have one entry per model output. The model has "+this.outputs.length+" output(s), but you passed loss="+e.loss+".");var r=e.loss;n=r.map(function(e){return get(e)})}else{var i=get(e.loss);this.outputs.forEach(function(e){n.push(i)})}else{for(var a in e.loss=e.loss,e.loss)if(-1===this.outputNames.indexOf(a))throw new ValueError('Unknown entry in loss dictionary: "'+a+'". Only expected the following keys: '+this.outputNames);for(var o=0,s=this.outputNames;o<s.length;o++){var l=s[o];null==e.loss[l]&&console.warn('Output "'+l+'" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to '+l+" during training"),n.push(get(e.loss[l]))}}this.lossFunctions=n,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(var u=0;u<this.outputs.length;++u){var c=this.internalOutputShapes[u],p=this.outputNames[u];this.feedOutputNames.push(p),this.feedOutputShapes.push(c),this.feedLossFns.push(this.lossFunctions[u])}var h=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],nameScope("loss",function(){for(var e=0;e<t.outputs.length;++e)if(-1===h.indexOf(e)){var n=t.lossFunctions[e];t.outputs.length>1&&(t.metricsTensors.push([n,e]),t.metricsNames.push(t.outputNames[e]+"_loss"))}});var d=collectMetrics(e.metrics,this.outputNames);nameScope("metric",function(){for(var e=function(e){if(-1!==h.indexOf(e))return"continue";!function(n){for(var r,i,a,o=function(n){if(-1!==["accuracy","acc","crossentropy","ce"].indexOf(n)){var o=t.internalOutputShapes[e];1===o[o.length-1]||t.lossFunctions[e]===binaryCrossentropy?-1!==["accuracy","acc"].indexOf(n)?i=binaryAccuracy:-1!==["crossentropy","ce"].indexOf(n)&&(i=binaryCrossentropy$1):t.lossFunctions[e]===sparseCategoricalCrossentropy?-1!==["accuracy","acc"].indexOf(n)?i=sparseCategoricalAccuracy:-1!==["crossentropy","ce"].indexOf(n)&&(i=sparseCategoricalCrossentropy$1):-1!==["accuracy","acc"].indexOf(n)?i=categoricalAccuracy:-1!==["crossentropy","ce"].indexOf(n)&&(i=categoricalCrossentropy$1);var s=void 0;-1!==["accuracy","acc"].indexOf(n)?s="acc":-1!==["crossentropy","ce"].indexOf(n)&&(s="ce"),a=i,r=""+s}else{var l=get$1(n);a=l,r=""+n}var u;nameScope(r,function(){u=a}),function(e,n,r){t.outputNames.length>1&&(n=t.outputNames[e]+"_"+n),t.metricsNames.push(n),t.metricsTensors.push([r,e])}(e,r,u)},s=0,l=n;s<l.length;s++)o(l[s])}(d[e])},n=0;n<t.outputs.length;++n)e(n)}),this.collectedTrainableWeights=this.trainableWeights},t.prototype.checkTrainableWeightsConsistency=function(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")},t.prototype.evaluate=function(e,t,n){void 0===n&&(n={});var r=null==n.batchSize?32:n.batchSize;checkBatchSize(r);var i=this.standardizeUserData(e,t,!0,r);try{var a=i[0].concat(i[1]);this.makeTestFunction();var o=this.testFunction;return singletonOrArray(this.testLoop(o,a,r,n.verbose,n.steps))}finally{disposeNewTensors(i[0],e),disposeNewTensors(i[1],t)}},t.prototype.evaluateDataset=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){return this.makeTestFunction(),[2,evaluateDataset(this,e,t)]})})},t.prototype.checkNumSamples=function(e,t,n,r){var i;if(void 0===r&&(r="steps"),null!=n){if(i=null,null!=t)throw new ValueError("If "+r+" is set, batchSize must be null or undefined.Got batchSize = "+t)}else{if(null==e)throw new ValueError("Either the input data should have a defined shape, or "+r+" shoud be specified.");i=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return i},t.prototype.execute=function(e,t){if(Array.isArray(t)&&0===t.length)throw new ValueError("`outputs` is an empty Array, which is not allowed.");var n=Array.isArray(t),r=n?t:[t],i=this.retrieveSymbolicTensors(r),a=new FeedDict;if(e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new ValueError("The number of inputs provided ("+e.length+") does not match the number of inputs of this model ("+this.inputs.length+").");for(var o=0;o<this.inputs.length;++o)a.add(this.inputs[o],e[o])}else for(var s=0,l=this.inputs;s<l.length;s++){var u=l[s],c=e[u.name];if(null==c)throw new ValueError("No value is provided for the model's input "+u.name);a.add(u,c)}var p=execute(i,a);return n?p:p[0]},t.prototype.retrieveSymbolicTensors=function(e){for(var t=pyListRepeat(null,e.length),n=e.length,r=0,i=this.layers;r<i.length;r++){for(var a=i[r],o=Array.isArray(a.output)?a.output:[a.output],s=o.map(function(e){return e.name}),l=0;l<e.length;++l){var u=s.indexOf(e[l]);if(-1!==u&&(t[l]=o[u],n--),0===n)break}if(0===n)break}if(n>0){var c=[];throw t.forEach(function(t,n){null==t&&c.push(e[n])}),new ValueError("Cannot find SymbolicTensors for output name(s): "+JSON.stringify(c))}return t},t.prototype.predictLoop=function(e,t,n){var r=this;return void 0===t&&(t=32),void 0===n&&(n=!1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var i=r.checkNumSamples(e);if(n)throw new NotImplementedError("Verbose predictLoop() is not implemented yet.");for(var a=makeBatches(i,t),o=r.outputs.map(function(e){return[]}),s=function(t){Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=a[t][0],i=a[t][1],o=sliceArrays(e,n,i),s=[];if(Array.isArray(o))for(var l=0;l<o.length;++l)s.push({key:r.inputs[l],value:o[l]});else s.push({key:r.inputs[0],value:o});var u=new FeedDict(s);return execute(r.outputs,u)}).forEach(function(e,t){return o[t].push(e)})},l=0;l<a.length;++l)s(l);return singletonOrArray(o.map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"])(e,0)}))})},t.prototype.predict=function(e,t){void 0===t&&(t={});var n=ensureTensorsRank2OrHigher(e);checkInputData(n,this.inputNames,this.feedInputShapes,!1);try{var r=null==t.batchSize?32:t.batchSize;return checkBatchSize(r),this.predictLoop(n,r)}finally{disposeNewTensors(n,e)}},t.prototype.predictOnBatch=function(e){return checkInputData(e,this.inputNames,this.feedInputShapes,!0),this.predictLoop(e,e.shape[0])},t.prototype.standardizeUserData=function(e,t,n,r){if(void 0===n&&(n=!0),null==this.optimizer_)throw new RuntimeError("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");for(var i=[],a=0;a<this.feedOutputShapes.length;++a){var o=this.feedOutputShapes[a];this.feedLossFns[a]===sparseCategoricalCrossentropy?i.push(o.slice(0,o.length-1).concat([1])):i.push(o)}if(checkArrayLengths(e=standardizeInputData(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=standardizeInputData(t,this.feedOutputNames,i,!1,"target"),null),checkLossAndTargetCompatibility(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!=0)throw new ValueError("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+r+". Found: "+e[0].shape[0]+" sample(s).");return[e,t,null]},t.prototype.testLoop=function(e,t,n,r,i){var a=this;return void 0===r&&(r=0),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var o=a.checkNumSamples(t,n,i,"steps"),s=[];if(r>0)throw new NotImplementedError("Verbose mode is not implemented yet.");if(null!=i)throw new NotImplementedError("steps mode in testLoop() is not implemented yet");for(var l=makeBatches(o,n),u=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"])(range(0,o)),c=0;c<l.length;++c){var p=l[c][0],h=l[c][1],d=sliceAlongFirstAxis(u,p,h-p),f=sliceArraysByIndices(t,d),g=e(f);if(0===c)for(var m=0;m<g.length;++m)s.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"])(0));for(m=0;m<g.length;++m){var y=g[m];s[m]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(s[m],Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(h-p,y))}}for(m=0;m<s.length;++m)s[m]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"])(s[m],o);return s})},t.prototype.getDedupedMetricsNames=function(){for(var e=this.metricsNames,t=[],n=0;n<e.length;++n){var r=e[n],i=r;if(count(e,r)>1)i+="_"+count(e.slice(0,n),r);t.push(i)}return t},t.prototype.makeTrainFunction=function(){var e=this;return function(t){var n=t.slice(0,e.inputs.length),r=t.slice(e.inputs.length,e.inputs.length+e.outputs.length),i=[],a=e.collectedTrainableWeights.map(function(e){return e.read()});return[e.optimizer_.minimize(function(){for(var t=[],a=0;a<e.inputs.length;++a)t.push({key:e.inputs[a],value:n[a]});var o,s=new FeedDict(t),l=execute(e.outputs,s,{training:!0});for(a=0;a<e.lossFunctions.length;++a){var u=(0,e.lossFunctions[a])(r[a],l[a]);Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(u),o=0===a?u:Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(o,u)}for(a=0;a<e.metricsTensors.length;++a){var c=e.metricsTensors[a][0],p=e.metricsTensors[a][1],h=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(c(r[p],l[p]));Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(h),i.push(h)}return o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(o),e.calculateLosses().forEach(function(e){o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(o,e)}),o},!0,a)].concat(i)}},t.prototype.makeTestFunction=function(){var e=this;this.testFunction=function(t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var n,r=[],i=t.slice(0,e.inputs.length),a=t.slice(e.inputs.length,e.inputs.length+e.outputs.length),o=[],s=0;s<e.inputs.length;++s)o.push({key:e.inputs[s],value:i[s]});var l=new FeedDict(o),u=execute(e.outputs,l);for(s=0;s<e.lossFunctions.length;++s){var c=e.lossFunctions[s],p=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(c(a[s],u[s]));n=0===s?p:Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(n,p),r.push(n)}for(s=0;s<e.metricsTensors.length;++s){var h=e.metricsTensors[s][0],d=e.metricsTensors[s][1],f=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(h(a[d],u[d]));r.push(f)}return r})}},t.prototype.fit=function(e,t,n){return void 0===n&&(n={}),__awaiter(this,void 0,void 0,function(){return __generator(this,function(r){return[2,fitTensors(this,e,t,n)]})})},t.prototype.fitDataset=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){return[2,fitDataset(this,e,t)]})})},t.prototype.trainOnBatch=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r,i,a,o,s,l,u,c;return __generator(this,function(p){switch(p.label){case 0:n=this.standardizeUserData(e,t),r=n[0],i=n[1],a=this.makeTrainFunction(),o=a(r.concat(i)),s=[],l=0,u=o,p.label=1;case 1:return l<u.length?[4,u[l].data()]:[3,4];case 2:c=p.sent(),s.push(c[0]),p.label=3;case 3:return l++,[3,1];case 4:return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(o),[2,singletonOrArray(s)]}})})},t.prototype.getNamedWeights=function(e){for(var t={},n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,i=this.getWeights(n),a=0;a<r.length;++a)n&&!r[a].trainable||(t[r[a].originalName]=i[a]);return t},Object.defineProperty(t.prototype,"stopTraining",{get:function(){return this.stopTraining_},set:function(e){this.stopTraining_=e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"optimizer",{get:function(){return this.optimizer_},set:function(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)},enumerable:!0,configurable:!0}),t.prototype.dispose=function(){var t=e.prototype.dispose.call(this);if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["memory"])().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=n-Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["memory"])().numTensors}return t},t.prototype.save=function(e,t){return __awaiter(this,void 0,void 0,function(){var n,r,i,a,o;return __generator(this,function(s){switch(s.label){case 0:if("string"==typeof e){if(0===(n=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].getSaveHandlers(e)).length)throw new ValueError("Cannot find any save handlers for URL '"+e+"'");if(n.length>1)throw new ValueError("Found more than one ("+n.length+") save handlers for URL '"+e+"'");e=n[0]}if(null==e.save)throw new ValueError("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return[4,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].encodeWeights(this.getNamedWeights(t))];case 1:return r=s.sent(),i=!1,a=null,o=this.toJSON(a,i),[2,e.save({modelTopology:o,weightData:r.data,weightSpecs:r.specs,format:LAYERS_MODEL_FORMAT_NAME,generatedBy:"TensorFlow.js tfjs-layers v"+version,convertedBy:null})]}})})},t.className="Model",t}(Container);function modelFromJSON(e,t){return __awaiter(this,void 0,void 0,function(){var n,r,i,a,o,s,l,u;return __generator(this,function(c){switch(c.label){case 0:return"modelTopology"in e||(e={modelTopology:e}),null!=(n=(e=e).modelTopology).model_config&&(n=n.model_config),r=convertPythonicToTs(n),i=deserialize(r,t),null==e.weightsManifest?[3,2]:[4,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].loadWeights(e.weightsManifest,e.pathPrefix,i.weights.map(function(e){return e.originalName}))];case 1:for(a=c.sent(),o={},s=0,l=i.weights;s<l.length;s++)u=l[s],o[u.originalName]=a[u.originalName];i.loadWeights(o),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(a),c.label=2;case 2:return[2,i]}})})}function loadLayersModelInternal(e,t){return __awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(r){if(null==t&&(t={}),"string"==typeof e){if(0===(n=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].getLoadHandlers(e)).length)n.push(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].browserHTTPRequest(e,t));else if(n.length>1)throw new ValueError("Found more than one ("+n.length+") load handlers for URL '"+e+"'");e=n[0]}return[2,loadLayersModelFromIOHandler(e,void 0,t)]})})}function loadLayersModelFromIOHandler(e,t,n){return __awaiter(this,void 0,void 0,function(){var r,i,a,o,s,l;return __generator(this,function(u){switch(u.label){case 0:if(null==n&&(n={}),null==e.load)throw new ValueError("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");return[4,e.load()];case 1:if(r=u.sent(),null!=(i=r.modelTopology).model_config&&(i=i.model_config),a=null==n.strict||n.strict,o=null!=r.weightData&&null!=r.weightSpecs&&a,s=deserialize(convertPythonicToTs(i),t,o),null!=r.weightData){if(null==r.weightSpecs)throw new ValueError("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");l=_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"].decodeWeights(r.weightData,r.weightSpecs),s.loadWeights(l,a),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(l)}return[2,s]}})})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LayersModel);var Sequential=function(e){function t(t){var n=e.call(this,{inputs:[],outputs:[]})||this;if(t=t||{},n.trainable=!0,n._updatable=!0,n.built=!1,n.name=null!=t.name?t.name:getUid("sequential_"),null!=t.layers)for(var r=0,i=t.layers;r<i.length;r++){var a=i[r];n.add(a)}return n}return __extends(t,e),t.prototype.checkShape=function(e){if(e.inboundNodes[0].outputTensors[0].shape.some(function(e){return e<0}))throw new ValueError("Negative dimension size caused by adding layer "+e.name+" with input shape ["+e.inboundNodes[0].inputTensors[0].shape+"]")},t.prototype.add=function(e){var n,r=e instanceof t||e instanceof LayersModel;if(r){if(1!==(n=e).outputs.length)throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new ValueError("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new ValueError("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");var i=Input({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(i)}if(r)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new ValueError("A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer "+e.name+" which has "+e.inboundNodes.length+" pre-existing inbound connections.");if(1!==e.inboundNodes[0].outputTensors.length)throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=getSourceInputs(this.outputs[0])}this.inboundNodes=[],new Node({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:pyListRepeat(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(function(e){return e.shape}),outputShapes:this.outputs[0].shape})}else{var a=e.apply(this.outputs[0]);if(Array.isArray(a))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[a],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1},t.prototype.pop=function(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{var e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}},t.prototype.call=function(e,t){return null==this.model&&this.build(),this.model.call(e,t)},t.prototype.build=function(e){if(getExactlyOneShape(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new LayersModel({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.model.updatable=this.updatable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0},t.prototype.countParams=function(){return this.built||this.build(),e.prototype.countParams.call(this)},t.prototype.summary=function(t,n,r){void 0===r&&(r=console.log),this.built||this.build(),e.prototype.summary.call(this,t,n,r)},t.prototype.setWeights=function(e){null==this.model&&this.build(),this.model.setWeights(e)},Object.defineProperty(t.prototype,"updatable",{get:function(){return this._updatable},set:function(e){this.built&&(this.model.updatable=e),this._updatable=e},enumerable:!0,configurable:!0}),t.prototype.evaluate=function(e,t,n){if(void 0===n&&(n={}),!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)},t.prototype.evaluateDataset=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return[2,this.model.evaluateDataset(e,t)]})})},t.prototype.predict=function(e,t){return void 0===t&&(t={}),null==this.model&&this.build(),this.model.predict(e,t)},t.prototype.predictOnBatch=function(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)},t.prototype.compile=function(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames},Object.defineProperty(t.prototype,"optimizer",{get:function(){return this.model.optimizer},set:function(e){this.model.optimizer=e},enumerable:!0,configurable:!0}),t.prototype.fit=function(e,t,n){return void 0===n&&(n={}),__awaiter(this,void 0,void 0,function(){return __generator(this,function(r){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return[2,this.model.fit(e,t,n)]})})},t.prototype.fitDataset=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return[2,this.model.fitDataset(e,t)]})})},t.prototype.trainOnBatch=function(e,t){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(n){return[2,this.model.trainOnBatch(e,t)]})})},t.fromConfig=function(e,n,r,i){var a;void 0===r&&(r={}),void 0===i&&(i=!1);var o={};if(n instanceof Array){if(null==n[0].className||"Merge"===n[0].className)throw new ValueError("Legacy serialization format not supported yet.");a=n}else _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(null!=n.layers,function(){return"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."}),a=n.layers,delete n.layers,o=n;var s=new e(o);if(!(s instanceof t))throw new NotImplementedError("Sequential.fromConfig called on non-Sequential input: "+s);for(var l=0,u=a;l<u.length;l++){var c=deserialize(u[l],void 0,i);i&&c.setFastWeightInitDuringBuild(!0),s.add(c)}return s},Object.defineProperty(t.prototype,"stopTraining",{get:function(){if(null==this.model)throw new ValueError("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining},set:function(e){if(null==this.model)throw new ValueError("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e},enumerable:!0,configurable:!0}),t.prototype.getConfig=function(){for(var e=[],t=0,n=this.layers;t<n.length;t++){var r=n[t],i={};i.className=r.getClassName(),i.config=r.getConfig(),e.push(i)}return e},t.className="Sequential",t}(LayersModel);function model(e){return new LayersModel(e)}function sequential(e){return new Sequential(e)}function loadLayersModel(e,t){return null==t&&(t={}),loadLayersModelInternal(e,t)}function input(e){return Input(e)}function registerCallbackConstructor(e,t){CallbackConstructorRegistry.registerCallbackConstructor(e,t)}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Sequential);var Activation=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.getConfig=function(){return{}},t}(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].Serializable),Elu=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e,t){return void 0===t&&(t=1),elu$1(e,t)},t.className="elu",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Elu);var Selu=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["selu"])(e)},t.className="selu",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Selu);var Relu=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"])(e)},t.className="relu",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Relu);var Relu6=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["minimum"])(6,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"])(e))})},t.className="relu6",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Relu6);var Linear=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return e},t.className="linear",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Linear);var Sigmoid=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sigmoid"])(e)},t.className="sigmoid",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Sigmoid);var HardSigmoid=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return hardSigmoid(e)},t.className="hardSigmoid",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(HardSigmoid);var Softplus=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softplus"])(e)},t.className="softplus",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Softplus);var Softsign=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return softsign(e)},t.className="softsign",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Softsign);var Tanh=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tanh"])(e)},t.className="tanh",t}(Activation);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Tanh);var Softmax=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e,t){return void 0===t&&(t=-1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"])(e,t)},t.className="softmax",t}(Activation);function serializeActivation(e){return e.getClassName()}function deserializeActivation(e,t){return void 0===t&&(t={}),deserializeKerasObject(e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].SerializationMap.getMap().classNameMap,t,"activation")}function getActivation(e){var t;return null==e?deserializeActivation(t={className:"linear",config:{}}):"string"==typeof e?((t={}).className=e,t.config={},deserializeActivation(t)):e instanceof Activation?e:deserializeActivation(e)}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Softmax);var Regularizer=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t}(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].Serializable),L1L2=function(e){function t(t){var n=e.call(this)||this;return n.l1=null==t||null==t.l1?.01:t.l1,n.l2=null==t||null==t.l2?.01:t.l2,n.hasL1=0!==n.l1,n.hasL2=0!==n.l2,n}return __extends(t,e),t.prototype.apply=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])([1]);return t.hasL1&&(n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(n,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(t.l1,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"])(e))))),t.hasL2&&(n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(n,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(t.l2,square(e))))),n.asScalar()})},t.prototype.getConfig=function(){return{l1:this.l1,l2:this.l2}},t.fromConfig=function(e,t){return new e({l1:t.l1,l2:t.l2})},t.className="L1L2",t}(Regularizer);function l1(e){return new L1L2({l1:null!=e?e.l1:null,l2:0})}function l2(e){return new L1L2({l2:null!=e?e.l2:null,l1:0})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(L1L2);var REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP={l1l2:"L1L2"};function serializeRegularizer(e){return serializeKerasObject(e)}function deserializeRegularizer(e,t){return void 0===t&&(t={}),deserializeKerasObject(e,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].SerializationMap.getMap().classNameMap,t,"regularizer")}function getRegularizer(e){return null==e?null:"string"==typeof e?deserializeRegularizer({className:e in REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP?REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[e]:e,config:{}}):e instanceof Regularizer?e:deserializeRegularizer(e)}var ReLU=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;return n.supportsMasking=!0,null!=t&&(n.maxValue=t.maxValue),n}return __extends(t,e),t.prototype.call=function(e,t){e=getExactlyOneTensor(e);var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"])(e);return null!=this.maxValue&&(n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"])(n,0,this.maxValue)),n},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t={maxValue:this.maxValue},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="ReLU",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(ReLU);var LeakyReLU=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;return n.DEFAULT_ALPHA=.3,null==t&&(t={}),n.alpha=null==t.alpha?n.DEFAULT_ALPHA:t.alpha,n}return __extends(t,e),t.prototype.call=function(e,t){var n=getExactlyOneTensor(e);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["leakyRelu"])(n,this.alpha)},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t={alpha:this.alpha},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="LeakyReLU",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LeakyReLU);var PReLU=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;if(n.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),n.supportsMasking=!0,n.alphaInitializer=getInitializer(t.alphaInitializer||n.DEFAULT_ALPHA_INITIALIZER),n.alphaRegularizer=getRegularizer(t.alphaRegularizer),n.alphaConstraint=getConstraint(t.alphaConstraint),null==t.sharedAxes)n.sharedAxes=null;else if(Array.isArray(t.sharedAxes))n.sharedAxes=t.sharedAxes;else{if("number"!=typeof t.sharedAxes)throw new ValueError("Expected sharedAxes to be a number or an array of numbers, but got "+t.sharedAxes);n.sharedAxes=[t.sharedAxes]}return n}return __extends(t,e),t.prototype.build=function(e){var t=(e=getExactlyOneShape(e)).slice(1);if(null!=this.sharedAxes)for(var n=0,r=this.sharedAxes;n<r.length;n++){t[(a=r[n])-1]=1}this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);var i={};if(null!=this.sharedAxes)for(var a=1;a<e.length;++a)i[a]=e[a];this.inputSpec=[new InputSpec({ndim:e.length,axes:i})],this.built=!0},t.prototype.call=function(e,t){return e=getExactlyOneTensor(e),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["prelu"])(e,this.alpha.read())},t.prototype.getConfig=function(){var t={alphaInitializer:serializeInitializer(this.alphaInitializer),alphaRegularizer:serializeRegularizer(this.alphaRegularizer),alphaConstraint:serializeConstraint(this.alphaConstraint),sharedAxes:this.sharedAxes},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="PReLU",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(PReLU);var ELU=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;if(n.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==n.DEFAULT_ALPHA)throw new NotImplementedError("Non-default alpha value ("+t.alpha+") is not supported by the ELU layer yet.");return n.alpha=null==t.alpha?n.DEFAULT_ALPHA:t.alpha,n}return __extends(t,e),t.prototype.call=function(e,t){var n=getExactlyOneTensor(e);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["elu"])(n)},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t={alpha:this.alpha},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="ELU",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(ELU);var ThresholdedReLU=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;return n.DEFAULT_THETA=1,null==t&&(t={}),n.theta=null==t.theta?n.DEFAULT_THETA:t.theta,n}return __extends(t,e),t.prototype.call=function(e,t){var n=getExactlyOneTensor(e);return n.mul(cast$1(n.greater(this.theta),"float32"))},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t={theta:this.theta},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="ThresholdedReLU",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(ThresholdedReLU);var Softmax$1=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;return n.DEFAULT_AXIS=1,null==t&&(t={}),n.softmax=(new Softmax).apply,n.axis=null==t.axis?n.DEFAULT_AXIS:t.axis,n}return __extends(t,e),t.prototype.call=function(e,t){var n=getExactlyOneTensor(e);return this.softmax(n,this.axis)},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t={axis:this.axis},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Softmax",t}(Layer);function normalizeArray(e,t,n){if("number"==typeof e)return pyListRepeat(e,t);if(e.length!==t)throw new ValueError("The "+n+" argument must be an integer or tuple of "+t+" integers. Received: "+e.length+" elements.");for(var r=0;r<t;++r){var i=e[r];if(!isInteger(i))throw new ValueError("The "+n+" argument must be an integer or tuple of "+t+" integers. Received: "+JSON.stringify(e)+" including a non-integer number "+i)}return e}function convOutputLength(e,t,n,r,i){return void 0===i&&(i=1),null==e?e:(a="same"===n?e:e-(t+(t-1)*(i-1))+1,Math.floor((a+r-1)/r));var a}function deconvLength(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+max$1([n-t,0]);else{if("same"!==r)throw new ValueError("Unsupport padding mode: "+r+".");e*=t}return e}function preprocessConv2DInput(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return checkDataFormat(t),"channelsFirst"===t?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(e,[0,2,3,1]):e})}function preprocessConv3DInput(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return checkDataFormat(t),"channelsFirst"===t?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(e,[0,2,3,4,1]):e})}function conv1dWithBias(e,t,n,r,i,a,o){return void 0===r&&(r=1),void 0===i&&(i="valid"),void 0===o&&(o=1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null==a&&(a=imageDataFormat()),checkDataFormat(a),3!==e.shape.length)throw new ValueError("The input of a conv1dWithBias operation should be 3, but is "+e.shape.length+" instead.");if(3!==t.shape.length)throw new ValueError("The kernel for a conv1dWithBias operation should be 3, but is "+t.shape.length+" instead");if(null!=n&&1!==n.shape.length)throw new ValueError("The bias for a conv1dWithBias operation should be 1, but is "+t.shape.length+" instead");if("channelsFirst"===a&&(e=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(e,[0,2,1])),"causal"===i)throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");var s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv1d"])(e,t,r,"same"===i?"same":"valid","NWC",o);return null!=n&&(s=biasAdd(s,n)),s})}function conv2dWithBias(e,t,n,r,i,a,o){return void 0===r&&(r=[1,1]),void 0===i&&(i="valid"),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null==a&&(a=imageDataFormat()),checkDataFormat(a),3!==e.rank&&4!==e.rank)throw new ValueError("conv2dWithBias expects input to be of rank 3 or 4, but received "+e.rank+".");if(3!==t.rank&&4!==t.rank)throw new ValueError("conv2dWithBias expects kernel to be of rank 3 or 4, but received "+e.rank+".");var s=preprocessConv2DInput(e,a);if("causal"===i)throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"])(s,t,r,"same"===i?"same":"valid","NHWC",o),null!=n&&(s=biasAdd(s,n)),"channelsFirst"===a&&(s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(s,[0,3,1,2])),s})}function conv3dWithBias(e,t,n,r,i,a,o){return void 0===r&&(r=[1,1,1]),void 0===i&&(i="valid"),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null==a&&(a=imageDataFormat()),checkDataFormat(a),4!==e.rank&&5!==e.rank)throw new ValueError("conv3dWithBias expects input to be of rank 4 or 5, but received "+e.rank+".");if(4!==t.rank&&5!==t.rank)throw new ValueError("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+e.rank+".");var s=preprocessConv3DInput(e,a);if("causal"===i)throw new NotImplementedError("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv3d"])(s,t,r,"same"===i?"same":"valid","NDHWC",o),null!=n&&(s=biasAdd(s,n)),"channelsFirst"===a&&(s=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(s,[0,4,1,2,3])),s})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Softmax$1);var BaseConv=function(e){function t(n,r){var i=e.call(this,r)||this;if(i.bias=null,i.DEFAULT_KERNEL_INITIALIZER="glorotNormal",i.DEFAULT_BIAS_INITIALIZER="zeros",t.verifyArgs(r),i.rank=n,assertPositiveInteger(i.rank,"rank"),1!==i.rank&&2!==i.rank&&3!==i.rank)throw new NotImplementedError("Convolution layer for rank other than 1, 2, or 3 ("+i.rank+") is not implemented yet.");if(i.kernelSize=normalizeArray(r.kernelSize,n,"kernelSize"),i.strides=normalizeArray(null==r.strides?1:r.strides,n,"strides"),i.padding=null==r.padding?"valid":r.padding,checkPaddingMode(i.padding),i.dataFormat=null==r.dataFormat?"channelsLast":r.dataFormat,checkDataFormat(i.dataFormat),i.activation=getActivation(r.activation),i.useBias=null==r.useBias||r.useBias,i.biasInitializer=getInitializer(r.biasInitializer||i.DEFAULT_BIAS_INITIALIZER),i.biasConstraint=getConstraint(r.biasConstraint),i.biasRegularizer=getRegularizer(r.biasRegularizer),i.activityRegularizer=getRegularizer(r.activityRegularizer),i.dilationRate=normalizeArray(null==r.dilationRate?1:r.dilationRate,n,"dilationRate"),1===i.rank&&Array.isArray(i.dilationRate)&&1!==i.dilationRate.length)throw new ValueError("dilationRate must be a number or an array of a single number for 1D convolution, but received "+JSON.stringify(i.dilationRate));if(2===i.rank){if("number"==typeof i.dilationRate)i.dilationRate=[i.dilationRate,i.dilationRate];else if(2!==i.dilationRate.length)throw new ValueError("dilationRate must be a number or array of two numbers for 2D convolution, but received "+JSON.stringify(i.dilationRate))}else if(3===i.rank)if("number"==typeof i.dilationRate)i.dilationRate=[i.dilationRate,i.dilationRate,i.dilationRate];else if(3!==i.dilationRate.length)throw new ValueError("dilationRate must be a number or array of three numbers for 3D convolution, but received "+JSON.stringify(i.dilationRate));return i}return __extends(t,e),t.verifyArgs=function(e){if(assert("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!checkArrayTypeAndLength(e.kernelSize,"number",1,3))throw new ValueError("BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received "+JSON.stringify(e.kernelSize)+".")},t.prototype.getConfig=function(){var t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:serializeActivation(this.activation),useBias:this.useBias,biasInitializer:serializeInitializer(this.biasInitializer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),biasConstraint:serializeConstraint(this.biasConstraint)},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t}(Layer),Conv=function(e){function t(n,r){var i=e.call(this,n,r)||this;return i.kernel=null,t.verifyArgs(r),i.filters=r.filters,assertPositiveInteger(i.filters,"filters"),i.kernelInitializer=getInitializer(r.kernelInitializer||i.DEFAULT_KERNEL_INITIALIZER),i.kernelConstraint=getConstraint(r.kernelConstraint),i.kernelRegularizer=getRegularizer(r.kernelRegularizer),i}return __extends(t,e),t.prototype.build=function(e){var t;e=getExactlyOneShape(e);var n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new ValueError("The channel dimension of the input should be defined. Found "+e[n]);var r=e[n],i=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:(t={},t[n]=r,t)}],this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t;e=getExactlyOneTensor(e);var r=null==n.bias?null:n.bias.read();if(1===n.rank)t=conv1dWithBias(e,n.kernel.read(),r,n.strides[0],n.padding,n.dataFormat,n.dilationRate[0]);else if(2===n.rank)t=conv2dWithBias(e,n.kernel.read(),r,n.strides,n.padding,n.dataFormat,n.dilationRate);else{if(3!==n.rank)throw new NotImplementedError("convolutions greater than 3D are not implemented yet.");t=conv3dWithBias(e,n.kernel.read(),r,n.strides,n.padding,n.dataFormat,n.dilationRate)}return null!=n.activation&&(t=n.activation.apply(t)),t})},t.prototype.computeOutputShape=function(e){e=getExactlyOneShape(e);for(var t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2),r=0;r<n.length;++r){var i=convOutputLength(n[r],this.kernelSize[r],this.padding,this.strides[r],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[r]);t.push(i)}var a=[e[0]];return"channelsLast"===this.dataFormat?(a=a.concat(t)).push(this.filters):(a.push(this.filters),a=a.concat(t)),a},t.prototype.getConfig=function(){var t={filters:this.filters,kernelInitializer:serializeInitializer(this.kernelInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint)},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.verifyArgs=function(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new ValueError("Convolution layer expected config.filters to be a 'number' > 0 but got "+JSON.stringify(e.filters))},t}(BaseConv),Conv2D=function(e){function t(n){var r=e.call(this,2,n)||this;return t.verifyArgs(n),r}return __extends(t,e),t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return delete t.rank,t},t.verifyArgs=function(e){if("number"!=typeof e.kernelSize&&!checkArrayTypeAndLength(e.kernelSize,"number",1,2))throw new ValueError("Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received "+JSON.stringify(e.kernelSize)+".")},t.className="Conv2D",t}(Conv);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Conv2D);var Conv3D=function(e){function t(n){var r=e.call(this,3,n)||this;return t.verifyArgs(n),r}return __extends(t,e),t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return delete t.rank,t},t.verifyArgs=function(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new ValueError("Conv3D expects config.kernelSize to be number or [number, number, number], but received "+JSON.stringify(e.kernelSize)+".")},t.className="Conv3D",t}(Conv);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Conv3D);var Conv2DTranspose=function(e){function t(t){var n=e.call(this,t)||this;if(n.inputSpec=[new InputSpec({ndim:4})],"same"!==n.padding&&"valid"!==n.padding)throw new ValueError("Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode "+n.padding);return n}return __extends(t,e),t.prototype.build=function(e){var t;if(4!==(e=getExactlyOneShape(e)).length)throw new ValueError("Input should have rank 4; Received input shape: "+JSON.stringify(e));var n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new ValueError("The channel dimension of the inputs should be defined. Found `None`.");var r=e[n],i=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new InputSpec({ndim:4,axes:(t={},t[n]=r,t)})],this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e);if(4!==t.shape.length)throw new ValueError("Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-"+t.shape.length);var r,i,a=t.shape,o=a[0];"channelsFirst"===n.dataFormat?(r=2,i=3):(r=1,i=2);var s=a[r],l=a[i],u=n.kernelSize[0],c=n.kernelSize[1],p=n.strides[0],h=n.strides[1],d=[o,deconvLength(s,p,u,n.padding),deconvLength(l,h,c,n.padding),n.filters];"channelsLast"!==n.dataFormat&&(t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(t,[0,2,3,1]));var f=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2dTranspose"])(t,n.kernel.read(),d,n.strides,n.padding);return"channelsLast"!==n.dataFormat&&(f=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(f,[0,3,1,2])),null!=n.bias&&(f=biasAdd(f,n.bias.read(),n.dataFormat)),null!=n.activation&&(f=n.activation.apply(f)),f})},t.prototype.computeOutputShape=function(e){var t,n,r,i=(e=getExactlyOneShape(e)).slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3):(t=3,n=1,r=2);var a=this.kernelSize[0],o=this.kernelSize[1],s=this.strides[0],l=this.strides[1];return i[t]=this.filters,i[n]=deconvLength(i[n],s,a,this.padding),i[r]=deconvLength(i[r],l,o,this.padding),i},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return delete t.dilationRate,t},t.className="Conv2DTranspose",t}(Conv2D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Conv2DTranspose);var SeparableConv=function(e){function t(t,n){var r=e.call(this,t,n)||this;if(r.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",r.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",r.depthwiseKernel=null,r.pointwiseKernel=null,null==n.filters)throw new ValueError("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=n.kernelInitializer||null!=n.kernelRegularizer||null!=n.kernelConstraint)throw new ValueError("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=n.padding&&"same"!==n.padding&&"valid"!==n.padding)throw new ValueError("SeparableConv"+r.rank+"D supports only padding modes: 'same' and 'valid', but received "+JSON.stringify(n.padding));return r.depthMultiplier=null==n.depthMultiplier?1:n.depthMultiplier,r.depthwiseInitializer=getInitializer(n.depthwiseInitializer||r.DEFAULT_DEPTHWISE_INITIALIZER),r.depthwiseRegularizer=getRegularizer(n.depthwiseRegularizer),r.depthwiseConstraint=getConstraint(n.depthwiseConstraint),r.pointwiseInitializer=getInitializer(n.depthwiseInitializer||r.DEFAULT_POINTWISE_INITIALIZER),r.pointwiseRegularizer=getRegularizer(n.pointwiseRegularizer),r.pointwiseConstraint=getConstraint(n.pointwiseConstraint),r}return __extends(t,e),t.prototype.build=function(e){var t;if((e=getExactlyOneShape(e)).length<this.rank+2)throw new ValueError("Inputs to SeparableConv"+this.rank+"D should have rank "+(this.rank+2)+", but received input shape: "+JSON.stringify(e));var n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n]||e[n]<0)throw new ValueError("The channel dimension of the inputs should be defined, but found "+JSON.stringify(e[n]));for(var r=e[n],i=this.kernelSize.concat([r,this.depthMultiplier]),a=[],o=0;o<this.rank;++o)a.push(1);a.push(r*this.depthMultiplier,this.filters);this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,!0,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.inputSpec=[new InputSpec({ndim:this.rank+2,axes:(t={},t[n]=r,t)})],this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t;if(e=getExactlyOneTensor(e),1===n.rank)throw new NotImplementedError("1D separable convolution is not implemented yet.");return 2===n.rank&&("channelsFirst"===n.dataFormat&&(e=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(e,[0,2,3,1])),t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["separableConv2d"])(e,n.depthwiseKernel.read(),n.pointwiseKernel.read(),n.strides,n.padding,n.dilationRate,"NHWC")),n.useBias&&(t=biasAdd(t,n.bias.read(),n.dataFormat)),null!=n.activation&&(t=n.activation.apply(t)),"channelsFirst"===n.dataFormat&&(t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(t,[0,3,1,2])),t})},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=serializeInitializer(this.depthwiseInitializer),t.pointwiseInitializer=serializeInitializer(this.pointwiseInitializer),t.depthwiseRegularizer=serializeRegularizer(this.depthwiseRegularizer),t.pointwiseRegularizer=serializeRegularizer(this.pointwiseRegularizer),t.depthwiseConstraint=serializeConstraint(this.depthwiseConstraint),t.pointwiseConstraint=serializeConstraint(this.pointwiseConstraint),t},t.className="SeparableConv",t}(Conv),SeparableConv2D=function(e){function t(t){return e.call(this,2,t)||this}return __extends(t,e),t.className="SeparableConv2D",t}(SeparableConv);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(SeparableConv2D);var Conv1D=function(e){function t(n){var r=e.call(this,1,n)||this;return t.verifyArgs(n),r.inputSpec=[{ndim:3}],r}return __extends(t,e),t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return delete t.rank,delete t.dataFormat,t},t.verifyArgs=function(e){if("number"!=typeof e.kernelSize&&!checkArrayTypeAndLength(e.kernelSize,"number",1,1))throw new ValueError("Conv1D expects config.kernelSize to be number or number[] with length 1, but received "+JSON.stringify(e.kernelSize)+".")},t.className="Conv1D",t}(Conv);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Conv1D);var Cropping2D=function(e){function t(t){var n=e.call(this,t)||this;return"number"==typeof t.cropping?n.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"==typeof t.cropping[0]?n.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:n.cropping=t.cropping,n.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,n.inputSpec=[{ndim:4}],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return e=getExactlyOneTensor(e),"channelsLast"===n.dataFormat?sliceAlongAxis(sliceAlongAxis(e,n.cropping[0][0],e.shape[1]-n.cropping[0][0]-n.cropping[0][1],2),n.cropping[1][0],e.shape[2]-n.cropping[1][1]-n.cropping[1][0],3):sliceAlongAxis(sliceAlongAxis(e,n.cropping[0][0],e.shape[2]-n.cropping[0][0]-n.cropping[0][1],3),n.cropping[1][0],e.shape[3]-n.cropping[1][1]-n.cropping[1][0],4)})},t.prototype.getConfig=function(){var t={cropping:this.cropping,dataFormat:this.dataFormat},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Cropping2D",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Cropping2D);var UpSampling2D=function(e){function t(t){var n=e.call(this,t)||this;return n.DEFAULT_SIZE=[2,2],n.inputSpec=[{ndim:4}],n.size=null==t.size?n.DEFAULT_SIZE:t.size,n.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,n}return __extends(t,e),t.prototype.computeOutputShape=function(e){if("channelsFirst"===this.dataFormat){var t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e),r=t.shape;if("channelsFirst"===n.dataFormat){t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(t,[0,2,3,1]);var i=n.size[0]*r[2],a=n.size[1]*r[3],o=t.resizeNearestNeighbor([i,a]);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(o,[0,3,1,2])}i=n.size[0]*r[1],a=n.size[1]*r[2];return t.resizeNearestNeighbor([i,a])})},t.prototype.getConfig=function(){var t={size:this.size,dataFormat:this.dataFormat},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="UpSampling2D",t}(Layer);function depthwiseConv2d$1(e,t,n,r,i,a){return void 0===n&&(n=[1,1]),void 0===r&&(r="valid"),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){null==i&&(i=imageDataFormat()),checkDataFormat(i);var o=preprocessConv2DInput(e,i);if(4!==e.rank)throw new ValueError("Input for depthwiseConv2d is required to be 4-D, but is instead "+e.rank+"-D");if(4!==t.rank)throw new ValueError("depthwiseKernel is required to be 4-D, but is instead "+t.rank+"-D");return o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthwiseConv2d"])(o,t,n,"same"===r?"same":"valid","NHWC",a),"channelsFirst"===i&&(o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(o,[0,3,1,2])),o})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(UpSampling2D);var DepthwiseConv2D=function(e){function t(t){var n=e.call(this,2,t)||this;return n.depthwiseKernel=null,n.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,n.depthwiseInitializer=getInitializer(t.depthwiseInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.depthwiseConstraint=getConstraint(t.depthwiseConstraint),n.depthwiseRegularizer=getRegularizer(t.depthwiseRegularizer),n}return __extends(t,e),t.prototype.build=function(e){if((e=getExactlyOneShape(e)).length<4)throw new ValueError("Inputs to DepthwiseConv2D should have rank 4. Received input shape: "+JSON.stringify(e)+".");var t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new ValueError("The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not ("+e[t]+").");var n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=depthwiseConv2d$1(e=getExactlyOneTensor(e),n.depthwiseKernel.read(),n.strides,n.padding,n.dataFormat,null);return n.useBias&&(t=biasAdd(t,n.bias.read(),n.dataFormat)),null!=n.activation&&(t=n.activation.apply(t)),t})},t.prototype.computeOutputShape=function(e){e=getExactlyOneShape(e);var t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=convOutputLength(t,this.kernelSize[0],this.padding,this.strides[0]),a=convOutputLength(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,i,a]:[e[0],i,a,r]},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this);return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=serializeInitializer(this.depthwiseInitializer),t.depthwiseRegularizer=serializeRegularizer(this.depthwiseRegularizer),t.depthwiseConstraint=serializeConstraint(this.depthwiseRegularizer),t},t.className="DepthwiseConv2D",t}(BaseConv);function mapActivationToFusedKernel(e){return"relu"===e?"relu":"linear"===e?"linear":null}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(DepthwiseConv2D);var Dropout=function(e){function t(t){var n=e.call(this,t)||this;if(n.rate=Math.max(Math.min(t.rate,1),0),n.noiseShape=t.noiseShape,n.seed=t.seed,null!=n.seed)throw new NotImplementedError("Non-default seed is not implemented in Dropout layer yet: "+n.seed);return n.supportsMasking=!0,n}return __extends(t,e),t.prototype.getNoiseShape=function(e){if(null==this.noiseShape)return this.noiseShape;for(var t=e.shape,n=[],r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e);if(null!=n.noiseShape&&!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(r.shape,n.noiseShape))throw new NotImplementedError("Non-default noise shape is not implemented in Dropout layer yet: "+JSON.stringify(n.noiseShape));if(0<n.rate&&n.rate<1){var i=null!=t.training&&t.training,a=n.getNoiseShape(r);return inTrainPhase(function(){return dropout(r,n.rate,a,n.seed)},function(){return r},i)}return e})},t.prototype.getConfig=function(){var t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.prototype.dispose=function(){return e.prototype.dispose.call(this)},t.className="Dropout",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Dropout);var Dense=function(e){function t(t){var n=e.call(this,t)||this;if(n.activation=null,n.useBias=!0,n.kernel=null,n.bias=null,n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){var r=null;null!=t.batchSize&&(r=t.batchSize),n.batchInputShape=[r,t.inputDim]}return n.units=t.units,assertPositiveInteger(n.units,"units"),n.activation=getActivation(t.activation),null!=t.useBias&&(n.useBias=t.useBias),n.kernelInitializer=getInitializer(t.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.biasInitializer=getInitializer(t.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.kernelConstraint=getConstraint(t.kernelConstraint),n.biasConstraint=getConstraint(t.biasConstraint),n.kernelRegularizer=getRegularizer(t.kernelRegularizer),n.biasRegularizer=getRegularizer(t.biasRegularizer),n.activityRegularizer=getRegularizer(t.activityRegularizer),n.supportsMasking=!0,n.inputSpec=[{minNDim:2}],n}return __extends(t,e),t.prototype.build=function(e){var t,n=(e=getExactlyOneShape(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:(t={},t[-1]=n,t)}],this.built=!0},t.prototype.computeOutputShape=function(e){var t=(e=getExactlyOneShape(e)).slice();return t[t.length-1]=this.units,t},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r,i=getExactlyOneTensor(e),a=mapActivationToFusedKernel(n.activation.getClassName());return null!=a?r=dot(i,n.kernel.read(),a,n.bias?n.bias.read():null):(r=dot(i,n.kernel.read()),null!=n.bias&&(r=biasAdd(r,n.bias.read())),null!=n.activation&&(r=n.activation.apply(r))),r})},t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),biasConstraint:serializeConstraint(this.biasConstraint)},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Dense",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Dense);var Flatten=function(e){function t(t){var n=e.call(this,t||{})||this;return n.inputSpec=[{minNDim:3}],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){for(var t=0,n=(e=getExactlyOneShape(e)).slice(1);t<n.length;t++){if(null==n[t])throw new ValueError('The shape of the input to "Flatten" is not fully defined (got '+e.slice(1)+'). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.')}return[e[0],arrayProd(e,1)]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return n.invokeCallHook(e,t),batchFlatten(getExactlyOneTensor(e))})},t.className="Flatten",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Flatten);var Activation$1=function(e){function t(t){var n=e.call(this,t)||this;return n.supportsMasking=!0,n.activation=getActivation(t.activation),n}return __extends(t,e),t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e);return n.activation.apply(r)})},t.prototype.getConfig=function(){var t={activation:serializeActivation(this.activation)},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Activation",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Activation$1);var RepeatVector=function(e){function t(t){var n=e.call(this,t)||this;return n.n=t.n,n.inputSpec=[{ndim:2}],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return[e[0],this.n,e[1]]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return repeat(e=getExactlyOneTensor(e),n.n)})},t.prototype.getConfig=function(){var t={n:this.n},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="RepeatVector",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(RepeatVector);var Reshape=function(e){function t(t){var n=e.call(this,t)||this;n.targetShape=t.targetShape;for(var r=0;r<n.targetShape.length;++r)n.isUnknown(n.targetShape[r])&&(n.targetShape[r]=null);return n}return __extends(t,e),t.prototype.isUnknown=function(e){return e<0||null==e},t.prototype.fixUnknownDimension=function(e,t){for(var n="Total size of new array must be unchanged.",r=t.slice(),i=1,a=null,o=0;o<r.length;++o){var s=r[o];if(this.isUnknown(s)){if(null!==a)throw new ValueError("Can only specifiy one unknown dimension.");a=o}else i*=s}var l=arrayProd(e);if(null!==a){if(0===i||l%i!=0)throw new ValueError(n);r[a]=l/i}else if(l!==i)throw new ValueError(n);return r},t.prototype.computeOutputShape=function(e){for(var t=!1,n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e),i=r.shape,a=i.slice(0,1).concat(n.fixUnknownDimension(i.slice(1),n.targetShape));return r.reshape(a)})},t.prototype.getConfig=function(){var t={targetShape:this.targetShape},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Reshape",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Reshape);var Permute=function(e){function t(t){var n=e.call(this,t)||this;if(null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+t.dims+" instead.");var r=range(1,t.dims.length+1);if(!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(t.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");return n.dims=t.dims,n.dimsIncludingBatch=[0].concat(n.dims),n.inputSpec=[new InputSpec({ndim:n.dims.length+1})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){var t=(e=getExactlyOneShape(e)).slice();return this.dims.forEach(function(n,r){t[r+1]=e[n]}),t},t.prototype.call=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(getExactlyOneTensor(e),this.dimsIncludingBatch)},t.prototype.getConfig=function(){var t={dims:this.dims},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Permute",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Permute);var Masking=function(e){function t(t){var n=e.call(this,null==t?{}:t)||this;return n.supportsMasking=!0,n.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0,n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this),n={maskValue:this.maskValue};return Object.assign(n,t),n},t.prototype.computeMask=function(e,t){var n=getExactlyOneTensor(e);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["any"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["notEqual"])(n,this.maskValue),-1)},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["any"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["notEqual"])(r,n.maskValue),-1,!0);return r.mul(i.asType(r.dtype))})},t.className="Masking",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Masking);var Embedding=function(e){function t(t){var n=e.call(this,t)||this;if(n.embeddings=null,n.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){var r=null;null!=t.batchSize&&(r=t.batchSize),null==t.inputLength?n.batchInputShape=[r,null]:n.batchInputShape=[r].concat(toList(t.inputLength))}return n.inputDim=t.inputDim,assertPositiveInteger(n.inputDim,"inputDim"),n.outputDim=t.outputDim,assertPositiveInteger(n.outputDim,"outputDim"),n.embeddingsInitializer=getInitializer(t.embeddingsInitializer||n.DEFAULT_EMBEDDINGS_INITIALIZER),n.embeddingsRegularizer=getRegularizer(t.embeddingsRegularizer),n.activityRegularizer=getRegularizer(t.activityRegularizer),n.embeddingsConstraint=getConstraint(t.embeddingsConstraint),n.maskZero=t.maskZero,n.supportsMasking=t.maskZero,n.inputLength=t.inputLength,n}return __extends(t,e),t.prototype.build=function(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0},t.prototype.warnOnIncompatibleInputShape=function(e){},t.prototype.computeMask=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return n.maskZero?(e=getExactlyOneTensor(e),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["notEqual"])(e,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zerosLike"])(e))):null})},t.prototype.computeOutputShape=function(e){if(e=getExactlyOneShape(e),null==this.inputLength)return e.concat([this.outputDim]);var t=toList(this.inputLength);if(t.length!==e.length-1)throw new ValueError('"inputLength" is '+this.inputLength+", but received input shape has shape "+e);for(var n=0,r=0;r<t.length;++r){var i=t[r],a=e[r+1];if(null!=i&&null!=a&&i!==a)throw new ValueError('"inputLength" is '+this.inputLength+", but received input shape has shape "+e);null==i&&(t[n]=a),n++}return[e[0]].concat(t,[this.outputDim])},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e);return"int32"!==r.dtype&&(r=cast$1(r,"int32")),gather$1(n.embeddings.read(),r.as1D()).reshape(getExactlyOneShape(n.computeOutputShape(r.shape)))})},t.prototype.getConfig=function(){var t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:serializeInitializer(this.embeddingsInitializer),embeddingsRegularizer:serializeRegularizer(this.embeddingsRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),embeddingsConstraint:serializeConstraint(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Embedding",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Embedding);var Merge=function(e){function t(t){var n=e.call(this,t||{})||this;return n.supportsMasking=!0,n}return __extends(t,e),t.prototype.mergeFunction=function(e){throw new NotImplementedError},t.prototype.computeElementwiseOpOutputShape=function(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;for(var n=e.slice(0,e.length-t.length),r=0;r<t.length;++r){var i=e[e.length-t.length+r],a=t[r];if(null==i||null==a||i<0||a<0)n.push(null);else if(1===i)n.push(a);else if(1===a)n.push(i);else{if(i!==a)throw new ValueError("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(i)}}return n},t.prototype.build=function(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[getExactlyOneShape(e)]),(e=e).length<2)throw new ValueError("A merge layer should be called on an Array of at least 2 inputs. Got "+e.length+" input(s).");for(var t=[],n=0,r=e;n<r.length;n++){null!=(o=r[n])&&null!==o[0]&&t.push(o[0])}if((t=unique(t)).length>1)throw new ValueError("Can not merge tensors with different batch sizes. Got tensors with shapes: "+JSON.stringify(e)+".");for(var i=null==e[0]?null:e[0].slice(1),a=1;a<e.length;++a){var o=null==e[a]?null:e[a].slice(1);i=this.computeElementwiseOpOutputShape(i,o)}var s=e.map(function(e){return e.length});-1===e.indexOf(null)&&1===unique(s).length?this.reshapeRequired=!1:this.reshapeRequired=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(e=e,n.reshapeRequired){var t=[],r=e.map(function(e){return e.rank});if(-1===r.indexOf(null)){for(var i=max$1(r),a=0,o=e;a<o.length;a++){for(var s=(h=o[a]).rank,l=0;l<i-s;++l)h=expandDims$1(h,1);t.push(h)}return n.mergeFunction(t)}for(var u=!1,c=0,p=e;c<p.length;c++){var h;if(null==(s=(h=p[c]).rank)){var d=h.shape,f=d[0],g=d.slice(1).concat([f]),m=h.reshape([f].concat(arrayProd(d.slice(1))));m=(m=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(m,[1,0])).reshape(g),t.push(m),u=!0}else if(s>1){var y=range(1,s).concat([0]);t.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(h,y)),u=!0}else t.push(h)}var v=n.mergeFunction(t),b=v.rank;if(u)if(null==b){var w=v.shape;g=[f=w[w.length-1]].concat(w.slice(0,w.length-1));v=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(v.reshape([-1,f]),[1,0]).reshape(g)}else if(b>1){y=[b-1].concat(range(0,b-1));v=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(v,y)}return v}return n.mergeFunction(e)})},t.prototype.computeOutputShape=function(e){var t;t=null==(e=e)[0]?null:e[0].slice(1);for(var n=1;n<e.length;++n){var r=null==e[n]?null:e[n].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}for(var i=[],a=0,o=e;a<o.length;a++){null!=(r=o[a])&&null!==r[0]&&i.push(r[0])}return t=1===(i=unique(i)).length?i.concat(t):[null].concat(t)},t.prototype.computeMask=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null==t)return null;if(!Array.isArray(t))throw new ValueError("`mask` should be an Array");if(!Array.isArray(e))throw new ValueError("`inputs` should be an Array");if(t.length!==e.length)throw new ValueError("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths ("+e.length+" vs "+t.length+")");if(t.every(function(e){return null==e}))return null;for(var n=(t=t.map(function(e){return null==e?e:Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"])(e,0)}))[0],r=1;r<t.length-1;++r)n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"])(n,t[r]);return n})},t}(Layer),Add=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.mergeFunction=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=e[0].clone(),n=1;n<e.length;++n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(t,e[n]);return t})},t.className="Add",t}(Merge);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Add);var Multiply=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.mergeFunction=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=e[0].clone(),n=1;n<e.length;++n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(t,e[n]);return t})},t.className="Multiply",t}(Merge);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Multiply);var Average=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.mergeFunction=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=e[0].clone(),n=1;n<e.length;++n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(t,e[n]);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(1/e.length,t)})},t.className="Average",t}(Merge);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Average);var Maximum=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.mergeFunction=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=e[0],n=1;n<e.length;++n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"])(t,e[n]);return t})},t.className="Maximum",t}(Merge);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Maximum);var Minimum=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.mergeFunction=function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var t=e[0],n=1;n<e.length;++n)t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["minimum"])(t,e[n]);return t})},t.className="Minimum",t}(Merge);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Minimum);var Concatenate=function(e){function t(t){var n=e.call(this,t)||this;return n.DEFAULT_AXIS=-1,null==t&&(t={}),n.axis=null==t.axis?n.DEFAULT_AXIS:t.axis,n.supportsMasking=!0,n.reshapeRequired=!1,n}return __extends(t,e),t.prototype.build=function(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new ValueError("A `Concatenate` layer should be called on a list of at least 2 inputs");for(var t=!0,n=0,r=e=e;n<r.length;n++){if(null!=(c=r[n])){t=!1;break}}if(!t){for(var i=[],a=0;a<e.length;++a){var o=e[a].slice();o.splice(this.axis,1);for(var s=!1,l=0,u=i;l<u.length;l++){var c=u[l];if(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(c,o)){s=!0;break}}s||i.push(o)}if(i.length>1)throw new ValueError("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}},t.prototype.mergeFunction=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return concatenate(e,t.axis)})},t.prototype.computeOutputShape=function(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new ValueError("A `Concatenate` layer should be called on a list of inputs.");for(var t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis,i=0,a=t.slice(1);i<a.length;i++){var o=a[i];if(null==n[r]||null==o[r]){n[r]=null;break}n[r]+=o[r]}return n},t.prototype.computeMask=function(e,t){var n=this;if(null==t)return null;if(!Array.isArray(t))throw new ValueError("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new ValueError("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new ValueError("Mismatch in the length of mask ("+t.length+") and the legnth of inputs ("+e.length+")");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=!0;if(t.forEach(function(e){null==e||(r=!1)}),r)return null;for(var i=[],a=0;a<e.length;++a)null==t[a]?i.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(e[a]).asType("bool")):t[a].rank<e[a].rank?i.push(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"])(t[a],-1)):i.push(t[a]);var o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"])(i,n.axis);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["all"])(o,-1,!1)})},t.prototype.getConfig=function(){var t={axis:this.axis},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Concatenate",t}(Merge);function interpretAxis(e,t){for(;e<0;)e+=t;return e}function batchDot(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new NotImplementedError("batchDot is not implemented for tensors of 4D or higher rank yet");if(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(e.shape.length>=2,function(){return"batchDot requires the rank of x to be >= 2, but got "+e.shape.length}),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(e.shape.length>=2,function(){return"batchDot requires the rank of y to be >= 2, but got "+t.shape.length}),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new NotImplementedError("batchDot is not implemented for complex64-type Tensors yet.");var r=e.shape.length,i=t.shape.length;null==n&&(n=[r-1,i-2]);var a=n;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n,o;if(r>i){n=r-i;for(var s=[],l=0;l<n;++l)s.push(1);t=t.reshape(t.shape.concat(s))}else if(i>r){n=i-r;for(s=[],l=0;l<n;++l)s.push(1);e=e.reshape(e.shape.concat(s))}else n=0;if(2===e.shape.length&&2===t.shape.length)o=a[0]===a[1]?e.mulStrict(t).sum(a[0]):e.transpose([1,0]).mulStrict(t).sum(a[1]);else{var u=a[0]!==e.shape.length-1,c=a[1]===t.shape.length-1;o=e.matMul(t,u,c)}if(n>0){var p=void 0,h=[];for(l=p=r>i?r+i-3:r-1;l<p+n;++l)h.push(l);o=o.squeeze(h)}return 1===o.shape.length&&(o=o.expandDims(1)),o})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Concatenate);var Dot=function(e){function t(t){var n=e.call(this,t)||this;return n.axes=t.axes,n.normalize=null!=t.normalize&&t.normalize,n.supportsMasking=!0,n.reshapeRequired=!1,n}return __extends(t,e),t.prototype.build=function(e){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),function(){return"A `Dot` layer should be called on a list of exactly 2 inputs."});var t=e[0],n=e[1];if(t.length>3||n.length>3)throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");var r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new ValueError("Dimension incompatibility: "+t[r[0]]+" !== "+n[r[1]])},t.prototype.mergeFunction=function(e){if(2!==e.length)throw new ValueError("A `Dot` layer must be called on exactly 2 inputs, but received "+e.length+" input(s).");var t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(function(t,n){return interpretAxis(t,e[n].shape.length)}):[interpretAxis(this.axes,n.shape.length),interpretAxis(this.axes,r.shape.length)],this.normalize&&(n=l2Normalize(n,t[0]),r=l2Normalize(r,t[1])),batchDot(n,r,t)},t.prototype.interpretAxes=function(e,t){return Array.isArray(this.axes)?this.axes:[interpretAxis(this.axes,e.length),interpretAxis(this.axes,t.length)]},t.prototype.computeOutputShape=function(e){_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),function(){return"A `Dot` layer should be called on a list of exactly 2 inputs."});var t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");var r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);var i=t.concat(n);return 1===i.length&&i.push(1),i},t.prototype.computeMask=function(e,t){return null},t.prototype.getConfig=function(){var t={axes:this.axes,normalize:this.normalize},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="Dot",t}(Merge);function batchNormalization(e,t,n,r,i,a){var o;if(void 0===a&&(a=.001),2===e.rank)o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm2d"])(e,t,n,r,i,a);else if(3===e.rank)o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm3d"])(e,t,n,r,i,a);else{if(4!==e.rank)throw new NotImplementedError("batchNormalization is not implemented for array of rank "+e.rank+" yet");o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm4d"])(e,t,n,r,i,a)}return o}function regularNormalizeBatchInTraining(e,t,n,r,i){return void 0===i&&(i=.001),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["moments"])(e,r),o=a.mean,s=a.variance;return[batchNormalization(e,o,s,n,t,i),o,s]})}function broadcastNormalizeBatchInTraining(e,t,n,r,i){return void 0===i&&(i=.001),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["moments"])(e,r),o=a.mean,s=a.variance,l=[],u=0,c=range(0,e.rank);u<c.length;u++){var p=c[u];-1!==r.indexOf(p)?l.push(1):l.push(e.shape[p])}var h=o.reshape(l),d=s.reshape(l),f=null==t?null:t.reshape(l),g=null==n?null:n.reshape(l);return[batchNormalization(e,h,d,g,f,i),o,s]})}function normalizeBatchInTraining(e,t,n,r,i){return void 0===i&&(i=.001),_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(r.slice().sort(),range(0,e.rank-1))?regularNormalizeBatchInTraining(e,t,n,r,i):broadcastNormalizeBatchInTraining(e,t,n,r,i)}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Dot);var BatchNormalization=function(e){function t(t){var n=this;return null==t&&(t={}),(n=e.call(this,t)||this).supportsMasking=!0,n.axis=null==t.axis?-1:t.axis,n.momentum=null==t.momentum?.99:t.momentum,n.epsilon=null==t.epsilon?.001:t.epsilon,n.center=null==t.center||t.center,n.scale=null==t.scale||t.scale,n.betaInitializer=getInitializer(t.betaInitializer||"zeros"),n.gammaInitializer=getInitializer(t.gammaInitializer||"ones"),n.movingMeanInitializer=getInitializer(t.movingMeanInitializer||"zeros"),n.movingVarianceInitializer=getInitializer(t.movingVarianceInitializer||"ones"),n.betaConstraint=getConstraint(t.betaConstraint),n.gammaConstraint=getConstraint(t.gammaConstraint),n.betaRegularizer=getRegularizer(t.betaRegularizer),n.gammaRegularizer=getRegularizer(t.gammaRegularizer),n}return __extends(t,e),t.prototype.build=function(e){var t;e=getExactlyOneShape(e);var n=this.axis>=0?this.axis:this.axis+e.length,r=e[n];if(null==r)throw new ValueError("Axis "+n+" of input tensor should have a defined dimension but the layer received an input with shape "+JSON.stringify(e)+".");this.inputSpec=[new InputSpec({ndim:e.length,axes:(t={},t[n]=r,t)})];var i=[r];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=null!=t.training&&t.training,i=getExactlyOneTensor(e),a=i.shape,o=a.length,s=range(0,o),l=n.axis>=0?n.axis:n.axis+o;s.splice(l,1);var u=pyListRepeat(1,o);u[l]=a[l];var c=s.slice();c.sort();var p=!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(c,range(0,o).slice(0,o-1));if(!r)return function(){if(p){var e=n.movingMean.read().reshape(u),t=n.movingVariance.read().reshape(u),r=n.center?n.beta.read().reshape(u):null,a=n.scale?n.gamma.read().reshape(u):null;return batchNormalization(i,e,t,r,a,n.epsilon)}return batchNormalization(i,n.movingMean.read(),n.movingVariance.read(),null==n.beta?null:n.beta.read(),null==n.gamma?null:n.gamma.read(),n.epsilon)}();var h=normalizeBatchInTraining(i,n.gamma.read(),n.beta.read(),s,n.epsilon),d=h[0],f=h[1],g=h[2],m=function(e,t,n){Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=1-n,i=e.read(),a=i.sub(t).mul(r);e.write(i.sub(a))})};return m(n.movingMean,f,n.momentum),m(n.movingVariance,g,n.momentum),d})},t.prototype.getConfig=function(){var t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:serializeInitializer(this.betaInitializer),gammaInitializer:serializeInitializer(this.gammaInitializer),movingMeanInitializer:serializeInitializer(this.movingMeanInitializer),movingVarianceInitializer:serializeInitializer(this.movingVarianceInitializer),betaRegularizer:serializeRegularizer(this.betaRegularizer),gammaRegularizer:serializeRegularizer(this.gammaRegularizer),betaConstraint:serializeConstraint(this.betaConstraint),gammaConstraint:serializeConstraint(this.gammaConstraint)},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="BatchNormalization",t}(Layer);function spatial2dPadding(e,t,n){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(4!==e.rank)throw new ValueError("temporalPadding expects input tensor to be 4-D, but received a "+e.rank+"-D tensor.");if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new ValueError("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n=imageDataFormat()),"channelsLast"!==n&&"channelsFirst"!==n)throw new ValueError("Unknown data format: "+n+". Supported data formats are 'channelsLast' and 'channelsFirst.");var r;return r="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad"])(e,r)})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(BatchNormalization);var ZeroPadding2D=function(e){function t(t){var n=this;if(null==t&&(t={}),(n=e.call(this,t)||this).dataFormat=null==t.dataFormat?imageDataFormat():t.dataFormat,null==t.padding)n.padding=[[1,1],[1,1]];else if("number"==typeof t.padding)n.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new ValueError("ZeroPadding2D expects padding to be a length-2 array, but received a length-"+t.padding.length+" array.");var r=void 0,i=void 0;if("number"==typeof t.padding[0])r=[t.padding[0],t.padding[0]],i=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new ValueError("ZeroPadding2D expects height padding to be a length-2 array, but received a length-"+t.padding[0].length+" array.");if(r=t.padding[0],2!==t.padding[1].length)throw new ValueError("ZeroPadding2D expects width padding to be a length-2 array, but received a length-"+t.padding[1].length+" array.");i=t.padding[1]}n.padding=[r,i]}return n.inputSpec=[new InputSpec({ndim:4})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){var t,n;return e=getExactlyOneShape(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return spatial2dPadding(getExactlyOneTensor(e),n.padding,n.dataFormat)})},t.prototype.getConfig=function(){var t={padding:this.padding,dataFormat:this.dataFormat},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="ZeroPadding2D",t}(Layer);function pool2d(e,t,n,r,i,a){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var o;checkDataFormat(i),checkPoolMode(a),checkPaddingMode(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==i&&(i=imageDataFormat()),null==a&&(a="max"),e=preprocessConv2DInput(e,i);var s="same"===r?"same":"valid";return o="max"===a?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maxPool"])(e,t,n,s):Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["avgPool"])(e,t,n,s),"channelsFirst"===i&&(o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(o,[0,3,1,2])),o})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(ZeroPadding2D);var Pooling1D=function(e){function t(t){var n=this;if(null==t.poolSize&&(t.poolSize=2),n=e.call(this,t)||this,"number"==typeof t.poolSize)n.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new ValueError("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+JSON.stringify(t.poolSize));n.poolSize=t.poolSize}if(assertPositiveInteger(n.poolSize,"poolSize"),null==t.strides)n.strides=n.poolSize;else if("number"==typeof t.strides)n.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new ValueError("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+JSON.stringify(t.strides));n.strides=t.strides}return assertPositiveInteger(n.strides,"strides"),n.padding=null==t.padding?"valid":t.padding,checkPaddingMode(n.padding),n.inputSpec=[new InputSpec({ndim:3})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){var t=convOutputLength((e=getExactlyOneShape(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t),e=expandDims$1(getExactlyOneTensor(e),2);var r=n.poolingFunction(getExactlyOneTensor(e),[n.poolSize[0],1],[n.strides[0],1],n.padding,"channelsLast");return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squeeze"])(r,[2])})},t.prototype.getConfig=function(){var t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t}(Layer),MaxPooling1D=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.poolingFunction=function(e,t,n,r,i){return checkDataFormat(i),checkPaddingMode(r),pool2d(e,t,n,r,i,"max")},t.className="MaxPooling1D",t}(Pooling1D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(MaxPooling1D);var AveragePooling1D=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.poolingFunction=function(e,t,n,r,i){return checkDataFormat(i),checkPaddingMode(r),pool2d(e,t,n,r,i,"avg")},t.className="AveragePooling1D",t}(Pooling1D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(AveragePooling1D);var Pooling2D=function(e){function t(t){var n=this;if(null==t.poolSize&&(t.poolSize=[2,2]),(n=e.call(this,t)||this).poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)n.strides=n.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new ValueError("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+t.strides.length+".");n.strides=t.strides}else n.strides=[t.strides,t.strides];return assertPositiveInteger(n.poolSize,"poolSize"),assertPositiveInteger(n.strides,"strides"),n.padding=null==t.padding?"valid":t.padding,n.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,checkDataFormat(n.dataFormat),checkPaddingMode(n.padding),n.inputSpec=[new InputSpec({ndim:4})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){e=getExactlyOneShape(e);var t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=convOutputLength(t,this.poolSize[0],this.padding,this.strides[0]),n=convOutputLength(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return n.invokeCallHook(e,t),n.poolingFunction(getExactlyOneTensor(e),n.poolSize,n.strides,n.padding,n.dataFormat)})},t.prototype.getConfig=function(){var t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t}(Layer),MaxPooling2D=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.poolingFunction=function(e,t,n,r,i){return checkDataFormat(i),checkPaddingMode(r),pool2d(e,t,n,r,i,"max")},t.className="MaxPooling2D",t}(Pooling2D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(MaxPooling2D);var AveragePooling2D=function(e){function t(t){return e.call(this,t)||this}return __extends(t,e),t.prototype.poolingFunction=function(e,t,n,r,i){return checkDataFormat(i),checkPaddingMode(r),pool2d(e,t,n,r,i,"avg")},t.className="AveragePooling2D",t}(Pooling2D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(AveragePooling2D);var GlobalPooling1D=function(e){function t(t){var n=e.call(this,t)||this;return n.inputSpec=[new InputSpec({ndim:3})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return[e[0],e[2]]},t.prototype.call=function(e,t){throw new NotImplementedError},t}(Layer),GlobalAveragePooling1D=function(e){function t(t){return e.call(this,t||{})||this}return __extends(t,e),t.prototype.call=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(t,1)})},t.className="GlobalAveragePooling1D",t}(GlobalPooling1D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlobalAveragePooling1D);var GlobalMaxPooling1D=function(e){function t(t){return e.call(this,t||{})||this}return __extends(t,e),t.prototype.call=function(e,t){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e);return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(t,1)})},t.className="GlobalMaxPooling1D",t}(GlobalPooling1D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlobalMaxPooling1D);var GlobalPooling2D=function(e){function t(t){var n=e.call(this,t)||this;return n.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,checkDataFormat(n.dataFormat),n.inputSpec=[new InputSpec({ndim:4})],n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return e=e,"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]},t.prototype.call=function(e,t){throw new NotImplementedError},t.prototype.getConfig=function(){var t={dataFormat:this.dataFormat},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t}(Layer),GlobalAveragePooling2D=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e);return"channelsLast"===n.dataFormat?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(t,[1,2]):Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"])(t,[2,3])})},t.className="GlobalAveragePooling2D",t}(GlobalPooling2D);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlobalAveragePooling2D);var GlobalMaxPooling2D=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var t=getExactlyOneTensor(e);return"channelsLast"===n.dataFormat?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(t,[1,2]):Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"])(t,[2,3])})},t.className="GlobalMaxPooling2D",t}(GlobalPooling2D);function standardizeArgs(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new ValueError("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function i(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=i(t),constants:n=i(n)}}function rnn(e,t,n,r,i,a,o,s){return void 0===r&&(r=!1),void 0===o&&(o=!1),void 0===s&&(s=!1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var l=t.shape.length;if(l<3)throw new ValueError("Input should be at least 3D, but is "+l+"D.");var u=[1,0].concat(range(2,l));if(t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(t,u),null!=a)throw new NotImplementedError("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=i&&((i=i.asType("bool").asType("float32")).rank===l-1&&(i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"])(i,-1)),i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"])(i,u)),r&&(t=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse"])(t,0),null!=i&&(i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse"])(i,0)));var c,p,h=[],d=n,f=t.shape[0],g=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"])(t);null!=i&&(p=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"])(i));for(var m,y=function(t){var n=g[t],r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return e(n,d)});if(null==i)c=r[0],d=r[1];else{var a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var e=p[t],n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(e).sub(e);return{output:r[0].mul(e).addStrict(d[0].mul(n)),newStates:d.map(function(t,i){return r[1][i].mul(e).addStrict(t.mul(n))})}});c=a.output,d=a.newStates}s&&h.push(c)},v=0;v<f;++v)y(v);if(s){m=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"])(h,1)}return[c,m,d]})}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GlobalMaxPooling2D);var RNN=function(e){function t(t){var n,r=e.call(this,t)||this;if(null==t.cell)throw new ValueError("cell property is missing for the constructor of RNN.");if(null==(n=Array.isArray(t.cell)?new StackedRNNCells({cells:t.cell}):t.cell).stateSize)throw new ValueError("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");return r.cell=n,r.returnSequences=null!=t.returnSequences&&t.returnSequences,r.returnState=null!=t.returnState&&t.returnState,r.goBackwards=null!=t.goBackwards&&t.goBackwards,r._stateful=null!=t.stateful&&t.stateful,r.unroll=null!=t.unroll&&t.unroll,r.supportsMasking=!0,r.inputSpec=[new InputSpec({ndim:3})],r.stateSpec=null,r.states_=null,r.numConstants=null,r.keptStates=[],r}return __extends(t,e),t.prototype.getStates=function(){return null==this.states_?range(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(function(e){return null}):this.states_},t.prototype.setStates=function(e){this.states_=e},t.prototype.computeOutputShape=function(e){isArrayOfShapes(e)&&(e=e[0]),e=e;var t=this.cell.stateSize;Array.isArray(t)||(t=[t]);var n,r=t[0];if(n=this.returnSequences?[e[0],e[1],r]:[e[0],r],this.returnState){for(var i=[],a=0,o=t;a<o.length;a++){var s=o[a];i.push([e[0],s])}return[n].concat(i)}return n},t.prototype.computeMask=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){Array.isArray(t)&&(t=t[0]);var e=n.returnSequences?t:null;if(n.returnState){var r=n.states.map(function(e){return null});return[e].concat(r)}return e})},Object.defineProperty(t.prototype,"states",{get:function(){if(null==this.states_){for(var e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[],n=0;n<e;++n)t.push(null);return t}return this.states_},set:function(e){this.states_=e},enumerable:!0,configurable:!0}),t.prototype.build=function(e){if(null!=this.numConstants)throw new NotImplementedError("Constants support is not implemented in RNN yet.");isArrayOfShapes(e)&&(e=e[0]),e=e;var t=this.stateful?e[0]:null,n=e[e.length-1];this.inputSpec[0]=new InputSpec({shape:[t,null,n]});var r,i=[e[0]].concat(e.slice(2));if(this.cell.build(i),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(this.stateSpec.map(function(e){return e.shape[e.shape.length-1]}),r))throw new ValueError("An initialState was passed that is not compatible with cell.stateSize. Received stateSpec="+this.stateSpec+"; However cell.stateSize is "+this.cell.stateSize)}else this.stateSpec=r.map(function(e){return new InputSpec({shape:[null,e]})});this.stateful&&this.resetStates()},t.prototype.resetStates=function(e,t){var n=this;void 0===t&&(t=!1),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(!n.stateful)throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");var r=n.inputSpec[0].shape[0];if(null==r)throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==n.states_)Array.isArray(n.cell.stateSize)?n.states_=n.cell.stateSize.map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])([r,e])}):n.states_=[Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])([r,n.cell.stateSize])];else if(null==e)Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(n.states_),null!=n.keptStates&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(n.keptStates),n.keptStates=[]),Array.isArray(n.cell.stateSize)?n.states_=n.cell.stateSize.map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])([r,e])}):n.states_[0]=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])([r,n.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==n.states_.length)throw new ValueError("Layer "+n.name+" expects "+n.states_.length+" state(s), but it received "+e.length+" state value(s). Input received: "+e);!0===t?n.keptStates.push(n.states_.slice()):Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(n.states_);for(var i=0;i<n.states_.length;++i){var a=e[i],o=Array.isArray(n.cell.stateSize)?n.cell.stateSize[i]:n.cell.stateSize,s=[r,o];if(!_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"].arraysEqual(a.shape,s))throw new ValueError("State "+i+" is incompatible with layer "+n.name+": expected shape="+s+", received shape="+a.shape);n.states_[i]=a}}n.states_=n.states_.map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(e.clone())})})},t.prototype.apply=function(t,n){var r=null==n?null:n.initialState,i=null==n?null:n.constants;null==n&&(n={});var a=standardizeArgs(t,r,i,this.numConstants);t=a.inputs,r=a.initialState,i=a.constants;var o=[],s=[];if(null!=r){n.initialState=r,o=o.concat(r),this.stateSpec=[];for(var l=0,u=r;l<u.length;l++){var c=u[l];this.stateSpec.push(new InputSpec({shape:c.shape}))}s=s.concat(this.stateSpec)}if(null!=i&&(n.constants=i,o=o.concat(i),this.numConstants=i.length),o[0]instanceof SymbolicTensor){var p=[t].concat(o),h=this.inputSpec.concat(s),d=this.inputSpec;this.inputSpec=h;var f=e.prototype.apply.call(this,p,n);return this.inputSpec=d,f}return e.prototype.apply.call(this,t,n)},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=null==t?null:t.mask,i=null==t?null:t.training,a=null==t?null:t.initialState;e=getExactlyOneTensor(e),null==a&&(a=n.stateful?n.states_:n.getInitialState(e));var o=Array.isArray(n.cell.stateSize)?n.cell.stateSize.length:1;if(a.length!==o)throw new ValueError("RNN Layer has "+o+" state(s) but was passed "+a.length+" initial state(s).");n.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");var s={training:i},l=rnn(function(e,t){var r=n.cell.call([e].concat(t),s);return[r[0],r.slice(1)]},e,a,n.goBackwards,r,null,n.unroll,n.returnSequences),u=l[0],c=l[1],p=l[2];n.stateful&&n.resetStates(p,i);var h=n.returnSequences?c:u;return n.returnState?[h].concat(p):h})},t.prototype.getInitialState=function(e){var t=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"])(e.shape);return n=expandDims$1(n=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"])(n,[1,2])),Array.isArray(t.cell.stateSize)?t.cell.stateSize.map(function(e){return e>1?tile$1(n,[1,e]):n}):t.cell.stateSize>1?[tile$1(n,[1,t.cell.stateSize])]:[n]})},Object.defineProperty(t.prototype,"trainableWeights",{get:function(){return this.trainable?this.cell.trainableWeights:[]},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights},enumerable:!0,configurable:!0}),t.prototype.setFastWeightInitDuringBuild=function(t){e.prototype.setFastWeightInitDuringBuild.call(this,t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)},t.prototype.getConfig=function(){var t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);var n=this.cell.getConfig();t.cell={className:this.cell.getClassName(),config:n};var r=e.prototype.getConfig.call(this);return Object.assign(t,r),t},t.className="RNN",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(RNN);var RNNCell=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t}(Layer),SimpleRNNCell=function(e){function t(t){var n=e.call(this,t)||this;return n.DEFAULT_ACTIVATION="tanh",n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_RECURRENT_INITIALIZER="orthogonal",n.DEFAULT_BIAS_INITIALIZER="zeros",n.units=t.units,assertPositiveInteger(n.units,"units"),n.activation=getActivation(null==t.activation?n.DEFAULT_ACTIVATION:t.activation),n.useBias=null==t.useBias||t.useBias,n.kernelInitializer=getInitializer(t.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.recurrentInitializer=getInitializer(t.recurrentInitializer||n.DEFAULT_RECURRENT_INITIALIZER),n.biasInitializer=getInitializer(t.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.kernelRegularizer=getRegularizer(t.kernelRegularizer),n.recurrentRegularizer=getRegularizer(t.recurrentRegularizer),n.biasRegularizer=getRegularizer(t.biasRegularizer),n.kernelConstraint=getConstraint(t.kernelConstraint),n.recurrentConstraint=getConstraint(t.recurrentConstraint),n.biasConstraint=getConstraint(t.biasConstraint),n.dropout=min$1([1,max$1([0,null==t.dropout?0:t.dropout])]),n.recurrentDropout=min$1([1,max$1([0,null==t.recurrentDropout?0:t.recurrentDropout])]),n.stateSize=n.units,n.dropoutMask=null,n.recurrentDropoutMask=null,n}return __extends(t,e),t.prototype.build=function(e){e=getExactlyOneShape(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(2!==(e=e).length)throw new ValueError("SimpleRNNCell expects 2 input Tensors, got "+e.length+".");var r=e[1];e=e[0];var i,a=null!=t.training&&t.training;0<n.dropout&&n.dropout<1&&null==n.dropoutMask&&(n.dropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(e)},n.dropout,a)),0<n.recurrentDropout&&n.recurrentDropout<1&&null==n.recurrentDropoutMask&&(n.recurrentDropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(r)},n.recurrentDropout,a));var o=n.dropoutMask,s=n.recurrentDropoutMask;i=dot(null!=o?Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,o):e,n.kernel.read()),null!=n.bias&&(i=biasAdd(i,n.bias.read())),null!=s&&(r=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(r,s));var l=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(i,dot(r,n.recurrentKernel.read()));return null!=n.activation&&(l=n.activation.apply(l)),[l,l]})},t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="SimpleRNNCell",t}(RNNCell);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(SimpleRNNCell);var SimpleRNN=function(e){function t(t){return t.cell=new SimpleRNNCell(t),e.call(this,t)||this}return __extends(t,e),t.prototype.call=function(t,n){var r=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){null!=r.cell.dropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.dropoutMask),r.cell.dropoutMask=null),null!=r.cell.recurrentDropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.recurrentDropoutMask),r.cell.recurrentDropoutMask=null);var i=null==n?null:n.mask,a=null==n?null:n.training,o=null==n?null:n.initialState;return e.prototype.call.call(r,t,{mask:i,training:a,initialState:o})})},Object.defineProperty(t.prototype,"units",{get:function(){return this.cell.units},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"activation",{get:function(){return this.cell.activation},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"useBias",{get:function(){return this.cell.useBias},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelInitializer",{get:function(){return this.cell.kernelInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentInitializer",{get:function(){return this.cell.recurrentInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasInitializer",{get:function(){return this.cell.biasInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelRegularizer",{get:function(){return this.cell.kernelRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentRegularizer",{get:function(){return this.cell.recurrentRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasRegularizer",{get:function(){return this.cell.biasRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelConstraint",{get:function(){return this.cell.kernelConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentConstraint",{get:function(){return this.cell.recurrentConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasConstraint",{get:function(){return this.cell.biasConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"dropout",{get:function(){return this.cell.dropout},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentDropout",{get:function(){return this.cell.recurrentDropout},enumerable:!0,configurable:!0}),t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout},n=e.prototype.getConfig.call(this);return delete n.cell,Object.assign(t,n),t},t.className="SimpleRNN",t}(RNN);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(SimpleRNN);var GRUCell=function(e){function t(t){var n=e.call(this,t)||this;return n.DEFAULT_ACTIVATION="tanh",n.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_RECURRENT_INITIALIZER="orthogonal",n.DEFAULT_BIAS_INITIALIZER="zeros",n.units=t.units,assertPositiveInteger(n.units,"units"),n.activation=getActivation(void 0===t.activation?n.DEFAULT_ACTIVATION:t.activation),n.recurrentActivation=getActivation(void 0===t.recurrentActivation?n.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),n.useBias=null==t.useBias||t.useBias,n.kernelInitializer=getInitializer(t.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.recurrentInitializer=getInitializer(t.recurrentInitializer||n.DEFAULT_RECURRENT_INITIALIZER),n.biasInitializer=getInitializer(t.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.kernelRegularizer=getRegularizer(t.kernelRegularizer),n.recurrentRegularizer=getRegularizer(t.recurrentRegularizer),n.biasRegularizer=getRegularizer(t.biasRegularizer),n.kernelConstraint=getConstraint(t.kernelConstraint),n.recurrentConstraint=getConstraint(t.recurrentConstraint),n.biasConstraint=getConstraint(t.biasConstraint),n.dropout=min$1([1,max$1([0,null==t.dropout?0:t.dropout])]),n.recurrentDropout=min$1([1,max$1([0,null==t.recurrentDropout?0:t.recurrentDropout])]),n.implementation=t.implementation,n.stateSize=n.units,n.dropoutMask=null,n.recurrentDropoutMask=null,n}return __extends(t,e),t.prototype.build=function(e){var t=(e=getExactlyOneShape(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(2!==(e=e).length)throw new ValueError("GRUCell expects 2 input Tensors (inputs, h, c), got "+e.length+".");var r=null!=t.training&&t.training,i=e[1];e=e[0],0<n.dropout&&n.dropout<1&&null==n.dropoutMask&&(n.dropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(e)},n.dropout,r,3)),0<n.recurrentDropout&&n.recurrentDropout<1&&null==n.recurrentDropoutMask&&(n.recurrentDropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(i)},n.recurrentDropout,r,3));var a,o,s,l=n.dropoutMask,u=n.recurrentDropoutMask;0<n.dropout&&n.dropout<1&&(e=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,l[0]));var c=dot(e,n.kernel.read());n.useBias&&(c=biasAdd(c,n.bias.read())),0<n.recurrentDropout&&n.recurrentDropout<1&&(i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(i,u[0]));var p=n.recurrentKernel.read(),h=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"])(p,[2*n.units,n.units],p.rank-1),d=h[0],f=h[1],g=dot(i,d),m=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"])(c,3,c.rank-1),y=m[0],v=m[1],b=m[2],w=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"])(g,2,g.rank-1),z=w[0],S=w[1];a=n.recurrentActivation.apply(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(y,z)),o=n.recurrentActivation.apply(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(v,S));var I=dot(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(o,i),f);s=n.activation.apply(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(b,I));var A=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(a,i),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(1,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"])(a)),s));return[A,A]})},t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="GRUCell",t}(RNNCell);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GRUCell);var GRU=function(e){function t(t){return 0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new GRUCell(t),e.call(this,t)||this}return __extends(t,e),t.prototype.call=function(t,n){var r=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){null!=r.cell.dropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.dropoutMask),r.cell.dropoutMask=null),null!=r.cell.recurrentDropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.recurrentDropoutMask),r.cell.recurrentDropoutMask=null);var i=null==n?null:n.mask,a=null==n?null:n.training,o=null==n?null:n.initialState;return e.prototype.call.call(r,t,{mask:i,training:a,initialState:o})})},Object.defineProperty(t.prototype,"units",{get:function(){return this.cell.units},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"activation",{get:function(){return this.cell.activation},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentActivation",{get:function(){return this.cell.recurrentActivation},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"useBias",{get:function(){return this.cell.useBias},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelInitializer",{get:function(){return this.cell.kernelInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentInitializer",{get:function(){return this.cell.recurrentInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasInitializer",{get:function(){return this.cell.biasInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelRegularizer",{get:function(){return this.cell.kernelRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentRegularizer",{get:function(){return this.cell.recurrentRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasRegularizer",{get:function(){return this.cell.biasRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelConstraint",{get:function(){return this.cell.kernelConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentConstraint",{get:function(){return this.cell.recurrentConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasConstraint",{get:function(){return this.cell.biasConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"dropout",{get:function(){return this.cell.dropout},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentDropout",{get:function(){return this.cell.recurrentDropout},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"implementation",{get:function(){return this.cell.implementation},enumerable:!0,configurable:!0}),t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},n=e.prototype.getConfig.call(this);return delete n.cell,Object.assign(t,n),t},t.fromConfig=function(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)},t.className="GRU",t}(RNN);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GRU);var LSTMCell=function(e){function t(t){var n=e.call(this,t)||this;return n.DEFAULT_ACTIVATION="tanh",n.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",n.DEFAULT_KERNEL_INITIALIZER="glorotNormal",n.DEFAULT_RECURRENT_INITIALIZER="orthogonal",n.DEFAULT_BIAS_INITIALIZER="zeros",n.units=t.units,assertPositiveInteger(n.units,"units"),n.activation=getActivation(void 0===t.activation?n.DEFAULT_ACTIVATION:t.activation),n.recurrentActivation=getActivation(void 0===t.recurrentActivation?n.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),n.useBias=null==t.useBias||t.useBias,n.kernelInitializer=getInitializer(t.kernelInitializer||n.DEFAULT_KERNEL_INITIALIZER),n.recurrentInitializer=getInitializer(t.recurrentInitializer||n.DEFAULT_RECURRENT_INITIALIZER),n.biasInitializer=getInitializer(t.biasInitializer||n.DEFAULT_BIAS_INITIALIZER),n.unitForgetBias=t.unitForgetBias,n.kernelRegularizer=getRegularizer(t.kernelRegularizer),n.recurrentRegularizer=getRegularizer(t.recurrentRegularizer),n.biasRegularizer=getRegularizer(t.biasRegularizer),n.kernelConstraint=getConstraint(t.kernelConstraint),n.recurrentConstraint=getConstraint(t.recurrentConstraint),n.biasConstraint=getConstraint(t.biasConstraint),n.dropout=min$1([1,max$1([0,null==t.dropout?0:t.dropout])]),n.recurrentDropout=min$1([1,max$1([0,null==t.recurrentDropout?0:t.recurrentDropout])]),n.implementation=t.implementation,n.stateSize=[n.units,n.units],n.dropoutMask=null,n.recurrentDropoutMask=null,n}return __extends(t,e),t.prototype.build=function(e){var t,n,r=(e=getExactlyOneShape(e))[e.length-1];if(this.kernel=this.addWeight("kernel",[r,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){var i=this.biasInitializer,a=this.units;n=new((t=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return __extends(t,e),t.prototype.apply=function(e,t){var n=i.apply([a]),r=(new Ones).apply([a]),o=i.apply([2*a]);return concatAlongFirstAxis(concatAlongFirstAxis(n,r),o)},t}(Initializer)).className="CustomInit",t)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){var r=null!=t.training&&t.training;if(3!==(e=e).length)throw new ValueError("LSTMCell expects 3 input Tensors (inputs, h, c), got "+e.length+".");var i=e[1],a=e[2];e=e[0],0<n.dropout&&n.dropout<1&&null==n.dropoutMask&&(n.dropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(e)},n.dropout,r,4)),0<n.recurrentDropout&&n.recurrentDropout<1&&null==n.recurrentDropoutMask&&(n.recurrentDropoutMask=generateDropoutMask(function(){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"])(i)},n.recurrentDropout,r,4));var o,s,l,u,c=n.dropoutMask,p=n.recurrentDropoutMask;0<n.dropout&&n.dropout<1&&(e=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(e,c[0]));var h=dot(e,n.kernel.read());0<n.recurrentDropout&&n.recurrentDropout<1&&(i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(i,p[0])),h=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(h,dot(i,n.recurrentKernel.read())),n.useBias&&(h=biasAdd(h,n.bias.read()));var d=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"])(h,4,h.rank-1),f=d[0],g=d[1],m=d[2],y=d[3];o=n.recurrentActivation.apply(f),s=n.recurrentActivation.apply(g),l=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(s,a),Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(o,n.activation.apply(m))),u=n.recurrentActivation.apply(y);var v=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(u,n.activation.apply(l));return[v,v,l]})},t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.className="LSTMCell",t}(RNNCell);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LSTMCell);var LSTM=function(e){function t(t){return 0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new LSTMCell(t),e.call(this,t)||this}return __extends(t,e),t.prototype.call=function(t,n){var r=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){null!=r.cell.dropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.dropoutMask),r.cell.dropoutMask=null),null!=r.cell.recurrentDropoutMask&&(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"])(r.cell.recurrentDropoutMask),r.cell.recurrentDropoutMask=null);var i=null==n?null:n.mask,a=null==n?null:n.training,o=null==n?null:n.initialState;return e.prototype.call.call(r,t,{mask:i,training:a,initialState:o})})},Object.defineProperty(t.prototype,"units",{get:function(){return this.cell.units},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"activation",{get:function(){return this.cell.activation},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentActivation",{get:function(){return this.cell.recurrentActivation},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"useBias",{get:function(){return this.cell.useBias},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelInitializer",{get:function(){return this.cell.kernelInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentInitializer",{get:function(){return this.cell.recurrentInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasInitializer",{get:function(){return this.cell.biasInitializer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"unitForgetBias",{get:function(){return this.cell.unitForgetBias},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelRegularizer",{get:function(){return this.cell.kernelRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentRegularizer",{get:function(){return this.cell.recurrentRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasRegularizer",{get:function(){return this.cell.biasRegularizer},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"kernelConstraint",{get:function(){return this.cell.kernelConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentConstraint",{get:function(){return this.cell.recurrentConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"biasConstraint",{get:function(){return this.cell.biasConstraint},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"dropout",{get:function(){return this.cell.dropout},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"recurrentDropout",{get:function(){return this.cell.recurrentDropout},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"implementation",{get:function(){return this.cell.implementation},enumerable:!0,configurable:!0}),t.prototype.getConfig=function(){var t={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation},n=e.prototype.getConfig.call(this);return delete n.cell,Object.assign(t,n),t},t.fromConfig=function(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)},t.className="LSTM",t}(RNN);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(LSTM);var StackedRNNCells=function(e){function t(t){var n=e.call(this,t)||this;return n.cells=t.cells,n}return __extends(t,e),Object.defineProperty(t.prototype,"stateSize",{get:function(){for(var e=[],t=0,n=this.cells.slice().reverse();t<n.length;t++){var r=n[t];Array.isArray(r.stateSize)?e.push.apply(e,r.stateSize):e.push(r.stateSize)}return e},enumerable:!0,configurable:!0}),t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){for(var r=(e=e).slice(1),i=[],a=0,o=n.cells.slice().reverse();a<o.length;a++){var s=o[a];Array.isArray(s.stateSize)?i.push(r.splice(0,s.stateSize.length)):i.push(r.splice(0,1))}i.reverse();for(var l,u=[],c=0;c<n.cells.length;++c){s=n.cells[c];r=i[c],l=0===c?[e[0]].concat(r):[l[0]].concat(r),l=s.call(l,t),u.push(l.slice(1))}r=[];for(var p=0,h=u.slice().reverse();p<h.length;p++){var d=h[p];r.push.apply(r,d)}return[l[0]].concat(r)})},t.prototype.build=function(e){var t;isArrayOfShapes(e)&&(e=e[0]),e=e;for(var n=0,r=this.cells;n<r.length;n++){var i=r[n];i.build(e),t=Array.isArray(i.stateSize)?i.stateSize[0]:i.stateSize,e=[e[0],t]}this.built=!0},t.prototype.getConfig=function(){for(var t=[],n=0,r=this.cells;n<r.length;n++){var i=r[n];t.push({className:this.getClassName(),config:i.getConfig()})}var a={cells:t},o=e.prototype.getConfig.call(this);return Object.assign(a,o),a},t.fromConfig=function(e,t,n){void 0===n&&(n={});for(var r=[],i=0,a=t.cells;i<a.length;i++){var o=a[i];r.push(deserialize(o,n))}return new e({cells:r})},Object.defineProperty(t.prototype,"trainableWeights",{get:function(){if(!this.trainable)return[];for(var e=[],t=0,n=this.cells;t<n.length;t++){var r=n[t];e.push.apply(e,r.trainableWeights)}return e},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){for(var e=[],t=0,n=this.cells;t<n.length;t++){var r=n[t];e.push.apply(e,r.nonTrainableWeights)}if(!this.trainable){for(var i=[],a=0,o=this.cells;a<o.length;a++){r=o[a];i.push.apply(i,r.trainableWeights)}return i.concat(e)}return e},enumerable:!0,configurable:!0}),t.prototype.getWeights=function(){for(var e=[],t=0,n=this.cells;t<n.length;t++){var r=n[t];e.push.apply(e,r.weights)}return batchGetValue(e)},t.prototype.setWeights=function(e){for(var t=[],n=0,r=this.cells;n<r.length;n++)for(var i=r[n],a=i.weights.length,o=e.splice(a),s=0;s<i.weights.length;++s)t.push([i.weights[s],o[s]]);batchSetValue(t)},t.className="StackedRNNCells",t}(RNNCell);function generateDropoutMask(e,t,n,r){function i(){return dropout(e(),t)}if(void 0===n&&(n=null),void 0===r&&(r=1),r>1){for(var a=[],o=0;o<r;o++)a.push(inTrainPhase(i,e,n));return a.map(function(e){return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(e.clone())})}return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"])(inTrainPhase(i,e,n).clone())}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(StackedRNNCells);var Wrapper=function(e){function t(t){var n=e.call(this,t)||this;return n.layer=t.layer,n}return __extends(t,e),t.prototype.build=function(e){this.built=!0},Object.defineProperty(t.prototype,"trainable",{get:function(){return null!=this.layer&&this.layer.trainable},set:function(e){null!=this.layer&&(this.layer.trainable=e)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"trainableWeights",{get:function(){return this.layer.trainableWeights},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){return this.layer.nonTrainableWeights},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"updates",{get:function(){return this.layer._updates},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"losses",{get:function(){return this.layer.losses},enumerable:!0,configurable:!0}),t.prototype.getWeights=function(){return this.layer.getWeights()},t.prototype.setWeights=function(e){this.layer.setWeights(e)},t.prototype.getConfig=function(){var t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.prototype.setFastWeightInitDuringBuild=function(t){e.prototype.setFastWeightInitDuringBuild.call(this,t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)},t.fromConfig=function(e,t,n){void 0===n&&(n={});var r=deserialize(t.layer,n);delete t.layer;var i={layer:r};return Object.assign(i,t),new e(i)},t}(Layer),TimeDistributed=function(e){function t(t){var n=e.call(this,t)||this;return n.supportsMasking=!0,n}return __extends(t,e),t.prototype.build=function(t){if((t=getExactlyOneShape(t)).length<3)throw new ValueError("TimeDistributed layer expects an input shape >= 3D, but received input shape "+JSON.stringify(t));this.inputSpec=[{shape:t}];var n=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),e.prototype.build.call(this,t)},t.prototype.computeOutputShape=function(e){var t=[(e=getExactlyOneShape(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){return rnn(function(e,r){return[getExactlyOneTensor(n.layer.call(e,t)),[]]},e=getExactlyOneTensor(e),[],!1,null,null,!1,!0)[1]})},t.className="TimeDistributed",t}(Wrapper);function checkBidirectionalMergeMode(e){checkStringTypeUnionValue(VALID_BIDIRECTIONAL_MERGE_MODES,"BidirectionalMergeMode",e)}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(TimeDistributed);var DEFAULT_BIDIRECTIONAL_MERGE_MODE="concat",Bidirectional=function(e){function t(t){var n=e.call(this,t)||this,r=t.layer.getConfig(),i={};i.className=t.layer.getClassName(),i.config=r,n.forwardLayer=deserialize(i),r.goBackwards=!0!==r.goBackwards;var a={};if(a.className=t.layer.getClassName(),a.config=r,n.backwardLayer=deserialize(a),n.forwardLayer.name="forward_"+n.forwardLayer.name,n.backwardLayer.name="backward_"+n.backwardLayer.name,n.mergeMode=void 0===t.mergeMode?DEFAULT_BIDIRECTIONAL_MERGE_MODE:t.mergeMode,checkBidirectionalMergeMode(n.mergeMode),t.weights)throw new NotImplementedError("weights support is not implemented for Bidirectional layer yet.");return n._stateful=t.layer.stateful,n.returnSequences=t.layer.returnSequences,n.returnState=t.layer.returnState,n.supportsMasking=!0,n._trainable=!0,n.inputSpec=t.layer.inputSpec,n.numConstants=null,n}return __extends(t,e),Object.defineProperty(t.prototype,"trainable",{get:function(){return this._trainable},set:function(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)},enumerable:!0,configurable:!0}),t.prototype.getWeights=function(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())},t.prototype.setWeights=function(e){var t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))},t.prototype.computeOutputShape=function(e){var t,n,r,i=this.forwardLayer.computeOutputShape(e);return Array.isArray(i)&&Array.isArray(i[0])||(i=[i]),i=i,this.returnState?(r=i.slice(1),t=i[0]):t=i[0],t=t,"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):singletonOrArray(n)},t.prototype.apply=function(t,n){var r=null==n?null:n.initialState,i=null==n?null:n.constants;null==n&&(n={});var a=standardizeArgs(t,r,i,this.numConstants);if(t=a.inputs,r=a.initialState,i=a.constants,Array.isArray(t)&&(r=t.slice(1),t=t[0]),(null==r||0===r.length)&&null==i)return e.prototype.apply.call(this,t,n);var o=[],s=[];if(null!=r){var l=r.length;if(l%2>0)throw new ValueError("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=r,o.push.apply(o,r);var u=r.map(function(e){return new InputSpec({shape:e.shape})});this.forwardLayer.stateSpec=u.slice(0,l/2),this.backwardLayer.stateSpec=u.slice(l/2),s.push.apply(s,u)}if(null!=i)throw new NotImplementedError("Support for constants in Bidirectional layers is not implemented yet.");for(var c=o[0]instanceof SymbolicTensor,p=0,h=o;p<h.length;p++){if(h[p]instanceof SymbolicTensor!==c)throw new ValueError("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors")}if(c){var d=[t].concat(o),f=this.inputSpec.concat(s),g=this.inputSpec;this.inputSpec=f;var m=e.prototype.apply.call(this,d,n);return this.inputSpec=g,m}return e.prototype.apply.call(this,t,n)},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(null!=t.mask)throw new NotImplementedError("The support for masking is not implemented for Bidirectional layers yet.");var r,i,a,o,s=t.initialState;if(null==s)r=n.forwardLayer.call(e,t),i=n.backwardLayer.call(e,t);else{var l=s.slice(0,s.length/2),u=s.slice(s.length/2);r=n.forwardLayer.call(e,Object.assign(t,{initialState:l})),i=n.backwardLayer.call(e,Object.assign(t,{initialState:u}))}return n.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),n.returnSequences&&(i=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse"])(i,1)),"concat"===n.mergeMode?o=concatenate([r,i]):"sum"===n.mergeMode?o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(r,i):"ave"===n.mergeMode?o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(.5,Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"])(r,i)):"mul"===n.mergeMode?o=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"])(r,i):null==n.mergeMode&&(o=[r,i]),n.returnState?null==n.mergeMode?o.concat(a):[o].concat(a):o})},t.prototype.resetStates=function(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()},t.prototype.build=function(e){var t=this;nameScope(this.forwardLayer.name,function(){t.forwardLayer.build(e)}),nameScope(this.backwardLayer.name,function(){t.backwardLayer.build(e)}),this.built=!0},Object.defineProperty(t.prototype,"trainableWeights",{get:function(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"nonTrainableWeights",{get:function(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)},enumerable:!0,configurable:!0}),t.prototype.setFastWeightInitDuringBuild=function(t){e.prototype.setFastWeightInitDuringBuild.call(this,t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)},t.prototype.getConfig=function(){var t={mergeMode:this.mergeMode},n=e.prototype.getConfig.call(this);return Object.assign(t,n),t},t.fromConfig=function(e,t){var n=deserialize(t.layer);if(delete t.layer,null!=t.numConstants)throw new NotImplementedError("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");var r=t;return r.layer=n,new e(r)},t.className="Bidirectional",t}(Wrapper);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(Bidirectional);var GaussianNoise=function(e){function t(t){var n=e.call(this,t)||this;return n.supportsMasking=!0,n.stddev=t.stddev,n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this),n={stddev:this.stddev};return Object.assign(n,t),n},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e);return inTrainPhase(function(){return randomNormal$1(r.shape,0,n.stddev).add(r)},function(){return r},t.training||!1)})},t.className="GaussianNoise",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GaussianNoise);var GaussianDropout=function(e){function t(t){var n=e.call(this,t)||this;return n.supportsMasking=!0,n.rate=t.rate,n}return __extends(t,e),t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this),n={rate:this.rate};return Object.assign(n,t),n},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){n.invokeCallHook(e,t);var r=getExactlyOneTensor(e);if(n.rate>0&&n.rate<1){return inTrainPhase(function(){var e=Math.sqrt(n.rate/(1-n.rate));return dot(r,randomNormal$1(r.shape,1,e))},function(){return r},t.training||!1)}return r})},t.className="GaussianDropout",t}(Layer);_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(GaussianDropout);var AlphaDropout=function(e){function t(t){var n=e.call(this,t)||this;return n.supportsMasking=!0,n.rate=t.rate,n.noiseShape=t.noiseShape,n}return __extends(t,e),t.prototype._getNoiseShape=function(e){return this.noiseShape||getExactlyOneTensor(e).shape},t.prototype.computeOutputShape=function(e){return e},t.prototype.getConfig=function(){var t=e.prototype.getConfig.call(this),n={rate:this.rate};return Object.assign(n,t),n},t.prototype.call=function(e,t){var n=this;return Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"])(function(){if(n.rate<1&&n.rate>0){var r=n._getNoiseShape(e);return inTrainPhase(function(){var t=getExactlyOneTensor(e),i=-1.7580993408473766,a=Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greaterEqual"])(Object(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"])(r),n.rate);a=cast$1(a,"float32");var o=Math.pow((1-n.rate)*(1+n.rate*Math.pow(i,2)),-.5),s=-o*i*n.rate;return dot(t,a).add(a.add(-1).mul(i)).mul(o).add(s)},function(){return getExactlyOneTensor(e)},t.training||!1)}return e})},t.className="AlphaDropout",t}(Layer);function inputLayer(e){return new InputLayer(e)}function elu$2(e){return new ELU(e)}function reLU(e){return new ReLU(e)}function leakyReLU(e){return new LeakyReLU(e)}function prelu$1(e){return new PReLU(e)}function softmax$1(e){return new Softmax$1(e)}function thresholdedReLU(e){return new ThresholdedReLU(e)}function conv1d$2(e){return new Conv1D(e)}function conv2d$2(e){return new Conv2D(e)}function conv2dTranspose$1(e){return new Conv2DTranspose(e)}function conv3d$2(e){return new Conv3D(e)}function separableConv2d$1(e){return new SeparableConv2D(e)}function cropping2D(e){return new Cropping2D(e)}function upSampling2d(e){return new UpSampling2D(e)}function depthwiseConv2d$2(e){return new DepthwiseConv2D(e)}function activation(e){return new Activation$1(e)}function dense(e){return new Dense(e)}function dropout$1(e){return new Dropout(e)}function flatten$1(e){return new Flatten(e)}function repeatVector(e){return new RepeatVector(e)}function reshape(e){return new Reshape(e)}function permute(e){return new Permute(e)}function embedding(e){return new Embedding(e)}function add$2(e){return new Add(e)}function average$1(e){return new Average(e)}function concatenate$2(e){return new Concatenate(e)}function maximum$2(e){return new Maximum(e)}function minimum$2(e){return new Minimum(e)}function multiply$1(e){return new Multiply(e)}function dot$1(e){return new Dot(e)}function batchNormalization$1(e){return new BatchNormalization(e)}function zeroPadding2d(e){return new ZeroPadding2D(e)}function averagePooling1d(e){return new AveragePooling1D(e)}function avgPool1d(e){return averagePooling1d(e)}function avgPooling1d(e){return averagePooling1d(e)}function averagePooling2d(e){return new AveragePooling2D(e)}function avgPool2d(e){return averagePooling2d(e)}function avgPooling2d(e){return averagePooling2d(e)}function globalAveragePooling1d(e){return new GlobalAveragePooling1D(e)}function globalAveragePooling2d(e){return new GlobalAveragePooling2D(e)}function globalMaxPooling1d(e){return new GlobalMaxPooling1D(e)}function globalMaxPooling2d(e){return new GlobalMaxPooling2D(e)}function maxPooling1d(e){return new MaxPooling1D(e)}function maxPooling2d(e){return new MaxPooling2D(e)}function gru(e){return new GRU(e)}function gruCell(e){return new GRUCell(e)}function lstm(e){return new LSTM(e)}function lstmCell(e){return new LSTMCell(e)}function simpleRNN(e){return new SimpleRNN(e)}function simpleRNNCell(e){return new SimpleRNNCell(e)}function rnn$1(e){return new RNN(e)}function stackedRNNCells(e){return new StackedRNNCells(e)}function bidirectional(e){return new Bidirectional(e)}function timeDistributed(e){return new TimeDistributed(e)}_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"].registerClass(AlphaDropout);var globalMaxPool1d=globalMaxPooling1d,globalMaxPool2d=globalMaxPooling2d,maxPool1d=maxPooling1d,maxPool2d=maxPooling2d;function gaussianNoise(e){return new GaussianNoise(e)}function gaussianDropout(e){return new GaussianDropout(e)}function alphaDropout(e){return new AlphaDropout(e)}function masking(e){return new Masking(e)}var exports_layers=Object.freeze({inputLayer:inputLayer,elu:elu$2,reLU:reLU,leakyReLU:leakyReLU,prelu:prelu$1,softmax:softmax$1,thresholdedReLU:thresholdedReLU,conv1d:conv1d$2,conv2d:conv2d$2,conv2dTranspose:conv2dTranspose$1,conv3d:conv3d$2,separableConv2d:separableConv2d$1,cropping2D:cropping2D,upSampling2d:upSampling2d,depthwiseConv2d:depthwiseConv2d$2,activation:activation,dense:dense,dropout:dropout$1,flatten:flatten$1,repeatVector:repeatVector,reshape:reshape,permute:permute,embedding:embedding,add:add$2,average:average$1,concatenate:concatenate$2,maximum:maximum$2,minimum:minimum$2,multiply:multiply$1,dot:dot$1,batchNormalization:batchNormalization$1,zeroPadding2d:zeroPadding2d,averagePooling1d:averagePooling1d,avgPool1d:avgPool1d,avgPooling1d:avgPooling1d,averagePooling2d:averagePooling2d,avgPool2d:avgPool2d,avgPooling2d:avgPooling2d,globalAveragePooling1d:globalAveragePooling1d,globalAveragePooling2d:globalAveragePooling2d,globalMaxPooling1d:globalMaxPooling1d,globalMaxPooling2d:globalMaxPooling2d,maxPooling1d:maxPooling1d,maxPooling2d:maxPooling2d,gru:gru,gruCell:gruCell,lstm:lstm,lstmCell:lstmCell,simpleRNN:simpleRNN,simpleRNNCell:simpleRNNCell,rnn:rnn$1,stackedRNNCells:stackedRNNCells,bidirectional:bidirectional,timeDistributed:timeDistributed,globalMaxPool1d:globalMaxPool1d,globalMaxPool2d:globalMaxPool2d,maxPool1d:maxPool1d,maxPool2d:maxPool2d,Layer:Layer,RNN:RNN,RNNCell:RNNCell,input:input,gaussianNoise:gaussianNoise,gaussianDropout:gaussianDropout,alphaDropout:alphaDropout,masking:masking});function binaryAccuracy$1(e,t){return binaryAccuracy(e,t)}function binaryCrossentropy$2(e,t){return binaryCrossentropy$1(e,t)}function sparseCategoricalAccuracy$1(e,t){return sparseCategoricalAccuracy(e,t)}function categoricalAccuracy$1(e,t){return categoricalAccuracy(e,t)}function categoricalCrossentropy$2(e,t){return categoricalCrossentropy$1(e,t)}function precision$1(e,t){return precision(e,t)}function recall$1(e,t){return recall(e,t)}function cosineProximity$1(e,t){return cosineProximity(e,t)}function meanAbsoluteError$1(e,t){return meanAbsoluteError(e,t)}function meanAbsolutePercentageError$1(e,t){return meanAbsolutePercentageError(e,t)}function MAPE$2(e,t){return meanAbsolutePercentageError(e,t)}function mape$2(e,t){return meanAbsolutePercentageError(e,t)}function meanSquaredError$1(e,t){return meanSquaredError(e,t)}function MSE$2(e,t){return meanSquaredError(e,t)}function mse$2(e,t){return meanSquaredError(e,t)}var exports_metrics=Object.freeze({binaryAccuracy:binaryAccuracy$1,binaryCrossentropy:binaryCrossentropy$2,sparseCategoricalAccuracy:sparseCategoricalAccuracy$1,categoricalAccuracy:categoricalAccuracy$1,categoricalCrossentropy:categoricalCrossentropy$2,precision:precision$1,recall:recall$1,cosineProximity:cosineProximity$1,meanAbsoluteError:meanAbsoluteError$1,meanAbsolutePercentageError:meanAbsolutePercentageError$1,MAPE:MAPE$2,mape:mape$2,meanSquaredError:meanSquaredError$1,MSE:MSE$2,mse:mse$2}),exports_models=Object.freeze({modelFromJSON:modelFromJSON});function l1l2(e){return new L1L2(e)}function l1$1(e){return l1(e)}function l2$1(e){return l2(e)}var exports_regularizers=Object.freeze({l1l2:l1l2,l1:l1$1,l2:l2$1}),Callback=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.model=null,t}return __extends(t,e),t.prototype.setModel=function(e){if(!(e instanceof LayersModel))throw new Error("model must be a LayersModel, not some other Container");this.model=e},t}(BaseCallback);function less(e,t){return e<t}function greater$1(e,t){return e>t}var EarlyStopping=function(e){function t(t){var n=e.call(this)||this;if(null==t&&(t={}),t.restoreBestWeights)throw new NotImplementedError("restoreBestWeights = True is not implemented in EarlyStopping yet.");return n.monitor=t.monitor||"val_loss",n.minDelta=Math.abs(t.minDelta||0),n.patience=t.patience||0,n.verbose=t.verbose||0,n.mode=t.mode||"auto",n.baseline=t.baseline,-1===["auto","min","max"].indexOf(n.mode)&&(console.warn("EarlyStopping mode '"+n.mode+"' is invalid. Falling back to mode 'auto'."),n.mode="auto"),"min"===n.mode?n.monitorFunc=less:"max"===n.mode?n.monitorFunc=greater$1:-1!==n.monitor.indexOf("acc")?n.monitorFunc=greater$1:n.monitorFunc=less,n.monitorFunc===less&&(n.minDelta*=-1),n}return __extends(t,e),t.prototype.onTrainBegin=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===less?1/0:-1/0,[2]})})},t.prototype.onEpochEnd=function(e,t){return __awaiter(this,void 0,void 0,function(){var n;return __generator(this,function(r){switch(r.label){case 0:return[4,resolveScalarsInLogs(t)];case 1:return r.sent(),null==(n=this.getMonitorValue(t))?[2]:(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)),[2])}})})},t.prototype.onTrainEnd=function(e){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(e){return this.stoppedEpoch>0&&this.verbose&&console.log("Epoch "+this.stoppedEpoch+": early stopping."),[2]})})},t.prototype.getMonitorValue=function(e){null==e&&(e={});var t=e[this.monitor];return null==t&&console.warn("Metric for EarlyStopping "+this.monitor+" is not available. Available metrics are: "+Object.keys(e)),t},t}(Callback);function earlyStopping(e){return new EarlyStopping(e)}var callbacks={earlyStopping:earlyStopping};
//# sourceMappingURL=tf-layers.esm.js.map


/***/ }),

/***/ "./node_modules/@tensorflow/tfjs/dist/tf.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs/dist/tf.esm.js ***!
  \******************************************************/
/*! exports provided: data, version, AdadeltaOptimizer, AdagradOptimizer, AdamOptimizer, AdamaxOptimizer, DataStorage, ENV, Environment, KernelBackend, MomentumOptimizer, Optimizer, RMSPropOptimizer, Rank, Reduction, SGDOptimizer, Tensor, TensorBuffer, Variable, abs, acos, acosh, add, addN, addStrict, all, any, argMax, argMin, asin, asinh, atan, atan2, atanh, avgPool, backend, basicLSTMCell, batchNorm, batchNorm2d, batchNorm3d, batchNorm4d, batchNormalization, batchNormalization2d, batchNormalization3d, batchNormalization4d, batchToSpaceND, browser, buffer, cast, ceil, clipByValue, clone, complex, concat, concat1d, concat2d, concat3d, concat4d, conv1d, conv2d, conv2dDerFilter, conv2dTranspose, conv3d, cos, cosh, cumsum, customGrad, deprecationWarn, depthToSpace, depthwiseConv2d, disableDeprecationWarnings, dispose, disposeVariables, div, divStrict, dot, dropout, elu, enableDebugMode, enableProdMode, environment, equal, equalStrict, erf, exp, expandDims, expm1, eye, fft, fill, findBackend, findBackendFactory, floor, floorDiv, fused, gather, gatherND, getBackend, grad, grads, greater, greaterEqual, greaterEqualStrict, greaterStrict, hammingWindow, hannWindow, ifft, imag, image, io, irfft, isFinite, isInf, isNaN, keep, leakyRelu, less, lessEqual, lessEqualStrict, lessStrict, linalg, linspace, localResponseNormalization, log, log1p, logSigmoid, logSoftmax, logSumExp, logicalAnd, logicalNot, logicalOr, logicalXor, losses, matMul, math, max, maxPool, maximum, maximumStrict, mean, memory, min, minimum, minimumStrict, mod, modStrict, moments, movingAverage, mul, mulStrict, multiRNNCell, multinomial, neg, nextFrame, norm, notEqual, notEqualStrict, oneHot, ones, onesLike, op, outerProduct, pad, pad1d, pad2d, pad3d, pad4d, pool, pow, powStrict, prelu, print, prod, profile, rand, randomNormal, randomUniform, range, ready, real, reciprocal, registerBackend, relu, removeBackend, reshape, reverse, reverse1d, reverse2d, reverse3d, reverse4d, rfft, round, rsqrt, scalar, scatterND, selu, separableConv2d, serialization, setBackend, setdiff1dAsync, sigmoid, sign, sin, sinh, slice, slice1d, slice2d, slice3d, slice4d, softmax, softplus, spaceToBatchND, sparseToDense, spectral, split, sqrt, square, squaredDifference, squaredDifferenceStrict, squeeze, stack, step, stridedSlice, sub, subStrict, sum, tan, tanh, tensor, tensor1d, tensor2d, tensor3d, tensor4d, tensor5d, tensor6d, tensor_util, test_util, tidy, tile, time, topk, train, transpose, truncatedNormal, unsortedSegmentSum, unstack, util, valueAndGrad, valueAndGrads, variable, variableGrads, version_core, webgl, where, whereAsync, zeros, zerosLike, constraints, initializers, layers, metrics, models, regularizers, CallbackList, CustomCallback, History, Callback, callbacks, EarlyStopping, InputSpec, SymbolicTensor, LayersModel, input, loadLayersModel, model, registerCallbackConstructor, sequential, RNN, Sequential, LayerVariable, version_layers, GraphModel, loadGraphModel, version_converter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version$1; });
/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AdadeltaOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["AdadeltaOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AdagradOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["AdagradOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AdamOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["AdamOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AdamaxOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["AdamaxOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataStorage", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["DataStorage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ENV", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ENV"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Environment", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Environment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KernelBackend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["KernelBackend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MomentumOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["MomentumOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Optimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Optimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RMSPropOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["RMSPropOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Rank", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Rank"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Reduction", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Reduction"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SGDOptimizer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["SGDOptimizer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tensor", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Tensor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TensorBuffer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["TensorBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Variable", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["Variable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "abs", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["abs"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["acos"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "acosh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["acosh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "add", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["add"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addN", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["addN"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["addStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "all", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["all"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "any", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["any"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "argMax", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMax"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "argMin", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["argMin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["asin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "asinh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["asinh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atan"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "atan2", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atan2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "atanh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["atanh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "avgPool", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["avgPool"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "backend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["backend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "basicLSTMCell", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["basicLSTMCell"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNorm", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNorm2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNorm3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNorm4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNorm4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNormalization", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNormalization"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNormalization2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNormalization2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNormalization3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNormalization3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchNormalization4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchNormalization4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batchToSpaceND", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["batchToSpaceND"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "browser", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["browser"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["buffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cast", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cast"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ceil"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clipByValue", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clipByValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["clone"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "complex", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["complex"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["concat4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "conv1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "conv2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "conv2dDerFilter", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2dDerFilter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "conv2dTranspose", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv2dTranspose"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "conv3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["conv3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cos"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cosh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cosh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cumsum", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["cumsum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "customGrad", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["customGrad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "deprecationWarn", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["deprecationWarn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "depthToSpace", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthToSpace"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "depthwiseConv2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["depthwiseConv2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "disableDeprecationWarnings", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["disableDeprecationWarnings"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dispose", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dispose"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "disposeVariables", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["disposeVariables"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "div", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["div"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "divStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["divStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dot"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dropout", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["dropout"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "elu", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["elu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "enableDebugMode", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["enableDebugMode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "enableProdMode", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["enableProdMode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "environment", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["environment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "equal", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "equalStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["equalStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "erf", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["erf"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["exp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "expandDims", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expandDims"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "expm1", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["expm1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "eye", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["eye"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fft", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fft"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fill", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fill"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findBackend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["findBackend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findBackendFactory", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["findBackendFactory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["floor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "floorDiv", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["floorDiv"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fused", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["fused"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gather", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["gather"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gatherND", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["gatherND"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getBackend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["getBackend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "grad", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["grad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "grads", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["grads"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "greater", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greater"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "greaterEqual", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greaterEqual"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "greaterEqualStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greaterEqualStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "greaterStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["greaterStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hammingWindow", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["hammingWindow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hannWindow", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["hannWindow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ifft", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ifft"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "imag", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["imag"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "image", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["image"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "io", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["io"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "irfft", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["irfft"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isFinite", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["isFinite"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isInf", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["isInf"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isNaN", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["isNaN"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keep", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["keep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "leakyRelu", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["leakyRelu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "less", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["less"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lessEqual", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["lessEqual"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lessEqualStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["lessEqualStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lessStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["lessStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "linalg", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["linalg"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "linspace", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["linspace"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "localResponseNormalization", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["localResponseNormalization"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "log", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "log1p", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["log1p"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logSigmoid", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logSigmoid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logSoftmax", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logSoftmax"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logSumExp", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logSumExp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logicalAnd", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalAnd"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logicalNot", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalNot"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logicalOr", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalOr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logicalXor", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["logicalXor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "losses", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["losses"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matMul", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["matMul"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "math", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["math"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "max", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["max"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "maxPool", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maxPool"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "maximum", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "maximumStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["maximumStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mean", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mean"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "memory", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["memory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "min", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["min"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "minimum", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["minimum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "minimumStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["minimumStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mod", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mod"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "modStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["modStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "moments", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["moments"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "movingAverage", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["movingAverage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mul"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mulStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["mulStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "multiRNNCell", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["multiRNNCell"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "multinomial", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["multinomial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "neg", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["neg"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nextFrame", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["nextFrame"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "norm", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["norm"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "notEqual", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["notEqual"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "notEqualStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["notEqualStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "oneHot", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["oneHot"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ones", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ones"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onesLike", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["onesLike"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "op", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["op"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "outerProduct", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["outerProduct"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pad", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pad1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pad2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pad3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pad4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pad4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pool", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pool"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["pow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "powStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["powStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "prelu", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["prelu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "print", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["print"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "prod", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["prod"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "profile", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["profile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rand", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["rand"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomNormal", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomNormal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomUniform", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["randomUniform"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "range", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["range"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ready", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["ready"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "real", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["real"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reciprocal", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reciprocal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerBackend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["registerBackend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "relu", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["relu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "removeBackend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["removeBackend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reshape", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reshape"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reverse4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["reverse4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rfft", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["rfft"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "round", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["round"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rsqrt", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["rsqrt"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scalar", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scalar"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scatterND", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["scatterND"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selu", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["selu"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "separableConv2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["separableConv2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "serialization", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["serialization"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setBackend", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["setBackend"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setdiff1dAsync", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["setdiff1dAsync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sigmoid", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sigmoid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sign", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sign"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sinh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sinh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "slice4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["slice4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "softmax", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softmax"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "softplus", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["softplus"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "spaceToBatchND", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["spaceToBatchND"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sparseToDense", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sparseToDense"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "spectral", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["spectral"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "split", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["split"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sqrt"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "square", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["square"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "squaredDifference", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squaredDifference"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "squaredDifferenceStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squaredDifferenceStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "squeeze", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["squeeze"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stack", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "step", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["step"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stridedSlice", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["stridedSlice"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sub"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "subStrict", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["subStrict"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["sum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tan"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tanh", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tanh"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor1d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor1d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor2d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor2d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor3d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor3d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor4d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor4d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor5d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor5d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor6d", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor6d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tensor_util", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tensor_util"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "test_util", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["test_util"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tidy", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tidy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tile", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["tile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "time", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["time"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "topk", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["topk"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "train", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["train"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["transpose"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "truncatedNormal", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["truncatedNormal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unsortedSegmentSum", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unsortedSegmentSum"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstack", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["unstack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "util", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["util"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "valueAndGrad", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["valueAndGrad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "valueAndGrads", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["valueAndGrads"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "variable", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["variable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "variableGrads", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["variableGrads"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version_core", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["version_core"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "webgl", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["webgl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "where", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["where"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "whereAsync", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["whereAsync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zeros", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zeros"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zerosLike", function() { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["zerosLike"]; });

/* harmony import */ var _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-layers */ "./node_modules/@tensorflow/tfjs-layers/dist/tf-layers.esm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "constraints", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["constraints"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "initializers", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["initializers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "layers", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["layers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "metrics", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["metrics"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "models", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["models"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "regularizers", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["regularizers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CallbackList", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["CallbackList"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CustomCallback", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["CustomCallback"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "History", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["History"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Callback", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["Callback"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "callbacks", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["callbacks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EarlyStopping", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["EarlyStopping"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InputSpec", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["InputSpec"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SymbolicTensor", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["SymbolicTensor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayersModel", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["LayersModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "input", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["input"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadLayersModel", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["loadLayersModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "model", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["model"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerCallbackConstructor", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["registerCallbackConstructor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sequential", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["sequential"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RNN", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["RNN"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Sequential", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["Sequential"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayerVariable", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["LayerVariable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version_layers", function() { return _tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["version_layers"]; });

/* harmony import */ var _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tensorflow/tfjs-converter */ "./node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GraphModel", function() { return _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_2__["GraphModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadGraphModel", function() { return _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_2__["loadGraphModel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version_converter", function() { return _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_2__["version_converter"]; });

/* harmony import */ var _tensorflow_tfjs_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tensorflow/tfjs-data */ "./node_modules/@tensorflow/tfjs-data/dist/tf-data.esm.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "data", function() { return _tensorflow_tfjs_data__WEBPACK_IMPORTED_MODULE_3__; });
// @tensorflow/tfjs Copyright 2019 Google
var version="1.1.2",version$1={"tfjs-core":_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__["version_core"],"tfjs-data":_tensorflow_tfjs_data__WEBPACK_IMPORTED_MODULE_3__["version_data"],"tfjs-layers":_tensorflow_tfjs_layers__WEBPACK_IMPORTED_MODULE_1__["version_layers"],"tfjs-converter":_tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_2__["version_converter"],tfjs:version};
//# sourceMappingURL=tf.esm.js.map


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1.js":
/*!******************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = exports;

asn1.bignum = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");

asn1.define = __webpack_require__(/*! ./asn1/api */ "./node_modules/asn1.js/lib/asn1/api.js").define;
asn1.base = __webpack_require__(/*! ./asn1/base */ "./node_modules/asn1.js/lib/asn1/base/index.js");
asn1.constants = __webpack_require__(/*! ./asn1/constants */ "./node_modules/asn1.js/lib/asn1/constants/index.js");
asn1.decoders = __webpack_require__(/*! ./asn1/decoders */ "./node_modules/asn1.js/lib/asn1/decoders/index.js");
asn1.encoders = __webpack_require__(/*! ./asn1/encoders */ "./node_modules/asn1.js/lib/asn1/encoders/index.js");


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/api.js":
/*!**********************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/api.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = __webpack_require__(/*! ../asn1 */ "./node_modules/asn1.js/lib/asn1.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
};

Entity.prototype._createNamed = function createNamed(base) {
  var named;
  try {
    named = __webpack_require__(/*! vm */ "./node_modules/vm-browserify/index.js").runInThisContext(
      '(function ' + this.name + '(entity) {\n' +
      '  this._initNamed(entity);\n' +
      '})'
    );
  } catch (e) {
    named = function (entity) {
      this._initNamed(entity);
    };
  }
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der';
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der';
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Reporter = __webpack_require__(/*! ../base */ "./node_modules/asn1.js/lib/asn1/base/index.js").Reporter;
var Buffer = __webpack_require__(/*! buffer */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  var res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
}

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  var res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
}

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
}

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!(item instanceof EncoderBuffer))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = new Buffer(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var base = exports;

base.Reporter = __webpack_require__(/*! ./reporter */ "./node_modules/asn1.js/lib/asn1/base/reporter.js").Reporter;
base.DecoderBuffer = __webpack_require__(/*! ./buffer */ "./node_modules/asn1.js/lib/asn1/base/buffer.js").DecoderBuffer;
base.EncoderBuffer = __webpack_require__(/*! ./buffer */ "./node_modules/asn1.js/lib/asn1/base/buffer.js").EncoderBuffer;
base.Node = __webpack_require__(/*! ./node */ "./node_modules/asn1.js/lib/asn1/base/node.js");


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/node.js":
/*!****************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/node.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Reporter = __webpack_require__(/*! ../base */ "./node_modules/asn1.js/lib/asn1/base/index.js").Reporter;
var EncoderBuffer = __webpack_require__(/*! ../base */ "./node_modules/asn1.js/lib/asn1/base/index.js").EncoderBuffer;
var DecoderBuffer = __webpack_require__(/*! ../base */ "./node_modules/asn1.js/lib/asn1/base/index.js").DecoderBuffer;
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any', 'contains'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit', 'contains'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  var state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  var state = this._baseState;

  assert(state.use === null);
  state.contains = item;

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input, options) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input, options));

  var result = state['default'];
  var present = true;

  var prevKey = null;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    var start = input.offset;

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        var save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    if (options && options.track && state.tag !== null)
      options.track(input.path(), start, input.length, 'tagged');

    if (options && options.track && state.tag !== null)
      options.track(input.path(), input.offset, input.length, 'content');

    // Select proper method for tag
    if (state.any)
      result = result;
    else if (state.choice === null)
      result = this._decodeGeneric(state.tag, input, options);
    else
      result = this._decodeChoice(input, options);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    }

    // Decode contained/encoded by schema, only in bit or octet strings
    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      var data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)
          ._decode(data, options);
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null, options);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag, options);
  else if (tag === 'null_')
    return this._decodeNull(input, options);
  else if (tag === 'bool')
    return this._decodeBool(input, options);
  else if (tag === 'objDesc')
    return this._decodeStr(input, tag, options);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)
        ._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input, options);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be omitted only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  if (!node) {
    assert(
        false,
        data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else if (tag === 'objDesc')
    return this._encodeStr(data, tag);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
};


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/base/reporter.js":
/*!********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/reporter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  var state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.exitKey = function exitKey(index) {
  var state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;

  this.exitKey(index);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;

  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;

  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;

  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
};
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ReporterError);

  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/constants/der.js":
/*!********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/constants/der.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var constants = __webpack_require__(/*! ../constants */ "./node_modules/asn1.js/lib/asn1/constants/index.js");

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/constants/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/constants/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    var value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = __webpack_require__(/*! ./der */ "./node_modules/asn1.js/lib/asn1/constants/der.js");


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/decoders/der.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/decoders/der.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var asn1 = __webpack_require__(/*! ../../asn1 */ "./node_modules/asn1.js/lib/asn1.js");
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer))
    data = new base.DecoderBuffer(data, options);

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
    (decodedTag.tagStr + 'of') === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.save();
  var res = this._skipUntilEnd(
      buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    var res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len)
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
                                                    options) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    var res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;
    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'bmpstr') {
    var raw = buffer.raw();
    if (raw.length % 2 === 1)
      return buffer.error('Decoding of string type: bmpstr length mismatch');

    var str = '';
    for (var i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag === 'numstr') {
    var numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' +
                          'numstr unsupported characters');
    }
    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    var printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' +
                          'printstr unsupported characters');
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var result;
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  var first = (identifiers[0] / 40) | 0;
  var second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values) {
    var tmp = values[result.join(' ')];
    if (tmp === undefined)
      tmp = values[result.join('.')];
    if (tmp !== undefined)
      result = tmp;
  }

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num > 4)
    return buf.error('length octect is too long');

  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/decoders/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/decoders/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var decoders = exports;

decoders.der = __webpack_require__(/*! ./der */ "./node_modules/asn1.js/lib/asn1/decoders/der.js");
decoders.pem = __webpack_require__(/*! ./pem */ "./node_modules/asn1.js/lib/asn1/decoders/pem.js");


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/decoders/pem.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/decoders/pem.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Buffer = __webpack_require__(/*! buffer */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer;

var DERDecoder = __webpack_require__(/*! ./der */ "./node_modules/asn1.js/lib/asn1/decoders/der.js");

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);

  var label = options.label.toUpperCase();

  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end = -1;
  for (var i = 0; i < lines.length; i++) {
    var match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  var base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

  var input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/encoders/der.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/encoders/der.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Buffer = __webpack_require__(/*! buffer */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer;

var asn1 = __webpack_require__(/*! ../../asn1 */ "./node_modules/asn1.js/lib/asn1.js");
var base = asn1.base;

// Import DER constants
var der = asn1.constants.der;

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                              primitive,
                                                              cls,
                                                              content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  var lenOctets = 1;
  for (var i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (tag === 'bmpstr') {
    var buf = new Buffer(str.length * 2);
    for (var i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    }
    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s\.]+/g);
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  var size = 0;
  for (var i = 0; i < id.length; i++) {
    var ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  var objid = new Buffer(size);
  var offset = objid.length - 1;
  for (var i = id.length - 1; i >= 0; i--) {
    var ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    var numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = new Buffer(numArray);
  }

  if (Buffer.isBuffer(num)) {
    var size = num.length;
    if (num.length === 0)
      size++;

    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  var size = 1;
  for (var i = num; i >= 0x100; i >>= 8)
    size++;

  var out = new Array(size);
  for (var i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(new Buffer(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  var state = this._baseState;
  var i;
  if (state['default'] === null)
    return false;

  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  var res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/encoders/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/encoders/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var encoders = exports;

encoders.der = __webpack_require__(/*! ./der */ "./node_modules/asn1.js/lib/asn1/encoders/der.js");
encoders.pem = __webpack_require__(/*! ./pem */ "./node_modules/asn1.js/lib/asn1/encoders/pem.js");


/***/ }),

/***/ "./node_modules/asn1.js/lib/asn1/encoders/pem.js":
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/encoders/pem.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var DEREncoder = __webpack_require__(/*! ./der */ "./node_modules/asn1.js/lib/asn1/encoders/der.js");

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);

  var p = buf.toString('base64');
  var out = [ '-----BEGIN ' + options.label + '-----' ];
  for (var i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/bn.js/lib/bn.js":
/*!**************************************!*\
  !*** ./node_modules/bn.js/lib/bn.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = __webpack_require__(/*! buffer */ 3).Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      r.strip();
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/brorand/index.js":
/*!***************************************!*\
  !*** ./node_modules/brorand/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = __webpack_require__(/*! crypto */ 4);
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}


/***/ }),

/***/ "./node_modules/browserify-aes/aes.js":
/*!********************************************!*\
  !*** ./node_modules/browserify-aes/aes.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

function asUInt32Array (buf) {
  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)

  var len = (buf.length / 4) | 0
  var out = new Array(len)

  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4)
  }

  return out
}

function scrubVec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
}

function cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0]
  var SUB_MIX1 = SUB_MIX[1]
  var SUB_MIX2 = SUB_MIX[2]
  var SUB_MIX3 = SUB_MIX[3]

  var s0 = M[0] ^ keySchedule[0]
  var s1 = M[1] ^ keySchedule[1]
  var s2 = M[2] ^ keySchedule[2]
  var s3 = M[3] ^ keySchedule[3]
  var t0, t1, t2, t3
  var ksRow = 4

  for (var round = 1; round < nRounds; round++) {
    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }

  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  t0 = t0 >>> 0
  t1 = t1 >>> 0
  t2 = t2 >>> 0
  t3 = t3 >>> 0

  return [t0, t1, t2, t3]
}

// AES constants
var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
var G = (function () {
  // Compute double table
  var d = new Array(256)
  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1
    } else {
      d[j] = (j << 1) ^ 0x11b
    }
  }

  var SBOX = []
  var INV_SBOX = []
  var SUB_MIX = [[], [], [], []]
  var INV_SUB_MIX = [[], [], [], []]

  // Walk GF(2^8)
  var x = 0
  var xi = 0
  for (var i = 0; i < 256; ++i) {
    // Compute sbox
    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    SBOX[x] = sx
    INV_SBOX[sx] = x

    // Compute multiplication
    var x2 = d[x]
    var x4 = d[x2]
    var x8 = d[x4]

    // Compute sub bytes, mix columns tables
    var t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    SUB_MIX[3][x] = t

    // Compute inv sub bytes, inv mix columns tables
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    INV_SUB_MIX[3][sx] = t

    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }

  return {
    SBOX: SBOX,
    INV_SBOX: INV_SBOX,
    SUB_MIX: SUB_MIX,
    INV_SUB_MIX: INV_SUB_MIX
  }
})()

function AES (key) {
  this._key = asUInt32Array(key)
  this._reset()
}

AES.blockSize = 4 * 4
AES.keySize = 256 / 8
AES.prototype.blockSize = AES.blockSize
AES.prototype.keySize = AES.keySize
AES.prototype._reset = function () {
  var keyWords = this._key
  var keySize = keyWords.length
  var nRounds = keySize + 6
  var ksRows = (nRounds + 1) * 4

  var keySchedule = []
  for (var k = 0; k < keySize; k++) {
    keySchedule[k] = keyWords[k]
  }

  for (k = keySize; k < ksRows; k++) {
    var t = keySchedule[k - 1]

    if (k % keySize === 0) {
      t = (t << 8) | (t >>> 24)
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])

      t ^= RCON[(k / keySize) | 0] << 24
    } else if (keySize > 6 && k % keySize === 4) {
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])
    }

    keySchedule[k] = keySchedule[k - keySize] ^ t
  }

  var invKeySchedule = []
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)]

    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt
    } else {
      invKeySchedule[ik] =
        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^
        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^
        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]]
    }
  }

  this._nRounds = nRounds
  this._keySchedule = keySchedule
  this._invKeySchedule = invKeySchedule
}

AES.prototype.encryptBlockRaw = function (M) {
  M = asUInt32Array(M)
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)
}

AES.prototype.encryptBlock = function (M) {
  var out = this.encryptBlockRaw(M)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = asUInt32Array(M)

  // swap
  var m1 = M[1]
  M[1] = M[3]
  M[3] = m1

  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrubVec(this._keySchedule)
  scrubVec(this._invKeySchedule)
  scrubVec(this._key)
}

module.exports.AES = AES


/***/ }),

/***/ "./node_modules/browserify-aes/authCipher.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-aes/authCipher.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aes = __webpack_require__(/*! ./aes */ "./node_modules/browserify-aes/aes.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var Transform = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var GHASH = __webpack_require__(/*! ./ghash */ "./node_modules/browserify-aes/ghash.js")
var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/buffer-xor/index.js")
var incr32 = __webpack_require__(/*! ./incr32 */ "./node_modules/browserify-aes/incr32.js")

function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) out++

  var len = Math.min(a.length, b.length)
  for (var i = 0; i < len; ++i) {
    out += (a[i] ^ b[i])
  }

  return out
}

function calcIv (self, iv, ck) {
  if (iv.length === 12) {
    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])])
    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])])
  }
  var ghash = new GHASH(ck)
  var len = iv.length
  var toPad = len % 16
  ghash.update(iv)
  if (toPad) {
    toPad = 16 - toPad
    ghash.update(Buffer.alloc(toPad, 0))
  }
  ghash.update(Buffer.alloc(8, 0))
  var ivBits = len * 8
  var tail = Buffer.alloc(8)
  tail.writeUIntBE(ivBits, 0, 8)
  ghash.update(tail)
  self._finID = ghash.state
  var out = Buffer.from(self._finID)
  incr32(out)
  return out
}
function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  var h = Buffer.alloc(4, 0)

  this._cipher = new aes.AES(key)
  var ck = this._cipher.encryptBlock(h)
  this._ghash = new GHASH(ck)
  iv = calcIv(this, iv, ck)

  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  this._mode = mode

  this._authTag = null
  this._called = false
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = Buffer.alloc(rump, 0)
      this._ghash.update(rump)
    }
  }

  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}

StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')

  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')

  this._authTag = tag
  this._cipher.scrub()
}

StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')

  return this._authTag
}

StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')

  this._authTag = tag
}

StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (this._called) throw new Error('Attempting to set AAD in unsupported state')

  this._ghash.update(buf)
  this._alen += buf.length
}

module.exports = StreamCipher


/***/ }),

/***/ "./node_modules/browserify-aes/browser.js":
/*!************************************************!*\
  !*** ./node_modules/browserify-aes/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ciphers = __webpack_require__(/*! ./encrypter */ "./node_modules/browserify-aes/encrypter.js")
var deciphers = __webpack_require__(/*! ./decrypter */ "./node_modules/browserify-aes/decrypter.js")
var modes = __webpack_require__(/*! ./modes/list.json */ "./node_modules/browserify-aes/modes/list.json")

function getCiphers () {
  return Object.keys(modes)
}

exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),

/***/ "./node_modules/browserify-aes/decrypter.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/decrypter.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var AuthCipher = __webpack_require__(/*! ./authCipher */ "./node_modules/browserify-aes/authCipher.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var MODES = __webpack_require__(/*! ./modes */ "./node_modules/browserify-aes/modes/index.js")
var StreamCipher = __webpack_require__(/*! ./streamCipher */ "./node_modules/browserify-aes/streamCipher.js")
var Transform = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var aes = __webpack_require__(/*! ./aes */ "./node_modules/browserify-aes/aes.js")
var ebtk = __webpack_require__(/*! evp_bytestokey */ "./node_modules/evp_bytestokey/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")

function Decipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Decipher, Transform)

Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}

Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}

Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }

  return null
}

Splitter.prototype.flush = function () {
  if (this.cache.length) return this.cache
}

function unpad (last) {
  var padded = last[15]
  if (padded < 1 || padded > 16) {
    throw new Error('unable to decrypt data')
  }
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) return

  return last.slice(0, 16 - padded)
}

function createDecipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv, true)
  }

  return new Decipher(config.module, password, iv)
}

function createDecipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}

exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv


/***/ }),

/***/ "./node_modules/browserify-aes/encrypter.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/encrypter.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MODES = __webpack_require__(/*! ./modes */ "./node_modules/browserify-aes/modes/index.js")
var AuthCipher = __webpack_require__(/*! ./authCipher */ "./node_modules/browserify-aes/authCipher.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var StreamCipher = __webpack_require__(/*! ./streamCipher */ "./node_modules/browserify-aes/streamCipher.js")
var Transform = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var aes = __webpack_require__(/*! ./aes */ "./node_modules/browserify-aes/aes.js")
var ebtk = __webpack_require__(/*! evp_bytestokey */ "./node_modules/evp_bytestokey/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")

function Cipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Cipher, Transform)

Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []

  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }

  return Buffer.concat(out)
}

var PADDING = Buffer.alloc(16, 0x10)

Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  }

  if (!chunk.equals(PADDING)) {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}

Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}

Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = Buffer.allocUnsafe(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }

  return Buffer.concat([this.cache, padBuff])
}

function createCipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv)
  }

  return new Cipher(config.module, password, iv)
}

function createCipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher


/***/ }),

/***/ "./node_modules/browserify-aes/ghash.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-aes/ghash.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var ZEROES = Buffer.alloc(16, 0)

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}

function fromArray (out) {
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0] >>> 0, 0)
  buf.writeUInt32BE(out[1] >>> 0, 4)
  buf.writeUInt32BE(out[2] >>> 0, 8)
  buf.writeUInt32BE(out[3] >>> 0, 12)
  return buf
}

function GHASH (key) {
  this.h = key
  this.state = Buffer.alloc(16, 0)
  this.cache = Buffer.allocUnsafe(0)
}

// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vh-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsbVi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi[0] ^= Vi[0]
      Zi[1] ^= Vi[1]
      Zi[2] ^= Vi[2]
      Zi[3] ^= Vi[3]
    }

    // Store the value of LSB(V_i)
    lsbVi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsbVi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}

GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}

GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, ZEROES], 16))
  }

  this.ghash(fromArray([0, abl, 0, bl]))
  return this.state
}

module.exports = GHASH


/***/ }),

/***/ "./node_modules/browserify-aes/incr32.js":
/*!***********************************************!*\
  !*** ./node_modules/browserify-aes/incr32.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}
module.exports = incr32


/***/ }),

/***/ "./node_modules/browserify-aes/modes/cbc.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cbc.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/buffer-xor/index.js")

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/cfb.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cfb.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/buffer-xor/index.js")

function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

exports.encrypt = function (self, data, decrypt) {
  var out = Buffer.allocUnsafe(0)
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = Buffer.allocUnsafe(0)
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/cfb1.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cfb1.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}

function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = Buffer.allocUnsafe(buffer.length)
  buffer = Buffer.concat([buffer, Buffer.from([value])])

  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/cfb8.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cfb8.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam

  self._prev = Buffer.concat([
    self._prev.slice(1),
    Buffer.from([decrypt ? byteParam : out])
  ])

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/ctr.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/ctr.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/buffer-xor/index.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var incr32 = __webpack_require__(/*! ../incr32 */ "./node_modules/browserify-aes/incr32.js")

function getBlock (self) {
  var out = self._cipher.encryptBlockRaw(self._prev)
  incr32(self._prev)
  return out
}

var blockSize = 16
exports.encrypt = function (self, chunk) {
  var chunkNum = Math.ceil(chunk.length / blockSize)
  var start = self._cache.length
  self._cache = Buffer.concat([
    self._cache,
    Buffer.allocUnsafe(chunkNum * blockSize)
  ])
  for (var i = 0; i < chunkNum; i++) {
    var out = getBlock(self)
    var offset = start + i * blockSize
    self._cache.writeUInt32BE(out[0], offset + 0)
    self._cache.writeUInt32BE(out[1], offset + 4)
    self._cache.writeUInt32BE(out[2], offset + 8)
    self._cache.writeUInt32BE(out[3], offset + 12)
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/ecb.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/ecb.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}

exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}


/***/ }),

/***/ "./node_modules/browserify-aes/modes/index.js":
/*!****************************************************!*\
  !*** ./node_modules/browserify-aes/modes/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var modeModules = {
  ECB: __webpack_require__(/*! ./ecb */ "./node_modules/browserify-aes/modes/ecb.js"),
  CBC: __webpack_require__(/*! ./cbc */ "./node_modules/browserify-aes/modes/cbc.js"),
  CFB: __webpack_require__(/*! ./cfb */ "./node_modules/browserify-aes/modes/cfb.js"),
  CFB8: __webpack_require__(/*! ./cfb8 */ "./node_modules/browserify-aes/modes/cfb8.js"),
  CFB1: __webpack_require__(/*! ./cfb1 */ "./node_modules/browserify-aes/modes/cfb1.js"),
  OFB: __webpack_require__(/*! ./ofb */ "./node_modules/browserify-aes/modes/ofb.js"),
  CTR: __webpack_require__(/*! ./ctr */ "./node_modules/browserify-aes/modes/ctr.js"),
  GCM: __webpack_require__(/*! ./ctr */ "./node_modules/browserify-aes/modes/ctr.js")
}

var modes = __webpack_require__(/*! ./list.json */ "./node_modules/browserify-aes/modes/list.json")

for (var key in modes) {
  modes[key].module = modeModules[modes[key].mode]
}

module.exports = modes


/***/ }),

/***/ "./node_modules/browserify-aes/modes/list.json":
/*!*****************************************************!*\
  !*** ./node_modules/browserify-aes/modes/list.json ***!
  \*****************************************************/
/*! exports provided: aes-128-ecb, aes-192-ecb, aes-256-ecb, aes-128-cbc, aes-192-cbc, aes-256-cbc, aes128, aes192, aes256, aes-128-cfb, aes-192-cfb, aes-256-cfb, aes-128-cfb8, aes-192-cfb8, aes-256-cfb8, aes-128-cfb1, aes-192-cfb1, aes-256-cfb1, aes-128-ofb, aes-192-ofb, aes-256-ofb, aes-128-ctr, aes-192-ctr, aes-256-ctr, aes-128-gcm, aes-192-gcm, aes-256-gcm, default */
/***/ (function(module) {

module.exports = {"aes-128-ecb":{"cipher":"AES","key":128,"iv":0,"mode":"ECB","type":"block"},"aes-192-ecb":{"cipher":"AES","key":192,"iv":0,"mode":"ECB","type":"block"},"aes-256-ecb":{"cipher":"AES","key":256,"iv":0,"mode":"ECB","type":"block"},"aes-128-cbc":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes-192-cbc":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes-256-cbc":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes128":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes192":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes256":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes-128-cfb":{"cipher":"AES","key":128,"iv":16,"mode":"CFB","type":"stream"},"aes-192-cfb":{"cipher":"AES","key":192,"iv":16,"mode":"CFB","type":"stream"},"aes-256-cfb":{"cipher":"AES","key":256,"iv":16,"mode":"CFB","type":"stream"},"aes-128-cfb8":{"cipher":"AES","key":128,"iv":16,"mode":"CFB8","type":"stream"},"aes-192-cfb8":{"cipher":"AES","key":192,"iv":16,"mode":"CFB8","type":"stream"},"aes-256-cfb8":{"cipher":"AES","key":256,"iv":16,"mode":"CFB8","type":"stream"},"aes-128-cfb1":{"cipher":"AES","key":128,"iv":16,"mode":"CFB1","type":"stream"},"aes-192-cfb1":{"cipher":"AES","key":192,"iv":16,"mode":"CFB1","type":"stream"},"aes-256-cfb1":{"cipher":"AES","key":256,"iv":16,"mode":"CFB1","type":"stream"},"aes-128-ofb":{"cipher":"AES","key":128,"iv":16,"mode":"OFB","type":"stream"},"aes-192-ofb":{"cipher":"AES","key":192,"iv":16,"mode":"OFB","type":"stream"},"aes-256-ofb":{"cipher":"AES","key":256,"iv":16,"mode":"OFB","type":"stream"},"aes-128-ctr":{"cipher":"AES","key":128,"iv":16,"mode":"CTR","type":"stream"},"aes-192-ctr":{"cipher":"AES","key":192,"iv":16,"mode":"CTR","type":"stream"},"aes-256-ctr":{"cipher":"AES","key":256,"iv":16,"mode":"CTR","type":"stream"},"aes-128-gcm":{"cipher":"AES","key":128,"iv":12,"mode":"GCM","type":"auth"},"aes-192-gcm":{"cipher":"AES","key":192,"iv":12,"mode":"GCM","type":"auth"},"aes-256-gcm":{"cipher":"AES","key":256,"iv":12,"mode":"GCM","type":"auth"}};

/***/ }),

/***/ "./node_modules/browserify-aes/modes/ofb.js":
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/ofb.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(/*! buffer-xor */ "./node_modules/buffer-xor/index.js")

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/browserify-aes/streamCipher.js":
/*!*****************************************************!*\
  !*** ./node_modules/browserify-aes/streamCipher.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aes = __webpack_require__(/*! ./aes */ "./node_modules/browserify-aes/aes.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var Transform = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")

function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._mode = mode
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}

StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

module.exports = StreamCipher


/***/ }),

/***/ "./node_modules/browserify-cipher/browser.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-cipher/browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DES = __webpack_require__(/*! browserify-des */ "./node_modules/browserify-des/index.js")
var aes = __webpack_require__(/*! browserify-aes/browser */ "./node_modules/browserify-aes/browser.js")
var aesModes = __webpack_require__(/*! browserify-aes/modes */ "./node_modules/browserify-aes/modes/index.js")
var desModes = __webpack_require__(/*! browserify-des/modes */ "./node_modules/browserify-des/modes.js")
var ebtk = __webpack_require__(/*! evp_bytestokey */ "./node_modules/evp_bytestokey/index.js")

function createCipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createCipheriv(suite, keys.key, keys.iv)
}

function createDecipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createDecipheriv(suite, keys.key, keys.iv)
}

function createCipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite })

  throw new TypeError('invalid suite type')
}

function createDecipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true })

  throw new TypeError('invalid suite type')
}

function getCiphers () {
  return Object.keys(desModes).concat(aes.getCiphers())
}

exports.createCipher = exports.Cipher = createCipher
exports.createCipheriv = exports.Cipheriv = createCipheriv
exports.createDecipher = exports.Decipher = createDecipher
exports.createDecipheriv = exports.Decipheriv = createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),

/***/ "./node_modules/browserify-des/index.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-des/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var CipherBase = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var des = __webpack_require__(/*! des.js */ "./node_modules/des.js/lib/des.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
}
modes.des = modes['des-cbc']
modes.des3 = modes['des-ede3-cbc']
module.exports = DES
inherits(DES, CipherBase)
function DES (opts) {
  CipherBase.call(this)
  var modeName = opts.mode.toLowerCase()
  var mode = modes[modeName]
  var type
  if (opts.decrypt) {
    type = 'decrypt'
  } else {
    type = 'encrypt'
  }
  var key = opts.key
  if (!Buffer.isBuffer(key)) {
    key = Buffer.from(key)
  }
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)])
  }
  var iv = opts.iv
  if (!Buffer.isBuffer(iv)) {
    iv = Buffer.from(iv)
  }
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  })
}
DES.prototype._update = function (data) {
  return Buffer.from(this._des.update(data))
}
DES.prototype._final = function () {
  return Buffer.from(this._des.final())
}


/***/ }),

/***/ "./node_modules/browserify-des/modes.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-des/modes.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports['des-ecb'] = {
  key: 8,
  iv: 0
}
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
}
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
}
exports['des-ede3'] = {
  key: 24,
  iv: 0
}
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
}
exports['des-ede'] = {
  key: 16,
  iv: 0
}


/***/ }),

/***/ "./node_modules/browserify-rsa/index.js":
/*!**********************************************!*\
  !*** ./node_modules/browserify-rsa/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var bn = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js");
module.exports = crt;
function blind(priv) {
  var r = getr(priv);
  var blinder = r.toRed(bn.mont(priv.modulus))
  .redPow(new bn(priv.publicExponent)).fromRed();
  return {
    blinder: blinder,
    unblinder:r.invm(priv.modulus)
  };
}
function crt(msg, priv) {
  var blinds = blind(priv);
  var len = priv.modulus.byteLength();
  var mod = bn.mont(priv.modulus);
  var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
  var c1 = blinded.toRed(bn.mont(priv.prime1));
  var c2 = blinded.toRed(bn.mont(priv.prime2));
  var qinv = priv.coefficient;
  var p = priv.prime1;
  var q = priv.prime2;
  var m1 = c1.redPow(priv.exponent1);
  var m2 = c2.redPow(priv.exponent2);
  m1 = m1.fromRed();
  m2 = m2.fromRed();
  var h = m1.isub(m2).imul(qinv).umod(p);
  h.imul(q);
  m2.iadd(h);
  return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
}
crt.getr = getr;
function getr(priv) {
  var len = priv.modulus.byteLength();
  var r = new bn(randomBytes(len));
  while (r.cmp(priv.modulus) >=  0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
    r = new bn(randomBytes(len));
  }
  return r;
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/browserify-sign/algos.js":
/*!***********************************************!*\
  !*** ./node_modules/browserify-sign/algos.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./browser/algorithms.json */ "./node_modules/browserify-sign/browser/algorithms.json")


/***/ }),

/***/ "./node_modules/browserify-sign/browser/algorithms.json":
/*!**************************************************************!*\
  !*** ./node_modules/browserify-sign/browser/algorithms.json ***!
  \**************************************************************/
/*! exports provided: sha224WithRSAEncryption, RSA-SHA224, sha256WithRSAEncryption, RSA-SHA256, sha384WithRSAEncryption, RSA-SHA384, sha512WithRSAEncryption, RSA-SHA512, RSA-SHA1, ecdsa-with-SHA1, sha256, sha224, sha384, sha512, DSA-SHA, DSA-SHA1, DSA, DSA-WITH-SHA224, DSA-SHA224, DSA-WITH-SHA256, DSA-SHA256, DSA-WITH-SHA384, DSA-SHA384, DSA-WITH-SHA512, DSA-SHA512, DSA-RIPEMD160, ripemd160WithRSA, RSA-RIPEMD160, md5WithRSAEncryption, RSA-MD5, default */
/***/ (function(module) {

module.exports = {"sha224WithRSAEncryption":{"sign":"rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"RSA-SHA224":{"sign":"ecdsa/rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"sha256WithRSAEncryption":{"sign":"rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"RSA-SHA256":{"sign":"ecdsa/rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"sha384WithRSAEncryption":{"sign":"rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"RSA-SHA384":{"sign":"ecdsa/rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"sha512WithRSAEncryption":{"sign":"rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA512":{"sign":"ecdsa/rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA1":{"sign":"rsa","hash":"sha1","id":"3021300906052b0e03021a05000414"},"ecdsa-with-SHA1":{"sign":"ecdsa","hash":"sha1","id":""},"sha256":{"sign":"ecdsa","hash":"sha256","id":""},"sha224":{"sign":"ecdsa","hash":"sha224","id":""},"sha384":{"sign":"ecdsa","hash":"sha384","id":""},"sha512":{"sign":"ecdsa","hash":"sha512","id":""},"DSA-SHA":{"sign":"dsa","hash":"sha1","id":""},"DSA-SHA1":{"sign":"dsa","hash":"sha1","id":""},"DSA":{"sign":"dsa","hash":"sha1","id":""},"DSA-WITH-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-WITH-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-WITH-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-WITH-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-RIPEMD160":{"sign":"dsa","hash":"rmd160","id":""},"ripemd160WithRSA":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"RSA-RIPEMD160":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"md5WithRSAEncryption":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"},"RSA-MD5":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"}};

/***/ }),

/***/ "./node_modules/browserify-sign/browser/curves.json":
/*!**********************************************************!*\
  !*** ./node_modules/browserify-sign/browser/curves.json ***!
  \**********************************************************/
/*! exports provided: 1.3.132.0.10, 1.3.132.0.33, 1.2.840.10045.3.1.1, 1.2.840.10045.3.1.7, 1.3.132.0.34, 1.3.132.0.35, default */
/***/ (function(module) {

module.exports = {"1.3.132.0.10":"secp256k1","1.3.132.0.33":"p224","1.2.840.10045.3.1.1":"p192","1.2.840.10045.3.1.7":"p256","1.3.132.0.34":"p384","1.3.132.0.35":"p521"};

/***/ }),

/***/ "./node_modules/browserify-sign/browser/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/browserify-sign/browser/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(/*! create-hash */ "./node_modules/create-hash/browser.js")
var stream = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var sign = __webpack_require__(/*! ./sign */ "./node_modules/browserify-sign/browser/sign.js")
var verify = __webpack_require__(/*! ./verify */ "./node_modules/browserify-sign/browser/verify.js")

var algorithms = __webpack_require__(/*! ./algorithms.json */ "./node_modules/browserify-sign/browser/algorithms.json")
Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = new Buffer(algorithms[key].id, 'hex')
  algorithms[key.toLowerCase()] = algorithms[key]
})

function Sign (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hashType = data.hash
  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Sign, stream.Writable)

Sign.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Sign.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc)

  this._hash.update(data)
  return this
}

Sign.prototype.sign = function signMethod (key, enc) {
  this.end()
  var hash = this._hash.digest()
  var sig = sign(hash, key, this._hashType, this._signType, this._tag)

  return enc ? sig.toString(enc) : sig
}

function Verify (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Verify, stream.Writable)

Verify.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Verify.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc)

  this._hash.update(data)
  return this
}

Verify.prototype.verify = function verifyMethod (key, sig, enc) {
  if (typeof sig === 'string') sig = new Buffer(sig, enc)

  this.end()
  var hash = this._hash.digest()
  return verify(sig, hash, key, this._signType, this._tag)
}

function createSign (algorithm) {
  return new Sign(algorithm)
}

function createVerify (algorithm) {
  return new Verify(algorithm)
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/browserify-sign/browser/sign.js":
/*!******************************************************!*\
  !*** ./node_modules/browserify-sign/browser/sign.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var createHmac = __webpack_require__(/*! create-hmac */ "./node_modules/create-hmac/browser.js")
var crt = __webpack_require__(/*! browserify-rsa */ "./node_modules/browserify-rsa/index.js")
var EC = __webpack_require__(/*! elliptic */ "./node_modules/elliptic/lib/elliptic.js").ec
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")
var parseKeys = __webpack_require__(/*! parse-asn1 */ "./node_modules/parse-asn1/index.js")
var curves = __webpack_require__(/*! ./curves.json */ "./node_modules/browserify-sign/browser/curves.json")

function sign (hash, key, hashType, signType, tag) {
  var priv = parseKeys(key)
  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
    return ecSign(hash, priv)
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong private key type')
    return dsaSign(hash, priv, hashType)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = priv.modulus.byteLength()
  var pad = [ 0, 1 ]
  while (hash.length + pad.length + 1 < len) pad.push(0xff)
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) pad.push(hash[i])

  var out = crt(pad, priv)
  return out
}

function ecSign (hash, priv) {
  var curveId = curves[priv.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))

  var curve = new EC(curveId)
  var key = curve.keyFromPrivate(priv.privateKey)
  var out = key.sign(hash)

  return new Buffer(out.toDER())
}

function dsaSign (hash, priv, algo) {
  var x = priv.params.priv_key
  var p = priv.params.p
  var q = priv.params.q
  var g = priv.params.g
  var r = new BN(0)
  var k
  var H = bits2int(hash, q).mod(q)
  var s = false
  var kv = getKey(x, q, hash, algo)
  while (s === false) {
    k = makeKey(q, kv, algo)
    r = makeR(g, k, p, q)
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)
    if (s.cmpn(0) === 0) {
      s = false
      r = new BN(0)
    }
  }
  return toDER(r, s)
}

function toDER (r, s) {
  r = r.toArray()
  s = s.toArray()

  // Pad values
  if (r[0] & 0x80) r = [ 0 ].concat(r)
  if (s[0] & 0x80) s = [ 0 ].concat(s)

  var total = r.length + s.length + 4
  var res = [ 0x30, total, 0x02, r.length ]
  res = res.concat(r, [ 0x02, s.length ], s)
  return new Buffer(res)
}

function getKey (x, q, hash, algo) {
  x = new Buffer(x.toArray())
  if (x.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - x.length)
    zeros.fill(0)
    x = Buffer.concat([ zeros, x ])
  }
  var hlen = hash.length
  var hbits = bits2octets(hash, q)
  var v = new Buffer(hlen)
  v.fill(1)
  var k = new Buffer(hlen)
  k.fill(0)
  k = createHmac(algo, k).update(v).update(new Buffer([ 0 ])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  k = createHmac(algo, k).update(v).update(new Buffer([ 1 ])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  return { k: k, v: v }
}

function bits2int (obits, q) {
  var bits = new BN(obits)
  var shift = (obits.length << 3) - q.bitLength()
  if (shift > 0) bits.ishrn(shift)
  return bits
}

function bits2octets (bits, q) {
  bits = bits2int(bits, q)
  bits = bits.mod(q)
  var out = new Buffer(bits.toArray())
  if (out.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - out.length)
    zeros.fill(0)
    out = Buffer.concat([ zeros, out ])
  }
  return out
}

function makeKey (q, kv, algo) {
  var t
  var k

  do {
    t = new Buffer(0)

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest()
      t = Buffer.concat([ t, kv.v ])
    }

    k = bits2int(t, q)
    kv.k = createHmac(algo, kv.k).update(kv.v).update(new Buffer([ 0 ])).digest()
    kv.v = createHmac(algo, kv.k).update(kv.v).digest()
  } while (k.cmp(q) !== -1)

  return k
}

function makeR (g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)
}

module.exports = sign
module.exports.getKey = getKey
module.exports.makeKey = makeKey

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/browserify-sign/browser/verify.js":
/*!********************************************************!*\
  !*** ./node_modules/browserify-sign/browser/verify.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")
var EC = __webpack_require__(/*! elliptic */ "./node_modules/elliptic/lib/elliptic.js").ec
var parseKeys = __webpack_require__(/*! parse-asn1 */ "./node_modules/parse-asn1/index.js")
var curves = __webpack_require__(/*! ./curves.json */ "./node_modules/browserify-sign/browser/curves.json")

function verify (sig, hash, key, signType, tag) {
  var pub = parseKeys(key)
  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
    return ecVerify(sig, hash, pub)
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong public key type')
    return dsaVerify(sig, hash, pub)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = pub.modulus.byteLength()
  var pad = [ 1 ]
  var padNum = 0
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff)
    padNum++
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }
  pad = new Buffer(pad)
  var red = BN.mont(pub.modulus)
  sig = new BN(sig).toRed(red)

  sig = sig.redPow(new BN(pub.publicExponent))
  sig = new Buffer(sig.fromRed().toArray())
  var out = padNum < 8 ? 1 : 0
  len = Math.min(sig.length, pad.length)
  if (sig.length !== pad.length) out = 1

  i = -1
  while (++i < len) out |= sig[i] ^ pad[i]
  return out === 0
}

function ecVerify (sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))

  var curve = new EC(curveId)
  var pubkey = pub.data.subjectPrivateKey.data

  return curve.verify(hash, sig, pubkey)
}

function dsaVerify (sig, hash, pub) {
  var p = pub.data.p
  var q = pub.data.q
  var g = pub.data.g
  var y = pub.data.pub_key
  var unpacked = parseKeys.signature.decode(sig, 'der')
  var s = unpacked.s
  var r = unpacked.r
  checkValue(s, q)
  checkValue(r, q)
  var montp = BN.mont(p)
  var w = s.invm(q)
  var v = g.toRed(montp)
    .redPow(new BN(hash).mul(w).mod(q))
    .fromRed()
    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
    .mod(p)
    .mod(q)
  return v.cmp(r) === 0
}

function checkValue (b, q) {
  if (b.cmpn(0) <= 0) throw new Error('invalid sig')
  if (b.cmp(q) >= q) throw new Error('invalid sig')
}

module.exports = verify

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/buffer-xor/index.js":
/*!******************************************!*\
  !*** ./node_modules/buffer-xor/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/cipher-base/index.js":
/*!*******************************************!*\
  !*** ./node_modules/cipher-base/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var Transform = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js").Transform
var StringDecoder = __webpack_require__(/*! string_decoder */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")

function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  if (this._final) {
    this.__final = this._final
    this._final = null
  }
  this._decoder = null
  this._encoding = null
}
inherits(CipherBase, Transform)

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc)
  }

  var outData = this._update(data)
  if (this.hashMode) return this

  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }

  return outData
}

CipherBase.prototype.setAutoPadding = function () {}
CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this.__final())
  } catch (e) {
    err = e
  }

  done(err)
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0)
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }

  return out
}

module.exports = CipherBase


/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/create-ecdh/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/create-ecdh/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var elliptic = __webpack_require__(/*! elliptic */ "./node_modules/elliptic/lib/elliptic.js")
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")

module.exports = function createECDH (curve) {
  return new ECDH(curve)
}

var aliases = {
  secp256k1: {
    name: 'secp256k1',
    byteLength: 32
  },
  secp224r1: {
    name: 'p224',
    byteLength: 28
  },
  prime256v1: {
    name: 'p256',
    byteLength: 32
  },
  prime192v1: {
    name: 'p192',
    byteLength: 24
  },
  ed25519: {
    name: 'ed25519',
    byteLength: 32
  },
  secp384r1: {
    name: 'p384',
    byteLength: 48
  },
  secp521r1: {
    name: 'p521',
    byteLength: 66
  }
}

aliases.p224 = aliases.secp224r1
aliases.p256 = aliases.secp256r1 = aliases.prime256v1
aliases.p192 = aliases.secp192r1 = aliases.prime192v1
aliases.p384 = aliases.secp384r1
aliases.p521 = aliases.secp521r1

function ECDH (curve) {
  this.curveType = aliases[curve]
  if (!this.curveType) {
    this.curveType = {
      name: curve
    }
  }
  this.curve = new elliptic.ec(this.curveType.name) // eslint-disable-line new-cap
  this.keys = void 0
}

ECDH.prototype.generateKeys = function (enc, format) {
  this.keys = this.curve.genKeyPair()
  return this.getPublicKey(enc, format)
}

ECDH.prototype.computeSecret = function (other, inenc, enc) {
  inenc = inenc || 'utf8'
  if (!Buffer.isBuffer(other)) {
    other = new Buffer(other, inenc)
  }
  var otherPub = this.curve.keyFromPublic(other).getPublic()
  var out = otherPub.mul(this.keys.getPrivate()).getX()
  return formatReturnValue(out, enc, this.curveType.byteLength)
}

ECDH.prototype.getPublicKey = function (enc, format) {
  var key = this.keys.getPublic(format === 'compressed', true)
  if (format === 'hybrid') {
    if (key[key.length - 1] % 2) {
      key[0] = 7
    } else {
      key[0] = 6
    }
  }
  return formatReturnValue(key, enc)
}

ECDH.prototype.getPrivateKey = function (enc) {
  return formatReturnValue(this.keys.getPrivate(), enc)
}

ECDH.prototype.setPublicKey = function (pub, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc)
  }
  this.keys._importPublic(pub)
  return this
}

ECDH.prototype.setPrivateKey = function (priv, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc)
  }

  var _priv = new BN(priv)
  _priv = _priv.toString(16)
  this.keys = this.curve.genKeyPair()
  this.keys._importPrivate(_priv)
  return this
}

function formatReturnValue (bn, enc, len) {
  if (!Array.isArray(bn)) {
    bn = bn.toArray()
  }
  var buf = new Buffer(bn)
  if (len && buf.length < len) {
    var zeros = new Buffer(len - buf.length)
    zeros.fill(0)
    buf = Buffer.concat([zeros, buf])
  }
  if (!enc) {
    return buf
  } else {
    return buf.toString(enc)
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/create-hash/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/create-hash/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var MD5 = __webpack_require__(/*! md5.js */ "./node_modules/md5.js/index.js")
var RIPEMD160 = __webpack_require__(/*! ripemd160 */ "./node_modules/ripemd160/index.js")
var sha = __webpack_require__(/*! sha.js */ "./node_modules/sha.js/index.js")
var Base = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}


/***/ }),

/***/ "./node_modules/create-hash/md5.js":
/*!*****************************************!*\
  !*** ./node_modules/create-hash/md5.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MD5 = __webpack_require__(/*! md5.js */ "./node_modules/md5.js/index.js")

module.exports = function (buffer) {
  return new MD5().update(buffer).digest()
}


/***/ }),

/***/ "./node_modules/create-hmac/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/create-hmac/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Legacy = __webpack_require__(/*! ./legacy */ "./node_modules/create-hmac/legacy.js")
var Base = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var md5 = __webpack_require__(/*! create-hash/md5 */ "./node_modules/create-hash/md5.js")
var RIPEMD160 = __webpack_require__(/*! ripemd160 */ "./node_modules/ripemd160/index.js")

var sha = __webpack_require__(/*! sha.js */ "./node_modules/sha.js/index.js")

var ZEROS = Buffer.alloc(128)

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key
  if (key.length > blocksize) {
    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
    key = hash.update(key).digest()
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }
  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
  this._hash.update(ipad)
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.update(data)
}

Hmac.prototype._final = function () {
  var h = this._hash.digest()
  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)
  return hash.update(this._opad).update(h).digest()
}

module.exports = function createHmac (alg, key) {
  alg = alg.toLowerCase()
  if (alg === 'rmd160' || alg === 'ripemd160') {
    return new Hmac('rmd160', key)
  }
  if (alg === 'md5') {
    return new Legacy(md5, key)
  }
  return new Hmac(alg, key)
}


/***/ }),

/***/ "./node_modules/create-hmac/legacy.js":
/*!********************************************!*\
  !*** ./node_modules/create-hmac/legacy.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var Base = __webpack_require__(/*! cipher-base */ "./node_modules/cipher-base/index.js")

var ZEROS = Buffer.alloc(128)
var blocksize = 64

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = alg(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = [ipad]
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.push(data)
}

Hmac.prototype._final = function () {
  var h = this._alg(Buffer.concat(this._hash))
  return this._alg(Buffer.concat([this._opad, h]))
}
module.exports = Hmac


/***/ }),

/***/ "./node_modules/crypto-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js")
exports.createHash = exports.Hash = __webpack_require__(/*! create-hash */ "./node_modules/create-hash/browser.js")
exports.createHmac = exports.Hmac = __webpack_require__(/*! create-hmac */ "./node_modules/create-hmac/browser.js")

var algos = __webpack_require__(/*! browserify-sign/algos */ "./node_modules/browserify-sign/algos.js")
var algoKeys = Object.keys(algos)
var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys)
exports.getHashes = function () {
  return hashes
}

var p = __webpack_require__(/*! pbkdf2 */ "./node_modules/pbkdf2/browser.js")
exports.pbkdf2 = p.pbkdf2
exports.pbkdf2Sync = p.pbkdf2Sync

var aes = __webpack_require__(/*! browserify-cipher */ "./node_modules/browserify-cipher/browser.js")

exports.Cipher = aes.Cipher
exports.createCipher = aes.createCipher
exports.Cipheriv = aes.Cipheriv
exports.createCipheriv = aes.createCipheriv
exports.Decipher = aes.Decipher
exports.createDecipher = aes.createDecipher
exports.Decipheriv = aes.Decipheriv
exports.createDecipheriv = aes.createDecipheriv
exports.getCiphers = aes.getCiphers
exports.listCiphers = aes.listCiphers

var dh = __webpack_require__(/*! diffie-hellman */ "./node_modules/diffie-hellman/browser.js")

exports.DiffieHellmanGroup = dh.DiffieHellmanGroup
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup
exports.getDiffieHellman = dh.getDiffieHellman
exports.createDiffieHellman = dh.createDiffieHellman
exports.DiffieHellman = dh.DiffieHellman

var sign = __webpack_require__(/*! browserify-sign */ "./node_modules/browserify-sign/browser/index.js")

exports.createSign = sign.createSign
exports.Sign = sign.Sign
exports.createVerify = sign.createVerify
exports.Verify = sign.Verify

exports.createECDH = __webpack_require__(/*! create-ecdh */ "./node_modules/create-ecdh/browser.js")

var publicEncrypt = __webpack_require__(/*! public-encrypt */ "./node_modules/public-encrypt/browser.js")

exports.publicEncrypt = publicEncrypt.publicEncrypt
exports.privateEncrypt = publicEncrypt.privateEncrypt
exports.publicDecrypt = publicEncrypt.publicDecrypt
exports.privateDecrypt = publicEncrypt.privateDecrypt

// the least I can do is make error messages for the rest of the node.js/crypto api.
// ;[
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error([
//       'sorry, ' + name + ' is not implemented yet',
//       'we accept pull requests',
//       'https://github.com/crypto-browserify/crypto-browserify'
//     ].join('\n'))
//   }
// })

var rf = __webpack_require__(/*! randomfill */ "./node_modules/randomfill/browser.js")

exports.randomFill = rf.randomFill
exports.randomFillSync = rf.randomFillSync

exports.createCredentials = function () {
  throw new Error([
    'sorry, createCredentials is not implemented yet',
    'we accept pull requests',
    'https://github.com/crypto-browserify/crypto-browserify'
  ].join('\n'))
}

exports.constants = {
  'DH_CHECK_P_NOT_SAFE_PRIME': 2,
  'DH_CHECK_P_NOT_PRIME': 1,
  'DH_UNABLE_TO_CHECK_GENERATOR': 4,
  'DH_NOT_SUITABLE_GENERATOR': 8,
  'NPN_ENABLED': 1,
  'ALPN_ENABLED': 1,
  'RSA_PKCS1_PADDING': 1,
  'RSA_SSLV23_PADDING': 2,
  'RSA_NO_PADDING': 3,
  'RSA_PKCS1_OAEP_PADDING': 4,
  'RSA_X931_PADDING': 5,
  'RSA_PKCS1_PSS_PADDING': 6,
  'POINT_CONVERSION_COMPRESSED': 2,
  'POINT_CONVERSION_UNCOMPRESSED': 4,
  'POINT_CONVERSION_HYBRID': 6
}


/***/ }),

/***/ "./node_modules/des.js/lib/des.js":
/*!****************************************!*\
  !*** ./node_modules/des.js/lib/des.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.utils = __webpack_require__(/*! ./des/utils */ "./node_modules/des.js/lib/des/utils.js");
exports.Cipher = __webpack_require__(/*! ./des/cipher */ "./node_modules/des.js/lib/des/cipher.js");
exports.DES = __webpack_require__(/*! ./des/des */ "./node_modules/des.js/lib/des/des.js");
exports.CBC = __webpack_require__(/*! ./des/cbc */ "./node_modules/des.js/lib/des/cbc.js");
exports.EDE = __webpack_require__(/*! ./des/ede */ "./node_modules/des.js/lib/des/ede.js");


/***/ }),

/***/ "./node_modules/des.js/lib/des/cbc.js":
/*!********************************************!*\
  !*** ./node_modules/des.js/lib/des/cbc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};


/***/ }),

/***/ "./node_modules/des.js/lib/des/cipher.js":
/*!***********************************************!*\
  !*** ./node_modules/des.js/lib/des/cipher.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

function Cipher(options) {
  this.options = options;

  this.type = this.options.type;
  this.blockSize = 8;
  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
}
module.exports = Cipher;

Cipher.prototype._init = function _init() {
  // Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0)
    return [];

  if (this.type === 'decrypt')
    return this._updateDecrypt(data);
  else
    return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);

    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - ((data.length - inputOff) % this.blockSize);
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);

  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer)
    first = this.update(buffer);

  var last;
  if (this.type === 'encrypt')
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();

  if (first)
    return first.concat(last);
  else
    return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0)
    return false;

  while (off < buffer.length)
    buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];

  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);

  return this._unpad(out);
};


/***/ }),

/***/ "./node_modules/des.js/lib/des/des.js":
/*!********************************************!*\
  !*** ./node_modules/des.js/lib/des/des.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var des = __webpack_require__(/*! ../des */ "./node_modules/des.js/lib/des.js");
var utils = des.utils;
var Cipher = des.Cipher;

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);

  var state = new DESState();
  this._desState = state;

  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [
  1, 1, 2, 2, 2, 2, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 1
];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);

  assert.equal(key.length, this.blockSize, 'Invalid key length');

  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);

  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;

  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];

  if (this.type === 'encrypt')
    this._encrypt(state, l, r, state.tmp, 0);
  else
    this._decrypt(state, l, r, state.tmp, 0);

  l = state.tmp[0];
  r = state.tmp[1];

  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++)
    buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++)
    assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};


/***/ }),

/***/ "./node_modules/des.js/lib/des/ede.js":
/*!********************************************!*\
  !*** ./node_modules/des.js/lib/des/ede.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var des = __webpack_require__(/*! ../des */ "./node_modules/des.js/lib/des.js");
var Cipher = des.Cipher;
var DES = des.DES;

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [
      DES.create({ type: 'encrypt', key: k1 }),
      DES.create({ type: 'decrypt', key: k2 }),
      DES.create({ type: 'encrypt', key: k3 })
    ];
  } else {
    this.ciphers = [
      DES.create({ type: 'decrypt', key: k3 }),
      DES.create({ type: 'encrypt', key: k2 }),
      DES.create({ type: 'decrypt', key: k1 })
    ];
  }
}

function EDE(options) {
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;


/***/ }),

/***/ "./node_modules/des.js/lib/des/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/des.js/lib/des/utils.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res =  (bytes[0 + off] << 24) |
             (bytes[1 + off] << 16) |
             (bytes[2 + off] << 8) |
             bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = (value >>> 16) & 0xff;
  bytes[2 + off] = (value >>> 8) & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + i)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + i)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
};

var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0,
  13, 22, 7, 18, 5, 9, 16, 24,
  2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16,
  5, 11, 23, 8, 12, 7, 17, 0,
  22, 3, 10, 14, 6, 20, 27, 24
];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> pc2table[i]) & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= (inR >>> pc2table[i]) & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }
  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [
  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
];

exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = (inL >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = (inR >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};

var permuteTable = [
  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
];

exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= (num >>> permuteTable[i]) & 0x1;
  }
  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = '0' + str;

  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(' ');
};


/***/ }),

/***/ "./node_modules/diffie-hellman/browser.js":
/*!************************************************!*\
  !*** ./node_modules/diffie-hellman/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var generatePrime = __webpack_require__(/*! ./lib/generatePrime */ "./node_modules/diffie-hellman/lib/generatePrime.js")
var primes = __webpack_require__(/*! ./lib/primes.json */ "./node_modules/diffie-hellman/lib/primes.json")

var DH = __webpack_require__(/*! ./lib/dh */ "./node_modules/diffie-hellman/lib/dh.js")

function getDiffieHellman (mod) {
  var prime = new Buffer(primes[mod].prime, 'hex')
  var gen = new Buffer(primes[mod].gen, 'hex')

  return new DH(prime, gen)
}

var ENCODINGS = {
  'binary': true, 'hex': true, 'base64': true
}

function createDiffieHellman (prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator)
  }

  enc = enc || 'binary'
  genc = genc || 'binary'
  generator = generator || new Buffer([2])

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc)
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true)
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc)
  }

  return new DH(prime, generator, true)
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/diffie-hellman/lib/dh.js":
/*!***********************************************!*\
  !*** ./node_modules/diffie-hellman/lib/dh.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var MillerRabin = __webpack_require__(/*! miller-rabin */ "./node_modules/miller-rabin/lib/mr.js");
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = __webpack_require__(/*! ./generatePrime */ "./node_modules/diffie-hellman/lib/generatePrime.js");
var randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js");
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;

  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/diffie-hellman/lib/generatePrime.js":
/*!**********************************************************!*\
  !*** ./node_modules/diffie-hellman/lib/generatePrime.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js");
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var TWENTYFOUR = new BN(24);
var MillerRabin = __webpack_require__(/*! miller-rabin */ "./node_modules/miller-rabin/lib/mr.js");
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);

  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }

}


/***/ }),

/***/ "./node_modules/diffie-hellman/lib/primes.json":
/*!*****************************************************!*\
  !*** ./node_modules/diffie-hellman/lib/primes.json ***!
  \*****************************************************/
/*! exports provided: modp1, modp2, modp5, modp14, modp15, modp16, modp17, modp18, default */
/***/ (function(module) {

module.exports = {"modp1":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"},"modp2":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"},"modp5":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"},"modp14":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"},"modp15":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"},"modp16":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"},"modp17":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"},"modp18":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"}};

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic.js":
/*!***********************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = exports;

elliptic.version = __webpack_require__(/*! ../package.json */ "./node_modules/elliptic/package.json").version;
elliptic.utils = __webpack_require__(/*! ./elliptic/utils */ "./node_modules/elliptic/lib/elliptic/utils.js");
elliptic.rand = __webpack_require__(/*! brorand */ "./node_modules/brorand/index.js");
elliptic.curve = __webpack_require__(/*! ./elliptic/curve */ "./node_modules/elliptic/lib/elliptic/curve/index.js");
elliptic.curves = __webpack_require__(/*! ./elliptic/curves */ "./node_modules/elliptic/lib/elliptic/curves.js");

// Protocols
elliptic.ec = __webpack_require__(/*! ./elliptic/ec */ "./node_modules/elliptic/lib/elliptic/ec/index.js");
elliptic.eddsa = __webpack_require__(/*! ./elliptic/eddsa */ "./node_modules/elliptic/lib/elliptic/eddsa/index.js");


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/base.js":
/*!**********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/base.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  for (var j = 0; j < naf.length; j += doubles.step) {
    var nafW = 0;
    for (var k = j + doubles.step - 1; k >= j; k--)
      nafW = (nafW << 1) + naf[k];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (var j = 0; j < repr.length; j++) {
      var nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var k = 0; i >= 0 && naf[i] === 0; i--)
      k++;
    if (i >= 0)
      k++;
    acc = acc.dblp(k);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                       points,
                                                       coeffs,
                                                       len,
                                                       jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  for (var i = 0; i < len; i++) {
    var p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (var i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a]);
      naf[b] = getNAF(coeffs[b], wndWidth[b]);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b] /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (var j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (var i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (var j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (var j = 0; j < len; j++) {
      var z = tmp[j];
      var p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (var i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
                          bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/edwards.js":
/*!*************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/edwards.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(/*! ../curve */ "./node_modules/elliptic/lib/elliptic/curve/index.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Base = curve.base;

var assert = elliptic.utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  if (this.curve.twisted) {
    // E = a * C
    var e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      var h = this.z.redSqr();
      // J = F - 2 * H
      var j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    var e = c.redAdd(d);
    // H = (c * Z1)^2
    var h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    var j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
                          this.y,
                          this.z,
                          this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = exports;

curve.base = __webpack_require__(/*! ./base */ "./node_modules/elliptic/lib/elliptic/curve/base.js");
curve.short = __webpack_require__(/*! ./short */ "./node_modules/elliptic/lib/elliptic/curve/short.js");
curve.mont = __webpack_require__(/*! ./mont */ "./node_modules/elliptic/lib/elliptic/curve/mont.js");
curve.edwards = __webpack_require__(/*! ./edwards */ "./node_modules/elliptic/lib/elliptic/curve/edwards.js");


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/mont.js":
/*!**********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/mont.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(/*! ../curve */ "./node_modules/elliptic/lib/elliptic/curve/index.js");
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Base = curve.base;

var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/short.js":
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/short.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(/*! ../curve */ "./node_modules/elliptic/lib/elliptic/curve/index.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var Base = curve.base;

var assert = elliptic.utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();

    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

  // Clean-up references to points and coefficients
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);

  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (var i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (var i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curves.js":
/*!******************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curves.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curves = exports;

var hash = __webpack_require__(/*! hash.js */ "./node_modules/hash.js/lib/hash.js");
var elliptic = __webpack_require__(/*! ../elliptic */ "./node_modules/elliptic/lib/elliptic.js");

var assert = elliptic.utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new elliptic.curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new elliptic.curve.edwards(options);
  else
    this.curve = new elliptic.curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
  ]
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
  ]
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
  ]
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
  ]
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650'
  ]
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9'
  ]
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658'
  ]
});

var pre;
try {
  pre = __webpack_require__(/*! ./precomputed/secp256k1 */ "./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js");
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre
  ]
});


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/ec/index.js":
/*!********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var HmacDRBG = __webpack_require__(/*! hmac-drbg */ "./node_modules/hmac-drbg/lib/hmac-drbg.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;

var KeyPair = __webpack_require__(/*! ./key */ "./node_modules/elliptic/lib/elliptic/ec/key.js");
var Signature = __webpack_require__(/*! ./signature */ "./node_modules/elliptic/lib/elliptic/ec/signature.js");

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);

    options = elliptic.curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof elliptic.curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray()
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  do {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  } while (true);
};

EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8'
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; true; iter++) {
    var k = options.k ?
        options.k(iter) :
        new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);

  if (!this.curve._maxwellTrick) {
    var p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  var p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/ec/key.js":
/*!******************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/key.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/ec/signature.js":
/*!************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/signature.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");

var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
  }
  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0 && (r[1] & 0x80)) {
    r = r.slice(1);
  }
  if (s[0] === 0 && (s[1] & 0x80)) {
    s = s.slice(1);
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/eddsa/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(/*! hash.js */ "./node_modules/hash.js/lib/hash.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = __webpack_require__(/*! ./key */ "./node_modules/elliptic/lib/elliptic/eddsa/key.js");
var Signature = __webpack_require__(/*! ./signature */ "./node_modules/elliptic/lib/elliptic/eddsa/signature.js");

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  var curve = elliptic.curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
               .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/eddsa/key.js":
/*!*********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/key.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/eddsa/signature.js":
/*!***************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/signature.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength)
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js":
/*!*********************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
      ]
    ]
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
      ]
    ]
  }
};


/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/utils.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var minAssert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");
var minUtils = __webpack_require__(/*! minimalistic-crypto-utils */ "./node_modules/minimalistic-crypto-utils/lib/utils.js");

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w) {
  var naf = [];
  var ws = 1 << (w + 1);
  var k = num.clone();
  while (k.cmpn(1) >= 0) {
    var z;
    if (k.isOdd()) {
      var mod = k.andln(ws - 1);
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }
    naf.push(z);

    // Optimization, shift by word if possible
    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
    for (var i = 1; i < shift; i++)
      naf.push(0);
    k.iushrn(shift);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    []
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      var m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      var m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
           this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
                                     bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;



/***/ }),

/***/ "./node_modules/elliptic/package.json":
/*!********************************************!*\
  !*** ./node_modules/elliptic/package.json ***!
  \********************************************/
/*! exports provided: name, version, description, main, files, scripts, repository, keywords, author, license, bugs, homepage, devDependencies, dependencies, default */
/***/ (function(module) {

module.exports = {"name":"elliptic","version":"6.4.1","description":"EC cryptography","main":"lib/elliptic.js","files":["lib"],"scripts":{"jscs":"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js","jshint":"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js","lint":"npm run jscs && npm run jshint","unit":"istanbul test _mocha --reporter=spec test/index.js","test":"npm run lint && npm run unit","version":"grunt dist && git add dist/"},"repository":{"type":"git","url":"git@github.com:indutny/elliptic"},"keywords":["EC","Elliptic","curve","Cryptography"],"author":"Fedor Indutny <fedor@indutny.com>","license":"MIT","bugs":{"url":"https://github.com/indutny/elliptic/issues"},"homepage":"https://github.com/indutny/elliptic","devDependencies":{"brfs":"^1.4.3","coveralls":"^2.11.3","grunt":"^0.4.5","grunt-browserify":"^5.0.0","grunt-cli":"^1.2.0","grunt-contrib-connect":"^1.0.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^1.0.1","grunt-mocha-istanbul":"^3.0.1","grunt-saucelabs":"^8.6.2","istanbul":"^0.4.2","jscs":"^2.9.0","jshint":"^2.6.0","mocha":"^2.1.0"},"dependencies":{"bn.js":"^4.4.0","brorand":"^1.0.1","hash.js":"^1.0.0","hmac-drbg":"^1.0.0","inherits":"^2.0.1","minimalistic-assert":"^1.0.0","minimalistic-crypto-utils":"^1.0.0"}};

/***/ }),

/***/ "./node_modules/evp_bytestokey/index.js":
/*!**********************************************!*\
  !*** ./node_modules/evp_bytestokey/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var MD5 = __webpack_require__(/*! md5.js */ "./node_modules/md5.js/index.js")

/* eslint-disable camelcase */
function EVP_BytesToKey (password, salt, keyBits, ivLen) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')
  if (salt) {
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')
    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')
  }

  var keyLen = keyBits / 8
  var key = Buffer.alloc(keyLen)
  var iv = Buffer.alloc(ivLen || 0)
  var tmp = Buffer.alloc(0)

  while (keyLen > 0 || ivLen > 0) {
    var hash = new MD5()
    hash.update(tmp)
    hash.update(password)
    if (salt) hash.update(salt)
    tmp = hash.digest()

    var used = 0

    if (keyLen > 0) {
      var keyStart = key.length - keyLen
      used = Math.min(keyLen, tmp.length)
      tmp.copy(key, keyStart, 0, used)
      keyLen -= used
    }

    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen
      var length = Math.min(ivLen, tmp.length - used)
      tmp.copy(iv, ivStart, used, used + length)
      ivLen -= length
    }
  }

  tmp.fill(0)
  return { key: key, iv: iv }
}

module.exports = EVP_BytesToKey


/***/ }),

/***/ "./node_modules/hash-base/index.js":
/*!*****************************************!*\
  !*** ./node_modules/hash-base/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var Transform = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js").Transform
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")

function throwIfNotStringOrBuffer (val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer')
  }
}

function HashBase (blockSize) {
  Transform.call(this)

  this._block = Buffer.allocUnsafe(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    this.update(chunk, encoding)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this.digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data')
  if (this._finalized) throw new Error('Digest already called')
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)

  // reset state
  this._block.fill(0)
  this._blockOffset = 0
  for (var i = 0; i < 4; ++i) this._length[i] = 0

  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase


/***/ }),

/***/ "./node_modules/hash.js/lib/hash.js":
/*!******************************************!*\
  !*** ./node_modules/hash.js/lib/hash.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hash = exports;

hash.utils = __webpack_require__(/*! ./hash/utils */ "./node_modules/hash.js/lib/hash/utils.js");
hash.common = __webpack_require__(/*! ./hash/common */ "./node_modules/hash.js/lib/hash/common.js");
hash.sha = __webpack_require__(/*! ./hash/sha */ "./node_modules/hash.js/lib/hash/sha.js");
hash.ripemd = __webpack_require__(/*! ./hash/ripemd */ "./node_modules/hash.js/lib/hash/ripemd.js");
hash.hmac = __webpack_require__(/*! ./hash/hmac */ "./node_modules/hash.js/lib/hash/hmac.js");

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/common.js":
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/common.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/hash.js/lib/hash/utils.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/hmac.js":
/*!***********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/hmac.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/hash.js/lib/hash/utils.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/ripemd.js":
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/ripemd.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ./common */ "./node_modules/hash.js/lib/hash/common.js");

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha.js":
/*!**********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.sha1 = __webpack_require__(/*! ./sha/1 */ "./node_modules/hash.js/lib/hash/sha/1.js");
exports.sha224 = __webpack_require__(/*! ./sha/224 */ "./node_modules/hash.js/lib/hash/sha/224.js");
exports.sha256 = __webpack_require__(/*! ./sha/256 */ "./node_modules/hash.js/lib/hash/sha/256.js");
exports.sha384 = __webpack_require__(/*! ./sha/384 */ "./node_modules/hash.js/lib/hash/sha/384.js");
exports.sha512 = __webpack_require__(/*! ./sha/512 */ "./node_modules/hash.js/lib/hash/sha/512.js");


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/1.js":
/*!************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/1.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ../common */ "./node_modules/hash.js/lib/hash/common.js");
var shaCommon = __webpack_require__(/*! ./common */ "./node_modules/hash.js/lib/hash/sha/common.js");

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/224.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/224.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var SHA256 = __webpack_require__(/*! ./256 */ "./node_modules/hash.js/lib/hash/sha/256.js");

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};



/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/256.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/256.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ../common */ "./node_modules/hash.js/lib/hash/common.js");
var shaCommon = __webpack_require__(/*! ./common */ "./node_modules/hash.js/lib/hash/sha/common.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/384.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/384.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");

var SHA512 = __webpack_require__(/*! ./512 */ "./node_modules/hash.js/lib/hash/sha/512.js");

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/512.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/512.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ../common */ "./node_modules/hash.js/lib/hash/common.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/common.js":
/*!*****************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/common.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/utils.js":
/*!************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/utils.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;


/***/ }),

/***/ "./node_modules/hmac-drbg/lib/hmac-drbg.js":
/*!*************************************************!*\
  !*** ./node_modules/hmac-drbg/lib/hmac-drbg.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(/*! hash.js */ "./node_modules/hash.js/lib/hash.js");
var utils = __webpack_require__(/*! minimalistic-crypto-utils */ "./node_modules/minimalistic-crypto-utils/lib/utils.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/indexof/index.js":
/*!***************************************!*\
  !*** ./node_modules/indexof/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {


var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/md5.js/index.js":
/*!**************************************!*\
  !*** ./node_modules/md5.js/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var HashBase = __webpack_require__(/*! hash-base */ "./node_modules/hash-base/index.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var ARRAY16 = new Array(16)

function MD5 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
}

inherits(MD5, HashBase)

MD5.prototype._update = function () {
  var M = ARRAY16
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d

  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
  c = fnF(c, d, a, b, M[2], 0x242070db, 17)
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
  d = fnG(d, a, b, c, M[10], 0x02441453, 9)
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

  this._a = (this._a + a) | 0
  this._b = (this._b + b) | 0
  this._c = (this._c + c) | 0
  this._d = (this._d + d) | 0
}

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.allocUnsafe(16)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fnF (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
}

function fnG (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
}

function fnH (a, b, c, d, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
}

function fnI (a, b, c, d, m, k, s) {
  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
}

module.exports = MD5


/***/ }),

/***/ "./node_modules/miller-rabin/lib/mr.js":
/*!*********************************************!*\
  !*** ./node_modules/miller-rabin/lib/mr.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var bn = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
var brorand = __webpack_require__(/*! brorand */ "./node_modules/brorand/index.js");

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._randbelow = function _randbelow(n) {
  var len = n.bitLength();
  var min_bytes = Math.ceil(len / 8);

  // Generage random bytes until a number less than n is found.
  // This ensures that 0..n-1 have an equal probability of being selected.
  do
    var a = new bn(this.rand.generate(min_bytes));
  while (a.cmp(n) >= 0);

  return a;
};

MillerRabin.prototype._randrange = function _randrange(start, stop) {
  // Generate a random number greater than or equal to start and less than stop.
  var size = stop.sub(start);
  return start.add(this._randbelow(size));
};

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};


/***/ }),

/***/ "./node_modules/minimalistic-assert/index.js":
/*!***************************************************!*\
  !*** ./node_modules/minimalistic-assert/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};


/***/ }),

/***/ "./node_modules/minimalistic-crypto-utils/lib/utils.js":
/*!*************************************************************!*\
  !*** ./node_modules/minimalistic-crypto-utils/lib/utils.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};


/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/buffer/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/buffer/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/events/events.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/events/events.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = $getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  var args = [];
  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/timers-browserify/main.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/timers-browserify/main.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/parse-asn1/aesid.json":
/*!********************************************!*\
  !*** ./node_modules/parse-asn1/aesid.json ***!
  \********************************************/
/*! exports provided: 2.16.840.1.101.3.4.1.1, 2.16.840.1.101.3.4.1.2, 2.16.840.1.101.3.4.1.3, 2.16.840.1.101.3.4.1.4, 2.16.840.1.101.3.4.1.21, 2.16.840.1.101.3.4.1.22, 2.16.840.1.101.3.4.1.23, 2.16.840.1.101.3.4.1.24, 2.16.840.1.101.3.4.1.41, 2.16.840.1.101.3.4.1.42, 2.16.840.1.101.3.4.1.43, 2.16.840.1.101.3.4.1.44, default */
/***/ (function(module) {

module.exports = {"2.16.840.1.101.3.4.1.1":"aes-128-ecb","2.16.840.1.101.3.4.1.2":"aes-128-cbc","2.16.840.1.101.3.4.1.3":"aes-128-ofb","2.16.840.1.101.3.4.1.4":"aes-128-cfb","2.16.840.1.101.3.4.1.21":"aes-192-ecb","2.16.840.1.101.3.4.1.22":"aes-192-cbc","2.16.840.1.101.3.4.1.23":"aes-192-ofb","2.16.840.1.101.3.4.1.24":"aes-192-cfb","2.16.840.1.101.3.4.1.41":"aes-256-ecb","2.16.840.1.101.3.4.1.42":"aes-256-cbc","2.16.840.1.101.3.4.1.43":"aes-256-ofb","2.16.840.1.101.3.4.1.44":"aes-256-cfb"};

/***/ }),

/***/ "./node_modules/parse-asn1/asn1.js":
/*!*****************************************!*\
  !*** ./node_modules/parse-asn1/asn1.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.


var asn1 = __webpack_require__(/*! asn1.js */ "./node_modules/asn1.js/lib/asn1.js")

exports.certificate = __webpack_require__(/*! ./certificate */ "./node_modules/parse-asn1/certificate.js")

var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
  )
})
exports.RSAPrivateKey = RSAPrivateKey

var RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(
    this.key('modulus').int(),
    this.key('publicExponent').int()
  )
})
exports.RSAPublicKey = RSAPublicKey

var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})
exports.PublicKey = PublicKey

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('none').null_().optional(),
    this.key('curve').objid().optional(),
    this.key('params').seq().obj(
      this.key('p').int(),
      this.key('q').int(),
      this.key('g').int()
    ).optional()
  )
})

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPrivateKey').octstr()
  )
})
exports.PrivateKey = PrivateKeyInfo
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('decrypt').seq().obj(
        this.key('kde').seq().obj(
          this.key('id').objid(),
          this.key('kdeparams').seq().obj(
            this.key('salt').octstr(),
            this.key('iters').int()
          )
        ),
        this.key('cipher').seq().obj(
          this.key('algo').objid(),
          this.key('iv').octstr()
        )
      )
    ),
    this.key('subjectPrivateKey').octstr()
  )
})

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo

var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('p').int(),
    this.key('q').int(),
    this.key('g').int(),
    this.key('pub_key').int(),
    this.key('priv_key').int()
  )
})
exports.DSAPrivateKey = DSAPrivateKey

exports.DSAparam = asn1.define('DSAparam', function () {
  this.int()
})

var ECPrivateKey = asn1.define('ECPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('parameters').optional().explicit(0).use(ECParameters),
    this.key('publicKey').optional().explicit(1).bitstr()
  )
})
exports.ECPrivateKey = ECPrivateKey

var ECParameters = asn1.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  })
})

exports.signature = asn1.define('signature', function () {
  this.seq().obj(
    this.key('r').int(),
    this.key('s').int()
  )
})


/***/ }),

/***/ "./node_modules/parse-asn1/certificate.js":
/*!************************************************!*\
  !*** ./node_modules/parse-asn1/certificate.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen



var asn = __webpack_require__(/*! asn1.js */ "./node_modules/asn1.js/lib/asn1.js")

var Time = asn.define('Time', function () {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  })
})

var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
  this.seq().obj(
    this.key('type').objid(),
    this.key('value').any()
  )
})

var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('parameters').optional(),
    this.key('curve').objid().optional()
  )
})

var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})

var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
  this.setof(AttributeTypeValue)
})

var RDNSequence = asn.define('RDNSequence', function () {
  this.seqof(RelativeDistinguishedName)
})

var Name = asn.define('Name', function () {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  })
})

var Validity = asn.define('Validity', function () {
  this.seq().obj(
    this.key('notBefore').use(Time),
    this.key('notAfter').use(Time)
  )
})

var Extension = asn.define('Extension', function () {
  this.seq().obj(
    this.key('extnID').objid(),
    this.key('critical').bool().def(false),
    this.key('extnValue').octstr()
  )
})

var TBSCertificate = asn.define('TBSCertificate', function () {
  this.seq().obj(
    this.key('version').explicit(0).int().optional(),
    this.key('serialNumber').int(),
    this.key('signature').use(AlgorithmIdentifier),
    this.key('issuer').use(Name),
    this.key('validity').use(Validity),
    this.key('subject').use(Name),
    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
    this.key('issuerUniqueID').implicit(1).bitstr().optional(),
    this.key('subjectUniqueID').implicit(2).bitstr().optional(),
    this.key('extensions').explicit(3).seqof(Extension).optional()
  )
})

var X509Certificate = asn.define('X509Certificate', function () {
  this.seq().obj(
    this.key('tbsCertificate').use(TBSCertificate),
    this.key('signatureAlgorithm').use(AlgorithmIdentifier),
    this.key('signatureValue').bitstr()
  )
})

module.exports = X509Certificate


/***/ }),

/***/ "./node_modules/parse-asn1/fixProc.js":
/*!********************************************!*\
  !*** ./node_modules/parse-asn1/fixProc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r\+\/\=]+)[\n\r]+/m
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r\+\/\=]+)-----END \1-----$/m
var evp = __webpack_require__(/*! evp_bytestokey */ "./node_modules/evp_bytestokey/index.js")
var ciphers = __webpack_require__(/*! browserify-aes */ "./node_modules/browserify-aes/browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
module.exports = function (okey, password) {
  var key = okey.toString()
  var match = key.match(findProc)
  var decrypted
  if (!match) {
    var match2 = key.match(fullRegex)
    decrypted = new Buffer(match2[2].replace(/[\r\n]/g, ''), 'base64')
  } else {
    var suite = 'aes' + match[1]
    var iv = Buffer.from(match[2], 'hex')
    var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ''), 'base64')
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
    var out = []
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
    out.push(cipher.update(cipherText))
    out.push(cipher.final())
    decrypted = Buffer.concat(out)
  }
  var tag = key.match(startRegex)[1]
  return {
    tag: tag,
    data: decrypted
  }
}


/***/ }),

/***/ "./node_modules/parse-asn1/index.js":
/*!******************************************!*\
  !*** ./node_modules/parse-asn1/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = __webpack_require__(/*! ./asn1 */ "./node_modules/parse-asn1/asn1.js")
var aesid = __webpack_require__(/*! ./aesid.json */ "./node_modules/parse-asn1/aesid.json")
var fixProc = __webpack_require__(/*! ./fixProc */ "./node_modules/parse-asn1/fixProc.js")
var ciphers = __webpack_require__(/*! browserify-aes */ "./node_modules/browserify-aes/browser.js")
var compat = __webpack_require__(/*! pbkdf2 */ "./node_modules/pbkdf2/browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
module.exports = parseKeys

function parseKeys (buffer) {
  var password
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase
    buffer = buffer.key
  }
  if (typeof buffer === 'string') {
    buffer = Buffer.from(buffer)
  }

  var stripped = fixProc(buffer, password)

  var type = stripped.tag
  var data = stripped.data
  var subtype, ndata
  switch (type) {
    case 'CERTIFICATE':
      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo
      // falls through
    case 'PUBLIC KEY':
      if (!ndata) {
        ndata = asn1.PublicKey.decode(data, 'der')
      }
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey
          return {
            type: 'ec',
            data: ndata
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der')
      data = decrypt(data, password)
      // falls through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der')
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der')
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      }
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der')
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      }
    default: throw new Error('unknown key type ' + type)
  }
}
parseKeys.signature = asn1.signature
function decrypt (data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
  var iv = data.algorithm.decrypt.cipher.iv
  var cipherText = data.subjectPrivateKey
  var keylen = parseInt(algo.split('-')[1], 10) / 8
  var key = compat.pbkdf2Sync(password, salt, iters, keylen, 'sha1')
  var cipher = ciphers.createDecipheriv(algo, key, iv)
  var out = []
  out.push(cipher.update(cipherText))
  out.push(cipher.final())
  return Buffer.concat(out)
}


/***/ }),

/***/ "./node_modules/pbkdf2/browser.js":
/*!****************************************!*\
  !*** ./node_modules/pbkdf2/browser.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.pbkdf2 = __webpack_require__(/*! ./lib/async */ "./node_modules/pbkdf2/lib/async.js")
exports.pbkdf2Sync = __webpack_require__(/*! ./lib/sync */ "./node_modules/pbkdf2/lib/sync-browser.js")


/***/ }),

/***/ "./node_modules/pbkdf2/lib/async.js":
/*!******************************************!*\
  !*** ./node_modules/pbkdf2/lib/async.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {var checkParameters = __webpack_require__(/*! ./precondition */ "./node_modules/pbkdf2/lib/precondition.js")
var defaultEncoding = __webpack_require__(/*! ./default-encoding */ "./node_modules/pbkdf2/lib/default-encoding.js")
var sync = __webpack_require__(/*! ./sync */ "./node_modules/pbkdf2/lib/sync-browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var ZERO_BUF
var subtle = global.crypto && global.crypto.subtle
var toBrowser = {
  'sha': 'SHA-1',
  'sha-1': 'SHA-1',
  'sha1': 'SHA-1',
  'sha256': 'SHA-256',
  'sha-256': 'SHA-256',
  'sha384': 'SHA-384',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  'sha512': 'SHA-512'
}
var checks = []
function checkNative (algo) {
  if (global.process && !global.process.browser) {
    return Promise.resolve(false)
  }
  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false)
  }
  if (checks[algo] !== undefined) {
    return checks[algo]
  }
  ZERO_BUF = ZERO_BUF || Buffer.alloc(8)
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
    .then(function () {
      return true
    }).catch(function () {
      return false
    })
  checks[algo] = prom
  return prom
}

function browserPbkdf2 (password, salt, iterations, length, algo) {
  return subtle.importKey(
    'raw', password, {name: 'PBKDF2'}, false, ['deriveBits']
  ).then(function (key) {
    return subtle.deriveBits({
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: {
        name: algo
      }
    }, key, length << 3)
  }).then(function (res) {
    return Buffer.from(res)
  })
}

function resolvePromise (promise, callback) {
  promise.then(function (out) {
    process.nextTick(function () {
      callback(null, out)
    })
  }, function (e) {
    process.nextTick(function () {
      callback(e)
    })
  })
}
module.exports = function (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }

  digest = digest || 'sha1'
  var algo = toBrowser[digest.toLowerCase()]

  if (!algo || typeof global.Promise !== 'function') {
    return process.nextTick(function () {
      var out
      try {
        out = sync(password, salt, iterations, keylen, digest)
      } catch (e) {
        return callback(e)
      }
      callback(null, out)
    })
  }

  checkParameters(password, salt, iterations, keylen)
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)

  resolvePromise(checkNative(algo).then(function (resp) {
    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)

    return sync(password, salt, iterations, keylen, digest)
  }), callback)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/pbkdf2/lib/default-encoding.js":
/*!*****************************************************!*\
  !*** ./node_modules/pbkdf2/lib/default-encoding.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var defaultEncoding
/* istanbul ignore next */
if (process.browser) {
  defaultEncoding = 'utf-8'
} else {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)

  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'
}
module.exports = defaultEncoding

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/pbkdf2/lib/precondition.js":
/*!*************************************************!*\
  !*** ./node_modules/pbkdf2/lib/precondition.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

function checkBuffer (buf, name) {
  if (typeof buf !== 'string' && !Buffer.isBuffer(buf)) {
    throw new TypeError(name + ' must be a buffer or string')
  }
}

module.exports = function (password, salt, iterations, keylen) {
  checkBuffer(password, 'Password')
  checkBuffer(salt, 'Salt')

  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length')
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/pbkdf2/lib/sync-browser.js":
/*!*************************************************!*\
  !*** ./node_modules/pbkdf2/lib/sync-browser.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var md5 = __webpack_require__(/*! create-hash/md5 */ "./node_modules/create-hash/md5.js")
var RIPEMD160 = __webpack_require__(/*! ripemd160 */ "./node_modules/ripemd160/index.js")
var sha = __webpack_require__(/*! sha.js */ "./node_modules/sha.js/index.js")

var checkParameters = __webpack_require__(/*! ./precondition */ "./node_modules/pbkdf2/lib/precondition.js")
var defaultEncoding = __webpack_require__(/*! ./default-encoding */ "./node_modules/pbkdf2/lib/default-encoding.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var ZEROS = Buffer.alloc(128)
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
}

function Hmac (alg, key, saltLen) {
  var hash = getDigest(alg)
  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  if (key.length > blocksize) {
    key = hash(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])
  var opad = Buffer.allocUnsafe(blocksize + sizes[alg])
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)
  ipad.copy(ipad1, 0, 0, blocksize)
  this.ipad1 = ipad1
  this.ipad2 = ipad
  this.opad = opad
  this.alg = alg
  this.blocksize = blocksize
  this.hash = hash
  this.size = sizes[alg]
}

Hmac.prototype.run = function (data, ipad) {
  data.copy(ipad, this.blocksize)
  var h = this.hash(ipad)
  h.copy(this.opad, this.blocksize)
  return this.hash(this.opad)
}

function getDigest (alg) {
  function shaFunc (data) {
    return sha(alg).update(data).digest()
  }
  function rmd160Func (data) {
    return new RIPEMD160().update(data).digest()
  }

  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func
  if (alg === 'md5') return md5
  return shaFunc
}

function pbkdf2 (password, salt, iterations, keylen, digest) {
  checkParameters(password, salt, iterations, keylen)

  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)

  digest = digest || 'sha1'

  var hmac = new Hmac(digest, password, salt.length)

  var DK = Buffer.allocUnsafe(keylen)
  var block1 = Buffer.allocUnsafe(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var destPos = 0
  var hLen = sizes[digest]
  var l = Math.ceil(keylen / hLen)

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)

    var T = hmac.run(block1, hmac.ipad1)
    var U = T

    for (var j = 1; j < iterations; j++) {
      U = hmac.run(U, hmac.ipad2)
      for (var k = 0; k < hLen; k++) T[k] ^= U[k]
    }

    T.copy(DK, destPos)
    destPos += hLen
  }

  return DK
}

module.exports = pbkdf2


/***/ }),

/***/ "./node_modules/process-nextick-args/index.js":
/*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/public-encrypt/browser.js":
/*!************************************************!*\
  !*** ./node_modules/public-encrypt/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.publicEncrypt = __webpack_require__(/*! ./publicEncrypt */ "./node_modules/public-encrypt/publicEncrypt.js")
exports.privateDecrypt = __webpack_require__(/*! ./privateDecrypt */ "./node_modules/public-encrypt/privateDecrypt.js")

exports.privateEncrypt = function privateEncrypt (key, buf) {
  return exports.publicEncrypt(key, buf, true)
}

exports.publicDecrypt = function publicDecrypt (key, buf) {
  return exports.privateDecrypt(key, buf, true)
}


/***/ }),

/***/ "./node_modules/public-encrypt/mgf.js":
/*!********************************************!*\
  !*** ./node_modules/public-encrypt/mgf.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var createHash = __webpack_require__(/*! create-hash */ "./node_modules/create-hash/browser.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

module.exports = function (seed, len) {
  var t = Buffer.alloc(0)
  var i = 0
  var c
  while (t.length < len) {
    c = i2ops(i++)
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()])
  }
  return t.slice(0, len)
}

function i2ops (c) {
  var out = Buffer.allocUnsafe(4)
  out.writeUInt32BE(c, 0)
  return out
}


/***/ }),

/***/ "./node_modules/public-encrypt/privateDecrypt.js":
/*!*******************************************************!*\
  !*** ./node_modules/public-encrypt/privateDecrypt.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var parseKeys = __webpack_require__(/*! parse-asn1 */ "./node_modules/parse-asn1/index.js")
var mgf = __webpack_require__(/*! ./mgf */ "./node_modules/public-encrypt/mgf.js")
var xor = __webpack_require__(/*! ./xor */ "./node_modules/public-encrypt/xor.js")
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")
var crt = __webpack_require__(/*! browserify-rsa */ "./node_modules/browserify-rsa/index.js")
var createHash = __webpack_require__(/*! create-hash */ "./node_modules/create-hash/browser.js")
var withPublic = __webpack_require__(/*! ./withPublic */ "./node_modules/public-encrypt/withPublic.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

module.exports = function privateDecrypt (privateKey, enc, reverse) {
  var padding
  if (privateKey.padding) {
    padding = privateKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }

  var key = parseKeys(privateKey)
  var k = key.modulus.byteLength()
  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error')
  }
  var msg
  if (reverse) {
    msg = withPublic(new BN(enc), key)
  } else {
    msg = crt(enc, key)
  }
  var zBuffer = Buffer.alloc(k - msg.length)
  msg = Buffer.concat([zBuffer, msg], k)
  if (padding === 4) {
    return oaep(key, msg)
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    return msg
  } else {
    throw new Error('unknown padding')
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  if (msg[0] !== 0) {
    throw new Error('decryption error')
  }
  var maskedSeed = msg.slice(1, hLen + 1)
  var maskedDb = msg.slice(hLen + 1)
  var seed = xor(maskedSeed, mgf(maskedDb, hLen))
  var db = xor(maskedDb, mgf(seed, k - hLen - 1))
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error')
  }
  var i = hLen
  while (db[i] === 0) {
    i++
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error')
  }
  return db.slice(i)
}

function pkcs1 (key, msg, reverse) {
  var p1 = msg.slice(0, 2)
  var i = 2
  var status = 0
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++
      break
    }
  }
  var ps = msg.slice(2, i - 1)

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
    status++
  }
  if (ps.length < 8) {
    status++
  }
  if (status) {
    throw new Error('decryption error')
  }
  return msg.slice(i)
}
function compare (a, b) {
  a = Buffer.from(a)
  b = Buffer.from(b)
  var dif = 0
  var len = a.length
  if (a.length !== b.length) {
    dif++
    len = Math.min(a.length, b.length)
  }
  var i = -1
  while (++i < len) {
    dif += (a[i] ^ b[i])
  }
  return dif
}


/***/ }),

/***/ "./node_modules/public-encrypt/publicEncrypt.js":
/*!******************************************************!*\
  !*** ./node_modules/public-encrypt/publicEncrypt.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var parseKeys = __webpack_require__(/*! parse-asn1 */ "./node_modules/parse-asn1/index.js")
var randomBytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js")
var createHash = __webpack_require__(/*! create-hash */ "./node_modules/create-hash/browser.js")
var mgf = __webpack_require__(/*! ./mgf */ "./node_modules/public-encrypt/mgf.js")
var xor = __webpack_require__(/*! ./xor */ "./node_modules/public-encrypt/xor.js")
var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")
var withPublic = __webpack_require__(/*! ./withPublic */ "./node_modules/public-encrypt/withPublic.js")
var crt = __webpack_require__(/*! browserify-rsa */ "./node_modules/browserify-rsa/index.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

module.exports = function publicEncrypt (publicKey, msg, reverse) {
  var padding
  if (publicKey.padding) {
    padding = publicKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }
  var key = parseKeys(publicKey)
  var paddedMsg
  if (padding === 4) {
    paddedMsg = oaep(key, msg)
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    paddedMsg = new BN(msg)
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus')
    }
  } else {
    throw new Error('unknown padding')
  }
  if (reverse) {
    return crt(paddedMsg, key)
  } else {
    return withPublic(paddedMsg, key)
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var mLen = msg.length
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  var hLen2 = 2 * hLen
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long')
  }
  var ps = Buffer.alloc(k - mLen - hLen2 - 2)
  var dblen = k - hLen - 1
  var seed = randomBytes(hLen)
  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))
  var maskedSeed = xor(seed, mgf(maskedDb, hLen))
  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))
}
function pkcs1 (key, msg, reverse) {
  var mLen = msg.length
  var k = key.modulus.byteLength()
  if (mLen > k - 11) {
    throw new Error('message too long')
  }
  var ps
  if (reverse) {
    ps = Buffer.alloc(k - mLen - 3, 0xff)
  } else {
    ps = nonZero(k - mLen - 3)
  }
  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))
}
function nonZero (len) {
  var out = Buffer.allocUnsafe(len)
  var i = 0
  var cache = randomBytes(len * 2)
  var cur = 0
  var num
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len * 2)
      cur = 0
    }
    num = cache[cur++]
    if (num) {
      out[i++] = num
    }
  }
  return out
}


/***/ }),

/***/ "./node_modules/public-encrypt/withPublic.js":
/*!***************************************************!*\
  !*** ./node_modules/public-encrypt/withPublic.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

function withPublic (paddedMsg, key) {
  return Buffer.from(paddedMsg
    .toRed(BN.mont(key.modulus))
    .redPow(new BN(key.publicExponent))
    .fromRed()
    .toArray())
}

module.exports = withPublic


/***/ }),

/***/ "./node_modules/public-encrypt/xor.js":
/*!********************************************!*\
  !*** ./node_modules/public-encrypt/xor.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function xor (a, b) {
  var len = a.length
  var i = -1
  while (++i < len) {
    a[i] ^= b[i]
  }
  return a
}


/***/ }),

/***/ "./node_modules/randombytes/browser.js":
/*!*********************************************!*\
  !*** ./node_modules/randombytes/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/randomfill/browser.js":
/*!********************************************!*\
  !*** ./node_modules/randomfill/browser.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

function oldBrowser () {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
}
var safeBuffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js")
var randombytes = __webpack_require__(/*! randombytes */ "./node_modules/randombytes/browser.js")
var Buffer = safeBuffer.Buffer
var kBufferMaxLength = safeBuffer.kMaxLength
var crypto = global.crypto || global.msCrypto
var kMaxUint32 = Math.pow(2, 32) - 1
function assertOffset (offset, length) {
  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare
    throw new TypeError('offset must be a number')
  }

  if (offset > kMaxUint32 || offset < 0) {
    throw new TypeError('offset must be a uint32')
  }

  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError('offset out of range')
  }
}

function assertSize (size, offset, length) {
  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare
    throw new TypeError('size must be a number')
  }

  if (size > kMaxUint32 || size < 0) {
    throw new TypeError('size must be a uint32')
  }

  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError('buffer too small')
  }
}
if ((crypto && crypto.getRandomValues) || !process.browser) {
  exports.randomFill = randomFill
  exports.randomFillSync = randomFillSync
} else {
  exports.randomFill = oldBrowser
  exports.randomFillSync = oldBrowser
}
function randomFill (buf, offset, size, cb) {
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  if (typeof offset === 'function') {
    cb = offset
    offset = 0
    size = buf.length
  } else if (typeof size === 'function') {
    cb = size
    size = buf.length - offset
  } else if (typeof cb !== 'function') {
    throw new TypeError('"cb" argument must be a function')
  }
  assertOffset(offset, buf.length)
  assertSize(size, offset, buf.length)
  return actualFill(buf, offset, size, cb)
}

function actualFill (buf, offset, size, cb) {
  if (process.browser) {
    var ourBuf = buf.buffer
    var uint = new Uint8Array(ourBuf, offset, size)
    crypto.getRandomValues(uint)
    if (cb) {
      process.nextTick(function () {
        cb(null, buf)
      })
      return
    }
    return buf
  }
  if (cb) {
    randombytes(size, function (err, bytes) {
      if (err) {
        return cb(err)
      }
      bytes.copy(buf, offset)
      cb(null, buf)
    })
    return
  }
  var bytes = randombytes(size)
  bytes.copy(buf, offset)
  return buf
}
function randomFillSync (buf, offset, size) {
  if (typeof offset === 'undefined') {
    offset = 0
  }
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  assertOffset(offset, buf.length)

  if (size === undefined) size = buf.length - offset

  assertSize(size, offset, buf.length)

  return actualFill(buf, offset, size)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/readable-stream/duplex-browser.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/duplex-browser.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");


/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

var Readable = __webpack_require__(/*! ./_stream_readable */ "./node_modules/readable-stream/lib/_stream_readable.js");
var Writable = __webpack_require__(/*! ./_stream_writable */ "./node_modules/readable-stream/lib/_stream_writable.js");

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(/*! ./_stream_transform */ "./node_modules/readable-stream/lib/_stream_transform.js");

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__(/*! events */ "./node_modules/node-libs-browser/node_modules/events/events.js").EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(/*! util */ 1);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ "./node_modules/readable-stream/lib/internal/streams/BufferList.js");
var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(/*! util-deprecate */ "./node_modules/util-deprecate/browser.js")
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../node-libs-browser/node_modules/timers-browserify/main.js */ "./node_modules/node-libs-browser/node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!*************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
var util = __webpack_require__(/*! util */ 2);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! events */ "./node_modules/node-libs-browser/node_modules/events/events.js").EventEmitter;


/***/ }),

/***/ "./node_modules/readable-stream/passthrough.js":
/*!*****************************************************!*\
  !*** ./node_modules/readable-stream/passthrough.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./readable */ "./node_modules/readable-stream/readable-browser.js").PassThrough


/***/ }),

/***/ "./node_modules/readable-stream/readable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ "./node_modules/readable-stream/lib/_stream_readable.js");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");
exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");
exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ "./node_modules/readable-stream/lib/_stream_transform.js");
exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "./node_modules/readable-stream/lib/_stream_passthrough.js");


/***/ }),

/***/ "./node_modules/readable-stream/transform.js":
/*!***************************************************!*\
  !*** ./node_modules/readable-stream/transform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./readable */ "./node_modules/readable-stream/readable-browser.js").Transform


/***/ }),

/***/ "./node_modules/readable-stream/writable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/writable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");


/***/ }),

/***/ "./node_modules/ripemd160/index.js":
/*!*****************************************!*\
  !*** ./node_modules/ripemd160/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! buffer */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var HashBase = __webpack_require__(/*! hash-base */ "./node_modules/hash-base/index.js")

var ARRAY16 = new Array(16)

var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var words = ARRAY16
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

  var al = this._a | 0
  var bl = this._b | 0
  var cl = this._c | 0
  var dl = this._d | 0
  var el = this._e | 0

  var ar = this._a | 0
  var br = this._b | 0
  var cr = this._c | 0
  var dr = this._d | 0
  var er = this._e | 0

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl
    var tr
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
    } else { // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
    }

    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = tl

    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = tr
  }

  // update state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160


/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/node-libs-browser/node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/sha.js/hash.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/hash.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash


/***/ }),

/***/ "./node_modules/sha.js/index.js":
/*!**************************************!*\
  !*** ./node_modules/sha.js/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = __webpack_require__(/*! ./sha */ "./node_modules/sha.js/sha.js")
exports.sha1 = __webpack_require__(/*! ./sha1 */ "./node_modules/sha.js/sha1.js")
exports.sha224 = __webpack_require__(/*! ./sha224 */ "./node_modules/sha.js/sha224.js")
exports.sha256 = __webpack_require__(/*! ./sha256 */ "./node_modules/sha.js/sha256.js")
exports.sha384 = __webpack_require__(/*! ./sha384 */ "./node_modules/sha.js/sha384.js")
exports.sha512 = __webpack_require__(/*! ./sha512 */ "./node_modules/sha.js/sha512.js")


/***/ }),

/***/ "./node_modules/sha.js/sha.js":
/*!************************************!*\
  !*** ./node_modules/sha.js/sha.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha


/***/ }),

/***/ "./node_modules/sha.js/sha1.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/sha1.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1


/***/ }),

/***/ "./node_modules/sha.js/sha224.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha224.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Sha256 = __webpack_require__(/*! ./sha256 */ "./node_modules/sha.js/sha256.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224


/***/ }),

/***/ "./node_modules/sha.js/sha256.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha256.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256


/***/ }),

/***/ "./node_modules/sha.js/sha384.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha384.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var SHA512 = __webpack_require__(/*! ./sha512 */ "./node_modules/sha.js/sha512.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384


/***/ }),

/***/ "./node_modules/sha.js/sha512.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha512.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512


/***/ }),

/***/ "./node_modules/stream-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = __webpack_require__(/*! events */ "./node_modules/node-libs-browser/node_modules/events/events.js").EventEmitter;
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

inherits(Stream, EE);
Stream.Readable = __webpack_require__(/*! readable-stream/readable.js */ "./node_modules/readable-stream/readable-browser.js");
Stream.Writable = __webpack_require__(/*! readable-stream/writable.js */ "./node_modules/readable-stream/writable-browser.js");
Stream.Duplex = __webpack_require__(/*! readable-stream/duplex.js */ "./node_modules/readable-stream/duplex-browser.js");
Stream.Transform = __webpack_require__(/*! readable-stream/transform.js */ "./node_modules/readable-stream/transform.js");
Stream.PassThrough = __webpack_require__(/*! readable-stream/passthrough.js */ "./node_modules/readable-stream/passthrough.js");

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};


/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/vm-browserify/index.js":
/*!*********************************************!*\
  !*** ./node_modules/vm-browserify/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var indexOf = __webpack_require__(/*! indexof */ "./node_modules/indexof/index.js");

var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    forEach(Object_keys(ctx), function (key) {
        context[key] = ctx[key];
    });

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./src/core/sketch_support.ts":
/*!************************************!*\
  !*** ./src/core/sketch_support.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function stringToUint8array(b64encoded) {
    var u8 = new Uint8Array(atob(b64encoded)
        .split("")
        .map(function (c) {
        return c.charCodeAt(0);
    }));
    return u8;
}
exports.stringToUint8array = stringToUint8array;
function stringToArray(b64encoded) {
    var u = stringToUint8array(b64encoded);
    var result = new Int16Array(u.buffer);
    return result;
}
exports.stringToArray = stringToArray;
var returnV = false;
var vVal = 0.0;
function gaussRandom() {
    if (returnV) {
        returnV = false;
        return vVal;
    }
    var u = 2 * Math.random() - 1;
    var v = 2 * Math.random() - 1;
    var r = u * u + v * v;
    if (r === 0 || r > 1) {
        return gaussRandom();
    }
    var c = Math.sqrt(-2 * Math.log(r) / r);
    vVal = v * c;
    returnV = true;
    return u * c;
}
exports.gaussRandom = gaussRandom;
function randf(a, b) {
    return Math.random() * (b - a) + a;
}
exports.randf = randf;
function randi(a, b) {
    return Math.floor(Math.random() * (b - a) + a);
}
exports.randi = randi;
function randn(mu, std) {
    return mu + gaussRandom() * std;
}
exports.randn = randn;
function birandn(mu1, mu2, std1, std2, rho) {
    var z1 = randn(0, 1);
    var z2 = randn(0, 1);
    var x = Math.sqrt(1 - rho * rho) * std1 * z1 + rho * std1 * z2 + mu1;
    var y = std2 * z2 + mu2;
    return [x, y];
}
exports.birandn = birandn;
function sampleSoftmax(zSample) {
    var x = randf(0, 1);
    var N = zSample.length;
    var accumulate = 0;
    var i;
    for (i = 0; i < N; i++) {
        accumulate += zSample[i];
        if (accumulate >= x) {
            return i;
        }
    }
    console.log('error sampling pi index');
    return -1;
}
exports.sampleSoftmax = sampleSoftmax;
function simplifyLine(V, tolerance) {
    if (tolerance === void 0) { tolerance = 2.0; }
    var tol = tolerance;
    function diff(u, v) {
        return [u[0] - v[0], u[1] - v[1]];
    }
    function dot(u, v) {
        return u[0] * v[0] + u[1] * v[1];
    }
    function norm2(v) {
        return v[0] * v[0] + v[1] * v[1];
    }
    function d2(u, v) { return norm2(diff(u, v)); }
    function simplifyDP(tol, v, j, k, mk) {
        if (k <= j + 1) {
            return;
        }
        var maxi = j;
        var maxd2 = 0;
        var tol2 = tol * tol;
        var S = [v[j], v[k]];
        var u = diff(S[1], S[0]);
        var cu = norm2(u);
        var w;
        var pb;
        var b, cw, dv2;
        for (var i_1 = j + 1; i_1 < k; i_1++) {
            w = diff(v[i_1], S[0]);
            cw = dot(w, u);
            if (cw <= 0) {
                dv2 = d2(v[i_1], S[0]);
            }
            else if (cu <= cw) {
                dv2 = d2(v[i_1], S[1]);
            }
            else {
                b = cw / cu;
                pb = [S[0][0] + b * u[0], S[0][1] + b * u[1]];
                dv2 = d2(v[i_1], pb);
            }
            if (dv2 <= maxd2) {
                continue;
            }
            maxi = i_1;
            maxd2 = dv2;
        }
        if (maxd2 > tol2) {
            mk[maxi] = 1;
            simplifyDP(tol, v, j, maxi, mk);
            simplifyDP(tol, v, maxi, k, mk);
        }
        return;
    }
    var n = V.length;
    var sV = [];
    var i, k, m, pv;
    var tol2 = tol * tol;
    var vt = [];
    var mk = [];
    vt[0] = V[0];
    for (i = k = 1, pv = 0; i < n; i++) {
        if (d2(V[i], V[pv]) < tol2) {
            continue;
        }
        vt[k++] = V[i];
        pv = i;
    }
    if (pv < n - 1) {
        vt[k++] = V[n - 1];
    }
    mk[0] = mk[k - 1] = 1;
    simplifyDP(tol, vt, 0, k - 1, mk);
    for (i = m = 0; i < k; i++) {
        if (mk[i]) {
            sV[m++] = vt[i];
        }
    }
    return sV;
}
exports.simplifyLine = simplifyLine;
function simplifyLines(lines, tolerance) {
    var result = [];
    var tol = 2.0;
    if (tolerance) {
        tol = tolerance;
    }
    for (var i = 0; i < lines.length; i++) {
        result.push(simplifyLine(lines[i], tol));
    }
    return result;
}
exports.simplifyLines = simplifyLines;
function linesToStrokes(rawData) {
    var x, y;
    var px = 0, py = 0;
    var dx, dy;
    var pon, poff;
    var stroke = [];
    var i, j;
    var len;
    var p;
    for (i = 0; i < rawData.length; i++) {
        len = rawData[i].length;
        if (len > 1) {
            for (j = 0; j < len; j++) {
                p = rawData[i][j];
                x = p[0];
                y = p[1];
                if (j === len - 1) {
                    poff = 1;
                    pon = 0;
                }
                else {
                    poff = 0;
                    pon = 1;
                }
                dx = x - px;
                dy = y - py;
                px = x;
                py = y;
                stroke.push([dx, dy, pon, poff, 0]);
            }
        }
    }
    stroke.push([0, 0, 0, 0, 1]);
    return stroke.slice(1);
}
exports.linesToStrokes = linesToStrokes;
function lineToStroke(line, lastPoint) {
    var pon, poff;
    var stroke = [];
    var len;
    var p;
    var dx, dy;
    var x, y;
    var px, py;
    var j;
    px = lastPoint[0];
    py = lastPoint[1];
    len = line.length;
    if (len > 1) {
        for (j = 0; j < len; j++) {
            p = line[j];
            x = p[0];
            y = p[1];
            if (j === len - 1) {
                poff = 1;
                pon = 0;
            }
            else {
                poff = 0;
                pon = 1;
            }
            dx = x - px;
            dy = y - py;
            px = x;
            py = y;
            stroke.push([dx, dy, pon, poff, 0]);
        }
    }
    return stroke;
}
exports.lineToStroke = lineToStroke;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var tf = __webpack_require__(/*! @tensorflow/tfjs */ "./node_modules/@tensorflow/tfjs/dist/tf.esm.js");
exports.tf = tf;
__export(__webpack_require__(/*! ./sketch_rnn */ "./src/sketch_rnn/index.ts"));


/***/ }),

/***/ "./src/sketch_rnn/index.ts":
/*!*********************************!*\
  !*** ./src/sketch_rnn/index.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var model_1 = __webpack_require__(/*! ./model */ "./src/sketch_rnn/model.ts");
exports.SketchRNN = model_1.SketchRNN;


/***/ }),

/***/ "./src/sketch_rnn/model.ts":
/*!*********************************!*\
  !*** ./src/sketch_rnn/model.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tf = __webpack_require__(/*! @tensorflow/tfjs-core */ "./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js");
var support = __webpack_require__(/*! ../core/sketch_support */ "./src/core/sketch_support.ts");
var SketchRNN = (function () {
    function SketchRNN(checkpointURL) {
        this.NMIXTURE = 20;
        this.checkpointURL = checkpointURL;
        this.initialized = false;
    }
    SketchRNN.prototype.isInitialized = function () {
        return this.initialized;
    };
    SketchRNN.prototype.instantiateFromJSON = function (info, weightDims, weightStrings) {
        this.forgetBias = tf.scalar(1.0);
        this.info = info;
        this.setPixelFactor(2.0);
        this.weightDims = weightDims;
        this.numUnits = this.weightDims[0][0];
        var rawWeights;
        var maxWeight = 10.0;
        this.weights = [];
        for (var i = 0; i < weightStrings.length; i++) {
            rawWeights = new Float32Array(support.stringToArray(weightStrings[i]));
            var N = rawWeights.length;
            for (var j = 0; j < N; j++) {
                rawWeights[j] = maxWeight * rawWeights[j] / 32767;
            }
            this.weights.push(rawWeights);
        }
        this.outputKernel = tf.tensor2d(this.weights[0], [this.weightDims[0][0], this.weightDims[0][1]]);
        this.outputBias = tf.tensor1d(this.weights[1]);
        var lstmKernelXH = tf.tensor2d(this.weights[2], [this.weightDims[2][0], this.weightDims[2][1]]);
        var lstmKernelHH = tf.tensor2d(this.weights[3], [this.weightDims[3][0], this.weightDims[3][1]]);
        var axis = 0;
        this.lstmKernel = tf.concat2d([lstmKernelXH, lstmKernelHH], axis);
        this.lstmBias = tf.tensor1d(this.weights[4]);
        this.rawVars = [
            this.outputKernel,
            this.outputBias,
            this.lstmKernel,
            this.lstmBias
        ];
    };
    SketchRNN.prototype.initialize = function () {
        return __awaiter(this, void 0, void 0, function () {
            var vars;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.dispose();
                        return [4, fetch(this.checkpointURL)
                                .then(function (response) { return response.json(); })];
                    case 1:
                        vars = _a.sent();
                        this.instantiateFromJSON(vars[0], vars[1], vars[2]);
                        this.initialized = true;
                        console.log('Initialized SketchRNN.');
                        return [2];
                }
            });
        });
    };
    SketchRNN.prototype.dispose = function () {
        if (this.rawVars) {
            for (var i = 0; i < this.rawVars.length; i++) {
                this.rawVars[i].dispose();
            }
            this.rawVars = undefined;
        }
        if (this.forgetBias) {
            this.forgetBias.dispose();
            this.forgetBias = undefined;
        }
        this.initialized = false;
    };
    SketchRNN.prototype.setPixelFactor = function (scale) {
        this.pixelFactor = scale;
        this.scaleFactor = this.info.scale_factor / this.pixelFactor;
    };
    SketchRNN.prototype.update = function (stroke, state) {
        var _this = this;
        var out = tf.tidy(function () {
            var numUnits = _this.numUnits;
            var s = _this.scaleFactor;
            var normStroke = [stroke[0] / s, stroke[1] / s, stroke[2], stroke[3], stroke[4]];
            var x = tf.tensor2d(normStroke, [1, 5]);
            var c = tf.tensor2d(state.c, [1, numUnits]);
            var h = tf.tensor2d(state.h, [1, numUnits]);
            var newState = tf.basicLSTMCell(_this.forgetBias, _this.lstmKernel, _this.lstmBias, x, c, h);
            return tf.concat(newState, 1);
        });
        var newCH = out.dataSync();
        out.dispose();
        var newC = newCH.slice(0, this.numUnits);
        var newH = newCH.slice(this.numUnits, this.numUnits * 2);
        var finalState = {
            c: new Float32Array(newC),
            h: new Float32Array(newH)
        };
        return finalState;
    };
    SketchRNN.prototype.updateStrokes = function (strokes, state, steps) {
        var _this = this;
        var out = tf.tidy(function () {
            var numUnits = _this.numUnits;
            var s = _this.scaleFactor;
            var normStroke;
            var x;
            var c;
            var h;
            var newState;
            var numSteps = strokes.length;
            if (steps) {
                numSteps = steps;
            }
            c = tf.tensor2d(state.c, [1, numUnits]);
            h = tf.tensor2d(state.h, [1, numUnits]);
            for (var i = 0; i < numSteps; i++) {
                normStroke = [strokes[i][0] / s,
                    strokes[i][1] / s,
                    strokes[i][2],
                    strokes[i][3],
                    strokes[i][4]];
                x = tf.tensor2d(normStroke, [1, 5]);
                newState = tf.basicLSTMCell(_this.forgetBias, _this.lstmKernel, _this.lstmBias, x, c, h);
                c = newState[0];
                h = newState[1];
            }
            return tf.concat(newState, 1);
        });
        var newCH = out.dataSync();
        out.dispose();
        var newC = newCH.slice(0, this.numUnits);
        var newH = newCH.slice(this.numUnits, this.numUnits * 2);
        var finalState = {
            c: new Float32Array(newC),
            h: new Float32Array(newH)
        };
        return finalState;
    };
    SketchRNN.prototype.getPDF = function (state, temperature, softmaxTemperature) {
        var _this = this;
        if (temperature === void 0) { temperature = 0.65; }
        var temp = temperature;
        var discreteTemp = 0.5 + temp * 0.5;
        if (softmaxTemperature) {
            discreteTemp = softmaxTemperature;
        }
        var NOUT = this.NMIXTURE;
        var out = tf.tidy(function () {
            var numUnits = _this.numUnits;
            var h = tf.tensor2d(state.h, [1, numUnits]);
            var sqrttemp = tf.scalar(Math.sqrt(temp));
            var softtemp = tf.scalar(discreteTemp);
            var z = tf.add(tf.matMul(h, _this.outputKernel), _this.outputBias)
                .squeeze();
            var _a = tf.split(z, [3, NOUT * 6]), rawPen = _a[0], rst = _a[1];
            var _b = tf.split(rst, 6), rawPi = _b[0], mu1 = _b[1], mu2 = _b[2], rawSigma1 = _b[3], rawSigma2 = _b[4], rawCorr = _b[5];
            var pen = tf.softmax(rawPen.div(softtemp));
            var pi = tf.softmax(rawPi.div(softtemp));
            var sigma1 = tf.exp(rawSigma1).mul(sqrttemp);
            var sigma2 = tf.exp(rawSigma2).mul(sqrttemp);
            var corr = tf.tanh(rawCorr);
            var result = [pi, mu1, mu2, sigma1, sigma2, corr, pen];
            return tf.concat(result);
        });
        var result = out.dataSync();
        out.dispose();
        var pdf = {
            pi: new Float32Array(result.slice(0, NOUT)),
            muX: new Float32Array(result.slice(1 * NOUT, 2 * NOUT)),
            muY: new Float32Array(result.slice(2 * NOUT, 3 * NOUT)),
            sigmaX: new Float32Array(result.slice(3 * NOUT, 4 * NOUT)),
            sigmaY: new Float32Array(result.slice(4 * NOUT, 15 * NOUT)),
            corr: new Float32Array(result.slice(5 * NOUT, 6 * NOUT)),
            pen: new Float32Array(result.slice(6 * NOUT, 6 * NOUT + 3))
        };
        return pdf;
    };
    SketchRNN.prototype.zeroState = function () {
        var result = {
            c: new Float32Array(this.numUnits),
            h: new Float32Array(this.numUnits)
        };
        return result;
    };
    SketchRNN.prototype.copyState = function (rnnState) {
        var result = {
            c: new Float32Array(rnnState.c),
            h: new Float32Array(rnnState.h)
        };
        return result;
    };
    SketchRNN.prototype.zeroInput = function () {
        return [0, 0, 1, 0, 0];
    };
    SketchRNN.prototype.sample = function (pdf) {
        var idx = support.sampleSoftmax(pdf.pi);
        var mu1 = pdf.muX[idx];
        var mu2 = pdf.muY[idx];
        var sigma1 = pdf.sigmaX[idx];
        var sigma2 = pdf.sigmaY[idx];
        var corr = pdf.corr[idx];
        var penIdx = support.sampleSoftmax(pdf.pen);
        var penstate = [0, 0, 0];
        penstate[penIdx] = 1;
        var delta = support.birandn(mu1, mu2, sigma1, sigma2, corr);
        var stroke = [
            delta[0] * this.scaleFactor,
            delta[1] * this.scaleFactor,
            penstate[0],
            penstate[1],
            penstate[2]
        ];
        return stroke;
    };
    SketchRNN.prototype.simplifyLine = function (line, tolerance) {
        return support.simplifyLine(line, tolerance);
    };
    SketchRNN.prototype.simplifyLines = function (lines, tolerance) {
        return support.simplifyLines(lines, tolerance);
    };
    SketchRNN.prototype.linesToStroke = function (lines) {
        return support.linesToStrokes(lines);
    };
    SketchRNN.prototype.lineToStroke = function (line, lastPoint) {
        return support.lineToStroke(line, lastPoint);
    };
    return SketchRNN;
}());
exports.SketchRNN = SketchRNN;


/***/ }),

/***/ 0:
/*!****************************!*\
  !*** node-fetch (ignored) ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 2:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 3:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 4:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 5:
/*!****************************!*\
  !*** node-fetch (ignored) ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 6:
/*!********************************!*\
  !*** string_decoder (ignored) ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 7:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vZGVtb3Mvc2ltcGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlci9kaXN0L3RmLWNvbnZlcnRlci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29yZS9kaXN0L3RmLWNvcmUuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWRhdGEvZGlzdC90Zi1kYXRhLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1sYXllcnMvZGlzdC90Zi1sYXllcnMuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzL2Rpc3QvdGYuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2FwaS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9iYXNlL2J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9iYXNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2Jhc2Uvbm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9iYXNlL3JlcG9ydGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2NvbnN0YW50cy9kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvY29uc3RhbnRzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2RlY29kZXJzL2Rlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9kZWNvZGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS5qcy9saWIvYXNuMS9kZWNvZGVycy9wZW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzbjEuanMvbGliL2FzbjEvZW5jb2RlcnMvZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc24xLmpzL2xpYi9hc24xL2VuY29kZXJzL3BlbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibi5qcy9saWIvYm4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3JhbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2Flcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvYXV0aENpcGhlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvZGVjcnlwdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9lbmNyeXB0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL2doYXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9pbmNyMzIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2NiYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvY2ZiLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jZmIxLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jZmI4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWFlcy9tb2Rlcy9jdHIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL2VjYi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvbW9kZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktYWVzL21vZGVzL29mYi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1hZXMvc3RyZWFtQ2lwaGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWNpcGhlci9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LWRlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1kZXMvbW9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktcnNhL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vYWxnb3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktc2lnbi9icm93c2VyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vYnJvd3Nlci9zaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vYnJvd3Nlci92ZXJpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci14b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NpcGhlci1iYXNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1lY2RoL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL21kNS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JlYXRlLWhtYWMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JlYXRlLWhtYWMvbGVnYWN5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVzLmpzL2xpYi9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rlcy5qcy9saWIvZGVzL2NiYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVzLmpzL2xpYi9kZXMvY2lwaGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZXMuanMvbGliL2Rlcy9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Rlcy5qcy9saWIvZGVzL2VkZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVzLmpzL2xpYi9kZXMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpZmZpZS1oZWxsbWFuL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RpZmZpZS1oZWxsbWFuL2xpYi9kaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGlmZmllLWhlbGxtYW4vbGliL2dlbmVyYXRlUHJpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL2Jhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9lZHdhcmRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9tb250LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvc2hvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VjL2tleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VjL3NpZ25hdHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VkZHNhL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWRkc2Eva2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWRkc2Evc2lnbmF0dXJlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvcHJlY29tcHV0ZWQvc2VjcDI1NmsxLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V2cF9ieXRlc3Rva2V5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLWJhc2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvY29tbW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL2htYWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvcmlwZW1kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMjI0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS8yNTYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLzM4NC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvNTEyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2htYWMtZHJiZy9saWIvaG1hYy1kcmJnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmRleG9mL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZDUuanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pbGxlci1yYWJpbi9saWIvbXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pbmltYWxpc3RpYy1hc3NlcnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21pbmltYWxpc3RpYy1jcnlwdG8tdXRpbHMvbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BhcnNlLWFzbjEvYXNuMS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9jZXJ0aWZpY2F0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFyc2UtYXNuMS9maXhQcm9jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXJzZS1hc24xL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYmtkZjIvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGJrZGYyL2xpYi9hc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGJrZGYyL2xpYi9kZWZhdWx0LWVuY29kaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYmtkZjIvbGliL3ByZWNvbmRpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGJrZGYyL2xpYi9zeW5jLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L21nZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHVibGljLWVuY3J5cHQvcHJpdmF0ZURlY3J5cHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L3B1YmxpY0VuY3J5cHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L3dpdGhQdWJsaWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3B1YmxpYy1lbmNyeXB0L3hvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFuZG9tYnl0ZXMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFuZG9tZmlsbC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUtYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmlwZW1kMTYwL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2hhLmpzL2hhc2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEyMjQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEyNTYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEzODQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGE1MTIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3ZtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL3NyYy9jb3JlL3NrZXRjaF9zdXBwb3J0LnRzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc2tldGNoX3Jubi9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc2tldGNoX3Jubi9tb2RlbC50cyIsIndlYnBhY2s6Ly8vbm9kZS1mZXRjaCAoaWdub3JlZCk/OWE2YyIsIndlYnBhY2s6Ly8vdXRpbCAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vL3V0aWwgKGlnbm9yZWQpPzk2MDEiLCJ3ZWJwYWNrOi8vL2J1ZmZlciAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vL2NyeXB0byAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vL25vZGUtZmV0Y2ggKGlnbm9yZWQpIiwid2VicGFjazovLy9zdHJpbmdfZGVjb2RlciAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vL2ZzIChpZ25vcmVkKSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBMEMsZ0NBQWdDO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQXdELGtCQUFrQjtBQUMxRTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBeUMsaUNBQWlDO0FBQzFFLHdIQUFnSCxtQkFBbUIsRUFBRTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtQzs7QUFFbkM7QUFDQSxpQkFBaUI7QUFDakIsMkJBQTJCO0FBQzNCOztBQUVBLGFBQWE7QUFDYixXQUFXO0FBQ1gsb0JBQW9CO0FBQ3BCLDhCQUE4QjtBQUM5Qixl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QixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsbURBQW1ELCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLDRCQUE0QixVQUFVLFdBQVcsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsc0RBQXNELCtCQUErQixVQUFVLDBEQUEwRCxFQUFFLDBEQUEwRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLHVFQUF1RSxFQUFFLHVFQUF1RSxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsa0RBQWtELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsaURBQWlELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUscURBQXFELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsbURBQW1ELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixFQUFFLG9DQUFvQyxVQUFVLCtEQUErRCxFQUFFLHFEQUFxRCxFQUFFLEVBQUUsb0RBQW9ELCtCQUErQixVQUFVLDBEQUEwRCxFQUFFLHFEQUFxRCxFQUFFLDJCQUEyQixZQUFZLFdBQVcsZ0RBQWdELGtDQUFrQyxFQUFFLEVBQUUsOENBQThDLGtDQUFrQyxFQUFFLGtDQUFrQyxFQUFFLEVBQUUsNkNBQTZDLDRDQUE0QyxFQUFFLEVBQUUsNkNBQTZDLG9DQUFvQyxVQUFVLHFEQUFxRCxFQUFFLG1EQUFtRCxFQUFFLG1EQUFtRCxFQUFFLEVBQUUsNENBQTRDLG9DQUFvQyxVQUFVLHFEQUFxRCxFQUFFLEVBQUUscURBQXFELG9DQUFvQyxVQUFVLHFEQUFxRCxFQUFFLEVBQUUscURBQXFELGtDQUFrQyxVQUFVLHlDQUF5QyxFQUFFLHdEQUF3RCxFQUFFLHFEQUFxRCxFQUFFLDREQUE0RCxFQUFFLDRFQUE0RSxFQUFFLHFEQUFxRCxFQUFFLEVBQUUsMERBQTBELDJDQUEyQyxFQUFFLG1DQUFtQyxFQUFFLG9DQUFvQyxFQUFFLG9DQUFvQyxVQUFVLHFEQUFxRCxFQUFFLEVBQUUseURBQXlELDJDQUEyQyxFQUFFLG1DQUFtQyxFQUFFLG9DQUFvQyxVQUFVLHlEQUF5RCxFQUFFLEVBQUUsMkRBQTJELDJDQUEyQyxFQUFFLHVDQUF1QyxFQUFFLG9DQUFvQyxVQUFVLHlDQUF5QyxFQUFFLHdEQUF3RCxFQUFFLEVBQUUsNERBQTRELDJDQUEyQyxFQUFFLHVDQUF1QyxFQUFFLG9DQUFvQyxFQUFFLG9DQUFvQyxVQUFVLHFDQUFxQyxFQUFFLEVBQUUsMkRBQTJELDJDQUEyQyxFQUFFLG9DQUFvQyxVQUFVLHlDQUF5QyxFQUFFLHVGQUF1RixFQUFFLEVBQUUsMERBQTBELDJDQUEyQyxFQUFFLG9DQUFvQyxFQUFFLHVDQUF1QyxFQUFFLG9DQUFvQyxVQUFVLHFDQUFxQyxFQUFFLEVBQUUseURBQXlELDJDQUEyQyxFQUFFLG9DQUFvQyxFQUFFLEVBQUUsMERBQTBELDJDQUEyQyxFQUFFLHlCQUF5QixZQUFZLFdBQVcsbURBQW1ELCtCQUErQixVQUFVLGdEQUFnRCxFQUFFLDBDQUEwQyxFQUFFLHFFQUFxRSxFQUFFLGlEQUFpRCxFQUFFLHFEQUFxRCxFQUFFLEVBQUUsbURBQW1ELCtCQUErQixVQUFVLGdEQUFnRCxFQUFFLDBDQUEwQyxFQUFFLHFFQUFxRSxFQUFFLGlEQUFpRCxFQUFFLHFEQUFxRCxFQUFFLEVBQUUsa0RBQWtELCtCQUErQixFQUFFLG9DQUFvQyxVQUFVLDRDQUE0QyxFQUFFLDBDQUEwQyxFQUFFLHdFQUF3RSxFQUFFLHFEQUFxRCxFQUFFLCtEQUErRCxFQUFFLEVBQUUsa0RBQWtELCtCQUErQixFQUFFLG9DQUFvQyxVQUFVLHFEQUFxRCxFQUFFLGdEQUFnRCxFQUFFLDBDQUEwQyxFQUFFLHdEQUF3RCxFQUFFLHlFQUF5RSxFQUFFLG9EQUFvRCxFQUFFLEVBQUUsK0RBQStELCtCQUErQixFQUFFLG9DQUFvQyxFQUFFLDJDQUEyQyxVQUFVLGdEQUFnRCxFQUFFLDBDQUEwQyxFQUFFLHFFQUFxRSxFQUFFLEVBQUUsMkRBQTJELG1DQUFtQyxFQUFFLG9DQUFvQyxVQUFVLGdEQUFnRCxFQUFFLDBDQUEwQyxFQUFFLHlFQUF5RSxFQUFFLG9EQUFvRCxFQUFFLEVBQUUsaUVBQWlFLG1DQUFtQyxFQUFFLG9DQUFvQyxVQUFVLGdEQUFnRCxFQUFFLDBDQUEwQyxFQUFFLHlFQUF5RSxFQUFFLG9EQUFvRCxFQUFFLDZCQUE2QixZQUFZLFdBQVcsNkNBQTZDLHFDQUFxQyxFQUFFLG1DQUFtQyxVQUFVLHFDQUFxQyxFQUFFLEVBQUUsaURBQWlELG1DQUFtQyxFQUFFLGtDQUFrQyxFQUFFLGlDQUFpQyxVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLHFDQUFxQyxFQUFFLG1DQUFtQyxFQUFFLG9EQUFvRCxFQUFFLHFEQUFxRCxVQUFVLHdEQUF3RCxFQUFFLHFEQUFxRCxFQUFFLEVBQUUsNkNBQTZDLHFDQUFxQyxVQUFVLHFDQUFxQyxFQUFFLEVBQUUsaURBQWlELCtCQUErQixVQUFVLHlDQUF5QyxFQUFFLEVBQUUsc0RBQXNELHFDQUFxQyxVQUFVLDJEQUEyRCxFQUFFLDJEQUEyRCxFQUFFLHlDQUF5QyxFQUFFLHVEQUF1RCxFQUFFLHlFQUF5RSxFQUFFLGtEQUFrRCxFQUFFLEVBQUUsOENBQThDLG1DQUFtQyxFQUFFLGtDQUFrQyxFQUFFLGlEQUFpRCxVQUFVLHdDQUF3QyxFQUFFLEVBQUUsd0RBQXdELHFDQUFxQyxVQUFVLHdEQUF3RCxFQUFFLDJEQUEyRCxFQUFFLHdDQUF3QyxFQUFFLHlFQUF5RSxFQUFFLHlDQUF5QyxFQUFFLGtEQUFrRCxFQUFFLEVBQUUsOENBQThDLHFDQUFxQyxVQUFVLHFDQUFxQyxFQUFFLEVBQUUsa0RBQWtELCtCQUErQixVQUFVLHFDQUFxQyxFQUFFLDBCQUEwQixZQUFZLFdBQVcsMkRBQTJELG1DQUFtQyxFQUFFLG9DQUFvQyxFQUFFLDJDQUEyQyxFQUFFLDBDQUEwQyxFQUFFLEVBQUUsMkRBQTJELG1DQUFtQyxFQUFFLG9DQUFvQyxFQUFFLDJDQUEyQyxFQUFFLDBDQUEwQyxFQUFFLDRDQUE0QyxFQUFFLEVBQUUsNkNBQTZDLHVDQUF1QyxVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLHlCQUF5QixZQUFZLFdBQVcsaURBQWlELCtCQUErQixFQUFFLCtCQUErQixVQUFVLDBDQUEwQyxFQUFFLDRCQUE0QixZQUFZLFdBQVcsNERBQTRELHFDQUFxQyxVQUFVLHlDQUF5QyxFQUFFLHlDQUF5QyxFQUFFLEVBQUUsZ0RBQWdELHlDQUF5QyxFQUFFLHlDQUF5QyxFQUFFLEVBQUUsa0NBQWtDLEVBQUUsOENBQThDLCtCQUErQixFQUFFLEVBQUUsK0NBQStDLHNDQUFzQyxFQUFFLEVBQUUsOENBQThDLCtCQUErQixFQUFFLEVBQUUsMENBQTBDLCtCQUErQixFQUFFLEVBQUUsMENBQTBDLCtCQUErQixFQUFFLEVBQUUsMkNBQTJDLCtCQUErQixFQUFFLEVBQUUsNENBQTRDLHNDQUFzQyxFQUFFLEVBQUUsMkNBQTJDLCtCQUErQixFQUFFLG1DQUFtQyxVQUFVLDhDQUE4QyxFQUFFLDZEQUE2RCxFQUFFLGlFQUFpRSxFQUFFLEVBQUUsMkNBQTJDLEVBQUUsa0RBQWtELCtCQUErQixFQUFFLEVBQUUsNkRBQTZELCtCQUErQixVQUFVLHNDQUFzQyxFQUFFLHNDQUFzQyxFQUFFLHVCQUF1QixZQUFZLFdBQVcsb0RBQW9ELG9DQUFvQyxFQUFFLG9DQUFvQyxVQUFVLHVEQUF1RCxFQUFFLHFEQUFxRCxFQUFFLEVBQUUsMkRBQTJELG9DQUFvQyxFQUFFLG9DQUFvQyxVQUFVLHVEQUF1RCxFQUFFLHFEQUFxRCxFQUFFLEVBQUUsbURBQW1ELG1DQUFtQyxFQUFFLG1DQUFtQyxFQUFFLG9DQUFvQyxFQUFFLHdDQUF3QyxVQUFVLDRDQUE0QyxFQUFFLHFFQUFxRSxFQUFFLHlCQUF5QixZQUFZLFdBQVcsNkNBQTZDLCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsb0RBQW9ELCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsNENBQTRDLCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsaURBQWlELCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsa0RBQWtELCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsa0RBQWtELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsaURBQWlELCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLHVDQUF1QyxFQUFFLCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLHlCQUF5QixZQUFZLFlBQVksK0NBQStDLCtCQUErQixFQUFFLCtCQUErQixVQUFVLG1FQUFtRSxFQUFFLG1FQUFtRSxFQUFFLHFEQUFxRCxFQUFFLEVBQUUsb0RBQW9ELCtCQUErQixFQUFFLCtCQUErQixVQUFVLDZEQUE2RCxFQUFFLDZEQUE2RCxFQUFFLHFEQUFxRCxFQUFFLEVBQUUsa0RBQWtELCtCQUErQixFQUFFLG9DQUFvQyxVQUFVLHFEQUFxRCxFQUFFLDBCQUEwQixhQUFhLFlBQVksNERBQTRELCtCQUErQixFQUFFLG1DQUFtQyxFQUFFLG9DQUFvQyxFQUFFLGtDQUFrQyxFQUFFLHNDQUFzQyxVQUFVLGdFQUFnRSxFQUFFLHFFQUFxRSxFQUFFLEVBQUUsOERBQThELCtCQUErQixFQUFFLG1DQUFtQyxFQUFFLG9DQUFvQyxFQUFFLGtDQUFrQyxFQUFFLHNDQUFzQyxVQUFVLGdFQUFnRSxFQUFFLHFFQUFxRSxFQUFFLEVBQUUsaURBQWlELCtCQUErQixVQUFVLGlFQUFpRSxFQUFFLHVEQUF1RCxFQUFFLHlEQUF5RCxFQUFFLHdEQUF3RCxFQUFFLEVBQUUscURBQXFELCtCQUErQixFQUFFLEVBQUUsd0RBQXdELCtCQUErQixFQUFFLEVBQUUsMkRBQTJELDJDQUEyQyxFQUFFLDJDQUEyQyxFQUFFLDBDQUEwQyxFQUFFLDBDQUEwQyxVQUFVLDZGQUE2RixFQUFFLCtCQUErQixhQUFhLFlBQVksNkNBQTZDLCtCQUErQixFQUFFLG9DQUFvQyxVQUFVLCtDQUErQyxFQUFFLEVBQUUsOENBQThDLCtCQUErQixFQUFFLG9DQUFvQyxVQUFVLCtDQUErQyxFQUFFLEVBQUUsNkNBQTZDLCtCQUErQixFQUFFLG9DQUFvQyxVQUFVLCtDQUErQyxFQUFFLEVBQUUsNkNBQTZDLCtCQUErQixFQUFFLG9DQUFvQyxVQUFVLCtDQUErQyxFQUFFLEVBQUUsNkNBQTZDLCtCQUErQixFQUFFLG9DQUFvQyxVQUFVLCtDQUErQyxFQUFFLEVBQUUsNkNBQTZDLCtCQUErQixFQUFFLG9DQUFvQyxVQUFVLCtDQUErQyxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixFQUFFLGtDQUFrQyxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixFQUFFLGtDQUFrQyxFQUFFLEVBQUUsOENBQThDLCtCQUErQixFQUFFLG9DQUFvQyxVQUFVLCtDQUErQyxFQUFFLDJCQUEyQixhQUFhLFlBQVksbURBQW1ELDZDQUE2QyxFQUFFLG1DQUFtQyxFQUFFLEVBQUUsaURBQWlELDRDQUE0QyxFQUFFLGtDQUFrQyxFQUFFLEVBQUUsbURBQW1ELCtCQUErQixFQUFFLHFDQUFxQyxFQUFFLGlEQUFpRCxFQUFFLEVBQUUsaURBQWlELCtCQUErQixFQUFFLHFDQUFxQyxVQUFVLHVEQUF1RCxFQUFFLDZFQUE2RSxFQUFFLEVBQUUsa0RBQWtELCtCQUErQixFQUFFLGdEQUFnRCxFQUFFLEVBQUUsb0RBQW9ELCtCQUErQixFQUFFLG9DQUFvQyxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixFQUFFLHFDQUFxQyxFQUFFLG9DQUFvQyxFQUFFLEVBQUUsdURBQXVELCtCQUErQixFQUFFLHFDQUFxQyxFQUFFLG1DQUFtQyxFQUFFLHVDQUF1QyxVQUFVLGtFQUFrRSxFQUFFLDhEQUE4RCxFQUFFLHVFQUF1RSxFQUFFLHdFQUF3RSxFQUFFLDZFQUE2RSxFQUFFLEVBQUUsK0NBQStDLDRDQUE0QyxVQUFVLHVEQUF1RCxFQUFFLEVBQUUsaURBQWlELG9DQUFvQyxVQUFVLHVEQUF1RCxFQUFFLHFFQUFxRSxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixFQUFFLG9DQUFvQyxFQUFFLEVBQUUsZ0RBQWdELGlEQUFpRCxFQUFFLCtCQUErQixVQUFVLHVFQUF1RSxFQUFFLEVBQUUsaURBQWlELCtCQUErQixFQUFFLCtDQUErQyxFQUFFLGlEQUFpRCxFQUFFLEVBQUUsb0RBQW9ELHFDQUFxQyxFQUFFLG9DQUFvQyxFQUFFLHFDQUFxQyxFQUFFLEVBQUUsbURBQW1ELCtCQUErQixFQUFFLHFDQUFxQyxFQUFFLEVBQUUsd0RBQXdELDJDQUEyQyxFQUFFLDJDQUEyQyxFQUFFLDBDQUEwQyxFQUFFLDBDQUEwQyxVQUFVLDZGQUE2RixFQUFFLDJCQUEyQixhQUFhLFlBQVksNENBQTRDLCtCQUErQixFQUFFLEVBQUUsNkNBQTZDLCtCQUErQixFQUFFLEVBQUUsNkNBQTZDLCtCQUErQixFQUFFLHdEQUF3RCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixFQUFFLHdEQUF3RCxFQUFFLDBCQUEwQixhQUFhLFlBQVksbURBQW1ELCtCQUErQixVQUFVLHlEQUF5RCxFQUFFLHdDQUF3QyxFQUFFLEVBQUUseURBQXlELCtCQUErQixFQUFFLGtDQUFrQyxFQUFFLEVBQUUsa0RBQWtELCtCQUErQixFQUFFLHVDQUF1QyxVQUFVLDBFQUEwRSxFQUFFLEVBQUUsb0RBQW9ELCtCQUErQixFQUFFLHVDQUF1QyxFQUFFLDBEQUEwRCxFQUFFLEVBQUUsc0RBQXNELCtCQUErQixFQUFFLHFDQUFxQyxFQUFFLEVBQUUsc0RBQXNELCtCQUErQixVQUFVLDBFQUEwRSxFQUFFLEVBQUUsNkRBQTZELCtCQUErQixFQUFFLDBDQUEwQyxFQUFFLHdDQUF3QyxFQUFFLEVBQUUsNkRBQTZELCtCQUErQixFQUFFLDBDQUEwQyxFQUFFLHFDQUFxQyxFQUFFLEVBQUUsMkRBQTJELCtCQUErQixVQUFVLG1EQUFtRCxFQUFFLHFEQUFxRCxFQUFFLGdDQUFnQyxhQUFhLHdLQUF3SyxhQUFhLDZNQUE2TSxjQUFjLEdBQUcsc0NBQXNDLHlCQUF5QixHQUFHLEVBQUUsMkNBQTJDLGVBQWUsaURBQWlELCtCQUErQix3Q0FBd0MseUNBQXlDLGdCQUFnQixFQUFFLHdDQUF3QywwQ0FBMEMsZ0JBQWdCLEVBQUUsd0NBQXdDLDZEQUE2RCxpS0FBaUssR0FBRyxZQUFZLDBDQUEwQyxXQUFXLGlDQUFpQyxnQ0FBZ0MsMENBQTBDLGlDQUFpQyxxQ0FBcUMsV0FBVyxpQ0FBaUMsR0FBRywwRkFBMEYsaUNBQWlDLGtDQUFrQyx1RUFBdUUsT0FBTyxpRkFBaUYsdUNBQXVDLHNDQUFzQyxnQkFBZ0IsK0JBQStCLCtEQUErRCxrQkFBa0Isd0RBQXdELEdBQUcsR0FBRyw2REFBNkQsc0JBQXNCLGVBQWUsK0pBQStKLE1BQU0sa0tBQWtLLE1BQU0sNktBQTZLLE1BQU0seUpBQXlKLE1BQU0sd0tBQXdLLE1BQU0sNEpBQTRKLE1BQU0saUNBQWlDLDRFQUE0RSxrQkFBa0IsZUFBZSxHQUFHLEdBQUcsS0FBSyxzQ0FBc0MsTUFBTSx5REFBRyxRQUFRLG9DQUFvQyx1RUFBdUUsb0dBQW9HLDhDQUE4QyxtQkFBbUIsV0FBVyxlQUFlLG9GQUFvRiwyQkFBMkIsU0FBUywwQ0FBMEMsV0FBVyxlQUFlLDRDQUE0QyxjQUFjLHFCQUFxQiwwQ0FBMEMsMkNBQTJDLFdBQVcsY0FBYyxhQUFhLHdEQUF3RCx1Q0FBdUMscUNBQXFDLG1DQUFtQyxrQkFBa0IsU0FBUyxpREFBaUQsV0FBVyxlQUFlLDhCQUE4Qix3REFBd0QseURBQXlELEVBQUUsU0FBUyxrREFBa0QsV0FBVyx1RUFBdUUsMENBQTBDLElBQUksR0FBRyw2QkFBNkIsYUFBYSwrQkFBK0IsaUVBQUcscURBQXFELGtCQUFrQixrRUFBSSxrQ0FBa0MsZ0NBQWdDLGlFQUFHLHFEQUFxRCxpQkFBaUIsaUVBQUcscURBQXFELCtCQUErQixpRUFBRyxxREFBcUQsc0JBQXNCLHNFQUFRLHFEQUFxRCxpQkFBaUIsaUVBQUcscURBQXFELHFCQUFxQixxRUFBTyxxREFBcUQscUJBQXFCLHFFQUFPLHFEQUFxRCxpQkFBaUIsaUVBQUcscURBQXFELCtCQUErQiwrRUFBaUIscURBQXFELGtFQUFrRSw2QkFBNkIsYUFBYSxpQkFBaUIsaUVBQUcsNEJBQTRCLGtCQUFrQixrRUFBSSw0QkFBNEIsbUJBQW1CLG1FQUFLLDRCQUE0QixrQkFBa0Isa0VBQUksNEJBQTRCLG1CQUFtQixtRUFBSyw0QkFBNEIsa0JBQWtCLGtFQUFJLDRCQUE0QixtQkFBbUIsbUVBQUsscURBQXFELG1CQUFtQixtRUFBSyw0QkFBNEIsa0JBQWtCLGtFQUFJLDRCQUE0QixpQkFBaUIsaUVBQUcsNEJBQTRCLGtCQUFrQixrRUFBSSw0QkFBNEIsaUJBQWlCLGlFQUFHLDRCQUE0QixpQkFBaUIsaUVBQUcsNEJBQTRCLGlCQUFpQixpRUFBRyw0QkFBNEIsbUJBQW1CLG1FQUFLLDRCQUE0QixtQkFBbUIsbUVBQUssNEJBQTRCLGlCQUFpQixpRUFBRyw0QkFBNEIsbUJBQW1CLG1FQUFLLDRCQUE0QixpQkFBaUIsaUVBQUcsNEJBQTRCLHdCQUF3Qix3RUFBVSw0QkFBNEIsa0JBQWtCLGtFQUFJLDRCQUE0QixtQkFBbUIsbUVBQUssNEJBQTRCLGtCQUFrQixrRUFBSSw0QkFBNEIscUJBQXFCLHFFQUFPLDRCQUE0QixpQkFBaUIsaUVBQUcsNEJBQTRCLGtCQUFrQixrRUFBSSw0QkFBNEIsa0JBQWtCLGtFQUFJLDRCQUE0QixzQkFBc0Isc0VBQVEsNEJBQTRCLGtCQUFrQixrRUFBSSw0QkFBNEIsb0JBQW9CLG9FQUFNLDRCQUE0QixrQkFBa0Isa0VBQUksNEJBQTRCLGlCQUFpQixpRUFBRyw0QkFBNEIscUNBQXFDLHlFQUFXLG9HQUFvRyxtQkFBbUIsbUVBQUssa0NBQWtDLGtCQUFrQixrRUFBSSx3REFBd0QsdUJBQXVCLHVFQUFTLHlEQUF5RCxrRUFBa0Usd0JBQXdCLDBCQUEwQixzTEFBc0wsbURBQW1ELGVBQWUsb0JBQW9CLCtCQUErQix1Q0FBdUMsaUNBQWlDLDBCQUEwQixrQ0FBa0MsNkJBQTZCLDJCQUEyQiw4QkFBOEIsc0ZBQXNGLDBIQUEwSCxzQkFBc0IsMExBQTBMLDhEQUE4RCxrQ0FBa0MsV0FBVyx5QkFBeUIsaUJBQWlCLEVBQUUsaUNBQWlDLHNGQUFzRixvSkFBb0osMEJBQTBCLDhNQUE4TSwwWEFBMFgsK0lBQStJLDBDQUEwQyxxQ0FBcUMsV0FBVywwTEFBMEwsd0JBQXdCLHVCQUF1QixFQUFFLGtDQUFrQywwR0FBMEcsT0FBTyxLQUFLLFlBQVksY0FBYyxjQUFjLHVCQUF1QixvRUFBTSxtQ0FBbUMsdUJBQXVCLDZHQUE2RyxtRUFBSyxNQUFNLGdDQUFnQywwR0FBMEcsMEJBQTBCLG9FQUFNLG1DQUFtQyxpQkFBaUIsY0FBYyxjQUFjLHVCQUF1Qiw4TEFBOEwsb0VBQU0sTUFBTSxtQ0FBbUMsNkdBQTZHLDRIQUE0SCw2QkFBNkIsc0hBQXNILGlCQUFpQixxRUFBTyxPQUFPLGlDQUFpQyxXQUFXLDZHQUE2Ryw0QkFBNEIsWUFBWSxFQUFFLDhLQUE4Syx5TkFBeU4sNEJBQTRCLGtFQUFJLFlBQVkscUJBQXFCLFlBQVksV0FBVyxLQUFLLHdDQUF3QyxLQUFLLG1FQUFLLGdDQUFnQyxTQUFTLEVBQUUsaUJBQWlCLFdBQVcsV0FBVyxvQkFBb0IsaUVBQWlFLG1CQUFtQiwwREFBSSwyREFBMkQsOENBQThDLEVBQUUseURBQXlELGdDQUFnQyxZQUFZLFdBQVcsa0RBQWtELFNBQVMsY0FBYyxHQUFHLDRCQUE0QiwrQ0FBK0MsMEVBQTBFLG9DQUFvQyxnQkFBZ0Isb0JBQW9CLDJCQUEyQix5QkFBeUIsd0JBQXdCLHdCQUF3Qix1QkFBdUIsZ0NBQWdDLGdDQUFnQyxxQ0FBcUMscUNBQXFDLHVDQUF1Qyx3Q0FBd0MsdUNBQXVDLHNDQUFzQyxxQ0FBcUMsc0NBQXNDLGFBQWEsdURBQXVELHVGQUF1RixtRUFBbUUsaURBQWlELGlDQUFpQyxzQ0FBc0MsaUhBQWlILDRFQUE0RSxnRkFBZ0YscVVBQXFVLG9FQUFNLE9BQU8sb0VBQU0sTUFBTSx1SkFBdUosb0VBQU0sTUFBTSx1SEFBdUgsNEpBQTRKLDRKQUE0SixvRUFBTSxNQUFNLDZIQUE2SCwwSkFBMEosb0VBQU0sTUFBTSxnRkFBZ0Ysb0VBQU0scUJBQXFCLGlHQUFpRyxrRUFBa0UsRUFBRSxFQUFFLGdDQUFnQyxhQUFhLGtLQUFrSyxPQUFPLG9FQUFNLGtFQUFrRSw2SEFBNkgsdUNBQXVDLE9BQU8sb0VBQU0sc0ZBQXNGLHlGQUF5Riw4REFBOEQsT0FBTyw2RUFBZSwwRUFBMEUscU1BQXFNLE9BQU8sNkVBQWUsMEZBQTBGLDRFQUE0RSx3Q0FBd0MsT0FBTyxxRUFBTyxzREFBc0QsZ0hBQWdILE9BQU8scUVBQU8sc0RBQXNELGtFQUFrRSw2QkFBNkIsYUFBYSw0R0FBNEcsT0FBTyxrRUFBSSxTQUFTLDZHQUE2RyxPQUFPLHNFQUFRLFNBQVMsb0pBQW9KLE9BQU8sb0VBQU0sV0FBVyxrQkFBa0Isa0VBQUksNkRBQTZELHNCQUFzQixzRUFBUSw0QkFBNEIsMkJBQTJCLDJFQUFhLHlIQUF5SCwyQ0FBMkMsZ0VBQWdFLE9BQU8sbUVBQUssc0NBQXNDLHFEQUFxRCxnR0FBZ0csT0FBTyw2RUFBZSx3Q0FBd0MsbUJBQW1CLG1FQUFLLDZEQUE2RCx1QkFBdUIsdUVBQVMsNEJBQTRCLG1FQUFtRSw0QkFBNEIsK0NBQStDLGNBQWMsb0NBQW9DLGdCQUFnQixvQkFBb0IsZ0VBQWdFLHdCQUF3QiwyQkFBMkIsWUFBWSxxTUFBcU0sMkRBQUssb0NBQW9DLDRCQUE0QixnQkFBZ0Isd0VBQVUsb0NBQW9DLDRCQUE0QixnQkFBZ0IsNEVBQWMscURBQXFELDBCQUEwQixpRUFBaUUsRUFBRSxFQUFFLGdDQUFnQyxhQUFhLHlHQUF5RyxrRUFBSSxRQUFRLDJCQUEyQixrRUFBa0UsNkJBQTZCLGFBQWEsNkJBQTZCLGtFQUFrRSxpQ0FBaUMsZ0RBQWdELHlHQUF5RyxnRUFBZ0UsaUJBQWlCLEVBQUUsd0RBQXdELG1CQUFtQixzRUFBUSwwQ0FBMEMsNkRBQTZELE9BQU8sc0VBQVEsVUFBVSxFQUFFLGtCQUFrQixvRUFBTSx5Q0FBeUMsa0JBQWtCLG9FQUFNLHlDQUF5QyxvQkFBb0IsNklBQTZJLDhIQUE4SCxZQUFZLFdBQVcsd0VBQXdFLFVBQVUsa0VBQWtFLDZCQUE2QixhQUFhLDZIQUE2SCxPQUFPLDJEQUFLLGtDQUFrQyxnSUFBZ0ksT0FBTywyREFBSyx5Q0FBeUMsb09BQW9PLE9BQU8sMkRBQUssNkJBQTZCLGtFQUFrRSw2QkFBNkIsYUFBYSxtQkFBbUIsbUVBQUsscURBQXFELHNCQUFzQixzRUFBUSxxREFBcUQscUJBQXFCLHFFQUFPLHFEQUFxRCwwQkFBMEIsMEVBQVkscURBQXFELGtCQUFrQixrRUFBSSxxREFBcUQsdUJBQXVCLHVFQUFTLHFEQUFxRCx3QkFBd0Isd0VBQVUscURBQXFELHdCQUF3Qix3RUFBVSw0QkFBNEIsdUJBQXVCLHVFQUFTLHFEQUFxRCxvQkFBb0IsbUVBQUssc0ZBQXNGLGtFQUFrRSw4QkFBOEIsYUFBYSxzQ0FBc0Msb0VBQU0seUhBQXlILHVCQUF1Qix1RUFBUyx3REFBd0Qsa0VBQWtFLDhCQUE4QixhQUFhLG1EQUFtRCx1RUFBUyxrTEFBa0wsaUJBQWlCLHdGQUEwQiwrSUFBK0kscUJBQXFCLHFFQUFPLDRCQUE0Qix3QkFBd0Isd0VBQVUsNEJBQTRCLDJCQUEyQiwyRUFBYSxtSkFBbUosa0VBQWtFLDhCQUE4QixhQUFhLDhFQUE4RSxPQUFPLGlFQUFHLGdDQUFnQywyRUFBMkUsT0FBTyxrRUFBSSxnQ0FBZ0MsMEVBQTBFLE9BQU8saUVBQUcsZ0NBQWdDLDBFQUEwRSxPQUFPLGlFQUFHLGdDQUFnQywwRUFBMEUsT0FBTyxpRUFBRyxnQ0FBZ0MsMEVBQTBFLE9BQU8saUVBQUcsZ0NBQWdDLDJDQUEyQyxPQUFPLG9FQUFNLDhCQUE4QiwyQ0FBMkMsT0FBTyxvRUFBTSw4QkFBOEIsMkVBQTJFLE9BQU8sa0VBQUksZ0NBQWdDLGtFQUFrRSw4QkFBOEIsYUFBYSwrRkFBK0YsT0FBTyxvRUFBTSxPQUFPLDBEQUEwRCxnRUFBZ0UsT0FBTyxvRUFBTSx5QkFBeUIsdUZBQXVGLE9BQU8scUVBQU8sT0FBTyw2RUFBNkUsT0FBTyxtRUFBSyxnQ0FBZ0Msa0RBQWtELG9SQUFvUiw4Q0FBOEMsaUJBQWlCLDhDQUE4QyxPQUFPLDBFQUFZLHFCQUFxQixrQkFBa0Isa0VBQUksWUFBWSwySEFBMkgsTUFBTSwwREFBSSx3QkFBd0IsUUFBUSwwREFBSSw0RkFBNEYsd0JBQXdCLEVBQUUsT0FBTyxtRUFBSyxPQUFPLEVBQUUsb0JBQW9CLGtFQUFJLFlBQVksa0VBQWtFLE9BQU8scUVBQU8sTUFBTSxFQUFFLDZDQUE2QyxPQUFPLGtFQUFJLDhCQUE4Qix1REFBdUQsNkNBQTZDLE9BQU8sbUVBQUssK0JBQStCLGlEQUFpRCxtRUFBbUUsT0FBTyx1RUFBUyxTQUFTLDhDQUE4QyxpQ0FBaUMsT0FBTyxzRUFBUSxPQUFPLGdHQUFnRyxnRkFBZ0YsT0FBTywyRUFBYSwrQ0FBK0Msa0VBQWtFLDhCQUE4QixhQUFhLGlCQUFpQixpRUFBRyw0QkFBNEIsa0JBQWtCLGtFQUFJLDRCQUE0QixrQkFBa0Isa0VBQUksNEJBQTRCLG1CQUFtQixtRUFBSyw0QkFBNEIsa0VBQWtFLDhCQUE4QixhQUFhLGtCQUFrQixrRUFBSSx5REFBeUQsbURBQW1ELE9BQU8sd0VBQVUsOEJBQThCLDRDQUE0QyxPQUFPLHFFQUFPLDhCQUE4QixxQkFBcUIscUVBQU8seURBQXlELDZCQUE2QixpRUFBRywyR0FBMkcsMEdBQTBHLE9BQU8sNEVBQWMsZ0NBQWdDLHlEQUF5RCw4Q0FBOEMsT0FBTyw0RUFBYyxnQ0FBZ0MsNEdBQTRHLE9BQU8sMEVBQVksZ0NBQWdDLG1FQUFtRSw2QkFBNkIsc0JBQXNCLG1CQUFtQix5Q0FBeUMsMkNBQTJDLHdDQUF3Qyw0Q0FBNEMseUNBQXlDLHdDQUF3QywyQ0FBMkMsc0NBQXNDLHNDQUFzQyx3Q0FBd0MsMENBQTBDLCtDQUErQywyQ0FBMkMsNENBQTRDLDBDQUEwQyxnREFBZ0Qsa0VBQWtFLFFBQVEsK0NBQStDLG1CQUFtQixlQUFlLGdDQUFnQyxnQkFBZ0IseURBQXlELGdDQUFnQyxpRkFBaUYsMENBQTBDLE9BQU8sZ0NBQWdDLHFEQUFxRCxlQUFlLHFCQUFxQixpQkFBaUIsc0VBQXNFLCtCQUErQix3REFBd0QsZUFBZSxrQ0FBa0MsK0JBQStCLHlEQUF5RCxlQUFlLCtCQUErQiwrQkFBK0IsbURBQW1ELGlCQUFpQix5QkFBeUIsS0FBSyxvREFBb0QscUNBQXFDLHFDQUFxQyw4Q0FBOEMsMkJBQTJCLG9FQUFvRSxlQUFlLG9DQUFvQyw4TEFBOEwsa0NBQWtDLHVHQUF1Ryw0RkFBNEYsc0NBQXNDLHFIQUFxSCxrREFBa0Qsc0JBQXNCLHdDQUF3Qyw0SUFBNEksbUNBQW1DLHlCQUF5Qix3Q0FBd0MsNEJBQTRCLHdDQUF3Qyw4QkFBOEIsR0FBRyw0QkFBNEIsY0FBYyx3REFBd0QsNEZBQTRGLHNEQUFzRCxlQUFlLHVCQUF1QixpQkFBaUIscUNBQXFDLDRCQUE0QixZQUFZLEVBQUUsRUFBRSx1REFBdUQsK0JBQStCLDhDQUE4QyxlQUFlLHlDQUF5QyxPQUFPLCtIQUErSCxFQUFFLCtCQUErQiwrQ0FBK0MsZUFBZSxxQ0FBcUMsT0FBTywrSEFBK0gsRUFBRSwrQkFBK0Isa0RBQWtELGVBQWUseUNBQXlDLGNBQWMsRUFBRSwrQkFBK0IsbURBQW1ELGVBQWUsb0NBQW9DLGNBQWMsRUFBRSwrQkFBK0IsMERBQTBELGVBQWUsa0NBQWtDLCtCQUErQiwyREFBMkQsZUFBZSxtQ0FBbUMsK0JBQStCLGtDQUFrQyw4REFBOEQsMERBQTBELGNBQWMsOEJBQThCLDZCQUE2Qiw0Q0FBNEMsV0FBVyxFQUFFLGNBQWMsc0RBQXNELDJDQUEyQyxnQ0FBZ0MsWUFBWSxhQUFhLEVBQUUsNEJBQTRCLHFDQUFxQyxXQUFXLG1CQUFtQiw0QkFBNEIscUZBQXFGLHdCQUF3QixHQUFHLCtCQUErQixpRUFBaUUsU0FBUyxPQUFPLGtFQUFJLFlBQVksNERBQTRELDhDQUE4Qyw4Q0FBOEMsV0FBVyxLQUFLLFdBQVcsK0dBQStHLGFBQWEsUUFBUSw0QkFBNEIsRUFBRSw0Q0FBNEMsd0RBQXdELFlBQVksa0JBQWtCLHlCQUF5QixZQUFZLEVBQUUsR0FBRyxrQkFBa0IsNERBQTRELHFFQUFxRSxrREFBa0QsK0JBQStCLDJCQUEyQiwrQ0FBK0MsK0JBQStCLG9CQUFvQixjQUFjLHVEQUF1RCxHQUFHLEdBQUcsd0NBQXdDLCtDQUErQywyQkFBMkIsb0NBQW9DLGdCQUFnQiwwRUFBMEUsNkdBQTZHLG9GQUFvRixlQUFlLG1DQUFtQyw0QkFBNEIsWUFBWSxFQUFFLDZEQUE2RCx5QkFBeUIsMEdBQTBHLEVBQUUsU0FBUyxFQUFFLEVBQUUsb0RBQW9ELCtDQUErQywyQkFBMkIsb0NBQW9DLGdCQUFnQiw0Q0FBNEMsd0JBQXdCLGlEQUFpRCxPQUFPLGtDQUFrQyxlQUFlLHVCQUF1QixrQ0FBa0MsV0FBVyx5RkFBeUYsNkJBQTZCLG9CQUFvQixFQUFFLEVBQUUsb0RBQW9ELGlDQUFpQyxjQUFjLDRCQUE0QixTQUFTLGtJQUFrSSwrQkFBK0IsNkNBQTZDLHVCQUF1QiwrQ0FBK0Msb0hBQW9ILDZGQUE2Rix5Q0FBeUMsUUFBUSxXQUFXLEtBQUssU0FBUyxtREFBbUQsK0JBQStCLHVDQUF1QyxvREFBb0QseUJBQXlCLG9CQUFvQixpQ0FBaUMsa0NBQWtDLHlCQUF5QixvQkFBb0IsaUNBQWlDLElBQUksRUFBRSwwQ0FBMEMsNEVBQTRFLGNBQWMsRUFBRSx5Q0FBeUMscURBQXFELCtCQUErQixHQUFHLEVBQUUsZ0NBQWdDLFdBQVcsZ0RBQWdELDBDQUEwQyxtQkFBbUIsRUFBRSxFQUFFLGtEQUFrRCx5REFBeUQsZ0JBQWdCLFNBQVMsV0FBVyxpREFBaUQsd0ZBQXdGLDBCQUEwQixFQUFFLDBEQUFJLHFCQUFxQiwrR0FBK0csRUFBRSw4Q0FBOEMsMERBQUksc0RBQXNELCtIQUErSCxHQUFHLEVBQUUsc0NBQXNDLFdBQVcsbUJBQW1CLCtCQUErQixvQ0FBb0MsNkJBQTZCLHdCQUF3Qix3Q0FBd0MsRUFBRSwyQkFBMkIsd0JBQXdCLEVBQUUsOElBQThJLHNLQUFzSyxxSEFBcUgsdUNBQXVDLHdCQUF3QixjQUFjLE9BQU8seUJBQXlCLDBCQUEwQiw2QkFBNkIsbUdBQW1HLEdBQUcsZ0dBQWdHLGdCQUFnQixpQkFBaUIscUZBQXFGLEVBQUUseURBQXlELGVBQWUsb0JBQW9CLCtCQUErQixrREFBa0QsZUFBZSxnQ0FBZ0MsK0JBQStCLG1EQUFtRCxlQUFlLGlDQUFpQywrQkFBK0IsOENBQThDLGVBQWUsNEJBQTRCLCtCQUErQiwrQ0FBK0MsZUFBZSw2QkFBNkIsK0JBQStCLCtDQUErQyxlQUFlLCtCQUErQiwrQkFBK0IsdUNBQXVDLG9CQUFvQiwrQkFBK0Isd0RBQXdELHdEQUFFLHdDQUF3QyxLQUFLLE1BQU0sd0RBQUUsZ0RBQWdELHVCQUF1Qix3REFBRSx5Q0FBeUMseUdBQXlHLG1CQUFtQiw2QkFBNkIsK0NBQStDLFVBQVUsb0NBQW9DLGdCQUFnQix3TEFBd0wsOEJBQThCLHlHQUF5Ryx3REFBRSw0TEFBNEwsRUFBRSxFQUFFLG1DQUFtQyw0Q0FBNEMsNENBQTRDLG1CQUFtQiw0REFBTSxPQUFPLDZMQUE2TCw4Q0FBOEMsbUJBQW1CLEdBQUcsRUFBRSxtQ0FBbUMsNkJBQTZCLHNDQUFzQywwREFBMEQsNERBQU0sZ09BQWdPLHVGQUF1RixzREFBc0QsWUFBWSxVQUFVLHdDQUF3QywrQ0FBK0MsUUFBUSxvQ0FBb0MsZ0JBQWdCLG1OQUFtTiwyQ0FBMkMsNERBQU0sMkhBQTJILDRGQUE0RixZQUFZLFlBQVksRUFBRSxFQUFFLHNEQUFzRCwyQ0FBMkMscUJBQXFCLEdBQUcsRUFBRSxnQ0FBZ0Msd0JBQXdCLEdBQUcsR0FBRyw2QkFBNkIsd0JBQXdCLDBDQUEwQyxNQUFNLG9DQUFvQyxnQkFBZ0IsNElBQTRJLHFCQUFxQix5SUFBeUksOEJBQThCLEVBQUUsRUFBRSxvQkFBbUY7QUFDN3U4RTs7Ozs7Ozs7Ozs7Ozs7QUNqQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFB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QUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDem5CQSxlQUFlLG1CQUFPLENBQUMsNkRBQVU7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVU7QUFDVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3hIQSxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBYzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDekNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLCtEQUFPOzs7Ozs7Ozs7Ozs7QUNsQi9CLGVBQWUsbUJBQU8sQ0FBQyw2REFBVTs7QUFFakMsV0FBVyxtQkFBTyxDQUFDLHNEQUFZO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN0SkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLGVBQVE7QUFDN0IsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDRCQUE0QjtBQUM3QztBQUNBOztBQUVBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsV0FBVztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFdBQVc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLCtDQUErQztBQUNsRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQkFBcUIsc0NBQXNDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsbUNBQW1DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixtQ0FBbUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNkIsbUNBQW1DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLG1DQUFtQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFLE1BQTZCOzs7Ozs7Ozs7Ozs7O0FDbDJHaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FB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QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUIsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdFhhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxxRUFBVTtBQUM5QixlQUFlLG1CQUFPLENBQUMsK0RBQWdCO0FBQ3ZDLFNBQVMsbUJBQU8sQ0FBQyw2Q0FBTztBQUN4QixlQUFlLG1CQUFPLENBQUMsNkRBQVU7QUFDakM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hiYTs7QUFFYjs7QUFFQSxhQUFhLG1CQUFPLENBQUMsa0VBQVE7QUFD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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4NkJhOztBQUViOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxtREFBUztBQUM1QixlQUFlLG1CQUFPLENBQUMsNERBQWE7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFFBQVEsbUJBQU8sQ0FBQyw4RkFBeUI7QUFDekMsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQzVNWTs7QUFFYixTQUFTLG1CQUFPLENBQUMsNkNBQU87QUFDeEIsZUFBZSxtQkFBTyxDQUFDLDREQUFXO0FBQ2xDLGVBQWUsbUJBQU8sQ0FBQywrREFBZ0I7QUFDdkM7QUFDQTs7QUFFQSxjQUFjLG1CQUFPLENBQUMsNkRBQU87QUFDN0IsZ0JBQWdCLG1CQUFPLENBQUMseUVBQWE7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQiwyQ0FBMkM7QUFDckU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9PYTs7QUFFYixTQUFTLG1CQUFPLENBQUMsNkNBQU87QUFDeEIsZUFBZSxtQkFBTyxDQUFDLCtEQUFnQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTs7QUFFWixVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEhhOztBQUViLFNBQVMsbUJBQU8sQ0FBQyw2Q0FBTzs7QUFFeEIsZUFBZSxtQkFBTyxDQUFDLCtEQUFnQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBLFFBQVEsY0FBYztBQUN0Qiw4Q0FBOEM7QUFDOUM7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbURBQW1EO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUM1dkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLG1CQUFPLENBQUMsaUVBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOURBO0FBQ0E7QUFDWTs7QUFFWixXQUFXLG1CQUFPLENBQUMsbURBQVM7O0FBRTVCLHNCQUFzQixtQkFBTyxDQUFDLCtEQUFlOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQ3pIRDtB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Q0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RTs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxtREFBbUQsaUVBQWlFO0FBQ3BIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7O0FDMS9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7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OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBa0I7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQ25RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsbUJBQU8sQ0FBQyw4RUFBUTtBQUN6QixlQUFlLG1CQUFPLENBQUMsNkRBQVU7O0FBRWpDO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsdUZBQTZCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLHVGQUE2QjtBQUN2RCxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMsaUZBQThCO0FBQ3pELHFCQUFxQixtQkFBTyxDQUFDLHFGQUFnQzs7QUFFN0Q7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxhQUFhLG1CQUFPLENBQUMsd0RBQWE7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzQ0FBc0Msc0NBQXNDO0FBQ3pHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN2RSxJQUFNLENBQUMsR0FBVyxVQUFVLENBQUMsTUFBTSxDQUFDO1lBQ3BDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQzFCLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxTQUFTLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQzthQUNuRDtZQUNELElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQy9CO1FBQ0QsSUFBSSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQzdDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNsRCxJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQy9DLElBQU0sWUFBWSxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFDOUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2xELElBQU0sWUFBWSxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFDOUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUks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QyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDOUIsSUFBTSxNQUFNLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztZQUV6RCxPQUFPLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDM0IsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFNLE1BQU0sR0FBRyxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDOUIsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2QsSUFBTSxHQUFHLEdBQWE7WUFDcEIsRUFBRSxFQUFFLElBQUksWUFBWSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQzNDLEdBQUcsRUFBRSxJQUFJLFlBQVksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFDLElBQUksQ0FBQyxDQUFDO1lBQ25ELEdBQUcsRUFBRSxJQUFJLFlBQVksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFDLElBQUksQ0FBQyxDQUFDO1lBQ25ELE1BQU0sRUFBRSxJQUFJLFlBQVksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3RELE1BQU0sRUFBRSxJQUFJLFlBQVksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBQyxJQUFJLEVBQUUsRUFBRSxHQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3ZELElBQUksRUFBRSxJQUFJLFlBQVksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3BELEdBQUcsRUFBRSxJQUFJLFlBQVksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENB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LFNBQVMsQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUFFSCxnQkFBQztBQUFELENBQUM7QUF4WVksOEJBQVM7Ozs7Ozs7Ozs7OztBQy9GdEIsZTs7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7Ozs7QUNBQSxlIiwiZmlsZSI6InNpbXBsZV9idW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL2RlbW9zL3NpbXBsZS5qc1wiKTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0ICogYXMgbXMgZnJvbSAnLi4vc3JjL2luZGV4JztcblxuY29uc3Qgc2tldGNoID0gZnVuY3Rpb24ocCkge1xuICBsZXQgbW9kZWxTdGF0ZTsgLy8gU3RvcmUgdGhlIGhpZGRlbiBzdGF0ZXMgb2Ygcm5uJ3MgbmV1cm9ucy5cbiAgY29uc3QgdGVtcGVyYXR1cmUgPSAwLjQ1OyAvLyBDb250cm9scyB0aGUgYW1vdW50IG9mIHVuY2VydGFpbnR5IG9mIHRoZSBtb2RlbC5cbiAgbGV0IG1vZGVsTG9hZGVkID0gZmFsc2U7XG5cbiAgbGV0IGR4LCBkeTsgLy8gT2Zmc2V0cyBvZiB0aGUgcGVuIHN0cm9rZXMsIGluIHBpeGVscy5cbiAgbGV0IHgsIHk7IC8vIEFic29sdXRlIGNvb3JkaW5hdGVzIG9uIHRoZSBzY3JlZW4gb2Ygd2hlcmUgdGhlIHBlbiBpcy5cbiAgbGV0IHBlbiA9IFswLDAsMF07IC8vIEN1cnJlbnQgcGVuIHN0YXRlLCBbcGVuX2Rvd24sIHBlbl91cCwgcGVuX2VuZF0uXG4gIGxldCBwcmV2aW91c1BlbiA9IFsxLCAwLCAwXTsgLy8gUHJldmlvdXMgcGVuIHN0YXRlLlxuICBjb25zdCBQRU4gPSB7RE9XTjogMCwgVVA6IDEsIEVORDogMn07XG5cbiAgLy8gTG9hZCB0aGUgbW9kZWwuXG4gIGNvbnN0IG1vZGVsID0gbmV3IG1zLlNrZXRjaFJOTignaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL3F1aWNrZHJhdy1tb2RlbHMvc2tldGNoUk5OL2xhcmdlX21vZGVscy9iaXJkLmdlbi5qc29uJyk7XG5cblxuICAvKlxuICAgKiBNYWluIHA1IGNvZGVcbiAgICovXG4gIHAuc2V0dXAgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBjb250YWluZXJTaXplID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NrZXRjaCcpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vIEluaXRpYWxpemUgdGhlIGNhbnZhcy5cbiAgICBjb25zdCBzY3JlZW5XaWR0aCA9IE1hdGguZmxvb3IoY29udGFpbmVyU2l6ZS53aWR0aCk7XG4gICAgY29uc3Qgc2NyZWVuSGVpZ2h0ID0gcC53aW5kb3dIZWlnaHQgLyAyO1xuICAgIHAuY3JlYXRlQ2FudmFzKHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpO1xuICAgIHAuZnJhbWVSYXRlKDYwKTtcblxuICAgIG1vZGVsLmluaXRpYWxpemUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgc2NhbGUgZmFjdG9yIGZvciB0aGUgbW9kZWwuIEJpZ2dlciAtPiBsYXJnZSBvdXRwdXRzXG4gICAgICBtb2RlbC5zZXRQaXhlbEZhY3RvcigzLjApO1xuICAgICAgbW9kZWxMb2FkZWQgPSB0cnVlO1xuICAgICAgcmVzdGFydCgpO1xuICAgICAgY29uc29sZS5sb2coJ1NrZXRjaFJOTiBtb2RlbCBsb2FkZWQuJyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gRHJhd2luZyBsb29wLlxuICBwLmRyYXcgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIW1vZGVsTG9hZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZmluaXNoZWQgdGhlIHByZXZpb3VzIGRyYXdpbmcsIHN0YXJ0IGEgbmV3IG9uZS5cbiAgICBpZiAocHJldmlvdXNQZW5bUEVOLkVORF0gPT09IDEpIHtcbiAgICAgIHJlc3RhcnQoKTtcbiAgICB9XG5cbiAgICAvLyBOZXcgc3RhdGUuXG4gICAgW2R4LCBkeSwgLi4ucGVuXSA9IHNhbXBsZU5ld1N0YXRlKCk7XG5cbiAgICAvLyBPbmx5IGRyYXcgb24gdGhlIHBhcGVyIGlmIHRoZSBwZW4gaXMgc3RpbGwgdG91Y2hpbmcgdGhlIHBhcGVyLlxuICAgIGlmIChwcmV2aW91c1BlbltQRU4uRE9XTl0gPT0gMSkge1xuICAgICAgcC5saW5lKHgsIHksIHgrZHgsIHkrZHkpOyAvLyBEcmF3IGxpbmUgY29ubmVjdGluZyBwcmV2IHBvaW50IHRvIGN1cnJlbnQgcG9pbnQuXG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBhYnNvbHV0ZSBjb29yZGluYXRlcyBmcm9tIHRoZSBvZmZzZXRzXG4gICAgeCArPSBkeDtcbiAgICB5ICs9IGR5O1xuXG4gICAgLy8gVXBkYXRlIHRoZSBwcmV2aW91cyBwZW4ncyBzdGF0ZSB0byB0aGUgY3VycmVudCBvbmUgd2UganVzdCBzYW1wbGVkLlxuICAgIHByZXZpb3VzUGVuID0gcGVuO1xuICB9O1xuXG4gIC8qXG4gICAqIEhlbHBlcnMuXG4gICAqL1xuICBmdW5jdGlvbiBzYW1wbGVOZXdTdGF0ZSgpIHtcbiAgICAvLyBVc2luZyB0aGUgcHJldmlvdXMgcGVuIHN0YXRlcywgYW5kIGhpZGRlbiBzdGF0ZSwgZ2V0IG5leHQgaGlkZGVuIHN0YXRlXG4gICAgLy8gdGhlIGJlbG93IGxpbmUgdGFrZXMgdGhlIG1vc3QgQ1BVIHBvd2VyLCBlc3BlY2lhbGx5IGZvciBsYXJnZSBtb2RlbHMuXG4gICAgbW9kZWxTdGF0ZSA9IG1vZGVsLnVwZGF0ZShbZHgsIGR5LCAuLi5wZW5dLCBtb2RlbFN0YXRlKTtcblxuICAgIC8vIEdldCB0aGUgcGFyYW1ldGVycyBvZiB0aGUgcHJvYmFiaWxpdHkgZGlzdHJpYnV0aW9uIChwZGYpIGZyb20gaGlkZGVuIHN0YXRlLlxuICAgIGNvbnN0IHBkZiA9IG1vZGVsLmdldFBERihtb2RlbFN0YXRlLCB0ZW1wZXJhdHVyZSk7XG5cbiAgICAvLyBTYW1wbGUgdGhlIG5leHQgcGVuJ3Mgc3RhdGVzIGZyb20gb3VyIHByb2JhYmlsaXR5IGRpc3RyaWJ1dGlvbi5cbiAgICByZXR1cm4gbW9kZWwuc2FtcGxlKHBkZik7XG4gIH1cblxuICBmdW5jdGlvbiBzZXR1cE5ld0RyYXdpbmcoKSB7XG4gICAgcC5iYWNrZ3JvdW5kKDI1NSwgMjU1LCAyNTUsIDI1NSk7XG4gICAgeCA9IHAud2lkdGggLyAyLjA7XG4gICAgeSA9IHAuaGVpZ2h0IC8gMy4wO1xuICAgIGNvbnN0IGxpbmVDb2xvciA9IHAuY29sb3IocC5yYW5kb20oNjQsIDIyNCksIHAucmFuZG9tKDY0LCAyMjQpLCBwLnJhbmRvbSg2NCwgMjI0KSk7XG5cbiAgICBwLnN0cm9rZVdlaWdodCgzLjApO1xuICAgIHAuc3Ryb2tlKGxpbmVDb2xvcik7XG4gIH1cblxuICBmdW5jdGlvbiByZXN0YXJ0KCkge1xuICAgIFtkeCwgZHksIC4uLnBlbl0gPSBtb2RlbC56ZXJvSW5wdXQoKTsgIC8vIFJlc2V0IHRoZSBwZW4gc3RhdGUuXG4gICAgbW9kZWxTdGF0ZSA9IG1vZGVsLnplcm9TdGF0ZSgpOyAgLy8gUmVzZXQgdGhlIG1vZGVsIHN0YXRlLlxuICAgIHNldHVwTmV3RHJhd2luZygpO1xuICB9XG59O1xuXG5uZXcgcDUoc2tldGNoLCAnc2tldGNoJyk7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5pbXBvcnR7RU5WLGNvbmNhdCxzbGljZSxzdGFjayx0ZW5zb3IsdGlkeSx1bnN0YWNrLHV0aWwsaW8sVGVuc29yLGFkZCxhZGROLG1vZCxtdWwsZGl2LGZsb29yRGl2LHN1YixtaW5pbXVtLG1heGltdW0scG93LHNxdWFyZWREaWZmZXJlbmNlLGFicyxhY29zLGFjb3NoLGFzaW4sYXNpbmgsYXRhbixhdGFuMixhdGFuaCxjZWlsLGNvcyxjb3NoLGVsdSxlcmYsZXhwLGV4cG0xLGZsb29yLGxvZyxsb2cxcCxuZWcscmVjaXByb2NhbCxyZWx1LHJvdW5kLHNlbHUsc2lnbW9pZCxzaW4sc2lnbixzaW5oLHNvZnRwbHVzLHNxcnQsc3F1YXJlLHRhbmgsdGFuLGNsaXBCeVZhbHVlLHJzcXJ0LHByb2QsbGVha3lSZWx1LHNjYWxhcixjb252MWQsY29udjJkLGNvbnYyZFRyYW5zcG9zZSxkZXB0aHdpc2VDb252MmQsYXZnUG9vbCxtYXhQb29sLGZpbGwsbGluc3BhY2Usb25lSG90LG9uZXMsb25lc0xpa2UscmFuZG9tVW5pZm9ybSxyYW5nZSx0cnVuY2F0ZWROb3JtYWwsemVyb3MsemVyb3NMaWtlLGltYWdlLHdoZXJlQXN5bmMsc2V0ZGlmZjFkQXN5bmMsdG9wayx0ZW5zb3IxZCxlcXVhbCxub3RFcXVhbCxncmVhdGVyLGdyZWF0ZXJFcXVhbCxsZXNzLGxlc3NFcXVhbCxsb2dpY2FsQW5kLGxvZ2ljYWxOb3QsbG9naWNhbE9yLHdoZXJlLG1hdE11bCx0cmFuc3Bvc2UsYmF0Y2hOb3JtLGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uLHNvZnRtYXgsbG9nU29mdG1heCxzcGFyc2VUb0RlbnNlLG1heCxtZWFuLG1pbixzdW0sYWxsLGFueSxhcmdNYXgsYXJnTWluLGdhdGhlcixyZXZlcnNlLHN0cmlkZWRTbGljZSx0aWxlLHNwbGl0LHNjYXR0ZXJORCxnYXRoZXJORCxmZnQsaWZmdCxyZmZ0LGlyZmZ0LGNhc3QsZXhwYW5kRGltcyxzcXVlZXplLHJlc2hhcGUscGFkLHNwYWNlVG9CYXRjaE5ELGJhdGNoVG9TcGFjZU5ELGRlcHRoVG9TcGFjZX1mcm9tXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIjt2YXIgRGF0YVR5cGUsU2F2ZXJEZWYsX19hc3NpZ249ZnVuY3Rpb24oKXtyZXR1cm4oX19hc3NpZ249T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciB0LGE9MSxyPWFyZ3VtZW50cy5sZW5ndGg7YTxyO2ErKylmb3IodmFyIG4gaW4gdD1hcmd1bWVudHNbYV0pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJihlW25dPXRbbl0pO3JldHVybiBlfSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtmdW5jdGlvbiBfX2F3YWl0ZXIoZSx0LGEscil7cmV0dXJuIG5ldyhhfHwoYT1Qcm9taXNlKSkoZnVuY3Rpb24obixzKXtmdW5jdGlvbiBvKGUpe3RyeXtpKHIubmV4dChlKSl9Y2F0Y2goZSl7cyhlKX19ZnVuY3Rpb24gcChlKXt0cnl7aShyLnRocm93KGUpKX1jYXRjaChlKXtzKGUpfX1mdW5jdGlvbiBpKGUpe2UuZG9uZT9uKGUudmFsdWUpOm5ldyBhKGZ1bmN0aW9uKHQpe3QoZS52YWx1ZSl9KS50aGVuKG8scCl9aSgocj1yLmFwcGx5KGUsdHx8W10pKS5uZXh0KCkpfSl9ZnVuY3Rpb24gX19nZW5lcmF0b3IoZSx0KXt2YXIgYSxyLG4scyxvPXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZigxJm5bMF0pdGhyb3cgblsxXTtyZXR1cm4gblsxXX0sdHJ5czpbXSxvcHM6W119O3JldHVybiBzPXtuZXh0OnAoMCksdGhyb3c6cCgxKSxyZXR1cm46cCgyKX0sXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYoc1tTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxzO2Z1bmN0aW9uIHAocyl7cmV0dXJuIGZ1bmN0aW9uKHApe3JldHVybiBmdW5jdGlvbihzKXtpZihhKXRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO2Zvcig7bzspdHJ5e2lmKGE9MSxyJiYobj0yJnNbMF0/ci5yZXR1cm46c1swXT9yLnRocm93fHwoKG49ci5yZXR1cm4pJiZuLmNhbGwociksMCk6ci5uZXh0KSYmIShuPW4uY2FsbChyLHNbMV0pKS5kb25lKXJldHVybiBuO3N3aXRjaChyPTAsbiYmKHM9WzImc1swXSxuLnZhbHVlXSksc1swXSl7Y2FzZSAwOmNhc2UgMTpuPXM7YnJlYWs7Y2FzZSA0OnJldHVybiBvLmxhYmVsKysse3ZhbHVlOnNbMV0sZG9uZTohMX07Y2FzZSA1Om8ubGFiZWwrKyxyPXNbMV0scz1bMF07Y29udGludWU7Y2FzZSA3OnM9by5vcHMucG9wKCksby50cnlzLnBvcCgpO2NvbnRpbnVlO2RlZmF1bHQ6aWYoIShuPShuPW8udHJ5cykubGVuZ3RoPjAmJm5bbi5sZW5ndGgtMV0pJiYoNj09PXNbMF18fDI9PT1zWzBdKSl7bz0wO2NvbnRpbnVlfWlmKDM9PT1zWzBdJiYoIW58fHNbMV0+blswXSYmc1sxXTxuWzNdKSl7by5sYWJlbD1zWzFdO2JyZWFrfWlmKDY9PT1zWzBdJiZvLmxhYmVsPG5bMV0pe28ubGFiZWw9blsxXSxuPXM7YnJlYWt9aWYobiYmby5sYWJlbDxuWzJdKXtvLmxhYmVsPW5bMl0sby5vcHMucHVzaChzKTticmVha31uWzJdJiZvLm9wcy5wb3AoKSxvLnRyeXMucG9wKCk7Y29udGludWV9cz10LmNhbGwoZSxvKX1jYXRjaChlKXtzPVs2LGVdLHI9MH1maW5hbGx5e2E9bj0wfWlmKDUmc1swXSl0aHJvdyBzWzFdO3JldHVybnt2YWx1ZTpzWzBdP3NbMV06dm9pZCAwLGRvbmU6ITB9fShbcyxwXSl9fX1mdW5jdGlvbiBnZXRQYXJhbVZhbHVlKGUsdCxhLHIpe3ZhciBuPXQuaW5wdXRQYXJhbXNbZV07aWYobiYmdm9pZCAwIT09bi5pbnB1dEluZGV4U3RhcnQpe3ZhciBzPW4uaW5wdXRJbmRleFN0YXJ0LG89MD09PW4uaW5wdXRJbmRleEVuZD92b2lkIDA6dm9pZCAwPT09bi5pbnB1dEluZGV4RW5kP3MrMTpuLmlucHV0SW5kZXhFbmQ7aWYoXCJ0ZW5zb3JcIj09PW4udHlwZSlyZXR1cm4gZ2V0VGVuc29yKHQuaW5wdXROYW1lc1tuLmlucHV0SW5kZXhTdGFydF0sYSxyKTtpZihcInRlbnNvcnNcIj09PW4udHlwZSlyZXR1cm4gdC5pbnB1dE5hbWVzLnNsaWNlKHMsbykubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBnZXRUZW5zb3IoZSxhLHIpfSk7dmFyIHA9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZ2V0VGVuc29yKHQuaW5wdXROYW1lcy5zbGljZShzKVswXSxhLHIpLmRhdGFTeW5jKCkpO3JldHVyblwibnVtYmVyXCI9PT1uLnR5cGU/cFswXTpwfXZhciBpPXQuYXR0clBhcmFtc1tlXTtyZXR1cm4gaSYmaS52YWx1ZX1mdW5jdGlvbiBnZXRUZW5zb3IoZSx0LGEpe3ZhciByPXBhcnNlTm9kZU5hbWUoZSksbj1yWzBdLHM9clsxXSxvPWEuY3VycmVudENvbnRleHRJZHMuZmluZChmdW5jdGlvbihlKXtyZXR1cm4hIXRbZ2V0Tm9kZU5hbWVXaXRoQ29udGV4dElkKG4sZSldfSk7cmV0dXJuIHZvaWQgMCE9PW8/dFtnZXROb2RlTmFtZVdpdGhDb250ZXh0SWQobixvKV1bc106dm9pZCAwfWZ1bmN0aW9uIGdldFRlbnNvcnNGb3JDdXJyZW50Q29udGVueHQoZSx0LGEpe3JldHVybiB0W2dldE5vZGVOYW1lV2l0aENvbnRleHRJZChlLGEuY3VycmVudENvbnRleHRJZCldfWZ1bmN0aW9uIGdldE5vZGVOYW1lQW5kSW5kZXgoZSx0KXt2YXIgYT1wYXJzZU5vZGVOYW1lKGUpLHI9YVswXSxuPWFbMV07cmV0dXJuW2dldE5vZGVOYW1lV2l0aENvbnRleHRJZChyLHQmJnQuY3VycmVudENvbnRleHRJZCksbl19ZnVuY3Rpb24gZ2V0Tm9kZU5hbWVXaXRoQ29udGV4dElkKGUsdCl7cmV0dXJuIHQ/ZStcIi1cIit0OmV9ZnVuY3Rpb24gcGFyc2VOb2RlTmFtZShlKXt2YXIgdD1lLmxhc3RJbmRleE9mKFwiOlwiKTtyZXR1cm4tMT09PXQ/W2UsMF06W2Uuc3Vic3RyaW5nKDAsdCksTnVtYmVyKGUuc3Vic3RyaW5nKHQrMSkpXX1mdW5jdGlvbiBzcGxpdCQxKGUsdCl7Zm9yKHZhciBhPVtdLHI9MDtyPGUubGVuZ3RoO3IrPXQpYS5wdXNoKGUuc2xpY2UocixyK3QpKTtyZXR1cm4gYX0hZnVuY3Rpb24oZSl7ZVtlLkRUX0lOVkFMSUQ9MF09XCJEVF9JTlZBTElEXCIsZVtlLkRUX0ZMT0FUPTFdPVwiRFRfRkxPQVRcIixlW2UuRFRfRE9VQkxFPTJdPVwiRFRfRE9VQkxFXCIsZVtlLkRUX0lOVDMyPTNdPVwiRFRfSU5UMzJcIixlW2UuRFRfVUlOVDg9NF09XCJEVF9VSU5UOFwiLGVbZS5EVF9JTlQxNj01XT1cIkRUX0lOVDE2XCIsZVtlLkRUX0lOVDg9Nl09XCJEVF9JTlQ4XCIsZVtlLkRUX1NUUklORz03XT1cIkRUX1NUUklOR1wiLGVbZS5EVF9DT01QTEVYNjQ9OF09XCJEVF9DT01QTEVYNjRcIixlW2UuRFRfSU5UNjQ9OV09XCJEVF9JTlQ2NFwiLGVbZS5EVF9CT09MPTEwXT1cIkRUX0JPT0xcIixlW2UuRFRfUUlOVDg9MTFdPVwiRFRfUUlOVDhcIixlW2UuRFRfUVVJTlQ4PTEyXT1cIkRUX1FVSU5UOFwiLGVbZS5EVF9RSU5UMzI9MTNdPVwiRFRfUUlOVDMyXCIsZVtlLkRUX0JGTE9BVDE2PTE0XT1cIkRUX0JGTE9BVDE2XCIsZVtlLkRUX0ZMT0FUX1JFRj0xMDFdPVwiRFRfRkxPQVRfUkVGXCIsZVtlLkRUX0RPVUJMRV9SRUY9MTAyXT1cIkRUX0RPVUJMRV9SRUZcIixlW2UuRFRfSU5UMzJfUkVGPTEwM109XCJEVF9JTlQzMl9SRUZcIixlW2UuRFRfVUlOVDhfUkVGPTEwNF09XCJEVF9VSU5UOF9SRUZcIixlW2UuRFRfSU5UMTZfUkVGPTEwNV09XCJEVF9JTlQxNl9SRUZcIixlW2UuRFRfSU5UOF9SRUY9MTA2XT1cIkRUX0lOVDhfUkVGXCIsZVtlLkRUX1NUUklOR19SRUY9MTA3XT1cIkRUX1NUUklOR19SRUZcIixlW2UuRFRfQ09NUExFWDY0X1JFRj0xMDhdPVwiRFRfQ09NUExFWDY0X1JFRlwiLGVbZS5EVF9JTlQ2NF9SRUY9MTA5XT1cIkRUX0lOVDY0X1JFRlwiLGVbZS5EVF9CT09MX1JFRj0xMTBdPVwiRFRfQk9PTF9SRUZcIixlW2UuRFRfUUlOVDhfUkVGPTExMV09XCJEVF9RSU5UOF9SRUZcIixlW2UuRFRfUVVJTlQ4X1JFRj0xMTJdPVwiRFRfUVVJTlQ4X1JFRlwiLGVbZS5EVF9RSU5UMzJfUkVGPTExM109XCJEVF9RSU5UMzJfUkVGXCIsZVtlLkRUX0JGTE9BVDE2X1JFRj0xMTRdPVwiRFRfQkZMT0FUMTZfUkVGXCJ9KERhdGFUeXBlfHwoRGF0YVR5cGU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7ZVtlLkxFR0FDWT0wXT1cIkxFR0FDWVwiLGVbZS5WMT0xXT1cIlYxXCIsZVtlLlYyPTJdPVwiVjJcIn0oZS5DaGVja3BvaW50Rm9ybWF0VmVyc2lvbnx8KGUuQ2hlY2twb2ludEZvcm1hdFZlcnNpb249e30pKX0oU2F2ZXJEZWZ8fChTYXZlckRlZj17fSkpO3ZhciBqc29uPVt7dGZPcE5hbWU6XCJBZGRcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBZGROXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxlbmQ6MCxuYW1lOlwidGVuc29yc1wiLHR5cGU6XCJ0ZW5zb3JzXCJ9XX0se3RmT3BOYW1lOlwiQmlhc0FkZFwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlN1YlwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJlYWxEaXZcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJEaXZcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJGbG9vckRpdlwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk11bFwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk1heGltdW1cIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJNaW5pbXVtXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiUG93XCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU3F1YXJlZERpZmZlcmVuY2VcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJNb2RcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJGbG9vck1vZFwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19XSxhcml0aG1ldGljPU9iamVjdC5mcmVlemUoe2pzb246anNvbn0pLGpzb24kMT1be3RmT3BOYW1lOlwiQWJzXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBY29zXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBc2luXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBdGFuXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBdGFuMlwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJ5XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkNlaWxcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkNsaXBCeVZhbHVlXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiY2xpcF92YWx1ZV9taW5cIixuYW1lOlwiY2xpcFZhbHVlTWluXCIsdHlwZTpcIm51bWJlclwifSx7dGZOYW1lOlwiY2xpcF92YWx1ZV9tYXhcIixuYW1lOlwiY2xpcFZhbHVlTWF4XCIsdHlwZTpcIm51bWJlclwifV19LHt0Zk9wTmFtZTpcIkNvc1wiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQ29zaFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRWx1XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJFeHBcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkZsb29yXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMb2dcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk5lZ1wiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmVsdVwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmVsdTZcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwiY2xpcFZhbHVlTWluXCIsbmFtZTpcImNsaXBWYWx1ZU1pblwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmTmFtZTpcImNsaXBWYWx1ZU1heFwiLG5hbWU6XCJjbGlwVmFsdWVNYXhcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjZ9XX0se3RmT3BOYW1lOlwiU2VsdVwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU2lnbW9pZFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU2luXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTaW5oXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTcXJ0XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSc3FydFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU3F1YXJlXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJUYW5cIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRhbmhcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNpZ25cIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJvdW5kXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJFeHBtMVwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTG9nMXBcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJlY2lwcm9jYWxcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNvZnRwbHVzXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBc2luaFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQWNvc2hcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkF0YW5oXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJFcmZcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlByb2RcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhlc1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJrZWVwX2RpbXNcIixuYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTGVha3lSZWx1XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiYWxwaGFcIixuYW1lOlwiYWxwaGFcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOi4yfSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfV0sYmFzaWNNYXRoPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQxfSksanNvbiQyPVt7dGZPcE5hbWU6XCJMb29wQ29uZFwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInByZWRcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiU3dpdGNoXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiZGF0YVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInByZWRcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiTWVyZ2VcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLGVuZDowLG5hbWU6XCJ0ZW5zb3JzXCIsdHlwZTpcInRlbnNvcnNcIn1dfSx7dGZPcE5hbWU6XCJFbnRlclwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcImZyYW1lX25hbWVcIixuYW1lOlwiZnJhbWVOYW1lXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiaXNfY29uc3RhbnRcIixuYW1lOlwiaXNDb25zdGFudFwiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiRXhpdFwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJOZXh0SXRlcmF0aW9uXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5VjNcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzaXplXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJkdHlwZVwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifSx7dGZOYW1lOlwiZWxlbWVudF9zaGFwZVwiLG5hbWU6XCJlbGVtZW50U2hhcGVcIix0eXBlOlwic2hhcGVcIn0se3RmTmFtZTpcImR5bmFtaWNfc2l6ZVwiLG5hbWU6XCJkeW5hbWljU2l6ZVwiLHR5cGU6XCJib29sXCJ9LHt0Zk5hbWU6XCJjbGVhcl9hZnRlcl9yZWFkXCIsbmFtZTpcImNsZWFyQWZ0ZXJSZWFkXCIsdHlwZTpcImJvb2xcIn0se3RmTmFtZTpcImlkZW50aWNhbF9lbGVtZW50X3NoYXBlc1wiLG5hbWU6XCJpZGVudGljYWxFbGVtZW50U2hhcGVzXCIsdHlwZTpcImJvb2xcIn0se3RmTmFtZTpcInRlbnNvcl9hcnJheV9uYW1lXCIsbmFtZTpcIm5hbWVcIix0eXBlOlwic3RyaW5nXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlXcml0ZVYzXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjEsbmFtZTpcImluZGV4XCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MixuYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MyxuYW1lOlwiZmxvd0luXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5UmVhZFYzXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjEsbmFtZTpcImluZGV4XCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MixuYW1lOlwiZmxvd0luXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJkdHlwZVwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheUdhdGhlclYzXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjEsbmFtZTpcImluZGljZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjIsbmFtZTpcImZsb3dJblwiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZHR5cGVcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn0se3RmTmFtZTpcImVsZW1lbnRfc2hhcGVcIixuYW1lOlwiZWxlbWVudFNoYXBlXCIsdHlwZTpcInNoYXBlXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlTY2F0dGVyVjNcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JBcnJheUlkXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MSxuYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MixuYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MyxuYW1lOlwiZmxvd0luXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlDb25jYXRWM1wiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvckFycmF5SWRcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoxLG5hbWU6XCJmbG93SW5cIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcImR0eXBlXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9LHt0Zk5hbWU6XCJlbGVtZW50X3NoYXBlX2V4Y2VwdDBcIixuYW1lOlwiZWxlbWVudFNoYXBlRXhjZXB0MFwiLHR5cGU6XCJzaGFwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheVNwbGl0VjNcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JBcnJheUlkXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MSxuYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwibGVuZ3Roc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MyxuYW1lOlwiZmxvd0luXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlTaXplVjNcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JBcnJheUlkXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MSxuYW1lOlwiZmxvd0luXCIsdHlwZTpcIm51bWJlclwifV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5Q2xvc2VWM1wiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvckFycmF5SWRcIix0eXBlOlwibnVtYmVyXCJ9XX1dLGNvbnRyb2w9T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDJ9KSxqc29uJDM9W3t0Zk9wTmFtZTpcIkF2Z1Bvb2xcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwia3NpemVcIixuYW1lOlwia2VybmVsU2l6ZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJNYXhQb29sXCIsY2F0ZWdvcnk6XCJjb252b2x1dGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcInN0cmlkZXNcIixuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwicGFkZGluZ1wiLG5hbWU6XCJwYWRcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJkYXRhX2Zvcm1hdFwiLG5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcImtzaXplXCIsbmFtZTpcImtlcm5lbFNpemVcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQ29udjFEXCIsY2F0ZWdvcnk6XCJjb252b2x1dGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJmaWx0ZXJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcInN0cmlkZVwiLG5hbWU6XCJzdHJpZGVcIix0eXBlOlwibnVtYmVyXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsZGVmYXVsdFZhbHVlOlwiTldDXCJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwiZGlsYXRpb25cIixuYW1lOlwiZGlsYXRpb25cIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjF9XX0se3RmT3BOYW1lOlwiQ29udjJEXCIsY2F0ZWdvcnk6XCJjb252b2x1dGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJmaWx0ZXJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJzdHJpZGVzXCIsbmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcInBhZGRpbmdcIixuYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwidXNlQ3Vkbm5PbkdwdVwiLG5hbWU6XCJ1c2VDdWRubk9uR3B1XCIsdHlwZTpcImJvb2xcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsZGVmYXVsdFZhbHVlOlwiTkhXQ1wifSx7dGZOYW1lOlwiZGlsYXRpb25zXCIsbmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIkNvbnYyREJhY2twcm9wSW5wdXRcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MixuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImZpbHRlclwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjAsbmFtZTpcIm91dHB1dFNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcInN0cmlkZXNcIixuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwicGFkZGluZ1wiLG5hbWU6XCJwYWRcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJkYXRhX2Zvcm1hdFwiLG5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJEZXB0aHdpc2VDb252MmRcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiaW5wdXRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJmaWx0ZXJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcInN0cmlkZXNcIixuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwicGFkZGluZ1wiLG5hbWU6XCJwYWRcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJkYXRhX2Zvcm1hdFwiLG5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLGRlZmF1bHRWYWx1ZTpcIk5IV0NcIn0se3RmTmFtZTpcImRpbGF0aW9uc1wiLG5hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJEZXB0aHdpc2VDb252MmROYXRpdmVcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiaW5wdXRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJmaWx0ZXJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcInN0cmlkZXNcIixuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwicGFkZGluZ1wiLG5hbWU6XCJwYWRcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJkYXRhX2Zvcm1hdFwiLG5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLGRlZmF1bHRWYWx1ZTpcIk5IV0NcIn0se3RmTmFtZTpcImRpbGF0aW9uc1wiLG5hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwibnVtYmVyW11cIn1dfV0sY29udm9sdXRpb249T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDN9KSxqc29uJDQ9W3t0Zk9wTmFtZTpcIkZpbGxcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwic2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjEsbmFtZTpcInZhbHVlXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiTGluU3BhY2VcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwic3RhcnRcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoxLG5hbWU6XCJzdG9wXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MixuYW1lOlwibnVtXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk9uZUhvdFwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJpbmRpY2VzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZGVwdGhcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoyLG5hbWU6XCJvblZhbHVlXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToxfSx7c3RhcnQ6MyxuYW1lOlwib2ZmVmFsdWVcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9XSxhdHRyczpbe3RmTmFtZTpcImF4aXNcIixuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk9uZXNcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwic2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIk9uZXNMaWtlXCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImR0eXBlXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiUmFuZG9tVW5pZm9ybVwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJtaW52YWxcIixuYW1lOlwibWludmFsXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZOYW1lOlwibWF4dmFsXCIsbmFtZTpcIm1heHZhbFwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MX0se3RmTmFtZTpcImR0eXBlXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9LHt0Zk5hbWU6XCJzZWVkXCIsbmFtZTpcInNlZWRcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0Zk5hbWU6XCJzZWVkMlwiLG5hbWU6XCJzZWVkMlwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MCxub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcIlRcIix0eXBlOlwibnVtYmVyXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJhbmdlXCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInN0YXJ0XCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MSxuYW1lOlwic3RvcFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjIsbmFtZTpcInN0ZXBcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9XSxhdHRyczpbe3RmTmFtZTpcIlRpZHhcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJUcnVuY2F0ZWROb3JtYWxcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwic2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwibWVhbnNcIixuYW1lOlwibWVhblwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmTmFtZTpcInN0ZGRldlwiLG5hbWU6XCJzdGREZXZcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjF9LHt0Zk5hbWU6XCJzZWVkXCIsbmFtZTpcInNlZWRcIix0eXBlOlwibnVtYmVyXCJ9LHt0Zk5hbWU6XCJzZWVkMlwiLG5hbWU6XCJzZWVkMlwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MCxub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJkdHlwZVwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJUXCIsdHlwZTpcIm51bWJlclwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJaZXJvc1wiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiWmVyb3NMaWtlXCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfV0sY3JlYXRpb249T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDR9KSxqc29uJDU9W3t0Zk9wTmFtZTpcIk5vbk1heFN1cHByZXNzaW9uVjJcIixjYXRlZ29yeTpcImR5bmFtaWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJib3hlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInNjb3Jlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcIm1heE91dHB1dFNpemVcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDozLG5hbWU6XCJpb3VUaHJlc2hvbGRcIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiTm9uTWF4U3VwcHJlc3Npb25WM1wiLGNhdGVnb3J5OlwiZHluYW1pY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImJveGVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwic2NvcmVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwibWF4T3V0cHV0U2l6ZVwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjMsbmFtZTpcImlvdVRocmVzaG9sZFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjQsbmFtZTpcInNjb3JlVGhyZXNob2xkXCIsdHlwZTpcIm51bWJlclwifV19LHt0Zk9wTmFtZTpcIldoZXJlXCIsY2F0ZWdvcnk6XCJkeW5hbWljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiY29uZGl0aW9uXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxpc3REaWZmXCIsY2F0ZWdvcnk6XCJkeW5hbWljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInlcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX1dLGR5bmFtaWM9T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDV9KSxqc29uJDY9W3t0Zk9wTmFtZTpcIlRvcEtWMlwiLGNhdGVnb3J5OlwiZXZhbHVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJrXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzb3J0ZWRcIixuYW1lOlwic29ydGVkXCIsdHlwZTpcImJvb2xcIn1dfV0sZXZhbHVhdGlvbj1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kNn0pLGpzb24kNz1be3RmT3BOYW1lOlwiUGxhY2Vob2xkZXJXaXRoRGVmYXVsdFwiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJkZWZhdWx0XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzaGFwZVwiLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJzaGFwZVwifSx7dGZOYW1lOlwiZHR5cGVcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJQbGFjZWhvbGRlclwiLGNhdGVnb3J5OlwiZ3JhcGhcIixhdHRyczpbe3RmTmFtZTpcInNoYXBlXCIsbmFtZTpcInNoYXBlXCIsdHlwZTpcInNoYXBlXCJ9LHt0Zk5hbWU6XCJkdHlwZVwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIkNvbnN0XCIsY2F0ZWdvcnk6XCJncmFwaFwifSx7dGZPcE5hbWU6XCJJZGVudGl0eVwiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIklkZW50aXR5TlwiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLGVuZDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvcnNcIn1dfSx7dGZPcE5hbWU6XCJTbmFwc2hvdFwiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlJhbmtcIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJTaXplXCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiU2hhcGVcIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJTaGFwZU5cIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxlbmQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JzXCJ9XX0se3RmT3BOYW1lOlwiUHJpbnRcIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImRhdGFcIix0eXBlOlwidGVuc29yc1wifV0sYXR0cnM6W3t0Zk5hbWU6XCJtZXNzYWdlXCIsbmFtZTpcIm1lc3NhZ2VcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJmaXJzdF9uXCIsbmFtZTpcImZpcnN0TlwiLHR5cGU6XCJudW1iZXJcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJzdW1tYXJpemVcIixuYW1lOlwic3VtbWFyaXplXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTozfV19LHt0Zk9wTmFtZTpcIk5vT3BcIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOltdfSx7dGZPcE5hbWU6XCJTdG9wR3JhZGllbnRcIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJGYWtlUXVhbnRXaXRoTWluTWF4VmFyc1wiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJtaW5cIixuYW1lOlwibWluXCIsdHlwZTpcIm51bWJlclwifSx7dGZOYW1lOlwibWF4XCIsbmFtZTpcIm1heFwiLHR5cGU6XCJudW1iZXJcIn1dfV0sZ3JhcGg9T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDd9KSxqc29uJDg9W3t0Zk9wTmFtZTpcIlJlc2l6ZUJpbGluZWFyXCIsY2F0ZWdvcnk6XCJpbWFnZVwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImltYWdlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInNpemVcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwiYWxpZ25fY29ybmVyc1wiLG5hbWU6XCJhbGlnbkNvcm5lcnNcIix0eXBlOlwiYm9vbFwifSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSZXNpemVOZWFyZXN0TmVpZ2hib3JcIixjYXRlZ29yeTpcImltYWdlXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiaW1hZ2VzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwic2l6ZVwiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJhbGlnbl9jb3JuZXJzXCIsbmFtZTpcImFsaWduQ29ybmVyc1wiLHR5cGU6XCJib29sXCJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkNyb3BBbmRSZXNpemVcIixjYXRlZ29yeTpcImltYWdlXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiaW1hZ2VcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJib3hlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcImJveEluZFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjMsbmFtZTpcImNyb3BTaXplXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcIm1ldGhvZFwiLG5hbWU6XCJtZXRob2RcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJleHRyYXBvbGF0aW9uX3ZhbHVlXCIsbmFtZTpcImV4dHJhcG9sYXRpb25WYWx1ZVwiLHR5cGU6XCJudW1iZXJcIn1dfV0saW1hZ2UkMT1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kOH0pLGpzb24kOT1be3RmT3BOYW1lOlwiRXF1YWxcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJOb3RFcXVhbFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkdyZWF0ZXJcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJHcmVhdGVyRXF1YWxcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMZXNzXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTGVzc0VxdWFsXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTG9naWNhbEFuZFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxvZ2ljYWxOb3RcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxvZ2ljYWxPclwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNlbGVjdFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImNvbmRpdGlvblwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19XSxsb2dpY2FsPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQ5fSksanNvbiQxMD1be3RmT3BOYW1lOlwiTWF0TXVsXCIsY2F0ZWdvcnk6XCJtYXRyaWNlc1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJ0cmFuc3Bvc2VfYVwiLG5hbWU6XCJ0cmFuc3Bvc2VBXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITF9LHt0Zk5hbWU6XCJ0cmFuc3Bvc2VfYlwiLG5hbWU6XCJ0cmFuc3Bvc2VCXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITF9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkJhdGNoTWF0TXVsXCIsY2F0ZWdvcnk6XCJtYXRyaWNlc1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJhZGpfeFwiLG5hbWU6XCJ0cmFuc3Bvc2VBXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITF9LHt0Zk5hbWU6XCJhZGpfeVwiLG5hbWU6XCJ0cmFuc3Bvc2VCXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITF9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRyYW5zcG9zZVwiLGNhdGVnb3J5OlwibWF0cmljZXNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwicGVybVwiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19XSxtYXRyaWNlcz1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kMTB9KSxqc29uJDExPVt7dGZPcE5hbWU6XCJGdXNlZEJhdGNoTm9ybVwiLGNhdGVnb3J5Olwibm9ybWFsaXphdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJzY2FsZVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcIm9mZnNldFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjMsbmFtZTpcIm1lYW5cIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDo0LG5hbWU6XCJ2YXJpYW5jZVwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZXBzaWxvblwiLG5hbWU6XCJlcHNpbG9uXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTouMDAxfSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRnVzZWRCYXRjaE5vcm1WMlwiLGNhdGVnb3J5Olwibm9ybWFsaXphdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJzY2FsZVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcIm9mZnNldFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjMsbmFtZTpcIm1lYW5cIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDo0LG5hbWU6XCJ2YXJpYW5jZVwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZXBzaWxvblwiLG5hbWU6XCJlcHNpbG9uXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTouMDAxfSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTFJOXCIsY2F0ZWdvcnk6XCJub3JtYWxpemF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZGVwdGhfcmFkaXVzXCIsbmFtZTpcInJhZGl1c1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6NX0se3RmTmFtZTpcImJpYXNcIixuYW1lOlwiYmlhc1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MX0se3RmTmFtZTpcImFscGhhXCIsbmFtZTpcImFscGhhXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToxfSx7dGZOYW1lOlwiYmV0YVwiLG5hbWU6XCJiZXRhXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTouNX1dfSx7dGZPcE5hbWU6XCJTb2Z0bWF4XCIsY2F0ZWdvcnk6XCJub3JtYWxpemF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJMb2dTb2Z0bWF4XCIsY2F0ZWdvcnk6XCJub3JtYWxpemF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJTcGFyc2VUb0RlbnNlXCIsY2F0ZWdvcnk6XCJub3JtYWxpemF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwic3BhcnNlSW5kaWNlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcIm91dHB1dFNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJzcGFyc2VWYWx1ZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDozLG5hbWU6XCJkZWZhdWx0VmFsdWVcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcInZhbGlkYXRlX2luZGljZXNcIixuYW1lOlwidmFsaWRhdGVJbmRpY2VzXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITAsbm90U3VwcG9ydGVkOiEwfV19XSxub3JtYWxpemF0aW9uPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQxMX0pLGpzb24kMTI9W3t0Zk9wTmFtZTpcIk1heFwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwia2VlcF9kaW1zXCIsbmFtZTpcImtlZXBEaW1zXCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJNZWFuXCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJrZWVwX2RpbXNcIixuYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIk1pblwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwia2VlcF9kaW1zXCIsbmFtZTpcImtlZXBEaW1zXCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJTdW1cIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImtlZXBfZGltc1wiLG5hbWU6XCJrZWVwRGltc1wiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiQWxsXCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJrZWVwX2RpbXNcIixuYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIkFueVwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwia2VlcF9kaW1zXCIsbmFtZTpcImtlZXBEaW1zXCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJBcmdNYXhcIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwifV19LHt0Zk9wTmFtZTpcIkFyZ01pblwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiUHJvZFwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwia2VlcF9kaW1zXCIsbmFtZTpcImtlZXBEaW1zXCIsdHlwZTpcImJvb2xcIn1dfV0scmVkdWN0aW9uPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQxMn0pLGpzb24kMTM9W3t0Zk9wTmFtZTpcIkNvbmNhdFYyXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxlbmQ6LTEsbmFtZTpcInRlbnNvcnNcIix0eXBlOlwidGVuc29yc1wifSx7c3RhcnQ6LTEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiQ29uY2F0XCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MSxlbmQ6MCxuYW1lOlwidGVuc29yc1wiLHR5cGU6XCJ0ZW5zb3JzXCJ9LHtzdGFydDowLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwifV19LHt0Zk9wTmFtZTpcIkdhdGhlclYyXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfV19LHt0Zk9wTmFtZTpcIkdhdGhlclwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJpbmRpY2VzXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJheGlzXCIsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0Zk5hbWU6XCJ2YWxpZGF0ZV9pbmRpY2VzXCIsbmFtZTpcInZhbGlkYXRlSW5kaWNlc1wiLHR5cGU6XCJib29sXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJldmVyc2VcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZGltc1wiLHR5cGU6XCJib29sXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJldmVyc2VWMlwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiU2xpY2VcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYmVnaW5cIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjIsbmFtZTpcInNpemVcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJTdHJpZGVkU2xpY2VcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYmVnaW5cIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjIsbmFtZTpcImVuZFwiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MyxuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJiZWdpbl9tYXNrXCIsbmFtZTpcImJlZ2luTWFza1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmTmFtZTpcImVuZF9tYXNrXCIsbmFtZTpcImVuZE1hc2tcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0Zk5hbWU6XCJuZXdfYXhpc19tYXNrXCIsbmFtZTpcIm5ld0F4aXNNYXNrXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZOYW1lOlwiZWxsaXBzaXNfbWFza1wiLG5hbWU6XCJlbGxpcHNpc01hc2tcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0Zk5hbWU6XCJzaHJpbmtfYXhpc19tYXNrXCIsbmFtZTpcInNocmlua0F4aXNNYXNrXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfV19LHt0Zk9wTmFtZTpcIlBhY2tcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLGVuZDowLG5hbWU6XCJ0ZW5zb3JzXCIsdHlwZTpcInRlbnNvcnNcIn1dLGF0dHJzOlt7dGZOYW1lOlwiYXhpc1wiLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfV19LHt0Zk9wTmFtZTpcIlVucGFja1wiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiYXhpc1wiLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZOYW1lOlwibnVtXCIsbmFtZTpcIm51bVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MCxub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVGlsZVwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJyZXBzXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiU3BsaXRcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7c3RhcnQ6MSxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwibnVtX3NwbGl0XCIsbmFtZTpcIm51bU9yU2l6ZVNwbGl0c1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MX1dfSx7dGZPcE5hbWU6XCJTcGxpdFZcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwibnVtT3JTaXplU3BsaXRzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfV19LHt0Zk9wTmFtZTpcIlNjYXR0ZXJOZFwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJ2YWx1ZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIkdhdGhlck5kXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiU3BhcnNlVG9EZW5zZVwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInNwYXJzZUluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJvdXRwdXRTaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MixuYW1lOlwic3BhcnNlVmFsdWVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MyxuYW1lOlwiZGVmYXVsdFZhbHVlXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJ2YWxpZGF0ZV9pbmRpY2VzXCIsbmFtZTpcInZhbGlkYXRlSW5kaWNlc1wiLHR5cGU6XCJib29sXCIsZGVmYXVsdFZhbHVlOiExLG5vdFN1cHBvcnRlZDohMH1dfV0sc2xpY2VKb2luPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQxM30pLGpzb24kMTQ9W3t0Zk9wTmFtZTpcIkZGVFwiLGNhdGVnb3J5Olwic3BlY3RyYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIklGRlRcIixjYXRlZ29yeTpcInNwZWN0cmFsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJSRkZUXCIsY2F0ZWdvcnk6XCJzcGVjdHJhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJmZnRfbGVuZ3RoXCIsdHlwZTpcIm51bWJlclwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJJUkZGVFwiLGNhdGVnb3J5Olwic3BlY3RyYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZmZ0X2xlbmd0aFwiLHR5cGU6XCJudW1iZXJcIixub3RTdXBwb3J0ZWQ6ITB9XX1dLHNwZWN0cmFsPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQxNH0pLGpzb24kMTU9W3t0Zk9wTmFtZTpcIkNhc3RcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiU3JjVFwiLG5hbWU6XCJzZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJEc3RUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiRXhwYW5kRGltc1wiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJQYWRcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInBhZGRpbmdcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwiY29uc3RhbnRfdmFsdWVcIixuYW1lOlwiY29uc3RhbnRWYWx1ZVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH1dfSx7dGZPcE5hbWU6XCJQYWRWMlwiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwicGFkZGluZ1wiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MixuYW1lOlwiY29uc3RhbnRWYWx1ZVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH1dfSx7dGZPcE5hbWU6XCJSZXNoYXBlXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIlNxdWVlemVcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiYXhpc1wiLHRmRGVwcmVjYXRlZE5hbWU6XCJzcXVlZXplX2RpbXNcIixuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIlNwYWNlVG9CYXRjaE5EXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJibG9ja1NoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJwYWRkaW5nc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIkJhdGNoVG9TcGFjZU5EXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJibG9ja1NoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJjcm9wc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIkRlcHRoVG9TcGFjZVwiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJibG9ja19zaXplXCIsbmFtZTpcImJsb2NrU2l6ZVwiLHR5cGU6XCJudW1iZXJcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCJ9XX1dLHRyYW5zZm9ybWF0aW9uPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQxNX0pLENPTlRST0xfRkxPV19PUFM9W1wiU3dpdGNoXCIsXCJNZXJnZVwiLFwiRW50ZXJcIixcIkV4aXRcIixcIk5leHRJdGVyYXRpb25cIl0sRFlOQU1JQ19TSEFQRV9PUFM9W1wiTm9uTWF4U3VwcHJlc3Npb25WMlwiLFwiTm9uTWF4U3VwcHJlc3Npb25WM1wiLFwiV2hlcmVcIl0sT3BlcmF0aW9uTWFwcGVyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3ZhciBlPVthcml0aG1ldGljLGJhc2ljTWF0aCxjb250cm9sLGNvbnZvbHV0aW9uLGNyZWF0aW9uLGR5bmFtaWMsZXZhbHVhdGlvbixsb2dpY2FsLGltYWdlJDEsZ3JhcGgsbWF0cmljZXMsbm9ybWFsaXphdGlvbixyZWR1Y3Rpb24sc2xpY2VKb2luLHNwZWN0cmFsLHRyYW5zZm9ybWF0aW9uXSx0PVtdLmNvbmNhdC5hcHBseShbXSxlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5qc29ufSkpO3RoaXMub3BNYXBwZXJzPXQucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbdC50Zk9wTmFtZV09dCxlfSx7fSl9cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiSW5zdGFuY2VcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2luc3RhbmNlfHwodGhpcy5faW5zdGFuY2U9bmV3IHRoaXMpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGUucHJvdG90eXBlLmlzQ29udHJvbEZsb3c9ZnVuY3Rpb24oZSl7cmV0dXJuIENPTlRST0xfRkxPV19PUFMuc29tZShmdW5jdGlvbih0KXtyZXR1cm4gdD09PWUub3B9KX0sZS5wcm90b3R5cGUuaXNEeW5hbWljU2hhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuIERZTkFNSUNfU0hBUEVfT1BTLnNvbWUoZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT1lLm9wfSl9LGUucHJvdG90eXBlLnRyYW5zZm9ybUdyYXBoPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsYT0hMSxyPSExLG49W10scz1bXSxvPWUubm9kZS5yZWR1Y2UoZnVuY3Rpb24oZSxvKXtyZXR1cm4gZVtvLm5hbWVdPXQubWFwTm9kZShvKSx0LmlzQ29udHJvbEZsb3cobykmJihhPSEwKSx0LmlzRHluYW1pY1NoYXBlKG8pJiYocj0hMCksXCJQbGFjZWhvbGRlclwiPT09by5vcCYmbi5wdXNoKGVbby5uYW1lXSksXCJDb25zdFwiPT09by5vcCYmcy5wdXNoKGVbby5uYW1lXSksZX0se30pLHA9W10saT1bXTtyZXR1cm4gT2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1vW2VdO3QuaW5wdXROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciBhPWdldE5vZGVOYW1lQW5kSW5kZXgoZSlbMF07dC5pbnB1dHMucHVzaChvW2FdKSxvW2FdLmNoaWxkcmVuLnB1c2godCl9KSwwPT09dC5pbnB1dHMubGVuZ3RoJiZwLnB1c2godCl9KSxPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PW9bZV07MD09PXQuY2hpbGRyZW4ubGVuZ3RoJiZpLnB1c2godCl9KSx7bm9kZXM6byxpbnB1dHM6cCxvdXRwdXRzOmksd2VpZ2h0czpzLHBsYWNlaG9sZGVyczpuLHdpdGhDb250cm9sRmxvdzphLHdpdGhEeW5hbWljU2hhcGU6cn19LGUucHJvdG90eXBlLm1hcE5vZGU9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxhPXRoaXMub3BNYXBwZXJzW2Uub3BdO2lmKHZvaWQgMD09PWEpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yZmxvdyBPcCBpcyBub3Qgc3VwcG9ydGVkOiBcIitlLm9wKTt2YXIgcj17bmFtZTplLm5hbWUsb3A6ZS5vcCxjYXRlZ29yeTphLmNhdGVnb3J5LGlucHV0TmFtZXM6KGUuaW5wdXR8fFtdKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3RhcnRzV2l0aChcIl5cIik/ZS5zdWJzdHIoMSk6ZX0pLGlucHV0czpbXSxjaGlsZHJlbjpbXSxpbnB1dFBhcmFtczp7fSxhdHRyUGFyYW1zOnt9fTtyZXR1cm4gbnVsbD09ZS5hdHRyJiYoZS5hdHRyPXt9KSxudWxsIT1hLmlucHV0cyYmKHIuaW5wdXRQYXJhbXM9YS5pbnB1dHMucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbdC5uYW1lXT17dHlwZTp0LnR5cGUsaW5wdXRJbmRleFN0YXJ0OnQuc3RhcnQsaW5wdXRJbmRleEVuZDp0LmVuZH0sZX0se30pKSxudWxsIT1hLmF0dHJzJiYoci5hdHRyUGFyYW1zPWEuYXR0cnMucmVkdWNlKGZ1bmN0aW9uKGEscil7dmFyIG49ci50eXBlLHM9dm9pZCAwO3N3aXRjaChyLnR5cGUpe2Nhc2VcInN0cmluZ1wiOnZvaWQgMD09PShzPXQuZ2V0U3RyaW5nUGFyYW0oZS5hdHRyLHIudGZOYW1lLHIuZGVmYXVsdFZhbHVlKSkmJnIudGZEZXByZWNhdGVkTmFtZSYmKHM9dC5nZXRTdHJpbmdQYXJhbShlLmF0dHIsci50ZkRlcHJlY2F0ZWROYW1lLHIuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwibnVtYmVyXCI6dm9pZCAwPT09KHM9dC5nZXROdW1iZXJQYXJhbShlLmF0dHIsci50Zk5hbWUsci5kZWZhdWx0VmFsdWV8fDApKSYmci50ZkRlcHJlY2F0ZWROYW1lJiYocz10LmdldE51bWJlclBhcmFtKGUuYXR0cixyLnRmRGVwcmVjYXRlZE5hbWUsci5kZWZhdWx0VmFsdWUpKTticmVhaztjYXNlXCJudW1iZXJbXVwiOnZvaWQgMD09PShzPXQuZ2V0TnVtZXJpY0FycmF5UGFyYW0oZS5hdHRyLHIudGZOYW1lLHIuZGVmYXVsdFZhbHVlKSkmJnIudGZEZXByZWNhdGVkTmFtZSYmKHM9dC5nZXROdW1lcmljQXJyYXlQYXJhbShlLmF0dHIsci50ZkRlcHJlY2F0ZWROYW1lLHIuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwiYm9vbFwiOnZvaWQgMD09PShzPXQuZ2V0Qm9vbFBhcmFtKGUuYXR0cixyLnRmTmFtZSxyLmRlZmF1bHRWYWx1ZSkpJiZyLnRmRGVwcmVjYXRlZE5hbWUmJihzPXQuZ2V0Qm9vbFBhcmFtKGUuYXR0cixyLnRmRGVwcmVjYXRlZE5hbWUsci5kZWZhdWx0VmFsdWUpKTticmVhaztjYXNlXCJzaGFwZVwiOnZvaWQgMD09PShzPXQuZ2V0VGVuc29yU2hhcGVQYXJhbShlLmF0dHIsci50Zk5hbWUsci5kZWZhdWx0VmFsdWUpKSYmci50ZkRlcHJlY2F0ZWROYW1lJiYocz10LmdldFRlbnNvclNoYXBlUGFyYW0oZS5hdHRyLHIudGZEZXByZWNhdGVkTmFtZSxyLmRlZmF1bHRWYWx1ZSkpO2JyZWFrO2Nhc2VcImR0eXBlXCI6dm9pZCAwPT09KHM9dC5nZXREdHlwZVBhcmFtKGUuYXR0cixyLnRmTmFtZSxyLmRlZmF1bHRWYWx1ZSkpJiZyLnRmRGVwcmVjYXRlZE5hbWUmJihzPXQuZ2V0RHR5cGVQYXJhbShlLmF0dHIsci50ZkRlcHJlY2F0ZWROYW1lLHIuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwidGVuc29yXCI6Y2FzZVwidGVuc29yc1wiOmJyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgcGFyYW0gdHlwZTogXCIrci50eXBlK1wiIGZvciBvcDogXCIrZS5vcCl9cmV0dXJuIGFbci5uYW1lXT17dmFsdWU6cyx0eXBlOm59LGF9LHt9KSkscn0sZS5wcm90b3R5cGUuZGVjb2RlQmFzZTY0PWZ1bmN0aW9uKGUpe3ZhciB0PUVOVi5nbG9iYWw7aWYodm9pZCAwIT09dC5hdG9iKXJldHVybiB0LmF0b2IoZSk7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEJ1ZmZlcilyZXR1cm4gbmV3IEJ1ZmZlcihlLFwiYmFzZTY0XCIpLnRvU3RyaW5nKCk7dGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGRlY29kZSBiYXNlNjQgaW4gdGhpcyBlbnZpcm9ubWVudC4gTWlzc2luZyBidWlsdC1pbiBhdG9iKCkgb3IgQnVmZmVyKClcIil9LGUucHJvdG90eXBlLmdldFN0cmluZ1BhcmFtPWZ1bmN0aW9uKGUsdCxhLHIpe3ZvaWQgMD09PXImJihyPSExKTt2YXIgbj1lW3RdO2lmKHZvaWQgMCE9PW4pe3ZhciBzPUFycmF5LmlzQXJyYXkobi5zKT9TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsbi5zKTp0aGlzLmRlY29kZUJhc2U2NChuLnMpO3JldHVybiByP3M6cy50b0xvd2VyQ2FzZSgpfXJldHVybiBhfSxlLnByb3RvdHlwZS5nZXRCb29sUGFyYW09ZnVuY3Rpb24oZSx0LGEpe3ZhciByPWVbdF07cmV0dXJuIHI/ci5iOmF9LGUucHJvdG90eXBlLmdldE51bWJlclBhcmFtPWZ1bmN0aW9uKGUsdCxhKXt2YXIgcj1lW3RdfHx7fSxuPXIuaT9yLmk6ci5mP3IuZjphO3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBuP246cGFyc2VJbnQobiwxMCl9LGUucHJvdG90eXBlLmdldER0eXBlUGFyYW09ZnVuY3Rpb24oZSx0LGEpe3ZhciByPWVbdF07aWYociYmci50eXBlKXt2YXIgbj1yLnR5cGU7c3dpdGNoKFwic3RyaW5nXCI9PXR5cGVvZiByLnR5cGUmJihuPURhdGFUeXBlW3IudHlwZV0pLG4pe2Nhc2UgRGF0YVR5cGUuRFRfRkxPQVQ6cmV0dXJuXCJmbG9hdDMyXCI7Y2FzZSBEYXRhVHlwZS5EVF9JTlQzMjpyZXR1cm5cImludDMyXCI7Y2FzZSBEYXRhVHlwZS5EVF9CT09MOnJldHVyblwiYm9vbFwiO2RlZmF1bHQ6cmV0dXJuIGF9fXJldHVybiBhfSxlLnByb3RvdHlwZS5nZXRUZW5zb3JTaGFwZVBhcmFtPWZ1bmN0aW9uKGUsdCxhKXt2YXIgcj1lW3RdO2lmKHImJnIuc2hhcGUpe2lmKHIuc2hhcGUudW5rbm93blJhbmspcmV0dXJuO2lmKG51bGwhPXIuc2hhcGUuZGltKXJldHVybiByLnNoYXBlLmRpbS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIGUuc2l6ZT9lLnNpemU6cGFyc2VJbnQoZS5zaXplLDEwKX0pfXJldHVybiBhfSxlLnByb3RvdHlwZS5nZXROdW1lcmljQXJyYXlQYXJhbT1mdW5jdGlvbihlLHQsYSl7dmFyIHI9ZVt0XTtyZXR1cm4gcj8oci5saXN0LmYmJnIubGlzdC5mLmxlbmd0aD9yLmxpc3QuZjpyLmxpc3QuaSkubWFwKGZ1bmN0aW9uKGUpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBlP2U6cGFyc2VJbnQoZSwxMCl9KTphfSxlfSgpLGV4ZWN1dGVPcD1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcIkJpYXNBZGRcIjpjYXNlXCJBZGRcIjpyZXR1cm5bYWRkKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiQWRkTlwiOnJldHVyblthZGROKGdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JzXCIsZSx0LGEpKV07Y2FzZVwiRmxvb3JNb2RcIjpjYXNlXCJNb2RcIjpyZXR1cm5bbW9kKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiTXVsXCI6cmV0dXJuW211bChnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIlJlYWxEaXZcIjpjYXNlXCJEaXZcIjpyZXR1cm5bZGl2KGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiRmxvb3JEaXZcIjpyZXR1cm5bZmxvb3JEaXYoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJTdWJcIjpyZXR1cm5bc3ViKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiTWluaW11bVwiOnJldHVyblttaW5pbXVtKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiTWF4aW11bVwiOnJldHVyblttYXhpbXVtKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiUG93XCI6cmV0dXJuW3BvdyhnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIlNxdWFyZWREaWZmZXJlbmNlXCI6cmV0dXJuW3NxdWFyZWREaWZmZXJlbmNlKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSxleGVjdXRlT3AkMT1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcIkFic1wiOnJldHVyblthYnMoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJBY29zXCI6cmV0dXJuW2Fjb3MoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJBY29zaFwiOnJldHVyblthY29zaChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkFzaW5cIjpyZXR1cm5bYXNpbihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkFzaW5oXCI6cmV0dXJuW2FzaW5oKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiQXRhblwiOnJldHVyblthdGFuKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiQXRhbjJcIjpyZXR1cm5bYXRhbjIoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcInlcIixlLHQsYSkpXTtjYXNlXCJBdGFuaFwiOnJldHVyblthdGFuaChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkNlaWxcIjpyZXR1cm5bY2VpbChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkNvc1wiOnJldHVybltjb3MoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJDb3NoXCI6cmV0dXJuW2Nvc2goZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJFbHVcIjpyZXR1cm5bZWx1KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiRXJmXCI6cmV0dXJuW2VyZihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkV4cFwiOnJldHVybltleHAoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJFeHBtMVwiOnJldHVybltleHBtMShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkZsb29yXCI6cmV0dXJuW2Zsb29yKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiTG9nXCI6cmV0dXJuW2xvZyhnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkxvZzFwXCI6cmV0dXJuW2xvZzFwKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiTmVnXCI6cmV0dXJuW25lZyhnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlJlY2lwcm9jYWxcIjpyZXR1cm5bcmVjaXByb2NhbChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlJlbHVcIjpyZXR1cm5bcmVsdShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlJvdW5kXCI6cmV0dXJuW3JvdW5kKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiU2VsdVwiOnJldHVybltzZWx1KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiU2lnbW9pZFwiOnJldHVybltzaWdtb2lkKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiU2luXCI6cmV0dXJuW3NpbihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlNpZ25cIjpyZXR1cm5bc2lnbihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlNpbmhcIjpyZXR1cm5bc2luaChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlNvZnRwbHVzXCI6cmV0dXJuW3NvZnRwbHVzKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiU3FydFwiOnJldHVybltzcXJ0KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiU3F1YXJlXCI6cmV0dXJuW3NxdWFyZShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlRhbmhcIjpyZXR1cm5bdGFuaChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlRhblwiOnJldHVyblt0YW4oZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJSZWx1NlwiOmNhc2VcIkNsaXBCeVZhbHVlXCI6cmV0dXJuW2NsaXBCeVZhbHVlKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJjbGlwVmFsdWVNaW5cIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImNsaXBWYWx1ZU1heFwiLGUsdCxhKSldO2Nhc2VcIlJzcXJ0XCI6cmV0dXJuW3JzcXJ0KGdldFRlbnNvcihlLmlucHV0TmFtZXNbMF0sdCxhKSldO2Nhc2VcIlByb2RcIjpyZXR1cm5bcHJvZChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYXhlc1wiLGUsdCxhKSldO2Nhc2VcIkxlYWt5UmVsdVwiOnJldHVybltsZWFreVJlbHUoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImFscGhhXCIsZSx0LGEpKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSxUZW5zb3JBcnJheT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxhLHIsbixzLG8scCl7dGhpcy5uYW1lPXQsdGhpcy5kdHlwZT1hLHRoaXMubWF4U2l6ZT1yLHRoaXMuZWxlbWVudFNoYXBlPW4sdGhpcy5pZGVudGljYWxFbGVtZW50U2hhcGVzPXMsdGhpcy5keW5hbWljU2l6ZT1vLHRoaXMuY2xlYXJBZnRlclJlYWQ9cCx0aGlzLnRlbnNvcnM9W10sdGhpcy5jbG9zZWRfPSExLHRoaXMuaWQ9ZS5uZXh0SWQrK31yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiY2xvc2VkXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNsb3NlZF99LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksZS5wcm90b3R5cGUuY2xlYXJBbmRDbG9zZT1mdW5jdGlvbigpe3RoaXMudGVuc29ycy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnRlbnNvci5kaXNwb3NlKCl9KSx0aGlzLnRlbnNvcnM9W10sdGhpcy5jbG9zZWRfPSEwfSxlLnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGVuc29ycy5sZW5ndGh9LGUucHJvdG90eXBlLnJlYWQ9ZnVuY3Rpb24oZSl7aWYodGhpcy5jbG9zZWRfKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IFwiK3RoaXMubmFtZStcIiBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cIik7aWYoZTwwfHxlPj10aGlzLnRlbnNvcnMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIHJlYWQgZnJvbSBpbmRleCBcIitlK1wiLCBidXQgYXJyYXkgc2l6ZSBpczogXCIrdGhpcy50ZW5zb3JzLmxlbmd0aCk7dmFyIHQ9dGhpcy50ZW5zb3JzW2VdO2lmKHQuY2xlYXJlZCl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBcIit0aGlzLm5hbWUrXCI6IENvdWxkIG5vdCByZWFkIGluZGV4IFwiK2UrXCIgdHdpY2UgYmVjYXVzZSBpdCB3YXMgY2xlYXJlZCBhZnRlciBhIHByZXZpb3VzIHJlYWQgKHBlcmhhcHMgdHJ5IHNldHRpbmcgY2xlYXJfYWZ0ZXJfcmVhZCA9IGZhbHNlPykuXCIpO3JldHVybiB0aGlzLmNsZWFyQWZ0ZXJSZWFkJiYodC5jbGVhcmVkPSEwKSx0LnJlYWQ9ITAsdC50ZW5zb3J9LGUucHJvdG90eXBlLnJlYWRNYW55PWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIGUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiB0LnJlYWQoZSl9KX0sZS5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24oZSx0KXtpZih0aGlzLmNsb3NlZF8pdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgXCIrdGhpcy5uYW1lK1wiIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtpZihlPDB8fCF0aGlzLmR5bmFtaWNTaXplJiZlPj10aGlzLm1heFNpemUpdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gd3JpdGUgdG8gaW5kZXggXCIrZStcIiwgYnV0IGFycmF5IGlzIG5vdCByZXNpemVhYmxlIGFuZCBzaXplIGlzOiBcIit0aGlzLm1heFNpemUpO3ZhciBhPXRoaXMudGVuc29yc1tlXXx8e307aWYodC5kdHlwZSE9PXRoaXMuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgXCIrdGhpcy5uYW1lK1wiOiBDb3VsZCBub3Qgd3JpdGUgdG8gVGVuc29yQXJyYXkgaW5kZXggXCIrZStcIixcXG4gICAgICAgICAgYmVjYXVzZSB0aGUgdmFsdWUgZHR5cGUgaXMgXCIrdC5kdHlwZStcIiwgYnV0IFRlbnNvckFycmF5IGR0eXBlIGlzIFwiK3RoaXMuZHR5cGUrXCIuXCIpO2lmKDAhPT10aGlzLnNpemUoKXx8bnVsbCE9dGhpcy5lbGVtZW50U2hhcGUmJjAhPT10aGlzLmVsZW1lbnRTaGFwZS5sZW5ndGh8fCh0aGlzLmVsZW1lbnRTaGFwZT10LnNoYXBlKSx0aGlzLmFzc2VydFNoYXBlc01hdGNoQWxsb3dVbmRlZmluZWRTaXplKHRoaXMuZWxlbWVudFNoYXBlLHQuc2hhcGUsXCJUZW5zb3JBcnJheSBcIit0aGlzLm5hbWUrXCI6IENvdWxkIG5vdCB3cml0ZSB0byBUZW5zb3JBcnJheSBpbmRleCBcIitlK1wiLlwiKSxhJiZhLnJlYWQpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgXCIrdGhpcy5uYW1lK1wiOiBDb3VsZCBub3Qgd3JpdGUgdG8gVGVuc29yQXJyYXkgaW5kZXggXCIrZStcIiwgYmVjYXVzZSBpdCBoYXMgYWxyZWFkeSBiZWVuIHJlYWQuXCIpO2lmKGEmJmEud3JpdHRlbil0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBcIit0aGlzLm5hbWUrXCI6IENvdWxkIG5vdCB3cml0ZSB0byBUZW5zb3JBcnJheSBpbmRleCBcIitlK1wiLCBiZWNhdXNlIGl0IGhhcyBhbHJlYWR5IGJlZW4gd3JpdHRlbi5cIik7YS50ZW5zb3I9dCxhLndyaXR0ZW49ITAsdGhpcy50ZW5zb3JzW2VdPWF9LGUucHJvdG90eXBlLndyaXRlTWFueT1mdW5jdGlvbihlLHQpe3ZhciBhPXRoaXM7aWYoZS5sZW5ndGghPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBcIit0aGlzLm5hbWUrXCI6IGNvdWxkIG5vdCB3cml0ZSBtdWx0aXBsZSB0ZW5zb3JzLGJlY2F1c2UgdGhlIGluZGV4IHNpemU6IFwiK2UubGVuZ3RoK1wiIGlzIG5vdCB0aGUgc2FtZSBhcyB0ZW5zb3JzIHNpemU6IFwiK3QubGVuZ3RoK1wiLlwiKTtlLmZvckVhY2goZnVuY3Rpb24oZSxyKXtyZXR1cm4gYS53cml0ZShlLHRbcl0pfSl9LGUucHJvdG90eXBlLmdhdGhlcj1mdW5jdGlvbihlLHQpe2lmKHQmJnQhPT10aGlzLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IGR0eXBlIGlzIFwiK3RoaXMuZHR5cGUrXCIgYnV0IGdhdGhlciByZXF1ZXN0ZWQgZHR5cGUgXCIrdCk7aWYoIWUpe2U9W107Zm9yKHZhciBhPTA7YTx0aGlzLnNpemUoKTthKyspZS5wdXNoKGEpfWlmKDA9PT1lLmxlbmd0aClyZXR1cm4gdGVuc29yKFtdLFswXS5jb25jYXQodGhpcy5lbGVtZW50U2hhcGUpKTt2YXIgcj10aGlzLnJlYWRNYW55KGUpO3JldHVybiB0aGlzLmFzc2VydFNoYXBlc01hdGNoQWxsb3dVbmRlZmluZWRTaXplKHRoaXMuZWxlbWVudFNoYXBlLHJbMF0uc2hhcGUsXCJUZW5zb3JBcnJheSBzaGFwZSBtaXNtYXRjaDogXCIpLHN0YWNrKHIsMCl9LGUucHJvdG90eXBlLmNvbmNhdD1mdW5jdGlvbihlKXtpZihlJiZlIT09dGhpcy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBkdHlwZSBpcyBcIit0aGlzLmR0eXBlK1wiIGJ1dCBjb25jYXQgcmVxdWVzdGVkIGR0eXBlIFwiK2UpO2lmKDA9PT10aGlzLnNpemUoKSlyZXR1cm4gdGVuc29yKFtdLFswXS5jb25jYXQodGhpcy5lbGVtZW50U2hhcGUpKTtmb3IodmFyIHQ9W10sYT0wO2E8dGhpcy5zaXplKCk7YSsrKXQucHVzaChhKTt2YXIgcj10aGlzLnJlYWRNYW55KHQpO3JldHVybiB0aGlzLmFzc2VydFNoYXBlc01hdGNoQWxsb3dVbmRlZmluZWRTaXplKHRoaXMuZWxlbWVudFNoYXBlLHJbMF0uc2hhcGUsXCJUZW5zb3JBcnJheSBzaGFwZSBtaXNtYXRjaDogdGVuc29yIGFycmF5IHNoYXBlIChcIit0aGlzLmVsZW1lbnRTaGFwZStcIikgdnMgZmlyc3QgdGVuc29yIHNoYXBlIChcIityWzBdLnNoYXBlK1wiKVwiKSxjb25jYXQociwwKX0sZS5wcm90b3R5cGUuc2NhdHRlcj1mdW5jdGlvbihlLHQpe2lmKHQuZHR5cGUhPT10aGlzLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IGR0eXBlIGlzIFwiK3RoaXMuZHR5cGUrXCIgYnV0IHRlbnNvciBoYXMgZHR5cGUgXCIrdC5kdHlwZSk7aWYoZS5sZW5ndGghPT10LnNoYXBlWzBdKXRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGxlbihpbmRpY2VzKSA9PSB0ZW5zb3Iuc2hhcGVbMF0sIGJ1dCBzYXc6IFwiK2UubGVuZ3RoK1wiIHZzLiBcIit0LnNoYXBlWzBdKTt2YXIgYT1NYXRoLm1heC5hcHBseShNYXRoLGUpO2lmKCF0aGlzLmR5bmFtaWNTaXplJiZhPj10aGlzLm1heFNpemUpdGhyb3cgbmV3IEVycm9yKFwiTWF4IGluZGV4IG11c3QgYmUgPCBhcnJheSBzaXplIChcIithK1wiICB2cy4gXCIrdGhpcy5tYXhTaXplK1wiKVwiKTt0aGlzLndyaXRlTWFueShlLHVuc3RhY2sodCwwKSl9LGUucHJvdG90eXBlLnNwbGl0PWZ1bmN0aW9uKGUsdCl7dmFyIGE9dGhpcztpZih0LmR0eXBlIT09dGhpcy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBkdHlwZSBpcyBcIit0aGlzLmR0eXBlK1wiIGJ1dCB0ZW5zb3IgaGFzIGR0eXBlIFwiK3QuZHR5cGUpO3ZhciByPTAsbj1lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gcis9ZX0pO2lmKHIhPT10LnNoYXBlWzBdKXRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHN1bSBvZiBsZW5ndGhzIHRvIGJlIGVxdWFsIHRvXFxuICAgICAgICAgIHRlbnNvci5zaGFwZVswXSwgYnV0IHN1bSBvZiBsZW5ndGhzIGlzXFxuICAgICAgICBcIityK1wiLCBhbmQgdGVuc29yJ3Mgc2hhcGUgaXM6IFwiK3Quc2hhcGUpO2lmKCF0aGlzLmR5bmFtaWNTaXplJiZlLmxlbmd0aCE9PXRoaXMubWF4U2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSdzIHNpemUgaXMgbm90IGVxdWFsIHRvIHRoZSBzaXplIG9mIGxlbmd0aHMgKFwiK3RoaXMubWF4U2l6ZStcIiB2cy4gXCIrZS5sZW5ndGgrXCIpLCBhbmQgdGhlIFRlbnNvckFycmF5IGlzIG5vdCBtYXJrZWQgYXMgZHluYW1pY2FsbHkgcmVzaXplYWJsZVwiKTt2YXIgcz0wPT09cj8wOnQuc2l6ZS9yLG89W107dGlkeShmdW5jdGlvbigpe3Q9dC5yZXNoYXBlKFsxLHIsc10pO2Zvcih2YXIgcD0wO3A8ZS5sZW5ndGg7KytwKXt2YXIgaT1bMCwwPT09cD8wOm5bcC0xXSwwXSx1PVsxLGVbcF0sc107b1twXT1zbGljZSh0LGksdSkucmVzaGFwZShhLmVsZW1lbnRTaGFwZSl9cmV0dXJuIG99KTtmb3IodmFyIHA9W10saT0wO2k8ZS5sZW5ndGg7aSsrKXBbaV09aTt0aGlzLndyaXRlTWFueShwLG8pfSxlLnByb3RvdHlwZS5hc3NlcnRTaGFwZXNNYXRjaEFsbG93VW5kZWZpbmVkU2l6ZT1mdW5jdGlvbihlLHQsYSl7dm9pZCAwPT09YSYmKGE9XCJcIiksdXRpbC5hc3NlcnQodGhpcy5zaGFwZXNFcXVhbEFsbG93VW5kZWZpbmVkU2l6ZShlLHQpLGZ1bmN0aW9uKCl7cmV0dXJuIGErXCIgU2hhcGVzIFwiK2UrXCIgYW5kIFwiK3QrXCIgbXVzdCBtYXRjaFwifSl9LGUucHJvdG90eXBlLnNoYXBlc0VxdWFsQWxsb3dVbmRlZmluZWRTaXplPWZ1bmN0aW9uKGUsdCl7aWYoZS5sZW5ndGghPT10Lmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIGE9MDthPGUubGVuZ3RoO2ErKylpZigtMSE9PWVbYV0mJi0xIT09dFthXSYmZVthXSE9PXRbYV0pcmV0dXJuITE7cmV0dXJuITB9LGUubmV4dElkPTAsZX0oKTtmdW5jdGlvbiBleGVjdXRlT3AkMihlLHQsYSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgcixuLHMsbyxwLGksdSxtLGMsbCxkLHksZixoLGcsTix4LGIsVixQLFQsTyx2LFMsXyx3LEEsRCxFLEksTSxDLGssaix6O3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKEYpe3N3aXRjaChGLmxhYmVsKXtjYXNlIDA6c3dpdGNoKGUub3Ape2Nhc2VcIkxvb3BDb25kXCI6cmV0dXJuWzMsMV07Y2FzZVwiU3dpdGNoXCI6cmV0dXJuWzMsMl07Y2FzZVwiTWVyZ2VcIjpyZXR1cm5bMyw0XTtjYXNlXCJFbnRlclwiOnJldHVyblszLDVdO2Nhc2VcIkV4aXRcIjpyZXR1cm5bMyw2XTtjYXNlXCJOZXh0SXRlcmF0aW9uXCI6cmV0dXJuWzMsN107Y2FzZVwiVGVuc29yQXJyYXlWM1wiOnJldHVyblszLDhdO2Nhc2VcIlRlbnNvckFycmF5V3JpdGVWM1wiOnJldHVyblszLDldO2Nhc2VcIlRlbnNvckFycmF5UmVhZFYzXCI6cmV0dXJuWzMsMTBdO2Nhc2VcIlRlbnNvckFycmF5R2F0aGVyVjNcIjpyZXR1cm5bMywxMV07Y2FzZVwiVGVuc29yQXJyYXlTY2F0dGVyVjNcIjpyZXR1cm5bMywxMl07Y2FzZVwiVGVuc29yQXJyYXlDb25jYXRWM1wiOnJldHVyblszLDEzXTtjYXNlXCJUZW5zb3JBcnJheVNwbGl0VjNcIjpyZXR1cm5bMywxNF07Y2FzZVwiVGVuc29yQXJyYXlTaXplVjNcIjpyZXR1cm5bMywxNV07Y2FzZVwiVGVuc29yQXJyYXlDbG9zZVYzXCI6cmV0dXJuWzMsMTZdfXJldHVyblszLDE3XTtjYXNlIDE6cmV0dXJuWzIsW2dldFBhcmFtVmFsdWUoXCJwcmVkXCIsZSx0LGEpLmNsb25lKCldXTtjYXNlIDI6cmV0dXJuIHI9Z2V0UGFyYW1WYWx1ZShcInByZWRcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwiZGF0YVwiLGUsdCxhKSxbNCxyLmRhdGEoKV07Y2FzZSAzOnJldHVyblsyLEYuc2VudCgpWzBdP1t2b2lkIDAsbi5jbG9uZSgpXTpbbi5jbG9uZSgpLHZvaWQgMF1dO2Nhc2UgNDpyZXR1cm5bMiwocz1lLmlucHV0TmFtZXMuZmluZChmdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwIT09Z2V0VGVuc29yKGUsdCxhKX0pKT9bZ2V0VGVuc29yKHMsdCxhKS5jbG9uZSgpXTp2b2lkIDBdO2Nhc2UgNTpyZXR1cm4gbz1nZXRQYXJhbVZhbHVlKFwiZnJhbWVOYW1lXCIsZSx0LGEpLHA9Z2V0UGFyYW1WYWx1ZShcInRlbnNvclwiLGUsdCxhKSxhLmVudGVyRnJhbWUobyksWzIsW3AuY2xvbmUoKV1dO2Nhc2UgNjpyZXR1cm4gaT1nZXRQYXJhbVZhbHVlKFwidGVuc29yXCIsZSx0LGEpLGEuZXhpdEZyYW1lKCksWzIsW2kuY2xvbmUoKV1dO2Nhc2UgNzpyZXR1cm4gdT1nZXRQYXJhbVZhbHVlKFwidGVuc29yXCIsZSx0LGEpLGEubmV4dEl0ZXJhdGlvbigpLFsyLFt1LmNsb25lKCldXTtjYXNlIDg6cmV0dXJuIG09Z2V0UGFyYW1WYWx1ZShcInNpemVcIixlLHQsYSksYz1nZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixlLHQsYSksbD1nZXRQYXJhbVZhbHVlKFwiZWxlbWVudFNoYXBlXCIsZSx0LGEpLGQ9Z2V0UGFyYW1WYWx1ZShcImR5bmFtaWNTaXplXCIsZSx0LGEpLHk9Z2V0UGFyYW1WYWx1ZShcImNsZWFyQWZ0ZXJSZWFkXCIsZSx0LGEpLGY9Z2V0UGFyYW1WYWx1ZShcImlkZW50aWNhbEVsZW1lbnRTaGFwZXNcIixlLHQsYSksaD1nZXRQYXJhbVZhbHVlKFwibmFtZVwiLGUsdCxhKSxnPW5ldyBUZW5zb3JBcnJheShoLGMsbSxsLGYsZCx5KSxhLmFkZFRlbnNvckFycmF5KGcpLFsyLFtzY2FsYXIoZy5pZCksc2NhbGFyKDEpXV07Y2FzZSA5OnJldHVybiBOPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JBcnJheUlkXCIsZSx0LGEpLHg9Z2V0UGFyYW1WYWx1ZShcImluZGV4XCIsZSx0LGEpLGI9Z2V0UGFyYW1WYWx1ZShcInRlbnNvclwiLGUsdCxhKSxhLmdldFRlbnNvckFycmF5KE4pLndyaXRlKHgsYiksWzIsW3NjYWxhcigxKV1dO2Nhc2UgMTA6cmV0dXJuIFY9Z2V0UGFyYW1WYWx1ZShcInRlbnNvckFycmF5SWRcIixlLHQsYSksUD1nZXRQYXJhbVZhbHVlKFwiaW5kZXhcIixlLHQsYSksWzIsW2EuZ2V0VGVuc29yQXJyYXkoVikucmVhZChQKV1dO2Nhc2UgMTE6cmV0dXJuIFQ9Z2V0UGFyYW1WYWx1ZShcInRlbnNvckFycmF5SWRcIixlLHQsYSksTz1nZXRQYXJhbVZhbHVlKFwiaW5kaWNlc1wiLGUsdCxhKSx2PWdldFBhcmFtVmFsdWUoXCJkdHlwZVwiLGUsdCxhKSxbMixbYS5nZXRUZW5zb3JBcnJheShUKS5nYXRoZXIoTyx2KV1dO2Nhc2UgMTI6cmV0dXJuIFM9Z2V0UGFyYW1WYWx1ZShcInRlbnNvckFycmF5SWRcIixlLHQsYSksXz1nZXRQYXJhbVZhbHVlKFwiaW5kaWNlc1wiLGUsdCxhKSx3PWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JcIixlLHQsYSksYS5nZXRUZW5zb3JBcnJheShTKS5zY2F0dGVyKF8sdyksWzIsW3NjYWxhcigxKV1dO2Nhc2UgMTM6cmV0dXJuIEE9Z2V0UGFyYW1WYWx1ZShcInRlbnNvckFycmF5SWRcIixlLHQsYSksRD1hLmdldFRlbnNvckFycmF5KEEpLEU9Z2V0UGFyYW1WYWx1ZShcImR0eXBlXCIsZSx0LGEpLFsyLFtELmNvbmNhdChFKV1dO2Nhc2UgMTQ6cmV0dXJuIEk9Z2V0UGFyYW1WYWx1ZShcInRlbnNvckFycmF5SWRcIixlLHQsYSksTT1nZXRQYXJhbVZhbHVlKFwidGVuc29yXCIsZSx0LGEpLEM9Z2V0UGFyYW1WYWx1ZShcImxlbmd0aHNcIixlLHQsYSksYS5nZXRUZW5zb3JBcnJheShJKS5zcGxpdChDLE0pLFsyLFtzY2FsYXIoMSldXTtjYXNlIDE1OnJldHVybiBrPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JBcnJheUlkXCIsZSx0LGEpLGo9YS5nZXRUZW5zb3JBcnJheShrKSxbMixbc2NhbGFyKGouc2l6ZSgpLFwiaW50MzJcIildXTtjYXNlIDE2OnJldHVybiB6PWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JBcnJheUlkXCIsZSx0LGEpLGEuZ2V0VGVuc29yQXJyYXkoeikuY2xlYXJBbmRDbG9zZSgpLFsyLFtdXTtjYXNlIDE3OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19KX0pfXZhciBleGVjdXRlT3AkMz1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcIkNvbnYxRFwiOnZhciByPWdldFBhcmFtVmFsdWUoXCJzdHJpZGVcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwicGFkXCIsZSx0LGEpLHM9Z2V0UGFyYW1WYWx1ZShcImRhdGFGb3JtYXRcIixlLHQsYSkudG9VcHBlckNhc2UoKSxvPWdldFBhcmFtVmFsdWUoXCJkaWxhdGlvblwiLGUsdCxhKTtyZXR1cm5bY29udjFkKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJmaWx0ZXJcIixlLHQsYSkscixuLHMsbyldO2Nhc2VcIkNvbnYyRFwiOnI9Z2V0UGFyYW1WYWx1ZShcInN0cmlkZXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwicGFkXCIsZSx0LGEpLHM9Z2V0UGFyYW1WYWx1ZShcImRhdGFGb3JtYXRcIixlLHQsYSkudG9VcHBlckNhc2UoKTt2YXIgcD1nZXRQYXJhbVZhbHVlKFwiZGlsYXRpb25zXCIsZSx0LGEpO3JldHVybltjb252MmQoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImZpbHRlclwiLGUsdCxhKSxbclsxXSxyWzJdXSxuLHMsW3BbMF0scFsxXV0pXTtjYXNlXCJDb252MkRCYWNrcHJvcElucHV0XCI6Y2FzZVwiQ29udjJkVHJhbnNwb3NlXCI6dmFyIGk9Z2V0UGFyYW1WYWx1ZShcIm91dHB1dFNoYXBlXCIsZSx0LGEpO3I9Z2V0UGFyYW1WYWx1ZShcInN0cmlkZXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwicGFkXCIsZSx0LGEpO3JldHVybltjb252MmRUcmFuc3Bvc2UoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImZpbHRlclwiLGUsdCxhKSxpLFtyWzFdLHJbMl1dLG4pXTtjYXNlXCJEZXB0aHdpc2VDb252MmROYXRpdmVcIjpjYXNlXCJEZXB0aHdpc2VDb252MmRcIjpyPWdldFBhcmFtVmFsdWUoXCJzdHJpZGVzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcInBhZFwiLGUsdCxhKSxwPWdldFBhcmFtVmFsdWUoXCJkaWxhdGlvbnNcIixlLHQsYSkscz1nZXRQYXJhbVZhbHVlKFwiZGF0YUZvcm1hdFwiLGUsdCxhKS50b1VwcGVyQ2FzZSgpO3JldHVybltkZXB0aHdpc2VDb252MmQoZ2V0UGFyYW1WYWx1ZShcImlucHV0XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJmaWx0ZXJcIixlLHQsYSksW3JbMV0sclsyXV0sbixzLFtwWzBdLHBbMV1dKV07Y2FzZVwiQXZnUG9vbFwiOnI9Z2V0UGFyYW1WYWx1ZShcInN0cmlkZXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwicGFkXCIsZSx0LGEpO3ZhciB1PWdldFBhcmFtVmFsdWUoXCJrZXJuZWxTaXplXCIsZSx0LGEpO3JldHVyblthdmdQb29sKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLFt1WzFdLHVbMl1dLFtyWzFdLHJbMl1dLG4pXTtjYXNlXCJNYXhQb29sXCI6cj1nZXRQYXJhbVZhbHVlKFwic3RyaWRlc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJwYWRcIixlLHQsYSksdT1nZXRQYXJhbVZhbHVlKFwia2VybmVsU2l6ZVwiLGUsdCxhKTtyZXR1cm5bbWF4UG9vbChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxbdVsxXSx1WzJdXSxbclsxXSxyWzJdXSxuKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSxleGVjdXRlT3AkND1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcIkZpbGxcIjp2YXIgcj1nZXRQYXJhbVZhbHVlKFwic2hhcGVcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixlLHQsYSkscz1nZXRQYXJhbVZhbHVlKFwidmFsdWVcIixlLHQsYSk7cmV0dXJuW2ZpbGwocixzLG4pXTtjYXNlXCJMaW5TcGFjZVwiOnZhciBvPWdldFBhcmFtVmFsdWUoXCJzdGFydFwiLGUsdCxhKSxwPWdldFBhcmFtVmFsdWUoXCJzdG9wXCIsZSx0LGEpLGk9Z2V0UGFyYW1WYWx1ZShcIm51bVwiLGUsdCxhKTtyZXR1cm5bbGluc3BhY2UobyxwLGkpXTtjYXNlXCJPbmVIb3RcIjp2YXIgdT1nZXRQYXJhbVZhbHVlKFwiaW5kaWNlc1wiLGUsdCxhKSxtPWdldFBhcmFtVmFsdWUoXCJkZXB0aFwiLGUsdCxhKSxjPWdldFBhcmFtVmFsdWUoXCJvblZhbHVlXCIsZSx0LGEpLGw9Z2V0UGFyYW1WYWx1ZShcIm9mZlZhbHVlXCIsZSx0LGEpO3JldHVybltvbmVIb3QodSxtLGMsbCldO2Nhc2VcIk9uZXNcIjpyZXR1cm5bb25lcyhnZXRQYXJhbVZhbHVlKFwic2hhcGVcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImR0eXBlXCIsZSx0LGEpKV07Y2FzZVwiT25lc0xpa2VcIjpyZXR1cm5bb25lc0xpa2UoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJSYW5kb21Vbmlmb3JtXCI6cmV0dXJuW3JhbmRvbVVuaWZvcm0oZ2V0UGFyYW1WYWx1ZShcInNoYXBlXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJtaW52YWxcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcIm1heHZhbFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixlLHQsYSkpXTtjYXNlXCJSYW5nZVwiOm89Z2V0UGFyYW1WYWx1ZShcInN0YXJ0XCIsZSx0LGEpO3ZhciBkPWdldFBhcmFtVmFsdWUoXCJzdG9wXCIsZSx0LGEpLHk9Z2V0UGFyYW1WYWx1ZShcInN0ZXBcIixlLHQsYSk7cmV0dXJuW3JhbmdlKG8sZCx5LGdldFBhcmFtVmFsdWUoXCJkdHlwZVwiLGUsdCxhKSldO2Nhc2VcIlRydW5jYXRlZE5vcm1hbFwiOnI9Z2V0UGFyYW1WYWx1ZShcInNoYXBlXCIsZSx0LGEpO3ZhciBmPWdldFBhcmFtVmFsdWUoXCJtZWFuXCIsZSx0LGEpLGg9Z2V0UGFyYW1WYWx1ZShcInN0ZERldlwiLGUsdCxhKSxnPWdldFBhcmFtVmFsdWUoXCJzZWVkXCIsZSx0LGEpO3JldHVyblt0cnVuY2F0ZWROb3JtYWwocixmLGgsZ2V0UGFyYW1WYWx1ZShcImR0eXBlXCIsZSx0LGEpLGcpXTtjYXNlXCJaZXJvc1wiOnJldHVyblt6ZXJvcyhnZXRQYXJhbVZhbHVlKFwic2hhcGVcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImR0eXBlXCIsZSx0LGEpKV07Y2FzZVwiWmVyb3NMaWtlXCI6cmV0dXJuW3plcm9zTGlrZShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX07ZnVuY3Rpb24gZXhlY3V0ZU9wJDUoZSx0LGEpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHIsbixzLG8scDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihpKXtzd2l0Y2goaS5sYWJlbCl7Y2FzZSAwOnN3aXRjaChlLm9wKXtjYXNlXCJOb25NYXhTdXBwcmVzc2lvblYzXCI6Y2FzZVwiTm9uTWF4U3VwcHJlc3Npb25WMlwiOnJldHVyblszLDFdO2Nhc2VcIldoZXJlXCI6cmV0dXJuWzMsM107Y2FzZVwiTGlzdERpZmZcIjpyZXR1cm5bMyw1XX1yZXR1cm5bMyw3XTtjYXNlIDE6cmV0dXJuIHI9Z2V0UGFyYW1WYWx1ZShcImJveGVzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcInNjb3Jlc1wiLGUsdCxhKSxzPWdldFBhcmFtVmFsdWUoXCJtYXhPdXRwdXRTaXplXCIsZSx0LGEpLG89Z2V0UGFyYW1WYWx1ZShcImlvdVRocmVzaG9sZFwiLGUsdCxhKSxwPWdldFBhcmFtVmFsdWUoXCJzY29yZVRocmVzaG9sZFwiLGUsdCxhKSxbNCxpbWFnZS5ub25NYXhTdXBwcmVzc2lvbkFzeW5jKHIsbixzLG8scCldO2Nhc2UgMjpyZXR1cm5bMixbaS5zZW50KCldXTtjYXNlIDM6cmV0dXJuWzQsd2hlcmVBc3luYyhnZXRQYXJhbVZhbHVlKFwiY29uZGl0aW9uXCIsZSx0LGEpKV07Y2FzZSA0OnJldHVyblsyLFtpLnNlbnQoKV1dO2Nhc2UgNTpyZXR1cm5bNCxzZXRkaWZmMWRBc3luYyhnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwieVwiLGUsdCxhKSldO2Nhc2UgNjpyZXR1cm5bMixpLnNlbnQoKV07Y2FzZSA3OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19KX0pfXZhciBleGVjdXRlT3AkNj1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcIlRvcEtWMlwiOnZhciByPWdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcImtcIixlLHQsYSkscz1nZXRQYXJhbVZhbHVlKFwic29ydGVkXCIsZSx0LGEpLG89dG9wayhyLG4scyk7cmV0dXJuW28udmFsdWVzLG8uaW5kaWNlc107ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSxleGVjdXRlT3AkNz1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcIkNvbnN0XCI6cmV0dXJuIHRbZS5uYW1lXTtjYXNlXCJQbGFjZWhvbGRlcldpdGhEZWZhdWx0XCI6dmFyIHI9Z2V0UGFyYW1WYWx1ZShcImRlZmF1bHRcIixlLHQsYSk7cmV0dXJuW2dldFRlbnNvcihlLm5hbWUsdCxhKXx8cl07Y2FzZVwiUGxhY2Vob2xkZXJcIjpyZXR1cm5bZ2V0VGVuc29yKGUubmFtZSx0LGEpXTtjYXNlXCJJZGVudGl0eVwiOmNhc2VcIlN0b3BHcmFkaWVudFwiOmNhc2VcIkZha2VRdWFudFdpdGhNaW5NYXhWYXJzXCI6cmV0dXJuW2dldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLmNsb25lKCldO2Nhc2VcIklkZW50aXR5TlwiOnJldHVybiBnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuY2xvbmUoKX0pO2Nhc2VcIlNuYXBzaG90XCI6cmV0dXJuW2dldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLmNsb25lKCldO2Nhc2VcIlNoYXBlXCI6cmV0dXJuW3RlbnNvcjFkKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLnNoYXBlLFwiaW50MzJcIildO2Nhc2VcIlNoYXBlTlwiOnJldHVybiBnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHRlbnNvcjFkKGUuc2hhcGUpfSk7Y2FzZVwiU2l6ZVwiOnJldHVybltzY2FsYXIoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkuc2l6ZSxcImludDMyXCIpXTtjYXNlXCJSYW5rXCI6cmV0dXJuW3NjYWxhcihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKS5yYW5rLFwiaW50MzJcIildO2Nhc2VcIk5vT3BcIjpyZXR1cm5bXTtjYXNlXCJQcmludFwiOnZhciBuPWdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHM9Z2V0UGFyYW1WYWx1ZShcImRhdGFcIixlLHQsYSksbz1nZXRQYXJhbVZhbHVlKFwibWVzc2FnZVwiLGUsdCxhKSxwPWdldFBhcmFtVmFsdWUoXCJzdW1tYXJpemVcIixlLHQsYSk7Y29uc29sZS53YXJuKFwiVGhlIGdyYXBoIGhhcyBhIHRmLnByaW50KCkgb3BlcmF0aW9uLHVzdWFsbHkgdXNlZCBmb3IgZGVidWdnaW5nLCB3aGljaCBzbG93cyBkb3duIHBlcmZvcm1hbmNlLlwiKSxjb25zb2xlLmxvZyhvKTtmb3IodmFyIGk9MDtpPHMubGVuZ3RoO2krKyljb25zb2xlLmxvZyhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzW2ldLmRhdGFTeW5jKCkpLnNsaWNlKDAscCkpO3JldHVybltuXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19LGV4ZWN1dGVPcCQ4PWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwiUmVzaXplQmlsaW5lYXJcIjp2YXIgcj1nZXRQYXJhbVZhbHVlKFwiaW1hZ2VzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcInNpemVcIixlLHQsYSkscz1nZXRQYXJhbVZhbHVlKFwiYWxpZ25Db3JuZXJzXCIsZSx0LGEpO3JldHVybltpbWFnZS5yZXNpemVCaWxpbmVhcihyLFtuWzBdLG5bMV1dLHMpXTtjYXNlXCJSZXNpemVOZWFyZXN0TmVpZ2hib3JcIjpyPWdldFBhcmFtVmFsdWUoXCJpbWFnZXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwic2l6ZVwiLGUsdCxhKSxzPWdldFBhcmFtVmFsdWUoXCJhbGlnbkNvcm5lcnNcIixlLHQsYSk7cmV0dXJuW2ltYWdlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvcihyLFtuWzBdLG5bMV1dLHMpXTtjYXNlXCJDcm9wQW5kUmVzaXplXCI6dmFyIG89Z2V0UGFyYW1WYWx1ZShcImltYWdlXCIsZSx0LGEpLHA9Z2V0UGFyYW1WYWx1ZShcImJveGVzXCIsZSx0LGEpLGk9Z2V0UGFyYW1WYWx1ZShcImJveEluZFwiLGUsdCxhKSx1PWdldFBhcmFtVmFsdWUoXCJjcm9wU2l6ZVwiLGUsdCxhKSxtPWdldFBhcmFtVmFsdWUoXCJtZXRob2RcIixlLHQsYSksYz1nZXRQYXJhbVZhbHVlKFwiZXh0cmFwb2xhdGlvblZhbHVlXCIsZSx0LGEpO3JldHVybltpbWFnZS5jcm9wQW5kUmVzaXplKG8scCxpLHUsbSxjKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSxleGVjdXRlT3AkOT1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcIkVxdWFsXCI6cmV0dXJuW2VxdWFsKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiTm90RXF1YWxcIjpyZXR1cm5bbm90RXF1YWwoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJHcmVhdGVyXCI6cmV0dXJuW2dyZWF0ZXIoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJHcmVhdGVyRXF1YWxcIjpyZXR1cm5bZ3JlYXRlckVxdWFsKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiTGVzc1wiOnJldHVybltsZXNzKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiTGVzc0VxdWFsXCI6cmV0dXJuW2xlc3NFcXVhbChnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIkxvZ2ljYWxBbmRcIjpyZXR1cm5bbG9naWNhbEFuZChnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIkxvZ2ljYWxOb3RcIjpyZXR1cm5bbG9naWNhbE5vdChnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSldO2Nhc2VcIkxvZ2ljYWxPclwiOnJldHVybltsb2dpY2FsT3IoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJTZWxlY3RcIjpyZXR1cm5bd2hlcmUoZ2V0UGFyYW1WYWx1ZShcImNvbmRpdGlvblwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0sZXhlY3V0ZU9wJDEwPWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwiQmF0Y2hNYXRNdWxcIjpjYXNlXCJNYXRNdWxcIjpyZXR1cm5bbWF0TXVsKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJ0cmFuc3Bvc2VBXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJ0cmFuc3Bvc2VCXCIsZSx0LGEpKV07Y2FzZVwiVHJhbnNwb3NlXCI6cmV0dXJuW3RyYW5zcG9zZShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwicGVybVwiLGUsdCxhKSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0sZXhlY3V0ZU9wJDExPWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwiRnVzZWRCYXRjaE5vcm1cIjpjYXNlXCJGdXNlZEJhdGNoTm9ybVYyXCI6cmV0dXJuW2JhdGNoTm9ybShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwibWVhblwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwidmFyaWFuY2VcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcIm9mZnNldFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwic2NhbGVcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImVwc2lsb25cIixlLHQsYSkpXTtjYXNlXCJMUk5cIjpyZXR1cm5bbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb24oZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcInJhZGl1c1wiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYmlhc1wiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYWxwaGFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJldGFcIixlLHQsYSkpXTtjYXNlXCJTb2Z0bWF4XCI6cmV0dXJuW3NvZnRtYXgoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJMb2dTb2Z0bWF4XCI6cmV0dXJuW2xvZ1NvZnRtYXgoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJTcGFyc2VUb0RlbnNlXCI6cmV0dXJuW3NwYXJzZVRvRGVuc2UoZ2V0UGFyYW1WYWx1ZShcInNwYXJzZUluZGljZXNcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcIm91dHB1dFNoYXBlXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJzcGFyc2VWYWx1ZXNcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImRlZmF1bHRWYWx1ZVwiLGUsdCxhKSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0sZXhlY3V0ZU9wJDEyPWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwiTWF4XCI6dmFyIHI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwia2VlcERpbXNcIixlLHQsYSk7cmV0dXJuW21heChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxyLG4pXTtjYXNlXCJNZWFuXCI6cj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJrZWVwRGltc1wiLGUsdCxhKTtyZXR1cm5bbWVhbihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxyLG4pXTtjYXNlXCJNaW5cIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcImtlZXBEaW1zXCIsZSx0LGEpO3JldHVyblttaW4oZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscixuKV07Y2FzZVwiU3VtXCI6cj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJrZWVwRGltc1wiLGUsdCxhKTtyZXR1cm5bc3VtKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHIsbildO2Nhc2VcIkFsbFwiOnI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwia2VlcERpbXNcIixlLHQsYSk7cmV0dXJuW2FsbChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxyLG4pXTtjYXNlXCJBbnlcIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcImtlZXBEaW1zXCIsZSx0LGEpO3JldHVyblthbnkoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscixuKV07Y2FzZVwiQXJnTWF4XCI6cj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKTtyZXR1cm5bYXJnTWF4KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHIpXTtjYXNlXCJBcmdNaW5cIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpO3JldHVyblthcmdNaW4oZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscildO2Nhc2VcIlByb2RcIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcImtlZXBEaW1zXCIsZSx0LGEpO3JldHVybltwcm9kKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHIsbildO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0sZXhlY3V0ZU9wJDEzPWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwiQ29uY2F0VjJcIjpjYXNlXCJDb25jYXRcIjp2YXIgcj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JzXCIsZSx0LGEpO3JldHVybltjb25jYXQobixyKV07Y2FzZVwiR2F0aGVyVjJcIjpjYXNlXCJHYXRoZXJcIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpO3ZhciBzPWdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLG89Z2V0UGFyYW1WYWx1ZShcImluZGljZXNcIixlLHQsYSk7cmV0dXJuW2dhdGhlcihzLG8uYXNUeXBlKFwiaW50MzJcIikscildO2Nhc2VcIlJldmVyc2VWMlwiOmNhc2VcIlJldmVyc2VcIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpLHM9Z2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSk7cmV0dXJuW3JldmVyc2UocyxyKV07Y2FzZVwiU2xpY2VcIjp2YXIgcD1nZXRQYXJhbVZhbHVlKFwiYmVnaW5cIixlLHQsYSksaT1nZXRQYXJhbVZhbHVlKFwic2l6ZVwiLGUsdCxhKTtyZXR1cm5bc2xpY2UoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscCxpKV07Y2FzZVwiU3RyaWRlZFNsaWNlXCI6cD1nZXRQYXJhbVZhbHVlKFwiYmVnaW5cIixlLHQsYSk7dmFyIHU9Z2V0UGFyYW1WYWx1ZShcImVuZFwiLGUsdCxhKSxtPWdldFBhcmFtVmFsdWUoXCJzdHJpZGVzXCIsZSx0LGEpLGM9Z2V0UGFyYW1WYWx1ZShcImJlZ2luTWFza1wiLGUsdCxhKSxsPWdldFBhcmFtVmFsdWUoXCJlbmRNYXNrXCIsZSx0LGEpLGQ9Z2V0UGFyYW1WYWx1ZShcImVsbGlwc2lzTWFza1wiLGUsdCxhKSx5PWdldFBhcmFtVmFsdWUoXCJuZXdBeGlzTWFza1wiLGUsdCxhKSxmPWdldFBhcmFtVmFsdWUoXCJzaHJpbmtBeGlzTWFza1wiLGUsdCxhKSxoPWdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpO2lmKDE9PT1wLmxlbmd0aCYmaC5zaGFwZS5sZW5ndGg+MSlmb3IodmFyIGc9MTtnPGguc2hhcGUubGVuZ3RoO2crKylwLnB1c2goMCksdS5wdXNoKGguc2hhcGVbZ10pLG0ucHVzaChtWzBdKTtyZXR1cm5bc3RyaWRlZFNsaWNlKGgscCx1LG0sYyxsLGQseSxmKV07Y2FzZVwiUGFja1wiOnJldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwidGVuc29yc1wiLGUsdCxhKSxzPW5bMF0uc2hhcGUsbz1uWzBdLnNxdWVlemUoKS5zaGFwZSxwPW4ubWFwKGZ1bmN0aW9uKGUpe3ZhciB0PXV0aWwuYXJyYXlzRXF1YWwoZS5zaGFwZSxzKTtpZighdCYmIXV0aWwuYXJyYXlzRXF1YWwoZS5zcXVlZXplKCkuc2hhcGUsbykpdGhyb3cgbmV3IEVycm9yKFwidGhlIGlucHV0IHRlbnNvcnMgc2hhcGUgZG9lcyBub3QgbWF0Y2hcIik7cmV0dXJuIHQ/ZTplLnJlc2hhcGUocyl9KTtyZXR1cm5bc3RhY2socCxyKV19KTtjYXNlXCJVbnBhY2tcIjpyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciByPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcInRlbnNvclwiLGUsdCxhKTtyZXR1cm4gdW5zdGFjayhuLHIpfSk7Y2FzZVwiVGlsZVwiOnZhciBOPWdldFBhcmFtVmFsdWUoXCJyZXBzXCIsZSx0LGEpO3JldHVyblt0aWxlKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLE4pXTtjYXNlXCJTcGxpdFwiOmNhc2VcIlNwbGl0VlwiOnI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSk7dmFyIHg9Z2V0UGFyYW1WYWx1ZShcIm51bU9yU2l6ZVNwbGl0c1wiLGUsdCxhKTtyZXR1cm4gc3BsaXQoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkseCxyKTtjYXNlXCJTY2F0dGVyTmRcIjpvPWdldFBhcmFtVmFsdWUoXCJpbmRpY2VzXCIsZSx0LGEpO3ZhciBiPWdldFBhcmFtVmFsdWUoXCJ2YWx1ZXNcIixlLHQsYSksVj1nZXRQYXJhbVZhbHVlKFwic2hhcGVcIixlLHQsYSk7cmV0dXJuW3NjYXR0ZXJORChvLGIsVildO2Nhc2VcIkdhdGhlck5kXCI6dmFyIFA9Z2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSk7bz1nZXRQYXJhbVZhbHVlKFwiaW5kaWNlc1wiLGUsdCxhKTtyZXR1cm5bZ2F0aGVyTkQoUCxvKV07Y2FzZVwiU3BhcnNlVG9EZW5zZVwiOm89Z2V0UGFyYW1WYWx1ZShcInNwYXJzZUluZGljZXNcIixlLHQsYSksVj1nZXRQYXJhbVZhbHVlKFwib3V0cHV0U2hhcGVcIixlLHQsYSk7dmFyIFQ9Z2V0UGFyYW1WYWx1ZShcInNwYXJzZVZhbHVlc1wiLGUsdCxhKSxPPWdldFBhcmFtVmFsdWUoXCJkZWZhdWx0VmFsdWVcIixlLHQsYSk7cmV0dXJuW3NwYXJzZVRvRGVuc2UobyxULFYsVC5kdHlwZT09PU8uZHR5cGU/TzpPLmFzVHlwZShULmR0eXBlKSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0sZXhlY3V0ZU9wJDE0PWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwiRkZUXCI6cmV0dXJuW2ZmdChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIklGRlRcIjpyZXR1cm5baWZmdChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlJGRlRcIjpyZXR1cm5bcmZmdChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIklSRkZUXCI6cmV0dXJuW2lyZmZ0KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSxleGVjdXRlT3AkMTU9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJDYXN0XCI6cmV0dXJuW2Nhc3QoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImR0eXBlXCIsZSx0LGEpKV07Y2FzZVwiRXhwYW5kRGltc1wiOnZhciByPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpO3JldHVybltleHBhbmREaW1zKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHIpXTtjYXNlXCJTcXVlZXplXCI6cj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKTtyZXR1cm5bc3F1ZWV6ZShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxyKV07Y2FzZVwiUmVzaGFwZVwiOnJldHVybltyZXNoYXBlKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJzaGFwZVwiLGUsdCxhKSldO2Nhc2VcIlBhZFYyXCI6Y2FzZVwiUGFkXCI6cmV0dXJuW3BhZChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxzcGxpdCQxKGdldFBhcmFtVmFsdWUoXCJwYWRkaW5nXCIsZSx0LGEpLDIpLGdldFBhcmFtVmFsdWUoXCJjb25zdGFudFZhbHVlXCIsZSx0LGEpKV07Y2FzZVwiU3BhY2VUb0JhdGNoTkRcIjp2YXIgbj1nZXRQYXJhbVZhbHVlKFwiYmxvY2tTaGFwZVwiLGUsdCxhKSxzPXNwbGl0JDEoZ2V0UGFyYW1WYWx1ZShcInBhZGRpbmdzXCIsZSx0LGEpLDIpO3JldHVybltzcGFjZVRvQmF0Y2hORChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxuLHMpXTtjYXNlXCJCYXRjaFRvU3BhY2VORFwiOm49Z2V0UGFyYW1WYWx1ZShcImJsb2NrU2hhcGVcIixlLHQsYSk7dmFyIG89c3BsaXQkMShnZXRQYXJhbVZhbHVlKFwiY3JvcHNcIixlLHQsYSksMik7cmV0dXJuW2JhdGNoVG9TcGFjZU5EKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLG4sbyldO2Nhc2VcIkRlcHRoVG9TcGFjZVwiOnZhciBwPWdldFBhcmFtVmFsdWUoXCJibG9ja1NpemVcIixlLHQsYSksaT1nZXRQYXJhbVZhbHVlKFwiZGF0YUZvcm1hdFwiLGUsdCxhKS50b1VwcGVyQ2FzZSgpO3JldHVybltkZXB0aFRvU3BhY2UoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscCxpKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fTtmdW5jdGlvbiBleGVjdXRlT3AkMTYoZSx0LGEpe3ZhciByPWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5jYXRlZ29yeSl7Y2FzZVwiYXJpdGhtZXRpY1wiOnJldHVybiBleGVjdXRlT3AoZSx0LGEpO2Nhc2VcImJhc2ljX21hdGhcIjpyZXR1cm4gZXhlY3V0ZU9wJDEoZSx0LGEpO2Nhc2VcImNvbnRyb2xcIjpyZXR1cm4gZXhlY3V0ZU9wJDIoZSx0LGEpO2Nhc2VcImNvbnZvbHV0aW9uXCI6cmV0dXJuIGV4ZWN1dGVPcCQzKGUsdCxhKTtjYXNlXCJjcmVhdGlvblwiOnJldHVybiBleGVjdXRlT3AkNChlLHQsYSk7Y2FzZVwiZHluYW1pY1wiOnJldHVybiBleGVjdXRlT3AkNShlLHQsYSk7Y2FzZVwiZXZhbHVhdGlvblwiOnJldHVybiBleGVjdXRlT3AkNihlLHQsYSk7Y2FzZVwiaW1hZ2VcIjpyZXR1cm4gZXhlY3V0ZU9wJDgoZSx0LGEpO2Nhc2VcImdyYXBoXCI6cmV0dXJuIGV4ZWN1dGVPcCQ3KGUsdCxhKTtjYXNlXCJsb2dpY2FsXCI6cmV0dXJuIGV4ZWN1dGVPcCQ5KGUsdCxhKTtjYXNlXCJtYXRyaWNlc1wiOnJldHVybiBleGVjdXRlT3AkMTAoZSx0LGEpO2Nhc2VcIm5vcm1hbGl6YXRpb25cIjpyZXR1cm4gZXhlY3V0ZU9wJDExKGUsdCxhKTtjYXNlXCJyZWR1Y3Rpb25cIjpyZXR1cm4gZXhlY3V0ZU9wJDEyKGUsdCxhKTtjYXNlXCJzbGljZV9qb2luXCI6cmV0dXJuIGV4ZWN1dGVPcCQxMyhlLHQsYSk7Y2FzZVwic3BlY3RyYWxcIjpyZXR1cm4gZXhlY3V0ZU9wJDE0KGUsdCxhKTtjYXNlXCJ0cmFuc2Zvcm1hdGlvblwiOnJldHVybiBleGVjdXRlT3AkMTUoZSx0LGEpO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0oZSx0LGEpO3JldHVybiByIGluc3RhbmNlb2YgUHJvbWlzZT9yLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuW10uY29uY2F0KGUpfSk6W10uY29uY2F0KHIpfXZhciBFeGVjdXRpb25Db250ZXh0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3RoaXMud2VpZ2h0TWFwPWUsdGhpcy50ZW5zb3JBcnJheU1hcD10LHRoaXMucm9vdENvbnRleHQ9e2lkOjAsZnJhbWVOYW1lOlwiXCIsaXRlcmF0aW9uSWQ6MH0sdGhpcy5jb250ZXh0cz1bdGhpcy5yb290Q29udGV4dF0sdGhpcy5sYXN0SWQ9MCx0aGlzLmdlbmVyYXRlQ3VycmVudENvbnRleHRJZHMoKX1yZXR1cm4gZS5wcm90b3R5cGUubmV3RnJhbWU9ZnVuY3Rpb24oZSx0KXtyZXR1cm57aWQ6ZSxmcmFtZU5hbWU6dCxpdGVyYXRpb25JZDowfX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiY3VycmVudENvbnRleHRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29udGV4dHN9LHNldDpmdW5jdGlvbihlKXt0aGlzLmNvbnRleHRzIT09ZSYmKHRoaXMuY29udGV4dHM9ZSx0aGlzLmdlbmVyYXRlQ3VycmVudENvbnRleHRJZHMoKSl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiY3VycmVudENvbnRleHRJZFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY3VycmVudENvbnRleHRJZHNbMF19LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiY3VycmVudENvbnRleHRJZHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2N1cnJlbnRDb250ZXh0SWRzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGUucHJvdG90eXBlLmdlbmVyYXRlQ3VycmVudENvbnRleHRJZHM9ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wO3Q8dGhpcy5jb250ZXh0cy5sZW5ndGgtMTt0Kyspe3ZhciBhPXRoaXMuY29udGV4dHMuc2xpY2UoMCx0aGlzLmNvbnRleHRzLmxlbmd0aC10KTtlLnB1c2godGhpcy5jb250ZXh0SWRmb3JDb250ZXh0cyhhKSl9ZS5wdXNoKFwiXCIpLHRoaXMuX2N1cnJlbnRDb250ZXh0SWRzPWV9LGUucHJvdG90eXBlLmNvbnRleHRJZGZvckNvbnRleHRzPWZ1bmN0aW9uKGUpe3JldHVybiBlP2UubWFwKGZ1bmN0aW9uKGUpe3JldHVybiAwPT09ZS5pZCYmMD09PWUuaXRlcmF0aW9uSWQ/XCJcIjplLmZyYW1lTmFtZStcIi1cIitlLml0ZXJhdGlvbklkfSkuam9pbihcIi9cIik6XCJcIn0sZS5wcm90b3R5cGUuZW50ZXJGcmFtZT1mdW5jdGlvbihlKXt0aGlzLmNvbnRleHRzJiYodGhpcy5sYXN0SWQrKyx0aGlzLmNvbnRleHRzPXRoaXMuY29udGV4dHMuc2xpY2UoKSx0aGlzLmNvbnRleHRzLnB1c2godGhpcy5uZXdGcmFtZSh0aGlzLmxhc3RJZCxlKSksdGhpcy5fY3VycmVudENvbnRleHRJZHMudW5zaGlmdCh0aGlzLmNvbnRleHRJZGZvckNvbnRleHRzKHRoaXMuY29udGV4dHMpKSl9LGUucHJvdG90eXBlLmV4aXRGcmFtZT1mdW5jdGlvbigpe2lmKCEodGhpcy5jb250ZXh0cyYmdGhpcy5jb250ZXh0cy5sZW5ndGg+MSkpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGV4aXQgZnJhbWUsIHRoZSBjb250ZXh0IGlzIGVtcHR5XCIpO3RoaXMuY29udGV4dHM9dGhpcy5jb250ZXh0cy5zbGljZSgpLHRoaXMuY29udGV4dHMuc3BsaWNlKC0xKSx0aGlzLmN1cnJlbnRDb250ZXh0SWRzLnNoaWZ0KCl9LGUucHJvdG90eXBlLm5leHRJdGVyYXRpb249ZnVuY3Rpb24oKXtpZighKHRoaXMuY29udGV4dHMmJnRoaXMuY29udGV4dHMubGVuZ3RoPjApKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpbmNyZWFzZSBmcmFtZSBpdGVyYXRpb24sIHRoZSBjb250ZXh0IGlzIGVtcHR5XCIpO3RoaXMuY29udGV4dHM9dGhpcy5jb250ZXh0cy5zbGljZSgpLHRoaXMubGFzdElkKys7dmFyIGU9T2JqZWN0LmFzc2lnbih7fSx0aGlzLmNvbnRleHRzW3RoaXMuY29udGV4dHMubGVuZ3RoLTFdKTtlLml0ZXJhdGlvbklkKz0xLGUuaWQ9dGhpcy5sYXN0SWQsdGhpcy5jb250ZXh0cy5zcGxpY2UoLTEsMSxlKSx0aGlzLl9jdXJyZW50Q29udGV4dElkcy5zcGxpY2UoMCwxLHRoaXMuY29udGV4dElkZm9yQ29udGV4dHModGhpcy5jb250ZXh0cykpfSxlLnByb3RvdHlwZS5nZXRXZWlnaHQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMud2VpZ2h0TWFwW2VdfSxlLnByb3RvdHlwZS5hZGRUZW5zb3JBcnJheT1mdW5jdGlvbihlKXt0aGlzLnRlbnNvckFycmF5TWFwW2UuaWRdPWV9LGUucHJvdG90eXBlLmdldFRlbnNvckFycmF5PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRlbnNvckFycmF5TWFwW2VdfSxlfSgpLEdyYXBoRXhlY3V0b3I9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3RoaXMuZ3JhcGg9ZSx0aGlzLmNvbXBpbGVkTWFwPW5ldyBNYXAsdGhpcy5fd2VpZ2h0TWFwPXt9LHRoaXMuU0VQRVJBVE9SPVwiLFwiLHRoaXMucGxhY2Vob2xkZXJzPWUucGxhY2Vob2xkZXJzLHRoaXMuX291dHB1dHM9ZS5vdXRwdXRzLHRoaXMuY29tcGlsZSgpfXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJ3ZWlnaHRNYXBcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3dlaWdodE1hcH0sc2V0OmZ1bmN0aW9uKGUpe3ZhciB0PU9iamVjdC5rZXlzKGUpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZVt0XS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaWR9KX0pO3RoaXMud2VpZ2h0SWRzPVtdLmNvbmNhdC5hcHBseShbXSx0KSx0aGlzLl93ZWlnaHRNYXA9ZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJpbnB1dHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGxhY2Vob2xkZXJzLm1hcChmdW5jdGlvbihlKXtyZXR1cm57bmFtZTplLm5hbWUsc2hhcGU6ZS5hdHRyUGFyYW1zLnNoYXBlP2UuYXR0clBhcmFtcy5zaGFwZS52YWx1ZTp2b2lkIDAsZHR5cGU6ZS5hdHRyUGFyYW1zLmR0eXBlP2UuYXR0clBhcmFtcy5kdHlwZS52YWx1ZTp2b2lkIDB9fSl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwib3V0cHV0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fb3V0cHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJue25hbWU6ZS5uYW1lLHNoYXBlOmUuYXR0clBhcmFtcy5zaGFwZT9lLmF0dHJQYXJhbXMuc2hhcGUudmFsdWU6dm9pZCAwLGR0eXBlOmUuYXR0clBhcmFtcy5kdHlwZT9lLmF0dHJQYXJhbXMuZHR5cGUudmFsdWU6dm9pZCAwfX0pfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImlucHV0Tm9kZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGxhY2Vob2xkZXJzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lfSl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwib3V0cHV0Tm9kZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3V0cHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmFtZX0pfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImlzQ29udHJvbEZsb3dNb2RlbFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmFwaC53aXRoQ29udHJvbEZsb3d9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiaXNEeW5hbWljU2hhcGVNb2RlbFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmFwaC53aXRoRHluYW1pY1NoYXBlfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGUucHJvdG90eXBlLmNvbXBpbGU9ZnVuY3Rpb24oZSl7aWYoIXRoaXMuZ3JhcGgud2l0aENvbnRyb2xGbG93JiYhdGhpcy5ncmFwaC53aXRoRHluYW1pY1NoYXBlKXt2YXIgdD1bXSxhPWV8fHRoaXMuZ3JhcGgucGxhY2Vob2xkZXJzLHI9YS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmFtZX0pLnNvcnQoKS5qb2luKHRoaXMuU0VQRVJBVE9SKTtpZighdGhpcy5jb21waWxlZE1hcC5nZXQocikpe2Zvcih2YXIgbj1hLmNvbmNhdCh0aGlzLmdyYXBoLndlaWdodHMpLHM9e307bi5sZW5ndGg+MDspe3ZhciBvPW4ucG9wKCk7c1tvLm5hbWVdPSEwLHQucHVzaChvKSxvLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oZSl7IXNbZS5uYW1lXSYmZS5pbnB1dE5hbWVzLmV2ZXJ5KGZ1bmN0aW9uKGUpe3ZhciB0PWdldE5vZGVOYW1lQW5kSW5kZXgoZSlbMF07cmV0dXJuIHNbdF19KSYmbi5wdXNoKGUpfSl9dGhpcy5jb21waWxlZE1hcC5zZXQocix0KX19fSxlLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGUsdCxhKXt2YXIgcj10aGlzO3ZvaWQgMD09PXQmJih0PSEwKTt2YXIgbj1PYmplY3Qua2V5cyhlKS5zb3J0KCk7dGhpcy5jaGVja0lucHV0KGUsdCksdGhpcy5jaGVja0lucHV0U2hhcGVBbmRUeXBlKGUsdCksdGhpcy5jb21waWxlKG4ubWFwKGZ1bmN0aW9uKGUpe3JldHVybiByLmdyYXBoLm5vZGVzW2VdfSkpO3ZhciBzPXRoaXMuY2FsY3VsYXRlT3V0cHV0cyhhKTt0aGlzLmNoZWNrT3V0cHV0KHRoaXMuY29tcGlsZWRNYXAuZ2V0KG4uam9pbih0aGlzLlNFUEVSQVRPUikpLHMpO3ZhciBvPXt9O3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBFeGVjdXRpb25Db250ZXh0KHIuX3dlaWdodE1hcCxvKSxhPV9fYXNzaWduKHt9LHIud2VpZ2h0TWFwLGUpLHA9ci5nZXRGcm96ZW5UZW5zb3JJZHMoYSksaT17fSx1PXIuY29tcGlsZWRNYXAuZ2V0KG4uam9pbihyLlNFUEVSQVRPUikpLG09MDttPHUubGVuZ3RoO20rKyl7dmFyIGM9dVttXTtpZihhW2MubmFtZV18fChhW2MubmFtZV09ZXhlY3V0ZU9wJDE2KGMsYSx0KSxyLmNoZWNrVGVuc29yRm9yRGlzcG9zYWwoYy5uYW1lLGMsYSx0LHAscyxpKSkscy5ldmVyeShmdW5jdGlvbihlKXtyZXR1cm4hIWFbZV19KSlicmVha31yZXR1cm4gci5maW5kT3V0cHV0cyhhLHQscyl9KX0sZS5wcm90b3R5cGUuZ2V0RnJvemVuVGVuc29ySWRzPWZ1bmN0aW9uKGUpe3ZhciB0PVtdLmNvbmNhdC5hcHBseShbXSxPYmplY3Qua2V5cyhlKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19KS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlkfSl9KSk7cmV0dXJuIG5ldyBTZXQodCl9LGUucHJvdG90eXBlLmNoZWNrVGVuc29yRm9yRGlzcG9zYWw9ZnVuY3Rpb24oZSx0LGEscixuLHMsbyl7XCJjb250cm9sXCIhPT10LmNhdGVnb3J5JiYtMT09PXMuaW5kZXhPZihlKSYmKGFbZV0uZm9yRWFjaChmdW5jdGlvbihlKXtudWxsIT1lJiYob1tlLmlkXT0ob1tlLmlkXXx8MCkrdC5jaGlsZHJlbi5sZW5ndGgpfSksdC5pbnB1dHMuZm9yRWFjaChmdW5jdGlvbihlKXtpZihcImNvbnRyb2xcIiE9PWUuY2F0ZWdvcnkpe3ZhciB0PWdldFRlbnNvcnNGb3JDdXJyZW50Q29udGVueHQoZS5uYW1lLGEscik7bnVsbCE9dCYmdC5mb3JFYWNoKGZ1bmN0aW9uKGUpe2lmKGUmJiFuLmhhcyhlLmlkKSl7dmFyIHQ9b1tlLmlkXTsxPT09dD8oZS5kaXNwb3NlKCksZGVsZXRlIG9bZS5pZF0pOm51bGwhPXQmJm9bZS5pZF0tLX19KX19KSl9LGUucHJvdG90eXBlLmV4ZWN1dGVBc3luYz1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGEscixuLHMsbyxwLGksdSxtPXRoaXM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oYyl7c3dpdGNoKGMubGFiZWwpe2Nhc2UgMDpyZXR1cm4gdGhpcy5jaGVja0lucHV0KGUsITEpLHRoaXMuY2hlY2tJbnB1dFNoYXBlQW5kVHlwZShlLCExKSxhPXt9LHI9bmV3IEV4ZWN1dGlvbkNvbnRleHQodGhpcy5fd2VpZ2h0TWFwLGEpLG49dGhpcy5jYWxjdWxhdGVPdXRwdXRzKHQpLFs0LHRoaXMuZXhlY3V0ZVdpdGhDb250cm9sRmxvdyhlLHIsbildO2Nhc2UgMTpyZXR1cm4gcz1jLnNlbnQoKSxvPXRoaXMuZmluZE91dHB1dHMocyxyLHQpLHA9T2JqZWN0LmtleXMobykubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBvW2VdLmlkfSksaT1PYmplY3Qua2V5cyhlKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGVbdF0ubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlkfSl9KSx1PVtdLmNvbmNhdC5hcHBseShbXSxpKSxPYmplY3Qua2V5cyhzKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3NbZV0uZm9yRWFjaChmdW5jdGlvbihlKXtlJiYhZS5pc0Rpc3Bvc2VkJiYtMT09PXAuaW5kZXhPZihlLmlkKSYmLTE9PT11LmluZGV4T2YoZS5pZCkmJi0xPT09bS53ZWlnaHRJZHMuaW5kZXhPZihlLmlkKSYmZS5kaXNwb3NlKCl9KX0pLFsyLG9dfX0pfSl9LGUucHJvdG90eXBlLmV4ZWN1dGVXaXRoQ29udHJvbEZsb3c9ZnVuY3Rpb24oZSx0LGEpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHIsbixzLG8scCxpLHUsbSxjPXRoaXM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obCl7c3dpdGNoKGwubGFiZWwpe2Nhc2UgMDpyPU9iamVjdC5rZXlzKGUpLG49ci5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGMuZ3JhcGgubm9kZXNbZV19KSxzPW4uY29uY2F0KHRoaXMuZ3JhcGgud2VpZ2h0cykubWFwKGZ1bmN0aW9uKGUpe3JldHVybntub2RlOmUsY29udGV4dHM6dC5jdXJyZW50Q29udGV4dH19KSxvPV9fYXNzaWduKHt9LHRoaXMud2VpZ2h0TWFwLGUpLHA9e30saT10aGlzLmdldEZyb3plblRlbnNvcklkcyhvKSx1PXt9LGwubGFiZWw9MTtjYXNlIDE6cmV0dXJuIHMubGVuZ3RoPjA/KG09dGhpcy5wcm9jZXNzU3RhY2sobixzLHQsbyx1LGksYSxwKSxbNCxQcm9taXNlLmFsbChtKV0pOlszLDNdO2Nhc2UgMjpyZXR1cm4gbC5zZW50KCksWzMsMV07Y2FzZSAzOnJldHVyblsyLG9dfX0pfSl9LGUucHJvdG90eXBlLnByb2Nlc3NTdGFjaz1mdW5jdGlvbihlLHQsYSxyLG4scyxvLHApe2Zvcih2YXIgaT10aGlzLHU9W10sbT1mdW5jdGlvbigpe3ZhciBtPXQucG9wKCk7YS5jdXJyZW50Q29udGV4dD1tLmNvbnRleHRzO3ZhciBsPVwiXCI7aWYoXCJFbnRlclwiPT09bS5ub2RlLm9wJiZnZXRQYXJhbVZhbHVlKFwiaXNDb25zdGFudFwiLG0ubm9kZSxyLGEpJiYobD1nZXROb2RlTmFtZUFuZEluZGV4KG0ubm9kZS5uYW1lLGEpWzBdKSwtMT09PWUuaW5kZXhPZihtLm5vZGUpKXt2YXIgZD1leGVjdXRlT3AkMTYobS5ub2RlLHIsYSk7bHx8KGw9Z2V0Tm9kZU5hbWVBbmRJbmRleChtLm5vZGUubmFtZSxhKVswXSk7dmFyIHk9YS5jdXJyZW50Q29udGV4dDtkIGluc3RhbmNlb2YgUHJvbWlzZT91LnB1c2goZC50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiByW2xdPWUsYS5jdXJyZW50Q29udGV4dD15LGkuY2hlY2tUZW5zb3JGb3JEaXNwb3NhbChsLG0ubm9kZSxyLGEscyxvLHApLGkucHJvY2Vzc0NoaWxkTm9kZXMobS5ub2RlLHQsYSxyLG4pLGV9KSk6KHJbbF09ZCxjLmNoZWNrVGVuc29yRm9yRGlzcG9zYWwobCxtLm5vZGUscixhLHMsbyxwKSxjLnByb2Nlc3NDaGlsZE5vZGVzKG0ubm9kZSx0LGEscixuKSl9ZWxzZSBjLnByb2Nlc3NDaGlsZE5vZGVzKG0ubm9kZSx0LGEscixuKX0sYz10aGlzO3QubGVuZ3RoPjA7KW0oKTtyZXR1cm4gdX0sZS5wcm90b3R5cGUucHJvY2Vzc0NoaWxkTm9kZXM9ZnVuY3Rpb24oZSx0LGEscixuKXtlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHM9Z2V0Tm9kZU5hbWVBbmRJbmRleChlLm5hbWUsYSlbMF07bltzXXx8KFwiTWVyZ2VcIj09PWUub3A/ZS5pbnB1dE5hbWVzLnNvbWUoZnVuY3Rpb24oZSl7cmV0dXJuISFnZXRUZW5zb3IoZSxyLGEpfSkmJihuW3NdPSEwLHQucHVzaCh7Y29udGV4dHM6YS5jdXJyZW50Q29udGV4dCxub2RlOmV9KSk6ZS5pbnB1dE5hbWVzLmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVybiEhZ2V0VGVuc29yKGUscixhKX0pJiYobltzXT0hMCx0LnB1c2goe2NvbnRleHRzOmEuY3VycmVudENvbnRleHQsbm9kZTplfSkpKX0pfSxlLnByb3RvdHlwZS5jYWxjdWxhdGVPdXRwdXRzPWZ1bmN0aW9uKGUpe3JldHVybiFlfHxlIGluc3RhbmNlb2YgQXJyYXl8fChlPVtlXSksZXx8dGhpcy5ncmFwaC5vdXRwdXRzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lfSl9LGUucHJvdG90eXBlLmZpbmRPdXRwdXRzPWZ1bmN0aW9uKGUsdCxhKXtyZXR1cm4gdGhpcy5jYWxjdWxhdGVPdXRwdXRzKGEpLnJlZHVjZShmdW5jdGlvbihhLHIpe3JldHVybiBhW3JdPWdldFRlbnNvcihyLGUsdCksYX0se30pfSxlLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcztPYmplY3Qua2V5cyh0aGlzLndlaWdodE1hcCkuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gZS53ZWlnaHRNYXBbdF0uZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gZS5kaXNwb3NlKCl9KX0pfSxlLnByb3RvdHlwZS5jaGVja0lucHV0U2hhcGVBbmRUeXBlPWZ1bmN0aW9uKGUsdCl7dm9pZCAwPT09dCYmKHQ9ITApLHRoaXMucGxhY2Vob2xkZXJzLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIHI9ZVthLm5hbWVdO2lmKHR8fHIpe3ZhciBuPXJbMF07aWYoYS5hdHRyUGFyYW1zLnNoYXBlJiZhLmF0dHJQYXJhbXMuc2hhcGUudmFsdWUpe3ZhciBzPWEuYXR0clBhcmFtcy5zaGFwZS52YWx1ZSxvPXMubGVuZ3RoPT09bi5zaGFwZS5sZW5ndGgmJm4uc2hhcGUuZXZlcnkoZnVuY3Rpb24oZSx0KXtyZXR1cm4tMT09PXNbdF18fHNbdF09PT1lfSk7dXRpbC5hc3NlcnQobyxmdW5jdGlvbigpe3JldHVyblwiVGhlIHNoYXBlIG9mIGRpY3RbJ1wiK2EubmFtZStcIiddIHByb3ZpZGVkIGluIG1vZGVsLmV4ZWN1dGUoZGljdCkgbXVzdCBiZSBbXCIrcytcIl0sIGJ1dCB3YXMgW1wiK24uc2hhcGUrXCJdXCJ9KX1hLmF0dHJQYXJhbXMuZHR5cGUmJmEuYXR0clBhcmFtcy5kdHlwZS52YWx1ZSYmdXRpbC5hc3NlcnQobi5kdHlwZT09PWEuYXR0clBhcmFtcy5kdHlwZS52YWx1ZSxmdW5jdGlvbigpe3JldHVyblwiVGhlIGR0eXBlIG9mIGRpY3RbJ1wiK2EubmFtZStcIiddIHByb3ZpZGVkIGluIG1vZGVsLmV4ZWN1dGUoZGljdCkgbXVzdCBiZSBcIithLmF0dHJQYXJhbXMuZHR5cGUudmFsdWUrXCIsIGJ1dCB3YXMgXCIrbi5kdHlwZX0pfX0pfSxlLnByb3RvdHlwZS5jaGVja0lucHV0PWZ1bmN0aW9uKGUsdCl7dmFyIGE9dGhpczt2b2lkIDA9PT10JiYodD0hMCk7dmFyIHI9T2JqZWN0LmtleXMoZSksbj1bXSxzPVtdO3RoaXMuaW5wdXROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGUpey0xPT09ci5pbmRleE9mKGUpJiZuLnB1c2goZSl9KSxyLmZvckVhY2goZnVuY3Rpb24oZSl7LTE9PT1hLmlucHV0Tm9kZXMuaW5kZXhPZihlKSYmcy5wdXNoKGUpfSk7dmFyIG89cy5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIWEuZ3JhcGgubm9kZXNbZV19KTtpZihuLmxlbmd0aD4wJiZ0KXRocm93IG5ldyBFcnJvcihcIlRoZSBkaWN0IHByb3ZpZGVkIGluIG1vZGVsLmV4ZWN1dGUoZGljdCkgaGFzIHRoZSBrZXlzIFtcIityK1wiXSwgYnV0IGlzIG1pc3NpbmcgdGhlIHJlcXVpcmVkIGtleXM6IFtcIituK1wiXS5cIik7aWYocy5sZW5ndGg+MCYmdCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGljdCBwcm92aWRlZCBpbiBtb2RlbC5leGVjdXRlKGRpY3QpIGhhcyB1bnVzZWQga2V5czogW1wiK3MrXCJdLiBQbGVhc2UgcHJvdmlkZSBvbmx5IHRoZSBmb2xsb3dpbmcga2V5czogW1wiK3RoaXMuaW5wdXROb2RlcytcIl0uXCIpO2lmKG8ubGVuZ3RoPjApdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRpY3QgcHJvdmlkZWQgaW4gbW9kZWwuZXhlY3V0ZShkaWN0KSBoYXMga2V5czogW1wiK28rXCJdIG5vdCBwYXJ0IG9mIG1vZGVsIGdyYXBoLlwiKX0sZS5wcm90b3R5cGUuY2hlY2tPdXRwdXQ9ZnVuY3Rpb24oZSx0KXt2YXIgYT1lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lfSkscj1bXTtpZih0LmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9cGFyc2VOb2RlTmFtZShlKVswXTstMT09PWEuaW5kZXhPZih0KSYmci5wdXNoKHQpfSksci5sZW5ndGg+MCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZm9sbG93aW5nIG91dHB1dHMgYXJlIG5vdCBnZW5lcmF0ZWQgYnkgdGhlIGV4ZWN1dGlvbjogW1wiK3IrXCJdLlwiKX0sZX0oKSxURkhVQl9TRUFSQ0hfUEFSQU09XCI/dGZqcy1mb3JtYXQ9ZmlsZVwiLERFRkFVTFRfTU9ERUxfTkFNRT1cIm1vZGVsLmpzb25cIixHcmFwaE1vZGVsPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3ZvaWQgMD09PXQmJih0PXt9KSx0aGlzLm1vZGVsVXJsPWUsdGhpcy5sb2FkT3B0aW9ucz10LHRoaXMudmVyc2lvbj1cIm4vYVwiLG51bGw9PXQmJih0aGlzLmxvYWRPcHRpb25zPXt9KX1yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwibW9kZWxWZXJzaW9uXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZlcnNpb259LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiaW5wdXROb2Rlc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5leGVjdXRvci5pbnB1dE5vZGVzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcIm91dHB1dE5vZGVzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmV4ZWN1dG9yLm91dHB1dE5vZGVzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImlucHV0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5leGVjdXRvci5pbnB1dHN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwib3V0cHV0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5leGVjdXRvci5vdXRwdXRzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcIndlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXhlY3V0b3Iud2VpZ2h0TWFwfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGUucHJvdG90eXBlLmZpbmRJT0hhbmRsZXI9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm1vZGVsVXJsO2lmKG51bGwhPWUubG9hZCl0aGlzLmhhbmRsZXI9ZTtlbHNlIGlmKG51bGwhPXRoaXMubG9hZE9wdGlvbnMucmVxdWVzdEluaXQpdGhpcy5oYW5kbGVyPWlvLmJyb3dzZXJIVFRQUmVxdWVzdChlLHRoaXMubG9hZE9wdGlvbnMpO2Vsc2V7dmFyIHQ9aW8uZ2V0TG9hZEhhbmRsZXJzKGUsdGhpcy5sb2FkT3B0aW9ucy5vblByb2dyZXNzKTtpZigwPT09dC5sZW5ndGgpdC5wdXNoKGlvLmJyb3dzZXJIVFRQUmVxdWVzdChlLHRoaXMubG9hZE9wdGlvbnMpKTtlbHNlIGlmKHQubGVuZ3RoPjEpdGhyb3cgbmV3IEVycm9yKFwiRm91bmQgbW9yZSB0aGFuIG9uZSAoXCIrdC5sZW5ndGgrXCIpIGxvYWQgaGFuZGxlcnMgZm9yIFVSTCAnXCIrW2VdK1wiJ1wiKTt0aGlzLmhhbmRsZXI9dFswXX19LGUucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLHQsYTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOmlmKHRoaXMuZmluZElPSGFuZGxlcigpLG51bGw9PXRoaXMuaGFuZGxlci5sb2FkKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwcm9jZWVkIHdpdGggbW9kZWwgbG9hZGluZyBiZWNhdXNlIHRoZSBJT0hhbmRsZXIgcHJvdmlkZWQgZG9lcyBub3QgaGF2ZSB0aGUgYGxvYWRgIG1ldGhvZCBpbXBsZW1lbnRlZC5cIik7cmV0dXJuWzQsdGhpcy5oYW5kbGVyLmxvYWQoKV07Y2FzZSAxOnJldHVybiBlPXIuc2VudCgpLHQ9ZS5tb2RlbFRvcG9sb2d5LHRoaXMudmVyc2lvbj10LnZlcnNpb25zLnByb2R1Y2VyK1wiLlwiK3QudmVyc2lvbnMubWluQ29uc3VtZXIsYT1pby5kZWNvZGVXZWlnaHRzKGUud2VpZ2h0RGF0YSxlLndlaWdodFNwZWNzKSx0aGlzLmV4ZWN1dG9yPW5ldyBHcmFwaEV4ZWN1dG9yKE9wZXJhdGlvbk1hcHBlci5JbnN0YW5jZS50cmFuc2Zvcm1HcmFwaCh0KSksdGhpcy5leGVjdXRvci53ZWlnaHRNYXA9dGhpcy5jb252ZXJ0VGVuc29yTWFwVG9UZW5zb3JzTWFwKGEpLFsyLCEwXX19KX0pfSxlLnByb3RvdHlwZS5wcmVkaWN0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZXhlY3V0ZV8oZSwhMCx0aGlzLm91dHB1dE5vZGVzKX0sZS5wcm90b3R5cGUuY29uc3RydWN0VGVuc29yTWFwPWZ1bmN0aW9uKGUpe3ZhciB0PWUgaW5zdGFuY2VvZiBUZW5zb3I/W2VdOmU7aWYodC5sZW5ndGghPT10aGlzLmlucHV0Tm9kZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIklucHV0IHRlbnNvciBjb3VudCBtaXNtYXRjaCx0aGUgZ3JhcGggbW9kZWwgaGFzIFwiK3RoaXMuaW5wdXROb2Rlcy5sZW5ndGgrXCIgcGxhY2Vob2xkZXJzLCB3aGlsZSB0aGVyZSBhcmUgXCIrdC5sZW5ndGgrXCIgaW5wdXQgdGVuc29ycy5cIik7cmV0dXJuIHRoaXMuaW5wdXROb2Rlcy5yZWR1Y2UoZnVuY3Rpb24oZSxhLHIpe3JldHVybiBlW2FdPXRbcl0sZX0se30pfSxlLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZXhlY3V0ZV8oZSwhMSx0KX0sZS5wcm90b3R5cGUuZXhlY3V0ZV89ZnVuY3Rpb24oZSx0LGEpe2lmKHZvaWQgMD09PXQmJih0PSEwKSxhPWF8fHRoaXMub3V0cHV0Tm9kZXMsKGUgaW5zdGFuY2VvZiBUZW5zb3J8fEFycmF5LmlzQXJyYXkoZSkpJiYoZT10aGlzLmNvbnN0cnVjdFRlbnNvck1hcChlKSksdGhpcy5leGVjdXRvci5pc0NvbnRyb2xGbG93TW9kZWx8fHRoaXMuZXhlY3V0b3IuaXNEeW5hbWljU2hhcGVNb2RlbCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbW9kZWwgY29udGFpbnMgY29udHJvbCBmbG93IG9yIGR5bmFtaWMgc2hhcGUgb3BzLCBwbGVhc2UgdXNlIGV4ZWN1dGVBc3luYyBtZXRob2RcIik7dmFyIHI9dGhpcy5leGVjdXRvci5leGVjdXRlKHRoaXMuY29udmVydFRlbnNvck1hcFRvVGVuc29yc01hcChlKSx0LGEpLG49T2JqZWN0LmtleXMocik7cmV0dXJuIEFycmF5LmlzQXJyYXkoYSkmJmEubGVuZ3RoPjE/YS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHJbZV19KTpyW25bMF1dfSxlLnByb3RvdHlwZS5leGVjdXRlQXN5bmM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBhLHI7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDppZighdGhpcy5leGVjdXRvci5pc0NvbnRyb2xGbG93TW9kZWwmJiF0aGlzLmV4ZWN1dG9yLmlzRHluYW1pY1NoYXBlTW9kZWwpdGhyb3cgbmV3IEVycm9yKFwiVGhlIG1vZGVsIGRvZXMgbm90IGNvbnRhaW4gY29udHJvbCBmbG93IG9yIGR5bmFtaWMgc2hhcGUgb3BzLCBwbGVhc2UgdXNlIGV4ZWN1dGUgbWV0aG9kIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXCIpO3JldHVybiB0PXR8fHRoaXMub3V0cHV0Tm9kZXMsKGUgaW5zdGFuY2VvZiBUZW5zb3J8fEFycmF5LmlzQXJyYXkoZSkpJiYoZT10aGlzLmNvbnN0cnVjdFRlbnNvck1hcChlKSksWzQsdGhpcy5leGVjdXRvci5leGVjdXRlQXN5bmModGhpcy5jb252ZXJ0VGVuc29yTWFwVG9UZW5zb3JzTWFwKGUpLHQpXTtjYXNlIDE6cmV0dXJuIGE9bi5zZW50KCkscj1PYmplY3Qua2V5cyhhKSxbMixBcnJheS5pc0FycmF5KHQpJiZ0Lmxlbmd0aD4xP3QubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBhW2VdfSk6YVtyWzBdXV19fSl9KX0sZS5wcm90b3R5cGUuY29udmVydFRlbnNvck1hcFRvVGVuc29yc01hcD1mdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LmtleXMoZSkucmVkdWNlKGZ1bmN0aW9uKHQsYSl7cmV0dXJuIHRbYV09W2VbYV1dLHR9LHt9KX0sZS5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMuZXhlY3V0b3IuZGlzcG9zZSgpfSxlfSgpO2Z1bmN0aW9uIGxvYWRHcmFwaE1vZGVsKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PXt9KSxfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGE7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDppZihudWxsPT1lKXRocm93IG5ldyBFcnJvcihcIm1vZGVsVXJsIGluIGxvYWRHcmFwaE1vZGVsKCkgY2Fubm90IGJlIG51bGwuIFBsZWFzZSBwcm92aWRlIGEgdXJsIG9yIGFuIElPSGFuZGxlciB0aGF0IGxvYWRzIHRoZSBtb2RlbFwiKTtyZXR1cm4gbnVsbD09dCYmKHQ9e30pLHQuZnJvbVRGSHViJiZudWxsPT1lLmxvYWQmJihlLmVuZHNXaXRoKFwiL1wiKXx8KGUrPVwiL1wiKSxlPVwiXCIrZStERUZBVUxUX01PREVMX05BTUUrVEZIVUJfU0VBUkNIX1BBUkFNKSxbNCwoYT1uZXcgR3JhcGhNb2RlbChlLHQpKS5sb2FkKCldO2Nhc2UgMTpyZXR1cm4gci5zZW50KCksWzIsYV19fSl9KX12YXIgdmVyc2lvbj1cIjEuMS4yXCI7ZXhwb3J0e0dyYXBoTW9kZWwsbG9hZEdyYXBoTW9kZWwsdmVyc2lvbiBhcyB2ZXJzaW9uX2NvbnZlcnRlcn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10Zi1jb252ZXJ0ZXIuZXNtLmpzLm1hcFxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIHQ9ZnVuY3Rpb24oZSxuKXtyZXR1cm4odD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24odCxlKXt0Ll9fcHJvdG9fXz1lfXx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gZSllLmhhc093blByb3BlcnR5KG4pJiYodFtuXT1lW25dKX0pKGUsbil9O2Z1bmN0aW9uIGUoZSxuKXtmdW5jdGlvbiByKCl7dGhpcy5jb25zdHJ1Y3Rvcj1lfXQoZSxuKSxlLnByb3RvdHlwZT1udWxsPT09bj9PYmplY3QuY3JlYXRlKG4pOihyLnByb3RvdHlwZT1uLnByb3RvdHlwZSxuZXcgcil9dmFyIG49ZnVuY3Rpb24oKXtyZXR1cm4obj1PYmplY3QuYXNzaWdufHxmdW5jdGlvbih0KXtmb3IodmFyIGUsbj0xLHI9YXJndW1lbnRzLmxlbmd0aDtuPHI7bisrKWZvcih2YXIgbyBpbiBlPWFyZ3VtZW50c1tuXSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxvKSYmKHRbb109ZVtvXSk7cmV0dXJuIHR9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIHIodCxlLG4scil7cmV0dXJuIG5ldyhufHwobj1Qcm9taXNlKSkoZnVuY3Rpb24obyxhKXtmdW5jdGlvbiBpKHQpe3RyeXt1KHIubmV4dCh0KSl9Y2F0Y2godCl7YSh0KX19ZnVuY3Rpb24gcyh0KXt0cnl7dShyLnRocm93KHQpKX1jYXRjaCh0KXthKHQpfX1mdW5jdGlvbiB1KHQpe3QuZG9uZT9vKHQudmFsdWUpOm5ldyBuKGZ1bmN0aW9uKGUpe2UodC52YWx1ZSl9KS50aGVuKGkscyl9dSgocj1yLmFwcGx5KHQsZXx8W10pKS5uZXh0KCkpfSl9ZnVuY3Rpb24gbyh0LGUpe3ZhciBuLHIsbyxhLGk9e2xhYmVsOjAsc2VudDpmdW5jdGlvbigpe2lmKDEmb1swXSl0aHJvdyBvWzFdO3JldHVybiBvWzFdfSx0cnlzOltdLG9wczpbXX07cmV0dXJuIGE9e25leHQ6cygwKSx0aHJvdzpzKDEpLHJldHVybjpzKDIpfSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihhW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLGE7ZnVuY3Rpb24gcyhhKXtyZXR1cm4gZnVuY3Rpb24ocyl7cmV0dXJuIGZ1bmN0aW9uKGEpe2lmKG4pdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7Zm9yKDtpOyl0cnl7aWYobj0xLHImJihvPTImYVswXT9yLnJldHVybjphWzBdP3IudGhyb3d8fCgobz1yLnJldHVybikmJm8uY2FsbChyKSwwKTpyLm5leHQpJiYhKG89by5jYWxsKHIsYVsxXSkpLmRvbmUpcmV0dXJuIG87c3dpdGNoKHI9MCxvJiYoYT1bMiZhWzBdLG8udmFsdWVdKSxhWzBdKXtjYXNlIDA6Y2FzZSAxOm89YTticmVhaztjYXNlIDQ6cmV0dXJuIGkubGFiZWwrKyx7dmFsdWU6YVsxXSxkb25lOiExfTtjYXNlIDU6aS5sYWJlbCsrLHI9YVsxXSxhPVswXTtjb250aW51ZTtjYXNlIDc6YT1pLm9wcy5wb3AoKSxpLnRyeXMucG9wKCk7Y29udGludWU7ZGVmYXVsdDppZighKG89KG89aS50cnlzKS5sZW5ndGg+MCYmb1tvLmxlbmd0aC0xXSkmJig2PT09YVswXXx8Mj09PWFbMF0pKXtpPTA7Y29udGludWV9aWYoMz09PWFbMF0mJighb3x8YVsxXT5vWzBdJiZhWzFdPG9bM10pKXtpLmxhYmVsPWFbMV07YnJlYWt9aWYoNj09PWFbMF0mJmkubGFiZWw8b1sxXSl7aS5sYWJlbD1vWzFdLG89YTticmVha31pZihvJiZpLmxhYmVsPG9bMl0pe2kubGFiZWw9b1syXSxpLm9wcy5wdXNoKGEpO2JyZWFrfW9bMl0mJmkub3BzLnBvcCgpLGkudHJ5cy5wb3AoKTtjb250aW51ZX1hPWUuY2FsbCh0LGkpfWNhdGNoKHQpe2E9WzYsdF0scj0wfWZpbmFsbHl7bj1vPTB9aWYoNSZhWzBdKXRocm93IGFbMV07cmV0dXJue3ZhbHVlOmFbMF0/YVsxXTp2b2lkIDAsZG9uZTohMH19KFthLHNdKX19fXZhciBhLGk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuZ2xvYmFsPXQsdGhpcy5mbGFncz17fSx0aGlzLmZsYWdSZWdpc3RyeT17fSx0aGlzLnVybEZsYWdzPXt9LHRoaXMucG9wdWxhdGVVUkxGbGFncygpfXJldHVybiB0LnByb3RvdHlwZS5yZWdpc3RlckZsYWc9ZnVuY3Rpb24odCxlLG4pe2lmKHRoaXMuZmxhZ1JlZ2lzdHJ5W3RdPXtldmFsdWF0aW9uRm46ZSxzZXRIb29rOm59LG51bGwhPXRoaXMudXJsRmxhZ3NbdF0pe3ZhciByPXRoaXMudXJsRmxhZ3NbdF07Y29uc29sZS53YXJuKFwiU2V0dGluZyBmZWF0dXJlIG92ZXJyaWRlIGZyb20gVVJMIFwiK3QrXCI6IFwiK3IrXCIuXCIpLHRoaXMuc2V0KHQscil9fSx0LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW4gdGhpcy5mbGFncz90aGlzLmZsYWdzW3RdOih0aGlzLmZsYWdzW3RdPXRoaXMuZXZhbHVhdGVGbGFnKHQpLHRoaXMuZmxhZ3NbdF0pfSx0LnByb3RvdHlwZS5nZXROdW1iZXI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2V0KHQpfSx0LnByb3RvdHlwZS5nZXRCb29sPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldCh0KX0sdC5wcm90b3R5cGUuZ2V0RmxhZ3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mbGFnc30sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiZmVhdHVyZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmxhZ3N9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKHQsZSl7aWYobnVsbD09dGhpcy5mbGFnUmVnaXN0cnlbdF0pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBmbGFnIFwiK3QrXCIgYXMgaXQgaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQuXCIpO3RoaXMuZmxhZ3NbdF09ZSxudWxsIT10aGlzLmZsYWdSZWdpc3RyeVt0XS5zZXRIb29rJiZ0aGlzLmZsYWdSZWdpc3RyeVt0XS5zZXRIb29rKGUpfSx0LnByb3RvdHlwZS5ldmFsdWF0ZUZsYWc9ZnVuY3Rpb24odCl7aWYobnVsbD09dGhpcy5mbGFnUmVnaXN0cnlbdF0pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGV2YWx1YXRlIGZsYWcgJ1wiK3QrXCInOiBubyBldmFsdWF0aW9uIGZ1bmN0aW9uIGZvdW5kLlwiKTtyZXR1cm4gdGhpcy5mbGFnUmVnaXN0cnlbdF0uZXZhbHVhdGlvbkZuKCl9LHQucHJvdG90eXBlLnNldEZsYWdzPWZ1bmN0aW9uKHQpe3RoaXMuZmxhZ3M9T2JqZWN0LmFzc2lnbih7fSx0KX0sdC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLmZsYWdzPXt9LHRoaXMudXJsRmxhZ3M9e30sdGhpcy5wb3B1bGF0ZVVSTEZsYWdzKCl9LHQucHJvdG90eXBlLnBvcHVsYXRlVVJMRmxhZ3M9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2lmKHZvaWQgMCE9PXRoaXMuZ2xvYmFsJiZ2b2lkIDAhPT10aGlzLmdsb2JhbC5sb2NhdGlvbiYmdm9pZCAwIT09dGhpcy5nbG9iYWwubG9jYXRpb24uc2VhcmNoKXt2YXIgZT1zKHRoaXMuZ2xvYmFsLmxvY2F0aW9uLnNlYXJjaCk7aWYoXCJ0ZmpzZmxhZ3NcImluIGUpZS50ZmpzZmxhZ3Muc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIG49ZS5zcGxpdChcIjpcIikscj1uWzBdLG89blsxXTt0LnVybEZsYWdzW3JdPWZ1bmN0aW9uKHQsZSl7aWYoXCJ0cnVlXCI9PT0oZT1lLnRvTG93ZXJDYXNlKCkpfHxcImZhbHNlXCI9PT1lKXJldHVyblwidHJ1ZVwiPT09ZTtpZihcIlwiKyArZT09PWUpcmV0dXJuK2U7dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHBhcnNlIHZhbHVlIGZsYWcgdmFsdWUgXCIrZStcIiBmb3IgZmxhZyBcIit0K1wiLlwiKX0ocixvKX0pfX0sdH0oKTtmdW5jdGlvbiBzKHQpe3ZhciBlPXt9O3JldHVybiB0LnJlcGxhY2UoL1s/Jl0oW149PyZdKykoPzo9KFteJl0qKSk/L2csZnVuY3Rpb24odCl7Zm9yKHZhciBuPVtdLHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKW5bci0xXT1hcmd1bWVudHNbcl07cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt0W2RlY29kZVVSSUNvbXBvbmVudChlKV09ZGVjb2RlVVJJQ29tcG9uZW50KG58fFwiXCIpfShlLG5bMF0sblsxXSksbi5qb2luKFwiPVwiKX0pLGV9ZnVuY3Rpb24gdSh0KXthPXR9dmFyIGw9T2JqZWN0LmZyZWV6ZSh7RW52aXJvbm1lbnQ6aSxnZXRRdWVyeVBhcmFtczpzLGdldCBFTlYoKXtyZXR1cm4gYX0sc2V0RW52aXJvbm1lbnRHbG9iYWw6dX0pO2Z1bmN0aW9uIGModCl7Zm9yKHZhciBlPXQubGVuZ3RoLG49MCxyPTA7ZT4wOylyPU1hdGgucmFuZG9tKCkqZXwwLG49dFstLWVdLHRbZV09dFtyXSx0W3JdPW59ZnVuY3Rpb24gaCh0LGUsbil7cmV0dXJuIE1hdGgubWF4KHQsTWF0aC5taW4oZSxuKSl9ZnVuY3Rpb24gcCh0KXtyZXR1cm4gdCUyPT0wP3Q6dCsxfWZ1bmN0aW9uIGYodCl7Zm9yKHZhciBlPTAsbj0wO248dC5sZW5ndGg7bisrKWUrPXRbbl07cmV0dXJuIGV9ZnVuY3Rpb24gZCh0LGUpe2lmKCF0KXRocm93IG5ldyBFcnJvcihcInN0cmluZ1wiPT10eXBlb2YgZT9lOmUoKSl9ZnVuY3Rpb24gdih0LGUsbil7dm9pZCAwPT09biYmKG49XCJcIiksZCh4KHQsZSksZnVuY3Rpb24oKXtyZXR1cm4gbitcIiBTaGFwZXMgXCIrdCtcIiBhbmQgXCIrZStcIiBtdXN0IG1hdGNoXCJ9KX1mdW5jdGlvbiBtKHQpe2QobnVsbCE9dCxmdW5jdGlvbigpe3JldHVyblwiVGhlIGlucHV0IHRvIHRoZSB0ZW5zb3IgY29uc3RydWN0b3IgbXVzdCBiZSBhIG5vbi1udWxsIHZhbHVlLlwifSl9ZnVuY3Rpb24gZyh0LGUpe2lmKHZvaWQgMD09PWUmJihlPVtdKSxudWxsPT1lJiYoZT1bXSksQXJyYXkuaXNBcnJheSh0KXx8Xyh0KSlmb3IodmFyIG49MDtuPHQubGVuZ3RoOysrbilnKHRbbl0sZSk7ZWxzZSBlLnB1c2godCk7cmV0dXJuIGV9ZnVuY3Rpb24geSh0KXtpZigwPT09dC5sZW5ndGgpcmV0dXJuIDE7Zm9yKHZhciBlPXRbMF0sbj0xO248dC5sZW5ndGg7bisrKWUqPXRbbl07cmV0dXJuIGV9ZnVuY3Rpb24geCh0LGUpe2lmKHQ9PT1lKXJldHVybiEwO2lmKG51bGw9PXR8fG51bGw9PWUpcmV0dXJuITE7aWYodC5sZW5ndGghPT1lLmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKylpZih0W25dIT09ZVtuXSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiB3KHQpe3JldHVybiB0JTE9PTB9ZnVuY3Rpb24gYih0KXtpZihudWxsIT1NYXRoLnRhbmgpcmV0dXJuIE1hdGgudGFuaCh0KTtpZih0PT09MS8wKXJldHVybiAxO2lmKHQ9PT0tMS8wKXJldHVybi0xO3ZhciBlPU1hdGguZXhwKDIqdCk7cmV0dXJuKGUtMSkvKGUrMSl9ZnVuY3Rpb24gQyh0KXt2YXIgZT1NYXRoLmNlaWwoTWF0aC5zcXJ0KHQpKTtyZXR1cm5bZSxNYXRoLmNlaWwodC9lKV19ZnVuY3Rpb24gRSh0LGUpe3JldHVybiBlPD10Lmxlbmd0aD90OnQrXCIgXCIucmVwZWF0KGUtdC5sZW5ndGgpfWZ1bmN0aW9uIFIodCxlLG4pe3JldHVybiB2b2lkIDA9PT1lJiYoZT1mdW5jdGlvbih0KXtyZXR1cm4gMH0pLG5ldyBQcm9taXNlKGZ1bmN0aW9uKHIsbyl7dmFyIGE9MCxpPWZ1bmN0aW9uKCl7aWYodCgpKXIoKTtlbHNle3ZhciBzPWUoKythKTtudWxsIT1uJiZhPj1uP28oKTpzZXRUaW1lb3V0KGkscyl9fTtpKCl9KX1mdW5jdGlvbiBTKHQsZSl7Zm9yKHZhciBuPTEscj0tMSxvPTA7bzx0Lmxlbmd0aDsrK28paWYodFtvXT49MCluKj10W29dO2Vsc2UgaWYoLTE9PT10W29dKXtpZigtMSE9PXIpdGhyb3cgRXJyb3IoXCJTaGFwZXMgY2FuIG9ubHkgaGF2ZSAxIGltcGxpY2l0IHNpemUuIEZvdW5kIC0xIGF0IGRpbSBcIityK1wiIGFuZCBkaW0gXCIrbyk7cj1vfWVsc2UgaWYodFtvXTwwKXRocm93IEVycm9yKFwiU2hhcGVzIGNhbiBub3QgYmUgPCAwLiBGb3VuZCBcIit0W29dK1wiIGF0IGRpbSBcIitvKTtpZigtMT09PXIpe2lmKGU+MCYmZSE9PW4pdGhyb3cgRXJyb3IoXCJTaXplKFwiK2UrXCIpIG11c3QgbWF0Y2ggdGhlIHByb2R1Y3Qgb2Ygc2hhcGUgXCIrdCk7cmV0dXJuIHR9aWYoMD09PW4pdGhyb3cgRXJyb3IoXCJDYW5ub3QgaW5mZXIgdGhlIG1pc3Npbmcgc2l6ZSBpbiBbXCIrdCtcIl0gd2hlbiB0aGVyZSBhcmUgMCBlbGVtZW50c1wiKTtpZihlJW4hPTApdGhyb3cgRXJyb3IoXCJUaGUgaW1wbGljaXQgc2hhcGUgY2FuJ3QgYmUgYSBmcmFjdGlvbmFsIG51bWJlci4gR290IFwiK2UrXCIgLyBcIituKTt2YXIgYT10LnNsaWNlKCk7cmV0dXJuIGFbcl09ZS9uLGF9ZnVuY3Rpb24gTih0LGUpe3ZhciBuPWUubGVuZ3RoO3JldHVybiBkKCh0PW51bGw9PXQ/ZS5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm4gZX0pOltdLmNvbmNhdCh0KSkuZXZlcnkoZnVuY3Rpb24odCl7cmV0dXJuIHQ+PS1uJiZ0PG59KSxmdW5jdGlvbigpe3JldHVyblwiQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW4gcmFuZ2UgWy1cIituK1wiLCBcIituK1wiKSBidXQgZ290IGF4aXMgXCIrdH0pLGQodC5ldmVyeShmdW5jdGlvbih0KXtyZXR1cm4gdyh0KX0pLGZ1bmN0aW9uKCl7cmV0dXJuXCJBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbnRlZ2VycyBidXQgZ290IGF4aXMgXCIrdH0pLHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0PDA/bit0OnR9KX1mdW5jdGlvbiBrKHQsZSl7Zm9yKHZhciBuPVtdLHI9W10sbz1udWxsPT1lP251bGw6TihlLHQpLnNvcnQoKSxhPTAsaT0wO2k8dC5sZW5ndGg7KytpKXtpZihudWxsIT1vKXtpZihvW2FdPT09aSYmMSE9PXRbaV0pdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc3F1ZWV6ZSBheGlzIFwiK2krXCIgc2luY2UgaXRzIGRpbSAnXCIrdFtpXStcIicgaXMgbm90IDFcIik7KG51bGw9PW9bYV18fG9bYV0+aSkmJjE9PT10W2ldJiYobi5wdXNoKHRbaV0pLHIucHVzaChpKSksb1thXTw9aSYmYSsrfTEhPT10W2ldJiYobi5wdXNoKHRbaV0pLHIucHVzaChpKSl9cmV0dXJue25ld1NoYXBlOm4sa2VwdERpbXM6cn19ZnVuY3Rpb24gSSh0LGUpe3ZhciBuPW51bGw7aWYobnVsbD09dHx8XCJmbG9hdDMyXCI9PT10KW49bmV3IEZsb2F0MzJBcnJheShlKTtlbHNlIGlmKFwiaW50MzJcIj09PXQpbj1uZXcgSW50MzJBcnJheShlKTtlbHNle2lmKFwiYm9vbFwiIT09dCl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBcIit0KTtuPW5ldyBVaW50OEFycmF5KGUpfXJldHVybiBufWZ1bmN0aW9uIEEodCxlKXt2YXIgbj1udWxsO2lmKG51bGw9PXR8fFwiZmxvYXQzMlwiPT09dCluPW5ldyBGbG9hdDMyQXJyYXkoZSk7ZWxzZSBpZihcImludDMyXCI9PT10KW49bmV3IEludDMyQXJyYXkoZSk7ZWxzZSBpZihcImJvb2xcIj09PXQpbj1uZXcgVWludDhBcnJheShlKTtlbHNle2lmKFwic3RyaW5nXCIhPT10KXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiK3QpO249bmV3IEFycmF5KGUpfXJldHVybiBufWZ1bmN0aW9uIFQodCxlLG4pe2lmKFwiZmxvYXQzMlwiPT09ZSlmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG89dFtyXTtpZihpc05hTihvKXx8IWlzRmluaXRlKG8pKXRocm93IEVycm9yKFwiVGhlIHJlc3VsdCBvZiB0aGUgJ1wiK24rXCInIGlzIFwiK28rXCIuXCIpfX1mdW5jdGlvbiBEKHQsZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07aWYoaXNOYU4ocil8fCFpc0Zpbml0ZShyKSl0aHJvdyBFcnJvcihcIkEgdGVuc29yIG9mIHR5cGUgXCIrZStcIiBiZWluZyB1cGxvYWRlZCBjb250YWlucyBcIityK1wiLlwiKX19ZnVuY3Rpb24gTyh0LGUpe3JldHVyblwiY29tcGxleDY0XCIhPT1lJiYoKFwiZmxvYXQzMlwiIT09ZXx8XCJjb21wbGV4NjRcIj09PXQpJiYoKFwiaW50MzJcIiE9PWV8fFwiZmxvYXQzMlwiPT09dHx8XCJjb21wbGV4NjRcIj09PXQpJiYoXCJib29sXCIhPT1lfHxcImJvb2xcIiE9PXQpKSl9ZnVuY3Rpb24gXyh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8dCBpbnN0YW5jZW9mIEludDMyQXJyYXl8fHQgaW5zdGFuY2VvZiBVaW50OEFycmF5fWZ1bmN0aW9uIE0odCl7aWYoXCJmbG9hdDMyXCI9PT10fHxcImludDMyXCI9PT10KXJldHVybiA0O2lmKFwiY29tcGxleDY0XCI9PT10KXJldHVybiA4O2lmKFwiYm9vbFwiPT09dClyZXR1cm4gMTt0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGR0eXBlIFwiK3QpfWZ1bmN0aW9uIEYodCl7aWYobnVsbD09dClyZXR1cm4gMDt2YXIgZT0wO3JldHVybiB0LmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIGUrPTIqdC5sZW5ndGh9KSxlfWZ1bmN0aW9uIEIodCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHR8fHQgaW5zdGFuY2VvZiBTdHJpbmd9ZnVuY3Rpb24gUCh0KXtyZXR1cm5cImJvb2xlYW5cIj09dHlwZW9mIHR9ZnVuY3Rpb24gTCh0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdH1mdW5jdGlvbiBXKHQpe3JldHVybiBBcnJheS5pc0FycmF5KHQpP1codFswXSk6dCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheT9cImZsb2F0MzJcIjp0IGluc3RhbmNlb2YgSW50MzJBcnJheXx8dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk/XCJpbnQzMlwiOkwodCk/XCJmbG9hdDMyXCI6Qih0KT9cInN0cmluZ1wiOlAodCk/XCJib29sXCI6XCJmbG9hdDMyXCJ9ZnVuY3Rpb24gVSh0KXtyZXR1cm4hISh0JiZ0LmNvbnN0cnVjdG9yJiZ0LmNhbGwmJnQuYXBwbHkpfWZ1bmN0aW9uIHoodCxlKXtmb3IodmFyIG49ZTtuPHQ7KytuKWlmKHQlbj09MClyZXR1cm4gbjtyZXR1cm4gdH1mdW5jdGlvbiBWKHQpe3ZhciBlPXQubGVuZ3RoO2lmKGU8MilyZXR1cm5bXTt2YXIgbj1uZXcgQXJyYXkoZS0xKTtuW2UtMl09dFtlLTFdO2Zvcih2YXIgcj1lLTM7cj49MDstLXIpbltyXT1uW3IrMV0qdFtyKzFdO3JldHVybiBufWZ1bmN0aW9uIEcodCxlLG4pe2lmKFwic3RyaW5nXCI9PT1lKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IGEgc3RyaW5nW10gdG8gYSBUeXBlZEFycmF5XCIpO2lmKEFycmF5LmlzQXJyYXkodCkmJih0PWcodCkpLG4mJkQodCxlKSxmdW5jdGlvbih0LGUpe3JldHVybiB0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5JiZcImZsb2F0MzJcIj09PWV8fHQgaW5zdGFuY2VvZiBJbnQzMkFycmF5JiZcImludDMyXCI9PT1lfHx0IGluc3RhbmNlb2YgVWludDhBcnJheSYmXCJib29sXCI9PT1lfSh0LGUpKXJldHVybiB0O2lmKG51bGw9PWV8fFwiZmxvYXQzMlwiPT09ZXx8XCJjb21wbGV4NjRcIj09PWUpcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodCk7aWYoXCJpbnQzMlwiPT09ZSlyZXR1cm4gbmV3IEludDMyQXJyYXkodCk7aWYoXCJib29sXCI9PT1lKXtmb3IodmFyIHI9bmV3IFVpbnQ4QXJyYXkodC5sZW5ndGgpLG89MDtvPHIubGVuZ3RoOysrbykwIT09TWF0aC5yb3VuZCh0W29dKSYmKHJbb109MSk7cmV0dXJuIHJ9dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIrZSl9ZnVuY3Rpb24gcSh0LGUpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gZVswXTt2YXIgbj10LnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KTtpZigwPT09bilyZXR1cm5bXTtpZihuIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiW1wiK3QrXCJdIGRvZXMgbm90IG1hdGNoIHRoZSBpbnB1dCBzaXplLlwiKTtyZXR1cm4gZnVuY3Rpb24gdChlLG4scil7dmFyIG89bmV3IEFycmF5O2lmKDE9PT1uLmxlbmd0aClmb3IodmFyIGE9blswXSxpPTA7aTxhO2krKylvW2ldPXJbZStpXTtlbHNle2E9blswXTt2YXIgcz1uLnNsaWNlKDEpLHU9cy5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSk7Zm9yKGk9MDtpPGE7aSsrKW9baV09dChlK2kqdSxzLHIpfXJldHVybiBvfSgwLHQsZSl9ZnVuY3Rpb24gSCh0LGUpe2Zvcih2YXIgbj0kKHQsZSkscj0wO3I8bi5sZW5ndGg7cisrKW5bcl09MTtyZXR1cm4gbn1mdW5jdGlvbiAkKHQsZSl7aWYobnVsbD09ZXx8XCJmbG9hdDMyXCI9PT1lfHxcImNvbXBsZXg2NFwiPT09ZSlyZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0KTtpZihcImludDMyXCI9PT1lKXJldHVybiBuZXcgSW50MzJBcnJheSh0KTtpZihcImJvb2xcIj09PWUpcmV0dXJuIG5ldyBVaW50OEFycmF5KHQpO3Rocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiK2UpfWZ1bmN0aW9uIGooKXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgcGVyZm9ybWFuY2UpcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBwcm9jZXNzKXt2YXIgdD1wcm9jZXNzLmhydGltZSgpO3JldHVybiAxZTMqdFswXSt0WzFdLzFlNn10aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbWVhc3VyZSB0aW1lIGluIHRoaXMgZW52aXJvbm1lbnQuIFlvdSBzaG91bGQgcnVuIHRmLmpzIGluIHRoZSBicm93c2VyIG9yIGluIE5vZGUuanNcIil9ZnVuY3Rpb24gSyh0KXt0LmZvckVhY2goZnVuY3Rpb24oZSl7ZChOdW1iZXIuaXNJbnRlZ2VyKGUpJiZlPj0wLGZ1bmN0aW9uKCl7cmV0dXJuXCJUZW5zb3IgbXVzdCBoYXZlIGEgc2hhcGUgY29tcHJpc2VkIG9mIHBvc2l0aXZlIGludGVnZXJzIGJ1dCBnb3Qgc2hhcGUgW1wiK3QrXCJdLlwifSl9KX12YXIgWCxZPWZ1bmN0aW9uKCl7aWYobnVsbCE9YS5nbG9iYWwuZmV0Y2gpcmV0dXJuIGEuZ2xvYmFsLmZldGNoO2lmKGEuZ2V0KFwiSVNfTk9ERVwiKSlyZXR1cm4gUS5mZXRjaEltcG9ydCgpO3Rocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHRoZSBmZXRjaCgpIG1ldGhvZC4gUGxlYXNlIGFkZCB5b3VyIG93biBmZXRjaCgpIGZ1bmN0aW9uIHRvIHRoZSBnbG9iYWwgbmFtZXNwYWNlLlwiKX0sUT17ZmV0Y2hJbXBvcnQ6ZnVuY3Rpb24oKXtyZXR1cm4gcmVxdWlyZShcIm5vZGUtZmV0Y2hcIil9fTtmdW5jdGlvbiBKKHQsZSl7cmV0dXJuIG51bGw9PVgmJihYPVkoKSksWCh0LGUpfXZhciBaPU9iamVjdC5mcmVlemUoe3NodWZmbGU6YyxjbGFtcDpoLG5lYXJlc3RMYXJnZXJFdmVuOnAsc3VtOmYscmFuZFVuaWZvcm06ZnVuY3Rpb24odCxlKXt2YXIgbj1NYXRoLnJhbmRvbSgpO3JldHVybiBlKm4rKDEtbikqdH0sZGlzdFNxdWFyZWQ6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MCxyPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBvPU51bWJlcih0W3JdKS1OdW1iZXIoZVtyXSk7bis9bypvfXJldHVybiBufSxhc3NlcnQ6ZCxhc3NlcnRTaGFwZXNNYXRjaDp2LGFzc2VydE5vbk51bGw6bSxmbGF0dGVuOmcsc2l6ZUZyb21TaGFwZTp5LGlzU2NhbGFyU2hhcGU6ZnVuY3Rpb24odCl7cmV0dXJuIDA9PT10Lmxlbmd0aH0sYXJyYXlzRXF1YWw6eCxpc0ludDp3LHRhbmg6YixzaXplVG9TcXVhcmlzaFNoYXBlOkMsY3JlYXRlU2h1ZmZsZWRJbmRpY2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgVWludDMyQXJyYXkodCksbj0wO248dDsrK24pZVtuXT1uO3JldHVybiBjKGUpLGV9LHJpZ2h0UGFkOkUscmVwZWF0ZWRUcnk6UixpbmZlckZyb21JbXBsaWNpdFNoYXBlOlMscGFyc2VBeGlzUGFyYW06TixzcXVlZXplU2hhcGU6ayxnZXRUeXBlZEFycmF5RnJvbURUeXBlOkksZ2V0QXJyYXlGcm9tRFR5cGU6QSxjaGVja0NvbXB1dGF0aW9uRm9yRXJyb3JzOlQsY2hlY2tDb252ZXJzaW9uRm9yRXJyb3JzOkQsaGFzRW5jb2RpbmdMb3NzOk8saXNUeXBlZEFycmF5Ol8sYnl0ZXNQZXJFbGVtZW50Ok0sYnl0ZXNGcm9tU3RyaW5nQXJyYXk6Rixpc1N0cmluZzpCLGlzQm9vbGVhbjpQLGlzTnVtYmVyOkwsaW5mZXJEdHlwZTpXLGlzRnVuY3Rpb246VSxuZWFyZXN0RGl2aXNvcjp6LGNvbXB1dGVTdHJpZGVzOlYsdG9UeXBlZEFycmF5OkcsdG9OZXN0ZWRBcnJheTpxLG1ha2VPbmVzVHlwZWRBcnJheTpILG1ha2VaZXJvc1R5cGVkQXJyYXk6JCxub3c6aixhc3NlcnROb25OZWdhdGl2ZUludGVnZXJEaW1lbnNpb25zOkssZ2V0Tm9kZUZldGNoOlEsZ2V0IHN5c3RlbUZldGNoKCl7cmV0dXJuIFh9LGZldGNoOkp9KSx0dD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt0aGlzLmJhY2tlbmRUaW1lcj10LHRoaXMubG9nZ2VyPWUsbnVsbD09ZSYmKHRoaXMubG9nZ2VyPW5ldyBldCl9cmV0dXJuIHQucHJvdG90eXBlLnByb2ZpbGVLZXJuZWw9ZnVuY3Rpb24odCxlKXt2YXIgbixyPXRoaXMsbz10aGlzLmJhY2tlbmRUaW1lci50aW1lKGZ1bmN0aW9uKCl7bj1lKCl9KTtyZXR1cm4oQXJyYXkuaXNBcnJheShuKT9uOltuXSkuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgbj1lLmRhdGFTeW5jKCk7VChuLGUuZHR5cGUsdCksby50aGVuKGZ1bmN0aW9uKG8pe3ZhciBhPVwiXCI7bnVsbCE9by5nZXRFeHRyYVByb2ZpbGVJbmZvJiYoYT1vLmdldEV4dHJhUHJvZmlsZUluZm8oKSksci5sb2dnZXIubG9nS2VybmVsUHJvZmlsZSh0LGUsbixvLmtlcm5lbE1zLGEpfSl9KSxufSx0fSgpLGV0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUubG9nS2VybmVsUHJvZmlsZT1mdW5jdGlvbih0LGUsbixyLG8pe3ZhciBhPUUocitcIm1zXCIsOSksaT1FKHQsMjUpLHM9ZS5yYW5rLHU9ZS5zaXplLGw9RShlLnNoYXBlLnRvU3RyaW5nKCksMTQpO2NvbnNvbGUubG9nKFwiJWNcIitpK1wiXFx0JWNcIithK1wiXFx0JWNcIitzK1wiRCBcIitsK1wiXFx0JWNcIit1K1wiXFx0JWNcIitvLFwiZm9udC13ZWlnaHQ6Ym9sZFwiLFwiY29sb3I6cmVkXCIsXCJjb2xvcjpibHVlXCIsXCJjb2xvcjogb3JhbmdlXCIsXCJjb2xvcjogZ3JlZW5cIil9LHR9KCksbnQ9MjAscnQ9MyxvdD03O2Z1bmN0aW9uIGF0KHQsZSxuLHIpe3ZhciBvPVYoZSksYT1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz15KGUpLGE9cltyLmxlbmd0aC0xXSxpPW5ldyBBcnJheShhKS5maWxsKDApLHM9ZS5sZW5ndGgsdT1cImNvbXBsZXg2NFwiPT09bj91dCh0KTp0O2lmKHM+MSlmb3IodmFyIGw9MDtsPG8vYTtsKyspZm9yKHZhciBjPWwqYSxoPTA7aDxhO2grKylpW2hdPU1hdGgubWF4KGlbaF0saXQodVtjK2hdLDAsbikubGVuZ3RoKTtyZXR1cm4gaX0odCxlLG4sbyksaT1lLmxlbmd0aCxzPWZ1bmN0aW9uIHQoZSxuLHIsbyxhLGkpe3ZvaWQgMD09PWkmJihpPSEwKTt2YXIgcz1cImNvbXBsZXg2NFwiPT09cj8yOjE7dmFyIHU9blswXTt2YXIgbD1uLmxlbmd0aDtpZigwPT09bCl7aWYoXCJjb21wbGV4NjRcIj09PXIpe3ZhciBjPXV0KGUpO3JldHVybltpdChjWzBdLDAscildfXJldHVyblwiYm9vbFwiPT09cj9bc3QoZVswXSldOltlWzBdLnRvU3RyaW5nKCldfWlmKDE9PT1sKXtpZih1Pm50KXt2YXIgaD1ydCpzLHA9QXJyYXkuZnJvbShlLnNsaWNlKDAsaCkpLGY9QXJyYXkuZnJvbShlLnNsaWNlKHUtcnQqcyx1KSk7cmV0dXJuXCJjb21wbGV4NjRcIj09PXImJihwPXV0KHApLGY9dXQoZikpLFtcIltcIitwLm1hcChmdW5jdGlvbih0LGUpe3JldHVybiBpdCh0LGFbZV0scil9KS5qb2luKFwiLCBcIikrXCIsIC4uLiwgXCIrZi5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm4gaXQodCxhW3UtcnQrZV0scil9KS5qb2luKFwiLCBcIikrXCJdXCJdfXZhciBkPVwiY29tcGxleDY0XCI9PT1yP3V0KGUpOkFycmF5LmZyb20oZSk7cmV0dXJuW1wiW1wiK2QubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGl0KHQsYVtlXSxyKX0pLmpvaW4oXCIsIFwiKStcIl1cIl19dmFyIHY9bi5zbGljZSgxKTt2YXIgbT1vLnNsaWNlKDEpO3ZhciBnPW9bMF0qczt2YXIgeT1bXTtpZih1Pm50KXtmb3IodmFyIHg9MDt4PHJ0O3grKyl7dmFyIHc9eCpnLGI9dytnO3kucHVzaC5hcHBseSh5LHQoZS5zbGljZSh3LGIpLHYscixtLGEsITEpKX15LnB1c2goXCIuLi5cIik7Zm9yKHZhciB4PXUtcnQ7eDx1O3grKyl7dmFyIHc9eCpnLGI9dytnO3kucHVzaC5hcHBseSh5LHQoZS5zbGljZSh3LGIpLHYscixtLGEseD09PXUtMSkpfX1lbHNlIGZvcih2YXIgeD0wO3g8dTt4Kyspe3ZhciB3PXgqZyxiPXcrZzt5LnB1c2guYXBwbHkoeSx0KGUuc2xpY2UodyxiKSx2LHIsbSxhLHg9PT11LTEpKX12YXIgQz0yPT09bD9cIixcIjpcIlwiO3lbMF09XCJbXCIreVswXStDO2Zvcih2YXIgeD0xO3g8eS5sZW5ndGgtMTt4KyspeVt4XT1cIiBcIit5W3hdK0M7dmFyIEU9XCIsXFxuXCI7Zm9yKHZhciB4PTI7eDxsO3grKylFKz1cIlxcblwiO3lbeS5sZW5ndGgtMV09XCIgXCIreVt5Lmxlbmd0aC0xXStcIl1cIisoaT9cIlwiOkUpO3JldHVybiB5fSh0LGUsbixvLGEpLHU9W1wiVGVuc29yXCJdO3JldHVybiByJiYodS5wdXNoKFwiICBkdHlwZTogXCIrbiksdS5wdXNoKFwiICByYW5rOiBcIitpKSx1LnB1c2goXCIgIHNoYXBlOiBbXCIrZStcIl1cIiksdS5wdXNoKFwiICB2YWx1ZXM6XCIpKSx1LnB1c2gocy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCIgICAgXCIrdH0pLmpvaW4oXCJcXG5cIikpLHUuam9pbihcIlxcblwiKX1mdW5jdGlvbiBpdCh0LGUsbil7cmV0dXJuIEUoQXJyYXkuaXNBcnJheSh0KT9wYXJzZUZsb2F0KHRbMF0udG9GaXhlZChvdCkpK1wiICsgXCIrcGFyc2VGbG9hdCh0WzFdLnRvRml4ZWQob3QpKStcImpcIjpCKHQpP1wiJ1wiK3QrXCInXCI6XCJib29sXCI9PT1uP3N0KHQpOnBhcnNlRmxvYXQodC50b0ZpeGVkKG90KSkudG9TdHJpbmcoKSxlKX1mdW5jdGlvbiBzdCh0KXtyZXR1cm4gMD09PXQ/XCJmYWxzZVwiOlwidHJ1ZVwifWZ1bmN0aW9uIHV0KHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDtuKz0yKWUucHVzaChbdFtuXSx0W24rMV1dKTtyZXR1cm4gZX12YXIgbHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxuKXt2YXIgcj10aGlzO2lmKHRoaXMuZHR5cGU9ZSx0aGlzLnNoYXBlPXQuc2xpY2UoKSx0aGlzLnNpemU9eSh0KSxudWxsIT1uKXt2YXIgbz1uLmxlbmd0aDtkKG89PT10aGlzLnNpemUsZnVuY3Rpb24oKXtyZXR1cm5cIkxlbmd0aCBvZiB2YWx1ZXMgJ1wiK28rXCInIGRvZXMgbm90IG1hdGNoIHRoZSBzaXplIGluZmVycmVkIGJ5IHRoZSBzaGFwZSAnXCIrci5zaXplK1wiJy5cIn0pfWlmKFwiY29tcGxleDY0XCI9PT1lKXRocm93IG5ldyBFcnJvcihcImNvbXBsZXg2NCBkdHlwZSBUZW5zb3JCdWZmZXJzIGFyZSBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgY3JlYXRlIGEgVGVuc29yQnVmZmVyIGZvciB0aGUgcmVhbCBhbmQgaW1hZ2luYXJ5IHBhcnRzIHNlcGFyYXRlbHkgYW5kIGNhbGwgdGYuY29tcGxleChyZWFsLCBpbWFnKS5cIik7dGhpcy52YWx1ZXM9bnx8QShlLHRoaXMuc2l6ZSksdGhpcy5zdHJpZGVzPVYodCl9cmV0dXJuIHQucHJvdG90eXBlLnNldD1mdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcyxuPVtdLHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKW5bci0xXT1hcmd1bWVudHNbcl07MD09PW4ubGVuZ3RoJiYobj1bMF0pLGQobi5sZW5ndGg9PT10aGlzLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBudW1iZXIgb2YgcHJvdmlkZWQgY29vcmRpbmF0ZXMgKFwiK24ubGVuZ3RoK1wiKSBtdXN0IG1hdGNoIHRoZSByYW5rIChcIitlLnJhbmsrXCIpXCJ9KTt2YXIgbz10aGlzLmxvY1RvSW5kZXgobik7dGhpcy52YWx1ZXNbb109dH0sdC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXRbZV09YXJndW1lbnRzW2VdOzA9PT10Lmxlbmd0aCYmKHQ9WzBdKTtmb3IodmFyIG49MCxyPTAsbz10O3I8by5sZW5ndGg7cisrKXt2YXIgYT1vW3JdO2lmKGE8MHx8YT49dGhpcy5zaGFwZVtuXSl7dmFyIGk9XCJSZXF1ZXN0ZWQgb3V0IG9mIHJhbmdlIGVsZW1lbnQgYXQgXCIrdCtcIi4gICBCdWZmZXIgc2hhcGU9XCIrdGhpcy5zaGFwZTt0aHJvdyBuZXcgRXJyb3IoaSl9bisrfWZvcih2YXIgcz10W3QubGVuZ3RoLTFdLHU9MDt1PHQubGVuZ3RoLTE7Kyt1KXMrPXRoaXMuc3RyaWRlc1t1XSp0W3VdO3JldHVybiB0aGlzLnZhbHVlc1tzXX0sdC5wcm90b3R5cGUubG9jVG9JbmRleD1mdW5jdGlvbih0KXtpZigwPT09dGhpcy5yYW5rKXJldHVybiAwO2lmKDE9PT10aGlzLnJhbmspcmV0dXJuIHRbMF07Zm9yKHZhciBlPXRbdC5sZW5ndGgtMV0sbj0wO248dC5sZW5ndGgtMTsrK24pZSs9dGhpcy5zdHJpZGVzW25dKnRbbl07cmV0dXJuIGV9LHQucHJvdG90eXBlLmluZGV4VG9Mb2M9ZnVuY3Rpb24odCl7aWYoMD09PXRoaXMucmFuaylyZXR1cm5bXTtpZigxPT09dGhpcy5yYW5rKXJldHVyblt0XTtmb3IodmFyIGU9bmV3IEFycmF5KHRoaXMuc2hhcGUubGVuZ3RoKSxuPTA7bjxlLmxlbmd0aC0xOysrbillW25dPU1hdGguZmxvb3IodC90aGlzLnN0cmlkZXNbbl0pLHQtPWVbbl0qdGhpcy5zdHJpZGVzW25dO3JldHVybiBlW2UubGVuZ3RoLTFdPXQsZX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmFua1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGFwZS5sZW5ndGh9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUudG9UZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4gZnQubWFrZSh0aGlzLnNoYXBlLHt2YWx1ZXM6dGhpcy52YWx1ZXN9LHRoaXMuZHR5cGUpfSx0fSgpLGN0PW51bGwsaHQ9bnVsbCxwdD1udWxsO3ZhciBmdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLG4scixvKXt0aGlzLmtlcHQ9ITEsdGhpcy5pc0Rpc3Bvc2VkSW50ZXJuYWw9ITEsdGhpcy5zaGFwZT10LnNsaWNlKCksdGhpcy5kdHlwZT1lfHxcImZsb2F0MzJcIix0aGlzLnNpemU9eSh0KSx0aGlzLnN0cmlkZXM9Vih0KSx0aGlzLmRhdGFJZD1udWxsIT1yP3I6e30sdGhpcy5pZD1jdCgpLm5leHRUZW5zb3JJZCgpLHRoaXMucmFua1R5cGU9dGhpcy5yYW5rPDU/dGhpcy5yYW5rLnRvU3RyaW5nKCk6XCJoaWdoZXJcIixjdCgpLnJlZ2lzdGVyVGVuc29yKHRoaXMsbyksbnVsbCE9biYmY3QoKS53cml0ZSh0aGlzLmRhdGFJZCxuKX1yZXR1cm4gdC5tYWtlPWZ1bmN0aW9uKGUsbixyLG8pe3JldHVybiBuZXcgdChlLHIsbi52YWx1ZXMsbi5kYXRhSWQsbyl9LHQucHJvdG90eXBlLmZsYXR0ZW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLmFzMUQoKX0sdC5wcm90b3R5cGUuYXNTY2FsYXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxkKDE9PT10aGlzLnNpemUsZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBhcnJheSBtdXN0IGhhdmUgb25seSAxIGVsZW1lbnQuXCJ9KSx0aGlzLnJlc2hhcGUoW10pfSx0LnByb3RvdHlwZS5hczFEPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5yZXNoYXBlKFt0aGlzLnNpemVdKX0sdC5wcm90b3R5cGUuYXMyRD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMucmVzaGFwZShbdCxlXSl9LHQucHJvdG90eXBlLmFzM0Q9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMucmVzaGFwZShbdCxlLG5dKX0sdC5wcm90b3R5cGUuYXM0RD1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnJlc2hhcGUoW3QsZSxuLHJdKX0sdC5wcm90b3R5cGUuYXM1RD1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMucmVzaGFwZShbdCxlLG4scixvXSl9LHQucHJvdG90eXBlLmFzVHlwZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5jYXN0KHRoaXMsdCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJhbmtcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2hhcGUubGVuZ3RofSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmJ1ZmZlcj1mdW5jdGlvbigpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0O3JldHVybiBvKHRoaXMsZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLmRhdGEoKV07Y2FzZSAxOnJldHVybiB0PWUuc2VudCgpLFsyLGh0LmJ1ZmZlcih0aGlzLnNoYXBlLHRoaXMuZHR5cGUsdCldfX0pfSl9LHQucHJvdG90eXBlLmJ1ZmZlclN5bmM9ZnVuY3Rpb24oKXtyZXR1cm4gaHQuYnVmZmVyKHRoaXMuc2hhcGUsdGhpcy5kdHlwZSx0aGlzLmRhdGFTeW5jKCkpfSx0LnByb3RvdHlwZS5hcnJheT1mdW5jdGlvbigpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0O3JldHVybiBvKHRoaXMsZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLmRhdGEoKV07Y2FzZSAxOnJldHVybiB0PWUuc2VudCgpLFsyLHEodGhpcy5zaGFwZSx0KV19fSl9KX0sdC5wcm90b3R5cGUuYXJyYXlTeW5jPWZ1bmN0aW9uKCl7cmV0dXJuIHEodGhpcy5zaGFwZSx0aGlzLmRhdGFTeW5jKCkpfSx0LnByb3RvdHlwZS5kYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIG8odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxbMixjdCgpLnJlYWQodGhpcy5kYXRhSWQpXX0pfSl9LHQucHJvdG90eXBlLmRhdGFTeW5jPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksY3QoKS5yZWFkU3luYyh0aGlzLmRhdGFJZCl9LHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLmlzRGlzcG9zZWR8fChjdCgpLmRpc3Bvc2VUZW5zb3IodGhpcyksdGhpcy5pc0Rpc3Bvc2VkSW50ZXJuYWw9ITApfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJpc0Rpc3Bvc2VkXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRGlzcG9zZWRJbnRlcm5hbH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS50aHJvd0lmRGlzcG9zZWQ9ZnVuY3Rpb24oKXtpZih0aGlzLmlzRGlzcG9zZWQpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIGlzIGRpc3Bvc2VkLlwiKX0sdC5wcm90b3R5cGUudG9GbG9hdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFzVHlwZShcImZsb2F0MzJcIil9LHQucHJvdG90eXBlLnRvSW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXNUeXBlKFwiaW50MzJcIil9LHQucHJvdG90eXBlLnRvQm9vbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFzVHlwZShcImJvb2xcIil9LHQucHJvdG90eXBlLnByaW50PWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0hMSksaHQucHJpbnQodGhpcyx0KX0sdC5wcm90b3R5cGUucmVzaGFwZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5yZXNoYXBlKHRoaXMsdCl9LHQucHJvdG90eXBlLnJlc2hhcGVBcz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnJlc2hhcGUodC5zaGFwZSl9LHQucHJvdG90eXBlLmV4cGFuZERpbXM9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLGh0LmV4cGFuZERpbXModGhpcyx0KX0sdC5wcm90b3R5cGUuY3Vtc3VtPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksdm9pZCAwPT09ZSYmKGU9ITEpLHZvaWQgMD09PW4mJihuPSExKSxodC5jdW1zdW0odGhpcyx0LGUsbil9LHQucHJvdG90eXBlLnNxdWVlemU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc3F1ZWV6ZSh0aGlzLHQpfSx0LnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmNsb25lKHRoaXMpfSx0LnByb3RvdHlwZS5vbmVIb3Q9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lm9uZUhvdCh0aGlzLHQsZSxuKX0sdC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PSExKSxhdCh0aGlzLmRhdGFTeW5jKCksdGhpcy5zaGFwZSx0aGlzLmR0eXBlLHQpfSx0LnByb3RvdHlwZS50aWxlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnRpbGUodGhpcyx0KX0sdC5wcm90b3R5cGUuZ2F0aGVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuZ2F0aGVyKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUubWF0TXVsPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITEpLHZvaWQgMD09PW4mJihuPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lm1hdE11bCh0aGlzLHQsZSxuKX0sdC5wcm90b3R5cGUuZG90PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmRvdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5ub3JtPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9XCJldWNsaWRlYW5cIiksdm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubm9ybSh0aGlzLHQsZSxuKX0sdC5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zbGljZSh0aGlzLHQsZSl9LHQucHJvdG90eXBlLnJldmVyc2U9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQucmV2ZXJzZSh0aGlzLHQpfSx0LnByb3RvdHlwZS5jb25jYXQ9ZnVuY3Rpb24oZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxlIGluc3RhbmNlb2YgdCYmKGU9W2VdKSxodC5jb25jYXQoW3RoaXNdLmNvbmNhdChlKSxuKX0sdC5wcm90b3R5cGUuc3BsaXQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9MCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zcGxpdCh0aGlzLHQsZSl9LHQucHJvdG90eXBlLnN0YWNrPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTApLGh0LnN0YWNrKFt0aGlzLHRdLGUpfSx0LnByb3RvdHlwZS51bnN0YWNrPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSxodC51bnN0YWNrKHRoaXMsdCl9LHQucHJvdG90eXBlLnBhZD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0wKSxodC5wYWQodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb249ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gdm9pZCAwPT09biYmKG49LjAwMSkscHQoXCJ0Zi5iYXRjaE5vcm1hbGl6YXRpb24oKSBpcyBnb2luZyBhd2F5LiBVc2UgdGYuYmF0Y2hOb3JtKCkgaW5zdGVhZCwgYW5kIG5vdGUgdGhlIHBvc2l0aW9uYWwgYXJndW1lbnQgY2hhbmdlIG9mIHNjYWxlLCBvZmZzZXQsIGFuZCB2YXJpYW5jZUVwc2lsb25cIiksdGhpcy5iYXRjaE5vcm0odCxlLG8scixuKX0sdC5wcm90b3R5cGUuYmF0Y2hOb3JtPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIHZvaWQgMD09PW8mJihvPS4wMDEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuYmF0Y2hOb3JtKHRoaXMsdCxlLG4scixvKX0sdC5wcm90b3R5cGUuYWxsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmFsbCh0aGlzLHQsZSl9LHQucHJvdG90eXBlLmFueT1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5hbnkodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5sb2dTdW1FeHA9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubG9nU3VtRXhwKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuc3VtPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnN1bSh0aGlzLHQsZSl9LHQucHJvdG90eXBlLnByb2Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQucHJvZCh0aGlzLHQsZSl9LHQucHJvdG90eXBlLm1lYW49ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubWVhbih0aGlzLHQsZSl9LHQucHJvdG90eXBlLm1pbj1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5taW4odGhpcyx0LGUpfSx0LnByb3RvdHlwZS5tYXg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubWF4KHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuYXJnTWluPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmFyZ01pbih0aGlzLHQpfSx0LnByb3RvdHlwZS5hcmdNYXg9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuYXJnTWF4KHRoaXMsdCl9LHQucHJvdG90eXBlLmNhc3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuY2FzdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuYWRkKHRoaXMsdCl9LHQucHJvdG90eXBlLmFkZFN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5hZGRTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUuYXRhbjI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuYXRhbjIodGhpcyx0KX0sdC5wcm90b3R5cGUuc3ViPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnN1Yih0aGlzLHQpfSx0LnByb3RvdHlwZS5zdWJTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc3ViU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLnBvdz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5wb3codGhpcyx0KX0sdC5wcm90b3R5cGUucG93U3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnBvd1N0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5tdWw9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubXVsKHRoaXMsdCl9LHQucHJvdG90eXBlLm11bFN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5tdWxTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUuZGl2PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmRpdih0aGlzLHQpfSx0LnByb3RvdHlwZS5mbG9vckRpdj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5mbG9vckRpdih0aGlzLHQpfSx0LnByb3RvdHlwZS5kaXZTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuZGl2U3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLm1pbmltdW09ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubWluaW11bSh0aGlzLHQpfSx0LnByb3RvdHlwZS5taW5pbXVtU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lm1pbmltdW1TdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUubWF4aW11bT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5tYXhpbXVtKHRoaXMsdCl9LHQucHJvdG90eXBlLm1heGltdW1TdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubWF4aW11bVN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5tb2Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubW9kKHRoaXMsdCl9LHQucHJvdG90eXBlLm1vZFN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5tb2RTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUuc3F1YXJlZERpZmZlcmVuY2U9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc3F1YXJlZERpZmZlcmVuY2UodGhpcyx0KX0sdC5wcm90b3R5cGUuc3F1YXJlZERpZmZlcmVuY2VTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc3F1YXJlZERpZmZlcmVuY2VTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUudHJhbnNwb3NlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnRyYW5zcG9zZSh0aGlzLHQpfSx0LnByb3RvdHlwZS5ub3RFcXVhbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5ub3RFcXVhbCh0aGlzLHQpfSx0LnByb3RvdHlwZS5ub3RFcXVhbFN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5ub3RFcXVhbFN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5sZXNzPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lmxlc3ModGhpcyx0KX0sdC5wcm90b3R5cGUubGVzc1N0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5sZXNzU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmVxdWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmVxdWFsKHRoaXMsdCl9LHQucHJvdG90eXBlLmVxdWFsU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmVxdWFsU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmxlc3NFcXVhbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5sZXNzRXF1YWwodGhpcyx0KX0sdC5wcm90b3R5cGUubGVzc0VxdWFsU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0Lmxlc3NFcXVhbFN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5ncmVhdGVyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmdyZWF0ZXIodGhpcyx0KX0sdC5wcm90b3R5cGUuZ3JlYXRlclN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5ncmVhdGVyU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmdyZWF0ZXJFcXVhbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5ncmVhdGVyRXF1YWwodGhpcyx0KX0sdC5wcm90b3R5cGUuZ3JlYXRlckVxdWFsU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmdyZWF0ZXJFcXVhbFN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5sb2dpY2FsQW5kPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmxvZ2ljYWxBbmQodGhpcyx0KX0sdC5wcm90b3R5cGUubG9naWNhbE9yPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmxvZ2ljYWxPcih0aGlzLHQpfSx0LnByb3RvdHlwZS5sb2dpY2FsTm90PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubG9naWNhbE5vdCh0aGlzKX0sdC5wcm90b3R5cGUubG9naWNhbFhvcj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5sb2dpY2FsWG9yKHRoaXMsdCl9LHQucHJvdG90eXBlLndoZXJlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQud2hlcmUodCx0aGlzLGUpfSx0LnByb3RvdHlwZS5uZWc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5uZWcodGhpcyl9LHQucHJvdG90eXBlLmNlaWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5jZWlsKHRoaXMpfSx0LnByb3RvdHlwZS5mbG9vcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmZsb29yKHRoaXMpfSx0LnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc2lnbih0aGlzKX0sdC5wcm90b3R5cGUuaXNOYU49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5pc05hTih0aGlzKX0sdC5wcm90b3R5cGUuaXNJbmY9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5pc0luZih0aGlzKX0sdC5wcm90b3R5cGUuaXNGaW5pdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5pc0Zpbml0ZSh0aGlzKX0sdC5wcm90b3R5cGUuZXhwPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuZXhwKHRoaXMpfSx0LnByb3RvdHlwZS5leHBtMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmV4cG0xKHRoaXMpfSx0LnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5sb2codGhpcyl9LHQucHJvdG90eXBlLmxvZzFwPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubG9nMXAodGhpcyl9LHQucHJvdG90eXBlLnNxcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zcXJ0KHRoaXMpfSx0LnByb3RvdHlwZS5yc3FydD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnJzcXJ0KHRoaXMpfSx0LnByb3RvdHlwZS5zcXVhcmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zcXVhcmUodGhpcyl9LHQucHJvdG90eXBlLnJlY2lwcm9jYWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5yZWNpcHJvY2FsKHRoaXMpfSx0LnByb3RvdHlwZS5hYnM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5hYnModGhpcyl9LHQucHJvdG90eXBlLmNsaXBCeVZhbHVlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuY2xpcEJ5VmFsdWUodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5yZWx1PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQucmVsdSh0aGlzKX0sdC5wcm90b3R5cGUuZWx1PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuZWx1KHRoaXMpfSx0LnByb3RvdHlwZS5zZWx1PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc2VsdSh0aGlzKX0sdC5wcm90b3R5cGUubGVha3lSZWx1PWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0uMiksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5sZWFreVJlbHUodGhpcyx0KX0sdC5wcm90b3R5cGUucHJlbHU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQucHJlbHUodGhpcyx0KX0sdC5wcm90b3R5cGUuc2lnbW9pZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnNpZ21vaWQodGhpcyl9LHQucHJvdG90eXBlLmxvZ1NpZ21vaWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5sb2dTaWdtb2lkKHRoaXMpfSx0LnByb3RvdHlwZS5zb2Z0cGx1cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnNvZnRwbHVzKHRoaXMpfSx0LnByb3RvdHlwZS56ZXJvc0xpa2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC56ZXJvc0xpa2UodGhpcyl9LHQucHJvdG90eXBlLm9uZXNMaWtlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQub25lc0xpa2UodGhpcyl9LHQucHJvdG90eXBlLnNpbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnNpbih0aGlzKX0sdC5wcm90b3R5cGUuY29zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuY29zKHRoaXMpfSx0LnByb3RvdHlwZS50YW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC50YW4odGhpcyl9LHQucHJvdG90eXBlLmFzaW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5hc2luKHRoaXMpfSx0LnByb3RvdHlwZS5hY29zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuYWNvcyh0aGlzKX0sdC5wcm90b3R5cGUuYXRhbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmF0YW4odGhpcyl9LHQucHJvdG90eXBlLnNpbmg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zaW5oKHRoaXMpfSx0LnByb3RvdHlwZS5jb3NoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuY29zaCh0aGlzKX0sdC5wcm90b3R5cGUudGFuaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnRhbmgodGhpcyl9LHQucHJvdG90eXBlLmFzaW5oPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuYXNpbmgodGhpcyl9LHQucHJvdG90eXBlLmFjb3NoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuYWNvc2godGhpcyl9LHQucHJvdG90eXBlLmF0YW5oPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuYXRhbmgodGhpcyl9LHQucHJvdG90eXBlLmVyZj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmVyZih0aGlzKX0sdC5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5yb3VuZCh0aGlzKX0sdC5wcm90b3R5cGUuc3RlcD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zdGVwKHRoaXMsdCl9LHQucHJvdG90eXBlLnNvZnRtYXg9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PS0xKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnNvZnRtYXgodGhpcyx0KX0sdC5wcm90b3R5cGUubG9nU29mdG1heD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9LTEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubG9nU29mdG1heCh0aGlzLHQpfSx0LnByb3RvdHlwZS5yZXNpemVCaWxpbmVhcj1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5pbWFnZS5yZXNpemVCaWxpbmVhcih0aGlzLHQsZSl9LHQucHJvdG90eXBlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvcj1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5pbWFnZS5yZXNpemVOZWFyZXN0TmVpZ2hib3IodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5jb252MWQ9ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB2b2lkIDA9PT1yJiYocj1cIk5XQ1wiKSx2b2lkIDA9PT1vJiYobz0xKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmNvbnYxZCh0aGlzLHQsZSxuLHIsbyxhKX0sdC5wcm90b3R5cGUuY29udjJkPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9XCJOSFdDXCIpLHZvaWQgMD09PW8mJihvPVsxLDFdKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmNvbnYyZCh0aGlzLHQsZSxuLHIsbyxhKX0sdC5wcm90b3R5cGUuY29udjJkVHJhbnNwb3NlPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuY29udjJkVHJhbnNwb3NlKHRoaXMsdCxlLG4scixvKX0sdC5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJEPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9XCJOSFdDXCIpLHZvaWQgMD09PW8mJihvPVsxLDFdKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LmRlcHRod2lzZUNvbnYyZCh0aGlzLHQsZSxuLHIsbyxhKX0sdC5wcm90b3R5cGUuc2VwYXJhYmxlQ29udjJkPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gdm9pZCAwPT09byYmKG89WzEsMV0pLHZvaWQgMD09PWEmJihhPVwiTkhXQ1wiKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnNlcGFyYWJsZUNvbnYyZCh0aGlzLHQsZSxuLHIsbyxhKX0sdC5wcm90b3R5cGUuYXZnUG9vbD1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5hdmdQb29sKHRoaXMsdCxlLG4scil9LHQucHJvdG90eXBlLm1heFBvb2w9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQubWF4UG9vbCh0aGlzLHQsZSxuLHIpfSx0LnByb3RvdHlwZS5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbj1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9NSksdm9pZCAwPT09ZSYmKGU9MSksdm9pZCAwPT09biYmKG49MSksdm9pZCAwPT09ciYmKHI9LjUpLGh0LmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uKHRoaXMsdCxlLG4scil9LHQucHJvdG90eXBlLnBvb2w9ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5wb29sKHRoaXMsdCxlLG4scixvKX0sdC5wcm90b3R5cGUudmFyaWFibGU9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT10JiYodD0hMCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxkdC52YXJpYWJsZSh0aGlzLHQsZSxuKX0sdC5wcm90b3R5cGUudW5zb3J0ZWRTZWdtZW50U3VtPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQudW5zb3J0ZWRTZWdtZW50U3VtKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuYmF0Y2hUb1NwYWNlTkQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5iYXRjaFRvU3BhY2VORCh0aGlzLHQsZSl9LHQucHJvdG90eXBlLnNwYWNlVG9CYXRjaE5EPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc3BhY2VUb0JhdGNoTkQodGhpcyx0LGUpfSx0LnByb3RvdHlwZS50b3BrPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PTEpLHZvaWQgMD09PWUmJihlPSEwKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh0LnRvcGsodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5zdHJpZGVkU2xpY2U9ZnVuY3Rpb24odCxlLG4scixvLGEsaSxzKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9MCksdm9pZCAwPT09byYmKG89MCksdm9pZCAwPT09YSYmKGE9MCksdm9pZCAwPT09aSYmKGk9MCksdm9pZCAwPT09cyYmKHM9MCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zdHJpZGVkU2xpY2UodGhpcyx0LGUsbixyLG8sYSxpLHMpfSx0LnByb3RvdHlwZS5kZXB0aFRvU3BhY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5kZXB0aFRvU3BhY2UodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5mZnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zcGVjdHJhbC5mZnQodGhpcyl9LHQucHJvdG90eXBlLmlmZnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zcGVjdHJhbC5pZmZ0KHRoaXMpfSx0LnByb3RvdHlwZS5yZmZ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaHQuc3BlY3RyYWwucmZmdCh0aGlzKX0sdC5wcm90b3R5cGUuaXJmZnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodC5zcGVjdHJhbC5pcmZmdCh0aGlzKX0sdH0oKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZnQsU3ltYm9sLmhhc0luc3RhbmNlLHt2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4hIXQmJm51bGwhPXQuZGF0YUlkJiZudWxsIT10LnNoYXBlJiZudWxsIT10LmR0eXBlfX0pO3ZhciBkdD1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKGUsbixyKXt2b2lkIDA9PT1uJiYobj0hMCk7dmFyIG89dC5jYWxsKHRoaXMsZS5zaGFwZSxlLmR0eXBlLG51bGwsZS5kYXRhSWQpfHx0aGlzO28udHJhaW5hYmxlPW4sby5uYW1lPXIsbnVsbD09by5uYW1lJiYoby5uYW1lPWN0KCkubmV4dFZhcmlhYmxlSWQoKS50b1N0cmluZygpKTt0cnl7Y3QoKS5yZWdpc3RlclZhcmlhYmxlKG8pfWNhdGNoKHQpe3Rocm93IGN0KCkuZGlzcG9zZVRlbnNvcihvKSx0fXJldHVybiBvfXJldHVybiBlKG4sdCksbi52YXJpYWJsZT1mdW5jdGlvbih0LGUscixvKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITApLG51bGwhPW8mJm8hPT10LmR0eXBlJiYodD10LmFzVHlwZShvKSksbmV3IG4odCxlLHIpfSxuLnByb3RvdHlwZS5hc3NpZ249ZnVuY3Rpb24odCl7aWYodC5kdHlwZSE9PXRoaXMuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiZHR5cGUgb2YgdGhlIG5ldyB2YWx1ZSAoXCIrdC5kdHlwZStcIikgYW5kIHByZXZpb3VzIHZhbHVlIChcIit0aGlzLmR0eXBlK1wiKSBtdXN0IG1hdGNoXCIpO2lmKCF4KHQuc2hhcGUsdGhpcy5zaGFwZSkpdGhyb3cgbmV3IEVycm9yKFwic2hhcGUgb2YgdGhlIG5ldyB2YWx1ZSAoXCIrdC5zaGFwZStcIikgYW5kIHByZXZpb3VzIHZhbHVlIChcIit0aGlzLnNoYXBlK1wiKSBtdXN0IG1hdGNoXCIpO2N0KCkuZGlzcG9zZVRlbnNvcih0aGlzKSx0aGlzLmRhdGFJZD10LmRhdGFJZCxjdCgpLnJlZ2lzdGVyVGVuc29yKHRoaXMpfSxufShmdCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGR0LFN5bWJvbC5oYXNJbnN0YW5jZSx7dmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBmdCYmbnVsbCE9dC5hc3NpZ24mJnQuYXNzaWduIGluc3RhbmNlb2YgRnVuY3Rpb259fSk7dmFyIHZ0LG10LGd0LHl0LHh0LHd0PWR0LnZhcmlhYmxlOyFmdW5jdGlvbih0KXt0LlIwPVwiUjBcIix0LlIxPVwiUjFcIix0LlIyPVwiUjJcIix0LlIzPVwiUjNcIix0LlI0PVwiUjRcIix0LlI1PVwiUjVcIix0LlI2PVwiUjZcIn0odnR8fCh2dD17fSkpLGZ1bmN0aW9uKHQpe3QuZmxvYXQzMj1cImZsb2F0MzJcIix0LmludDMyPVwiaW50MzJcIix0LmJvb2w9XCJpbnQzMlwiLHQuY29tcGxleDY0PVwiY29tcGxleDY0XCJ9KG10fHwobXQ9e30pKSxmdW5jdGlvbih0KXt0LmZsb2F0MzI9XCJmbG9hdDMyXCIsdC5pbnQzMj1cImludDMyXCIsdC5ib29sPVwiYm9vbFwiLHQuY29tcGxleDY0PVwiY29tcGxleDY0XCJ9KGd0fHwoZ3Q9e30pKSxmdW5jdGlvbih0KXt0LmZsb2F0MzI9XCJmbG9hdDMyXCIsdC5pbnQzMj1cImZsb2F0MzJcIix0LmJvb2w9XCJmbG9hdDMyXCIsdC5jb21wbGV4NjQ9XCJjb21wbGV4NjRcIn0oeXR8fCh5dD17fSkpLGZ1bmN0aW9uKHQpe3QuZmxvYXQzMj1cImNvbXBsZXg2NFwiLHQuaW50MzI9XCJjb21wbGV4NjRcIix0LmJvb2w9XCJjb21wbGV4NjRcIix0LmNvbXBsZXg2ND1cImNvbXBsZXg2NFwifSh4dHx8KHh0PXt9KSk7dmFyIGJ0PXtmbG9hdDMyOnl0LGludDMyOm10LGJvb2w6Z3QsY29tcGxleDY0Onh0fTtmdW5jdGlvbiBDdCh0LGUpe2lmKFwic3RyaW5nXCI9PT10fHxcInN0cmluZ1wiPT09ZSl7aWYoXCJzdHJpbmdcIj09PXQmJlwic3RyaW5nXCI9PT1lKXJldHVyblwic3RyaW5nXCI7dGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCB1cGNhc3QgXCIrdCtcIiB3aXRoIFwiK2UpfXJldHVybiBidFt0XVtlXX1mdW5jdGlvbiBFdCh0KXtyZXR1cm4gQ3QodCxcImludDMyXCIpfWZ1bmN0aW9uIFJ0KHQsZSl7aWYodC5kdHlwZT09PWUuZHR5cGUpcmV0dXJuW3QsZV07dmFyIG49Q3QodC5kdHlwZSxlLmR0eXBlKTtyZXR1cm5bdC5jYXN0KG4pLGUuY2FzdChuKV19ZnVuY3Rpb24gU3QodCxlKXtkKHQuZHR5cGU9PT1lLmR0eXBlLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZHR5cGVzIG9mIHRoZSBmaXJzdChcIit0LmR0eXBlK1wiKSBhbmQgc2Vjb25kKFwiK2UuZHR5cGUrXCIpIGlucHV0IG11c3QgbWF0Y2hcIn0pfWZ1bmN0aW9uIE50KHQpe3ZhciBlPVtdO3JldHVybiBmdW5jdGlvbiB0KGUsbixyKXtpZihudWxsPT1lKXJldHVybjtpZihlIGluc3RhbmNlb2YgZnQpcmV0dXJuIHZvaWQgbi5wdXNoKGUpO2lmKG89ZSwhQXJyYXkuaXNBcnJheShvKSYmXCJvYmplY3RcIiE9dHlwZW9mIG8pcmV0dXJuO3ZhciBvO3ZhciBhPWU7Zm9yKHZhciBpIGluIGEpe3ZhciBzPWFbaV07ci5oYXMocyl8fChyLmFkZChzKSx0KHMsbixyKSl9fSh0LGUsbmV3IFNldCksZX12YXIga3QsSXQ9T2JqZWN0LmZyZWV6ZSh7bWFrZVR5cGVzTWF0Y2g6UnQsYXNzZXJ0VHlwZXNNYXRjaDpTdCxpc1RlbnNvckluTGlzdDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKWlmKGVbbl0uaWQ9PT10LmlkKXJldHVybiEwO3JldHVybiExfSxnZXRUZW5zb3JzSW5Db250YWluZXI6TnR9KSxBdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXM9e30sdGhpcy5uZXh0VGFwZU5vZGVJZD0wLHRoaXMubnVtQnl0ZXM9MCx0aGlzLm51bVRlbnNvcnM9MCx0aGlzLm51bVN0cmluZ1RlbnNvcnM9MCx0aGlzLm51bURhdGFCdWZmZXJzPTAsdGhpcy5ncmFkaWVudERlcHRoPTAsdGhpcy5rZXJuZWxEZXB0aD0wLHRoaXMuc2NvcGVTdGFjaz1bXSx0aGlzLm5leHRTY29wZUlkPTAsdGhpcy50ZW5zb3JJbmZvPW5ldyBXZWFrTWFwLHRoaXMucHJvZmlsaW5nPSExLHRoaXMuYWN0aXZlUHJvZmlsZT17bmV3Qnl0ZXM6MCxuZXdUZW5zb3JzOjAscGVha0J5dGVzOjAsa2VybmVsczpbXSxyZXN1bHQ6bnVsbH19cmV0dXJuIHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy5yZWdpc3RlcmVkVmFyaWFibGVzKXRoaXMucmVnaXN0ZXJlZFZhcmlhYmxlc1t0XS5kaXNwb3NlKCl9LHR9KCksVHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuRU5WPXQsdGhpcy5yZWdpc3RyeT17fSx0aGlzLnJlZ2lzdHJ5RmFjdG9yeT17fSx0aGlzLnN0YXRlPW5ldyBBdH1yZXR1cm4gdC5wcm90b3R5cGUucmVhZHk9ZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlLG47cmV0dXJuIG8odGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOmlmKG51bGwhPXRoaXMucGVuZGluZ0JhY2tlbmRJbml0KXJldHVyblsyLHRoaXMucGVuZGluZ0JhY2tlbmRJbml0LnRoZW4oZnVuY3Rpb24oKXt9KV07aWYobnVsbCE9dGhpcy5iYWNrZW5kSW5zdGFuY2UpcmV0dXJuWzJdO3Q9dGhpcy5nZXRTb3J0ZWRCYWNrZW5kcygpLGU9MCxyLmxhYmVsPTE7Y2FzZSAxOnJldHVybiBlPHQubGVuZ3RoPyhuPXRbZV0sWzQsdGhpcy5pbml0aWFsaXplQmFja2VuZChuKS5zdWNjZXNzXSk6WzMsNF07Y2FzZSAyOmlmKHIuc2VudCgpKXJldHVybiB0aGlzLnNldEJhY2tlbmQobiksWzJdO3IubGFiZWw9MztjYXNlIDM6cmV0dXJuIGUrKyxbMywxXTtjYXNlIDQ6dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGluaXRpYWxpemUgYW55IGJhY2tlbmRzLCBhbGwgYmFja2VuZCBpbml0aWFsaXphdGlvbnMgZmFpbGVkLlwiKX19KX0pfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJiYWNrZW5kXCIse2dldDpmdW5jdGlvbigpe2lmKG51bGwhPXRoaXMucGVuZGluZ0JhY2tlbmRJbml0KXRocm93IG5ldyBFcnJvcihcIkJhY2tlbmQgJ1wiK3RoaXMuYmFja2VuZE5hbWUrXCInIGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGl6ZWQuIE1ha2Ugc3VyZSB0byBhd2FpdCB0Zi5yZWFkeSgpIGJlZm9yZSBjYWxsaW5nIG90aGVyIG1ldGhvZHNcIik7aWYobnVsbD09dGhpcy5iYWNrZW5kSW5zdGFuY2Upe3ZhciB0PXRoaXMuaW5pdGlhbGl6ZUJhY2tlbmRzQW5kUmV0dXJuQmVzdCgpLGU9dC5uYW1lO2lmKHQuYXN5bmNJbml0KXRocm93IG5ldyBFcnJvcihcIlRoZSBoaWdoZXN0IHByaW9yaXR5IGJhY2tlbmQgJ1wiK2UrXCInIGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGl6ZWQuIE1ha2Ugc3VyZSB0byBhd2FpdCB0Zi5yZWFkeSgpIGJlZm9yZSBjYWxsaW5nIG90aGVyIG1ldGhvZHNcIik7dGhpcy5zZXRCYWNrZW5kKGUpfXJldHVybiB0aGlzLmJhY2tlbmRJbnN0YW5jZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5iYWNrZW5kTmFtZXM9ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5yZWdpc3RyeUZhY3RvcnkpfSx0LnByb3RvdHlwZS5maW5kQmFja2VuZD1mdW5jdGlvbih0KXtpZighKHQgaW4gdGhpcy5yZWdpc3RyeSkpe2lmKCEodCBpbiB0aGlzLnJlZ2lzdHJ5RmFjdG9yeSkpcmV0dXJuIG51bGw7aWYodGhpcy5pbml0aWFsaXplQmFja2VuZCh0KS5hc3luY0luaXQpcmV0dXJuIG51bGx9cmV0dXJuIHRoaXMucmVnaXN0cnlbdF19LHQucHJvdG90eXBlLmZpbmRCYWNrZW5kRmFjdG9yeT1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbiB0aGlzLnJlZ2lzdHJ5RmFjdG9yeT90aGlzLnJlZ2lzdHJ5RmFjdG9yeVt0XS5mYWN0b3J5Om51bGx9LHQucHJvdG90eXBlLnJlZ2lzdGVyQmFja2VuZD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPTEpLHQgaW4gdGhpcy5yZWdpc3RyeUZhY3Rvcnk/KGNvbnNvbGUud2Fybih0K1wiIGJhY2tlbmQgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZC4gUmV1c2luZyBleGlzdGluZyBiYWNrZW5kIGZhY3RvcnkuXCIpLCExKToodGhpcy5yZWdpc3RyeUZhY3RvcnlbdF09e2ZhY3Rvcnk6ZSxwcmlvcml0eTpufSwhMCl9LHQucHJvdG90eXBlLnNldEJhY2tlbmQ9ZnVuY3Rpb24odCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsbixyO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obyl7c3dpdGNoKG8ubGFiZWwpe2Nhc2UgMDppZihudWxsPT10aGlzLnJlZ2lzdHJ5RmFjdG9yeVt0XSl0aHJvdyBuZXcgRXJyb3IoXCJCYWNrZW5kIG5hbWUgJ1wiK3QrXCInIG5vdCBmb3VuZCBpbiByZWdpc3RyeVwiKTtyZXR1cm4gdGhpcy5iYWNrZW5kTmFtZT10LG51bGwhPXRoaXMucmVnaXN0cnlbdF0/WzMsNF06KHRoaXMuYmFja2VuZEluc3RhbmNlPW51bGwsZT10aGlzLmluaXRpYWxpemVCYWNrZW5kKHQpLG49ZS5zdWNjZXNzLGUuYXN5bmNJbml0P1s0LG5dOlszLDJdKTtjYXNlIDE6cmV0dXJuIHI9by5zZW50KCksWzMsM107Y2FzZSAyOnI9bixvLmxhYmVsPTM7Y2FzZSAzOmlmKCFyKXJldHVyblsyLCExXTtvLmxhYmVsPTQ7Y2FzZSA0OnJldHVybiB0aGlzLmJhY2tlbmRJbnN0YW5jZT10aGlzLnJlZ2lzdHJ5W3RdLHRoaXMucHJvZmlsZXI9bmV3IHR0KHRoaXMuYmFja2VuZEluc3RhbmNlKSxbMiwhMF19fSl9KX0sdC5wcm90b3R5cGUuaW5pdGlhbGl6ZUJhY2tlbmQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPUR0LnJlZ2lzdHJ5RmFjdG9yeVt0XTtpZihudWxsPT1uKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpbml0aWFsaXplIGJhY2tlbmQgXCIrdCtcIiwgbm8gcmVnaXN0cmF0aW9uIGZvdW5kLlwiKTt0cnl7dmFyIHI9bi5mYWN0b3J5KCk7aWYoUHJvbWlzZS5yZXNvbHZlKHIpPT09cil7dmFyIG89ci50aGVuKGZ1bmN0aW9uKG4pe3JldHVybiBlLnJlZ2lzdHJ5W3RdPW4sZS5wZW5kaW5nQmFja2VuZEluaXQ9bnVsbCwhMH0pLmNhdGNoKGZ1bmN0aW9uKG4pe3JldHVybiBlLnBlbmRpbmdCYWNrZW5kSW5pdD1udWxsLGNvbnNvbGUud2FybihcIkluaXRpYWxpemF0aW9uIG9mIGJhY2tlbmQgXCIrdCtcIiBmYWlsZWRcIiksY29uc29sZS53YXJuKG4uc3RhY2t8fG4ubWVzc2FnZSksITF9KTtyZXR1cm4gdGhpcy5wZW5kaW5nQmFja2VuZEluaXQ9byx7c3VjY2VzczpvLGFzeW5jSW5pdDohMH19cmV0dXJuIHRoaXMucmVnaXN0cnlbdF09cix7c3VjY2VzczohMCxhc3luY0luaXQ6ITF9fWNhdGNoKGUpe3JldHVybiBjb25zb2xlLndhcm4oXCJJbml0aWFsaXphdGlvbiBvZiBiYWNrZW5kIFwiK3QrXCIgZmFpbGVkXCIpLGNvbnNvbGUud2FybihlLnN0YWNrfHxlLm1lc3NhZ2UpLHtzdWNjZXNzOiExLGFzeW5jSW5pdDohMX19fSx0LnByb3RvdHlwZS5yZW1vdmVCYWNrZW5kPWZ1bmN0aW9uKHQpe2lmKCEodCBpbiB0aGlzLnJlZ2lzdHJ5RmFjdG9yeSkpdGhyb3cgbmV3IEVycm9yKHQrXCIgYmFja2VuZCBub3QgZm91bmQgaW4gcmVnaXN0cnlcIik7dCBpbiB0aGlzLnJlZ2lzdHJ5JiYodGhpcy5yZWdpc3RyeVt0XS5kaXNwb3NlKCksZGVsZXRlIHRoaXMucmVnaXN0cnlbdF0pLGRlbGV0ZSB0aGlzLnJlZ2lzdHJ5RmFjdG9yeVt0XX0sdC5wcm90b3R5cGUuZ2V0U29ydGVkQmFja2VuZHM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2lmKDA9PT1PYmplY3Qua2V5cyh0aGlzLnJlZ2lzdHJ5RmFjdG9yeSkubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk5vIGJhY2tlbmQgZm91bmQgaW4gcmVnaXN0cnkuXCIpO3JldHVybiBPYmplY3Qua2V5cyh0aGlzLnJlZ2lzdHJ5RmFjdG9yeSkuc29ydChmdW5jdGlvbihlLG4pe3JldHVybiB0LnJlZ2lzdHJ5RmFjdG9yeVtuXS5wcmlvcml0eS10LnJlZ2lzdHJ5RmFjdG9yeVtlXS5wcmlvcml0eX0pfSx0LnByb3RvdHlwZS5pbml0aWFsaXplQmFja2VuZHNBbmRSZXR1cm5CZXN0PWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ2V0U29ydGVkQmFja2VuZHMoKSxlPTA7ZTx0Lmxlbmd0aDtlKyspe3ZhciBuPXRbZV0scj10aGlzLmluaXRpYWxpemVCYWNrZW5kKG4pLG89ci5zdWNjZXNzLGE9ci5hc3luY0luaXQ7aWYoYXx8bylyZXR1cm57bmFtZTpuLGFzeW5jSW5pdDphfX10aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgaW5pdGlhbGl6ZSBhbnkgYmFja2VuZHMsIGFsbCBiYWNrZW5kIGluaXRpYWxpemF0aW9ucyBmYWlsZWQuXCIpfSx0LnByb3RvdHlwZS5tb3ZlRGF0YT1mdW5jdGlvbih0KXt0aGlzLndyaXRlKHQsdGhpcy5yZWFkU3luYyh0KSl9LHQucHJvdG90eXBlLnRpZHk9ZnVuY3Rpb24odCxlKXt2YXIgbixyPXRoaXMsbz1udWxsO2lmKG51bGw9PWUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgYSBmdW5jdGlvbiB0byB0aWR5KClcIik7ZT10fWVsc2V7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIHQmJiEodCBpbnN0YW5jZW9mIFN0cmluZykpdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBjYWxsaW5nIHdpdGggdHdvIGFyZ3VtZW50cywgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRpZHkoKSBtdXN0IGJlIGEgc3RyaW5nXCIpO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBjYWxsaW5nIHdpdGggdHdvIGFyZ3VtZW50cywgdGhlIDJuZCBhcmd1bWVudCB0byB0aWR5KCkgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO289dH1yZXR1cm4gdGhpcy5zY29wZWRSdW4oZnVuY3Rpb24oKXtyZXR1cm4gci5zdGFydFNjb3BlKG8pfSxmdW5jdGlvbigpe3JldHVybiByLmVuZFNjb3BlKG4pfSxmdW5jdGlvbigpe3JldHVybihuPWUoKSlpbnN0YW5jZW9mIFByb21pc2UmJmNvbnNvbGUuZXJyb3IoXCJDYW5ub3QgcmV0dXJuIGEgUHJvbWlzZSBpbnNpZGUgb2YgdGlkeS5cIiksbn0pfSx0LnByb3RvdHlwZS5zY29wZWRSdW49ZnVuY3Rpb24odCxlLG4pe3QoKTt0cnl7dmFyIHI9bigpO3JldHVybiBlKCkscn1jYXRjaCh0KXt0aHJvdyBlKCksdH19LHQucHJvdG90eXBlLm5leHRUZW5zb3JJZD1mdW5jdGlvbigpe3JldHVybiB0Lm5leHRUZW5zb3JJZCsrfSx0LnByb3RvdHlwZS5uZXh0VmFyaWFibGVJZD1mdW5jdGlvbigpe3JldHVybiB0Lm5leHRWYXJpYWJsZUlkKyt9LHQucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKHQpe3ZhciBlPWZ0Lm1ha2UodC5zaGFwZSx7ZGF0YUlkOnQuZGF0YUlkfSx0LmR0eXBlKTtyZXR1cm4gdGhpcy5hZGRUYXBlTm9kZShbdF0sZSxmdW5jdGlvbih0KXtyZXR1cm5bdC50b0Zsb2F0KCldfSksZX0sdC5wcm90b3R5cGUucnVuS2VybmVsPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcixvPXRoaXMsYT1bXSxpPXRoaXMuaXNUYXBlT24oKSxzPW51bGwhPXRoaXMuc3RhdGUuYWN0aXZlU2NvcGU/dGhpcy5zdGF0ZS5hY3RpdmVTY29wZS5uYW1lOlwiXCIsdT1mdW5jdGlvbih0KXtpJiYoYT10Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gby5rZWVwKG8uY2xvbmUodCkpfSkpfSxsPXRoaXMuc3RhdGUubnVtQnl0ZXMsYz10aGlzLnN0YXRlLm51bVRlbnNvcnM7aWYodGhpcy5zY29wZWRSdW4oZnVuY3Rpb24oKXtyZXR1cm4gby5zdGF0ZS5rZXJuZWxEZXB0aCsrfSxmdW5jdGlvbigpe3JldHVybiBvLnN0YXRlLmtlcm5lbERlcHRoLS19LGZ1bmN0aW9uKCl7cj1vLkVOVi5nZXRCb29sKFwiREVCVUdcIik/by5wcm9maWxlci5wcm9maWxlS2VybmVsKHMsZnVuY3Rpb24oKXtyZXR1cm4gdChvLmJhY2tlbmQsdSl9KTp0KG8uYmFja2VuZCx1KX0pLGkpe3ZhciBoPXtpZDp0aGlzLnN0YXRlLm5leHRUYXBlTm9kZUlkKyssbmFtZTpzLGlucHV0czplLG91dHB1dHM6QXJyYXkuaXNBcnJheShyKT9yOltyXSxzYXZlZDphfTtudWxsIT1uJiYoaC5ncmFkaWVudD1mdW5jdGlvbih0KXtyZXR1cm4gbih0LGEpfSksdGhpcy5zdGF0ZS5hY3RpdmVUYXBlLnB1c2goaCl9cmV0dXJuIHRoaXMuc3RhdGUucHJvZmlsaW5nJiZ0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUua2VybmVscy5wdXNoKHtuYW1lOnMsYnl0ZXNBZGRlZDp0aGlzLnN0YXRlLm51bUJ5dGVzLWwsdG90YWxCeXRlc1NuYXBzaG90OnRoaXMuc3RhdGUubnVtQnl0ZXMsdGVuc29yc0FkZGVkOnRoaXMuc3RhdGUubnVtVGVuc29ycy1jLHRvdGFsVGVuc29yc1NuYXBzaG90OnRoaXMuc3RhdGUubnVtVGVuc29ycyxpbnB1dFNoYXBlczpPYmplY3Qua2V5cyhlKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGVbdF0uc2hhcGV9KSxvdXRwdXRTaGFwZTpBcnJheS5pc0FycmF5KHIpP3IubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSk6ci5zaGFwZX0pLHJ9LHQucHJvdG90eXBlLnJlZ2lzdGVyVGVuc29yPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmhhcyh0LmRhdGFJZCk/dGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldCh0LmRhdGFJZCkucmVmQ291bnQ6MDtpZih0aGlzLnN0YXRlLm51bVRlbnNvcnMrKyxcInN0cmluZ1wiPT09dC5kdHlwZSYmdGhpcy5zdGF0ZS5udW1TdHJpbmdUZW5zb3JzKyssMD09PW4pe3RoaXMuc3RhdGUubnVtRGF0YUJ1ZmZlcnMrKzt2YXIgcj0wO1wiY29tcGxleDY0XCIhPT10LmR0eXBlJiZcInN0cmluZ1wiIT09dC5kdHlwZSYmKHI9dC5zaXplKk0odC5kdHlwZSkpLHRoaXMuc3RhdGUudGVuc29ySW5mby5zZXQodC5kYXRhSWQse2JhY2tlbmQ6bnVsbCE9ZT9lOnRoaXMuYmFja2VuZCxkdHlwZTp0LmR0eXBlLHNoYXBlOnQuc2hhcGUsYnl0ZXM6cixyZWZDb3VudDowfSksdGhpcy5zdGF0ZS5udW1CeXRlcys9cixudWxsIT1lP2UucmVnaXN0ZXIodC5kYXRhSWQsdC5zaGFwZSx0LmR0eXBlKTp0aGlzLmJhY2tlbmQucmVnaXN0ZXIodC5kYXRhSWQsdC5zaGFwZSx0LmR0eXBlKX10aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KHQuZGF0YUlkKS5yZWZDb3VudCsrLHQgaW5zdGFuY2VvZiBkdHx8dGhpcy50cmFjayh0KX0sdC5wcm90b3R5cGUucmVnaXN0ZXJWYXJpYWJsZT1mdW5jdGlvbih0KXtpZihudWxsIT10aGlzLnN0YXRlLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdC5uYW1lXSl0aHJvdyBuZXcgRXJyb3IoXCJWYXJpYWJsZSB3aXRoIG5hbWUgXCIrdC5uYW1lK1wiIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWRcIik7dGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzW3QubmFtZV09dH0sdC5wcm90b3R5cGUuZGlzcG9zZVRlbnNvcj1mdW5jdGlvbih0KXtpZih0aGlzLnN0YXRlLnRlbnNvckluZm8uaGFzKHQuZGF0YUlkKSl7dGhpcy5zdGF0ZS5udW1UZW5zb3JzLS0sXCJzdHJpbmdcIj09PXQuZHR5cGUmJnRoaXMuc3RhdGUubnVtU3RyaW5nVGVuc29ycy0tO3ZhciBlPXRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQodC5kYXRhSWQpO2UucmVmQ291bnQ8PTE/KFwiY29tcGxleDY0XCIhPT10LmR0eXBlJiYodGhpcy5zdGF0ZS5udW1CeXRlcy09ZS5ieXRlcyksdGhpcy5zdGF0ZS5udW1EYXRhQnVmZmVycy0tLGUuYmFja2VuZC5kaXNwb3NlRGF0YSh0LmRhdGFJZCksdGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmRlbGV0ZSh0LmRhdGFJZCkpOnRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQodC5kYXRhSWQpLnJlZkNvdW50LS19fSx0LnByb3RvdHlwZS5kaXNwb3NlVmFyaWFibGVzPWZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlcyl7dmFyIGU9dGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzW3RdO3RoaXMuZGlzcG9zZVRlbnNvcihlKSxkZWxldGUgdGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzW3RdfX0sdC5wcm90b3R5cGUubWVtb3J5PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5iYWNrZW5kLm1lbW9yeSgpO3JldHVybiB0Lm51bVRlbnNvcnM9dGhpcy5zdGF0ZS5udW1UZW5zb3JzLHQubnVtRGF0YUJ1ZmZlcnM9dGhpcy5zdGF0ZS5udW1EYXRhQnVmZmVycyx0Lm51bUJ5dGVzPXRoaXMuc3RhdGUubnVtQnl0ZXMsdGhpcy5zdGF0ZS5udW1TdHJpbmdUZW5zb3JzPjAmJih0LnVucmVsaWFibGU9ITAsbnVsbD09dC5yZWFzb25zJiYodC5yZWFzb25zPVtdKSx0LnJlYXNvbnMucHVzaChcIk1lbW9yeSB1c2FnZSBieSBzdHJpbmcgdGVuc29ycyBpcyBhcHByb3hpbWF0ZSAoMiBieXRlcyBwZXIgY2hhcmFjdGVyKVwiKSksdH0sdC5wcm90b3R5cGUucHJvZmlsZT1mdW5jdGlvbih0KXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxuO3JldHVybiBvKHRoaXMsZnVuY3Rpb24ocil7cmV0dXJuIHRoaXMuc3RhdGUucHJvZmlsaW5nPSEwLGU9dGhpcy5zdGF0ZS5udW1CeXRlcyxuPXRoaXMuc3RhdGUubnVtVGVuc29ycyx0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUua2VybmVscz1bXSx0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUucmVzdWx0PXQoKSx0aGlzLnN0YXRlLnByb2ZpbGluZz0hMSx0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUucGVha0J5dGVzPU1hdGgubWF4LmFwcGx5KE1hdGgsdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLmtlcm5lbHMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRvdGFsQnl0ZXNTbmFwc2hvdH0pKSx0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUubmV3Qnl0ZXM9dGhpcy5zdGF0ZS5udW1CeXRlcy1lLHRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5uZXdUZW5zb3JzPXRoaXMuc3RhdGUubnVtVGVuc29ycy1uLFsyLHRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZV19KX0pfSx0LnByb3RvdHlwZS5pc1RhcGVPbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlLmdyYWRpZW50RGVwdGg+MCYmMD09PXRoaXMuc3RhdGUua2VybmVsRGVwdGh9LHQucHJvdG90eXBlLmFkZFRhcGVOb2RlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj17fTt0LmZvckVhY2goZnVuY3Rpb24odCxlKXtyW2VdPXR9KTt2YXIgbz17aWQ6dGhpcy5zdGF0ZS5uZXh0VGFwZU5vZGVJZCsrLG5hbWU6dGhpcy5zdGF0ZS5hY3RpdmVTY29wZS5uYW1lLGlucHV0czpyLG91dHB1dHM6W2VdLGdyYWRpZW50OmZ1bmN0aW9uKHQpe3ZhciBlPW4odCkscj17fTtyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKHQsZSl7cltlXT1mdW5jdGlvbigpe3JldHVybiB0fX0pLHJ9fTt0aGlzLnN0YXRlLmFjdGl2ZVRhcGUucHVzaChvKX0sdC5wcm90b3R5cGUua2VlcD1mdW5jdGlvbih0KXtyZXR1cm4gdC5rZXB0PSEwLHR9LHQucHJvdG90eXBlLnN0YXJ0VGFwZT1mdW5jdGlvbigpezA9PT10aGlzLnN0YXRlLmdyYWRpZW50RGVwdGgmJih0aGlzLnN0YXRlLmFjdGl2ZVRhcGU9W10pLHRoaXMuc3RhdGUuZ3JhZGllbnREZXB0aCsrfSx0LnByb3RvdHlwZS5lbmRUYXBlPWZ1bmN0aW9uKCl7dGhpcy5zdGF0ZS5ncmFkaWVudERlcHRoLS19LHQucHJvdG90eXBlLnN0YXJ0U2NvcGU9ZnVuY3Rpb24odCl7dmFyIGU9e3RyYWNrOltdLG5hbWU6XCJ1bm5hbWVkIHNjb3BlXCIsaWQ6dGhpcy5zdGF0ZS5uZXh0U2NvcGVJZCsrfTt0JiYoZS5uYW1lPXQpLHRoaXMuc3RhdGUuc2NvcGVTdGFjay5wdXNoKGUpLHRoaXMuc3RhdGUuYWN0aXZlU2NvcGU9ZX0sdC5wcm90b3R5cGUuZW5kU2NvcGU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMsbj1OdCh0KSxyPW5ldyBTZXQobi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuaWR9KSksbz0wO288dGhpcy5zdGF0ZS5hY3RpdmVTY29wZS50cmFjay5sZW5ndGg7bysrKXt2YXIgYT10aGlzLnN0YXRlLmFjdGl2ZVNjb3BlLnRyYWNrW29dO2Eua2VwdHx8ci5oYXMoYS5pZCl8fGEuZGlzcG9zZSgpfXZhciBpPXRoaXMuc3RhdGUuc2NvcGVTdGFjay5wb3AoKTt0aGlzLnN0YXRlLmFjdGl2ZVNjb3BlPTA9PT10aGlzLnN0YXRlLnNjb3BlU3RhY2subGVuZ3RoP251bGw6dGhpcy5zdGF0ZS5zY29wZVN0YWNrW3RoaXMuc3RhdGUuc2NvcGVTdGFjay5sZW5ndGgtMV0sbi5mb3JFYWNoKGZ1bmN0aW9uKHQpe3Qua2VwdHx8dC5zY29wZUlkIT09aS5pZHx8ZS50cmFjayh0KX0pfSx0LnByb3RvdHlwZS5ncmFkaWVudHM9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89dGhpcztpZih2b2lkIDA9PT1yJiYocj0hMSksZChlLmxlbmd0aD4wLGZ1bmN0aW9uKCl7cmV0dXJuXCJncmFkaWVudHMoKSByZWNlaXZlZCBhbiBlbXB0eSBsaXN0IG9mIHhzLlwifSksbnVsbCE9biYmXCJmbG9hdDMyXCIhPT1uLmR0eXBlKXRocm93IG5ldyBFcnJvcihcImR5IG11c3QgaGF2ZSAnZmxvYXQzMicgZHR5cGUsIGJ1dCBoYXMgJ1wiK24uZHR5cGUrXCInXCIpO3ZhciBhPXRoaXMuc2NvcGVkUnVuKGZ1bmN0aW9uKCl7cmV0dXJuIG8uc3RhcnRUYXBlKCl9LGZ1bmN0aW9uKCl7cmV0dXJuIG8uZW5kVGFwZSgpfSxmdW5jdGlvbigpe3JldHVybiBvLnRpZHkoXCJmb3J3YXJkXCIsdCl9KTtkKGEgaW5zdGFuY2VvZiBmdCxmdW5jdGlvbigpe3JldHVyblwiVGhlIHJlc3VsdCB5IHJldHVybmVkIGJ5IGYoKSBtdXN0IGJlIGEgdGVuc29yLlwifSk7dmFyIGk9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj17fSxvPXt9LGE9MDthPGUubGVuZ3RoO2ErKylyW2VbYV0uaWRdPSEwO2ZvcihhPTA7YTx0Lmxlbmd0aDthKyspe3ZhciBpPShkPXRbYV0pLmlucHV0cztmb3IodmFyIHMgaW4gaSl7Zm9yKHZhciB1PWlbc10sbD0hMSxjPTA7YzxlLmxlbmd0aDtjKyspaWYoclt1LmlkXSl7ZC5vdXRwdXRzLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIHJbdC5pZF09ITB9KSxsPSEwLG9bZC5pZF09ITA7YnJlYWt9aWYobClicmVha319dmFyIGg9e307aFtuLmlkXT0hMDt2YXIgcD17fTtmb3IoYT10Lmxlbmd0aC0xO2E+PTA7YS0tKWZvcihpPShkPXRbYV0pLmlucHV0cyxjPTA7YzxkLm91dHB1dHMubGVuZ3RoO2MrKylpZihoW2Qub3V0cHV0c1tjXS5pZF0pe2Zvcih2YXIgcyBpbiBpKWhbaVtzXS5pZF09ITAscFtkLmlkXT0hMDticmVha312YXIgZj1bXTtmb3IoYT0wO2E8dC5sZW5ndGg7YSsrKXt2YXIgZDtpZihvWyhkPXRbYV0pLmlkXSYmcFtkLmlkXSl7dmFyIHY9e307Zm9yKHZhciBzIGluIGQuaW5wdXRzKXt2YXIgbT1kLmlucHV0c1tzXTtyW20uaWRdJiYodltzXT1tKX12YXIgZz1PYmplY3QuYXNzaWduKHt9LGQpO2cuaW5wdXRzPXYsZy5vdXRwdXRzPWQub3V0cHV0cyxmLnB1c2goZyl9fXJldHVybiBmfSh0aGlzLnN0YXRlLmFjdGl2ZVRhcGUsZSxhKTtpZighciYmMD09PWkubGVuZ3RoJiZlLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21wdXRlIGdyYWRpZW50IG9mIHk9Zih4KSB3aXRoIHJlc3BlY3QgdG8geC4gTWFrZSBzdXJlIHRoYXQgdGhlIGYgeW91IHBhc3NlZCBlbmNsb3NlcyBhbGwgb3BlcmF0aW9ucyB0aGF0IGxlYWQgZnJvbSB4IHRvIHkuXCIpO3JldHVybiB0aGlzLnRpZHkoXCJiYWNrd2FyZFwiLGZ1bmN0aW9uKCl7dmFyIHQscixzPXt9O3NbYS5pZF09bnVsbD09bj8odD1hLnNoYXBlLHI9SCh5KHQpLFwiZmxvYXQzMlwiKSxmdC5tYWtlKHQse3ZhbHVlczpyfSkpOm4sZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj1mdW5jdGlvbihyKXt2YXIgbz1lW3JdLGE9W107aWYoby5vdXRwdXRzLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIG49dFtlLmlkXTtpZihudWxsIT1uKWEucHVzaChuKTtlbHNle3ZhciByPWZ0Lm1ha2UoZS5zaGFwZSx7dmFsdWVzOiQoZS5zaXplLGUuZHR5cGUpfSxlLmR0eXBlKTthLnB1c2gocil9fSksbnVsbD09by5ncmFkaWVudCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSBncmFkaWVudDogZ3JhZGllbnQgZnVuY3Rpb24gbm90IGZvdW5kIGZvciBcIitvLm5hbWUrXCIuXCIpO3ZhciBpPW8uZ3JhZGllbnQoMT09PW8ub3V0cHV0cy5sZW5ndGg/YVswXTphKSxzPWZ1bmN0aW9uKGUpe2lmKCEoZSBpbiBpKSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYmFja3Byb3AgdGhyb3VnaCBpbnB1dCBcIitlK1wiLiBBdmFpbGFibGUgZ3JhZGllbnRzIGZvdW5kOiBcIitPYmplY3Qua2V5cyhpKStcIi5cIik7dmFyIHI9bihmdW5jdGlvbigpe3JldHVybiBpW2VdKCl9KTtpZihcImZsb2F0MzJcIiE9PXIuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gZ3JhZGllbnQgZm9yIG9wIFwiK28ubmFtZStcIi4gVGhlIGdyYWRpZW50IG9mIGlucHV0IFwiK2UrXCIgbXVzdCBoYXZlICdmbG9hdDMyJyBkdHlwZSwgYnV0IGhhcyAnXCIrci5kdHlwZStcIidcIik7dmFyIGE9by5pbnB1dHNbZV07aWYoIXgoci5zaGFwZSxhLnNoYXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBncmFkaWVudCBmb3Igb3AgXCIrby5uYW1lK1wiLiBUaGUgZ3JhZGllbnQgb2YgaW5wdXQgJ1wiK2UrXCInIGhhcyBzaGFwZSAnXCIrci5zaGFwZStcIicsIHdoaWNoIGRvZXMgbm90IG1hdGNoIHRoZSBzaGFwZSBvZiB0aGUgaW5wdXQgJ1wiK2Euc2hhcGUrXCInXCIpO2lmKG51bGw9PXRbYS5pZF0pdFthLmlkXT1yO2Vsc2V7dmFyIHM9dFthLmlkXTt0W2EuaWRdPXMuYWRkKHIpLHMuZGlzcG9zZSgpfX07Zm9yKHZhciB1IGluIG8uaW5wdXRzKXModSl9LG89ZS5sZW5ndGgtMTtvPj0wO28tLSlyKG8pfShzLGksZnVuY3Rpb24odCl7cmV0dXJuIG8udGlkeSh0KX0pO3ZhciB1PWUubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBzW3QuaWRdfSk7cmV0dXJuIDA9PT1vLnN0YXRlLmdyYWRpZW50RGVwdGgmJihvLnN0YXRlLmFjdGl2ZVRhcGUuZm9yRWFjaChmdW5jdGlvbih0KXtmb3IodmFyIGUgaW4gdC5zYXZlZCl0LnNhdmVkW2VdLmRpc3Bvc2UoKX0pLG8uc3RhdGUuYWN0aXZlVGFwZT1udWxsKSx7dmFsdWU6YSxncmFkczp1fX0pfSx0LnByb3RvdHlwZS5jdXN0b21HcmFkPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7cmV0dXJuIGQoVSh0KSxmdW5jdGlvbigpe3JldHVyblwiVGhlIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCBiZSBhIGZ1bmN0aW9uLlwifSksZnVuY3Rpb24oKXtmb3IodmFyIG4scj1bXSxvPTA7bzxhcmd1bWVudHMubGVuZ3RoO28rKylyW29dPWFyZ3VtZW50c1tvXTtkKHIuZXZlcnkoZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBmdH0pLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgYXJncyBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSh4MSwgeDIsLi4uKSBtdXN0IGFsbCBiZSB0ZW5zb3JzXCJ9KTt2YXIgYT17fTtyZXR1cm4gci5mb3JFYWNoKGZ1bmN0aW9uKHQsZSl7YVtlXT10fSksZS5ydW5LZXJuZWwoZnVuY3Rpb24oZSxvKXtyZXR1cm4gZCgobj10LmFwcGx5KHZvaWQgMCxyLmNvbmNhdChbb10pKSkudmFsdWUgaW5zdGFuY2VvZiBmdCxmdW5jdGlvbigpe3JldHVyblwiVGhlIGZ1bmN0aW9uIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdoZXJlIGBvYmoudmFsdWVgIGlzIGEgdGVuc29yXCJ9KSxkKFUobi5ncmFkRnVuYyksZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aGVyZSBgb2JqLmdyYWRGdW5jYCBpcyBhIGZ1bmN0aW9uLlwifSksbi52YWx1ZX0sYSxmdW5jdGlvbih0LGUpe3ZhciBvPW4uZ3JhZEZ1bmModCxlKSxhPUFycmF5LmlzQXJyYXkobyk/bzpbb107ZChhLmxlbmd0aD09PXIubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZnVuY3Rpb24gZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IHJldHVybiBhbiBvYmplY3Qgd2hlcmUgYG9iai5ncmFkRnVuY2AgaXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHNhbWUgbnVtYmVyIG9mIHRlbnNvcnMgYXMgaW5wdXRzIHBhc3NlZCB0byBmKC4uLikuXCJ9KSxkKGEuZXZlcnkoZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBmdH0pLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZnVuY3Rpb24gZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IHJldHVybiBhbiBvYmplY3Qgd2hlcmUgYG9iai5ncmFkRnVuY2AgaXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBsaXN0IG9mIG9ubHkgdGVuc29ycy5cIn0pO3ZhciBpPXt9O3JldHVybiBhLmZvckVhY2goZnVuY3Rpb24odCxlKXtpW2VdPWZ1bmN0aW9uKCl7cmV0dXJuIHR9fSksaX0pfX0sdC5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KHQpO2lmKFwic3RyaW5nXCI9PT1uLmR0eXBlKXt2YXIgcj1GKGUpO3RoaXMuc3RhdGUubnVtQnl0ZXMrPXItbi5ieXRlcyxuLmJ5dGVzPXJ9dGhpcy5iYWNrZW5kIT09bi5iYWNrZW5kJiYobi5iYWNrZW5kLmRpc3Bvc2VEYXRhKHQpLG4uYmFja2VuZD10aGlzLmJhY2tlbmQsdGhpcy5iYWNrZW5kLnJlZ2lzdGVyKHQsbi5zaGFwZSxuLmR0eXBlKSksdGhpcy5iYWNrZW5kLndyaXRlKHQsZSl9LHQucHJvdG90eXBlLnJlYWRTeW5jPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KHQpLmJhY2tlbmQucmVhZFN5bmModCl9LHQucHJvdG90eXBlLnJlYWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQodCkuYmFja2VuZC5yZWFkKHQpfSx0LnByb3RvdHlwZS5mcm9tUGl4ZWxzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYmFja2VuZC5mcm9tUGl4ZWxzKHQsZSl9LHQucHJvdG90eXBlLnRpbWU9ZnVuY3Rpb24odCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsbjtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuIGU9aigpLFs0LHRoaXMuYmFja2VuZC50aW1lKHQpXTtjYXNlIDE6cmV0dXJuKG49ci5zZW50KCkpLndhbGxNcz1qKCktZSxbMixuXX19KX0pfSx0LnByb3RvdHlwZS50cmFjaz1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9dGhpcy5zdGF0ZS5hY3RpdmVTY29wZSYmKHQuc2NvcGVJZD10aGlzLnN0YXRlLmFjdGl2ZVNjb3BlLmlkLHRoaXMuc3RhdGUuYWN0aXZlU2NvcGUudHJhY2sucHVzaCh0KSksdH0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVnaXN0ZXJlZFZhcmlhYmxlc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMuc3RhdGUuZGlzcG9zZSgpLHRoaXMuRU5WLnJlc2V0KCksdGhpcy5zdGF0ZT1uZXcgQXQsdGhpcy5yZWdpc3RyeSl0aGlzLnJlZ2lzdHJ5W3RdLmRpc3Bvc2UoKSxkZWxldGUgdGhpcy5yZWdpc3RyeVt0XTt0aGlzLmJhY2tlbmROYW1lPW51bGwsdGhpcy5iYWNrZW5kSW5zdGFuY2U9bnVsbH0sdC5uZXh0VGVuc29ySWQ9MCx0Lm5leHRWYXJpYWJsZUlkPTAsdH0oKTt2YXIgRHQ9ZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbigpe2lmKG51bGw9PWt0KXt2YXIgdD12b2lkIDA7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyl0PXdpbmRvdztlbHNlIGlmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWwpdD1nbG9iYWw7ZWxzZXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgcHJvY2Vzcyl0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBhIGdsb2JhbCBvYmplY3RcIik7dD1wcm9jZXNzfWt0PXR9cmV0dXJuIGt0fSgpO2lmKG51bGw9PXQuX3RmZW5naW5lKXt2YXIgZT1uZXcgaSh0KTt0Ll90ZmVuZ2luZT1uZXcgVHQoZSl9cmV0dXJuIHUodC5fdGZlbmdpbmUuRU5WKSxjdD1mdW5jdGlvbigpe3JldHVybiB0Ll90ZmVuZ2luZX0sdC5fdGZlbmdpbmV9KCk7ZnVuY3Rpb24gT3QoKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93fWEucmVnaXN0ZXJGbGFnKFwiREVCVUdcIixmdW5jdGlvbigpe3JldHVybiExfSxmdW5jdGlvbih0KXt0JiZjb25zb2xlLndhcm4oXCJEZWJ1Z2dpbmcgbW9kZSBpcyBPTi4gVGhlIG91dHB1dCBvZiBldmVyeSBtYXRoIGNhbGwgd2lsbCBiZSBkb3dubG9hZGVkIHRvIENQVSBhbmQgY2hlY2tlZCBmb3IgTmFOcy4gVGhpcyBzaWduaWZpY2FudGx5IGltcGFjdHMgcGVyZm9ybWFuY2UuXCIpfSksYS5yZWdpc3RlckZsYWcoXCJJU19CUk9XU0VSXCIsZnVuY3Rpb24oKXtyZXR1cm4gT3QoKX0pLGEucmVnaXN0ZXJGbGFnKFwiSVNfTk9ERVwiLGZ1bmN0aW9uKCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHByb2Nlc3MmJnZvaWQgMCE9PXByb2Nlc3MudmVyc2lvbnMmJnZvaWQgMCE9PXByb2Nlc3MudmVyc2lvbnMubm9kZX0pLGEucmVnaXN0ZXJGbGFnKFwiSVNfQ0hST01FXCIsZnVuY3Rpb24oKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgbmF2aWdhdG9yJiZudWxsIT1uYXZpZ2F0b3ImJm51bGwhPW5hdmlnYXRvci51c2VyQWdlbnQmJi9DaHJvbWUvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkmJi9Hb29nbGUgSW5jLy50ZXN0KG5hdmlnYXRvci52ZW5kb3IpfSksYS5yZWdpc3RlckZsYWcoXCJQUk9EXCIsZnVuY3Rpb24oKXtyZXR1cm4hMX0pLGEucmVnaXN0ZXJGbGFnKFwiVEVOU09STElLRV9DSEVDS19TSEFQRV9DT05TSVNURU5DWVwiLGZ1bmN0aW9uKCl7cmV0dXJuIWEuZ2V0Qm9vbChcIlBST0RcIil9KSxhLnJlZ2lzdGVyRmxhZyhcIkRFUFJFQ0FUSU9OX1dBUk5JTkdTX0VOQUJMRURcIixmdW5jdGlvbigpe3JldHVybiEwfSksYS5yZWdpc3RlckZsYWcoXCJJU19URVNUXCIsZnVuY3Rpb24oKXtyZXR1cm4hMX0pO3ZhciBfdD17fSxNdD17YWxwaGE6ITEsYW50aWFsaWFzOiExLHByZW11bHRpcGxpZWRBbHBoYTohMSxwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITEsZGVwdGg6ITEsc3RlbmNpbDohMSxmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiEwfTtmdW5jdGlvbiBGdCh0KXt0IGluIF90fHwoX3RbdF09ZnVuY3Rpb24odCl7aWYoMSE9PXQmJjIhPT10KXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHQsIFdlYkdMIGlzIGRpc2FibGVkLlwiKTt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO2lmKGUuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dGxvc3RcIixmdW5jdGlvbihlKXtlLnByZXZlbnREZWZhdWx0KCksZGVsZXRlIF90W3RdfSwhMSksMT09PXQpcmV0dXJuIGUuZ2V0Q29udGV4dChcIndlYmdsXCIsTXQpfHxlLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIixNdCk7cmV0dXJuIGUuZ2V0Q29udGV4dChcIndlYmdsMlwiLE10KX0odCkpO3ZhciBlPV90W3RdO3JldHVybiBlLmlzQ29udGV4dExvc3QoKT8oZGVsZXRlIF90W3RdLEZ0KHQpKTooZS5kaXNhYmxlKGUuREVQVEhfVEVTVCksZS5kaXNhYmxlKGUuU1RFTkNJTF9URVNUKSxlLmRpc2FibGUoZS5CTEVORCksZS5kaXNhYmxlKGUuRElUSEVSKSxlLmRpc2FibGUoZS5QT0xZR09OX09GRlNFVF9GSUxMKSxlLmRpc2FibGUoZS5TQU1QTEVfQ09WRVJBR0UpLGUuZW5hYmxlKGUuU0NJU1NPUl9URVNUKSxlLmVuYWJsZShlLkNVTExfRkFDRSksZS5jdWxsRmFjZShlLkJBQ0spLF90W3RdKX1mdW5jdGlvbiBCdCh0LGUsbil7dmFyIHI9bigpO3JldHVybiBlJiZmdW5jdGlvbih0KXt2YXIgZT10LmdldEVycm9yKCk7aWYoZSE9PXQuTk9fRVJST1IpdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgRXJyb3I6IFwiK1V0KHQsZSkpfSh0KSxyfXZhciBQdD01Ljk2ZS04LEx0PTY1NTA0O2Z1bmN0aW9uIFd0KHQpe3JldHVybiEhKGEuZ2V0Qm9vbChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIil8fDA9PT10fHxQdDxNYXRoLmFicyh0KSYmTWF0aC5hYnModCk8THQpfWZ1bmN0aW9uIFV0KHQsZSl7c3dpdGNoKGUpe2Nhc2UgdC5OT19FUlJPUjpyZXR1cm5cIk5PX0VSUk9SXCI7Y2FzZSB0LklOVkFMSURfRU5VTTpyZXR1cm5cIklOVkFMSURfRU5VTVwiO2Nhc2UgdC5JTlZBTElEX1ZBTFVFOnJldHVyblwiSU5WQUxJRF9WQUxVRVwiO2Nhc2UgdC5JTlZBTElEX09QRVJBVElPTjpyZXR1cm5cIklOVkFMSURfT1BFUkFUSU9OXCI7Y2FzZSB0LklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OOnJldHVyblwiSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT05cIjtjYXNlIHQuT1VUX09GX01FTU9SWTpyZXR1cm5cIk9VVF9PRl9NRU1PUllcIjtjYXNlIHQuQ09OVEVYVF9MT1NUX1dFQkdMOnJldHVyblwiQ09OVEVYVF9MT1NUX1dFQkdMXCI7ZGVmYXVsdDpyZXR1cm5cIlVua25vd24gZXJyb3IgY29kZSBcIitlfX1mdW5jdGlvbiB6dCh0LGUsbil7cmV0dXJuIGhlKHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmdldEV4dGVuc2lvbihuKX0sJ0V4dGVuc2lvbiBcIicrbisnXCIgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXIuJyl9ZnVuY3Rpb24gVnQodCxlLG4pe3ZhciByPWhlKHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmNyZWF0ZVNoYWRlcih0LlZFUlRFWF9TSEFERVIpfSxcIlVuYWJsZSB0byBjcmVhdGUgdmVydGV4IFdlYkdMU2hhZGVyLlwiKTtpZihCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5zaGFkZXJTb3VyY2UocixuKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmNvbXBpbGVTaGFkZXIocil9KSwhMT09PXQuZ2V0U2hhZGVyUGFyYW1ldGVyKHIsdC5DT01QSUxFX1NUQVRVUykpdGhyb3cgY29uc29sZS5sb2codC5nZXRTaGFkZXJJbmZvTG9nKHIpKSxuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY29tcGlsZSB2ZXJ0ZXggc2hhZGVyLlwiKTtyZXR1cm4gcn1mdW5jdGlvbiBHdCh0LGUsbil7dmFyIHI9aGUodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuY3JlYXRlU2hhZGVyKHQuRlJBR01FTlRfU0hBREVSKX0sXCJVbmFibGUgdG8gY3JlYXRlIGZyYWdtZW50IFdlYkdMU2hhZGVyLlwiKTtpZihCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5zaGFkZXJTb3VyY2UocixuKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmNvbXBpbGVTaGFkZXIocil9KSwhMT09PXQuZ2V0U2hhZGVyUGFyYW1ldGVyKHIsdC5DT01QSUxFX1NUQVRVUykpdGhyb3cgZnVuY3Rpb24odCxlKXt2YXIgbj0kdC5leGVjKGUpO2lmKG51bGw9PW4pcmV0dXJuIGNvbnNvbGUubG9nKFwiQ291bGRuJ3QgcGFyc2UgbGluZSBudW1iZXIgaW4gZXJyb3I6IFwiK2UpLHZvaWQgY29uc29sZS5sb2codCk7Zm9yKHZhciByPStuWzFdLG89dC5zcGxpdChcIlxcblwiKSxhPW8ubGVuZ3RoLnRvU3RyaW5nKCkubGVuZ3RoKzIsaT1vLm1hcChmdW5jdGlvbih0LGUpe3JldHVybiBFKChlKzEpLnRvU3RyaW5nKCksYSkrdH0pLHM9MCx1PTA7dTxpLmxlbmd0aDt1Kyspcz1NYXRoLm1heChpW3VdLmxlbmd0aCxzKTt2YXIgbD1pLnNsaWNlKDAsci0xKSxjPWkuc2xpY2Uoci0xLHIpLGg9aS5zbGljZShyKTtjb25zb2xlLmxvZyhsLmpvaW4oXCJcXG5cIikpLGNvbnNvbGUubG9nKGUuc3BsaXQoXCJcXG5cIilbMF0pLGNvbnNvbGUubG9nKFwiJWMgXCIrRShjWzBdLHMpLFwiYm9yZGVyOjFweCBzb2xpZCByZWQ7IGJhY2tncm91bmQtY29sb3I6I2UzZDJkMjsgY29sb3I6I2E2MTcxN1wiKSxjb25zb2xlLmxvZyhoLmpvaW4oXCJcXG5cIikpfShuLHQuZ2V0U2hhZGVySW5mb0xvZyhyKSksbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNvbXBpbGUgZnJhZ21lbnQgc2hhZGVyLlwiKTtyZXR1cm4gcn12YXIgcXQsSHQsJHQ9L0VSUk9SOiBbMC05XSs6KFswLTldKyk6L2c7ZnVuY3Rpb24ganQodCxlKXtyZXR1cm4gaGUodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuY3JlYXRlUHJvZ3JhbSgpfSxcIlVuYWJsZSB0byBjcmVhdGUgV2ViR0xQcm9ncmFtLlwiKX1mdW5jdGlvbiBLdCh0LGUsbil7aWYoQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQubGlua1Byb2dyYW0obil9KSwhMT09PXQuZ2V0UHJvZ3JhbVBhcmFtZXRlcihuLHQuTElOS19TVEFUVVMpKXRocm93IGNvbnNvbGUubG9nKHQuZ2V0UHJvZ3JhbUluZm9Mb2cobikpLG5ldyBFcnJvcihcIkZhaWxlZCB0byBsaW5rIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVycy5cIil9ZnVuY3Rpb24gWHQodCxlLG4pe2lmKEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LnZhbGlkYXRlUHJvZ3JhbShuKX0pLCExPT09dC5nZXRQcm9ncmFtUGFyYW1ldGVyKG4sdC5WQUxJREFURV9TVEFUVVMpKXRocm93IGNvbnNvbGUubG9nKHQuZ2V0UHJvZ3JhbUluZm9Mb2cobikpLG5ldyBFcnJvcihcIlNoYWRlciBwcm9ncmFtIHZhbGlkYXRpb24gZmFpbGVkLlwiKX1mdW5jdGlvbiBZdCh0LGUsbil7dmFyIHI9aGUodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuY3JlYXRlQnVmZmVyKCl9LFwiVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEJ1ZmZlclwiKTtyZXR1cm4gQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZEJ1ZmZlcih0LkFSUkFZX0JVRkZFUixyKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmJ1ZmZlckRhdGEodC5BUlJBWV9CVUZGRVIsbix0LlNUQVRJQ19EUkFXKX0pLHJ9ZnVuY3Rpb24gUXQodCxlLG4pe3ZhciByPWhlKHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmNyZWF0ZUJ1ZmZlcigpfSxcIlVuYWJsZSB0byBjcmVhdGUgV2ViR0xCdWZmZXJcIik7cmV0dXJuIEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmJpbmRCdWZmZXIodC5FTEVNRU5UX0FSUkFZX0JVRkZFUixyKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmJ1ZmZlckRhdGEodC5FTEVNRU5UX0FSUkFZX0JVRkZFUixuLHQuU1RBVElDX0RSQVcpfSkscn1mdW5jdGlvbiBKdCgpe3JldHVybiAyPT09YS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpPzE6NH1mdW5jdGlvbiBadCh0LGUpe3JldHVybiBoZSh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5jcmVhdGVUZXh0dXJlKCl9LFwiVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTFRleHR1cmUuXCIpfWZ1bmN0aW9uIHRlKHQsZSl7dmFyIG49YS5nZXROdW1iZXIoXCJXRUJHTF9NQVhfVEVYVFVSRV9TSVpFXCIpO2lmKHQ8PTB8fGU8PTApe3ZhciByPVwiW1wiK3QrXCJ4XCIrZStcIl1cIjt0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0ZWQgdGV4dHVyZSBzaXplIFwiK3IrXCIgaXMgaW52YWxpZC5cIil9aWYodD5ufHxlPm4pe3I9XCJbXCIrdCtcInhcIitlK1wiXVwiO3Rocm93IG5ldyBFcnJvcihcIlJlcXVlc3RlZCB0ZXh0dXJlIHNpemUgXCIrcitcIiBncmVhdGVyIHRoYW4gV2ViR0wgbWF4aW11bSBvbiB0aGlzIGJyb3dzZXIgLyBHUFUgXCIrKFwiW1wiK24rXCJ4XCIrbitcIl1cIikrXCIuXCIpfX1mdW5jdGlvbiBlZSh0LGUpe3JldHVybiBoZSh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5jcmVhdGVGcmFtZWJ1ZmZlcigpfSxcIlVuYWJsZSB0byBjcmVhdGUgV2ViR0xGcmFtZWJ1ZmZlci5cIil9ZnVuY3Rpb24gbmUodCxlLG4scixvLGEsaSxzKXt2YXIgdT10LmdldEF0dHJpYkxvY2F0aW9uKG4scik7cmV0dXJuLTEhPT11JiYoQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZEJ1ZmZlcih0LkFSUkFZX0JVRkZFUixvKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LnZlcnRleEF0dHJpYlBvaW50ZXIodSxhLHQuRkxPQVQsITEsaSxzKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHUpfSksITApfWZ1bmN0aW9uIHJlKHQsZSxuLHIpe3BlKHQsciksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYWN0aXZlVGV4dHVyZSh0LlRFWFRVUkUwK3IpfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG4pfSl9ZnVuY3Rpb24gb2UodCxlLG4scil7cmV0dXJuIGhlKHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmdldFVuaWZvcm1Mb2NhdGlvbihuLHIpfSwndW5pZm9ybSBcIicrcisnXCIgbm90IHByZXNlbnQgaW4gcHJvZ3JhbS4nKX1mdW5jdGlvbiBhZSh0LGUsbil7cmV0dXJuIHQuZ2V0VW5pZm9ybUxvY2F0aW9uKGUsbil9ZnVuY3Rpb24gaWUodCxlLG4scixvLGEpe0J0KHQsZSxmdW5jdGlvbigpe3JldHVybiByZSh0LGUscixhKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LnVuaWZvcm0xaShvLGEpfSl9ZnVuY3Rpb24gc2UodCxlLG4scil7QnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIscil9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh0LkZSQU1FQlVGRkVSLHQuQ09MT1JfQVRUQUNITUVOVDAsdC5URVhUVVJFXzJELG4sMCl9KX1mdW5jdGlvbiB1ZSh0LGUsbil7QnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsbil9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh0LkZSQU1FQlVGRkVSLHQuQ09MT1JfQVRUQUNITUVOVDAsdC5URVhUVVJFXzJELG51bGwsMCl9KX1mdW5jdGlvbiBsZSh0KXt2YXIgZT10LmNoZWNrRnJhbWVidWZmZXJTdGF0dXModC5GUkFNRUJVRkZFUik7aWYoZSE9PXQuRlJBTUVCVUZGRVJfQ09NUExFVEUpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgYmluZGluZyBmcmFtZWJ1ZmZlcjogXCIrY2UodCxlKSl9ZnVuY3Rpb24gY2UodCxlKXtzd2l0Y2goZSl7Y2FzZSB0LkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVDpyZXR1cm5cIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVFwiO2Nhc2UgdC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVDpyZXR1cm5cIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UXCI7Y2FzZSB0LkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUzpyZXR1cm5cIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OU1wiO2Nhc2UgdC5GUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDpyZXR1cm5cIkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEXCI7ZGVmYXVsdDpyZXR1cm5cInVua25vd24gZXJyb3IgXCIrZX19ZnVuY3Rpb24gaGUodCxlLG4scil7dmFyIG89QnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIG4oKX0pO2lmKG51bGw9PW8pdGhyb3cgbmV3IEVycm9yKHIpO3JldHVybiBvfWZ1bmN0aW9uIHBlKHQsZSl7dmFyIG49dC5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUy0xLHI9ZSt0LlRFWFRVUkUwO2lmKHI8dC5URVhUVVJFMHx8cj5uKXRocm93IG5ldyBFcnJvcihcInRleHR1cmVVbml0IG11c3QgYmUgaW4gXCIrKFwiW2dsLlRFWFRVUkUwLCBnbC5URVhUVVJFXCIrbitcIl1cIikrXCIuXCIpfWZ1bmN0aW9uIGZlKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTIpLHkodC5zbGljZSgwLHQubGVuZ3RoLWUpKX1mdW5jdGlvbiBkZSh0KXtpZigwPT09dC5sZW5ndGgpdGhyb3cgRXJyb3IoXCJDYW5ub3QgZ2V0IHJvd3MgYW5kIGNvbHVtbnMgb2YgYW4gZW1wdHkgc2hhcGUgYXJyYXkuXCIpO3JldHVyblt0Lmxlbmd0aD4xP3RbdC5sZW5ndGgtMl06MSx0W3QubGVuZ3RoLTFdXX1mdW5jdGlvbiB2ZSh0LGUpe3ZhciBuO3ZvaWQgMD09PWUmJihlPSExKTt2YXIgcj1hLmdldE51bWJlcihcIldFQkdMX01BWF9URVhUVVJFX1NJWkVcIik7aWYoZSYmKHIqPTIsMT09PSh0PXQubWFwKGZ1bmN0aW9uKGUsbil7cmV0dXJuIG4+PXQubGVuZ3RoLTI/cCh0W25dKTp0W25dfSkpLmxlbmd0aCYmKHQ9WzIsdFswXV0pKSwyIT09dC5sZW5ndGgpe3ZhciBvPWsodCk7dD1vLm5ld1NoYXBlfXZhciBpPXkodCk7aWYodC5sZW5ndGg8PTEmJmk8PXIpcmV0dXJuWzEsaV07aWYoMj09PXQubGVuZ3RoJiZ0WzBdPD1yJiZ0WzFdPD1yKXJldHVybiB0O2lmKDM9PT10Lmxlbmd0aCYmdFswXSp0WzFdPD1yJiZ0WzJdPD1yKXJldHVyblt0WzBdKnRbMV0sdFsyXV07aWYoMz09PXQubGVuZ3RoJiZ0WzBdPD1yJiZ0WzFdKnRbMl08PXIpcmV0dXJuW3RbMF0sdFsxXSp0WzJdXTtpZig0PT09dC5sZW5ndGgmJnRbMF0qdFsxXSp0WzJdPD1yJiZ0WzNdPD1yKXJldHVyblt0WzBdKnRbMV0qdFsyXSx0WzNdXTtpZig0PT09dC5sZW5ndGgmJnRbMF08PXImJnRbMV0qdFsyXSp0WzNdPD1yKXJldHVyblt0WzBdLHRbMV0qdFsyXSp0WzNdXTtpZihlKXt2YXIgcz1mZSh0KSx1PTIsbD0yO3JldHVybiB0Lmxlbmd0aCYmKHU9KG49ZGUodCkpWzBdLGw9blsxXSksQyhpPXMqKHUvMikqKGwvMikpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gMip0fSl9cmV0dXJuIEMoaSl9ZnVuY3Rpb24gbWUodCl7cmV0dXJuIHQlMj09MH1mdW5jdGlvbiBnZSh0LGUpe2lmKHgodD10LnNsaWNlKC0yKSxlPWUuc2xpY2UoLTIpKSlyZXR1cm4hMDtpZighdC5sZW5ndGh8fCFlLmxlbmd0aClyZXR1cm4hMDtpZigwPT09dFswXXx8MD09PXRbMV18fDA9PT1lWzBdfHwwPT09ZVsxXSlyZXR1cm4hMDtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXt2YXIgbj10LnNsaWNlKC0xKVswXSxyPWUuc2xpY2UoLTEpWzBdO2lmKG49PT1yKXJldHVybiEwO2lmKG1lKG4pJiZtZShyKSYmKDE9PT10WzBdfHwxPT09ZVswXSkpcmV0dXJuITB9cmV0dXJuIHRbMV09PT1lWzFdJiZtZSh0WzBdKSYmbWUoZVswXSl9ZnVuY3Rpb24geWUodCl7aWYobnVsbD09cXQpe3ZhciBlPUZ0KHQpO3F0PWUuZ2V0UGFyYW1ldGVyKGUuTUFYX1RFWFRVUkVfU0laRSl9cmV0dXJuIHF0fWZ1bmN0aW9uIHhlKHQpe2lmKG51bGw9PUh0KXt2YXIgZT1GdCh0KTtIdD1lLmdldFBhcmFtZXRlcihlLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKX1yZXR1cm4gTWF0aC5taW4oMTYsSHQpfWZ1bmN0aW9uIHdlKHQpe2lmKDA9PT10KXJldHVybiAwO3ZhciBlPUZ0KHQpO3JldHVybiBiZShlLFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMlwiKSYmMj09PXQ/MjpiZShlLFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5XCIpPzE6MH1mdW5jdGlvbiBiZSh0LGUpe3JldHVybiBudWxsIT10LmdldEV4dGVuc2lvbihlKX1mdW5jdGlvbiBDZSh0KXt0cnl7aWYobnVsbCE9RnQodCkpcmV0dXJuITB9Y2F0Y2godCl7cmV0dXJuITF9cmV0dXJuITF9ZnVuY3Rpb24gRWUodCl7aWYoMD09PXQpcmV0dXJuITE7dmFyIGU9RnQodCk7aWYoMT09PXQpe2lmKCFiZShlLFwiT0VTX3RleHR1cmVfZmxvYXRcIikpcmV0dXJuITF9ZWxzZSBpZighYmUoZSxcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIikpcmV0dXJuITE7cmV0dXJuIFNlKGUsdCl9ZnVuY3Rpb24gUmUodCl7aWYoMD09PXQpcmV0dXJuITE7dmFyIGU9RnQodCk7aWYoMT09PXQpe2lmKCFiZShlLFwiT0VTX3RleHR1cmVfZmxvYXRcIikpcmV0dXJuITE7aWYoIWJlKGUsXCJXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXRcIikpcmV0dXJuITF9ZWxzZSBpZighYmUoZSxcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIikpcmV0dXJuITE7cmV0dXJuIFNlKGUsdCl9ZnVuY3Rpb24gU2UodCxlKXt2YXIgbj10LmNyZWF0ZUZyYW1lYnVmZmVyKCkscj10LmNyZWF0ZVRleHR1cmUoKTt0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxyKTt2YXIgbz0yPT09ZT90LlJHQkEzMkY6dC5SR0JBO3QudGV4SW1hZ2UyRCh0LlRFWFRVUkVfMkQsMCxvLDEsMSwwLHQuUkdCQSx0LkZMT0FULG51bGwpLHQuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsbiksdC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh0LkZSQU1FQlVGRkVSLHQuQ09MT1JfQVRUQUNITUVOVDAsdC5URVhUVVJFXzJELHIsMCk7dmFyIGE9dC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKHQuRlJBTUVCVUZGRVIpPT09dC5GUkFNRUJVRkZFUl9DT01QTEVURTtyZXR1cm4gdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbnVsbCksdC5iaW5kRnJhbWVidWZmZXIodC5GUkFNRUJVRkZFUixudWxsKSx0LmRlbGV0ZVRleHR1cmUociksdC5kZWxldGVGcmFtZWJ1ZmZlcihuKSxhfWZ1bmN0aW9uIE5lKHQpe3JldHVybiAyPT09dCYmbnVsbCE9RnQodCkuZmVuY2VTeW5jfXZhciBrZT1PYmplY3QuZnJlZXplKHtjYWxsQW5kQ2hlY2s6QnQsY2FuQmVSZXByZXNlbnRlZDpXdCxnZXRXZWJHTEVycm9yTWVzc2FnZTpVdCxnZXRFeHRlbnNpb25PclRocm93Onp0LGNyZWF0ZVZlcnRleFNoYWRlcjpWdCxjcmVhdGVGcmFnbWVudFNoYWRlcjpHdCxjcmVhdGVQcm9ncmFtOmp0LGxpbmtQcm9ncmFtOkt0LHZhbGlkYXRlUHJvZ3JhbTpYdCxjcmVhdGVTdGF0aWNWZXJ0ZXhCdWZmZXI6WXQsY3JlYXRlU3RhdGljSW5kZXhCdWZmZXI6UXQsZ2V0TnVtQ2hhbm5lbHM6SnQsY3JlYXRlVGV4dHVyZTpadCx2YWxpZGF0ZVRleHR1cmVTaXplOnRlLGNyZWF0ZUZyYW1lYnVmZmVyOmVlLGJpbmRWZXJ0ZXhCdWZmZXJUb1Byb2dyYW1BdHRyaWJ1dGU6bmUsYmluZFRleHR1cmVVbml0OnJlLHVuYmluZFRleHR1cmVVbml0OmZ1bmN0aW9uKHQsZSxuKXtwZSh0LG4pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmFjdGl2ZVRleHR1cmUodC5URVhUVVJFMCtuKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKX0pfSxnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uT3JUaHJvdzpvZSxnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uOmFlLGJpbmRUZXh0dXJlVG9Qcm9ncmFtVW5pZm9ybVNhbXBsZXI6aWUsYmluZENhbnZhc1RvRnJhbWVidWZmZXI6ZnVuY3Rpb24odCxlKXtCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kRnJhbWVidWZmZXIodC5GUkFNRUJVRkZFUixudWxsKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LnZpZXdwb3J0KDAsMCx0LmNhbnZhcy53aWR0aCx0LmNhbnZhcy5oZWlnaHQpfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuc2Npc3NvcigwLDAsdC5jYW52YXMud2lkdGgsdC5jYW52YXMuaGVpZ2h0KX0pfSxiaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcjpzZSx1bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXI6dWUsdmFsaWRhdGVGcmFtZWJ1ZmZlcjpsZSxnZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZTpjZSxnZXRCYXRjaERpbTpmZSxnZXRSb3dzQ29sczpkZSxnZXRUZXh0dXJlU2hhcGVGcm9tTG9naWNhbFNoYXBlOnZlLGlzUmVzaGFwZUZyZWU6Z2UsZ2V0IE1BWF9URVhUVVJFX1NJWkUoKXtyZXR1cm4gcXR9LGdldCBNQVhfVEVYVFVSRVNfSU5fU0hBREVSKCl7cmV0dXJuIEh0fSxnZXRXZWJHTE1heFRleHR1cmVTaXplOnllLGdldE1heFRleHR1cmVzSW5TaGFkZXI6eGUsZ2V0V2ViR0xEaXNqb2ludFF1ZXJ5VGltZXJWZXJzaW9uOndlLGlzV2ViR0xWZXJzaW9uRW5hYmxlZDpDZSxpc1JlbmRlclRvRmxvYXRUZXh0dXJlRW5hYmxlZDpFZSxpc0Rvd25sb2FkRmxvYXRUZXh0dXJlRW5hYmxlZDpSZSxpc1dlYkdMRmVuY2VFbmFibGVkOk5lfSk7ZnVuY3Rpb24gSWUoKXthLnNldChcIlBST0RcIiwhMCl9ZnVuY3Rpb24gQWUoKXthLnNldChcIkRFQlVHXCIsITApfWZ1bmN0aW9uIFRlKCl7YS5zZXQoXCJERVBSRUNBVElPTl9XQVJOSU5HU19FTkFCTEVEXCIsITEpLGNvbnNvbGUud2FybihcIlRlbnNvckZsb3cuanMgZGVwcmVjYXRpb24gd2FybmluZ3MgaGF2ZSBiZWVuIGRpc2FibGVkLlwiKX1mdW5jdGlvbiBEZSh0KXthLmdldEJvb2woXCJERVBSRUNBVElPTl9XQVJOSU5HU19FTkFCTEVEXCIpJiZjb25zb2xlLndhcm4odCtcIiBZb3UgY2FuIGRpc2FibGUgZGVwcmVjYXRpb24gd2FybmluZ3Mgd2l0aCB0Zi5kaXNhYmxlRGVwcmVjYXRpb25XYXJuaW5ncygpLlwiKX1mdW5jdGlvbiBPZSgpe0R0LmRpc3Bvc2VWYXJpYWJsZXMoKX1mdW5jdGlvbiBfZSgpe3JldHVybiBEdC5tZW1vcnkoKX1mdW5jdGlvbiBNZSh0KXtyZXR1cm4gRHQucHJvZmlsZSh0KX1mdW5jdGlvbiBGZSh0LGUpe3JldHVybiBEdC50aWR5KHQsZSl9ZnVuY3Rpb24gQmUodCl7TnQodCkuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gdC5kaXNwb3NlKCl9KX1mdW5jdGlvbiBQZSh0KXtyZXR1cm4gRHQua2VlcCh0KX1mdW5jdGlvbiBMZSh0KXtyZXR1cm4gRHQudGltZSh0KX1mdW5jdGlvbiBXZSh0KXtyZXR1cm4gRHQuc2V0QmFja2VuZCh0KX1mdW5jdGlvbiBVZSgpe3JldHVybiBEdC5yZWFkeSgpfWZ1bmN0aW9uIHplKCl7cmV0dXJuIER0LmJhY2tlbmROYW1lfWZ1bmN0aW9uIFZlKHQpe0R0LnJlbW92ZUJhY2tlbmQodCl9ZnVuY3Rpb24gR2UodCl7cmV0dXJuIER0LmZpbmRCYWNrZW5kKHQpfWZ1bmN0aW9uIHFlKHQpe3JldHVybiBEdC5maW5kQmFja2VuZEZhY3RvcnkodCl9ZnVuY3Rpb24gSGUodCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0xKSxEdC5yZWdpc3RlckJhY2tlbmQodCxlLG4pfWZ1bmN0aW9uICRlKCl7cmV0dXJuIER0LmJhY2tlbmR9ZnVuY3Rpb24gamUoKXtmb3IodmFyIHQ9W10sZT0wO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspdFtlXT1hcmd1bWVudHNbZV07YS5nZXRCb29sKFwiSVNfVEVTVFwiKXx8Y29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsdCl9ZnVuY3Rpb24gS2UodCxlLG4scil7dm9pZCAwPT09ciYmKHI9ITApO3ZhciBvPVtdO2lmKHIpKG89by5jb25jYXQoZS5zbGljZSgwKSkpLnB1c2godFswXS9uKSxvPW8uY29uY2F0KHQuc2xpY2UoMSkpO2Vsc2V7bz1vLmNvbmNhdCh0WzBdKTtmb3IodmFyIGE9ZS5sZW5ndGgsaT0wO2k8YTsrK2kpbz1vLmNvbmNhdChbdFtpKzFdL2VbaV0sZVtpXV0pO289by5jb25jYXQodC5zbGljZShhKzEpKX1yZXR1cm4gb31mdW5jdGlvbiBYZSh0LGUsbil7dm9pZCAwPT09biYmKG49ITApO3ZhciByPVtdO2lmKG4pe3IucHVzaChlKTtmb3IodmFyIG89ZSsxO288dDsrK28pbzw9MiplPyhyLnB1c2gobyksci5wdXNoKG8tKGUrMSkpKTpyLnB1c2gobyl9ZWxzZXt2YXIgYT1bXSxpPVtdO2ZvcihvPTE7bzx0OysrbylvPj0yKmUrMXx8byUyPT0xP2kucHVzaChvKTphLnB1c2gobyk7ci5wdXNoLmFwcGx5KHIsYSksci5wdXNoKDApLHIucHVzaC5hcHBseShyLGkpfXJldHVybiByfWZ1bmN0aW9uIFllKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPSEwKTt2YXIgbz1bXTtyP28ucHVzaCh0WzBdL24pOm8ucHVzaCh0WzBdKm4pO2Zvcih2YXIgYT0xO2E8dC5sZW5ndGg7KythKWE8PWUubGVuZ3RoP3I/by5wdXNoKGVbYS0xXSp0W2FdKTpvLnB1c2godFthXS9lW2EtMV0pOm8ucHVzaCh0W2FdKTtyZXR1cm4gb31mdW5jdGlvbiBRZSh0LGUpe2Zvcih2YXIgbj1bMF0scj0wO3I8ZTsrK3Ipbi5wdXNoKHRbcl1bMF0pO3JldHVybiBufWZ1bmN0aW9uIEplKHQsZSxuKXtmb3IodmFyIHI9dC5zbGljZSgwLDEpLG89MDtvPG47KytvKXIucHVzaCh0W28rMV0tZVtvXVswXS1lW29dWzFdKTtyZXR1cm4gcn1mdW5jdGlvbiBaZSh0LGUpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7KytuKWlmKHRbdC5sZW5ndGgtbi0xXSE9PWUtMS1uKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIHRuKHQsZSl7Zm9yKHZhciBuPVtdLHI9dC5sZW5ndGgsbz0wO288cjtvKyspLTE9PT1lLmluZGV4T2YobykmJm4ucHVzaCh0W29dKTtyZXR1cm5bbixlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gdFtlXX0pXX1mdW5jdGlvbiBlbih0LGUpe3JldHVybiBmdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPXQubGVuZ3RoK2UubGVuZ3RoLG89W10sYT0wLGk9MCxzPTA7czxyO3MrKyktMT09PW4uaW5kZXhPZihzKT9vLnB1c2godFthKytdKTpvLnB1c2goZVtpKytdKTtyZXR1cm4gb30odCxlLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gMX0pLGUpfWZ1bmN0aW9uIG5uKHQsZSxuKXtkKFplKGUsbiksZnVuY3Rpb24oKXtyZXR1cm4gdCtcIiBzdXBwb3J0cyBvbmx5IGlubmVyLW1vc3QgYXhlcyBmb3Igbm93LiBHb3QgYXhlcyBcIitlK1wiIGFuZCByYW5rLVwiK24rXCIgaW5wdXQuXCJ9KX1mdW5jdGlvbiBybih0LGUpe2lmKFplKHQsZSkpcmV0dXJuIG51bGw7Zm9yKHZhciBuPVtdLHI9MDtyPGU7KytyKS0xPT09dC5pbmRleE9mKHIpJiZuLnB1c2gocik7cmV0dXJuIHQuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gbi5wdXNoKHQpfSksbn1mdW5jdGlvbiBvbih0KXtyZXR1cm4gdC5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm5bZSx0XX0pLnNvcnQoZnVuY3Rpb24odCxlKXtyZXR1cm4gdFsxXS1lWzFdfSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0WzBdfSl9ZnVuY3Rpb24gYW4odCxlKXtmb3IodmFyIG49W10scj1lLXQ7cjxlOysrciluLnB1c2gocik7cmV0dXJuIG59ZnVuY3Rpb24gc24odCxlKXtmb3IodmFyIG49dFswXS5zbGljZSgpLHI9MTtyPHQubGVuZ3RoO3IrKyluW2VdKz10W3JdW2VdO3JldHVybiBufWZ1bmN0aW9uIHVuKHQsZSl7aWYodC5yYW5rPDEpdGhyb3cgbmV3IEVycm9yKFwidGYuZ2F0aGVyTkQoKSBleHBlY3RzIHRoZSBpbnB1dCB0byBiZSByYW5rIDEgb3IgaGlnaGVyLCBidXQgdGhlIHJhbmsgd2FzIFwiK3QucmFuaytcIi5cIik7aWYoZS5yYW5rPDEpdGhyb3cgbmV3IEVycm9yKFwidGYuZ2F0aGVyTkQoKSBleHBlY3RzIHRoZSBpbmRpY2VzIHRvIGJlIHJhbmsgMSBvciBoaWdoZXIsIGJ1dCB0aGUgcmFuayB3YXMgXCIrZS5yYW5rK1wiLlwiKTtpZihcImludDMyXCIhPT1lLmR0eXBlKXRocm93IG5ldyBFcnJvcihcInRmLmdhdGhlck5EKCkgZXhwZWN0cyB0aGUgaW5kaWNlcyB0byBiZSBpbnQzMiB0eXBlLCBidXQgdGhlIGR0eXBlIHdhcyBcIitlLmR0eXBlK1wiLlwiKTtpZihlLnNoYXBlW2UucmFuay0xXT50LnJhbmspdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggaW5uZXJtb3N0IGRpbWVuc2lvbiBsZW5ndGggbXVzdCBiZSA8PSB0ZW5zb3IgcmFuazsgc2F3OiBcIitlLnNoYXBlW2UucmFuay0xXStcIiB2cy4gXCIrdC5yYW5rKTtpZigwPT09dC5zaXplKXRocm93IG5ldyBFcnJvcihcIlJlcXVlc3RlZCBtb3JlIHRoYW4gMCBlbnRyaWVzLCBidXQgaW5wdXQgaXMgZW1wdHkuIElucHV0IHNoYXBlOiBcIit0LnNoYXBlK1wiLlwiKTtmb3IodmFyIG49ZS5zaGFwZSxyPW5bbi5sZW5ndGgtMV0sbz0xLGE9MDthPG4ubGVuZ3RoLTE7KythKW8qPW5bYV07dmFyIGk9dC5zaGFwZSxzPW4uc2xpY2UoKTtzLnBvcCgpO3ZhciB1PTE7Zm9yKGE9cjthPHQucmFuazsrK2EpdSo9aVthXSxzLnB1c2goaVthXSk7dmFyIGw9Vih0LnNoYXBlKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQvdX0pLmNvbmNhdChbMV0pLnNsaWNlKDAscik7cmV0dXJuW3Msbyx1LGxdfWEucmVnaXN0ZXJGbGFnKFwiSEFTX1dFQkdMXCIsZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpPjB9KSxhLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1ZFUlNJT05cIixmdW5jdGlvbigpe3JldHVybiBDZSgyKT8yOkNlKDEpPzE6MH0pLGEucmVnaXN0ZXJGbGFnKFwiV0VCR0xfQlVGRkVSX1NVUFBPUlRFRFwiLGZ1bmN0aW9uKCl7cmV0dXJuIDI9PT1hLmdldChcIldFQkdMX1ZFUlNJT05cIil9KSxhLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0NQVV9GT1JXQVJEXCIsZnVuY3Rpb24oKXtyZXR1cm4hMX0pLGEucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS1wiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZ2V0Qm9vbChcIkhBU19XRUJHTFwiKX0pLGEucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19OT1JNQUxJWkFUSU9OXCIsZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKX0pLGEucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19DTElQXCIsZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKX0pLGEucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19ERVBUSFdJU0VDT05WXCIsZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKX0pLGEucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSxhLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSxhLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfSU1BR0VfT1BFUkFUSU9OU1wiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSxhLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfUkVEVUNFXCIsZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKX0pLGEucmVnaXN0ZXJGbGFnKFwiV0VCR0xfTEFaSUxZX1VOUEFDS1wiLGZ1bmN0aW9uKCl7cmV0dXJuIGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSxhLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0NPTlZfSU0yQ09MXCIsZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKX0pLGEucmVnaXN0ZXJGbGFnKFwiV0VCR0xfTUFYX1RFWFRVUkVfU0laRVwiLGZ1bmN0aW9uKCl7cmV0dXJuIHllKGEuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSl9KSxhLnJlZ2lzdGVyRmxhZyhcIldFQkdMX01BWF9URVhUVVJFU19JTl9TSEFERVJcIixmdW5jdGlvbigpe3JldHVybiB4ZShhLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpfSksYS5yZWdpc3RlckZsYWcoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiLGZ1bmN0aW9uKCl7dmFyIHQ9YS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpO3JldHVybiAwPT09dD8wOndlKHQpfSksYS5yZWdpc3RlckZsYWcoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fUkVMSUFCTEVcIixmdW5jdGlvbigpe3JldHVybiBhLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpPjAmJih0PW5hdmlnYXRvci51c2VyQWdlbnR8fG5hdmlnYXRvci52ZW5kb3J8fHdpbmRvdy5vcGVyYSwhKC8oYW5kcm9pZHxiYlxcZCt8bWVlZ28pLittb2JpbGV8YXZhbnRnb3xiYWRhXFwvfGJsYWNrYmVycnl8YmxhemVyfGNvbXBhbHxlbGFpbmV8ZmVubmVjfGhpcHRvcHxpZW1vYmlsZXxpcChob25lfG9kKXxpcmlzfGtpbmRsZXxsZ2UgfG1hZW1vfG1pZHB8bW1wfG1vYmlsZS4rZmlyZWZveHxuZXRmcm9udHxvcGVyYSBtKG9ifGluKWl8cGFsbSggb3MpP3xwaG9uZXxwKGl4aXxyZSlcXC98cGx1Y2tlcnxwb2NrZXR8cHNwfHNlcmllcyg0fDYpMHxzeW1iaWFufHRyZW98dXBcXC4oYnJvd3NlcnxsaW5rKXx2b2RhZm9uZXx3YXB8d2luZG93cyBjZXx4ZGF8eGlpbm8vaS50ZXN0KHQpfHwvMTIwN3w2MzEwfDY1OTB8M2dzb3w0dGhwfDUwWzEtNl1pfDc3MHN8ODAyc3xhIHdhfGFiYWN8YWMoZXJ8b298c1xcLSl8YWkoa298cm4pfGFsKGF2fGNhfGNvKXxhbW9pfGFuKGV4fG55fHl3KXxhcHR1fGFyKGNofGdvKXxhcyh0ZXx1cyl8YXR0d3xhdShkaXxcXC1tfHIgfHMgKXxhdmFufGJlKGNrfGxsfG5xKXxiaShsYnxyZCl8YmwoYWN8YXopfGJyKGV8dil3fGJ1bWJ8YndcXC0obnx1KXxjNTVcXC98Y2FwaXxjY3dhfGNkbVxcLXxjZWxsfGNodG18Y2xkY3xjbWRcXC18Y28obXB8bmQpfGNyYXd8ZGEoaXR8bGx8bmcpfGRidGV8ZGNcXC1zfGRldml8ZGljYXxkbW9ifGRvKGN8cClvfGRzKDEyfFxcLWQpfGVsKDQ5fGFpKXxlbShsMnx1bCl8ZXIoaWN8azApfGVzbDh8ZXooWzQtN10wfG9zfHdhfHplKXxmZXRjfGZseShcXC18Xyl8ZzEgdXxnNTYwfGdlbmV8Z2ZcXC01fGdcXC1tb3xnbyhcXC53fG9kKXxncihhZHx1bil8aGFpZXxoY2l0fGhkXFwtKG18cHx0KXxoZWlcXC18aGkocHR8dGEpfGhwKCBpfGlwKXxoc1xcLWN8aHQoYyhcXC18IHxffGF8Z3xwfHN8dCl8dHApfGh1KGF3fHRjKXxpXFwtKDIwfGdvfG1hKXxpMjMwfGlhYyggfFxcLXxcXC8pfGlicm98aWRlYXxpZzAxfGlrb218aW0xa3xpbm5vfGlwYXF8aXJpc3xqYSh0fHYpYXxqYnJvfGplbXV8amlnc3xrZGRpfGtlaml8a2d0KCB8XFwvKXxrbG9ufGtwdCB8a3djXFwtfGt5byhjfGspfGxlKG5vfHhpKXxsZyggZ3xcXC8oa3xsfHUpfDUwfDU0fFxcLVthLXddKXxsaWJ3fGx5bnh8bTFcXC13fG0zZ2F8bTUwXFwvfG1hKHRlfHVpfHhvKXxtYygwMXwyMXxjYSl8bVxcLWNyfG1lKHJjfHJpKXxtaShvOHxvYXx0cyl8bW1lZnxtbygwMXwwMnxiaXxkZXxkb3x0KFxcLXwgfG98dil8enopfG10KDUwfHAxfHYgKXxtd2JwfG15d2F8bjEwWzAtMl18bjIwWzItM118bjMwKDB8Mil8bjUwKDB8Mnw1KXxuNygwKDB8MSl8MTApfG5lKChjfG0pXFwtfG9ufHRmfHdmfHdnfHd0KXxub2soNnxpKXxuenBofG8yaW18b3AodGl8d3YpfG9yYW58b3dnMXxwODAwfHBhbihhfGR8dCl8cGR4Z3xwZygxM3xcXC0oWzEtOF18YykpfHBoaWx8cGlyZXxwbChheXx1Yyl8cG5cXC0yfHBvKGNrfHJ0fHNlKXxwcm94fHBzaW98cHRcXC1nfHFhXFwtYXxxYygwN3wxMnwyMXwzMnw2MHxcXC1bMi03XXxpXFwtKXxxdGVrfHIzODB8cjYwMHxyYWtzfHJpbTl8cm8odmV8em8pfHM1NVxcL3xzYShnZXxtYXxtbXxtc3xueXx2YSl8c2MoMDF8aFxcLXxvb3xwXFwtKXxzZGtcXC98c2UoYyhcXC18MHwxKXw0N3xtY3xuZHxyaSl8c2doXFwtfHNoYXJ8c2llKFxcLXxtKXxza1xcLTB8c2woNDV8aWQpfHNtKGFsfGFyfGIzfGl0fHQ1KXxzbyhmdHxueSl8c3AoMDF8aFxcLXx2XFwtfHYgKXxzeSgwMXxtYil8dDIoMTh8NTApfHQ2KDAwfDEwfDE4KXx0YShndHxsayl8dGNsXFwtfHRkZ1xcLXx0ZWwoaXxtKXx0aW1cXC18dFxcLW1vfHRvKHBsfHNoKXx0cyg3MHxtXFwtfG0zfG01KXx0eFxcLTl8dXAoXFwuYnxnMXxzaSl8dXRzdHx2NDAwfHY3NTB8dmVyaXx2aShyZ3x0ZSl8dmsoNDB8NVswLTNdfFxcLXYpfHZtNDB8dm9kYXx2dWxjfHZ4KDUyfDUzfDYwfDYxfDcwfDgwfDgxfDgzfDg1fDk4KXx3M2MoXFwtfCApfHdlYmN8d2hpdHx3aShnIHxuY3xudyl8d21sYnx3b251fHg3MDB8eWFzXFwtfHlvdXJ8emV0b3x6dGVcXC0vaS50ZXN0KHQuc3Vic3RyKDAsNCkpKSk7dmFyIHR9KSxhLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIixmdW5jdGlvbigpe3JldHVybiBFZShhLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpfSksYS5yZWdpc3RlckZsYWcoXCJXRUJHTF9ET1dOTE9BRF9GTE9BVF9FTkFCTEVEXCIsZnVuY3Rpb24oKXtyZXR1cm4gUmUoYS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKX0pLGEucmVnaXN0ZXJGbGFnKFwiV0VCR0xfRkVOQ0VfQVBJX0VOQUJMRURcIixmdW5jdGlvbigpe3JldHVybiBOZShhLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpfSksYS5yZWdpc3RlckZsYWcoXCJXRUJHTF9TSVpFX1VQTE9BRF9VTklGT1JNXCIsZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXRCb29sKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRFwiKT80OjB9KSxwdD1EZTt2YXIgbG49MzA7ZnVuY3Rpb24gY24odCl7cmV0dXJuIHQ8PWxuP3Q6eih0LE1hdGguZmxvb3IoTWF0aC5zcXJ0KHQpKSl9ZnVuY3Rpb24gaG4odCxlLG4pe2lmKGUucmFuazwxKXRocm93IG5ldyBFcnJvcihcInRmLnNjYXR0ZXJORCgpIGV4cGVjdHMgdGhlIGluZGljZXMgdG8gYmUgcmFuayAxIG9yIGhpZ2hlciwgYnV0IHRoZSByYW5rIHdhcyBcIitlLnJhbmsrXCIuXCIpO2lmKHQucmFuazwxKXRocm93IG5ldyBFcnJvcihcInRmLnNjYXR0ZXJORCgpIGV4cGVjdHMgdGhlIHVwZGF0ZXMgdG8gYmUgcmFuayAxIG9yIGhpZ2hlciwgYnV0IHRoZSByYW5rIHdhcyBcIit0LnJhbmsrXCIuXCIpO2lmKFwiaW50MzJcIiE9PWUuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGR0eXBlIG9mICdpbmRpY2VzJyBzaG91bGQgYmUgaW50MzIsIGJ1dCBnb3QgZHR5cGU6IFwiK2UuZHR5cGUpO2lmKG4ubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiT3V0cHV0IHJhbmsgbXVzdCBiZSBncmVhdGVyIG9yIGVxdWFsIHRvIDEsIGJ1dCBnb3Qgc2hhcGU6IFwiK24pO2lmKDA9PT1uLmxlbmd0aCl7aWYoMD09PWUuc2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJJbmRpY2VzIHNwZWNpZmllZCBmb3IgZW1wdHkgb3V0cHV0LiBpbmRpY2VzIHNoYXBlOiBcIitlLnNoYXBlKTtpZigwPT09dC5zaXplKXRocm93IG5ldyBFcnJvcihcIlVwZGF0ZXMgc3BlY2lmaWVkIGZvciBlbXB0eSBvdXRwdXQuIHVwZGF0ZXMgc2hhcGU6IFwiK3Quc2hhcGUpfSFmdW5jdGlvbih0LGUsbil7dmFyIHI9ZS5yYW5rPjE/ZS5zaGFwZVtlLnJhbmstMV06MSxvPWUucmFuaz4xP2UucmFuay0xOjEsYT1cIk11c3QgaGF2ZSB1cGRhdGVzLnNoYXBlID0gaW5kaWNlcy5zaGFwZVs6YmF0Y2hEaW1dICsgc2hhcGVbc2xpY2VEaW06XSwgZ290IHVwZGF0ZXMuc2hhcGU6IFwiK24uc2hhcGUrXCIsIGluZGljZXMuc2hhcGU6IFwiK2Uuc2hhcGUrXCIsIHNoYXBlOiBcIit0K1wiLCBzbGljZURpbTogXCIrcitcIiwgYW5kIGJhdGNoRGltOiBcIitvK1wiLlwiO2lmKG4ucmFuazxvKXRocm93IG5ldyBFcnJvcihhK1wiIHVwZGF0ZS5yYW5rIDwgXCIrbytcIi4gXCIpO2lmKHQubGVuZ3RoPHIrKG4ucmFuay1vKSl0aHJvdyBuZXcgRXJyb3IoYStcIiBPdXRwdXQgc2hhcGUgbGVuZ3RoIDwgXCIrKHIrKG4ucmFuay1vKSkpO2lmKG4ucmFuayE9PW8rdC5sZW5ndGgtcil0aHJvdyBuZXcgRXJyb3IoYStcIiB1cGRhdGUucmFuayAhPSBcIisobyt0Lmxlbmd0aC1yKSk7Zm9yKHZhciBpPTA7aTxvOysraSlpZihuLnNoYXBlW2ldIT09ZS5zaGFwZVtpXSl0aHJvdyBuZXcgRXJyb3IoYStcIiB1cGRhdGVzLnNoYXBlW1wiK2krXCJdIChcIituLnNoYXBlW2ldK1wiKSAhPSBpbmRpY2VzLnNoYXBlW1wiK2krXCJdIChcIitlLnNoYXBlW2ldK1wiKS5cIik7Zm9yKGk9MDtpPG4ucmFuay1vOysraSlpZihuLnNoYXBlW2krb10hPT10W2krcl0pdGhyb3cgbmV3IEVycm9yKGErXCIgdXBkYXRlcy5zaGFwZVtcIisoaStvKStcIl0gKFwiK24uc2hhcGVbaStvXStcIikgIT0gc2hhcGVbXCIrKGkrbykrXCJdIChcIit0W2krb10rXCIpXCIpfShuLGUsdCl9ZnVuY3Rpb24gcG4odCxlLG4pe2Zvcih2YXIgcj1lLnJhbms+MT9lLnNoYXBlW2UucmFuay0xXToxLG89bi5sZW5ndGgsYT0xLGk9cjtpPG87KytpKWEqPW5baV07dmFyIHM9cjwxPzE6cjtyZXR1cm57c2xpY2VSYW5rOnIsbnVtVXBkYXRlczplLnNpemUvcyxzbGljZVNpemU6YSxzdHJpZGVzOlYobi5zbGljZSgwLHIpKS5jb25jYXQoWzFdKSxvdXRwdXRTaXplOnkobil9fWZ1bmN0aW9uIGZuKHQsZSxuLHIsbyxhLGkscyx1KXtpZih2b2lkIDA9PT1vJiYobz0wKSx2b2lkIDA9PT1hJiYoYT0wKSx2b2lkIDA9PT1pJiYoaT0wKSx2b2lkIDA9PT1zJiYocz0wKSx2b2lkIDA9PT11JiYodT0wKSwwIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJlbGxpcHNpcyBtYXNrIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO2lmKDAhPT1zKXRocm93IG5ldyBFcnJvcihcIm5ldyBheGlzIG1hc2sgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7Zm9yKHZhciBsPVtdLGM9W10saD1bXSxwPTA7cDx0Lmxlbmd0aDtwKyspbFtwXT1kbihvLGUscix0LHApLGNbcF09dm4oYSxuLHIsdCxwKSx1JjE8PHAmJihjW3BdPWxbcF0rMSxoLnB1c2gocCkpO3ZhciBmPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbCgwKTtyZXR1cm4gZj1mLm1hcChmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wLG89cltlXXx8MSxhPWxbZV07IShvPjA/YT49Y1tlXTphPD1jW2VdKTthKz1vKW4rPTE7cmV0dXJuIG59KSxbbCxmLGhdfWZ1bmN0aW9uIGRuKHQsZSxuLHIsbyl7dmFyIGE9ZVtvXSxpPW5bb118fDE7KHQmMTw8b3x8bnVsbD09YSkmJihhPWk+MD9OdW1iZXIuTUlOX1NBRkVfSU5URUdFUjpOdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7dmFyIHM9cltvXTtyZXR1cm4gYTwwJiYoYSs9cyksYT1oKDAsYSxzLTEpfWZ1bmN0aW9uIHZuKHQsZSxuLHIsbyl7dmFyIGE9ZVtvXSxpPW5bb118fDE7KHQmMTw8b3x8bnVsbD09YSkmJihhPWk+MD9OdW1iZXIuTUFYX1NBRkVfSU5URUdFUjpOdW1iZXIuTUlOX1NBRkVfSU5URUdFUik7dmFyIHM9cltvXTtyZXR1cm4gYTwwJiYoYSs9cyksYT1pPjA/aCgwLGEscyk6aCgtMSxhLHMtMSl9ZnVuY3Rpb24gbW4odCxlLG4pe2Zvcih2YXIgcj1uLmxlbmd0aCxvPTA7bzxuLmxlbmd0aDtvKyspaWYobltvXT4xKXtyPW87YnJlYWt9Zm9yKG89cisxO288bi5sZW5ndGg7bysrKWlmKGVbb10+MHx8bltvXSE9PXRbb10pcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gZ24odCxlKXtmb3IodmFyIG49dC5sZW5ndGg+MD90W3QubGVuZ3RoLTFdOjEscj0wO3I8dC5sZW5ndGgtMTtyKyspbis9dFtyXSplW3JdO3JldHVybiBufWZ1bmN0aW9uIHluKHQpe3ZhciBlPXQ7aWYoXyh0KSlyZXR1cm5bdC5sZW5ndGhdO2lmKCFBcnJheS5pc0FycmF5KHQpKXJldHVybltdO2Zvcih2YXIgbj1bXTtBcnJheS5pc0FycmF5KGUpfHxfKGUpOyluLnB1c2goZS5sZW5ndGgpLGU9ZVswXTtyZXR1cm4gQXJyYXkuaXNBcnJheSh0KSYmYS5nZXRCb29sKFwiVEVOU09STElLRV9DSEVDS19TSEFQRV9DT05TSVNURU5DWVwiKSYmZnVuY3Rpb24gdChlLG4scil7cj1yfHxbXTtpZighQXJyYXkuaXNBcnJheShlKSYmIV8oZSkpcmV0dXJuIHZvaWQgZCgwPT09bi5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIkVsZW1lbnQgYXJyW1wiK3Iuam9pbihcIl1bXCIpK1wiXSBpcyBhIHByaW1pdGl2ZSwgYnV0IHNob3VsZCBiZSBhbiBhcnJheS9UeXBlZEFycmF5IG9mIFwiK25bMF0rXCIgZWxlbWVudHNcIn0pO2Qobi5sZW5ndGg+MCxmdW5jdGlvbigpe3JldHVyblwiRWxlbWVudCBhcnJbXCIrci5qb2luKFwiXVtcIikrXCJdIHNob3VsZCBiZSBhIHByaW1pdGl2ZSwgYnV0IGlzIGFuIGFycmF5IG9mIFwiK2UubGVuZ3RoK1wiIGVsZW1lbnRzXCJ9KTtkKGUubGVuZ3RoPT09blswXSxmdW5jdGlvbigpe3JldHVyblwiRWxlbWVudCBhcnJbXCIrci5qb2luKFwiXVtcIikrXCJdIHNob3VsZCBoYXZlIFwiK25bMF0rXCIgZWxlbWVudHMsIGJ1dCBoYXMgXCIrZS5sZW5ndGgrXCIgZWxlbWVudHNcIn0pO3ZhciBvPW4uc2xpY2UoMSk7Zm9yKHZhciBhPTA7YTxlLmxlbmd0aDsrK2EpdChlW2FdLG8sci5jb25jYXQoYSkpfSh0LG4sW10pLG59ZnVuY3Rpb24geG4odCxlLG4scil7aWYobnVsbCE9dCYmKFwibnVtZXJpY1wiIT09dCYmdCE9PWV8fFwibnVtZXJpY1wiPT09dCYmXCJzdHJpbmdcIj09PWUpKXRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50ICdcIituK1wiJyBwYXNzZWQgdG8gJ1wiK3IrXCInIG11c3QgYmUgXCIrdCtcIiB0ZW5zb3IsIGJ1dCBnb3QgXCIrZStcIiB0ZW5zb3JcIil9ZnVuY3Rpb24gd24odCxlLG4scil7aWYodm9pZCAwPT09ciYmKHI9XCJudW1lcmljXCIpLHQgaW5zdGFuY2VvZiBmdClyZXR1cm4geG4ocix0LmR0eXBlLGUsbiksdDt2YXIgbz1XKHQpO2lmKFwic3RyaW5nXCIhPT1vJiZbXCJib29sXCIsXCJpbnQzMlwiLFwiZmxvYXQzMlwiXS5pbmRleE9mKHIpPj0wJiYobz1yKSx4bihyLG8sZSxuKSxudWxsPT10fHwhXyh0KSYmIUFycmF5LmlzQXJyYXkodCkmJlwibnVtYmVyXCIhPXR5cGVvZiB0JiZcImJvb2xlYW5cIiE9dHlwZW9mIHQmJlwic3RyaW5nXCIhPXR5cGVvZiB0KXt2YXIgaT1udWxsPT10P1wibnVsbFwiOnQuY29uc3RydWN0b3IubmFtZTt0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCAnXCIrZStcIicgcGFzc2VkIHRvICdcIituK1wiJyBtdXN0IGJlIGEgVGVuc29yIG9yIFRlbnNvckxpa2UsIGJ1dCBnb3QgJ1wiK2krXCInXCIpfXZhciBzPXluKHQpO18odCl8fEFycmF5LmlzQXJyYXkodCl8fCh0PVt0XSk7dmFyIHU9XCJzdHJpbmdcIiE9PW8/Ryh0LG8sYS5nZXRCb29sKFwiREVCVUdcIikpOmcodCk7cmV0dXJuIGZ0Lm1ha2Uocyx7dmFsdWVzOnV9LG8pfWZ1bmN0aW9uIGJuKHQsZSxuLHIpe2lmKHZvaWQgMD09PXImJihyPVwibnVtZXJpY1wiKSwhQXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCBcIitlK1wiIHBhc3NlZCB0byBcIituK1wiIG11c3QgYmUgYSBgVGVuc29yW11gIG9yIGBUZW5zb3JMaWtlW11gXCIpO3JldHVybiB0Lm1hcChmdW5jdGlvbih0LHIpe3JldHVybiB3bih0LGUrXCJbXCIrcitcIl1cIixuKX0scil9ZnVuY3Rpb24gQ24odCl7cmV0dXJuIGQoVSh0KSxmdW5jdGlvbigpe3JldHVyblwiVGhlIGYgcGFzc2VkIGluIGdyYWQoZikgbXVzdCBiZSBhIGZ1bmN0aW9uXCJ9KSxmdW5jdGlvbihlLG4pe3ZhciByPXduKGUsXCJ4XCIsXCJ0Zi5ncmFkXCIsbnVsbCksbz1udWxsIT1uP3duKG4sXCJkeVwiLFwidGYuZ3JhZFwiKTpudWxsO3JldHVybiBEdC50aWR5KGZ1bmN0aW9uKCl7dmFyIGU9RHQuZ3JhZGllbnRzKGZ1bmN0aW9uKCl7cmV0dXJuIHQocil9LFtyXSxvKSxuPWUudmFsdWUsYT1lLmdyYWRzO3JldHVybiBudWxsIT1vJiZ2KG4uc2hhcGUsby5zaGFwZSxcIlRoZSBzaGFwZSBvZiBkeSBwYXNzZWQgaW4gZ3JhZChmKSh4LCBkeSkgbXVzdCBtYXRjaCB0aGUgc2hhcGUgcmV0dXJuZWQgYnkgZih4KVwiKSxJbihhKSxhWzBdfSl9fWZ1bmN0aW9uIEVuKHQpe3JldHVybiBkKFUodCksZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmIHBhc3NlZCBpbiBncmFkcyhmKSBtdXN0IGJlIGEgZnVuY3Rpb25cIn0pLGZ1bmN0aW9uKGUsbil7ZChBcnJheS5pc0FycmF5KGUpLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgYXJncyBwYXNzZWQgaW4gZ3JhZHMoZikoYXJncykgbXVzdCBiZSBhbiBhcnJheSBvZiBgVGVuc29yYHMgb3IgYFRlbnNvckxpa2Vgc1wifSk7dmFyIHI9Ym4oZSxcImFyZ3NcIixcInRmLmdyYWRzXCIsbnVsbCksbz1udWxsIT1uP3duKG4sXCJkeVwiLFwidGYuZ3JhZHNcIik6bnVsbDtyZXR1cm4gRHQudGlkeShmdW5jdGlvbigpe3ZhciBlPUR0LmdyYWRpZW50cyhmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KHZvaWQgMCxyKX0scixvKSxuPWUudmFsdWUsYT1lLmdyYWRzO3JldHVybiBudWxsIT1vJiZ2KG4uc2hhcGUsby5zaGFwZSxcIlRoZSBzaGFwZSBvZiBkeSBwYXNzZWQgaW4gZ3JhZHMoZikoW3gxLC4uLl0sIGR5KSBtdXN0IG1hdGNoIHRoZSBzaGFwZSByZXR1cm5lZCBieSBmKFt4MSwuLi5dKVwiKSxJbihhKSxhfSl9fWZ1bmN0aW9uIFJuKHQpe3JldHVybiBkKFUodCksZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmIHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWQoZikgbXVzdCBiZSBhIGZ1bmN0aW9uXCJ9KSxmdW5jdGlvbihlLG4pe2QoZSBpbnN0YW5jZW9mIGZ0LGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgeCBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkKGYpKHgpIG11c3QgYmUgYSB0ZW5zb3JcIn0pLGQobnVsbD09bnx8biBpbnN0YW5jZW9mIGZ0LGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZHkgcGFzc2VkIGluIHZhbHVlQW5kR3JhZChmKSh4LCBkeSkgbXVzdCBiZSBhIHRlbnNvclwifSk7dmFyIHI9RHQuZ3JhZGllbnRzKGZ1bmN0aW9uKCl7cmV0dXJuIHQoZSl9LFtlXSxuKSxvPXIuZ3JhZHMsYT1yLnZhbHVlO3JldHVybiBJbihvKSx7Z3JhZDpvWzBdLHZhbHVlOmF9fX1mdW5jdGlvbiBTbih0KXtyZXR1cm4gZChVKHQpLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZiBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkcyhmKSBtdXN0IGJlIGEgZnVuY3Rpb25cIn0pLGZ1bmN0aW9uKGUsbil7ZChBcnJheS5pc0FycmF5KGUpJiZlLmV2ZXJ5KGZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgZnR9KSxmdW5jdGlvbigpe3JldHVyblwiVGhlIGFyZ3MgcGFzc2VkIGluIHZhbHVlQW5kR3JhZHMoZikoYXJncykgbXVzdCBiZSBhcnJheSBvZiB0ZW5zb3JzXCJ9KSxkKG51bGw9PW58fG4gaW5zdGFuY2VvZiBmdCxmdW5jdGlvbigpe3JldHVyblwiVGhlIGR5IHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWRzKGYpKGFyZ3MsIGR5KSBtdXN0IGJlIGEgdGVuc29yXCJ9KTt2YXIgcj1EdC5ncmFkaWVudHMoZnVuY3Rpb24oKXtyZXR1cm4gdC5hcHBseSh2b2lkIDAsZSl9LGUsbik7cmV0dXJuIG51bGwhPW4mJnYoci52YWx1ZS5zaGFwZSxuLnNoYXBlLFwiVGhlIHNoYXBlIG9mIGR5IHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWRzKGYpKFt4MSwuLi5dLCBkeSkgbXVzdCBtYXRjaCB0aGUgc2hhcGUgcmV0dXJuZWQgYnkgZihbeDEsLi4uXSlcIiksSW4oci5ncmFkcykscn19ZnVuY3Rpb24gTm4odCxlKXtpZihkKFUodCksZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmIHBhc3NlZCBpbiB2YXJpYWJsZUdyYWRzKGYpIG11c3QgYmUgYSBmdW5jdGlvblwifSksZChudWxsPT1lfHxBcnJheS5pc0FycmF5KGUpJiZlLmV2ZXJ5KGZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgZHR9KSxmdW5jdGlvbigpe3JldHVyblwiVGhlIHZhckxpc3QgcGFzc2VkIGluIHZhcmlhYmxlR3JhZHMoZiwgdmFyTGlzdCkgbXVzdCBiZSBhbiBhcnJheSBvZiB2YXJpYWJsZXNcIn0pLG51bGw9PWUpZm9yKHZhciBuIGluIGU9W10sRHQucmVnaXN0ZXJlZFZhcmlhYmxlcyllLnB1c2goRHQucmVnaXN0ZXJlZFZhcmlhYmxlc1tuXSk7dmFyIHI9ZS5sZW5ndGg7ZCgoZT1lLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gdC50cmFpbmFibGV9KSkubGVuZ3RoPjAsZnVuY3Rpb24oKXtyZXR1cm5cInZhcmlhYmxlR3JhZHMoKSBleHBlY3RzIGF0IGxlYXN0IG9uZSBvZiB0aGUgaW5wdXQgdmFyaWFibGVzIHRvIGJlIHRyYWluYWJsZSwgYnV0IG5vbmUgb2YgdGhlIFwiK3IrXCIgdmFyaWFibGVzIGlzIHRyYWluYWJsZS5cIn0pO3ZhciBvPUR0LmdyYWRpZW50cyh0LGUsbnVsbCwhMCksYT1vLnZhbHVlLGk9by5ncmFkcztkKGkuc29tZShmdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9dH0pLGZ1bmN0aW9uKCl7cmV0dXJuXCJDYW5ub3QgZmluZCBhIGNvbm5lY3Rpb24gYmV0d2VlbiBhbnkgdmFyaWFibGUgYW5kIHRoZSByZXN1bHQgb2YgdGhlIGxvc3MgZnVuY3Rpb24geT1mKHgpLiBQbGVhc2UgbWFrZSBzdXJlIHRoZSBvcGVyYXRpb25zIHRoYXQgdXNlIHZhcmlhYmxlcyBhcmUgaW5zaWRlIHRoZSBmdW5jdGlvbiBmIHBhc3NlZCB0byBtaW5pbWl6ZSgpLlwifSksZCgwPT09YS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZiBwYXNzZWQgaW4gdmFyaWFibGVHcmFkcyhmKSBtdXN0IHJldHVybiBhIHNjYWxhciwgYnV0IGl0IHJldHVybmVkIGEgcmFuay1cIithLnJhbmsrXCIgdGVuc29yXCJ9KTt2YXIgcz17fTtyZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKHQsZSl7bnVsbCE9aVtlXSYmKHNbdC5uYW1lXT1pW2VdKX0pLHt2YWx1ZTphLGdyYWRzOnN9fWZ1bmN0aW9uIGtuKHQpe3JldHVybiBEdC5jdXN0b21HcmFkKHQpfWZ1bmN0aW9uIEluKHQpe2lmKHQuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT10fSkubGVuZ3RoPjApdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgZ3JhZGllbnQgb2YgeT1mKHgpIHdpdGggcmVzcGVjdCB0byB4LiBNYWtlIHN1cmUgdGhhdFxcbiAgICB0aGUgZiB5b3UgcGFzc2VkIGVuY2xvc2VzIGFsbCBvcGVyYXRpb25zIHRoYXQgbGVhZCBmcm9tIHggdG8geS5cIil9ZnVuY3Rpb24gQW4odCl7dmFyIGU9T2JqZWN0LmtleXModCk7aWYoMSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGFuIG9iamVjdCB3aXRoIGEgc2luZ2xlIGtleSAob3BlcmF0aW9uIG5hbWUpIG1hcHBpbmcgdG8gYSBmdW5jdGlvbi4gR290IGFuIG9iamVjdCB3aXRoIFwiK2UubGVuZ3RoK1wiIGtleXMuXCIpO3ZhciBuPWVbMF0scj10W25dO24uZW5kc1dpdGgoXCJfXCIpJiYobj1uLnN1YnN0cmluZygwLG4ubGVuZ3RoLTEpKTt2YXIgbz1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxlPTA7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl0W2VdPWFyZ3VtZW50c1tlXTtEdC5zdGFydFNjb3BlKG4pO3RyeXt2YXIgbz1yLmFwcGx5KHZvaWQgMCx0KTtyZXR1cm4gbyBpbnN0YW5jZW9mIFByb21pc2UmJmNvbnNvbGUuZXJyb3IoXCJDYW5ub3QgcmV0dXJuIGEgUHJvbWlzZSBpbnNpZGUgb2YgdGlkeS5cIiksRHQuZW5kU2NvcGUobyksb31jYXRjaCh0KXt0aHJvdyBEdC5lbmRTY29wZShudWxsKSx0fX07cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLFwibmFtZVwiLHt2YWx1ZTpuLGNvbmZpZ3VyYWJsZTohMH0pLG99dmFyIFRuPUFuKHtzb2Z0bWF4XzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPS0xKTt2YXIgbj13bih0LFwibG9naXRzXCIsXCJzb2Z0bWF4XCIpO2lmKC0xPT09ZSYmKGU9bi5yYW5rLTEpLGUhPT1uLnJhbmstMSl0aHJvdyBFcnJvcihcIlNvZnRtYXggYWxvbmcgYSBub24tbGFzdCBkaW1lbnNpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQuIExvZ2l0cyB3YXMgcmFuayBcIituLnJhbmsrXCIgYW5kIGRpbSB3YXMgXCIrZSk7cmV0dXJuIGtuKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5sb2dTdW1FeHAoW2VdLCEwKSxvPXQudG9GbG9hdCgpLnN1YihyKS5leHAoKTtyZXR1cm4gbihbb10pLHt2YWx1ZTpvLGdyYWRGdW5jOmZ1bmN0aW9uKHQsbil7dmFyIHI9blswXSxvPXQubXVsKHIpO3JldHVybiBvLnN1YihvLnN1bShbZV0sITApLm11bChyKSl9fX0pKG4pfX0pLERuPUFuKHtsb2dTb2Z0bWF4XzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPS0xKTt2YXIgbj13bih0LFwibG9naXRzXCIsXCJsb2dTb2Z0bWF4XCIpO2lmKC0xPT09ZSYmKGU9bi5yYW5rLTEpLGUhPT1uLnJhbmstMSl0aHJvdyBFcnJvcihcIkxvZyBTb2Z0bWF4IGFsb25nIGEgbm9uLWxhc3QgZGltZW5zaW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLiBMb2dpdHMgd2FzIHJhbmsgXCIrbi5yYW5rK1wiIGFuZCBheGlzIHdhcyBcIitlKTtyZXR1cm4ga24oZnVuY3Rpb24odCxuKXt2YXIgcj10Lm1heChlLCEwKSxvPXQuc3ViKHIpLGE9by50b0Zsb2F0KCkuc3ViKG8uZXhwKCkuc3VtKGUsITApLmxvZygpKTtyZXR1cm4gbihbYV0pLHt2YWx1ZTphLGdyYWRGdW5jOmZ1bmN0aW9uKHQsbil7dmFyIHI9blswXS5leHAoKTtyZXR1cm4gdC5zdWIodC5zdW0oZSwhMCkubXVsKHIpKX19fSkobil9fSk7dmFyIE9uPUFuKHtjb21wbGV4XzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJyZWFsXCIsXCJjb21wbGV4XCIpLHI9d24oZSxcImltYWdcIixcImNvbXBsZXhcIik7cmV0dXJuIHYobi5zaGFwZSxyLnNoYXBlLFwicmVhbCBhbmQgaW1hZyBzaGFwZXMsIFwiK24uc2hhcGUrXCIgYW5kIFwiK3Iuc2hhcGUrXCIsIG11c3QgbWF0Y2ggaW4gY2FsbCB0byB0Zi5jb21wbGV4KCkuXCIpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb21wbGV4KG4scil9LHskcmVhbDpuLCRpbWFnOnJ9KX19KSxfbj1Bbih7cmVhbF86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcImlucHV0XCIsXCJyZWFsXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQucmVhbChlKX0seyRpbnB1dDplfSl9fSksTW49QW4oe2ltYWdfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJpbnB1dFwiLFwiaW1hZ1wiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmltYWcoZSl9LHskaW5wdXQ6ZX0pfX0pO2Z1bmN0aW9uIEZuKHQsZSxuKXtpZihudWxsPT1uJiYobj1XKHQpKSxcImNvbXBsZXg2NFwiPT09bil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29uc3RydWN0IGEgY29tcGxleDY0IHRlbnNvciBkaXJlY3RseS4gUGxlYXNlIHVzZSB0Zi5jb21wbGV4KHJlYWwsIGltYWcpLlwiKTtpZighXyh0KSYmIUFycmF5LmlzQXJyYXkodCkmJlwibnVtYmVyXCIhPXR5cGVvZiB0JiZcImJvb2xlYW5cIiE9dHlwZW9mIHQmJlwic3RyaW5nXCIhPXR5cGVvZiB0KXRocm93IG5ldyBFcnJvcihcInZhbHVlcyBwYXNzZWQgdG8gdGVuc29yKHZhbHVlcykgbXVzdCBiZSBhIG51bWJlci9ib29sZWFuL3N0cmluZyBvciBhbiBhcnJheSBvZiBudW1iZXJzL2Jvb2xlYW5zL3N0cmluZ3MsIG9yIGEgVHlwZWRBcnJheVwiKTt2YXIgcj15bih0KTtpZihudWxsIT1lKXtLKGUpO3ZhciBvPXkoZSksaT15KHIpO2Qobz09PWksZnVuY3Rpb24oKXtyZXR1cm5cIkJhc2VkIG9uIHRoZSBwcm92aWRlZCBzaGFwZSwgW1wiK2UrXCJdLCB0aGUgdGVuc29yIHNob3VsZCBoYXZlIFwiK28rXCIgdmFsdWVzIGJ1dCBoYXMgXCIraX0pO2Zvcih2YXIgcz0wO3M8ci5sZW5ndGg7KytzKXt2YXIgdT1yW3NdLGw9cyE9PXIubGVuZ3RoLTF8fHUhPT15KGUuc2xpY2UocykpO2QocltzXT09PWVbc118fCFsLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBjcmVhdGluZyBhIG5ldyBUZW5zb3IuIEluZmVycmVkIHNoYXBlIChcIityK1wiKSBkb2VzIG5vdCBtYXRjaCB0aGUgcHJvdmlkZWQgc2hhcGUgKFwiK2UrXCIpLiBcIn0pfX1yZXR1cm4gXyh0KXx8QXJyYXkuaXNBcnJheSh0KXx8KHQ9W3RdKSxlPWV8fHIsdD1cInN0cmluZ1wiIT09bj9HKHQsbixhLmdldEJvb2woXCJERUJVR1wiKSk6Zyh0KSxmdC5tYWtlKGUse3ZhbHVlczp0fSxuKX1mdW5jdGlvbiBCbih0LGUpe2lmKChfKHQpfHxBcnJheS5pc0FycmF5KHQpKSYmXCJjb21wbGV4NjRcIiE9PWUpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgY3JlYXRpbmcgYSBuZXcgU2NhbGFyOiB2YWx1ZSBtdXN0IGJlIGEgcHJpbWl0aXZlIChudW1iZXJ8Ym9vbGVhbnxzdHJpbmcpXCIpO3JldHVybiBGbih0LFtdLGUpfWZ1bmN0aW9uIFBuKHQsZSl7bSh0KTt2YXIgbj15bih0KTtpZigxIT09bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yMWQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgYSBmbGF0L1R5cGVkQXJyYXlcIik7cmV0dXJuIEZuKHQsbixlKX1mdW5jdGlvbiBMbih0LGUsbil7aWYobSh0KSxudWxsIT1lJiYyIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yMmQoKSByZXF1aXJlcyBzaGFwZSB0byBoYXZlIHR3byBudW1iZXJzXCIpO3ZhciByPXluKHQpO2lmKDIhPT1yLmxlbmd0aCYmMSE9PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjJkKCkgcmVxdWlyZXMgdmFsdWVzIHRvIGJlIG51bWJlcltdW10gb3IgZmxhdC9UeXBlZEFycmF5XCIpO2lmKDE9PT1yLmxlbmd0aCYmbnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IyZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGJlIHByb3ZpZGVkIHdoZW4gYHZhbHVlc2AgYXJlIGEgZmxhdC9UeXBlZEFycmF5XCIpO3JldHVybiBGbih0LGU9ZXx8cixuKX1mdW5jdGlvbiBXbih0LGUsbil7aWYobSh0KSxudWxsIT1lJiYzIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yM2QoKSByZXF1aXJlcyBzaGFwZSB0byBoYXZlIHRocmVlIG51bWJlcnNcIik7dmFyIHI9eW4odCk7aWYoMyE9PXIubGVuZ3RoJiYxIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yM2QoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgbnVtYmVyW11bXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZigxPT09ci5sZW5ndGgmJm51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yM2QoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQgYXJyYXlcIik7cmV0dXJuIEZuKHQsZT1lfHxyLG4pfWZ1bmN0aW9uIFVuKHQsZSxuKXtpZihtKHQpLG51bGwhPWUmJjQhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I0ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgZm91ciBudW1iZXJzXCIpO3ZhciByPXluKHQpO2lmKDQhPT1yLmxlbmd0aCYmMSE9PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjRkKCkgcmVxdWlyZXMgdmFsdWVzIHRvIGJlIG51bWJlcltdW11bXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZigxPT09ci5sZW5ndGgmJm51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNGQoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQgYXJyYXlcIik7cmV0dXJuIEZuKHQsZT1lfHxyLG4pfWZ1bmN0aW9uIHpuKHQsZSxuKXtpZihtKHQpLG51bGwhPWUmJjUhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I1ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgZml2ZSBudW1iZXJzXCIpO3ZhciByPXluKHQpO2lmKDUhPT1yLmxlbmd0aCYmMSE9PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjVkKCkgcmVxdWlyZXMgdmFsdWVzIHRvIGJlIG51bWJlcltdW11bXVtdW10gb3IgZmxhdC9UeXBlZEFycmF5XCIpO2lmKDE9PT1yLmxlbmd0aCYmbnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I1ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGJlIHByb3ZpZGVkIHdoZW4gYHZhbHVlc2AgYXJlIGEgZmxhdCBhcnJheVwiKTtyZXR1cm4gRm4odCxlPWV8fHIsbil9ZnVuY3Rpb24gVm4odCxlLG4pe2lmKG0odCksbnVsbCE9ZSYmNiE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjZkKCkgcmVxdWlyZXMgc2hhcGUgdG8gaGF2ZSBzaXggbnVtYmVyc1wiKTt2YXIgcj15bih0KTtpZig2IT09ci5sZW5ndGgmJjEhPT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I2ZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdW11bXVtdW10gb3IgZmxhdC9UeXBlZEFycmF5XCIpO2lmKDE9PT1yLmxlbmd0aCYmbnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I2ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGJlIHByb3ZpZGVkIHdoZW4gYHZhbHVlc2AgYXJlIGEgZmxhdCBhcnJheVwiKTtyZXR1cm4gRm4odCxlPWV8fHIsbil9ZnVuY3Rpb24gR24odCxlKXtpZih2b2lkIDA9PT1lJiYoZT1cImZsb2F0MzJcIiksXCJjb21wbGV4NjRcIj09PWUpe3ZhciBuPUduKHQsXCJmbG9hdDMyXCIpLHI9cW4odCxcImZsb2F0MzJcIik7cmV0dXJuIE9uKG4scil9dmFyIG89SCh5KHQpLGUpO3JldHVybiBmdC5tYWtlKHQse3ZhbHVlczpvfSxlKX1mdW5jdGlvbiBxbih0LGUpe2lmKHZvaWQgMD09PWUmJihlPVwiZmxvYXQzMlwiKSxcImNvbXBsZXg2NFwiPT09ZSl7dmFyIG49cW4odCxcImZsb2F0MzJcIikscj1xbih0LFwiZmxvYXQzMlwiKTtyZXR1cm4gT24obixyKX12YXIgbz0kKHkodCksZSk7cmV0dXJuIGZ0Lm1ha2UodCx7dmFsdWVzOm99LGUpfWZ1bmN0aW9uIEhuKHQsZSxuKXtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHIpe3JldHVybiByLmZpbGwodCxlLG4pfSx7fSl9ZnVuY3Rpb24gJG4odCxlLG4pe2lmKG48PTApdGhyb3cgbmV3IEVycm9yKFwiVGhlIG51bWJlciBvZiB2YWx1ZXMgc2hvdWxkIGJlIHBvc2l0aXZlLlwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHIpe3JldHVybiByLmxpbnNwYWNlKHQsZSxuKX0se30pfWZ1bmN0aW9uIGpuKHQsZSxuLHIpe2lmKHZvaWQgMD09PW4mJihuPTEpLHZvaWQgMD09PXImJihyPVwiZmxvYXQzMlwiKSwwPT09bil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaGF2ZSBhIHN0ZXAgb2YgemVyb1wiKTtpZih0PT09ZXx8dDxlJiZuPDB8fGU8dCYmbj4xKXJldHVybiBxbihbMF0scik7dmFyIG89JChNYXRoLmFicyhNYXRoLmNlaWwoKGUtdCkvbikpLHIpO2U8dCYmMT09PW4mJihuPS0xKSxvWzBdPXQ7Zm9yKHZhciBhPTE7YTxvLmxlbmd0aDthKyspb1thXT1vW2EtMV0rbjtyZXR1cm4gUG4obyxyKX12YXIgS249QW4oe29uZXNMaWtlXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwib25lc0xpa2VcIik7aWYoXCJjb21wbGV4NjRcIj09PWUuZHR5cGUpe3ZhciBuPUtuKF9uKGUpKSxyPVhuKE1uKGUpKTtyZXR1cm4gT24obixyKX1yZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm9uZXNMaWtlKGUpfSx7JHg6ZX0sbnVsbCl9fSksWG49QW4oe3plcm9zTGlrZV86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcInplcm9zTGlrZVwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0Lnplcm9zTGlrZShlKX0seyR4OmV9LG51bGwpfX0pLFluPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmRhdGFNb3Zlcj10LHRoaXMuZGF0YT1uZXcgV2Vha01hcH1yZXR1cm4gdC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRhdGEuaGFzKHQpfHx0aGlzLmRhdGFNb3Zlci5tb3ZlRGF0YSh0KSx0aGlzLmRhdGEuZ2V0KHQpfSx0LnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24odCxlKXt0aGlzLmRhdGEuc2V0KHQsZSl9LHQucHJvdG90eXBlLmhhcz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kYXRhLmhhcyh0KX0sdC5wcm90b3R5cGUuZGVsZXRlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRhdGEuZGVsZXRlKHQpfSx0fSgpLFFuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUudGltZT1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkLlwiKX0sdC5wcm90b3R5cGUucmVhZD1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkLlwiKX0sdC5wcm90b3R5cGUucmVhZFN5bmM9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZC5cIil9LHQucHJvdG90eXBlLmRpc3Bvc2VEYXRhPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWQuXCIpfSx0LnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWQuXCIpfSx0LnByb3RvdHlwZS5mcm9tUGl4ZWxzPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZC5cIil9LHQucHJvdG90eXBlLnJlZ2lzdGVyPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkLlwiKX0sdC5wcm90b3R5cGUubWVtb3J5PWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZC5cIil9LHQucHJvdG90eXBlLmZsb2F0UHJlY2lzaW9uPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuZXBzaWxvbj1mdW5jdGlvbigpe3JldHVybiAzMj09PXRoaXMuZmxvYXRQcmVjaXNpb24oKT8xZS03OjFlLTR9LHQucHJvdG90eXBlLmJhdGNoTWF0TXVsPWZ1bmN0aW9uKHQsZSxuLHIpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmZ1c2VkQmF0Y2hNYXRNdWw9ZnVuY3Rpb24odCxlLG4scixvLGEpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5zdHJpZGVkU2xpY2U9ZnVuY3Rpb24odCxlLG4scixvLGEsaSxzLHUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnVuc3RhY2s9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5yZXZlcnNlPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuY29uY2F0PWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUubmVnPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmFkZE49ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuc3VidHJhY3Q9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnJlYWxEaXZpZGU9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5mbG9vckRpdj1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnN1bT1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnByb2Q9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS51bnNvcnRlZFNlZ21lbnRTdW09ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmFyZ01pbj1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmFyZ01heD1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmVxdWFsPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUubm90RXF1YWw9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5sZXNzPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUubGVzc0VxdWFsPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuZ3JlYXRlcj1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmdyZWF0ZXJFcXVhbD1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmxvZ2ljYWxOb3Q9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUubG9naWNhbEFuZD1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmxvZ2ljYWxPcj1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLndoZXJlPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnNlbGVjdD1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUudG9waz1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUubWluPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUubWluaW11bT1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLm1vZD1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLm1heD1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLm1heGltdW09ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5hbGw9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5hbnk9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5zcXVhcmVkRGlmZmVyZW5jZT1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmNlaWw9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuZmxvb3I9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuc2lnbj1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5pc05hTj1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5pc0luZj1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5pc0Zpbml0ZT1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5leHA9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuZXhwbTE9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUubG9nPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmxvZzFwPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnNxcnQ9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUucnNxcnQ9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuc3F1YXJlPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnJlY2lwcm9jYWw9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUucmVsdT1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5wcmVsdT1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmVsdT1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5lbHVEZXI9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5zZWx1PWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmludD1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5jbGlwPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5hYnM9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuY29tcGxleEFicz1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5zaWdtb2lkPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnNvZnRwbHVzPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnNpbj1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5jb3M9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUudGFuPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmFzaW49ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuYWNvcz1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5hdGFuPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmF0YW4yPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuc2luaD1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5jb3NoPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnRhbmg9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuYXNpbmg9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuYWNvc2g9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuYXRhbmg9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuZXJmPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnN0ZXA9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5jb252MmQ9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmNvbnYyZERlcklucHV0PWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5jb252MmREZXJGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRD1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJERGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuY29udjNkPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5jb252M2REZXJJbnB1dD1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuY29udjNkRGVyRmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5tYXhQb29sPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUubWF4UG9vbEJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuLHIpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmF2Z1Bvb2w9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5hdmdQb29sQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnJlc2hhcGU9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5jYXN0PWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUudGlsZT1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnBhZD1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUudHJhbnNwb3NlPWZ1bmN0aW9uKHQsZSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuZ2F0aGVyPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5nYXRoZXJORD1mdW5jdGlvbih0LGUpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnNjYXR0ZXJORD1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuYmF0Y2hUb1NwYWNlTkQ9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLnNwYWNlVG9CYXRjaE5EPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5yZXNpemVCaWxpbmVhcj1mdW5jdGlvbih0LGUsbixyKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5yZXNpemVCaWxpbmVhckJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3I9ZnVuY3Rpb24odCxlLG4scil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbj1mdW5jdGlvbih0LGUsbixyLG8sYSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb240RD1mdW5jdGlvbih0LGUsbixyLG8pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLkxSTkdyYWQ9ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUubXVsdGlub21pYWw9ZnVuY3Rpb24odCxlLG4scil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUub25lSG90PWZ1bmN0aW9uKHQsZSxuLHIpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmN1bXN1bT1mdW5jdGlvbih0LGUsbixyKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5ub25NYXhTdXBwcmVzc2lvbj1mdW5jdGlvbih0LGUsbixyLG8pe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmZmdD1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5pZmZ0PWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmNvbXBsZXg9ZnVuY3Rpb24odCxlKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5yZWFsPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmltYWc9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuY3JvcEFuZFJlc2l6ZT1mdW5jdGlvbih0LGUsbixyLG8sYSl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuZGVwdGhUb1NwYWNlPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuc3BhcnNlVG9EZW5zZT1mdW5jdGlvbih0LGUsbixyKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkLlwiKX0sdC5wcm90b3R5cGUub25lc0xpa2U9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdC5wcm90b3R5cGUuemVyb3NMaWtlPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWRcIil9LHQucHJvdG90eXBlLmxpbnNwYWNlPWZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgeWV0IGltcGxlbWVudGVkXCIpfSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IHlldCBpbXBsZW1lbnRlZFwiKX0sdH0oKTtmdW5jdGlvbiBKbih0LGUsbil7aWYoXCJjb21wbGV4NjRcIj09PWUpe2lmKFwiY29tcGxleDY0XCI9PT10LmR0eXBlKXJldHVybiB0LmNsb25lKCk7dmFyIHI9cW4odC5zaGFwZSksbz10LnRvRmxvYXQoKSxhPW4uY29tcGxleChvLHIpO3JldHVybiByLmRpc3Bvc2UoKSxvLmRpc3Bvc2UoKSxhfWlmKCFPKHQuZHR5cGUsZSkpcmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7ZGF0YUlkOnQuZGF0YUlkfSxlKTtpZihcImNvbXBsZXg2NFwiPT09dC5kdHlwZSl7dmFyIGk9bi5yZWFsKHQpO2E9aS5jYXN0KGUpO3JldHVybiBpLmRpc3Bvc2UoKSxhfWlmKFwiaW50MzJcIj09PWUpcmV0dXJuIG4uaW50KHQpO2lmKFwiYm9vbFwiPT09ZSl7dmFyIHM9Qm4oMCx0LmR0eXBlKTthPW4ubm90RXF1YWwodCxzKTtyZXR1cm4gcy5kaXNwb3NlKCksYX10aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBDYXN0OiB1bmtub3duIGR0eXBlIGFyZ3VtZW50IChcIitlK1wiKVwiKX1mdW5jdGlvbiBabih0LGUpe3JldHVybiBmdC5tYWtlKGUse2RhdGFJZDp0LmRhdGFJZH0sdC5kdHlwZSl9ZnVuY3Rpb24gdHIodCxlLG4pe3ZhciByPShlLXQpLyhuLTEpLG89JChuLFwiZmxvYXQzMlwiKTtvWzBdPXQ7Zm9yKHZhciBhPTE7YTxvLmxlbmd0aDthKyspb1thXT1vW2EtMV0rcjtyZXR1cm4gUG4obyxcImZsb2F0MzJcIil9ZnVuY3Rpb24gZXIodCxlKXtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtZXJnZSByZWFsIGFuZCBpbWFnIGFycmF5cyBvZiBkaWZmZXJlbnQgbGVuZ3Rocy4gcmVhbDpcIit0Lmxlbmd0aCtcIiwgaW1hZzogXCIrZS5sZW5ndGgrXCIuXCIpO2Zvcih2YXIgbj1uZXcgRmxvYXQzMkFycmF5KDIqdC5sZW5ndGgpLHI9MDtyPG4ubGVuZ3RoO3IrPTIpbltyXT10W3IvMl0sbltyKzFdPWVbci8yXTtyZXR1cm4gbn1mdW5jdGlvbiBucih0LGUpe3JldHVybntyZWFsOnRbMiplXSxpbWFnOnRbMiplKzFdfX1mdW5jdGlvbiBycih0LGUsbixyKXt0WzIqcl09ZSx0WzIqcisxXT1ufWZ1bmN0aW9uIG9yKHQsZSxuKXt2YXIgcj0obj8yOi0yKSpNYXRoLlBJKih0L2UpO3JldHVybntyZWFsOk1hdGguY29zKHIpLGltYWc6TWF0aC5zaW4ocil9fWZ1bmN0aW9uIGFyKHQsZSxuLHIsbyl7Zm9yKHZhciBhPUFycmF5LmZyb20oZSkubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJue3Njb3JlOnQsYm94SW5kZXg6ZX19KS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2NvcmU+b30pLnNvcnQoZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5zY29yZS10LnNjb3JlfSksaT1bXSxzPTA7czxhLmxlbmd0aDtzKyspe3ZhciB1PWFbc10sbD11LnNjb3JlLGM9dS5ib3hJbmRleDtpZihsPG8pYnJlYWs7Zm9yKHZhciBoPSExLHA9aS5sZW5ndGgtMTtwPj0wOy0tcCl7aWYoaXIodCxjLGlbcF0pPj1yKXtoPSEwO2JyZWFrfX1pZighaCYmKGkucHVzaChjKSxpLmxlbmd0aD49bikpYnJlYWt9cmV0dXJuIFBuKGksXCJpbnQzMlwiKX1mdW5jdGlvbiBpcih0LGUsbil7dmFyIHI9dC5zdWJhcnJheSg0KmUsNCplKzQpLG89dC5zdWJhcnJheSg0Km4sNCpuKzQpLGE9TWF0aC5taW4oclswXSxyWzJdKSxpPU1hdGgubWluKHJbMV0sclszXSkscz1NYXRoLm1heChyWzBdLHJbMl0pLHU9TWF0aC5tYXgoclsxXSxyWzNdKSxsPU1hdGgubWluKG9bMF0sb1syXSksYz1NYXRoLm1pbihvWzFdLG9bM10pLGg9TWF0aC5tYXgob1swXSxvWzJdKSxwPU1hdGgubWF4KG9bMV0sb1szXSksZj0ocy1hKSoodS1pKSxkPShoLWwpKihwLWMpO2lmKGY8PTB8fGQ8PTApcmV0dXJuIDA7dmFyIHY9TWF0aC5tYXgoYSxsKSxtPU1hdGgubWF4KGksYyksZz1NYXRoLm1pbihzLGgpLHk9TWF0aC5taW4odSxwKSx4PU1hdGgubWF4KGctdiwwKSpNYXRoLm1heCh5LW0sMCk7cmV0dXJuIHgvKGYrZC14KX1mdW5jdGlvbiBzcih0LGUsbil7dmFyIHI9bmV3IEFycmF5KHQucmFuaykuZmlsbCgwKSxvPXQuc2hhcGUuc2xpY2UoKTtyZXR1cm4gZS5tYXAoZnVuY3Rpb24oZSl7b1tuXT1lO3ZhciBhPXQuc2xpY2UocixvKTtyZXR1cm4gcltuXSs9ZSxhfSl9ZnVuY3Rpb24gdXIodCxlLG4scixvKXtmb3IodmFyIGE9ZVtlLmxlbmd0aC0xXSxpPVt0Lmxlbmd0aC9hLGFdLHM9aVswXSx1PWlbMV0sbD1JKG4scypyKSxjPUkoXCJpbnQzMlwiLHMqciksaD0wO2g8cztoKyspe2Zvcih2YXIgcD1oKnUsZj10LnN1YmFycmF5KHAscCt1KSxkPVtdLHY9MDt2PGYubGVuZ3RoO3YrKylkLnB1c2goe3ZhbHVlOmZbdl0saW5kZXg6dn0pO2Quc29ydChmdW5jdGlvbih0LGUpe3JldHVybiBlLnZhbHVlLXQudmFsdWV9KTt2YXIgbT1oKnIsZz1sLnN1YmFycmF5KG0sbStyKSx5PWMuc3ViYXJyYXkobSxtK3IpO2Zvcih2PTA7djxyO3YrKylnW3ZdPWRbdl0udmFsdWUseVt2XT1kW3ZdLmluZGV4fXZhciB4PWUuc2xpY2UoKTtyZXR1cm4geFt4Lmxlbmd0aC0xXT1yLFtGbihsLHgsbiksRm4oYyx4LFwiaW50MzJcIildfXZhciBscj1Bbih7Y29uY2F0XzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPTApLGQodC5sZW5ndGg+PTEsZnVuY3Rpb24oKXtyZXR1cm5cIlBhc3MgYXQgbGVhc3Qgb25lIHRlbnNvciB0byBjb25jYXRcIn0pO3ZhciBuPWJuKHQsXCJ0ZW5zb3JzXCIsXCJjb25jYXRcIik7ZT1OKGUsblswXS5zaGFwZSlbMF07dmFyIHI9c24obi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSxlKTtpZigwPT09eShyKSlyZXR1cm4gRm4oW10scik7aWYoMT09PShuPW4uZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNpemU+MH0pKS5sZW5ndGgpcmV0dXJuIG5bMF07dmFyIG89bi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KTshZnVuY3Rpb24odCxlKXt2YXIgbj10WzBdLmxlbmd0aDt0LmZvckVhY2goZnVuY3Rpb24odCxlKXtkKHQubGVuZ3RoPT09bixmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29uY2F0XCIrbitcIkQ6IHJhbmsgb2YgdGVuc29yc1tcIitlK1wiXSBtdXN0IGJlIHRoZSBzYW1lIGFzIHRoZSByYW5rIG9mIHRoZSByZXN0IChcIituK1wiKVwifSl9KSxkKGU+PTAmJmU8bixmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29uY2F0XCIrbitcIkQ6IGF4aXMgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIFwiKyhuLTEpK1wiLlwifSk7dmFyIHI9dFswXTt0LmZvckVhY2goZnVuY3Rpb24odCxvKXtmb3IodmFyIGE9MDthPG47YSsrKWQoYT09PWV8fHRbYV09PT1yW2FdLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb25jYXRcIituK1wiRDogU2hhcGUgb2YgdGVuc29yc1tcIitvK1wiXSAoXCIrdCtcIikgZG9lcyBub3QgbWF0Y2ggdGhlIHNoYXBlIG9mIHRoZSByZXN0IChcIityK1wiKSBhbG9uZyB0aGUgbm9uLWNvbmNhdGVuYXRlZCBheGlzIFwiK28rXCIuXCJ9KX0pfShvLGUpO3ZhciBhPW47cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb25jYXQobixlKX0sYSxmdW5jdGlvbih0KXt2YXIgbj1vLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdFtlXX0pO3JldHVybiBkcih0LG4sZSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0fX0pfSl9fSksY3I9QW4oe2NvbmNhdDFkXzpmdW5jdGlvbih0KXtyZXR1cm4gbHIodCwwKX19KSxocj1Bbih7Y29uY2F0MmRfOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIGxyKHQsZSl9fSkscHI9QW4oe2NvbmNhdDNkXzpmdW5jdGlvbih0LGUpe3JldHVybiBscih0LGUpfX0pLGZyPUFuKHtjb25jYXQ0ZF86ZnVuY3Rpb24odCxlKXtyZXR1cm4gbHIodCxlKX19KSxkcj1Bbih7c3BsaXRfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0wKTt2YXIgcixvPXduKHQsXCJ4XCIsXCJzcGxpdFwiKTtyZXR1cm4gbj1OKG4sby5zaGFwZSlbMF0sXCJudW1iZXJcIj09dHlwZW9mIGU/KGQoby5zaGFwZVtuXSVlPT0wLGZ1bmN0aW9uKCl7cmV0dXJuXCJOdW1iZXIgb2Ygc3BsaXRzIG11c3QgZXZlbmx5IGRpdmlkZSB0aGUgYXhpcy5cIn0pLHI9bmV3IEFycmF5KGUpLmZpbGwoby5zaGFwZVtuXS9lKSk6KGQoby5zaGFwZVtuXT09PWUucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQrZX0pLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgc3VtIG9mIHNpemVzIG11c3QgbWF0Y2ggdGhlIHNpemUgb2YgdGhlIGF4aXMgZGltZW5zaW9uLlwifSkscj1lKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3BsaXQobyxyLG4pfSx7JHg6b30sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIGxyKHQsbil9fX0pfX0pO1widW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJnNlbGY7ZnVuY3Rpb24gdnIodCxlKXtyZXR1cm4gdChlPXtleHBvcnRzOnt9fSxlLmV4cG9ydHMpLGUuZXhwb3J0c312YXIgbXI9dnIoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlLG49dGhpcyxyPShlPTQwMjI4NzExOTcsZnVuY3Rpb24odCl7dD10LnRvU3RyaW5nKCk7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPS4wMjUxOTYwMzI4MjQxNjkzOCooZSs9dC5jaGFyQ29kZUF0KG4pKTtyLT1lPXI+Pj4wLGU9KHIqPWUpPj4+MCxlKz00Mjk0OTY3Mjk2KihyLT1lKX1yZXR1cm4gMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMCooZT4+PjApfSk7bi5uZXh0PWZ1bmN0aW9uKCl7dmFyIHQ9MjA5MTYzOSpuLnMwKzIuMzI4MzA2NDM2NTM4Njk2M2UtMTAqbi5jO3JldHVybiBuLnMwPW4uczEsbi5zMT1uLnMyLG4uczI9dC0obi5jPTB8dCl9LG4uYz0xLG4uczA9cihcIiBcIiksbi5zMT1yKFwiIFwiKSxuLnMyPXIoXCIgXCIpLG4uczAtPXIodCksbi5zMDwwJiYobi5zMCs9MSksbi5zMS09cih0KSxuLnMxPDAmJihuLnMxKz0xKSxuLnMyLT1yKHQpLG4uczI8MCYmKG4uczIrPTEpLHI9bnVsbH1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuIGUuYz10LmMsZS5zMD10LnMwLGUuczE9dC5zMSxlLnMyPXQuczIsZX1mdW5jdGlvbiBhKHQsZSl7dmFyIG49bmV3IHIodCksYT1lJiZlLnN0YXRlLGk9bi5uZXh0O3JldHVybiBpLmludDMyPWZ1bmN0aW9uKCl7cmV0dXJuIDQyOTQ5NjcyOTYqbi5uZXh0KCl8MH0saS5kb3VibGU9ZnVuY3Rpb24oKXtyZXR1cm4gaSgpKzEuMTEwMjIzMDI0NjI1MTU2NWUtMTYqKDIwOTcxNTIqaSgpfDApfSxpLnF1aWNrPWksYSYmKFwib2JqZWN0XCI9PXR5cGVvZiBhJiZvKGEsbiksaS5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBvKG4se30pfSksaX1lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPWE6biYmbi5hbWQ/bihmdW5jdGlvbigpe3JldHVybiBhfSk6dGhpcy5hbGVhPWF9KDAsdCwhMSl9KSxncj12cihmdW5jdGlvbih0KXshZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dmFyIGU9dGhpcyxuPVwiXCI7ZS54PTAsZS55PTAsZS56PTAsZS53PTAsZS5uZXh0PWZ1bmN0aW9uKCl7dmFyIHQ9ZS54XmUueDw8MTE7cmV0dXJuIGUueD1lLnksZS55PWUueixlLno9ZS53LGUud149ZS53Pj4+MTledF50Pj4+OH0sdD09PSgwfHQpP2UueD10Om4rPXQ7Zm9yKHZhciByPTA7cjxuLmxlbmd0aCs2NDtyKyspZS54Xj0wfG4uY2hhckNvZGVBdChyKSxlLm5leHQoKX1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuIGUueD10LngsZS55PXQueSxlLno9dC56LGUudz10LncsZX1mdW5jdGlvbiBhKHQsZSl7dmFyIG49bmV3IHIodCksYT1lJiZlLnN0YXRlLGk9ZnVuY3Rpb24oKXtyZXR1cm4obi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2fTtyZXR1cm4gaS5kb3VibGU9ZnVuY3Rpb24oKXtkb3t2YXIgdD0oKG4ubmV4dCgpPj4+MTEpKyhuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYpLygxPDwyMSl9d2hpbGUoMD09PXQpO3JldHVybiB0fSxpLmludDMyPW4ubmV4dCxpLnF1aWNrPWksYSYmKFwib2JqZWN0XCI9PXR5cGVvZiBhJiZvKGEsbiksaS5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBvKG4se30pfSksaX1lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPWE6biYmbi5hbWQ/bihmdW5jdGlvbigpe3JldHVybiBhfSk6dGhpcy54b3IxMjg9YX0oMCx0LCExKX0pLHlyPXZyKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXt2YXIgZT10aGlzLG49XCJcIjtlLm5leHQ9ZnVuY3Rpb24oKXt2YXIgdD1lLnheZS54Pj4+MjtyZXR1cm4gZS54PWUueSxlLnk9ZS56LGUuej1lLncsZS53PWUudiwoZS5kPWUuZCszNjI0Mzd8MCkrKGUudj1lLnZeZS52PDw0XnRedDw8MSl8MH0sZS54PTAsZS55PTAsZS56PTAsZS53PTAsZS52PTAsdD09PSgwfHQpP2UueD10Om4rPXQ7Zm9yKHZhciByPTA7cjxuLmxlbmd0aCs2NDtyKyspZS54Xj0wfG4uY2hhckNvZGVBdChyKSxyPT1uLmxlbmd0aCYmKGUuZD1lLng8PDEwXmUueD4+PjQpLGUubmV4dCgpfWZ1bmN0aW9uIG8odCxlKXtyZXR1cm4gZS54PXQueCxlLnk9dC55LGUuej10LnosZS53PXQudyxlLnY9dC52LGUuZD10LmQsZX1mdW5jdGlvbiBhKHQsZSl7dmFyIG49bmV3IHIodCksYT1lJiZlLnN0YXRlLGk9ZnVuY3Rpb24oKXtyZXR1cm4obi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2fTtyZXR1cm4gaS5kb3VibGU9ZnVuY3Rpb24oKXtkb3t2YXIgdD0oKG4ubmV4dCgpPj4+MTEpKyhuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYpLygxPDwyMSl9d2hpbGUoMD09PXQpO3JldHVybiB0fSxpLmludDMyPW4ubmV4dCxpLnF1aWNrPWksYSYmKFwib2JqZWN0XCI9PXR5cGVvZiBhJiZvKGEsbiksaS5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBvKG4se30pfSksaX1lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPWE6biYmbi5hbWQ/bihmdW5jdGlvbigpe3JldHVybiBhfSk6dGhpcy54b3J3b3c9YX0oMCx0LCExKX0pLHhyPXZyKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXt2YXIgZT10aGlzO2UubmV4dD1mdW5jdGlvbigpe3ZhciB0LG4scj1lLngsbz1lLmk7cmV0dXJuIHQ9cltvXSxuPSh0Xj10Pj4+NyledDw8MjQsbl49KHQ9cltvKzEmN10pXnQ+Pj4xMCxuXj0odD1yW28rMyY3XSledD4+PjMsbl49KHQ9cltvKzQmN10pXnQ8PDcsdD1yW28rNyY3XSxuXj0odF49dDw8MTMpXnQ8PDkscltvXT1uLGUuaT1vKzEmNyxufSxmdW5jdGlvbih0LGUpe3ZhciBuLHI9W107aWYoZT09PSgwfGUpKXJbMF09ZTtlbHNlIGZvcihlPVwiXCIrZSxuPTA7bjxlLmxlbmd0aDsrK24pcls3Jm5dPXJbNyZuXTw8MTVeZS5jaGFyQ29kZUF0KG4pK3JbbisxJjddPDwxMztmb3IoO3IubGVuZ3RoPDg7KXIucHVzaCgwKTtmb3Iobj0wO248OCYmMD09PXJbbl07KytuKTtmb3IoOD09bj9yWzddPS0xOnJbbl0sdC54PXIsdC5pPTAsbj0yNTY7bj4wOy0tbil0Lm5leHQoKX0oZSx0KX1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuIGUueD10Lnguc2xpY2UoKSxlLmk9dC5pLGV9ZnVuY3Rpb24gYSh0LGUpe251bGw9PXQmJih0PStuZXcgRGF0ZSk7dmFyIG49bmV3IHIodCksYT1lJiZlLnN0YXRlLGk9ZnVuY3Rpb24oKXtyZXR1cm4obi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2fTtyZXR1cm4gaS5kb3VibGU9ZnVuY3Rpb24oKXtkb3t2YXIgdD0oKG4ubmV4dCgpPj4+MTEpKyhuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYpLygxPDwyMSl9d2hpbGUoMD09PXQpO3JldHVybiB0fSxpLmludDMyPW4ubmV4dCxpLnF1aWNrPWksYSYmKGEueCYmbyhhLG4pLGkuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbyhuLHt9KX0pLGl9ZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1hOm4mJm4uYW1kP24oZnVuY3Rpb24oKXtyZXR1cm4gYX0pOnRoaXMueG9yc2hpZnQ3PWF9KDAsdCwhMSl9KSx3cj12cihmdW5jdGlvbih0KXshZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dmFyIGU9dGhpcztlLm5leHQ9ZnVuY3Rpb24oKXt2YXIgdCxuLHI9ZS53LG89ZS5YLGE9ZS5pO3JldHVybiBlLnc9cj1yKzE2NDA1MzE1Mjd8MCxuPW9bYSszNCYxMjddLHQ9b1thPWErMSYxMjddLG5ePW48PDEzLHRePXQ8PDE3LG5ePW4+Pj4xNSx0Xj10Pj4+MTIsbj1vW2FdPW5edCxlLmk9YSxuKyhyXnI+Pj4xNil8MH0sZnVuY3Rpb24odCxlKXt2YXIgbixyLG8sYSxpLHM9W10sdT0xMjg7Zm9yKGU9PT0oMHxlKT8ocj1lLGU9bnVsbCk6KGUrPVwiXFwwXCIscj0wLHU9TWF0aC5tYXgodSxlLmxlbmd0aCkpLG89MCxhPS0zMjthPHU7KythKWUmJihyXj1lLmNoYXJDb2RlQXQoKGErMzIpJWUubGVuZ3RoKSksMD09PWEmJihpPXIpLHJePXI8PDEwLHJePXI+Pj4xNSxyXj1yPDw0LHJePXI+Pj4xMyxhPj0wJiYoaT1pKzE2NDA1MzE1Mjd8MCxvPTA9PShuPXNbMTI3JmFdXj1yK2kpP28rMTowKTtmb3Iobz49MTI4JiYoc1sxMjcmKGUmJmUubGVuZ3RofHwwKV09LTEpLG89MTI3LGE9NTEyO2E+MDstLWEpcj1zW28rMzQmMTI3XSxuPXNbbz1vKzEmMTI3XSxyXj1yPDwxMyxuXj1uPDwxNyxyXj1yPj4+MTUsbl49bj4+PjEyLHNbb109cl5uO3Qudz1pLHQuWD1zLHQuaT1vfShlLHQpfWZ1bmN0aW9uIG8odCxlKXtyZXR1cm4gZS5pPXQuaSxlLnc9dC53LGUuWD10Llguc2xpY2UoKSxlfWZ1bmN0aW9uIGEodCxlKXtudWxsPT10JiYodD0rbmV3IERhdGUpO3ZhciBuPW5ldyByKHQpLGE9ZSYmZS5zdGF0ZSxpPWZ1bmN0aW9uKCl7cmV0dXJuKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIGkuZG91YmxlPWZ1bmN0aW9uKCl7ZG97dmFyIHQ9KChuLm5leHQoKT4+PjExKSsobi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2KS8oMTw8MjEpfXdoaWxlKDA9PT10KTtyZXR1cm4gdH0saS5pbnQzMj1uLm5leHQsaS5xdWljaz1pLGEmJihhLlgmJm8oYSxuKSxpLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG8obix7fSl9KSxpfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9YTpuJiZuLmFtZD9uKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KTp0aGlzLnhvcjQwOTY9YX0oMCx0LCExKX0pLGJyPXZyKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXt2YXIgZT10aGlzLG49XCJcIjtlLm5leHQ9ZnVuY3Rpb24oKXt2YXIgdD1lLmIsbj1lLmMscj1lLmQsbz1lLmE7cmV0dXJuIHQ9dDw8MjVedD4+PjdebixuPW4tcnwwLHI9cjw8MjRecj4+PjhebyxvPW8tdHwwLGUuYj10PXQ8PDIwXnQ+Pj4xMl5uLGUuYz1uPW4tcnwwLGUuZD1yPDwxNl5uPj4+MTZebyxlLmE9by10fDB9LGUuYT0wLGUuYj0wLGUuYz0tMTY0MDUzMTUyNyxlLmQ9MTM2NzEzMDU1MSx0PT09TWF0aC5mbG9vcih0KT8oZS5hPXQvNDI5NDk2NzI5NnwwLGUuYj0wfHQpOm4rPXQ7Zm9yKHZhciByPTA7cjxuLmxlbmd0aCsyMDtyKyspZS5iXj0wfG4uY2hhckNvZGVBdChyKSxlLm5leHQoKX1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuIGUuYT10LmEsZS5iPXQuYixlLmM9dC5jLGUuZD10LmQsZX1mdW5jdGlvbiBhKHQsZSl7dmFyIG49bmV3IHIodCksYT1lJiZlLnN0YXRlLGk9ZnVuY3Rpb24oKXtyZXR1cm4obi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2fTtyZXR1cm4gaS5kb3VibGU9ZnVuY3Rpb24oKXtkb3t2YXIgdD0oKG4ubmV4dCgpPj4+MTEpKyhuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYpLygxPDwyMSl9d2hpbGUoMD09PXQpO3JldHVybiB0fSxpLmludDMyPW4ubmV4dCxpLnF1aWNrPWksYSYmKFwib2JqZWN0XCI9PXR5cGVvZiBhJiZvKGEsbiksaS5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBvKG4se30pfSksaX1lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPWE6biYmbi5hbWQ/bihmdW5jdGlvbigpe3JldHVybiBhfSk6dGhpcy50eWNoZWk9YX0oMCx0LCExKX0pLENyPXZyKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlLG4pe3ZhciByLG89dGhpcyxhPTI1NixpPTYscz1cInJhbmRvbVwiLHU9bi5wb3coYSxpKSxsPW4ucG93KDIsNTIpLGM9MipsLGg9YS0xO2Z1bmN0aW9uIHAodCxoLHApe3ZhciBnPVtdLHk9dihmdW5jdGlvbiB0KGUsbil7dmFyIHIsbz1bXSxhPXR5cGVvZiBlO2lmKG4mJlwib2JqZWN0XCI9PWEpZm9yKHIgaW4gZSl0cnl7by5wdXNoKHQoZVtyXSxuLTEpKX1jYXRjaCh0KXt9cmV0dXJuIG8ubGVuZ3RoP286XCJzdHJpbmdcIj09YT9lOmUrXCJcXDBcIn0oKGg9MT09aD97ZW50cm9weTohMH06aHx8e30pLmVudHJvcHk/W3QsbShlKV06bnVsbD09dD9mdW5jdGlvbigpe3RyeXt2YXIgdDtyZXR1cm4gciYmKHQ9ci5yYW5kb21CeXRlcyk/dD10KGEpOih0PW5ldyBVaW50OEFycmF5KGEpLChvLmNyeXB0b3x8by5tc0NyeXB0bykuZ2V0UmFuZG9tVmFsdWVzKHQpKSxtKHQpfWNhdGNoKHQpe3ZhciBuPW8ubmF2aWdhdG9yLGk9biYmbi5wbHVnaW5zO3JldHVyblsrbmV3IERhdGUsbyxpLG8uc2NyZWVuLG0oZSldfX0oKTp0LDMpLGcpLHg9bmV3IGYoZyksdz1mdW5jdGlvbigpe2Zvcih2YXIgdD14LmcoaSksZT11LG49MDt0PGw7KXQ9KHQrbikqYSxlKj1hLG49eC5nKDEpO2Zvcig7dD49YzspdC89MixlLz0yLG4+Pj49MTtyZXR1cm4odCtuKS9lfTtyZXR1cm4gdy5pbnQzMj1mdW5jdGlvbigpe3JldHVybiAwfHguZyg0KX0sdy5xdWljaz1mdW5jdGlvbigpe3JldHVybiB4LmcoNCkvNDI5NDk2NzI5Nn0sdy5kb3VibGU9dyx2KG0oeC5TKSxlKSwoaC5wYXNzfHxwfHxmdW5jdGlvbih0LGUscixvKXtyZXR1cm4gbyYmKG8uUyYmZChvLHgpLHQuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gZCh4LHt9KX0pLHI/KG5bc109dCxlKTp0fSkodyx5LFwiZ2xvYmFsXCJpbiBoP2guZ2xvYmFsOnRoaXM9PW4saC5zdGF0ZSl9ZnVuY3Rpb24gZih0KXt2YXIgZSxuPXQubGVuZ3RoLHI9dGhpcyxvPTAsaT1yLmk9ci5qPTAscz1yLlM9W107Zm9yKG58fCh0PVtuKytdKTtvPGE7KXNbb109bysrO2ZvcihvPTA7bzxhO28rKylzW29dPXNbaT1oJmkrdFtvJW5dKyhlPXNbb10pXSxzW2ldPWU7KHIuZz1mdW5jdGlvbih0KXtmb3IodmFyIGUsbj0wLG89ci5pLGk9ci5qLHM9ci5TO3QtLTspZT1zW289aCZvKzFdLG49biphK3NbaCYoc1tvXT1zW2k9aCZpK2VdKSsoc1tpXT1lKV07cmV0dXJuIHIuaT1vLHIuaj1pLG59KShhKX1mdW5jdGlvbiBkKHQsZSl7cmV0dXJuIGUuaT10LmksZS5qPXQuaixlLlM9dC5TLnNsaWNlKCksZX1mdW5jdGlvbiB2KHQsZSl7Zm9yKHZhciBuLHI9dCtcIlwiLG89MDtvPHIubGVuZ3RoOyllW2gmb109aCYobl49MTkqZVtoJm9dKStyLmNoYXJDb2RlQXQobysrKTtyZXR1cm4gbShlKX1mdW5jdGlvbiBtKHQpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KDAsdCl9aWYobltcInNlZWRcIitzXT1wLHYobi5yYW5kb20oKSxlKSx0LmV4cG9ydHMpe3QuZXhwb3J0cz1wO3RyeXtyPXJlcXVpcmUoXCJjcnlwdG9cIil9Y2F0Y2godCl7fX19KFtdLE1hdGgpfSk7Q3IuYWxlYT1tcixDci54b3IxMjg9Z3IsQ3IueG9yd293PXlyLENyLnhvcnNoaWZ0Nz14cixDci54b3I0MDk2PXdyLENyLnR5Y2hlaT1icjt2YXIgRXI9Q3IuYWxlYSxScj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLG4scixvKXt0aGlzLm1lYW49dCx0aGlzLnN0ZERldj1lLHRoaXMuZHR5cGU9bix0aGlzLm5leHRWYWw9TmFOLHRoaXMudHJ1bmNhdGVkPXIsdGhpcy50cnVuY2F0ZWQmJih0aGlzLnVwcGVyPXRoaXMubWVhbisyKnRoaXMuc3RkRGV2LHRoaXMubG93ZXI9dGhpcy5tZWFuLTIqdGhpcy5zdGREZXYpO3ZhciBhPW98fE1hdGgucmFuZG9tKCk7dGhpcy5yYW5kb209RXIoYS50b1N0cmluZygpKX1yZXR1cm4gdC5wcm90b3R5cGUubmV4dFZhbHVlPWZ1bmN0aW9uKCl7aWYoIWlzTmFOKHRoaXMubmV4dFZhbCkpe3ZhciB0PXRoaXMubmV4dFZhbDtyZXR1cm4gdGhpcy5uZXh0VmFsPU5hTix0fWZvcih2YXIgZSxuLHI9ITE7IXI7KXt2YXIgbz12b2lkIDAsYT12b2lkIDAsaT12b2lkIDA7ZG97aT0obz0yKnRoaXMucmFuZG9tKCktMSkqbysoYT0yKnRoaXMucmFuZG9tKCktMSkqYX13aGlsZShpPj0xfHwwPT09aSk7dmFyIHM9TWF0aC5zcXJ0KC0yKk1hdGgubG9nKGkpL2kpO2U9dGhpcy5tZWFuK3RoaXMuc3RkRGV2Km8qcyxuPXRoaXMubWVhbit0aGlzLnN0ZERldiphKnMsdGhpcy50cnVuY2F0ZWQmJiF0aGlzLmlzVmFsaWRUcnVuY2F0ZWQoZSl8fChyPSEwKX1yZXR1cm4gdGhpcy50cnVuY2F0ZWQmJiF0aGlzLmlzVmFsaWRUcnVuY2F0ZWQobil8fCh0aGlzLm5leHRWYWw9dGhpcy5jb252ZXJ0VmFsdWUobikpLHRoaXMuY29udmVydFZhbHVlKGUpfSx0LnByb3RvdHlwZS5jb252ZXJ0VmFsdWU9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXRoaXMuZHR5cGV8fFwiZmxvYXQzMlwiPT09dGhpcy5kdHlwZT90Ok1hdGgucm91bmQodCl9LHQucHJvdG90eXBlLmlzVmFsaWRUcnVuY2F0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQ8PXRoaXMudXBwZXImJnQ+PXRoaXMubG93ZXJ9LHR9KCksU3I9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxuLHIpe3ZvaWQgMD09PXQmJih0PTApLHZvaWQgMD09PWUmJihlPTEpLHZvaWQgMD09PXImJihyPU1hdGgucmFuZG9tKCkpO3ZhciBvPXRoaXM7aWYodGhpcy5jYW5SZXR1cm5GbG9hdD1mdW5jdGlvbigpe3JldHVybiBudWxsPT1vLmR0eXBlfHxcImZsb2F0MzJcIj09PW8uZHR5cGV9LHRoaXMubWluPXQsdGhpcy5yYW5nZT1lLXQsdGhpcy5kdHlwZT1uLCF0aGlzLmNhblJldHVybkZsb2F0KCkmJnRoaXMucmFuZ2U8PTEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBcIit0K1wiIC0gXCIrZStcIiA8PSAxIGFuZCBkdHlwZSBpcyBub3QgZmxvYXRcIik7dGhpcy5yYW5kb209RXIoci50b1N0cmluZygpKX1yZXR1cm4gdC5wcm90b3R5cGUuY29udmVydFZhbHVlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNhblJldHVybkZsb2F0KCk/dDpNYXRoLnJvdW5kKHQpfSx0LnByb3RvdHlwZS5uZXh0VmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb252ZXJ0VmFsdWUodGhpcy5taW4rdGhpcy5yYW5nZSp0aGlzLnJhbmRvbSgpKX0sdH0oKTtmdW5jdGlvbiBOcih0LGUsbil7cmV0dXJuIHZvaWQgMD09PWUmJihlPVwiZmxvYXQzMlwiKSxlPWV8fFwiZmxvYXQzMlwiLEsodCksbmV3IGx0KHQsZSxuKX1mdW5jdGlvbiBrcih0LGUpe3ZvaWQgMD09PWUmJihlPSExKSxjb25zb2xlLmxvZyh0LnRvU3RyaW5nKGUpKX12YXIgSXI9QW4oe2JhdGNoVG9TcGFjZU5EXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9d24odCxcInhcIixcImJhdGNoVG9TcGFjZU5EXCIpLG89ZS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSk7cmV0dXJuIGQoci5yYW5rPj0xK2UubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJpbnB1dCByYW5rIGlzIFwiK3IucmFuaytcIiBidXQgc2hvdWxkIGJlID4gdGhhbiBibG9ja1NoYXBlLmxlbmd0aCBcIitlLmxlbmd0aH0pLGQobi5sZW5ndGg9PT1lLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiY3JvcHMubGVuZ3RoIGlzIFwiK24ubGVuZ3RoK1wiIGJ1dCBzaG91bGQgYmUgZXF1YWwgdG8gYmxvY2tTaGFwZS5sZW5ndGggIFwiK2UubGVuZ3RofSksZChyLnNoYXBlWzBdJW89PTAsZnVuY3Rpb24oKXtyZXR1cm5cImlucHV0IHRlbnNvciBiYXRjaCBpcyBcIityLnNoYXBlWzBdK1wiIGJ1dCBpcyBub3QgZGl2aXNpYmxlIGJ5IHRoZSBwcm9kdWN0IG9mIHRoZSBlbGVtZW50cyBvZiBibG9ja1NoYXBlIFwiK2Uuam9pbihcIiAqIFwiKStcIiA9PT0gXCIrb30pLER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5iYXRjaFRvU3BhY2VORChyLGUsbil9LHskeDpyfSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5zcGFjZVRvQmF0Y2hORChlLG4pfX19KX19KSxBcj1Bbih7Y2FzdF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwieFwiLFwiY2FzdFwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNhc3QobixlKX0seyR4Om59LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmNsb25lKCl9fX0pfX0pLFRyPUFuKHtjbG9uZV86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImNsb25lXCIsbnVsbCk7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gZnQubWFrZShlLnNoYXBlLHtkYXRhSWQ6ZS5kYXRhSWR9LGUuZHR5cGUpfSx7JHg6ZX0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQudG9GbG9hdCgpfX19KX19KSxEcj1Bbih7Y3Vtc3VtXzpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1lJiYoZT0wKSx2b2lkIDA9PT1uJiYobj0hMSksdm9pZCAwPT09ciYmKHI9ITEpO3ZhciBvPXduKHQsXCJ4XCIsXCJjdW1zdW1cIiksYT1ybihbZXw9MF0sby5yYW5rKSxpPW87bnVsbCE9YSYmKGk9by50cmFuc3Bvc2UoYSkpO3ZhciBzPWFuKDEsby5yYW5rKVswXSx1PUR0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5jdW1zdW0oaSxzLG4scil9LHtwZXJtdXRlZFg6aX0sZnVuY3Rpb24odCl7cmV0dXJue3Blcm11dGVkWDpmdW5jdGlvbigpe3JldHVybiB0LmN1bXN1bShlLG4sIXIpfX19KTtyZXR1cm4gbnVsbCE9YSYmKHU9dS50cmFuc3Bvc2UoYSkpLHV9fSksT3I9QW4oe2RlcHRoVG9TcGFjZV86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPVwiTkhXQ1wiKTt2YXIgcj13bih0LFwieFwiLFwiZGVwdGhUb1NwYWNlXCIpLG89XCJOSFdDXCI9PT1uP3Iuc2hhcGVbMV06ci5zaGFwZVsyXSxhPVwiTkhXQ1wiPT09bj9yLnNoYXBlWzJdOnIuc2hhcGVbM10saT1cIk5IV0NcIj09PW4/ci5zaGFwZVszXTpyLnNoYXBlWzFdO3JldHVybiBkKG8qZT49MCxmdW5jdGlvbigpe3JldHVyblwiTmVnYXRpdmUgZGltZW5zaW9uIHNpemUgY2F1c2VkIGJ5IG92ZXJmbG93IHdoZW4gbXVsdGlwbHlpbmdcXG4gICAgICBcIitvK1wiIGFuZCBcIitlK1wiICBmb3IgZGVwdGhUb1NwYWNlIHdpdGggaW5wdXQgc2hhcGVcXG4gICAgICBcIityLnNoYXBlfSksZChhKmU+PTAsZnVuY3Rpb24oKXtyZXR1cm5cIk5lZ2F0aXZlIGRpbWVuc2lvbiBzaXplIGNhdXNlZCBieSBvdmVyZmxvdyB3aGVuIG11bHRpcGx5aW5nXFxuICAgICAgXCIrYStcIiBhbmQgXCIrZStcIiBmb3IgZGVwdGhUb1NwYWNlIHdpdGggaW5wdXQgc2hhcGVcXG4gICAgICAgICAgXCIrci5zaGFwZX0pLGQoaSUoZSplKT09MCxmdW5jdGlvbigpe3JldHVyblwiRGltZW5zaW9uIHNpemUgbXVzdCBiZSBldmVubHkgZGl2aXNpYmxlIGJ5IFwiK2UqZStcIiBidXQgaXMgXCIraStcIiBmb3IgZGVwdGhUb1NwYWNlIHdpdGggaW5wdXQgc2hhcGUgXCIrci5zaGFwZX0pLER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5kZXB0aFRvU3BhY2UocixlLG4pfSx7JHg6cn0pfX0pLF9yPUFuKHtleHBhbmREaW1zXzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPTApO3ZhciBuPXduKHQsXCJ4XCIsXCJleHBhbmREaW1zXCIpO2QoZTw9bi5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJBeGlzIG11c3QgYmUgPD0gcmFuayBvZiB0aGUgdGVuc29yXCJ9KTt2YXIgcj1uLnNoYXBlLnNsaWNlKCk7cmV0dXJuIGU8MCYmKGQoLShuLnJhbmsrMSk8PWUsZnVuY3Rpb24oKXtyZXR1cm5cIkF4aXMgbXVzdCBiZSBpbiB0aGUgaW50ZXJ2YWwgW1wiKy0obi5yYW5rKzEpK1wiLCBcIituLnJhbmsrXCJdXCJ9KSxlPW4ucmFuaytlKzEpLHIuc3BsaWNlKGUsMCwxKSxIcihuLHIpfX0pLE1yPUFuKHtleWVfOmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPVwiZmxvYXQzMlwiKSxudWxsPT1lJiYoZT10KTtmb3IodmFyIG89TnIoW3QsZV0sciksYT10PD1lP3Q6ZSxpPTA7aTxhOysraSlvLnNldCgxLGksaSk7dmFyIHM9by50b1RlbnNvcigpLmFzMkQodCxlKTtpZihudWxsPT1uKXJldHVybiBzO2lmKDE9PT1uLmxlbmd0aClyZXR1cm4gWHIoX3IocywwKSxbblswXSwxLDFdKTtpZigyPT09bi5sZW5ndGgpcmV0dXJuIFhyKF9yKF9yKHMsMCksMCksW25bMF0sblsxXSwxLDFdKTtpZigzPT09bi5sZW5ndGgpcmV0dXJuIFhyKF9yKF9yKF9yKHMsMCksMCksMCksW25bMF0sblsxXSxuWzJdLDEsMV0pO3Rocm93IG5ldyBFcnJvcihcImV5ZSgpIGN1cnJlbnRseSBzdXBwb3J0cyBvbmx5IDFEIGFuZCAyRCBiYXRjaFNoYXBlcywgYnV0IHJlY2VpdmVkIFwiK24ubGVuZ3RoK1wiRC5cIil9fSksRnI9QW4oe211bHRpbm9taWFsXzpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj0hMSk7dmFyIG89d24odCxcImxvZ2l0c1wiLFwibXVsdGlub21pYWxcIiksYT1vLnNpemUsaT1vLnJhbms7aWYoYTwyKXRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIG11bHRpbm9taWFsOiB5b3UgbmVlZCBhdCBsZWFzdCAyIG91dGNvbWVzLCBidXQgZ290IFwiK2ErXCIuXCIpO2lmKGk+Mil0aHJvdyBuZXcgRXJyb3IoXCJSYW5rIG9mIHByb2JhYmlsaXRpZXMgbXVzdCBiZSAxIG9yIDIsIGJ1dCBpcyBcIitpKTtuPW58fE1hdGgucmFuZG9tKCk7dmFyIHM9MT09PWk/by5hczJEKDEsLTEpOm8sdT1EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQubXVsdGlub21pYWwocyxyLGUsbil9LHtsb2dpdHMyRDpzfSk7cmV0dXJuIDE9PT1pP3UuYXMxRCgpOnV9fSksQnI9QW4oe29uZUhvdF86ZnVuY3Rpb24odCxlLG4scil7aWYodm9pZCAwPT09biYmKG49MSksdm9pZCAwPT09ciYmKHI9MCksZTwyKXRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIG9uZUhvdDogZGVwdGggbXVzdCBiZSA+PTIsIGJ1dCBpdCBpcyBcIitlKTt2YXIgbz13bih0LFwiaW5kaWNlc1wiLFwib25lSG90XCIsXCJpbnQzMlwiKSxhPW8uc2hhcGUuY29uY2F0KFtlXSk7cmV0dXJuIG89by5mbGF0dGVuKCksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm9uZUhvdChvLGUsbixyKX0seyRpbmRpY2VzOm99LGZ1bmN0aW9uKHQpe3JldHVybnskaW5kaWNlczpmdW5jdGlvbigpe3JldHVybiBxbihvLnNoYXBlLFwiZmxvYXQzMlwiKX19fSkucmVzaGFwZShhKX19KSxQcj1Bbih7cGFkXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49MCk7dmFyIHI9d24odCxcInhcIixcInBhZFwiKTtpZigwPT09ci5yYW5rKXRocm93IG5ldyBFcnJvcihcInBhZChzY2FsYXIpIGlzIG5vdCBkZWZpbmVkLiBQYXNzIG5vbi1zY2FsYXIgdG8gcGFkXCIpO3ZhciBvPWUubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0WzBdfSk7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5wYWQocixlLG4pfSx7JHg6cn0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuc2xpY2UobyxyLnNoYXBlKX19fSl9fSksTHI9QW4oe3BhZDFkXzpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPTApLGQoMj09PWUubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJJbnZhbGlkIG51bWJlciBvZiBwYWRkaW5ncy4gTXVzdCBiZSBsZW5ndGggb2YgMi5cIn0pLFByKHQsW2VdLG4pfX0pLFdyPUFuKHtwYWQyZF86ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0wKSxkKDI9PT1lLmxlbmd0aCYmMj09PWVbMF0ubGVuZ3RoJiYyPT09ZVsxXS5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIkludmFsaWQgbnVtYmVyIG9mIHBhZGRpbmdzLiBNdXN0IGJlIGxlbmd0aCBvZiAyIGVhY2guXCJ9KSxQcih0LGUsbil9fSksVXI9QW4oe3BhZDNkXzpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPTApLGQoMz09PWUubGVuZ3RoJiYyPT09ZVswXS5sZW5ndGgmJjI9PT1lWzFdLmxlbmd0aCYmMj09PWVbMl0ubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJJbnZhbGlkIG51bWJlciBvZiBwYWRkaW5ncy4gTXVzdCBiZSBsZW5ndGggb2YgMiBlYWNoLlwifSksUHIodCxlLG4pfX0pLHpyPUFuKHtwYWQ0ZF86ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0wKSxkKDQ9PT1lLmxlbmd0aCYmMj09PWVbMF0ubGVuZ3RoJiYyPT09ZVsxXS5sZW5ndGgmJjI9PT1lWzJdLmxlbmd0aCYmMj09PWVbM10ubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJJbnZhbGlkIG51bWJlciBvZiBwYWRkaW5ncy4gTXVzdCBiZSBsZW5ndGggb2YgMiBlYWNoLlwifSksUHIodCxlLG4pfX0pLFZyPUFuKHtyYW5kXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9eSh0KSxvPW51bGw7aWYobnVsbD09bnx8XCJmbG9hdDMyXCI9PT1uKW89bmV3IEZsb2F0MzJBcnJheShyKTtlbHNlIGlmKFwiaW50MzJcIj09PW4pbz1uZXcgSW50MzJBcnJheShyKTtlbHNle2lmKFwiYm9vbFwiIT09bil0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBcIituKTtvPW5ldyBVaW50OEFycmF5KHIpfWZvcih2YXIgYT0wO2E8cjthKyspb1thXT1lKCk7cmV0dXJuIGZ0Lm1ha2UodCx7dmFsdWVzOm99LG4pfX0pLEdyPUFuKHtyYW5kb21Ob3JtYWxfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7aWYodm9pZCAwPT09ZSYmKGU9MCksdm9pZCAwPT09biYmKG49MSksbnVsbCE9ciYmXCJib29sXCI9PT1yKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGRhdGEgdHlwZSBcIityKTtmb3IodmFyIGE9bmV3IFJyKGUsbixyLCExLG8pLGk9TnIodCxyKSxzPTA7czxpLnZhbHVlcy5sZW5ndGg7cysrKWkudmFsdWVzW3NdPWEubmV4dFZhbHVlKCk7cmV0dXJuIGkudG9UZW5zb3IoKX19KSxxcj1Bbih7cmFuZG9tVW5pZm9ybV86ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1lJiYoZT0wKSx2b2lkIDA9PT1uJiYobj0xKSx2b2lkIDA9PT1yJiYocj1cImZsb2F0MzJcIik7Zm9yKHZhciBhPU5yKHQsciksaT1uZXcgU3IoZSxuLG51bGwsbykscz0wO3M8YS52YWx1ZXMubGVuZ3RoO3MrKylhLnZhbHVlc1tzXT1pLm5leHRWYWx1ZSgpO3JldHVybiBhLnRvVGVuc29yKCl9fSksSHI9QW4oe3Jlc2hhcGVfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcInhcIixcInJlc2hhcGVcIixudWxsKTtyZXR1cm4gZT1TKGUsbi5zaXplKSxkKG4uc2l6ZT09PXkoZSksZnVuY3Rpb24oKXtyZXR1cm5cIm5ldyBzaGFwZSBhbmQgb2xkIHNoYXBlIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuXCJ9KSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQucmVzaGFwZShuLGUpfSx7JHg6bn0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQucmVzaGFwZShuLnNoYXBlKX19fSl9fSksJHI9QW4oe3NwYWNlVG9CYXRjaE5EXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9d24odCxcInhcIixcInNwYWNlVG9CYXRjaE5EXCIpO3JldHVybiBkKHIucmFuaz49MStlLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiaW5wdXQgcmFuayBcIityLnJhbmsrXCIgc2hvdWxkIGJlID4gdGhhbiBbYmxvY2tTaGFwZV0gXCIrZS5sZW5ndGh9KSxkKG4ubGVuZ3RoPT09ZS5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cInBhZGRpbmdzLnNoYXBlWzBdIFwiK24ubGVuZ3RoK1wiIG11c3QgYmUgZXF1YWwgdG8gW2Jsb2NrU2hhcGVdIFwiK2UubGVuZ3RofSksZChyLnNoYXBlLnJlZHVjZShmdW5jdGlvbih0LHIsbyl7cmV0dXJuIG8+MCYmbzw9ZS5sZW5ndGg/dCYmKHIrbltvLTFdWzBdK25bby0xXVsxXSklZVtvLTFdPT0wOnR9LCEwKSxmdW5jdGlvbigpe3JldHVyblwiaW5wdXQgc3BhdGlhbCBkaW1lbnNpb25zIFwiK3Iuc2hhcGUuc2xpY2UoMSkrXCIgd2l0aCBwYWRkaW5ncyBcIituLnRvU3RyaW5nKCkrXCIgbXVzdCBiZSBkaXZpc2libGUgYnkgYmxvY2tTaGFwZXMgXCIrZS50b1N0cmluZygpfSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNwYWNlVG9CYXRjaE5EKHIsZSxuKX0seyR4OnJ9LGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmJhdGNoVG9TcGFjZU5EKGUsbil9fX0pfX0pLGpyPUFuKHtzcXVlZXplXzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJ4XCIsXCJzcXVlZXplXCIpO3JldHVybiBIcihuLGsobi5zaGFwZSxlKS5uZXdTaGFwZSl9fSksS3I9QW4oe3N0YWNrXzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPTApO3ZhciBuPWJuKHQsXCJ0ZW5zb3JzXCIsXCJzdGFja1wiKTtpZihkKG4ubGVuZ3RoPj0xLGZ1bmN0aW9uKCl7cmV0dXJuXCJQYXNzIGF0IGxlYXN0IG9uZSB0ZW5zb3IgdG8gdGYuc3RhY2tcIn0pLDE9PT1uLmxlbmd0aClyZXR1cm4gblswXS5leHBhbmREaW1zKGUpO3ZhciByPW5bMF0ucmFuayxvPW5bMF0uc2hhcGUsYT1uWzBdLmR0eXBlO2QoZTw9cixmdW5jdGlvbigpe3JldHVyblwiQXhpcyBtdXN0IGJlIDw9IHJhbmsgb2YgdGhlIHRlbnNvclwifSksbi5mb3JFYWNoKGZ1bmN0aW9uKHQpe3Yobyx0LnNoYXBlLFwiQWxsIHRlbnNvcnMgcGFzc2VkIHRvIHN0YWNrIG11c3QgaGF2ZSBtYXRjaGluZyBzaGFwZXNcIil9KSxuLmZvckVhY2goZnVuY3Rpb24odCl7ZChhPT09dC5kdHlwZSxmdW5jdGlvbigpe3JldHVyblwiQWxsIHRlbnNvcnMgcGFzc2VkIHRvIHN0YWNrIG11c3QgaGF2ZSBtYXRjaGluZyBkdHlwZXNcIn0pfSk7dmFyIGk9bi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuZXhwYW5kRGltcyhlKX0pO3JldHVybiBscihpLGUpfX0pLFhyPUFuKHt0aWxlXzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJ4XCIsXCJ0aWxlXCIpO3JldHVybiBkKG4ucmFuaz09PWUubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiB0cmFuc3Bvc2U6IHJhbmsgb2YgaW5wdXQgXCIrbi5yYW5rK1wiIG11c3QgbWF0Y2ggbGVuZ3RoIG9mIHJlcHMgXCIrZStcIi5cIn0pLER0LnJ1bktlcm5lbChmdW5jdGlvbih0LHIpe3ZhciBvPXQudGlsZShuLGUpO3JldHVybiByKFtuXSksb30seyR4Om59LGZ1bmN0aW9uKHQsbil7dmFyIHI9blswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXt2YXIgbj1YbihyKTtpZigxPT09ci5yYW5rKWZvcih2YXIgbz0wO288ZVswXTsrK28pbj1uLmFkZCh0LnNsaWNlKFtvKnIuc2hhcGVbMF1dLFtyLnNoYXBlWzBdXSkpO2Vsc2UgaWYoMj09PXIucmFuaylmb3Iobz0wO288ZVswXTsrK28pZm9yKHZhciBhPTA7YTxlWzFdOysrYSluPW4uYWRkKHQuc2xpY2UoW28qci5zaGFwZVswXSxhKnIuc2hhcGVbMV1dLFtyLnNoYXBlWzBdLHIuc2hhcGVbMV1dKSk7ZWxzZSBpZigzPT09ci5yYW5rKWZvcihvPTA7bzxlWzBdOysrbylmb3IoYT0wO2E8ZVsxXTsrK2EpZm9yKHZhciBpPTA7aTxlWzJdOysraSluPW4uYWRkKHQuc2xpY2UoW28qci5zaGFwZVswXSxhKnIuc2hhcGVbMV0saSpyLnNoYXBlWzJdXSxbci5zaGFwZVswXSxyLnNoYXBlWzFdLHIuc2hhcGVbMl1dKSk7ZWxzZXtpZig0IT09ci5yYW5rKXRocm93IG5ldyBFcnJvcihcIkdyYWRpZW50IGZvciB0aWxlIG9wZXJhdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIHJhbmstXCIrci5yYW5rK1wiIHRlbnNvcnMgeWV0LlwiKTtmb3Iobz0wO288ZVswXTsrK28pZm9yKGE9MDthPGVbMV07KythKWZvcihpPTA7aTxlWzJdOysraSlmb3IodmFyIHM9MDtzPGVbM107KytzKW49bi5hZGQodC5zbGljZShbbypyLnNoYXBlWzBdLGEqci5zaGFwZVsxXSxpKnIuc2hhcGVbMl0scypyLnNoYXBlWzNdXSxbci5zaGFwZVswXSxyLnNoYXBlWzFdLHIuc2hhcGVbMl0sci5zaGFwZVszXV0pKX1yZXR1cm4gbn19fSl9fSksWXI9QW4oe3RydW5jYXRlZE5vcm1hbF86ZnVuY3Rpb24odCxlLG4scixvKXtpZih2b2lkIDA9PT1lJiYoZT0wKSx2b2lkIDA9PT1uJiYobj0xKSxudWxsIT1yJiZcImJvb2xcIj09PXIpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZGF0YSB0eXBlIFwiK3IpO2Zvcih2YXIgYT1uZXcgUnIoZSxuLHIsITAsbyksaT1Ocih0LHIpLHM9MDtzPGkudmFsdWVzLmxlbmd0aDtzKyspaS52YWx1ZXNbc109YS5uZXh0VmFsdWUoKTtyZXR1cm4gaS50b1RlbnNvcigpfX0pLFFyPUFuKHt1bnN0YWNrXzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPTApLGU9ZXx8MDt2YXIgbj13bih0LFwieFwiLFwidW5zdGFja1wiKTtyZXR1cm4gZChlPj0tbi5zaGFwZS5sZW5ndGgmJmU8bi5zaGFwZS5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIkF4aXMgPSBcIitlK1wiIGlzIG5vdCBpbiBbLVwiK24uc2hhcGUubGVuZ3RoK1wiLCBcIituLnNoYXBlLmxlbmd0aCtcIilcIn0pLGU8MCYmKGUrPW4uc2hhcGUubGVuZ3RoKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQudW5zdGFjayhuLGUpfSx7JHg6bn0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIEtyKHQsZSl9fX0pfX0pLEpyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIG4scixhLGkscyx1LGwsYyxoLHA7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOnJldHVybiBuPXduKHQsXCJ4XCIsXCJzZXRkaWZmMWRcIikscj13bihlLFwieVwiLFwic2V0ZGlmZjFkXCIpLGQobi5kdHlwZT09PXIuZHR5cGUsZnVuY3Rpb24oKXtyZXR1cm5cInggYW5kIHkgc2hvdWxkIGhhdmUgdGhlIHNhbWUgZHR5cGUsIGJ1dCBnb3QgeCAoXCIrbi5kdHlwZStcIikgYW5kIHkgKFwiK3IuZHR5cGUrXCIpLlwifSksZCgxPT09bi5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJ4IHNob3VsZCBiZSAxRCB0ZW5zb3IsIGJ1dCBnb3QgeCAoXCIrbi5zaGFwZStcIikuXCJ9KSxkKDE9PT1yLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cInkgc2hvdWxkIGJlIDFEIHRlbnNvciwgYnV0IGdvdCB5IChcIityLnNoYXBlK1wiKS5cIn0pLFs0LG4uZGF0YSgpXTtjYXNlIDE6cmV0dXJuIGE9by5zZW50KCksWzQsci5kYXRhKCldO2Nhc2UgMjpmb3IoaT1vLnNlbnQoKSxzPW5ldyBTZXQoaSksdT0wLGg9MDtoPGEubGVuZ3RoO2grKylzLmhhcyhhW2hdKXx8dSsrO2ZvcihsPW5ldyBsdChbdV0sbi5kdHlwZSksYz1uZXcgbHQoW3VdLFwiaW50MzJcIiksaD0wLHA9MDtoPGEubGVuZ3RoO2grKylzLmhhcyhhW2hdKXx8KGwudmFsdWVzW3BdPWFbaF0sYy52YWx1ZXNbcF09aCxwKyspO3JldHVyblsyLFtsLnRvVGVuc29yKCksYy50b1RlbnNvcigpXV19fSl9KX07ZnVuY3Rpb24gWnIodCxlKXtmb3IodmFyIG49W10scj0wO3I8ZS5sZW5ndGg7cisrKWVbcl0mJm4ucHVzaChyKTt2YXIgbz1Ocih0LFwiaW50MzJcIiksYT1Ocihbbi5sZW5ndGgsdC5sZW5ndGhdLFwiaW50MzJcIik7Zm9yKHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIGk9by5pbmRleFRvTG9jKG5bcl0pLHM9cip0Lmxlbmd0aDthLnZhbHVlcy5zZXQoaSxzKX1yZXR1cm4gYS50b1RlbnNvcigpfXZhciB0bz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUpe3RoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudmFyaWFibGVOYW1lcz1lLm1hcChmdW5jdGlvbih0LGUpe3JldHVyblwiVFwiK2V9KTt2YXIgbj1bXTt0aGlzLnZhcmlhYmxlTmFtZXMuZm9yRWFjaChmdW5jdGlvbih0KXtuLnB1c2goXCJmbG9hdCB2XCIrdCtcIiA9IGdldFwiK3QrXCJBdE91dENvb3JkcygpO1wiKX0pO3ZhciByPXRoaXMudmFyaWFibGVOYW1lcy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJ2XCIrdH0pLmpvaW4oXCIgKyBcIik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK24uam9pbihcIlxcbiAgICAgICAgXCIpK1wiXFxuXFxuICAgICAgICBmbG9hdCByZXN1bHQgPSBcIityK1wiO1xcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksZW89ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlKXt0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnZhcmlhYmxlTmFtZXM9ZS5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm5cIlRcIitlfSk7dmFyIG49W107dGhpcy52YXJpYWJsZU5hbWVzLmZvckVhY2goZnVuY3Rpb24odCl7bi5wdXNoKFwidmVjNCB2XCIrdCtcIiA9IGdldFwiK3QrXCJBdE91dENvb3JkcygpO1wiKX0pO3ZhciByPXRoaXMudmFyaWFibGVOYW1lcy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJ2XCIrdH0pLmpvaW4oXCIgKyBcIik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK24uam9pbihcIlxcbiAgICAgICAgXCIpK1wiXFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IFwiK3IrXCI7XFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxubz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl07dmFyIHI9dC53aW5kb3dTaXplLG89dC5iYXRjaFNpemUsYT10LmluU2l6ZSxpPU1hdGguY2VpbChhL3IpO258fHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwiYmVzdEluZGljZXNBXCIpLHRoaXMub3V0cHV0U2hhcGU9W28saV07dmFyIHM9XCJtYXhcIj09PWU/XCI+XCI6XCI8XCIsdT1uP1wiaW5PZmZzZXQgKyBpO1wiOlwicm91bmQoZ2V0QmVzdEluZGljZXNBKGJhdGNoLCBpbk9mZnNldCArIGkpKTtcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGluT2Zmc2V0ID0gb3V0SWR4ICogXCIrcitcIjtcXG5cXG4gICAgICAgIGludCBiZXN0SW5kZXggPSBpbk9mZnNldDtcXG4gICAgICAgIGZsb2F0IGJlc3RWYWx1ZSA9IGdldEEoYmF0Y2gsIGJlc3RJbmRleCk7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK3IrXCI7IGkrKykge1xcbiAgICAgICAgICBpbnQgaW5JZHggPSBcIit1K1wiO1xcbiAgICAgICAgICBmbG9hdCBjYW5kaWRhdGUgPSBnZXRBKGJhdGNoLCBpbklkeCk7XFxuICAgICAgICAgIGlmIChjYW5kaWRhdGUgXCIrcytcIiBiZXN0VmFsdWUpIHtcXG4gICAgICAgICAgICBiZXN0VmFsdWUgPSBjYW5kaWRhdGU7XFxuICAgICAgICAgICAgYmVzdEluZGV4ID0gaW5JZHg7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChiZXN0SW5kZXgpKTtcXG4gICAgICB9XFxuICAgIFwifX0oKTtmdW5jdGlvbiBybyh0LGUpe3JldHVybltcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl0uc2xpY2UoMCxlKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHQrXCIuXCIrZX0pfWZ1bmN0aW9uIG9vKHQsZSl7cmV0dXJuIDE9PT1lP1t0XTpybyh0LGUpfWZ1bmN0aW9uIGFvKHQsZSl7Zm9yKHZhciBuPXQubGVuZ3RoLHI9W10sbz0wO288bjtvKyspe3ZhciBhPW4tMS1vLGk9dFthXXx8MTsoZVtlLmxlbmd0aC0xLW9dfHwxKT4xJiYxPT09aSYmci51bnNoaWZ0KGEpfXJldHVybiByfWZ1bmN0aW9uIGlvKHQsZSl7Zm9yKHZhciBuPVtdLHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIG89dFt0Lmxlbmd0aC1yLTFdLGE9ZS5sZW5ndGgtci0xLGk9ZVthXTsobnVsbD09b3x8MT09PW8mJmk+MSkmJm4udW5zaGlmdChhKX1yZXR1cm4gbn1mdW5jdGlvbiBzbyh0LGUpe2Zvcih2YXIgbj1bXSxyPU1hdGgubWF4KHQubGVuZ3RoLGUubGVuZ3RoKSxvPTA7bzxyO28rKyl7dmFyIGE9dFt0Lmxlbmd0aC1vLTFdO251bGw9PWEmJihhPTEpO3ZhciBpPWVbZS5sZW5ndGgtby0xXTtpZihudWxsPT1pJiYoaT0xKSwxPT09YSluLnVuc2hpZnQoaSk7ZWxzZSBpZigxPT09aSluLnVuc2hpZnQoYSk7ZWxzZXtpZihhIT09aSl0aHJvdyBFcnJvcihcIk9wZXJhbmRzIGNvdWxkIG5vdCBiZSBicm9hZGNhc3QgdG9nZXRoZXIgd2l0aCBzaGFwZXMgXCIrdCtcIiBhbmQgXCIrZStcIi5cIik7bi51bnNoaWZ0KGEpfX1yZXR1cm4gbn1mdW5jdGlvbiB1bygpe3ZhciB0LGUsbixyLG8saSxzLHUsbCxjO3JldHVybiAyPT09YS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpPyh0PVwiI3ZlcnNpb24gMzAwIGVzXCIsZT1cImluXCIsbj1cIm91dFwiLHI9XCJpblwiLG89XCJ0ZXh0dXJlXCIsaT1cIm91dHB1dENvbG9yXCIscz1cIm91dCB2ZWM0IG91dHB1dENvbG9yO1wiLHU9XCJcXG4gICAgICBib29sIGlzbmFuX2N1c3RvbShmbG9hdCB2YWwpIHtcXG4gICAgICAgIHJldHVybiAodmFsID4gMC4gfHwgdmFsIDwgMC4gfHwgdmFsID09IDAuKSA/IGZhbHNlIDogdHJ1ZTtcXG4gICAgICB9XFxuICAgIFwiLGw9XCJcXG4gICAgICBjb25zdCBmbG9hdCBJTkZJTklUWSA9IHVpbnRCaXRzVG9GbG9hdCh1aW50KDB4N2Y4MDAwMDApKTtcXG4gICAgXCIsYz1cIlxcbiAgICAgICNkZWZpbmUgcm91bmQodmFsdWUpIG5ld1JvdW5kKHZhbHVlKVxcbiAgICAgIGludCBuZXdSb3VuZChmbG9hdCB2YWx1ZSkge1xcbiAgICAgICAgcmV0dXJuIGludChmbG9vcih2YWx1ZSArIDAuNSkpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpdmVjNCBuZXdSb3VuZCh2ZWM0IHZhbHVlKSB7XFxuICAgICAgICByZXR1cm4gaXZlYzQoZmxvb3IodmFsdWUgKyB2ZWM0KDAuNSkpKTtcXG4gICAgICB9XFxuICAgIFwiKToodD1cIlwiLGU9XCJhdHRyaWJ1dGVcIixuPVwidmFyeWluZ1wiLHI9XCJ2YXJ5aW5nXCIsbz1cInRleHR1cmUyRFwiLGk9XCJnbF9GcmFnQ29sb3JcIixzPVwiXCIsdT1cIlxcbiAgICAgIGJvb2wgaXNuYW5fY3VzdG9tKGZsb2F0IHZhbCkge1xcbiAgICAgICAgcmV0dXJuICh2YWwgPiAwLiB8fCB2YWwgPCAxLiB8fCB2YWwgPT0gMC4pID8gZmFsc2UgOiB0cnVlO1xcbiAgICAgIH1cXG4gICAgXCIsbD1cIlxcbiAgICAgIHVuaWZvcm0gZmxvYXQgSU5GSU5JVFk7XFxuXFxuICAgICAgYm9vbCBpc2luZihmbG9hdCB2YWwpIHtcXG4gICAgICAgIHJldHVybiBhYnModmFsKSA9PSBJTkZJTklUWTtcXG4gICAgICB9XFxuICAgICAgYnZlYzQgaXNpbmYodmVjNCB2YWwpIHtcXG4gICAgICAgIHJldHVybiBlcXVhbChhYnModmFsKSwgdmVjNChJTkZJTklUWSkpO1xcbiAgICAgIH1cXG4gICAgXCIsYz1cIlxcbiAgICAgIGludCByb3VuZChmbG9hdCB2YWx1ZSkge1xcbiAgICAgICAgcmV0dXJuIGludChmbG9vcih2YWx1ZSArIDAuNSkpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpdmVjNCByb3VuZCh2ZWM0IHZhbHVlKSB7XFxuICAgICAgICByZXR1cm4gaXZlYzQoZmxvb3IodmFsdWUgKyB2ZWM0KDAuNSkpKTtcXG4gICAgICB9XFxuICAgIFwiKSx7dmVyc2lvbjp0LGF0dHJpYnV0ZTplLHZhcnlpbmdWczpuLHZhcnlpbmdGczpyLHRleHR1cmUyRDpvLG91dHB1dDppLGRlZmluZU91dHB1dDpzLGRlZmluZVNwZWNpYWxOYU46dSxkZWZpbmVTcGVjaWFsSW5mOmwsZGVmaW5lUm91bmQ6Y319ZnVuY3Rpb24gbG8odCxlLG4pe3ZvaWQgMD09PW4mJihuPVwiaW5kZXhcIik7dmFyIHI9VihlKTtyZXR1cm4gci5tYXAoZnVuY3Rpb24oZSxvKXtyZXR1cm5cImludCBcIit0W29dK1wiID0gXCIrbitcIiAvIFwiK2UrXCI7IFwiKyhvPT09ci5sZW5ndGgtMT9cImludCBcIit0W28rMV0rXCIgPSBcIituK1wiIC0gXCIrdFtvXStcIiAqIFwiK2U6XCJpbmRleCAtPSBcIit0W29dK1wiICogXCIrZSkrXCI7XCJ9KS5qb2luKFwiXCIpfWZ1bmN0aW9uIGNvKHQpe3JldHVybiAxPT09dC5sZW5ndGg/XCJcIit0WzBdOlwidmVjXCIrdC5sZW5ndGgrXCIoXCIrdC5qb2luKFwiLFwiKStcIilcIn1mdW5jdGlvbiBobyh0LGUsbixyKXt2YXIgbz1bXTt0LmZvckVhY2goZnVuY3Rpb24odCl7dmFyIGU9eSh0LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUpO3Quc2hhcGVJbmZvLmlzVW5pZm9ybT9vLnB1c2goXCJ1bmlmb3JtIGZsb2F0IFwiK3QubmFtZSsoZT4xP1wiW1wiK2UrXCJdXCI6XCJcIikrXCI7XCIpOihvLnB1c2goXCJ1bmlmb3JtIHNhbXBsZXIyRCBcIit0Lm5hbWUrXCI7XCIpLG8ucHVzaChcInVuaWZvcm0gaW50IG9mZnNldFwiK3QubmFtZStcIjtcIikpfSk7dmFyIGEsaSxzPW8uam9pbihcIlxcblwiKSx1PXQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49ITEpO3ZhciByPVwiXCI7cis9bj9mbyh0KTpwbyh0KTt2YXIgbz10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsYT1lLmxvZ2ljYWxTaGFwZTtvLmxlbmd0aDw9YS5sZW5ndGgmJihyKz1uP2Z1bmN0aW9uKHQsZSl7dmFyIG4scj10Lm5hbWUsbz1yLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Iuc2xpY2UoMSksYT1cImdldFwiK28rXCJBdE91dENvb3Jkc1wiLGk9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aCxzPWUubG9naWNhbFNoYXBlLmxlbmd0aCx1PWFvKHQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxlLmxvZ2ljYWxTaGFwZSksbD1ibyhzKSxjPXMtaSxoPVtcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl07bj0wPT09aT9cIlwiOnM8MiYmdS5sZW5ndGg+PTE/XCJjb29yZHMgPSAwO1wiOnUubWFwKGZ1bmN0aW9uKHQpe3JldHVyblwiY29vcmRzLlwiK2hbdCtjXStcIiA9IDA7XCJ9KS5qb2luKFwiXFxuXCIpO3ZhciBwPVwiXCI7cD1zPDImJmk+MD9cImNvb3Jkc1wiOnQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm5cImNvb3Jkcy5cIitoW2UrY119KS5qb2luKFwiLCBcIik7dmFyIGY9XCJyZXR1cm4gb3V0cHV0VmFsdWU7XCIsZD0xPT09eSh0LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUpLHY9MT09PXkoZS5sb2dpY2FsU2hhcGUpO2lmKDEhPT1pfHxkfHx2KXtpZihkJiYhdilmPTE9PT1zP1wiXFxuICAgICAgICByZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54LCBvdXRwdXRWYWx1ZS54LCAwLiwgMC4pO1xcbiAgICAgIFwiOlwiXFxuICAgICAgICByZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54KTtcXG4gICAgICBcIjtlbHNlIGlmKHUubGVuZ3RoKXt2YXIgbT1pLTIsZz1pLTE7dS5pbmRleE9mKG0pPi0xJiZ1LmluZGV4T2YoZyk+LTE/Zj1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpO1wiOnUuaW5kZXhPZihtKT4tMT9mPVwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSwgb3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSk7XCI6dS5pbmRleE9mKGcpPi0xJiYoZj1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh4LCBvdXRwdXRWYWx1ZS56eik7XCIpfX1lbHNlIGY9XCJcXG4gICAgICByZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54eSwgb3V0cHV0VmFsdWUueHkpO1xcbiAgICBcIjtyZXR1cm5cIlxcbiAgICB2ZWM0IFwiK2ErXCIoKSB7XFxuICAgICAgXCIrbCtcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICBcIituK1wiXFxuICAgICAgdmVjNCBvdXRwdXRWYWx1ZSA9IGdldFwiK28rXCIoXCIrcCtcIik7XFxuICAgICAgXCIrZitcIlxcbiAgICB9XFxuICBcIn0odCxlKTpmdW5jdGlvbih0LGUpe3ZhciBuPXQubmFtZSxyPW4uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxvPVwiZ2V0XCIrcitcIkF0T3V0Q29vcmRzXCIsYT1lLnRleFNoYXBlLGk9dC5zaGFwZUluZm8udGV4U2hhcGUscz10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubGVuZ3RoLHU9ZS5sb2dpY2FsU2hhcGUubGVuZ3RoO2lmKCF0LnNoYXBlSW5mby5pc1VuaWZvcm0mJnM9PT11JiZudWxsPT10LnNoYXBlSW5mby5mbGF0T2Zmc2V0JiZ4KGksYSkpcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIitvK1wiKCkge1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgcmVzdWx0VVYpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIGwsYz1ibyh1KSxoPWFvKHQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxlLmxvZ2ljYWxTaGFwZSkscD11LXMsZj1bXCJ4XCIsXCJ5XCIsXCJ6XCIsXCJ3XCIsXCJ1XCIsXCJ2XCJdO2w9MD09PXM/XCJcIjp1PDImJmgubGVuZ3RoPj0xP1wiY29vcmRzID0gMDtcIjpoLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cImNvb3Jkcy5cIitmW3QrcF0rXCIgPSAwO1wifSkuam9pbihcIlxcblwiKTt2YXIgZD1cIlwiO2Q9dTwyJiZzPjA/XCJjb29yZHNcIjp0LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJjb29yZHMuXCIrZltlK3BdfSkuam9pbihcIiwgXCIpO3JldHVyblwiXFxuICAgIGZsb2F0IFwiK28rXCIoKSB7XFxuICAgICAgXCIrYytcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICBcIitsK1wiXFxuICAgICAgcmV0dXJuIGdldFwiK3IrXCIoXCIrZCtcIik7XFxuICAgIH1cXG4gIFwifSh0LGUpKTtyZXR1cm4gcn0odCxlLHIpfSkuam9pbihcIlxcblwiKSxsPWUudGV4U2hhcGUsYz11bygpLGg9ZnVuY3Rpb24odCl7cmV0dXJuXCJcXG4gICAgZmxvYXQgc2FtcGxlVGV4dHVyZShzYW1wbGVyMkQgdGV4dHVyZVNhbXBsZXIsIHZlYzIgdXYpIHtcXG4gICAgICByZXR1cm4gXCIrdC50ZXh0dXJlMkQrXCIodGV4dHVyZVNhbXBsZXIsIHV2KS5yO1xcbiAgICB9XFxuICBcIn0oYykscD1mdW5jdGlvbih0KXtyZXR1cm4gdC52ZXJzaW9uK1wiXFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGludDtcXG4gICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcXG4gICAgXCIrdC52YXJ5aW5nRnMrXCIgdmVjMiByZXN1bHRVVjtcXG4gICAgXCIrdC5kZWZpbmVPdXRwdXQrXCJcXG4gICAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcXG5cXG4gICAgc3RydWN0IGl2ZWM1XFxuICAgIHtcXG4gICAgICBpbnQgeDtcXG4gICAgICBpbnQgeTtcXG4gICAgICBpbnQgejtcXG4gICAgICBpbnQgdztcXG4gICAgICBpbnQgdTtcXG4gICAgfTtcXG5cXG4gICAgc3RydWN0IGl2ZWM2XFxuICAgIHtcXG4gICAgICBpbnQgeDtcXG4gICAgICBpbnQgeTtcXG4gICAgICBpbnQgejtcXG4gICAgICBpbnQgdztcXG4gICAgICBpbnQgdTtcXG4gICAgICBpbnQgdjtcXG4gICAgfTtcXG5cXG4gICAgdW5pZm9ybSBmbG9hdCBOQU47XFxuICAgICNkZWZpbmUgaXNuYW4odmFsdWUpIGlzbmFuX2N1c3RvbSh2YWx1ZSlcXG4gICAgXCIrdC5kZWZpbmVTcGVjaWFsTmFOK1wiXFxuICAgIGJ2ZWM0IGlzbmFuX2N1c3RvbSh2ZWM0IHZhbCkge1xcbiAgICAgIHJldHVybiBidmVjNChpc25hbih2YWwueCksIGlzbmFuKHZhbC55KSwgaXNuYW4odmFsLnopLCBpc25hbih2YWwudykpO1xcbiAgICB9XFxuXFxuICAgIFwiK3QuZGVmaW5lU3BlY2lhbEluZitcIlxcbiAgICBcIit0LmRlZmluZVJvdW5kK1wiXFxuXFxuICAgIGludCBpbW9kKGludCB4LCBpbnQgeSkge1xcbiAgICAgIHJldHVybiB4IC0geSAqICh4IC8geSk7XFxuICAgIH1cXG5cXG4gICAgaW50IGlkaXYoaW50IGEsIGludCBiLCBmbG9hdCBzaWduKSB7XFxuICAgICAgaW50IHJlcyA9IGEgLyBiO1xcbiAgICAgIGludCBtb2QgPSBpbW9kKGEsIGIpO1xcbiAgICAgIGlmIChzaWduIDwgMC4gJiYgbW9kICE9IDApIHtcXG4gICAgICAgIHJlcyAtPSAxO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gcmVzO1xcbiAgICB9XFxuXFxuICAgIC8vQmFzZWQgb24gdGhlIHdvcmsgb2YgRGF2ZSBIb3NraW5zXFxuICAgIC8vaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3LzRkalNSV1xcbiAgICAjZGVmaW5lIEhBU0hTQ0FMRTEgNDQzLjg5NzVcXG4gICAgZmxvYXQgcmFuZG9tKGZsb2F0IHNlZWQpe1xcbiAgICAgIHZlYzIgcCA9IHJlc3VsdFVWICogc2VlZDtcXG4gICAgICB2ZWMzIHAzICA9IGZyYWN0KHZlYzMocC54eXgpICogSEFTSFNDQUxFMSk7XFxuICAgICAgcDMgKz0gZG90KHAzLCBwMy55enggKyAxOS4xOSk7XFxuICAgICAgcmV0dXJuIGZyYWN0KChwMy54ICsgcDMueSkgKiBwMy56KTtcXG4gICAgfVxcblxcbiAgICBcIit2bytcIlxcbiAgICBcIittbytcIlxcbiAgICBcIitnbytcIlxcbiAgXCJ9KGMpO3JldHVybiBlLmlzUGFja2VkPyhhPWZ1bmN0aW9uKHQsZSl7c3dpdGNoKHQubGVuZ3RoKXtjYXNlIDA6cmV0dXJuXCJcXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICByZXR1cm4gMDtcXG4gICAgfVxcbiAgXCI7Y2FzZSAxOnJldHVybiBmdW5jdGlvbih0LGUpe3ZhciBuPVtNYXRoLmNlaWwoZVswXS8yKSxNYXRoLmNlaWwoZVsxXS8yKV07aWYoMT09PW5bMF0pcmV0dXJuXCJcXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIDIgKiBpbnQocmVzdWx0VVYueCAqIFwiK25bMV0rXCIuMCk7XFxuICAgICAgfVxcbiAgICBcIjtpZigxPT09blsxXSlyZXR1cm5cIlxcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gMiAqIGludChyZXN1bHRVVi55ICogXCIrblswXStcIi4wKTtcXG4gICAgICB9XFxuICAgIFwiO3JldHVyblwiXFxuICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK25bMF0rXCIsIFwiK25bMV0rXCIpKTtcXG4gICAgICByZXR1cm4gcmVzVGV4UkMueCAqIFwiK25bMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICB9XFxuICBcIn0oMCxlKTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIG49W01hdGguY2VpbChlWzBdLzIpLE1hdGguY2VpbChlWzFdLzIpXTtpZih4KHQsZSkpcmV0dXJuXCJcXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gMiAqIGl2ZWMyKHJlc3VsdFVWLnl4ICogdmVjMihcIituWzBdK1wiLCBcIituWzFdK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIjt2YXIgcj1NYXRoLmNlaWwodFsxXS8yKTtyZXR1cm5cIlxcbiAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK25bMF0rXCIsIFwiK25bMV0rXCIpKTtcXG5cXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrblsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgICAgaW50IHIgPSAyICogKGluZGV4IC8gXCIrcitcIik7XFxuICAgICAgaW50IGMgPSBpbW9kKGluZGV4LCBcIityK1wiKSAqIDI7XFxuXFxuICAgICAgcmV0dXJuIGl2ZWMyKHIsIGMpO1xcbiAgICB9XFxuICBcIn0odCxlKTtjYXNlIDM6cmV0dXJuIG49dCxyPWUsbz1bTWF0aC5jZWlsKHJbMF0vMiksTWF0aC5jZWlsKHJbMV0vMildLGE9TWF0aC5jZWlsKG5bMl0vMiksaT1hKk1hdGguY2VpbChuWzFdLzIpLFwiXFxuICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrb1swXStcIiwgXCIrb1sxXStcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIitvWzFdK1wiICsgcmVzVGV4UkMueTtcXG5cXG4gICAgICBpbnQgYiA9IGluZGV4IC8gXCIraStcIjtcXG4gICAgICBpbmRleCAtPSBiICogXCIraStcIjtcXG5cXG4gICAgICBpbnQgciA9IDIgKiAoaW5kZXggLyBcIithK1wiKTtcXG4gICAgICBpbnQgYyA9IGltb2QoaW5kZXgsIFwiK2ErXCIpICogMjtcXG5cXG4gICAgICByZXR1cm4gaXZlYzMoYiwgciwgYyk7XFxuICAgIH1cXG4gIFwiO2RlZmF1bHQ6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPVtNYXRoLmNlaWwoZVswXS8yKSxNYXRoLmNlaWwoZVsxXS8yKV0scj1NYXRoLmNlaWwodFt0Lmxlbmd0aC0xXS8yKSxvPXIqTWF0aC5jZWlsKHRbdC5sZW5ndGgtMl0vMiksYT1vLGk9XCJcIixzPVwiYiwgciwgY1wiLHU9Mjt1PHQubGVuZ3RoLTE7dSsrKWEqPXRbdC5sZW5ndGgtdS0xXSxpPVwiXFxuICAgICAgaW50IGJcIit1K1wiID0gaW5kZXggLyBcIithK1wiO1xcbiAgICAgIGluZGV4IC09IGJcIit1K1wiICogXCIrYStcIjtcXG4gICAgXCIraSxzPVwiYlwiK3UrXCIsIFwiK3M7cmV0dXJuXCJcXG4gICAgaXZlY1wiK3QubGVuZ3RoK1wiIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrblswXStcIiwgXCIrblsxXStcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIituWzFdK1wiICsgcmVzVGV4UkMueTtcXG5cXG4gICAgICBcIitpK1wiXFxuXFxuICAgICAgaW50IGIgPSBpbmRleCAvIFwiK28rXCI7XFxuICAgICAgaW5kZXggLT0gYiAqIFwiK28rXCI7XFxuXFxuICAgICAgaW50IHIgPSAyICogKGluZGV4IC8gXCIrcitcIik7XFxuICAgICAgaW50IGMgPSBpbW9kKGluZGV4LCBcIityK1wiKSAqIDI7XFxuXFxuICAgICAgcmV0dXJuIGl2ZWNcIit0Lmxlbmd0aCtcIihcIitzK1wiKTtcXG4gICAgfVxcbiAgXCJ9KHQsZSl9dmFyIG4scixvLGEsaX0oZS5sb2dpY2FsU2hhcGUsbCksaT1mdW5jdGlvbih0KXtyZXR1cm5cIlxcbiAgICB2b2lkIHNldE91dHB1dCh2ZWM0IHZhbCkge1xcbiAgICAgIFwiK3Qub3V0cHV0K1wiID0gdmFsO1xcbiAgICB9XFxuICBcIn0oYykpOihhPWZ1bmN0aW9uKHQsZSl7c3dpdGNoKHQubGVuZ3RoKXtjYXNlIDA6cmV0dXJuXCJcXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICByZXR1cm4gMDtcXG4gICAgfVxcbiAgXCI7Y2FzZSAxOnJldHVybiBmdW5jdGlvbih0LGUpe2lmKDE9PT1lWzBdKXJldHVyblwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiBpbnQocmVzdWx0VVYueCAqIFwiK2VbMV0rXCIuMCk7XFxuICAgICAgfVxcbiAgICBcIjtpZigxPT09ZVsxXSlyZXR1cm5cIlxcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gaW50KHJlc3VsdFVWLnkgKiBcIitlWzBdK1wiLjApO1xcbiAgICAgIH1cXG4gICAgXCI7cmV0dXJuXCJcXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZVswXStcIiwgXCIrZVsxXStcIikpO1xcbiAgICAgIHJldHVybiByZXNUZXhSQy54ICogXCIrZVsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgIH1cXG4gIFwifSgwLGUpO2Nhc2UgMjpyZXR1cm4gZnVuY3Rpb24odCxlKXtpZih4KHQsZSkpcmV0dXJuXCJcXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gaXZlYzIocmVzdWx0VVYueXggKiB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO2lmKDE9PT10WzFdKXJldHVyblwiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZVswXStcIiwgXCIrZVsxXStcIikpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICAgICAgcmV0dXJuIGl2ZWMyKGluZGV4LCAwKTtcXG4gICAgICB9XFxuICAgIFwiO2lmKDE9PT10WzBdKXJldHVyblwiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZVswXStcIiwgXCIrZVsxXStcIikpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICAgICAgcmV0dXJuIGl2ZWMyKDAsIGluZGV4KTtcXG4gICAgICB9XFxuICAgIFwiO3JldHVyblwiXFxuICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZVswXStcIiwgXCIrZVsxXStcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIitlWzFdK1wiICsgcmVzVGV4UkMueTtcXG4gICAgICBpbnQgciA9IGluZGV4IC8gXCIrdFsxXStcIjtcXG4gICAgICBpbnQgYyA9IGluZGV4IC0gciAqIFwiK3RbMV0rXCI7XFxuICAgICAgcmV0dXJuIGl2ZWMyKHIsIGMpO1xcbiAgICB9XFxuICBcIn0odCxlKTtjYXNlIDM6cmV0dXJuIG49ZSxyPWxvKFtcInJcIixcImNcIixcImRcIl0sdCksXCJcXG4gICAgaXZlYzMgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIituWzBdK1wiLCBcIituWzFdK1wiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK25bMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIFwiK3IrXCJcXG4gICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XFxuICAgIH1cXG4gIFwiO2Nhc2UgNDpyZXR1cm4gZnVuY3Rpb24odCxlKXt2YXIgbj1sbyhbXCJyXCIsXCJjXCIsXCJkXCIsXCJkMlwiXSx0KTtyZXR1cm5cIlxcbiAgICBpdmVjNCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrZVsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgICAgXCIrbitcIlxcbiAgICAgIHJldHVybiBpdmVjNChyLCBjLCBkLCBkMik7XFxuICAgIH1cXG4gIFwifSh0LGUpO2Nhc2UgNTpyZXR1cm4gZnVuY3Rpb24odCxlKXt2YXIgbj1sbyhbXCJyXCIsXCJjXCIsXCJkXCIsXCJkMlwiLFwiZDNcIl0sdCk7cmV0dXJuXCJcXG4gICAgaXZlYzUgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKiB2ZWMyKFwiK2VbMF0rXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIitlWzFdK1wiKSk7XFxuXFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcblxcbiAgICAgIFwiK24rXCJcXG5cXG4gICAgICBpdmVjNSBvdXRTaGFwZSA9IGl2ZWM1KHIsIGMsIGQsIGQyLCBkMyk7XFxuICAgICAgcmV0dXJuIG91dFNoYXBlO1xcbiAgICB9XFxuICBcIn0odCxlKTtjYXNlIDY6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIG49bG8oW1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIixcImQzXCIsXCJkNFwiXSx0KTtyZXR1cm5cIlxcbiAgICBpdmVjNiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrZVsxXStcIiArIHJlc1RleFJDLnk7XFxuXFxuICAgICAgXCIrbitcIlxcblxcbiAgICAgIGl2ZWM2IHJlc3VsdCA9IGl2ZWM2KHIsIGMsIGQsIGQyLCBkMywgZDQpO1xcbiAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH1cXG4gIFwifSh0LGUpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKHQubGVuZ3RoK1wiLUQgb3V0cHV0IHNhbXBsaW5nIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpfXZhciBuLHJ9KGUubG9naWNhbFNoYXBlLGwpLGk9ZnVuY3Rpb24odCl7cmV0dXJuXCJcXG4gICAgdm9pZCBzZXRPdXRwdXQoZmxvYXQgdmFsKSB7XFxuICAgICAgXCIrdC5vdXRwdXQrXCIgPSB2ZWM0KHZhbCwgMCwgMCwgMCk7XFxuICAgIH1cXG4gIFwifShjKSksciYmKHArPXlvKSxbcCxoLGkscyxhLHUsbl0uam9pbihcIlxcblwiKX1mdW5jdGlvbiBwbyh0KXt2YXIgZT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGU7c3dpdGNoKGUubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQubmFtZSxuPVwiZ2V0XCIrZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStlLnNsaWNlKDEpO2lmKHQuc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5cImZsb2F0IFwiK24rXCIoKSB7cmV0dXJuIFwiK2UrXCI7fVwiO3ZhciByPXQuc2hhcGVJbmZvLnRleFNoYXBlLG89clswXSxhPXJbMV07aWYoMT09PW8mJjE9PT1hKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrbitcIigpIHtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK2UrXCIsIGhhbGZDUik7XFxuICAgICAgfVxcbiAgICBcIjt2YXIgaT10LnNoYXBlSW5mby50ZXhTaGFwZSxzPWlbMF0sdT1pWzFdLGw9eG8oZSk7cmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrbitcIigpIHtcXG4gICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdChcIitzK1wiLCBcIit1K1wiLCBcIitsK1wiKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIitlK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KTtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQubmFtZSxuPVwiZ2V0XCIrZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStlLnNsaWNlKDEpO2lmKHQuc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK24rXCIoaW50IGluZGV4KSB7XFxuICAgICAgICBcIit3byh0KStcIlxcbiAgICAgIH1cXG4gICAgXCI7dmFyIHI9dC5zaGFwZUluZm8udGV4U2hhcGUsbz1yWzBdLGE9clsxXTtpZigxPT09YSYmMT09PW8pcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIituK1wiKGludCBpbmRleCkge1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrZStcIiwgaGFsZkNSKTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciBpPXhvKGUpO2lmKDE9PT1hKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrbitcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGZsb2F0KGluZGV4ICsgXCIraStcIikgKyAwLjUpIC8gXCIrbytcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK2UrXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO2lmKDE9PT1vKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrbitcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIHZlYzIgdXYgPSB2ZWMyKChmbG9hdChpbmRleCArIFwiK2krXCIpICsgMC41KSAvIFwiK2ErXCIuMCwgMC41KTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK2UrXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO3JldHVyblwiXFxuICAgIGZsb2F0IFwiK24rXCIoaW50IGluZGV4KSB7XFxuICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoXCIrbytcIiwgXCIrYStcIiwgaW5kZXggKyBcIitpK1wiKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIitlK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxuPXQubmFtZSxyPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLG89dC5zaGFwZUluZm8udGV4U2hhcGU7aWYobnVsbCE9byYmeChlLG8pKXt2YXIgYT1vWzBdLGk9b1sxXTtyZXR1cm5cIlxcbiAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICB2ZWMyIHV2ID0gKHZlYzIoY29sLCByb3cpICsgaGFsZkNSKSAvIHZlYzIoXCIraStcIi4wLCBcIithK1wiLjApO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9dmFyIHM9ayhlKSx1PXMubmV3U2hhcGUsbD1zLmtlcHREaW1zLGM9dTtpZihjLmxlbmd0aDxlLmxlbmd0aCl7dmFyIGg9Q28odCxjKTtyZXR1cm5cIlxcbiAgICAgIFwiK3BvKGgpK1wiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICByZXR1cm4gXCIrcitcIihcIitFbyhbXCJyb3dcIixcImNvbFwiXSxsKStcIik7XFxuICAgICAgfVxcbiAgICBcIn1pZih0LnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgIGludCBpbmRleCA9IHJvdW5kKGRvdCh2ZWMyKHJvdywgY29sKSwgdmVjMihcIitlWzFdK1wiLCAxKSkpO1xcbiAgICAgICAgXCIrd28odCkrXCJcXG4gICAgICB9XFxuICAgIFwiO3ZhciBwPW9bMF0sZj1vWzFdLGQ9eG8obik7aWYoMT09PWYpcmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgXCIrZCtcIiksIHZlYzMoXCIrZVsxXStcIiwgMSwgMSkpO1xcbiAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGluZGV4ICsgMC41KSAvIFwiK3ArXCIuMCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtpZigxPT09cClyZXR1cm5cIlxcbiAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICBmbG9hdCBpbmRleCA9IGRvdCh2ZWMzKHJvdywgY29sLCBcIitkK1wiKSwgdmVjMyhcIitlWzFdK1wiLCAxLCAxKSk7XFxuICAgICAgdmVjMiB1diA9IHZlYzIoKGluZGV4ICsgMC41KSAvIFwiK2YrXCIuMCwgMC41KTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwiO3JldHVyblwiXFxuICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgICBpbnQgaW5kZXggPSByb3cgKiBcIitlWzFdK1wiICsgY29sICsgXCIrZCtcIjtcXG4gICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoXCIrcCtcIiwgXCIrZitcIiwgaW5kZXgpO1xcbiAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICB9XFxuXCJ9KHQpO2Nhc2UgMzpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLG49dC5uYW1lLHI9XCJnZXRcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSksbz1lWzFdKmVbMl0sYT1lWzJdLGk9ayhlKSxzPWkubmV3U2hhcGUsdT1pLmtlcHREaW1zLGw9cztpZihsLmxlbmd0aDxlLmxlbmd0aCl7dmFyIGM9Q28odCxsKTtyZXR1cm5cIlxcbiAgICAgICAgXCIrcG8oYykrXCJcXG4gICAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICAgIHJldHVybiBcIityK1wiKFwiK0VvKFtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiXSx1KStcIik7XFxuICAgICAgICB9XFxuICAgICAgXCJ9aWYodC5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgIGludCBpbmRleCA9IHJvdW5kKGRvdCh2ZWMzKHJvdywgY29sLCBkZXB0aCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMzKFwiK28rXCIsIFwiK2ErXCIsIDEpKSk7XFxuICAgICAgICBcIit3byh0KStcIlxcbiAgICAgIH1cXG4gICAgXCI7dmFyIGg9dC5zaGFwZUluZm8udGV4U2hhcGUscD1oWzBdLGY9aFsxXSxkPXQuc2hhcGVJbmZvLmZsYXRPZmZzZXQ7aWYoZj09PW8mJm51bGw9PWQpcmV0dXJuXCJcXG4gICAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICAgIGZsb2F0IHRleFIgPSBmbG9hdChyb3cpO1xcbiAgICAgICAgICBmbG9hdCB0ZXhDID0gZG90KHZlYzIoY29sLCBkZXB0aCksIHZlYzIoXCIrYStcIiwgMSkpO1xcbiAgICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK2YrXCIuMCwgXCIrcCtcIi4wKTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO2lmKGY9PT1hJiZudWxsPT1kKXJldHVyblwiXFxuICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgZmxvYXQgdGV4UiA9IGRvdCh2ZWMyKHJvdywgY29sKSwgdmVjMihcIitlWzFdK1wiLCAxKSk7XFxuICAgICAgZmxvYXQgdGV4QyA9IGZsb2F0KGRlcHRoKTtcXG4gICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMihcIitmK1wiLjAsIFwiK3ArXCIuMCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICB9XFxuICBcIjt2YXIgdj14byhuKTtyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXFxuICAgICAgICBpbnQgaW5kZXggPSByb3cgKiBcIitvK1wiICsgY29sICogXCIrYStcIiArIGRlcHRoICsgXCIrditcIjtcXG4gICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KFwiK3ArXCIsIFwiK2YrXCIsIGluZGV4KTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgICB9XFxuICBcIn0odCk7Y2FzZSA0OnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsbj10Lm5hbWUscj1cImdldFwiK24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxvPWVbM10sYT1lWzJdKm8saT1lWzFdKmEscz1rKGUpLHU9cy5uZXdTaGFwZSxsPXMua2VwdERpbXM7aWYodS5sZW5ndGg8ZS5sZW5ndGgpe3ZhciBjPUNvKHQsdSk7cmV0dXJuXCJcXG4gICAgICBcIitwbyhjKStcIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICByZXR1cm4gXCIrcitcIihcIitFbyhbXCJyb3dcIixcImNvbFwiLFwiZGVwdGhcIixcImRlcHRoMlwiXSxsKStcIik7XFxuICAgICAgfVxcbiAgICBcIn1pZih0LnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZG90KHZlYzQocm93LCBjb2wsIGRlcHRoLCBkZXB0aDIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjNChcIitpK1wiLCBcIithK1wiLCBcIitvK1wiLCAxKSkpO1xcbiAgICAgICAgXCIrd28odCkrXCJcXG4gICAgICB9XFxuICAgIFwiO3ZhciBoPXQuc2hhcGVJbmZvLmZsYXRPZmZzZXQscD10LnNoYXBlSW5mby50ZXhTaGFwZSxmPXBbMF0sZD1wWzFdO2lmKGQ9PT1pJiZudWxsPT1oKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIGZsb2F0IHRleFIgPSBmbG9hdChyb3cpO1xcbiAgICAgICAgZmxvYXQgdGV4QyA9XFxuICAgICAgICAgICAgZG90KHZlYzMoY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgICAgICAgdmVjMyhcIithK1wiLCBcIitvK1wiLCAxKSk7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgdmVjMihcIitkK1wiLjAsIFwiK2YrXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtpZihkPT09byYmbnVsbD09aClyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICBmbG9hdCB0ZXhSID0gZG90KHZlYzMocm93LCBjb2wsIGRlcHRoKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgdmVjMyhcIitlWzFdKmVbMl0rXCIsIFwiK2VbMl0rXCIsIDEpKTtcXG4gICAgICAgIGZsb2F0IHRleEMgPSBmbG9hdChkZXB0aDIpO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgdmVjMihcIitkK1wiLjAsIFwiK2YrXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjt2YXIgdj14byhuKTtyZXR1cm5cIlxcbiAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gICAgICBpbnQgaW5kZXggPSByb3cgKiBcIitpK1wiICsgY29sICogXCIrYStcIiArXFxuICAgICAgICAgIGRlcHRoICogXCIrbytcIiArIGRlcHRoMjtcXG4gICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdChcIitmK1wiLCBcIitkK1wiLCBpbmRleCArIFwiK3YrXCIpO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9KHQpO2Nhc2UgNTpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLG49dC5uYW1lLHI9XCJnZXRcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSksbz1lWzRdLGE9ZVszXSpvLGk9ZVsyXSphLHM9ZVsxXSppLHU9ayhlKSxsPXUubmV3U2hhcGUsYz11LmtlcHREaW1zO2lmKGwubGVuZ3RoPGUubGVuZ3RoKXt2YXIgaD1Dbyh0LGwpO3JldHVyblwiXFxuICAgICAgXCIrcG8oaCkrXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xcbiAgICAgICAgcmV0dXJuIFwiK3IrXCIoXCIrRW8oW1wicm93XCIsXCJjb2xcIixcImRlcHRoXCIsXCJkZXB0aDJcIixcImRlcHRoM1wiXSxjKStcIik7XFxuICAgICAgfVxcbiAgICBcIn1pZih0LnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xcbiAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QoXFxuICAgICAgICAgIHZlYzQocm93LCBjb2wsIGRlcHRoLCBkZXB0aDIpLFxcbiAgICAgICAgICB2ZWM0KFwiK3MrXCIsIFwiK2krXCIsIFwiK2ErXCIsIFwiK28rXCIpKSArXFxuICAgICAgICAgIGRlcHRoMztcXG4gICAgICAgIFwiK3dvKHQpK1wiXFxuICAgICAgfVxcbiAgICBcIjt2YXIgcD10LnNoYXBlSW5mby5mbGF0T2Zmc2V0LGY9dC5zaGFwZUluZm8udGV4U2hhcGUsZD1mWzBdLHY9ZlsxXTtpZih2PT09cyYmbnVsbD09cClyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgICBpbnQgdGV4UiA9IHJvdztcXG4gICAgICAgIGZsb2F0IHRleEMgPSBkb3QodmVjNChjb2wsIGRlcHRoLCBkZXB0aDIsIGRlcHRoMyksXFxuICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQoXCIraStcIiwgXCIrYStcIiwgXCIrbytcIiwgMSkpO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrditcIi4wLCBcIitkK1wiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7aWYodj09PW8mJm51bGw9PXApcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xcbiAgICAgICAgZmxvYXQgdGV4UiA9IGRvdChcXG4gICAgICAgICAgdmVjNChyb3csIGNvbCwgZGVwdGgsIGRlcHRoMiksXFxuICAgICAgICAgIHZlYzQoXCIrZVsxXSplWzJdKmVbM10rXCIsXFxuICAgICAgICAgICAgICAgXCIrZVsyXSplWzNdK1wiLCBcIitlWzNdK1wiLCAxKSk7XFxuICAgICAgICBpbnQgdGV4QyA9IGRlcHRoMztcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgIHZlYzIoXCIrditcIi4wLCBcIitkK1wiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIG09eG8obik7cmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXFxuICAgICAgaW50IGluZGV4ID0gcm93ICogXCIrcytcIiArIGNvbCAqIFwiK2krXCIgKyBkZXB0aCAqIFwiK2ErXCIgK1xcbiAgICAgICAgICBkZXB0aDIgKiBcIitvK1wiICsgZGVwdGgzICsgXCIrbStcIjtcXG4gICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdChcIitkK1wiLCBcIit2K1wiLCBpbmRleCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCk7Y2FzZSA2OnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsbj10Lm5hbWUscj1cImdldFwiK24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxvPWsoZSksYT1vLm5ld1NoYXBlLGk9by5rZXB0RGltcztpZihhLmxlbmd0aDxlLmxlbmd0aCl7dmFyIHM9Q28odCxhKTtyZXR1cm5cIlxcbiAgICAgIFwiK3BvKHMpK1wiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgICByZXR1cm4gXCIrcitcIihcIitFbyhbXCJyb3dcIixcImNvbFwiLFwiZGVwdGhcIixcImRlcHRoMlwiLFwiZGVwdGgzXCIsXCJkZXB0aDRcIl0saSkrXCIpO1xcbiAgICAgIH1cXG4gICAgXCJ9dmFyIHU9ZVs1XSxsPWVbNF0qdSxjPWVbM10qbCxoPWVbMl0qYyxwPWVbMV0qaDtpZih0LnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgICBpbnQgaW5kZXggPSByb3VuZChkb3QoXFxuICAgICAgICAgIHZlYzQocm93LCBjb2wsIGRlcHRoLCBkZXB0aDIpLFxcbiAgICAgICAgICB2ZWM0KFwiK3ArXCIsIFwiK2grXCIsIFwiK2MrXCIsIFwiK2wrXCIpKSArXFxuICAgICAgICAgIGRvdChcXG4gICAgICAgICAgICB2ZWMyKGRlcHRoMywgZGVwdGg0KSxcXG4gICAgICAgICAgICB2ZWMyKFwiK3UrXCIsIDEpKSk7XFxuICAgICAgICBcIit3byh0KStcIlxcbiAgICAgIH1cXG4gICAgXCI7dmFyIGY9dC5zaGFwZUluZm8uZmxhdE9mZnNldCxkPXQuc2hhcGVJbmZvLnRleFNoYXBlLHY9ZFswXSxtPWRbMV07aWYobT09PXAmJm51bGw9PWYpcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcXG4gICAgICAgIGludCB0ZXhSID0gcm93O1xcbiAgICAgICAgZmxvYXQgdGV4QyA9IGRvdCh2ZWM0KGNvbCwgZGVwdGgsIGRlcHRoMiwgZGVwdGgzKSxcXG4gICAgICAgICAgdmVjNChcIitoK1wiLCBcIitjK1wiLCBcIitsK1wiLCBcIit1K1wiKSkgK1xcbiAgICAgICAgICAgICAgIGZsb2F0KGRlcHRoNCk7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgdmVjMihcIittK1wiLjAsIFwiK3YrXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtpZihtPT09dSYmbnVsbD09ZilyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICAgICAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgICAgZmxvYXQgdGV4UiA9IGRvdCh2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgdmVjNChcIitlWzFdKmVbMl0qZVszXSplWzRdK1wiLFxcbiAgICAgICAgICAgICAgIFwiK2VbMl0qZVszXSplWzRdK1wiLFxcbiAgICAgICAgICAgICAgIFwiK2VbM10qZVs0XStcIixcXG4gICAgICAgICAgICAgICBcIitlWzRdK1wiKSkgKyBmbG9hdChkZXB0aDMpO1xcbiAgICAgICAgaW50IHRleEMgPSBkZXB0aDQ7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICB2ZWMyKFwiK20rXCIuMCwgXCIrditcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciBnPXhvKG4pO3JldHVyblwiXFxuICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICAgICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcXG4gICAgICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXFxuICAgICAgaW50IGluZGV4ID0gcm93ICogXCIrcCtcIiArIGNvbCAqIFwiK2grXCIgKyBkZXB0aCAqIFwiK2MrXCIgK1xcbiAgICAgICAgICBkZXB0aDIgKiBcIitsK1wiICsgZGVwdGgzICogXCIrdStcIiArIGRlcHRoNCArIFwiK2crXCI7XFxuICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoXCIrditcIiwgXCIrbStcIiwgaW5kZXgpO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9KHQpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGUubGVuZ3RoK1wiLUQgaW5wdXQgc2FtcGxpbmcgaXMgbm90IHlldCBzdXBwb3J0ZWRcIil9fWZ1bmN0aW9uIGZvKHQpe3ZhciBlLG4scjtzd2l0Y2godC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBlPXQubmFtZSxuPVwiZ2V0XCIrZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStlLnNsaWNlKDEpLHI9dW8oKSxcIlxcbiAgICB2ZWM0IFwiK24rXCIoKSB7XFxuICAgICAgcmV0dXJuIFwiK3IudGV4dHVyZTJEK1wiKFwiK2UrXCIsIGhhbGZDUik7XFxuICAgIH1cXG4gIFwiO2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5uYW1lLG49XCJnZXRcIitlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Uuc2xpY2UoMSkscj10LnNoYXBlSW5mby50ZXhTaGFwZSxvPVtNYXRoLmNlaWwoclswXS8yKSxNYXRoLmNlaWwoclsxXS8yKV0sYT11bygpO3JldHVyblwiXFxuICAgIHZlYzQgXCIrbitcIihpbnQgaW5kZXgpIHtcXG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tMUQoXFxuICAgICAgICBcIitvWzBdK1wiLCBcIitvWzFdK1wiLCBpbmRleCk7XFxuICAgICAgcmV0dXJuIFwiK2EudGV4dHVyZTJEK1wiKFwiK2UrXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9KHQpO2Nhc2UgMjpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLG49dC5uYW1lLHI9XCJnZXRcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSksbz10LnNoYXBlSW5mby50ZXhTaGFwZSxhPW9bMF0saT1vWzFdLHM9dW8oKTtpZihudWxsIT1vJiZ4KGUsbykpcmV0dXJuXCJcXG4gICAgICB2ZWM0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKFwiK2krXCIuMCwgXCIrYStcIi4wKTtcXG5cXG4gICAgICAgIHJldHVybiBcIitzLnRleHR1cmUyRCtcIihcIituK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjt2YXIgdT1bTWF0aC5jZWlsKG9bMF0vMiksTWF0aC5jZWlsKG9bMV0vMildLGw9TWF0aC5jZWlsKGVbMV0vMik7cmV0dXJuXCJcXG4gICAgdmVjNCBcIityK1wiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tMkQoXCIrbCtcIiwgXCIrdVswXStcIiwgXCIrdVsxXStcIiwgcm93LCBjb2wpO1xcbiAgICAgIHJldHVybiBcIitzLnRleHR1cmUyRCtcIihcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KTtjYXNlIDM6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxuPXQubmFtZSxyPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLG89dC5zaGFwZUluZm8udGV4U2hhcGUsYT1bTWF0aC5jZWlsKG9bMF0vMiksTWF0aC5jZWlsKG9bMV0vMildO2lmKDE9PT1lWzBdKXt2YXIgaT1lLnNsaWNlKDEpLHM9Q28odCxpKTtyZXR1cm5cIlxcbiAgICAgICAgXCIrZm8ocykrXCJcXG4gICAgICAgIHZlYzQgXCIrcitcIihpbnQgYiwgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgICByZXR1cm4gXCIrcitcIihcIitFbyhbXCJiXCIsXCJyb3dcIixcImNvbFwiXSxbMSwyXSkrXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIFwifXZhciB1PWFbMF0sbD1hWzFdLGM9TWF0aC5jZWlsKGVbMl0vMiksaD1jKk1hdGguY2VpbChlWzFdLzIpLHA9dW8oKTtyZXR1cm5cIlxcbiAgICB2ZWM0IFwiK3IrXCIoaW50IGIsIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tM0QoXFxuICAgICAgICBcIit1K1wiLCBcIitsK1wiLCBcIitoK1wiLCBcIitjK1wiLCBiLCByb3csIGNvbCk7XFxuICAgICAgcmV0dXJuIFwiK3AudGV4dHVyZTJEK1wiKFwiK24rXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9KHQpO2RlZmF1bHQ6cmV0dXJuIGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsbj1lLmxlbmd0aCxyPXQubmFtZSxvPVwiZ2V0XCIrci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStyLnNsaWNlKDEpLGE9dC5zaGFwZUluZm8udGV4U2hhcGUsaT1bTWF0aC5jZWlsKGFbMF0vMiksTWF0aC5jZWlsKGFbMV0vMildLHM9aVswXSx1PWlbMV0sbD1NYXRoLmNlaWwoZVtuLTFdLzIpLGM9bCpNYXRoLmNlaWwoZVtuLTJdLzIpLGg9XCJpbnQgYiwgaW50IHJvdywgaW50IGNvbFwiLHA9XCJiICogXCIrYytcIiArIChyb3cgLyAyKSAqIFwiK2wrXCIgKyAoY29sIC8gMilcIixmPTI7ZjxuLTE7ZisrKWg9XCJpbnQgYlwiK2YrXCIsIFwiK2gsYyo9ZVtuLWYtMV0scD1cImJcIitmK1wiICogXCIrYytcIiArIFwiK3A7dmFyIGQ9dW8oKTtyZXR1cm5cIlxcbiAgICB2ZWM0IFwiK28rXCIoXCIraCtcIikge1xcbiAgICAgIGludCBpbmRleCA9IFwiK3ArXCI7XFxuICAgICAgaW50IHRleFIgPSBpbmRleCAvIFwiK3UrXCI7XFxuICAgICAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiBcIit1K1wiO1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKFwiK3UrXCIsIFwiK3MrXCIpO1xcbiAgICAgIHJldHVybiBcIitkLnRleHR1cmUyRCtcIihcIityK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KX19dmFyIHZvPVwiXFxudmVjMiB1dkZyb21GbGF0KGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IGluZGV4KSB7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG52ZWMyIHBhY2tlZFVWZnJvbTFEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IGluZGV4KSB7XFxuICBpbnQgdGV4ZWxJbmRleCA9IGluZGV4IC8gMjtcXG4gIGludCB0ZXhSID0gdGV4ZWxJbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IHRleGVsSW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIixtbz1cIlxcbnZlYzIgcGFja2VkVVZmcm9tMkQoaW50IHRleGVsc0luTG9naWNhbFJvdywgaW50IHRleE51bVIsXFxuICBpbnQgdGV4TnVtQywgaW50IHJvdywgaW50IGNvbCkge1xcbiAgaW50IHRleGVsSW5kZXggPSAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XFxuICBpbnQgdGV4UiA9IHRleGVsSW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSB0ZXhlbEluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxuXCIsZ289XCJcXG52ZWMyIHBhY2tlZFVWZnJvbTNEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQyxcXG4gICAgaW50IHRleGVsc0luQmF0Y2gsIGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCBiLFxcbiAgICBpbnQgcm93LCBpbnQgY29sKSB7XFxuICBpbnQgaW5kZXggPSBiICogdGV4ZWxzSW5CYXRjaCArIChyb3cgLyAyKSAqIHRleGVsc0luTG9naWNhbFJvdyArIChjb2wgLyAyKTtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiLHlvPVwiXFxuICBmbG9hdCBnZXRDaGFubmVsKHZlYzQgZnJhZywgdmVjMiBpbm5lckRpbXMpIHtcXG4gICAgdmVjMiBtb2RDb29yZCA9IG1vZChpbm5lckRpbXMsIDIuKTtcXG4gICAgcmV0dXJuIG1vZENvb3JkLnggPT0gMC4gP1xcbiAgICAgIChtb2RDb29yZC55ID09IDAuID8gZnJhZy5yIDogZnJhZy5nKSA6XFxuICAgICAgKG1vZENvb3JkLnkgPT0gMC4gPyBmcmFnLmIgOiBmcmFnLmEpO1xcbiAgfVxcbiAgZmxvYXQgZ2V0Q2hhbm5lbCh2ZWM0IGZyYWcsIGludCBkaW0pIHtcXG4gICAgZmxvYXQgbW9kQ29vcmQgPSBtb2QoZmxvYXQoZGltKSwgMi4pO1xcbiAgICByZXR1cm4gbW9kQ29vcmQgPT0gMC4gPyBmcmFnLnIgOiBmcmFnLmc7XFxuICB9XFxuXCI7ZnVuY3Rpb24geG8odCl7cmV0dXJuXCJvZmZzZXRcIit0fWZ1bmN0aW9uIHdvKHQpe3ZhciBlPXQubmFtZSxuPXkodC5zaGFwZUluZm8ubG9naWNhbFNoYXBlKTtyZXR1cm4gbjwyP1wicmV0dXJuIFwiK2UrXCI7XCI6XCJcXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIituK1wiOyBpKyspIHtcXG4gICAgICBpZiAoaSA9PSBpbmRleCkge1xcbiAgICAgICAgcmV0dXJuIFwiK2UrXCJbaV07XFxuICAgICAgfVxcbiAgICB9XFxuICBcIn1mdW5jdGlvbiBibyh0KXtpZih0PD0xKXJldHVyblwiaW50XCI7aWYoMj09PXQpcmV0dXJuXCJpdmVjMlwiO2lmKDM9PT10KXJldHVyblwiaXZlYzNcIjtpZig0PT09dClyZXR1cm5cIml2ZWM0XCI7aWYoNT09PXQpcmV0dXJuXCJpdmVjNVwiO2lmKDY9PT10KXJldHVyblwiaXZlYzZcIjt0aHJvdyBFcnJvcihcIkdQVSBmb3IgcmFuayBcIit0K1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpfWZ1bmN0aW9uIENvKHQsZSl7dmFyIG49SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0KSk7cmV0dXJuIG4uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZT1lLG59ZnVuY3Rpb24gRW8odCxlKXtyZXR1cm4gZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHRbZV19KS5qb2luKFwiLCBcIil9dmFyIFJvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwLGQodC5sZW5ndGg+MixmdW5jdGlvbigpe3JldHVyblwiUGFja2VkIGFyZ1wiKyhuLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSkpK1wiIHN1cHBvcnRzIG9ubHkgaW5wdXRzIHdpdGggcmFuayBhYm92ZSAyLlwifSk7dmFyIG89dFt0Lmxlbmd0aC0xXSxhPU1hdGguY2VpbChvL2UpO3RoaXMub3V0cHV0U2hhcGU9dC5zbGljZSgwLC0xKSxhPjEmJnRoaXMub3V0cHV0U2hhcGUucHVzaChhKSxyfHx0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcImJlc3RJbmRpY2VzQVwiKTt2YXIgaSxzLHU9dGhpcy5vdXRwdXRTaGFwZSxsPXUubGVuZ3RoLGM9Ym8obCksaD1vbyhcImNvb3Jkc1wiLGwpO2lmKDE9PT1hKXt2YXIgcD1ibyhzPWwrMSk7aT1cIlxcbiAgICAgICAgXCIrcCtcIiBzb3VyY2VMb2NSID0gXCIrcCtcIihcIitoLmpvaW4oKStcIiwgMCk7XFxuICAgICAgICArK1wiK2hbbC0xXStcIjtcXG4gICAgICAgIFwiK3ArXCIgc291cmNlTG9jRyA9IFwiK3ArXCIoXCIraC5qb2luKCkrXCIsIDApO1xcbiAgICAgICAgKytcIitoW2wtMl0rXCI7XFxuICAgICAgICBcIitwK1wiIHNvdXJjZUxvY0EgPSBcIitwK1wiKFwiK2guam9pbigpK1wiLCAwKTtcXG4gICAgICAgIC0tXCIraFtsLTFdK1wiO1xcbiAgICAgICAgXCIrcCtcIiBzb3VyY2VMb2NCID0gXCIrcCtcIihcIitoLmpvaW4oKStcIiwgMCk7XFxuICAgICAgICAtLVwiK2hbbC0yXStcIjtcIn1lbHNlIHM9bCxpPVwiXFxuICAgICAgICBcIitjK1wiIHNvdXJjZUxvY1IgPSBjb29yZHM7XFxuICAgICAgICArK1wiK2hbbC0xXStcIjtcXG4gICAgICAgIFwiK2MrXCIgc291cmNlTG9jRyA9IGNvb3JkcztcXG4gICAgICAgICsrXCIraFtsLTJdK1wiO1xcbiAgICAgICAgXCIrYytcIiBzb3VyY2VMb2NBID0gY29vcmRzO1xcbiAgICAgICAgLS1cIitoW2wtMV0rXCI7XFxuICAgICAgICBcIitjK1wiIHNvdXJjZUxvY0IgPSBjb29yZHM7XFxuICAgICAgICAtLVwiK2hbbC0yXStcIjtcIjt2YXIgZj1bXCJ4XCIsXCJ5XCIsXCJ6XCIsXCJ3XCIsXCJ1XCIsXCJ2XCJdLnNsaWNlKDAscyksdj1cIi5cIitmW3MtMV0sbT1mLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cImludCBcIit0fSksZz1vbyhcInNvdXJjZUxvY1JcIixzLTEpLmNvbmNhdChcImluSWR4LnJcIikseT1vbyhcInNvdXJjZUxvY0dcIixzLTEpLmNvbmNhdChcImluSWR4LmdcIikseD1vbyhcInNvdXJjZUxvY0JcIixzLTEpLmNvbmNhdChcImluSWR4LmJcIiksdz1vbyhcInNvdXJjZUxvY0FcIixzLTEpLmNvbmNhdChcImluSWR4LmFcIiksYj1cIm1heFwiPT09bj9cImdyZWF0ZXJUaGFuXCI6XCJsZXNzVGhhblwiLEM9cj9cIlwiOlwiXFxuICAgICAgICAgIGluSWR4ID0gcm91bmQodmVjNChnZXRCZXN0SW5kaWNlc0FDaGFubmVsKFwiK2cuam9pbigpK1wiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEJlc3RJbmRpY2VzQUNoYW5uZWwoXCIreS5qb2luKCkrXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QmVzdEluZGljZXNBQ2hhbm5lbChcIit4LmpvaW4oKStcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRCZXN0SW5kaWNlc0FDaGFubmVsKFwiK3cuam9pbigpK1wiKSkpO1wiLEU9XCJ2ZWM0KFxcbiAgICAgICAgICAgIGdldEFDaGFubmVsKFwiK2cuam9pbigpK1wiKSxcXG4gICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QUNoYW5uZWwoXCIreS5qb2luKCkrXCIpIDogMC4sXFxuICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFDaGFubmVsKFwiK3guam9pbigpK1wiKSA6IDAuLFxcbiAgICAgICAgICAgIGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCA/IGdldEFDaGFubmVsKFwiK3cuam9pbigpK1wiKSA6IDAuKVwiLFI9cj9cIlwiOlwiXFxuICAgICAgZmxvYXQgZ2V0QmVzdEluZGljZXNBQ2hhbm5lbChcIittLmpvaW4oKStcIikge1xcbiAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoZ2V0QmVzdEluZGljZXNBKFwiK2Yuam9pbigpK1wiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK2Yuc2xpY2UoLTIpLmpvaW4oKStcIikpO1xcbiAgICAgIH1cIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgZmxvYXQgZ2V0QUNoYW5uZWwoXCIrbS5qb2luKCkrXCIpIHtcXG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKGdldEEoXCIrZi5qb2luKCkrXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK2Yuc2xpY2UoLTIpLmpvaW4oKStcIikpO1xcbiAgICAgIH1cXG4gICAgICBcIitSK1wiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrYytcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGJvb2wgaGFzTmV4dENvbCA9IFwiK2hbbC0xXStcIiA8IFwiKyh1W2wtMV0tMSkrXCI7XFxuICAgICAgICBib29sIGhhc05leHRSb3cgPSBcIitoW2wtMl0rXCIgPCBcIisodVtsLTJdLTEpK1wiO1xcbiAgICAgICAgXCIraStcIlxcbiAgICAgICAgaXZlYzQgc3JjSWR4ID0gaXZlYzQoc291cmNlTG9jUlwiK3YrXCIsIHNvdXJjZUxvY0dcIit2K1wiLFxcbiAgICAgICAgICBzb3VyY2VMb2NCXCIrditcIiwgc291cmNlTG9jQVwiK3YrXCIpICogXCIrZStcIjtcXG4gICAgICAgIGl2ZWM0IGluSWR4ID0gc3JjSWR4O1xcbiAgICAgICAgdmVjNCBiZXN0SW5kZXggPSB2ZWM0KGluSWR4KTtcXG4gICAgICAgIHZlYzQgYmVzdFZhbHVlID0gXCIrRStcIjtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrZStcIjsgaSsrKSB7XFxuICAgICAgICAgIGluSWR4ID0gc3JjSWR4O1xcbiAgICAgICAgICBcIitDK1wiXFxuICAgICAgICAgIHZlYzQgY2FuZGlkYXRlID0gXCIrRStcIjtcXG4gICAgICAgICAgYnZlYzQgbmFuID0gaXNuYW4oY2FuZGlkYXRlKTtcXG4gICAgICAgICAgYnZlYzQgcmVwbGFjZSA9IGJ2ZWM0KFxcbiAgICAgICAgICAgIHZlYzQoXCIrYitcIihjYW5kaWRhdGUsIGJlc3RWYWx1ZSkpICogKHZlYzQoMS4wKSAtIHZlYzQobmFuKSkpO1xcblxcbiAgICAgICAgICBiZXN0VmFsdWUgPSB2ZWM0KHJlcGxhY2UueCAgPyBjYW5kaWRhdGUueCA6IGJlc3RWYWx1ZS54LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2UueSAgPyBjYW5kaWRhdGUueSA6IGJlc3RWYWx1ZS55LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2UueiAgPyBjYW5kaWRhdGUueiA6IGJlc3RWYWx1ZS56LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2UudyAgPyBjYW5kaWRhdGUudyA6IGJlc3RWYWx1ZS53KTtcXG4gICAgICAgICAgYmVzdEluZGV4ID0gbWl4KGJlc3RJbmRleCwgdmVjNChpbklkeCksIHZlYzQocmVwbGFjZSkpO1xcbiAgICAgICAgICBzcmNJZHgrKztcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChiZXN0SW5kZXgpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLFNvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPXQuaW5TaGFwZTt2YXIgZT10LmZpbHRlckhlaWdodCxuPXQuZmlsdGVyV2lkdGgscj10LnN0cmlkZUhlaWdodCxvPXQuc3RyaWRlV2lkdGgsYT10LmRpbGF0aW9uSGVpZ2h0LGk9dC5kaWxhdGlvbldpZHRoLHM9dC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsdT10LmVmZmVjdGl2ZUZpbHRlcldpZHRoLGw9cy0xLXQucGFkSW5mby50b3AsYz11LTEtdC5wYWRJbmZvLmxlZnQsaD0xLyhlKm4pO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIrbCtcIiwgXCIrYytcIik7XFxuICAgICAgY29uc3QgZmxvYXQgYXZnTXVsdGlwbGllciA9IGZsb2F0KFwiK2grXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgIGl2ZWMyIGR5UkNDb3JuZXIgPSBjb29yZHMueXogLSBwYWRzO1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5UkNDb3JuZXIueDtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeVJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkKSB3aXRoIHBvcyBtYXNrKDosIDosIGQpIHRvIGdldCBkeCh4UiwgeEMsIGQpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK3MrXCI7XFxuICAgICAgICAgICAgd1IgKz0gXCIrYStcIikge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIityK1wiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiK3Qub3V0SGVpZ2h0K1wiLjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIit1K1wiO1xcbiAgICAgICAgICAgIHdDKz0gXCIraStcIikge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiK28rXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIit0Lm91dFdpZHRoK1wiLjAgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIGlkeVIsIGlkeUMsIGQpO1xcblxcbiAgICAgICAgICAgIGRvdFByb2QgKz0gZHlWYWx1ZSAqIGF2Z011bHRpcGxpZXI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxObz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyLG8sYSl7dGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwibWVhblwiLFwidmFyaWFuY2VcIl0sc28odCxlKSxzbyh0LG4pO3ZhciBpPVwiMC4wXCI7bnVsbCE9ciYmKHNvKHQsciksdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJvZmZzZXRcIiksaT1cImdldE9mZnNldEF0T3V0Q29vcmRzKClcIik7dmFyIHM9XCIxLjBcIjtudWxsIT1vJiYoc28odCxvKSx0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcInNjYWxlXCIpLHM9XCJnZXRTY2FsZUF0T3V0Q29vcmRzKClcIiksdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCB4ID0gZ2V0WEF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBtZWFuID0gZ2V0TWVhbkF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCB2YXJpYW5jZSA9IGdldFZhcmlhbmNlQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IG9mZnNldCA9IFwiK2krXCI7XFxuICAgICAgICBmbG9hdCBzY2FsZSA9IFwiK3MrXCI7XFxuICAgICAgICBmbG9hdCBpbnYgPSBzY2FsZSAqIGludmVyc2VzcXJ0KHZhcmlhbmNlICsgZmxvYXQoXCIrYStcIikpO1xcbiAgICAgICAgc2V0T3V0cHV0KGRvdCh2ZWMzKHgsIC1tZWFuLCBvZmZzZXQpLCB2ZWMzKGludiwgaW52LCAxKSkpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLGtvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt0aGlzLnVzZXNQYWNrZWRUZXh0dXJlcz0hMCx0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwibWVhblwiLFwidmFyaWFuY2VcIl0sc28odCxlKSxzbyh0LG4pO3ZhciBpPVwidmVjNCgwLjApXCI7bnVsbCE9ciYmKHNvKHQsciksdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJvZmZzZXRcIiksaT1cImdldE9mZnNldEF0T3V0Q29vcmRzKClcIik7dmFyIHM9XCJ2ZWM0KDEuMClcIjtudWxsIT1vJiYoc28odCxvKSx0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcInNjYWxlXCIpLHM9XCJnZXRTY2FsZUF0T3V0Q29vcmRzKClcIiksdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IG9mZnNldCA9IFwiK2krXCI7XFxuICAgICAgICB2ZWM0IHNjYWxlID0gXCIrcytcIjtcXG5cXG4gICAgICAgIHZlYzQgeCA9IGdldFhBdE91dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCBtZWFuID0gZ2V0TWVhbkF0T3V0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IHZhcmlhbmNlID0gZ2V0VmFyaWFuY2VBdE91dENvb3JkcygpO1xcblxcbiAgICAgICAgdmVjNCBpbnYgPSBzY2FsZSAqIGludmVyc2VzcXJ0KHZhcmlhbmNlICsgdmVjNChcIithK1wiKSk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQoKHggLSBtZWFuKSAqIGludiArIG9mZnNldCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksSW89XCJyZXR1cm4gYXJlYWwgKiBicmVhbCAtIGFpbWFnICogYmltYWc7XCIsQW89XCJyZXR1cm4gYXJlYWwgKiBiaW1hZyArIGFpbWFnICogYnJlYWw7XCIsVG89ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBUmVhbFwiLFwiQUltYWdcIixcIkJSZWFsXCIsXCJCSW1hZ1wiXSx0aGlzLm91dHB1dFNoYXBlPXNvKGUsbiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGZsb2F0IGJpbmFyeU9wQ29tcGxleChcXG4gICAgICAgICAgZmxvYXQgYXJlYWwsIGZsb2F0IGFpbWFnLCBmbG9hdCBicmVhbCwgZmxvYXQgYmltYWcpIHtcXG4gICAgICAgIFwiK3QrXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgYXJlYWwgPSBnZXRBUmVhbEF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBhaW1hZyA9IGdldEFJbWFnQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGJyZWFsID0gZ2V0QlJlYWxBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgYmltYWcgPSBnZXRCSW1hZ0F0T3V0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoYmluYXJ5T3BDb21wbGV4KGFyZWFsLCBhaW1hZywgYnJlYWwsIGJpbWFnKSk7XFxuICAgICAgfVxcbiAgICBcIn19KCksRG89XCJyZXR1cm4gYSArIGI7XCIsT289XCJyZXR1cm4gYSAtIGI7XCIsX289XCJyZXR1cm4gYSAqIGI7XCIsTW89ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCIsXCJCXCJdLHRoaXMub3V0cHV0U2hhcGU9c28oZSxuKSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgZmxvYXQgYmluYXJ5T3BlcmF0aW9uKGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgICAgIFwiK3QrXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgYSA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgYiA9IGdldEJBdE91dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGJpbmFyeU9wZXJhdGlvbihhLCBiKSk7XFxuICAgICAgfVxcbiAgICBcIn19KCksRm89ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9ITEpLHRoaXMudmFyaWFibGVOYW1lcz1bXCJBXCIsXCJCXCJdLHRoaXMuc3VwcG9ydHNCcm9hZGNhc3Rpbmc9ITAsdGhpcy51c2VzUGFja2VkVGV4dHVyZXM9ITAsdGhpcy5vdXRwdXRTaGFwZT1zbyhlLG4pO3ZhciBvPXRoaXMub3V0cHV0U2hhcGUubGVuZ3RoLGE9XCJcIjtpZihyKWlmKDA9PT1vfHwxPT09eSh0aGlzLm91dHB1dFNoYXBlKSlhPVwiXFxuICAgICAgICAgIHJlc3VsdC55ID0gMC47XFxuICAgICAgICAgIHJlc3VsdC56ID0gMC47XFxuICAgICAgICAgIHJlc3VsdC53ID0gMC47XFxuICAgICAgICBcIjtlbHNlIGlmKGE9XCJcXG4gICAgICAgICAgXCIrYm8obykrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBcIiwxPT09bylhKz1cIlxcbiAgICAgICAgICAgIHJlc3VsdC55ID0gKGNvb3JkcyArIDEpID49IFwiK3RoaXMub3V0cHV0U2hhcGVbMF0rXCIgPyAwLiA6IHJlc3VsdC55O1xcbiAgICAgICAgICAgIHJlc3VsdC56ID0gMC47XFxuICAgICAgICAgICAgcmVzdWx0LncgPSAwLjtcXG4gICAgICAgICAgXCI7ZWxzZXt2YXIgaT1vbyhcImNvb3Jkc1wiLG8pO2ErPVwiXFxuICAgICAgICAgICAgYm9vbCBuZXh0Um93T3V0T2ZCb3VuZHMgPVxcbiAgICAgICAgICAgICAgKFwiK2lbby0yXStcIiArIDEpID49IFwiK3RoaXMub3V0cHV0U2hhcGVbby0yXStcIjtcXG4gICAgICAgICAgICBib29sIG5leHRDb2xPdXRPZkJvdW5kcyA9XFxuICAgICAgICAgICAgICAoXCIraVtvLTFdK1wiICsgMSkgPj0gXCIrdGhpcy5vdXRwdXRTaGFwZVtvLTFdK1wiO1xcbiAgICAgICAgICAgIHJlc3VsdC55ID0gbmV4dENvbE91dE9mQm91bmRzID8gMC4gOiByZXN1bHQueTtcXG4gICAgICAgICAgICByZXN1bHQueiA9IG5leHRSb3dPdXRPZkJvdW5kcyA/IDAuIDogcmVzdWx0Lno7XFxuICAgICAgICAgICAgcmVzdWx0LncgPSBuZXh0Q29sT3V0T2ZCb3VuZHMgfHwgbmV4dFJvd091dE9mQm91bmRzID8gMC4gOiByZXN1bHQudztcXG4gICAgICAgICAgXCJ9dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZlYzQgYmluYXJ5T3BlcmF0aW9uKHZlYzQgYSwgdmVjNCBiKSB7XFxuICAgICAgICBcIit0K1wiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZlYzQgYSA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCBiID0gZ2V0QkF0T3V0Q29vcmRzKCk7XFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IGJpbmFyeU9wZXJhdGlvbihhLCBiKTtcXG4gICAgICAgIFwiK2ErXCJcXG5cXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLEJvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHVuaWZvcm0gZmxvYXQgbWluO1xcbiAgICAgIHVuaWZvcm0gZmxvYXQgbWF4O1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBpZiAoaXNuYW4odmFsdWUpKSB7XFxuICAgICAgICAgIHNldE91dHB1dCh2YWx1ZSk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHNldE91dHB1dChjbGFtcCh2YWx1ZSwgbWluLCBtYXgpKTtcXG4gICAgICB9XFxuICAgIFwifXJldHVybiB0LnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmM9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO3JldHVybiBmdW5jdGlvbihyLG8pe251bGw9PW4ubWluTG9jJiYobi5taW5Mb2M9ci5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KG8sXCJtaW5cIiksbi5tYXhMb2M9ci5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KG8sXCJtYXhcIikpLHIuZ2wudW5pZm9ybTFmKG4ubWluTG9jLHQpLHIuZ2wudW5pZm9ybTFmKG4ubWF4TG9jLGUpfX0sdH0oKSxQbz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy51c2VzUGFja2VkVGV4dHVyZXM9ITAsdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB1bmlmb3JtIGZsb2F0IG1pbjtcXG4gICAgICB1bmlmb3JtIGZsb2F0IG1heDtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IHZhbHVlID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuXFxuICAgICAgICBpZiAoYW55KGlzbmFuKHZhbHVlKSkpIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGNsYW1wKHZhbHVlLCB2ZWM0KG1pbiksIHZlYzQobWF4KSkpO1xcbiAgICAgIH1cXG4gICAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYz1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKHIsbyl7bnVsbD09bi5taW5Mb2MmJihuLm1pbkxvYz1yLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cobyxcIm1pblwiKSxuLm1heExvYz1yLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cobyxcIm1heFwiKSksci5nbC51bmlmb3JtMWYobi5taW5Mb2MsdCksci5nbC51bmlmb3JtMWYobi5tYXhMb2MsZSl9fSx0fSgpLExvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJyZWFsXCIsXCJpbWFnXCJdLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgcmUgPSBhYnMoZ2V0UmVhbEF0T3V0Q29vcmRzKCkpO1xcbiAgICAgICAgZmxvYXQgaW0gPSBhYnMoZ2V0SW1hZ0F0T3V0Q29vcmRzKCkpO1xcbiAgICAgICAgZmxvYXQgbXggPSBtYXgocmUsIGltKTtcXG5cXG4gICAgICAgIC8vIHNhZGx5IHRoZSBsZW5ndGggZnVuY3Rpb24gaW4gZ2xzbCBpcyBub3QgdW5kZXJmbG93LXNhZmVcXG4gICAgICAgIC8vIChhdCBsZWFzdCBub3Qgb24gSW50ZWwgR1BVcykuIFNvIHRoZSBzYWZlIHNvbHV0aW9uIGlzXFxuICAgICAgICAvLyB0byBlbnN1cmUgdW5kZXJmbG93LXNhZmV0eSBpbiBhbGwgY2FzZXMuXFxuICAgICAgICBzZXRPdXRwdXQoXFxuICAgICAgICAgIG14ID09IDAuMCA/IDAuMCA6IG14ICogbGVuZ3RoKHZlYzIoMSwgbWluKHJlLCBpbSkvbXgpKVxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxXbz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9c24odCwxKSx0aGlzLnZhcmlhYmxlTmFtZXM9dC5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm5cIlRcIitlfSk7dmFyIGU9bmV3IEFycmF5KHQubGVuZ3RoLTEpO2VbMF09dFswXVsxXTtmb3IodmFyIG49MTtuPGUubGVuZ3RoO24rKyllW25dPWVbbi0xXSt0W25dWzFdO3ZhciByPVtcImlmICh5QyA8IFwiK2VbMF0rXCIpIHNldE91dHB1dChnZXRUMCh5UiwgeUMpKTtcIl07Zm9yKG49MTtuPGUubGVuZ3RoO24rKyl7dmFyIG89ZVtuLTFdO3IucHVzaChcImVsc2UgaWYgKHlDIDwgXCIrZVtuXStcIikgc2V0T3V0cHV0KGdldFRcIituK1wiKHlSLCB5Qy1cIitvK1wiKSk7XCIpfXZhciBhPWUubGVuZ3RoLGk9ZVtlLmxlbmd0aC0xXTtyLnB1c2goXCJlbHNlIHNldE91dHB1dChnZXRUXCIrYStcIih5UiwgeUMtXCIraStcIikpO1wiKSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgeVIgPSBjb29yZHMueDtcXG4gICAgICAgIGludCB5QyA9IGNvb3Jkcy55O1xcblxcbiAgICAgICAgXCIrci5qb2luKFwiXFxuICAgICAgICBcIikrXCJcXG4gICAgICB9XFxuICAgIFwifX0oKSxVbz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUpe3RoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT1zbih0LGUpO3ZhciBuPXRoaXMub3V0cHV0U2hhcGUscj1uLmxlbmd0aCxvPWJvKHIpLGE9b28oXCJjb29yZHNcIixyKSxpPVtcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl0uc2xpY2UoMCxyKTt0aGlzLnZhcmlhYmxlTmFtZXM9dC5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm5cIlRcIitlfSk7dmFyIHM9bmV3IEFycmF5KHQubGVuZ3RoLTEpO3NbMF09dFswXVtlXTtmb3IodmFyIHU9MTt1PHMubGVuZ3RoO3UrKylzW3VdPXNbdS0xXSt0W3VdW2VdO3ZhciBsPWlbZV0sYz1cInZlYzIoXCIraS5zbGljZSgtMikuam9pbigpK1wiKVwiLGg9aS5qb2luKCkscD1cImlmIChcIitsK1wiIDwgXCIrc1swXStcIilcXG4gICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoZ2V0VDAoXCIraCtcIiksIFwiK2MrXCIpO1wiO2Zvcih1PTE7dTxzLmxlbmd0aDt1Kyspe3ZhciBmPXNbdS0xXTtwKz1cIlxcbiAgICAgICAgZWxzZSBpZiAoXCIrbCtcIiA8IFwiK3NbdV0rXCIpIHtcXG4gICAgICAgICAgXCIrbCtcIiAtPSBcIitmK1wiO1xcbiAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChnZXRUXCIrdStcIihcIitoK1wiKSwgXCIrYytcIik7XFxuICAgICAgICB9XCJ9dmFyIGQ9cy5sZW5ndGg7cCs9XCJcXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICBcIitsK1wiIC09IFwiK3Nbcy5sZW5ndGgtMV0rXCI7XFxuICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsKGdldFRcIitkK1wiKFwiK2grXCIpLCBcIitjK1wiKTtcXG4gICAgICAgIH1cIix0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgZmxvYXQgZ2V0VmFsdWUoXCIraS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJpbnQgXCIrdH0pK1wiKSB7XFxuICAgICAgICBcIitwK1wiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK28rXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoZ2V0VmFsdWUoXCIrYStcIiksIDAuLCAwLiwgMC4pO1xcbiAgICAgICAgaWYgKCsrXCIrYVtyLTFdK1wiIDwgXCIrbltyLTFdK1wiKSB7XFxuICAgICAgICAgIHJlc3VsdC5nID0gZ2V0VmFsdWUoXCIrYStcIik7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoKytcIithW3ItMl0rXCIgPCBcIituW3ItMl0rXCIpIHtcXG4gICAgICAgICAgcmVzdWx0LmEgPSBnZXRWYWx1ZShcIithK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChcIithW3ItMl0rXCIgPCBcIituW3ItMl0rXCIgJiZcXG4gICAgICAgICAgICAtLVwiK2Fbci0xXStcIiA8IFwiK25bci0xXStcIikge1xcbiAgICAgICAgICByZXN1bHQuYiA9IGdldFZhbHVlKFwiK2ErXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksem89ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9dC5maWx0ZXJTaGFwZTt2YXIgZT10LnN0cmlkZUhlaWdodCxuPXQuc3RyaWRlV2lkdGgscj10LnBhZEluZm8udG9wLG89dC5wYWRJbmZvLmxlZnQ7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHdSID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgd0MgPSBjb29yZHMueTtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy56O1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnc7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIGR5KDosIDosIGQyKSB0byBnZXQgZHcod1IsIHdDLCBkMSwgZDIpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgYiA9IDA7IGIgPCBcIit0LmJhdGNoU2l6ZStcIjsgYisrKSB7XFxuICAgICAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCBcIit0Lm91dEhlaWdodCtcIjsgeVIrKykge1xcbiAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiBcIitlK1wiIC0gXCIrcitcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK3QuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB5QyA9IDA7IHlDIDwgXCIrdC5vdXRXaWR0aCtcIjsgeUMrKykge1xcbiAgICAgICAgICAgICAgaW50IHhDID0gd0MgKyB5QyAqIFwiK24rXCIgLSBcIitvK1wiO1xcblxcbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIit0LmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgeVIsIHlDLCBkMik7XFxuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksVm89ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9dC5pblNoYXBlO3ZhciBlPXQuZmlsdGVySGVpZ2h0LG49dC5maWx0ZXJXaWR0aCxyPXQuc3RyaWRlSGVpZ2h0LG89dC5zdHJpZGVXaWR0aCxhPWUtMS10LnBhZEluZm8udG9wLGk9bi0xLXQucGFkSW5mby5sZWZ0O3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIrYStcIiwgXCIraStcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHNbM107XFxuXFxuICAgICAgICBpdmVjMiBkeUNvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrZStcIjsgd1IrKykge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIityK1wiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiK3Qub3V0SGVpZ2h0K1wiLjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgIGludCB3UlBlcm0gPSBcIitlK1wiIC0gMSAtIHdSO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrbitcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiK28rXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIit0Lm91dFdpZHRoK1wiLjAgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgaW50IHdDUGVybSA9IFwiK24rXCIgLSAxIC0gd0M7XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgZDIgPSAwOyBkMiA8IFwiK3Qub3V0Q2hhbm5lbHMrXCI7IGQyKyspIHtcXG4gICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldER5KGJhdGNoLCBpZHlSLCBpZHlDLCBkMik7XFxuICAgICAgICAgICAgICBmbG9hdCB3VmFsdWUgPSBnZXRXKHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksR289ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9dC5maWx0ZXJTaGFwZTt2YXIgZT10LnN0cmlkZURlcHRoLG49dC5zdHJpZGVIZWlnaHQscj10LnN0cmlkZVdpZHRoLG89dC5wYWRJbmZvLmZyb250LGE9dC5wYWRJbmZvLnRvcCxpPXQucGFkSW5mby5sZWZ0O3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCB3RiA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IHdSID0gY29vcmRzLnk7XFxuICAgICAgICBpbnQgd0MgPSBjb29yZHMuejtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy53O1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnU7XFxuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgYiA9IDA7IGIgPCBcIit0LmJhdGNoU2l6ZStcIjsgYisrKSB7XFxuICAgICAgICAgIGZvciAoaW50IHlGID0gMDsgeUYgPCBcIit0Lm91dERlcHRoK1wiOyB5RisrKSB7XFxuICAgICAgICAgICAgaW50IHhGID0gd0YgKyB5RiAqIFwiK2UrXCIgLSBcIitvK1wiO1xcblxcbiAgICAgICAgICAgIGlmICh4RiA8IDAgfHwgeEYgPj0gXCIrdC5pbkRlcHRoK1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgeVIgPSAwOyB5UiA8IFwiK3Qub3V0SGVpZ2h0K1wiOyB5UisrKSB7XFxuICAgICAgICAgICAgICBpbnQgeFIgPSB3UiArIHlSICogXCIrbitcIiAtIFwiK2ErXCI7XFxuXFxuICAgICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK3QuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmb3IgKGludCB5QyA9IDA7IHlDIDwgXCIrdC5vdXRXaWR0aCtcIjsgeUMrKykge1xcbiAgICAgICAgICAgICAgICBpbnQgeEMgPSB3QyArIHlDICogXCIrcitcIiAtIFwiK2krXCI7XFxuXFxuICAgICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrdC5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIHlGLCB5UiwgeUMsIGQyKTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0WChiLCB4RiwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gKHhWYWx1ZSAqIGR5VmFsdWUpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLHFvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPXQuaW5TaGFwZTt2YXIgZT10LmZpbHRlckRlcHRoLG49dC5maWx0ZXJIZWlnaHQscj10LmZpbHRlcldpZHRoLG89dC5zdHJpZGVEZXB0aCxhPXQuc3RyaWRlSGVpZ2h0LGk9dC5zdHJpZGVXaWR0aCxzPWUtMS10LnBhZEluZm8uZnJvbnQsdT1uLTEtdC5wYWRJbmZvLnRvcCxsPXItMS10LnBhZEluZm8ubGVmdDt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzMgcGFkcyA9IGl2ZWMzKFwiK3MrXCIsIFwiK3UrXCIsIFwiK2wrXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHMudTtcXG5cXG5cXG4gICAgICAgIGl2ZWMzIGR5Q29ybmVyID0gaXZlYzMoY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMudykgLSBwYWRzO1xcbiAgICAgICAgaW50IGR5RkNvcm5lciA9IGR5Q29ybmVyLng7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueTtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci56O1xcblxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdGID0gMDsgd0YgPCBcIitlK1wiOyB3RisrKSB7XFxuICAgICAgICAgIGZsb2F0IGR5RiA9IGZsb2F0KGR5RkNvcm5lciArIHdGKSAvIFwiK28rXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5RiA8IDAuMCB8fCBkeUYgPj0gXCIrdC5vdXREZXB0aCtcIi4wIHx8IGZyYWN0KGR5RikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5RiA9IGludChkeUYpO1xcblxcbiAgICAgICAgICBpbnQgd0ZQZXJtID0gXCIrZStcIiAtIDEgLSB3RjtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK24rXCI7IHdSKyspIHtcXG4gICAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIithK1wiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIrdC5vdXRIZWlnaHQrXCIuMCB8fFxcbiAgICAgICAgICAgICAgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgICAgaW50IHdSUGVybSA9IFwiK24rXCIgLSAxIC0gd1I7XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK3IrXCI7IHdDKyspIHtcXG4gICAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiK2krXCIuMDtcXG5cXG4gICAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiK3Qub3V0V2lkdGgrXCIuMCB8fFxcbiAgICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgICAgaW50IHdDUGVybSA9IFwiK3IrXCIgLSAxIC0gd0M7XFxuXFxuICAgICAgICAgICAgICBmb3IgKGludCBkMiA9IDA7IGQyIDwgXCIrdC5vdXRDaGFubmVscytcIjsgZDIrKykge1xcbiAgICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXREeShiYXRjaCwgaWR5RiwgaWR5UiwgaWR5QywgZDIpO1xcbiAgICAgICAgICAgICAgICBmbG9hdCB3VmFsdWUgPSBnZXRXKHdGUGVybSwgd1JQZXJtLCB3Q1Blcm0sIGQxLCBkMik7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbHVlICogd1ZhbHVlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLEhvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPXQuZmlsdGVyU2hhcGU7dmFyIGU9dC5zdHJpZGVIZWlnaHQsbj10LnN0cmlkZVdpZHRoLHI9dC5wYWRJbmZvLnRvcCxvPXQucGFkSW5mby5sZWZ0LGE9dC5vdXRDaGFubmVscy90LmluQ2hhbm5lbHM7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHdSID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgd0MgPSBjb29yZHMueTtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy56O1xcbiAgICAgICAgaW50IGRtID0gY29vcmRzLnc7XFxuICAgICAgICBpbnQgZDIgPSBkMSAqIFwiK2ErXCIgKyBkbTtcXG5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuXFxuICAgICAgICAvLyBUT0RPOiBWZWM0IG92ZXIgdGhlIGJhdGNoIHNpemVcXG4gICAgICAgIGZvciAoaW50IGIgPSAwOyBiIDwgXCIrdC5iYXRjaFNpemUrXCI7IGIrKykge1xcbiAgICAgICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgXCIrdC5vdXRIZWlnaHQrXCI7IHlSKyspIHtcXG4gICAgICAgICAgICBpbnQgeFIgPSB3UiArIHlSICogXCIrZStcIiAtIFwiK3IrXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIit0LmluSGVpZ2h0K1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgeUMgPSAwOyB5QyA8IFwiK3Qub3V0V2lkdGgrXCI7IHlDKyspIHtcXG4gICAgICAgICAgICAgIGludCB4QyA9IHdDICsgeUMgKiBcIituK1wiIC0gXCIrbytcIjtcXG5cXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrdC5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIHlSLCB5QywgZDIpO1xcbiAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0WChiLCB4UiwgeEMsIGQxKTtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gKHhWYWx1ZSAqIGR5VmFsdWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLCRvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPXQuaW5TaGFwZTt2YXIgZT10LmZpbHRlckhlaWdodCxuPXQuZmlsdGVyV2lkdGgscj10LnN0cmlkZUhlaWdodCxvPXQuc3RyaWRlV2lkdGgsYT1lLTEtdC5wYWRJbmZvLnRvcCxpPW4tMS10LnBhZEluZm8ubGVmdCxzPXQub3V0Q2hhbm5lbHMvdC5pbkNoYW5uZWxzO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIrYStcIiwgXCIraStcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHNbM107XFxuICAgICAgICBpdmVjMiBkeUNvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xcblxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitlK1wiOyB3UisrKSB7XFxuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiK3IrXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIrdC5vdXRIZWlnaHQrXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgaW50IHdSUGVybSA9IFwiK2UrXCIgLSAxIC0gd1I7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIituK1wiOyB3QysrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIrbytcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiK3Qub3V0V2lkdGgrXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBpbnQgd0NQZXJtID0gXCIrbitcIiAtIDEgLSB3QztcXG5cXG4gICAgICAgICAgICAvLyBUT0RPOiBWZWM0IG92ZXIgdGhlIGNoYW5uZWxNdWxcXG4gICAgICAgICAgICBmb3IgKGludCBkbSA9IDA7IGRtIDwgXCIrcytcIjsgZG0rKykge1xcbiAgICAgICAgICAgICAgaW50IGQyID0gZDEgKiBcIitzK1wiICsgZG07XFxuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXREeShiYXRjaCwgaWR5UiwgaWR5QywgZDIpO1xcbiAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3UlBlcm0sIHdDUGVybSwgZDEsIGRtKTtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbHVlICogd1ZhbHVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLGpvPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9dC5vdXRTaGFwZTt2YXIgZT10LnBhZEluZm8udG9wLG49dC5wYWRJbmZvLmxlZnQscj10LnN0cmlkZUhlaWdodCxvPXQuc3RyaWRlV2lkdGgsYT10LmRpbGF0aW9uSGVpZ2h0LGk9dC5kaWxhdGlvbldpZHRoLHM9dC5maWx0ZXJIZWlnaHQsdT10LmZpbHRlcldpZHRoLGw9NCpNYXRoLmZsb29yKHQuaW5DaGFubmVscy80KSxjPXQuaW5DaGFubmVscyU0O3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIrcitcIiwgXCIrbytcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2UrXCIsIFwiK24rXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCBkMSkgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gZ2V0IHkoeVIsIHlDLCBkMikuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrcytcIjsgd1IrKykge1xcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSICogXCIrYStcIjtcXG5cXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIit0LmluSGVpZ2h0K1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK3UrXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogXCIraStcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK3QuaW5XaWR0aCtcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IGQxID0gMDsgZDEgPCBcIitsK1wiOyBkMSArPSA0KSB7XFxuICAgICAgICAgICAgICB2ZWM0IHhWYWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxKSxcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSArIDEpLFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMiksXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgZDEgKyAzKVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIHZlYzQgd1ZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDIsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMywgZDIpXFxuICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChcIisoMT09PWMpK1wiKSB7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9XFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIrbCtcIikgKlxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIrbCtcIiwgZDIpO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIrKDI9PT1jKStcIikge1xcbiAgICAgICAgICAgICAgdmVjMiB4VmFsdWVzID0gdmVjMihcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIitsK1wiKSxcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIitsK1wiICsgMSlcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICB2ZWMyIHdWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIrbCtcIiwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIrbCtcIiArIDEsIGQyKVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIrKDM9PT1jKStcIikge1xcbiAgICAgICAgICAgICAgdmVjMyB4VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIitsK1wiKSxcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIitsK1wiICsgMSksXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIrbCtcIiArIDIpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgdmVjMyB3VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiK2wrXCIsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiK2wrXCIgKyAxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIitsK1wiICsgMiwgZDIpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksS289ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIldcIl0sdGhpcy5vdXRwdXRTaGFwZT10Lm91dFNoYXBlO3ZhciBlPXQucGFkSW5mby5mcm9udCxuPXQucGFkSW5mby50b3Ascj10LnBhZEluZm8ubGVmdCxvPXQuc3RyaWRlRGVwdGgsYT10LnN0cmlkZUhlaWdodCxpPXQuc3RyaWRlV2lkdGgscz10LmRpbGF0aW9uRGVwdGgsdT10LmRpbGF0aW9uSGVpZ2h0LGw9dC5kaWxhdGlvbldpZHRoLGM9dC5maWx0ZXJEZXB0aCxoPXQuZmlsdGVySGVpZ2h0LHA9dC5maWx0ZXJXaWR0aCxmPTQqTWF0aC5mbG9vcih0LmluQ2hhbm5lbHMvNCksZD10LmluQ2hhbm5lbHMlNDt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzMgc3RyaWRlcyA9IGl2ZWMzKFwiK28rXCIsIFwiK2ErXCIsIFwiK2krXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMzIHBhZHMgPSBpdmVjMyhcIitlK1wiLCBcIituK1wiLCBcIityK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnU7XFxuXFxuICAgICAgICBpdmVjMyB4RlJDQ29ybmVyID0gaXZlYzMoY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMudykgKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCB4RkNvcm5lciA9IHhGUkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhGUkNDb3JuZXIueTtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhGUkNDb3JuZXIuejtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgPywgZDEpIHdpdGggdyg6LCA6LCA6LCBkMSwgZDIpIHRvIGdldFxcbiAgICAgICAgLy8geSh5RiwgeVIsIHlDLCBkMikuID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbFxcbiAgICAgICAgLy8gdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3RiA9IDA7IHdGIDwgXCIrYytcIjsgd0YrKykge1xcbiAgICAgICAgICBpbnQgeEYgPSB4RkNvcm5lciArIHdGICogXCIrcytcIjtcXG5cXG4gICAgICAgICAgaWYgKHhGIDwgMCB8fCB4RiA+PSBcIit0LmluRGVwdGgrXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIraCtcIjsgd1IrKykge1xcbiAgICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1IgKiBcIit1K1wiO1xcblxcbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrdC5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIitwK1wiOyB3QysrKSB7XFxuICAgICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogXCIrbCtcIjtcXG5cXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrdC5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgZm9yIChpbnQgZDEgPSAwOyBkMSA8IFwiK2YrXCI7IGQxICs9IDQpIHtcXG4gICAgICAgICAgICAgICAgdmVjNCB4VmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAxKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMylcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgdmVjNCB3VmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIGQxLCBkMiksXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBkMSArIDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIGQxICsgMiwgZDIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgZDEgKyAzLCBkMilcXG4gICAgICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBpZiAoXCIrKDE9PT1kKStcIikge1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9XFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgXCIrZitcIikgKlxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgXCIrZitcIiwgZDIpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChcIisoMj09PWQpK1wiKSB7XFxuICAgICAgICAgICAgICAgIHZlYzIgeFZhbHVlcyA9IHZlYzIoXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgXCIrZitcIiksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgXCIrZitcIiArIDEpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIHZlYzIgd1ZhbHVlcyA9IHZlYzIoXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBcIitmK1wiLCBkMiksXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBcIitmK1wiICsgMSwgZDIpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChcIisoMz09PWQpK1wiKSB7XFxuICAgICAgICAgICAgICAgIHZlYzMgeFZhbHVlcyA9IHZlYzMoXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgXCIrZitcIiksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgXCIrZitcIiArIDEpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIFwiK2YrXCIgKyAyKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICB2ZWMzIHdWYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgXCIrZitcIiwgZDIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgXCIrZitcIiArIDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIFwiK2YrXCIgKyAyLCBkMilcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksWG89ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIldcIl0sdGhpcy5vdXRwdXRTaGFwZT10Lm91dFNoYXBlO3ZhciBlPXQuaW5IZWlnaHQsbj10LmluV2lkdGgscj10LnBhZEluZm8udG9wLG89dC5wYWRJbmZvLmxlZnQsYT10LnN0cmlkZUhlaWdodCxpPXQuc3RyaWRlV2lkdGgscz10LmRpbGF0aW9uSGVpZ2h0LHU9dC5kaWxhdGlvbldpZHRoLGw9dC5maWx0ZXJIZWlnaHQsYz10LmZpbHRlcldpZHRoLGg9dC5vdXRDaGFubmVscy90LmluQ2hhbm5lbHM7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIithK1wiLCBcIitpK1wiKTtcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIrcitcIiwgXCIrbytcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy55eiAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnc7XFxuICAgICAgICBpbnQgZDEgPSBkMiAvIFwiK2grXCI7XFxuICAgICAgICBpbnQgcSA9IGQyIC0gZDEgKiBcIitoK1wiO1xcblxcbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggdyg6LCA6LCBkMSwgcSkgdG8gZ2V0IHkoeVIsIHlDLCBkMikuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICAvLyBUT0RPKGRzbWlsa292KTogRmxhdHRlbiB0aGUgdHdvIGZvciBsb29wcyBhbmQgdmVjNCB0aGUgb3BlcmF0aW9ucy5cXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitsK1wiOyB3UisrKSB7XFxuICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1IgKiBcIitzK1wiO1xcblxcbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK2UrXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrYytcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0MgKiBcIit1K1wiO1xcblxcbiAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrbitcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZsb2F0IHhWYWwgPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxKTtcXG4gICAgICAgICAgICBmbG9hdCB3VmFsID0gZ2V0Vyh3Uiwgd0MsIGQxLCBxKTtcXG4gICAgICAgICAgICBkb3RQcm9kICs9IHhWYWwgKiB3VmFsO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksWW89ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIldcIl0sdGhpcy51c2VzUGFja2VkVGV4dHVyZXM9ITAsdGhpcy5vdXRwdXRTaGFwZT10Lm91dFNoYXBlO2Zvcih2YXIgZT10LmluSGVpZ2h0LG49dC5pbldpZHRoLHI9dC5wYWRJbmZvLnRvcCxvPXQucGFkSW5mby5sZWZ0LGE9dC5zdHJpZGVIZWlnaHQsaT10LnN0cmlkZVdpZHRoLHM9dC5kaWxhdGlvbkhlaWdodCx1PXQuZGlsYXRpb25XaWR0aCxsPXQuZmlsdGVySGVpZ2h0LGM9dC5maWx0ZXJXaWR0aCxoPWMsZj1cImludCB4UjsgaW50IHhDOyBpbnQgeENPZmZzZXQ7XCIsZD0wO2Q8bDtkKyspZm9yKHZhciB2PTA7djxjO3YrKylmKz1cIlxcbiAgICAgICAgICB2ZWM0IHhUZXhlbFJcIitkK1wiQ1wiKzIqditcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICB2ZWM0IHdSXCIrZCtcIkNcIit2K1wiID0gdmVjNCgwLik7XFxuICAgICAgICAgIHZlYzQgeFJcIitkK1wiQ1wiK3YrXCIgPSB2ZWM0KDAuKTtcIjtmb3IoZD0wO2Q8bDtkKyspZm9yKHZhciBtPTA7bTxoO20rKyl7aWYoZis9XCJcXG4gICAgICAgICAgeFIgPSB4UkNvcm5lciArIFwiK2QqcytcIjtcXG4gICAgICAgICAgeEMgPSB4Q0Nvcm5lciArIFwiKyh2PTIqbSkqdStcIjtcXG4gICAgICAgIFwiLDE9PT1pKXtpZih2PGMmJihmKz1vJTI9PTE/XCJcXG4gICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIDE7XFxuICAgICAgICAgICAgICAgIGlmKHhSID49IDAgJiYgeFIgPCBcIitlK1wiICYmIHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIituK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2QrXCJDXCIrditcIiA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitkK1wiQ1wiK3YrXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgMSAtIDI7XFxuICAgICAgICAgICAgICAgIGlmKHhSID49IDAgJiYgeFIgPCBcIitlK1wiICYmIHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIituK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgdmVjNCBwcmV2aW91cyA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcbiAgICAgICAgICAgICAgICAgIHhSXCIrZCtcIkNcIit2K1wiID0gdmVjNChwcmV2aW91cy56dywgeFRleGVsUlwiK2QrXCJDXCIrditcIi54eSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgeFJcIitkK1wiQ1wiK3YrXCIgPSB2ZWM0KDAsIDAsIHhUZXhlbFJcIitkK1wiQ1wiK3YrXCIueHkpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBcIjpcIlxcbiAgICAgICAgICAgICAgICBpZih4UiA+PSAwICYmIHhSIDwgXCIrZStcIiAmJiB4QyA+PSAwICYmIHhDIDwgXCIrbitcIikge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitkK1wiQ1wiK3YrXCIgPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZCtcIkNcIit2K1wiID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgeFJcIitkK1wiQ1wiK3YrXCIgPSB4VGV4ZWxSXCIrZCtcIkNcIit2K1wiO1xcbiAgICAgICAgICAgICAgXCIsdisxPGMpKXt2YXIgZz1vJTI9PTA/cCh1KTp1O3UlMj09MCYmbyUyPT0xfHx1JTIhPTAmJm8lMiE9MT8oZis9XCJcXG4gICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgXCIrbyUyK1wiICsgXCIrZytcIjtcXG5cXG4gICAgICAgICAgICAgICAgICBpZih4UiA+PSAwICYmIHhSIDwgXCIrZStcIiAmJlxcbiAgICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IFwiK24rXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitkK1wiQ1wiKyh2KzIpK1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBcIix1PjEmJihmKz1cIlxcbiAgICAgICAgICAgICAgICAgICAgeENPZmZzZXQgLT0gMjtcXG4gICAgICAgICAgICAgICAgICAgIGlmKHhSID49IDAgJiYgeFIgPCBcIitlK1wiICYmXFxuICAgICAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIituK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitkK1wiQ1wiK3YrXCIgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitkK1wiQ1wiK3YrXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICBcIiksZis9XCJcXG4gICAgICAgICAgICAgICAgICB4UlwiK2QrXCJDXCIrKHYrMSkrXCIgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2QrXCJDXCIrditcIi56dywgeFRleGVsUlwiK2QrXCJDXCIrKHYrMikrXCIueHkpO1xcbiAgICAgICAgICAgICAgICBcIik6Zis9XCJcXG4gICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgXCIrZytcIjtcXG5cXG4gICAgICAgICAgICAgICAgICBpZih4UiA+PSAwICYmIHhSIDwgXCIrZStcIiAmJlxcbiAgICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IFwiK24rXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitkK1wiQ1wiKyh2KzIpK1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XFxuICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgIHhSXCIrZCtcIkNcIisodisxKStcIiA9IHhUZXhlbFJcIitkK1wiQ1wiKyh2KzIpK1wiO1xcbiAgICAgICAgICAgICAgICBcIn19ZWxzZSB2PGMmJihmKz1cIlxcbiAgICAgICAgICAgICAgaWYoeFIgPj0gMCAmJiB4UiA8IFwiK2UrXCIpIHtcXG4gICAgICAgICAgICBcIixvJTI9PTE/KGYrPVwiXFxuICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxIC0gXCIraStcIjtcXG4gICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IFwiK24rXCIpIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZCtcIkNcIit2K1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2QrXCJDXCIrditcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmKHhDICsgMSA+PSAwICYmIHhDICsgMSA8IFwiK24rXCIpIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZCtcIkNcIisodisyKStcIiA9IGdldFgoYmF0Y2gsIHhSLCB4QyArIDEsIGQxKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZCtcIkNcIisodisyKStcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHhSXCIrZCtcIkNcIit2K1wiID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZCtcIkNcIit2K1wiLnp3LCB4VGV4ZWxSXCIrZCtcIkNcIisodisyKStcIi56dyk7XFxuICAgICAgICAgICAgICBcIix2KzE8YyYmKGYrPVwiXFxuICAgICAgICAgICAgICAgICAgdmVjNCBmaW5hbCA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxICsgXCIraStcIjtcXG4gICAgICAgICAgICAgICAgICBpZih4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIrbitcIikge1xcbiAgICAgICAgICAgICAgICAgICAgZmluYWwgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgeFJcIitkK1wiQ1wiKyh2KzEpK1wiID0gdmVjNCh4VGV4ZWxSXCIrZCtcIkNcIisodisyKStcIi54eSwgZmluYWwueHkpO1xcbiAgICAgICAgICAgICAgICBcIikpOihmKz1cIlxcbiAgICAgICAgICAgICAgICBpZih4QyA+PSAwICYmIHhDIDwgXCIrbitcIikge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitkK1wiQ1wiK3YrXCIgPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZCtcIkNcIit2K1wiID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIFwiK2krXCI7XFxuICAgICAgICAgICAgICAgIGlmKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIituK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2QrXCJDXCIrKHYrMikrXCIgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZCtcIkNcIisodisyKStcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHhSXCIrZCtcIkNcIit2K1wiID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZCtcIkNcIit2K1wiLnh5LCB4VGV4ZWxSXCIrZCtcIkNcIisodisyKStcIi54eSk7XFxuICAgICAgICAgICAgICBcIix2KzE8YyYmKGYrPVwiXFxuICAgICAgICAgICAgICAgICAgeFJcIitkK1wiQ1wiKyh2KzEpK1wiID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitkK1wiQ1wiK3YrXCIuencsIHhUZXhlbFJcIitkK1wiQ1wiKyh2KzIpK1wiLnp3KTtcXG4gICAgICAgICAgICAgICAgXCIpKSxmKz1cIn1cIik7djxjJiYoZis9XCJcXG4gICAgICAgICAgICB2ZWM0IHdUZXhlbFJcIitkK1wiQ1wiK3YrXCIgPSBnZXRXKFwiK2QrXCIsIFwiK3YrXCIsIGQxLCBxKTtcXG4gICAgICAgICAgICB3UlwiK2QrXCJDXCIrditcIiA9IHZlYzQod1RleGVsUlwiK2QrXCJDXCIrditcIi54eiwgd1RleGVsUlwiK2QrXCJDXCIrditcIi54eik7XFxuICAgICAgICAgIFwiLHYrMTxjJiYoZis9XCJcXG4gICAgICAgICAgICAgIHZlYzQgd1RleGVsUlwiK2QrXCJDXCIrKHYrMSkrXCIgPSBnZXRXKFwiK2QrXCIsIFwiKyh2KzEpK1wiLCBkMSwgcSk7XFxuICAgICAgICAgICAgICB3UlwiK2QrXCJDXCIrKHYrMSkrXCIgPVxcbiAgICAgICAgICAgICAgICB2ZWM0KHdUZXhlbFJcIitkK1wiQ1wiKyh2KzEpK1wiLnh6LCB3VGV4ZWxSXCIrZCtcIkNcIisodisxKStcIi54eik7XCIpKX1mb3IoZD0wO2Q8bDtkKyspZm9yKHY9MDt2PGM7disrKWYrPVwicmVzdWx0ICs9IHhSXCIrZCtcIkNcIit2K1wiICogd1JcIitkK1wiQ1wiK3YrXCI7XCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIithK1wiLCBcIitpK1wiKTtcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIrcitcIiwgXCIrbytcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcblxcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy55eiAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnc7XFxuICAgICAgICBpbnQgZDEgPSBkMjtcXG4gICAgICAgIGludCBxID0gMDtcXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcblxcbiAgICAgICAgXCIrZitcIlxcblxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksUW89ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scixvKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiSW1hZ2VcIixcIkJveGVzXCIsXCJCb3hJbmRcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXTt2YXIgYT10WzBdLGk9dFsxXSxzPXRbMl0sdT10WzNdLGw9ZVswXSxjPW5bMF0saD1uWzFdO3RoaXMub3V0cHV0U2hhcGU9W2wsYyxoLHVdO3ZhciBwPVwiYmlsaW5lYXJcIj09PXI/MTowLGY9W2ktMStcIi4wXCIscy0xK1wiLjBcIl0sZD1mWzBdLHY9ZlsxXSxtPWM+MT9bXCJcIisoaS0xKS8oYy0xKSxcIih5Mi15MSkgKiBoZWlnaHRfcmF0aW9cIixcInkxKlwiK2QrXCIgKyBmbG9hdCh5KSooaGVpZ2h0X3NjYWxlKVwiXTpbXCIwLjBcIixcIjAuMFwiLFwiMC41ICogKHkxK3kyKSAqIFwiK2RdLGc9bVswXSx5PW1bMV0seD1tWzJdLHc9aD4xP1tcIlwiKyhzLTEpLyhoLTEpLFwiKHgyLXgxKSAqIHdpZHRoX3JhdGlvXCIsXCJ4MSpcIit2K1wiICsgZmxvYXQoeCkqKHdpZHRoX3NjYWxlKVwiXTpbXCIwLjBcIixcIjAuMFwiLFwiMC41ICogKHgxK3gyKSAqIFwiK3ZdLGI9d1swXSxDPXdbMV0sRT13WzJdO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBmbG9hdCBoZWlnaHRfcmF0aW8gPSBmbG9hdChcIitnK1wiKTtcXG4gICAgICBjb25zdCBmbG9hdCB3aWR0aF9yYXRpbyA9IGZsb2F0KFwiK2IrXCIpO1xcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgeSA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCB4ID0gY29vcmRzWzJdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuXFxuICAgICAgICAvLyBnZXQgYm94IHZhbHNcXG4gICAgICAgIGZsb2F0IHkxID0gZ2V0Qm94ZXMoYiwwKTtcXG4gICAgICAgIGZsb2F0IHgxID0gZ2V0Qm94ZXMoYiwxKTtcXG4gICAgICAgIGZsb2F0IHkyID0gZ2V0Qm94ZXMoYiwyKTtcXG4gICAgICAgIGZsb2F0IHgyID0gZ2V0Qm94ZXMoYiwzKTtcXG5cXG4gICAgICAgIC8vIGdldCBpbWFnZSBpbiBiYXRjaCBpbmRleFxcbiAgICAgICAgaW50IGJJbmQgPSByb3VuZChnZXRCb3hJbmQoYikpO1xcbiAgICAgICAgaWYoYkluZCA8IDAgfHwgYkluZCA+PSBcIithK1wiKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZsb2F0IGhlaWdodF9zY2FsZSA9IFwiK3krXCI7XFxuICAgICAgICBmbG9hdCB3aWR0aF9zY2FsZSA9IFwiK0MrXCI7XFxuXFxuICAgICAgICBmbG9hdCBpbl95ID0gXCIreCtcIjtcXG4gICAgICAgIGlmKCBpbl95IDwgMC4wIHx8IGluX3kgPiBcIitkK1wiICkge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoXCIrbytcIikpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBmbG9hdCBpbl94ID0gXCIrRStcIjtcXG4gICAgICAgIGlmKCBpbl94IDwgMC4wIHx8IGluX3ggPiBcIit2K1wiICkge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoXCIrbytcIikpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2ZWMyIHNvdXJjZUZyYWNJbmRleENSID0gdmVjMihpbl94LGluX3kpO1xcbiAgICAgICAgaWYoXCIrcCtcIiA9PSAxKSB7XFxuICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGZvdXIgaW50ZWdlciBpbmRpY2VzLlxcbiAgICAgICAgICBpdmVjMiBzb3VyY2VGbG9vckNSID0gaXZlYzIoc291cmNlRnJhY0luZGV4Q1IpO1xcbiAgICAgICAgICBpdmVjMiBzb3VyY2VDZWlsQ1IgPSBpdmVjMihjZWlsKHNvdXJjZUZyYWNJbmRleENSKSk7XFxuXFxuICAgICAgICAgIGZsb2F0IHRvcExlZnQgPSBnZXRJbWFnZShiLCBzb3VyY2VGbG9vckNSLnksIHNvdXJjZUZsb29yQ1IueCwgZCk7XFxuICAgICAgICAgIGZsb2F0IGJvdHRvbUxlZnQgPSBnZXRJbWFnZShiLCBzb3VyY2VDZWlsQ1IueSwgc291cmNlRmxvb3JDUi54LCBkKTtcXG4gICAgICAgICAgZmxvYXQgdG9wUmlnaHQgPSBnZXRJbWFnZShiLCBzb3VyY2VGbG9vckNSLnksIHNvdXJjZUNlaWxDUi54LCBkKTtcXG4gICAgICAgICAgZmxvYXQgYm90dG9tUmlnaHQgPSBnZXRJbWFnZShiLCBzb3VyY2VDZWlsQ1IueSwgc291cmNlQ2VpbENSLngsIGQpO1xcblxcbiAgICAgICAgICB2ZWMyIGZyYWNDUiA9IHNvdXJjZUZyYWNJbmRleENSIC0gdmVjMihzb3VyY2VGbG9vckNSKTtcXG5cXG4gICAgICAgICAgZmxvYXQgdG9wID0gdG9wTGVmdCArICh0b3BSaWdodCAtIHRvcExlZnQpICogZnJhY0NSLng7XFxuICAgICAgICAgIGZsb2F0IGJvdHRvbSA9IGJvdHRvbUxlZnQgKyAoYm90dG9tUmlnaHQgLSBib3R0b21MZWZ0KSAqIGZyYWNDUi54O1xcbiAgICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IHRvcCArIChib3R0b20gLSB0b3ApICogZnJhY0NSLnk7XFxuICAgICAgICAgIHNldE91dHB1dChuZXdWYWx1ZSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb29yZGluYXRvcnMgb2YgbmVhcmVzdCBuZWlnaGJvciBwb2ludC5cXG4gICAgICAgICAgaXZlYzIgc291cmNlTmVhcmVzdENSID0gaXZlYzIoZmxvb3IoXFxuICAgICAgICAgICAgc291cmNlRnJhY0luZGV4Q1IgKyB2ZWMyKDAuNSwwLjUpKSk7XFxuICAgICAgICAgIGZsb2F0IG5ld1ZhbHVlID0gZ2V0SW1hZ2UoYiwgc291cmNlTmVhcmVzdENSLnksIHNvdXJjZU5lYXJlc3RDUi54LCBkKTtcXG4gICAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIFwifX0oKSxKbz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT10O3ZhciByPXQubGVuZ3RoLG89dFt0Lmxlbmd0aC0xXSxhPW4/XCI8XCI6XCI+XCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGludCBnZXRJbmRleChpbnQgaSkge1xcbiAgICAgICAgXCIrKG4/XCJyZXR1cm4gXCIrbytcIiAtaSAtIDE7XCI6XCJyZXR1cm4gaTtcIikrXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrYm8ocikrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgZW5kID0gXCIrWm8ocixcImNvb3Jkc1wiKStcIjtcXG4gICAgICAgIGZsb2F0IHZhbCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IGkgPSBcIitvK1wiIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcXG4gICAgICAgICAgaW50IGlkeCA9IGdldEluZGV4KGkpO1xcbiAgICAgICAgICBpZiAoaWR4IFwiK2ErXCIgZW5kKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKGlkeCA9PSBlbmQgJiYgXCIrZStcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIFwiK1pvKHIsXCJjb29yZHNcIikrXCIgPSBpZHg7XFxuICAgICAgICAgIHZhbCArPSBnZXRYKFwiK2Z1bmN0aW9uKHQsZSl7aWYoMT09PXQpcmV0dXJuXCJcIitlO2lmKDI9PT10KXJldHVybiBlK1wiLngsIFwiK2UrXCIueVwiO2lmKDM9PT10KXJldHVybiBlK1wiLngsIFwiK2UrXCIueSwgXCIrZStcIi56XCI7aWYoND09PXQpcmV0dXJuIGUrXCIueCwgXCIrZStcIi55LCBcIitlK1wiLnosIFwiK2UrXCIud1wiO3Rocm93IEVycm9yKFwiQ3VtdWxhdGl2ZSBzdW0gZm9yIHJhbmsgXCIrdCtcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX0ocixcImNvb3Jkc1wiKStcIik7XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQodmFsKTtcXG4gICAgICB9XFxuICAgIFwifX0oKTtmdW5jdGlvbiBabyh0LGUpe2lmKDE9PT10KXJldHVyblwiXCIrZTtpZigyPT09dClyZXR1cm4gZStcIi55XCI7aWYoMz09PXQpcmV0dXJuIGUrXCIuelwiO2lmKDQ9PT10KXJldHVybiBlK1wiLndcIjt0aHJvdyBFcnJvcihcIkN1bXVsYXRpdmUgc3VtIGZvciByYW5rIFwiK3QrXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIil9dmFyIHRhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy5ibG9ja1NpemU9ZSx0aGlzLmRhdGFGb3JtYXQ9bix0aGlzLnVzZXJDb2RlPVwiXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICBpbnQgaCA9IFwiK3RoaXMuZ2V0SGVpZ2h0Q29vcmRTdHJpbmcoKStcIjtcXG4gICAgICBpbnQgdyA9IFwiK3RoaXMuZ2V0V2lkdGhDb29yZFN0cmluZygpK1wiO1xcbiAgICAgIGludCBkID0gXCIrdGhpcy5nZXREZXB0aENvb3JkU3RyaW5nKCkrXCI7XFxuXFxuICAgICAgaW50IGluX2ggPSBoIC8gXCIrZStcIjtcXG4gICAgICBpbnQgb2Zmc2V0X2ggPSBpbW9kKGgsIFwiK2UrXCIpO1xcbiAgICAgIGludCBpbl93ID0gdyAvIFwiK2UrXCI7XFxuICAgICAgaW50IG9mZnNldF93ID0gaW1vZCh3LCBcIitlK1wiKTtcXG4gICAgICBpbnQgb2Zmc2V0X2QgPSAob2Zmc2V0X2ggKiBcIitlK1wiICsgb2Zmc2V0X3cpICpcXG4gICAgICAgIFwiK3RoaXMuZ2V0T3V0cHV0RGVwdGhTaXplKCkrXCI7XFxuICAgICAgaW50IGluX2QgPSBkICsgb2Zmc2V0X2Q7XFxuXFxuICAgICAgZmxvYXQgcmVzdWx0ID0gXCIrdGhpcy5nZXRJbnB1dFNhbXBsaW5nU3RyaW5nKCkrXCI7XFxuICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgIH1cXG4gIFwifXJldHVybiB0LnByb3RvdHlwZS5nZXRIZWlnaHRDb29yZFN0cmluZz1mdW5jdGlvbigpe3JldHVyblwiTkhXQ1wiPT09dGhpcy5kYXRhRm9ybWF0P1wiY29vcmRzWzFdXCI6XCJjb29yZHNbMl1cIn0sdC5wcm90b3R5cGUuZ2V0V2lkdGhDb29yZFN0cmluZz1mdW5jdGlvbigpe3JldHVyblwiTkhXQ1wiPT09dGhpcy5kYXRhRm9ybWF0P1wiY29vcmRzWzJdXCI6XCJjb29yZHNbM11cIn0sdC5wcm90b3R5cGUuZ2V0RGVwdGhDb29yZFN0cmluZz1mdW5jdGlvbigpe3JldHVyblwiTkhXQ1wiPT09dGhpcy5kYXRhRm9ybWF0P1wiY29vcmRzWzNdXCI6XCJjb29yZHNbMV1cIn0sdC5wcm90b3R5cGUuZ2V0T3V0cHV0RGVwdGhTaXplPWZ1bmN0aW9uKCl7cmV0dXJuXCJOSFdDXCI9PT10aGlzLmRhdGFGb3JtYXQ/dGhpcy5vdXRwdXRTaGFwZVszXTp0aGlzLm91dHB1dFNoYXBlWzFdfSx0LnByb3RvdHlwZS5nZXRJbnB1dFNhbXBsaW5nU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJOSFdDXCI9PT10aGlzLmRhdGFGb3JtYXQ/XCJnZXRYKGIsIGluX2gsIGluX3csIGluX2QpXCI6XCJnZXRYKGIsIGluX2QsIGluX2gsIGluX3cpXCJ9LHR9KCksZWE9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl07dmFyIGU9dW8oKTt0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGZsb2F0IEZMT0FUX01BWCA9IDEuNzAxNDExODRlMzg7XFxuICAgICAgY29uc3QgZmxvYXQgRkxPQVRfTUlOID0gMS4xNzU0OTQzNWUtMzg7XFxuXFxuICAgICAgbG93cCB2ZWM0IGVuY29kZV9mbG9hdChoaWdocCBmbG9hdCB2KSB7XFxuICAgICAgICBpZiAoaXNuYW4odikpIHtcXG4gICAgICAgICAgcmV0dXJuIHZlYzQoMjU1LCAyNTUsIDI1NSwgMjU1KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGhpZ2hwIGZsb2F0IGF2ID0gYWJzKHYpO1xcblxcbiAgICAgICAgaWYoYXYgPCBGTE9BVF9NSU4pIHtcXG4gICAgICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG4gICAgICAgIH0gZWxzZSBpZih2ID4gRkxPQVRfTUFYKSB7XFxuICAgICAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAxMjguMCwgMTI3LjApIC8gMjU1LjA7XFxuICAgICAgICB9IGVsc2UgaWYodiA8IC1GTE9BVF9NQVgpIHtcXG4gICAgICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsICAxMjguMCwgMjU1LjApIC8gMjU1LjA7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBoaWdocCB2ZWM0IGMgPSB2ZWM0KDAsMCwwLDApO1xcblxcbiAgICAgICAgaGlnaHAgZmxvYXQgZSA9IGZsb29yKGxvZzIoYXYpKTtcXG4gICAgICAgIGhpZ2hwIGZsb2F0IG0gPSBleHAyKGZyYWN0KGxvZzIoYXYpKSkgLSAxLjA7XFxuXFxuICAgICAgICBjWzJdID0gZmxvb3IoMTI4LjAgKiBtKTtcXG4gICAgICAgIG0gLT0gY1syXSAvIDEyOC4wO1xcbiAgICAgICAgY1sxXSA9IGZsb29yKDMyNzY4LjAgKiBtKTtcXG4gICAgICAgIG0gLT0gY1sxXSAvIDMyNzY4LjA7XFxuICAgICAgICBjWzBdID0gZmxvb3IoODM4ODYwOC4wICogbSk7XFxuXFxuICAgICAgICBoaWdocCBmbG9hdCBlYmlhcyA9IGUgKyAxMjcuMDtcXG4gICAgICAgIGNbM10gPSBmbG9vcihlYmlhcyAvIDIuMCk7XFxuICAgICAgICBlYmlhcyAtPSBjWzNdICogMi4wO1xcbiAgICAgICAgY1syXSArPSBmbG9vcihlYmlhcykgKiAxMjguMDtcXG5cXG4gICAgICAgIGNbM10gKz0gMTI4LjAgKiBzdGVwKDAuMCwgLXYpO1xcblxcbiAgICAgICAgcmV0dXJuIGMgLyAyNTUuMDtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgeCA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgXCIrZS5vdXRwdXQrXCIgPSBlbmNvZGVfZmxvYXQoeCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksbmE9XCJyZXR1cm4gcmVhbCAqIGV4cFIgLSBpbWFnICogZXhwSTtcIixyYT1cInJldHVybiByZWFsICogZXhwSSArIGltYWcgKiBleHBSO1wiLG9hPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wicmVhbFwiLFwiaW1hZ1wiXTt2YXIgcj1lWzFdO3RoaXMub3V0cHV0U2hhcGU9ZTt2YXIgbz1uP1wiMi4wICogXCIrTWF0aC5QSTpcIi0yLjAgKiBcIitNYXRoLlBJLGE9bj9yK1wiLjBcIjpcIjEuMFwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBmbG9hdCBleHBvbmVudE11bHRpcGxpZXIgPSBcIitvK1wiO1xcblxcbiAgICAgIGZsb2F0IHVuYXJ5T3BDb21wbGV4KGZsb2F0IHJlYWwsIGZsb2F0IGV4cFIsIGZsb2F0IGltYWcsIGZsb2F0IGV4cEkpIHtcXG4gICAgICAgIFwiK3QrXCJcXG4gICAgICB9XFxuXFxuICAgICAgZmxvYXQgbXVsTWF0REZUKGludCBiYXRjaCwgaW50IGluZGV4KSB7XFxuICAgICAgICBmbG9hdCBpbmRleFJhdGlvID0gZmxvYXQoaW5kZXgpIC8gZmxvYXQoXCIrcitcIik7XFxuICAgICAgICBmbG9hdCBleHBvbmVudE11bHRpcGxpZXJUaW1lc0luZGV4UmF0aW8gPVxcbiAgICAgICAgICAgIGV4cG9uZW50TXVsdGlwbGllciAqIGluZGV4UmF0aW87XFxuXFxuICAgICAgICBmbG9hdCByZXN1bHQgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK3IrXCI7IGkrKykge1xcbiAgICAgICAgICAvLyB4ID0gKC0yfDIgKiBQSSAvIE4pICogaW5kZXggKiBpO1xcbiAgICAgICAgICBmbG9hdCB4ID0gZXhwb25lbnRNdWx0aXBsaWVyVGltZXNJbmRleFJhdGlvICogZmxvYXQoaSk7XFxuICAgICAgICAgIGZsb2F0IGV4cFIgPSBjb3MoeCk7XFxuICAgICAgICAgIGZsb2F0IGV4cEkgPSBzaW4oeCk7XFxuICAgICAgICAgIGZsb2F0IHJlYWwgPSBnZXRSZWFsKGJhdGNoLCBpKTtcXG4gICAgICAgICAgZmxvYXQgaW1hZyA9IGdldEltYWcoYmF0Y2gsIGkpO1xcblxcbiAgICAgICAgICByZXN1bHQgKz1cXG4gICAgICAgICAgICAgIHVuYXJ5T3BDb21wbGV4KHJlYWwsIGV4cFIsIGltYWcsIGV4cEkpIC8gXCIrYStcIjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KG11bE1hdERGVChjb29yZHNbMF0sIGNvb3Jkc1sxXSkpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLGFhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3RoaXMub3V0cHV0U2hhcGU9W10sdGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB1bmlmb3JtIGZsb2F0IHZhbHVlO1xcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIC8vIElucHV0IGNhbiBiZSBvYnRhaW5lZCBmcm9tIHVuaWZvcm0gdmFsdWUuXFxuICAgICAgICBzZXRPdXRwdXQodmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiBmdW5jdGlvbihuLHIpe251bGw9PWUudmFsdWVMb2MmJihlLnZhbHVlTG9jPW4uZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyhyLFwidmFsdWVcIikpLG4uZ2wudW5pZm9ybTFmKGUudmFsdWVMb2MsdCl9fSx0fSgpLGlhPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdO3ZhciBlPXVvKCksbj10WzBdLHI9dFsxXTt0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHRleFIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgdGV4QyA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBkZXB0aCA9IGNvb3Jkc1syXTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKFwiK3IrXCIuMCwgXCIrbitcIi4wKTtcXG5cXG4gICAgICAgIHZlYzQgdmFsdWVzID0gXCIrZS50ZXh0dXJlMkQrXCIoQSwgdXYpO1xcbiAgICAgICAgZmxvYXQgdmFsdWU7XFxuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5yO1xcbiAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAxKSB7XFxuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmc7XFxuICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDIpIHtcXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuYjtcXG4gICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMykge1xcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5hO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGZsb29yKHZhbHVlICogMjU1LjAgKyAwLjUpKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxzYT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIixcImluZGljZXNcIl07dmFyIHI9dC5zbGljZSgpO3Jbbl09ZSx0aGlzLm91dHB1dFNoYXBlPXIsdGhpcy5yYW5rPXIubGVuZ3RoO3ZhciBvPWJvKHRoaXMucmFuayksYT1mdW5jdGlvbih0LGUpe3ZhciBuPXQubGVuZ3RoO2lmKG4+NCl0aHJvdyBFcnJvcihcIkdhdGhlciBmb3IgcmFuayBcIituK1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO2lmKDE9PT1uKXJldHVyblwiaW50KGdldEluZGljZXMocmVzUkMpKVwiO2Zvcih2YXIgcj1bXCJyZXNSQy54XCIsXCJyZXNSQy55XCIsXCJyZXNSQy56XCIsXCJyZXNSQy53XCJdLG89W10sYT0wO2E8dC5sZW5ndGg7YSsrKWE9PT1lP28ucHVzaChcImludChnZXRJbmRpY2VzKFwiK3JbYV0rXCIpKVwiKTpvLnB1c2goXCJcIityW2FdKTtyZXR1cm4gby5qb2luKCl9KHQsbik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK28rXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRBKFwiK2ErXCIpKTtcXG4gICAgICB9XFxuICAgIFwifX0oKTt2YXIgdWEsbGEsY2E9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3RoaXMuc2xpY2VEaW09dCx0aGlzLnN0cmlkZXM9ZSx0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiaW5kaWNlc1wiXSx0aGlzLm91dHB1dFNoYXBlPW47dmFyIHI9Ym8oZS5sZW5ndGgpLG89Ym8obi5sZW5ndGgpLGE9dGhpcy5zbGljZURpbT4xP1wic3RyaWRlc1tqXVwiOlwic3RyaWRlc1wiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICAgIFwiK3IrXCIgc3RyaWRlcyA9IFwiK3IrXCIoXCIrdGhpcy5zdHJpZGVzK1wiKTtcXG4gICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIFwiK28rXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGludCBmbGF0dGVuSW5kZXggPSAwO1xcbiAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IFwiK3RoaXMuc2xpY2VEaW0rXCI7IGorKykge1xcbiAgICAgICAgICAgIGludCBpbmRleCA9IHJvdW5kKGdldEluZGljZXMoY29vcmRzWzBdLCBqKSk7XFxuICAgICAgICAgICAgZmxhdHRlbkluZGV4ICs9IGluZGV4ICogXCIrYStcIjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0WChmbGF0dGVuSW5kZXgsIGNvb3Jkc1sxXSkpO1xcbiAgICAgICAgfVxcbiAgICAgIFwifX0oKTtmdW5jdGlvbiBoYSh0LGUpe3JldHVybltlLHRdfWZ1bmN0aW9uIHBhKHQsZSl7cmV0dXJuIHQqZX1mdW5jdGlvbiBmYSh0LGUsbil7dmFyIHI9ZnVuY3Rpb24odCxlKXtpZih0JWUhPTApdGhyb3cgbmV3IEVycm9yKFwidW5wYWNrZWRTaXplIChcIit0K1wiKSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgXCIrZSk7cmV0dXJuIHQvZX0odC5sZW5ndGgsbik7aWYoZS5sZW5ndGg8cil0aHJvdyBuZXcgRXJyb3IoXCJtYXRyaXggbGVuZ3RoIChcIitlLmxlbmd0aCtcIikgbXVzdCBiZSA+PSBcIityKTtmb3IodmFyIG89MCxhPTA7YTx0Lmxlbmd0aDthKz1uKWVbbysrXT10W2FdfWZ1bmN0aW9uIGRhKHQsZSl7cmV0dXJuW01hdGgubWF4KDEsTWF0aC5jZWlsKGUvMikpLE1hdGgubWF4KDEsTWF0aC5jZWlsKHQvMikpXX1mdW5jdGlvbiB2YSh0LGUpe3ZhciBuPWRhKHQsZSk7cmV0dXJuIG5bMF0qblsxXSo0fWZ1bmN0aW9uIG1hKHQsZSxuLHIsbyl7dmFyIGE9bipyO2lmKG8ubGVuZ3RoPGEpdGhyb3cgbmV3IEVycm9yKFwibWF0cml4IGxlbmd0aCAoXCIrby5sZW5ndGgrXCIpIG11c3QgYmUgPj0gXCIrYSk7Zm9yKHZhciBpPXIlMj09MSxzPW4lMj09MSx1PU1hdGguZmxvb3Ioci8yKSxsPU1hdGguZmxvb3Iobi8yKSxjPU1hdGguY2VpbChyLzIpLGg9YypNYXRoLmNlaWwobi8yKSxmPXAobikqcChyKSxkPTA7ZDxlO2QrKyl7Zm9yKHZhciB2PWQqbipyLG09ZCpmLGc9aT80OjAseT1yKyhpPzE6MCkseD1tLHc9dixiPXYrcixDPTA7QzxsOysrQyl7Zm9yKHZhciBFPTA7RTx1OysrRSlvW3crK109dFt4KytdLG9bdysrXT10W3grK10sb1tiKytdPXRbeCsrXSxvW2IrK109dFt4KytdO3grPWcsdys9eSxiKz15fWlmKGkpe3g9bSs0KihjLTEpO3ZhciBSPXYrci0xO2ZvcihnPTQqYyx5PTIqcixDPTA7QzxsOysrQylvW1JdPXRbeF0sb1tSK3JdPXRbeCsyXSx4Kz1nLFIrPXl9aWYocyl7Zm9yKHg9bSs0KihoLWMpLFI9disobi0xKSpyLEU9MDtFPHU7KytFKW9bUisrXT10W3grK10sb1tSKytdPXRbeCsrXSx4Kz0yO2kmJihvW3YrbipyLTFdPXRbeF0pfX1yZXR1cm4gb31mdW5jdGlvbiBnYSh0LGUpe3ZhciBuPXVvKCk7cmV0dXJuIFZ0KHQsZSxuLnZlcnNpb24rXCJcXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgICBcIituLmF0dHJpYnV0ZStcIiB2ZWMzIGNsaXBTcGFjZVBvcztcXG4gICAgXCIrbi5hdHRyaWJ1dGUrXCIgdmVjMiB1djtcXG4gICAgXCIrbi52YXJ5aW5nVnMrXCIgdmVjMiByZXN1bHRVVjtcXG5cXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChjbGlwU3BhY2VQb3MsIDEpO1xcbiAgICAgIHJlc3VsdFVWID0gdXY7XFxuICAgIH1cIil9ZnVuY3Rpb24geWEodCxlKXtyZXR1cm4gWXQodCxlLG5ldyBGbG9hdDMyQXJyYXkoWy0xLDEsMCwwLDEsLTEsLTEsMCwwLDAsMSwxLDAsMSwxLDEsLTEsMCwxLDBdKSl9ZnVuY3Rpb24geGEodCxlKXtyZXR1cm4gUXQodCxlLG5ldyBVaW50MTZBcnJheShbMCwxLDIsMiwxLDNdKSl9ZnVuY3Rpb24gd2EodCxlKXt2YXIgbixyLG8saSxzLHUsbCxjLGg9dDtyZXR1cm4gMj09PWEuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKT8obj1oLlIzMkYscj1oLlIxNkYsbz1oLlJHQkExNkYsaT1oLlJHQkEzMkYscz1oLlJFRCx1PTQsbD0xLGM9aC5IQUxGX0ZMT0FUKToobj10LlJHQkEscj10LlJHQkEsbz10LlJHQkEsaT1oLlJHQkEscz10LlJHQkEsdT00LGw9NCxjPW51bGwhPWU/ZS5IQUxGX0ZMT0FUX09FUzpudWxsKSx7aW50ZXJuYWxGb3JtYXRGbG9hdDpuLGludGVybmFsRm9ybWF0SGFsZkZsb2F0OnIsaW50ZXJuYWxGb3JtYXRQYWNrZWRIYWxmRmxvYXQ6byxpbnRlcm5hbEZvcm1hdFBhY2tlZEZsb2F0OmksdGV4dHVyZUZvcm1hdEZsb2F0OnMsZG93bmxvYWRUZXh0dXJlRm9ybWF0OnQuUkdCQSxkb3dubG9hZFVucGFja051bUNoYW5uZWxzOnUsZGVmYXVsdE51bUNoYW5uZWxzOmwsdGV4dHVyZVR5cGVIYWxmRmxvYXQ6Y319ZnVuY3Rpb24gYmEodCxlLG4scixvLGEsaSl7dGUobixyKTt2YXIgcz1adCh0LGUpLHU9dC5URVhUVVJFXzJEO3JldHVybiBCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kVGV4dHVyZSh1LHMpfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQudGV4UGFyYW1ldGVyaSh1LHQuVEVYVFVSRV9XUkFQX1MsdC5DTEFNUF9UT19FREdFKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LnRleFBhcmFtZXRlcmkodSx0LlRFWFRVUkVfV1JBUF9ULHQuQ0xBTVBfVE9fRURHRSl9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC50ZXhQYXJhbWV0ZXJpKHUsdC5URVhUVVJFX01JTl9GSUxURVIsdC5ORUFSRVNUKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LnRleFBhcmFtZXRlcmkodSx0LlRFWFRVUkVfTUFHX0ZJTFRFUix0Lk5FQVJFU1QpfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQudGV4SW1hZ2UyRCh1LDAsbyxuLHIsMCxhLGksbnVsbCl9KSxCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbnVsbCl9KSxzfWZ1bmN0aW9uIENhKHQsZSxuLHIsbyl7dmFyIGE9aGEobixyKTtyZXR1cm4gYmEodCxlLGFbMF0sYVsxXSxvLmludGVybmFsRm9ybWF0RmxvYXQsby50ZXh0dXJlRm9ybWF0RmxvYXQsdC5GTE9BVCl9ZnVuY3Rpb24gRWEodCxlLG4scixvKXt2YXIgYT1oYShuLHIpO3JldHVybiBiYSh0LGUsYVswXSxhWzFdLG8uaW50ZXJuYWxGb3JtYXRIYWxmRmxvYXQsby50ZXh0dXJlRm9ybWF0RmxvYXQsby50ZXh0dXJlVHlwZUhhbGZGbG9hdCl9ZnVuY3Rpb24gUmEodCxlLG4scixvKXt2YXIgYT1oYShuLHIpO3JldHVybiBiYSh0LGUsYVswXSxhWzFdLHQuUkdCQSx0LlJHQkEsdC5VTlNJR05FRF9CWVRFKX1mdW5jdGlvbiBTYSh0LGUsbixyLG8pe3ZhciBhPWRhKG4scik7cmV0dXJuIGJhKHQsZSxhWzBdLGFbMV0sby5pbnRlcm5hbEZvcm1hdFBhY2tlZEZsb2F0LHQuUkdCQSx0LkZMT0FUKX1mdW5jdGlvbiBOYSh0LGUsbixyLG8pe3ZhciBhPWRhKG4scik7cmV0dXJuIGJhKHQsZSxhWzBdLGFbMV0sby5pbnRlcm5hbEZvcm1hdFBhY2tlZEhhbGZGbG9hdCx0LlJHQkEsby50ZXh0dXJlVHlwZUhhbGZGbG9hdCl9ZnVuY3Rpb24ga2EodCxlLG4scil7cmV0dXJuIEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmJpbmRCdWZmZXIodC5BUlJBWV9CVUZGRVIscil9KSxuZSh0LGUsbixcImNsaXBTcGFjZVBvc1wiLHIsMywyMCwwKSYmbmUodCxlLG4sXCJ1dlwiLHIsMiwyMCwxMil9ZnVuY3Rpb24gSWEodCxlLG4scil7QnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG4pfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQudGV4SW1hZ2UyRCh0LlRFWFRVUkVfMkQsMCx0LlJHQkEsdC5SR0JBLHQuVU5TSUdORURfQllURSxyKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKX0pfWZ1bmN0aW9uIEFhKHQsZSxuLHIsbyxhLGkpe3RlKHIsbyksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG4pfSksQnQodCxlLGZ1bmN0aW9uKCl7cmV0dXJuIHQudGV4U3ViSW1hZ2UyRCh0LlRFWFRVUkVfMkQsMCwwLDAscixvLGksdC5GTE9BVCxhKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKX0pfWZ1bmN0aW9uIFRhKHQsZSxuLHIsbyxhLGkscyl7dmFyIHUsbD1oYShyLG8pLGM9bFswXSxoPWxbMV0scD1yKm87MT09PXMuZGVmYXVsdE51bUNoYW5uZWxzJiZwPT09YS5sZW5ndGg/dT1hOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1wYSh0Lmxlbmd0aCxuKTtpZihlLmxlbmd0aDxyKXRocm93IG5ldyBFcnJvcihcInVucGFja2VkQXJyYXkgbGVuZ3RoIChcIitlLmxlbmd0aCtcIikgbXVzdCBiZSA+PSBcIityKTtmb3IodmFyIG89MCxhPTA7YTx0Lmxlbmd0aDsrK2EpZVtvXT10W2FdLG8rPW59KGEsdT1uZXcgRmxvYXQzMkFycmF5KHAqaSksaSksQWEodCxlLG4sYyxoLHUscy50ZXh0dXJlRm9ybWF0RmxvYXQpfWZ1bmN0aW9uIERhKHQsZSxuLHIsbyxhLGkscyx1LGwpe3ZhciBjPWRhKGkscyksaD1jWzBdLGY9Y1sxXSxkPW5ldyBGbG9hdDMyQXJyYXkodmEoaSxzKSk7IWZ1bmN0aW9uKHQsZSxuLHIsbyl7Zm9yKHZhciBhPXIlMj09MSxpPW4lMj09MSxzPU1hdGguZmxvb3Ioci8yKSx1PU1hdGguZmxvb3Iobi8yKSxsPU1hdGguY2VpbChyLzIpLGM9bCpNYXRoLmNlaWwobi8yKSxoPXAobikqcChyKSxmPTA7ZjxlO2YrKyl7Zm9yKHZhciBkPWYqbipyLHY9ZipoLG09YT80OjAsZz1yLHk9dix4PTA7eDx1OysreCl7Zm9yKHZhciB3PTIqeCpyLGI9MDtiPHM7KytiKXt2YXIgQz1kK3crMipiO29beV09dFtDXSxvW3krMV09dFtDKzFdLG9beSsyXT10W0MrZ10sb1t5KzNdPXRbQytnKzFdLHkrPTR9eSs9bX1pZihhKXtDPWQrci0xLHk9dis0KihsLTEpO3ZhciBFPTIqcjtmb3IobT00KmwseD0wO3g8dTsrK3gpb1t5XT10W0NdLG9beSsyXT10W0Mrcl0sQys9RSx5Kz1tfWlmKGkpe2ZvcihDPWQrKG4tMSkqcix5PXYrNCooYy1sKSxiPTA7YjxzOysrYilvW3krK109dFtDKytdLG9beSsrXT10W0MrK10seSs9MjthJiZpJiYob1t2K2gtNF09dFtDXSl9fX0odSxyLG8sYSxkKSxBYSh0LGUsbixoLGYsZCx0LlJHQkEpfWZ1bmN0aW9uIE9hKHQsZSxuLHIsbyl7dmFyIGE9dC5jcmVhdGVCdWZmZXIoKTtCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kQnVmZmVyKHQuUElYRUxfUEFDS19CVUZGRVIsYSl9KTt2YXIgaT00KnBhKG4qcixvLmRvd25sb2FkVW5wYWNrTnVtQ2hhbm5lbHMpO3JldHVybiBCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5idWZmZXJEYXRhKHQuUElYRUxfUEFDS19CVUZGRVIsaSx0LlNUUkVBTV9SRUFEKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LnJlYWRQaXhlbHMoMCwwLHIsbix0LlJHQkEsdC5GTE9BVCwwKX0pLEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LmJpbmRCdWZmZXIodC5QSVhFTF9QQUNLX0JVRkZFUixudWxsKX0pLGF9ZnVuY3Rpb24gX2EodCxlLG4scixvKXt2YXIgYT10LGk9bmV3IEZsb2F0MzJBcnJheShwYShuKnIsby5kb3dubG9hZFVucGFja051bUNoYW5uZWxzKSk7YS5iaW5kQnVmZmVyKGEuUElYRUxfUEFDS19CVUZGRVIsZSksYS5nZXRCdWZmZXJTdWJEYXRhKGEuUElYRUxfUEFDS19CVUZGRVIsMCxpKSxhLmJpbmRCdWZmZXIoYS5QSVhFTF9QQUNLX0JVRkZFUixudWxsKTt2YXIgcz1uZXcgRmxvYXQzMkFycmF5KG4qcik7cmV0dXJuIGZhKGkscyxvLmRvd25sb2FkVW5wYWNrTnVtQ2hhbm5lbHMpLHN9ZnVuY3Rpb24gTWEodCxlLG4scixvKXt2YXIgYT1oYShuLHIpLGk9YVswXSxzPWFbMV0sdT1uZXcgRmxvYXQzMkFycmF5KHBhKG4qcixvLmRvd25sb2FkVW5wYWNrTnVtQ2hhbm5lbHMpKTtCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5yZWFkUGl4ZWxzKDAsMCxpLHMsby5kb3dubG9hZFRleHR1cmVGb3JtYXQsdC5GTE9BVCx1KX0pO3ZhciBsPW5ldyBGbG9hdDMyQXJyYXkobipyKTtyZXR1cm4gZmEodSxsLG8uZG93bmxvYWRVbnBhY2tOdW1DaGFubmVscyksbH1mdW5jdGlvbiBGYSh0LGUsbixyLG8pe3ZhciBhPWhhKG4sciksaT1hWzBdLHM9YVsxXSx1PW5ldyBVaW50OEFycmF5KHBhKG4qciw0KSk7cmV0dXJuIEJ0KHQsZSxmdW5jdGlvbigpe3JldHVybiB0LnJlYWRQaXhlbHMoMCwwLGkscyxvLmRvd25sb2FkVGV4dHVyZUZvcm1hdCx0LlVOU0lHTkVEX0JZVEUsdSl9KSxuZXcgRmxvYXQzMkFycmF5KHUuYnVmZmVyKX1mdW5jdGlvbiBCYSh0LGUsbixyLG8sYSxpLHMpe3ZhciB1PXQsbD1uZXcgRmxvYXQzMkFycmF5KHZhKGEsaSkpO3UuYmluZEJ1ZmZlcih1LlBJWEVMX1BBQ0tfQlVGRkVSLGUpLHUuZ2V0QnVmZmVyU3ViRGF0YSh1LlBJWEVMX1BBQ0tfQlVGRkVSLDAsbCksdS5iaW5kQnVmZmVyKHUuUElYRUxfUEFDS19CVUZGRVIsbnVsbCk7dmFyIGM9bmV3IEZsb2F0MzJBcnJheSh5KFtuLHIsb10pKTtyZXR1cm4gbWEobCxuLHIsbyxjKSxjfWZ1bmN0aW9uIFBhKHQsZSxuLHIsbyxhLGkscyl7dmFyIHU9ZGEoYSxpKSxsPXVbMF0sYz11WzFdLGg9bmV3IEZsb2F0MzJBcnJheSh2YShhLGkpKTtCdCh0LGUsZnVuY3Rpb24oKXtyZXR1cm4gdC5yZWFkUGl4ZWxzKDAsMCxsLGMsdC5SR0JBLHQuRkxPQVQsaCl9KTt2YXIgcD1uZXcgRmxvYXQzMkFycmF5KHkoW24scixvXSkpO3JldHVybiBtYShoLG4scixvLHApfSFmdW5jdGlvbih0KXt0W3QuUkVOREVSPTBdPVwiUkVOREVSXCIsdFt0LlVQTE9BRD0xXT1cIlVQTE9BRFwiLHRbdC5QSVhFTFM9Ml09XCJQSVhFTFNcIix0W3QuRE9XTkxPQUQ9M109XCJET1dOTE9BRFwifSh1YXx8KHVhPXt9KSksZnVuY3Rpb24odCl7dFt0LlVOUEFDS0VEX0ZMT0FUMTY9MF09XCJVTlBBQ0tFRF9GTE9BVDE2XCIsdFt0LlVOUEFDS0VEX0ZMT0FUMzI9MV09XCJVTlBBQ0tFRF9GTE9BVDMyXCIsdFt0LlBBQ0tFRF80WDFfVU5TSUdORURfQllURT0yXT1cIlBBQ0tFRF80WDFfVU5TSUdORURfQllURVwiLHRbdC5QQUNLRURfMlgyX0ZMT0FUMzI9M109XCJQQUNLRURfMlgyX0ZMT0FUMzJcIix0W3QuUEFDS0VEXzJYMl9GTE9BVDE2PTRdPVwiUEFDS0VEXzJYMl9GTE9BVDE2XCJ9KGxhfHwobGE9e30pKTt2YXIgTGE9T2JqZWN0LmZyZWV6ZSh7Y3JlYXRlVmVydGV4U2hhZGVyOmdhLGNyZWF0ZVZlcnRleEJ1ZmZlcjp5YSxjcmVhdGVJbmRleEJ1ZmZlcjp4YSxnZXRUZXh0dXJlQ29uZmlnOndhLGNyZWF0ZUZsb2F0MzJNYXRyaXhUZXh0dXJlOkNhLGNyZWF0ZUZsb2F0MTZNYXRyaXhUZXh0dXJlOkVhLGNyZWF0ZVVuc2lnbmVkQnl0ZXNNYXRyaXhUZXh0dXJlOlJhLGNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmU6U2EsY3JlYXRlRmxvYXQxNlBhY2tlZE1hdHJpeFRleHR1cmU6TmEsYmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zOmthLHVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZTpJYSx1cGxvYWRNYXRyaXhUb1RleHR1cmU6VGEsdXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlOkRhLGNyZWF0ZUJ1ZmZlckZyb21PdXRwdXRUZXh0dXJlOk9hLGRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21CdWZmZXI6X2EsZG93bmxvYWRGbG9hdDMyTWF0cml4RnJvbU91dHB1dFRleHR1cmU6TWEsZG93bmxvYWRCeXRlRW5jb2RlZEZsb2F0TWF0cml4RnJvbU91dHB1dFRleHR1cmU6RmEsZG93bmxvYWRQYWNrZWRNYXRyaXhGcm9tQnVmZmVyOkJhLGRvd25sb2FkTWF0cml4RnJvbVBhY2tlZE91dHB1dFRleHR1cmU6UGF9KSxXYT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5vdXRwdXRUZXh0dXJlPW51bGwsdGhpcy5wcm9ncmFtPW51bGwsdGhpcy5kaXNwb3NlZD0hMSx0aGlzLnZlcnRleEF0dHJzQXJlQm91bmQ9ITEsdGhpcy5pdGVtc1RvUG9sbD1bXTt2YXIgZT1hLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik7bnVsbCE9dD8odGhpcy5nbD10LGZ1bmN0aW9uKHQsZSl7X3RbdF09ZX0oZSx0KSk6dGhpcy5nbD1GdChlKSwxPT09YS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpPyh0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbj16dCh0aGlzLmdsLHRoaXMuZGVidWcsXCJPRVNfdGV4dHVyZV9mbG9hdFwiKSx0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb249dGhpcy5nbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXRcIiksYS5nZXRCb29sKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRFwiKXx8KHRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbj16dCh0aGlzLmdsLHRoaXMuZGVidWcsXCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCIpLHRoaXMuY29sb3JCdWZmZXJIYWxmRmxvYXRFeHRlbnNpb249dGhpcy5nbC5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXRcIikpKTp0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb249enQodGhpcy5nbCx0aGlzLmRlYnVnLFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKSx0aGlzLnZlcnRleEJ1ZmZlcj15YSh0aGlzLmdsLHRoaXMuZGVidWcpLHRoaXMuaW5kZXhCdWZmZXI9eGEodGhpcy5nbCx0aGlzLmRlYnVnKSx0aGlzLmZyYW1lYnVmZmVyPWVlKHRoaXMuZ2wsdGhpcy5kZWJ1ZyksdGhpcy50ZXh0dXJlQ29uZmlnPXdhKHRoaXMuZ2wsdGhpcy50ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uKX1yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiZGVidWdcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEuZ2V0Qm9vbChcIkRFQlVHXCIpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2lmKCF0aGlzLmRpc3Bvc2VkKXtudWxsIT10aGlzLnByb2dyYW0mJmNvbnNvbGUud2FybihcIkRpc3Bvc2luZyBhIEdQR1BVQ29udGV4dCB0aGF0IHN0aWxsIGhhcyBhIGJvdW5kIFdlYkdMUHJvZ3JhbS4gVGhpcyBpcyBwcm9iYWJseSBhIHJlc291cmNlIGxlYWssIGRlbGV0ZSB0aGUgcHJvZ3JhbSB3aXRoIEdQR1BVQ29udGV4dC5kZWxldGVQcm9ncmFtIGJlZm9yZSBkaXNwb3NpbmcuXCIpLG51bGwhPXRoaXMub3V0cHV0VGV4dHVyZSYmY29uc29sZS53YXJuKFwiRGlzcG9zaW5nIGEgR1BHUFVDb250ZXh0IHRoYXQgc3RpbGwgaGFzIGEgYm91bmQgb3V0cHV0IG1hdHJpeCB0ZXh0dXJlLiAgVGhpcyBpcyBwcm9iYWJseSBhIHJlc291cmNlIGxlYWssIGRlbGV0ZSB0aGUgb3V0cHV0IG1hdHJpeCB0ZXh0dXJlIHdpdGggR1BHUFVDb250ZXh0LmRlbGV0ZU1hdHJpeFRleHR1cmUgYmVmb3JlIGRpc3Bvc2luZy5cIik7dmFyIGU9dGhpcy5nbDtCdChlLHRoaXMuZGVidWcsZnVuY3Rpb24oKXtyZXR1cm4gZS5maW5pc2goKX0pLEJ0KGUsdGhpcy5kZWJ1ZyxmdW5jdGlvbigpe3JldHVybiBlLmJpbmRGcmFtZWJ1ZmZlcihlLkZSQU1FQlVGRkVSLG51bGwpfSksQnQoZSx0aGlzLmRlYnVnLGZ1bmN0aW9uKCl7cmV0dXJuIGUuZGVsZXRlRnJhbWVidWZmZXIodC5mcmFtZWJ1ZmZlcil9KSxCdChlLHRoaXMuZGVidWcsZnVuY3Rpb24oKXtyZXR1cm4gZS5iaW5kQnVmZmVyKGUuQVJSQVlfQlVGRkVSLG51bGwpfSksQnQoZSx0aGlzLmRlYnVnLGZ1bmN0aW9uKCl7cmV0dXJuIGUuYmluZEJ1ZmZlcihlLkVMRU1FTlRfQVJSQVlfQlVGRkVSLG51bGwpfSksQnQoZSx0aGlzLmRlYnVnLGZ1bmN0aW9uKCl7cmV0dXJuIGUuZGVsZXRlQnVmZmVyKHQuaW5kZXhCdWZmZXIpfSksdGhpcy5kaXNwb3NlZD0hMH19LHQucHJvdG90eXBlLmNyZWF0ZUZsb2F0MzJNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksQ2EodGhpcy5nbCx0aGlzLmRlYnVnLHQsZSx0aGlzLnRleHR1cmVDb25maWcpfSx0LnByb3RvdHlwZS5jcmVhdGVGbG9hdDE2TWF0cml4VGV4dHVyZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEVhKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LGUsdGhpcy50ZXh0dXJlQ29uZmlnKX0sdC5wcm90b3R5cGUuY3JlYXRlVW5zaWduZWRCeXRlc01hdHJpeFRleHR1cmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxSYSh0aGlzLmdsLHRoaXMuZGVidWcsdCxlLHRoaXMudGV4dHVyZUNvbmZpZyl9LHQucHJvdG90eXBlLnVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZT1mdW5jdGlvbih0LGUpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksSWEodGhpcy5nbCx0aGlzLmRlYnVnLHQsZSl9LHQucHJvdG90eXBlLmNyZWF0ZUZsb2F0MTZQYWNrZWRNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksTmEodGhpcy5nbCx0aGlzLmRlYnVnLHQsZSx0aGlzLnRleHR1cmVDb25maWcpfSx0LnByb3RvdHlwZS5jcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksU2EodGhpcy5nbCx0aGlzLmRlYnVnLHQsZSx0aGlzLnRleHR1cmVDb25maWcpfSx0LnByb3RvdHlwZS5kZWxldGVNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLm91dHB1dFRleHR1cmU9PT10JiYodWUodGhpcy5nbCx0aGlzLmRlYnVnLHRoaXMuZnJhbWVidWZmZXIpLHRoaXMub3V0cHV0VGV4dHVyZT1udWxsKSxCdCh0aGlzLmdsLHRoaXMuZGVidWcsZnVuY3Rpb24oKXtyZXR1cm4gZS5nbC5kZWxldGVUZXh0dXJlKHQpfSl9LHQucHJvdG90eXBlLnVwbG9hZE1hdHJpeFRvVGV4dHVyZT1mdW5jdGlvbih0LGUsbixyKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpO3ZhciBvPUp0KCk7cmV0dXJuIFRhKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LGUsbixyLG8sdGhpcy50ZXh0dXJlQ29uZmlnKX0sdC5wcm90b3R5cGUudXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLERhKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LGUsbixyLG8sYSxpLHRoaXMudGV4dHVyZUNvbmZpZyl9LHQucHJvdG90eXBlLmRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21PdXRwdXRUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzO3JldHVybiB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyKHQsZnVuY3Rpb24oKXtyZXR1cm4gTWEoci5nbCxyLmRlYnVnLGUsbixyLnRleHR1cmVDb25maWcpfSl9LHQucHJvdG90eXBlLmRvd25sb2FkQnl0ZUVuY29kZWRGbG9hdE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzO3JldHVybiB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyKHQsZnVuY3Rpb24oKXtyZXR1cm4gRmEoci5nbCxyLmRlYnVnLGUsbixyLnRleHR1cmVDb25maWcpfSl9LHQucHJvdG90eXBlLmRvd25sb2FkUGFja2VkTWF0cml4RnJvbUJ1ZmZlcj1mdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIEJhKHRoaXMuZ2wsdCxlLG4scixvLGEsdGhpcy50ZXh0dXJlQ29uZmlnKX0sdC5wcm90b3R5cGUuZG93bmxvYWRGbG9hdDMyTWF0cml4RnJvbUJ1ZmZlcj1mdW5jdGlvbih0LGUsbil7cmV0dXJuIF9hKHRoaXMuZ2wsdCxlLG4sdGhpcy50ZXh0dXJlQ29uZmlnKX0sdC5wcm90b3R5cGUuY3JlYXRlQnVmZmVyRnJvbVRleHR1cmU9ZnVuY3Rpb24odCxlLG4pe3RoaXMuYmluZFRleHR1cmVUb0ZyYW1lQnVmZmVyKHQpO3ZhciByPU9hKHRoaXMuZ2wsdGhpcy5kZWJ1ZyxlLG4sdGhpcy50ZXh0dXJlQ29uZmlnKTtyZXR1cm4gdGhpcy51bmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcigpLHJ9LHQucHJvdG90eXBlLmNyZWF0ZUFuZFdhaXRGb3JGZW5jZT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuY3JlYXRlRmVuY2UodGhpcy5nbCk7cmV0dXJuIHRoaXMucG9sbEZlbmNlKHQpfSx0LnByb3RvdHlwZS5jcmVhdGVGZW5jZT1mdW5jdGlvbih0KXt2YXIgZSxuLHI9dGhpcztpZihhLmdldEJvb2woXCJXRUJHTF9GRU5DRV9BUElfRU5BQkxFRFwiKSl7dmFyIG89dCxpPW8uZmVuY2VTeW5jKG8uU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUsMCk7dC5mbHVzaCgpLG49ZnVuY3Rpb24oKXt2YXIgdD1vLmNsaWVudFdhaXRTeW5jKGksMCwwKTtyZXR1cm4gdD09PW8uQUxSRUFEWV9TSUdOQUxFRHx8dD09PW8uQ09ORElUSU9OX1NBVElTRklFRH0sZT1pfWVsc2UgYS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT4wPyhlPXRoaXMuYmVnaW5RdWVyeSgpLHRoaXMuZW5kUXVlcnkoKSxuPWZ1bmN0aW9uKCl7cmV0dXJuIHIuaXNRdWVyeUF2YWlsYWJsZShlLGEuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIikpfSk6bj1mdW5jdGlvbigpe3JldHVybiEwfTtyZXR1cm57cXVlcnk6ZSxpc0ZlbmNlUGFzc2VkOm59fSx0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeEZyb21QYWNrZWRUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2YXIgaT10aGlzO3JldHVybiB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyKHQsZnVuY3Rpb24oKXtyZXR1cm4gUGEoaS5nbCxpLmRlYnVnLGUsbixyLG8sYSxpLnRleHR1cmVDb25maWcpfSl9LHQucHJvdG90eXBlLmNyZWF0ZVByb2dyYW09ZnVuY3Rpb24odCl7dGhpcy50aHJvd0lmRGlzcG9zZWQoKTt2YXIgZT10aGlzLmdsLG49R3QoZSx0aGlzLmRlYnVnLHQpLHI9Z2EoZSx0aGlzLmRlYnVnKSxvPWp0KGUsdGhpcy5kZWJ1Zyk7cmV0dXJuIEJ0KGUsdGhpcy5kZWJ1ZyxmdW5jdGlvbigpe3JldHVybiBlLmF0dGFjaFNoYWRlcihvLHIpfSksQnQoZSx0aGlzLmRlYnVnLGZ1bmN0aW9uKCl7cmV0dXJuIGUuYXR0YWNoU2hhZGVyKG8sbil9KSxLdChlLHRoaXMuZGVidWcsbyksdGhpcy5kZWJ1ZyYmWHQoZSx0aGlzLmRlYnVnLG8pLHRoaXMudmVydGV4QXR0cnNBcmVCb3VuZHx8KHRoaXMuc2V0UHJvZ3JhbShvKSx0aGlzLnZlcnRleEF0dHJzQXJlQm91bmQ9a2EoZSx0aGlzLmRlYnVnLHRoaXMucHJvZ3JhbSx0aGlzLnZlcnRleEJ1ZmZlcikpLG99LHQucHJvdG90eXBlLmRlbGV0ZVByb2dyYW09ZnVuY3Rpb24odCl7dmFyIGU9dGhpczt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHQ9PT10aGlzLnByb2dyYW0mJih0aGlzLnByb2dyYW09bnVsbCksbnVsbCE9dCYmQnQodGhpcy5nbCx0aGlzLmRlYnVnLGZ1bmN0aW9uKCl7cmV0dXJuIGUuZ2wuZGVsZXRlUHJvZ3JhbSh0KX0pfSx0LnByb3RvdHlwZS5zZXRQcm9ncmFtPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnByb2dyYW09dCxudWxsIT10aGlzLnByb2dyYW0mJnRoaXMuZGVidWcmJlh0KHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0aGlzLnByb2dyYW0pLEJ0KHRoaXMuZ2wsdGhpcy5kZWJ1ZyxmdW5jdGlvbigpe3JldHVybiBlLmdsLnVzZVByb2dyYW0odCl9KX0sdC5wcm90b3R5cGUuZ2V0VW5pZm9ybUxvY2F0aW9uPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49ITApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksbj9vZSh0aGlzLmdsLHRoaXMuZGVidWcsdCxlKTphZSh0aGlzLmdsLHQsZSl9LHQucHJvdG90eXBlLmdldEF0dHJpYnV0ZUxvY2F0aW9uPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcztyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxCdCh0aGlzLmdsLHRoaXMuZGVidWcsZnVuY3Rpb24oKXtyZXR1cm4gbi5nbC5nZXRBdHRyaWJMb2NhdGlvbih0LGUpfSl9LHQucHJvdG90eXBlLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3c9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0LGUpfSx0LnByb3RvdHlwZS5zZXRJbnB1dE1hdHJpeFRleHR1cmU9ZnVuY3Rpb24odCxlLG4pe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy50aHJvd0lmTm9Qcm9ncmFtKCksaWUodGhpcy5nbCx0aGlzLmRlYnVnLHRoaXMucHJvZ3JhbSx0LGUsbil9LHQucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFRleHR1cmU9ZnVuY3Rpb24odCxlLG4pe3RoaXMuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlcih0LG4sZSl9LHQucHJvdG90eXBlLnNldE91dHB1dFBhY2tlZE1hdHJpeFRleHR1cmU9ZnVuY3Rpb24odCxlLG4pe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCk7dmFyIHI9ZGEoZSxuKSxvPXJbMF0sYT1yWzFdO3RoaXMuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlcih0LG8sYSl9LHQucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMuc2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb25Ecml2ZXIobix0LHIsZSl9LHQucHJvdG90eXBlLnNldE91dHB1dFBhY2tlZE1hdHJpeFdyaXRlUmVnaW9uPWZ1bmN0aW9uKHQsZSxuLHIpe3Rocm93IG5ldyBFcnJvcihcInNldE91dHB1dFBhY2tlZE1hdHJpeFdyaXRlUmVnaW9uIG5vdCBpbXBsZW1lbnRlZC5cIil9LHQucHJvdG90eXBlLmRlYnVnVmFsaWRhdGU9ZnVuY3Rpb24oKXtudWxsIT10aGlzLnByb2dyYW0mJlh0KHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0aGlzLnByb2dyYW0pLGxlKHRoaXMuZ2wpfSx0LnByb3RvdHlwZS5leGVjdXRlUHJvZ3JhbT1mdW5jdGlvbigpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy50aHJvd0lmTm9Qcm9ncmFtKCk7dmFyIHQ9dGhpcy5nbDt0aGlzLmRlYnVnJiZ0aGlzLmRlYnVnVmFsaWRhdGUoKSxCdCh0LHRoaXMuZGVidWcsZnVuY3Rpb24oKXtyZXR1cm4gdC5kcmF3RWxlbWVudHModC5UUklBTkdMRVMsNix0LlVOU0lHTkVEX1NIT1JULDApfSl9LHQucHJvdG90eXBlLmJsb2NrVW50aWxBbGxQcm9ncmFtc0NvbXBsZXRlZD1mdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSxCdCh0aGlzLmdsLHRoaXMuZGVidWcsZnVuY3Rpb24oKXtyZXR1cm4gdC5nbC5maW5pc2goKX0pfSx0LnByb3RvdHlwZS5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PXRoaXMuZGlzam9pbnRRdWVyeVRpbWVyRXh0ZW5zaW9uJiYodGhpcy5kaXNqb2ludFF1ZXJ5VGltZXJFeHRlbnNpb249enQodGhpcy5nbCx0aGlzLmRlYnVnLDI9PT1hLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpP1wiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMlwiOlwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5XCIpKSx0aGlzLmRpc2pvaW50UXVlcnlUaW1lckV4dGVuc2lvbn0sdC5wcm90b3R5cGUuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb24oKX0sdC5wcm90b3R5cGUuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb24oKX0sdC5wcm90b3R5cGUuYmVnaW5RdWVyeT1mdW5jdGlvbigpe2lmKDI9PT1hLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpKXt2YXIgdD10aGlzLmdsLGU9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wyKCksbj10LmNyZWF0ZVF1ZXJ5KCk7cmV0dXJuIHQuYmVnaW5RdWVyeShlLlRJTUVfRUxBUFNFRF9FWFQsbiksbn12YXIgcj10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEoKSxvPXIuY3JlYXRlUXVlcnlFWFQoKTtyZXR1cm4gci5iZWdpblF1ZXJ5RVhUKHIuVElNRV9FTEFQU0VEX0VYVCxvKSxvfSx0LnByb3RvdHlwZS5lbmRRdWVyeT1mdW5jdGlvbigpe2lmKDIhPT1hLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpKXt2YXIgdD10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEoKTt0LmVuZFF1ZXJ5RVhUKHQuVElNRV9FTEFQU0VEX0VYVCl9ZWxzZXt2YXIgZT10aGlzLmdsLG49dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wyKCk7ZS5lbmRRdWVyeShuLlRJTUVfRUxBUFNFRF9FWFQpfX0sdC5wcm90b3R5cGUud2FpdEZvclF1ZXJ5QW5kR2V0VGltZT1mdW5jdGlvbih0KXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxSKGZ1bmN0aW9uKCl7cmV0dXJuIGUuZGlzcG9zZWR8fGUuaXNRdWVyeUF2YWlsYWJsZSh0LGEuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIikpfSldO2Nhc2UgMTpyZXR1cm4gbi5zZW50KCksWzIsdGhpcy5nZXRRdWVyeVRpbWUodCxhLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpKV19fSl9KX0sdC5wcm90b3R5cGUuZ2V0UXVlcnlUaW1lPWZ1bmN0aW9uKHQsZSl7aWYoMD09PWUpcmV0dXJuIG51bGw7aWYoMj09PWUpe3ZhciBuPXRoaXMuZ2w7cmV0dXJuIG4uZ2V0UXVlcnlQYXJhbWV0ZXIodCxuLlFVRVJZX1JFU1VMVCkvMWU2fXZhciByPXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpO3JldHVybiByLmdldFF1ZXJ5T2JqZWN0RVhUKHQsci5RVUVSWV9SRVNVTFRfRVhUKS8xZTZ9LHQucHJvdG90eXBlLmlzUXVlcnlBdmFpbGFibGU9ZnVuY3Rpb24odCxlKXtpZigwPT09ZSlyZXR1cm4hMDtpZigyPT09ZSl7dmFyIG49dGhpcy5nbCxyPXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMigpLG89bi5nZXRRdWVyeVBhcmFtZXRlcih0LG4uUVVFUllfUkVTVUxUX0FWQUlMQUJMRSk7cmV0dXJuIG51bGw9PXRoaXMuZGlzam9pbnQmJih0aGlzLmRpc2pvaW50PXRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHIuR1BVX0RJU0pPSU5UX0VYVCkpLG8mJiF0aGlzLmRpc2pvaW50fW89KHI9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxKCkpLmdldFF1ZXJ5T2JqZWN0RVhUKHQsci5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFX0VYVCk7cmV0dXJuIG51bGw9PXRoaXMuZGlzam9pbnQmJih0aGlzLmRpc2pvaW50PXRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHIuR1BVX0RJU0pPSU5UX0VYVCkpLG8mJiF0aGlzLmRpc2pvaW50fSx0LnByb3RvdHlwZS5wb2xsRmVuY2U9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24obil7ZS5hZGRJdGVtVG9Qb2xsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuaXNGZW5jZVBhc3NlZCgpfSxmdW5jdGlvbigpe3JldHVybiBuKCl9KX0pfSx0LnByb3RvdHlwZS5wb2xsSXRlbXM9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDsrK2Upe3ZhciBuPXRbZV0oKTtpZighbilicmVha31yZXR1cm4gZS0xfSh0aGlzLml0ZW1zVG9Qb2xsLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5pc0RvbmVGbn0pKSxlPTA7ZTw9dDsrK2UpeygwLHRoaXMuaXRlbXNUb1BvbGxbZV0ucmVzb2x2ZUZuKSgpfXRoaXMuaXRlbXNUb1BvbGw9dGhpcy5pdGVtc1RvUG9sbC5zbGljZSh0KzEpfSx0LnByb3RvdHlwZS5hZGRJdGVtVG9Qb2xsPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpczt0aGlzLml0ZW1zVG9Qb2xsLnB1c2goe2lzRG9uZUZuOnQscmVzb2x2ZUZuOmV9KSx0aGlzLml0ZW1zVG9Qb2xsLmxlbmd0aD4xfHxSKGZ1bmN0aW9uKCl7cmV0dXJuIG4ucG9sbEl0ZW1zKCksMD09PW4uaXRlbXNUb1BvbGwubGVuZ3RofSl9LHQucHJvdG90eXBlLmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcj1mdW5jdGlvbih0KXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHNlKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LHRoaXMuZnJhbWVidWZmZXIpLHRoaXMuZGVidWcmJmxlKHRoaXMuZ2wpfSx0LnByb3RvdHlwZS51bmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcj1mdW5jdGlvbigpe251bGwhPXRoaXMub3V0cHV0VGV4dHVyZT8oc2UodGhpcy5nbCx0aGlzLmRlYnVnLHRoaXMub3V0cHV0VGV4dHVyZSx0aGlzLmZyYW1lYnVmZmVyKSx0aGlzLmRlYnVnJiZsZSh0aGlzLmdsKSk6dWUodGhpcy5nbCx0aGlzLmRlYnVnLHRoaXMuZnJhbWVidWZmZXIpfSx0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeERyaXZlcj1mdW5jdGlvbih0LGUpe3RoaXMuYmluZFRleHR1cmVUb0ZyYW1lQnVmZmVyKHQpO3ZhciBuPWUoKTtyZXR1cm4gdGhpcy51bmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcigpLG59LHQucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXI9ZnVuY3Rpb24odCxlLG4pe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCk7dmFyIHI9dGhpcy5nbDtzZShyLHRoaXMuZGVidWcsdCx0aGlzLmZyYW1lYnVmZmVyKSx0aGlzLmRlYnVnJiZsZShyKSx0aGlzLm91dHB1dFRleHR1cmU9dCxCdChyLHRoaXMuZGVidWcsZnVuY3Rpb24oKXtyZXR1cm4gci52aWV3cG9ydCgwLDAsZSxuKX0pLEJ0KHIsdGhpcy5kZWJ1ZyxmdW5jdGlvbigpe3JldHVybiByLnNjaXNzb3IoMCwwLGUsbil9KX0sdC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb25Ecml2ZXI9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89dGhpczt0aGlzLnRocm93SWZEaXNwb3NlZCgpLEJ0KHRoaXMuZ2wsdGhpcy5kZWJ1ZyxmdW5jdGlvbigpe3JldHVybiBvLmdsLnNjaXNzb3IodCxlLG4scil9KX0sdC5wcm90b3R5cGUudGhyb3dJZkRpc3Bvc2VkPWZ1bmN0aW9uKCl7aWYodGhpcy5kaXNwb3NlZCl0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gdXNlIGRpc3Bvc2VkIEdQR1BVQ29udGV4dC5cIil9LHQucHJvdG90eXBlLnRocm93SWZOb1Byb2dyYW09ZnVuY3Rpb24oKXtpZihudWxsPT10aGlzLnByb2dyYW0pdGhyb3cgbmV3IEVycm9yKFwiTm8gR1BVIHByb2dyYW0gaXMgY3VycmVudGx5IHNldC5cIil9LHR9KCk7ZnVuY3Rpb24gVWEodCxlKXtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IEVycm9yKFwiQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoIFwiK3QubGVuZ3RoK1wiIGlucHV0cywgYnV0IHdhcyBleGVjdXRlZCB3aXRoIFwiK2UubGVuZ3RoK1wiIGlucHV0c1wiKTt0LmZvckVhY2goZnVuY3Rpb24odCxuKXt2YXIgcj10LmxvZ2ljYWxTaGFwZSxvPWVbbl0sYT1vLnNoYXBlO2lmKCF4KHIsYSkpdGhyb3cgRXJyb3IoXCJCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggZGlmZmVyZW50IHNoYXBlcyB0aGFuIHRoZSBjdXJyZW50IGFyZ3MuIFNoYXBlcyBcIityK1wiIGFuZCBcIithK1wiIG11c3QgbWF0Y2hcIik7aWYoIXQuaXNVbmlmb3JtfHwhby5pc1VuaWZvcm0pe3ZhciBpPXQudGV4U2hhcGUscz1vLmlzVW5pZm9ybT9udWxsOm8udGV4RGF0YS50ZXhTaGFwZTtpZigheChpLHMpKXRocm93IEVycm9yKFwiQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoIGRpZmZlcmVudCB0ZXh0dXJlIHNoYXBlcyB0aGFuIHRoZSBjdXJyZW50IGFyZ3MuIFNoYXBlIFwiK2krXCIgYW5kIFwiK3MrXCIgbXVzdCBtYXRjaFwiKX19KX12YXIgemE9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwLHRoaXMub3V0cHV0U2hhcGU9dDt2YXIgcj1uLmZpbHRlcldpZHRoLG89bi5pbkNoYW5uZWxzLGE9bi5zdHJpZGVXaWR0aCxpPW4uc3RyaWRlSGVpZ2h0LHM9bi5wYWRJbmZvLHU9bi5vdXRXaWR0aCxsPW4uZGlsYXRpb25XaWR0aCxjPW4uZGlsYXRpb25IZWlnaHQsaD1zLmxlZnQscD1zLnRvcCxmPW8qcixkPXVvKCk7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMCk7XFxuXFxuICAgICAgICBmb3IoaW50IHJvdz0wOyByb3c8PTE7IHJvdysrKSB7XFxuICAgICAgICAgIGZvcihpbnQgY29sPTA7IGNvbDw9MTsgY29sKyspIHtcXG4gICAgICAgICAgICBpbnQgYmxvY2tJbmRleCA9IHJjLnkgKyBjb2w7XFxuICAgICAgICAgICAgaW50IHBvcyA9IHJjLnggKyByb3c7XFxuXFxuICAgICAgICAgICAgaWYoYmxvY2tJbmRleCA+PSBcIit0WzFdK1wiIHx8IHBvcyA+PSBcIit0WzBdK1wiKSBjb250aW51ZTtcXG5cXG4gICAgICAgICAgICBpbnQgb2Zmc2V0WSA9IGludChibG9ja0luZGV4IC8gKFwiK3UrXCIpKSAqIFwiK2krXCIgLSBcIitwK1wiO1xcbiAgICAgICAgICAgIGludCBkMCA9IG9mZnNldFkgKyBcIitjK1wiICogKHBvcyAvIFwiK2YrXCIpO1xcblxcbiAgICAgICAgICAgIGlmKGQwID49IFwiK2VbMF0rXCIgfHwgZDAgPCAwKSBjb250aW51ZTtcXG5cXG4gICAgICAgICAgICBpbnQgb2Zmc2V0WCA9IGludChtb2QoZmxvYXQoYmxvY2tJbmRleCksIFwiK3UrXCIuKSAqIFwiK2ErXCIuIC0gXCIraCtcIi4pO1xcbiAgICAgICAgICAgIGludCBkMSA9IG9mZnNldFggKyBcIitsK1wiICogKGludChtb2QoZmxvYXQocG9zKSwgXCIrZitcIi4pIC8gXCIrbytcIi4pKTtcXG5cXG4gICAgICAgICAgICBpZihkMSA+PSBcIitlWzFdK1wiIHx8IGQxIDwgMCkgY29udGludWU7XFxuXFxuICAgICAgICAgICAgdmVjMiBpbm5lckRpbXMgPSB2ZWMyKGQxLCBpbnQobW9kKGZsb2F0KHBvcyksIFwiK28rXCIuKSkpO1xcbiAgICAgICAgICAgIHJlc3VsdFtyb3cgKiAyICsgY29sXSA9IGdldENoYW5uZWwoZ2V0QShkMCwgaW50KGlubmVyRGltcy54KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50KGlubmVyRGltcy55KSksIGlubmVyRGltcyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIFwiK2Qub3V0cHV0K1wiID0gcmVzdWx0O1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLFZhPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIsbyl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXTt2YXIgYSxpPWUscz10WzNdLTE7dGhpcy5vdXRwdXRTaGFwZT10O3ZhciB1PVwiZmxvYXQoXCIrbitcIikgKyBmbG9hdChcIityK1wiKSAqIHN1bVwiO2E9LjU9PT1vP1wiaW52ZXJzZXNxcnQoXCIrdStcIilcIjoxPT09bz9cIjEuMC8oXCIrdStcIilcIjpcImV4cChsb2coXCIrdStcIikgKiBmbG9hdCgtXCIrbytcIikpO1wiLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IHIgPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgYyA9IGNvb3Jkc1syXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcbiAgICAgICAgZmxvYXQgeCA9IGdldFgoYiwgciwgYywgZCk7XFxuICAgICAgICBmbG9hdCBzdW0gPSAwLjA7XFxuICAgICAgICBmb3IgKGludCBqID0gLVwiK2krXCI7IGogPD0gXCIraStcIjsgaisrKSB7XFxuICAgICAgICAgIGludCBpZHggPSBkICsgajtcXG4gICAgICAgICAgaWYgKGlkeCA+PSAwICYmIGlkeCA8PSAgXCIrcytcIikge1xcbiAgICAgICAgICAgIGZsb2F0IHogPSBnZXRYKGIsIHIsIGMsIGlkeCk7XFxuICAgICAgICAgICAgc3VtICs9IHogKiB6O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBmbG9hdCB2YWwgPSB4ICogXCIrYStcIjtcXG4gICAgICAgIHNldE91dHB1dCh2YWwpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLEdhPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIsbyl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImlucHV0SW1hZ2VcIixcIm91dHB1dEltYWdlXCIsXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLmRlcHRoPXRbM10sdGhpcy5kZXB0aFJhZGl1cz1lLHRoaXMuYmlhcz1uLHRoaXMuYWxwaGE9cix0aGlzLmJldGE9byx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XFxuXFxuICAgICAgICBmbG9hdCByZXN1bHQgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCBkID0gMDsgZCA8IFwiK3RoaXMuZGVwdGgrXCI7ICsrZCkge1xcbiAgICAgICAgICBpbnQgZGVwdGhCZWdpbiA9IGludChtYXgoMC4wLCBmbG9hdChkIC0gXCIrZStcIikpKTtcXG4gICAgICAgICAgaW50IGRlcHRoRW5kID0gaW50KG1pbihmbG9hdChcIit0aGlzLmRlcHRoK1wiKSxcXG4gICAgICAgICAgICAgIGZsb2F0KGQgKyBcIitlK1wiICsgMSkpKTtcXG5cXG4gICAgICAgICAgY29uc3QgaW50IE1JTl9ERVBUSF9CRUdJTiA9IDA7XFxuICAgICAgICAgIGNvbnN0IGludCBNQVhfREVQVEhfRU5EID0gXCIrdGhpcy5kZXB0aCtcIjtcXG5cXG4gICAgICAgICAgZmxvYXQgbm9ybSA9IDAuMDtcXG4gICAgICAgICAgZm9yIChpbnQgayA9IE1JTl9ERVBUSF9CRUdJTjsgayA8IE1BWF9ERVBUSF9FTkQ7ICsraykge1xcbiAgICAgICAgICAgIGlmIChrIDwgZGVwdGhCZWdpbil7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSBpZiAoayA+PSBkZXB0aEJlZ2luICYmIGsgPCBkZXB0aEVuZCkge1xcbiAgICAgICAgICAgICAgbm9ybSArPSBnZXRJbnB1dEltYWdlKGIsIHIsIGMsIGspICogZ2V0SW5wdXRJbWFnZShiLCByLCBjLCBrKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbm9ybSA9IGZsb2F0KFwiK3IrXCIpICogbm9ybSArIGZsb2F0KFwiK24rXCIpO1xcblxcbiAgICAgICAgICBmb3IoaW50IGsgPSBNSU5fREVQVEhfQkVHSU47IGsgPCBNQVhfREVQVEhfRU5EOyArK2spe1xcbiAgICAgICAgICAgIGlmIChrIDwgZGVwdGhCZWdpbil7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSBpZiAoayA+PSBkZXB0aEJlZ2luICYmIGsgPCBkZXB0aEVuZCl7XFxuICAgICAgICAgICAgICBmbG9hdCBkeWkgPSAtMi4wICogZmxvYXQoXCIrcitcIilcXG4gICAgICAgICAgICAgICAgKiBmbG9hdChcIitvK1wiKVxcbiAgICAgICAgICAgICAgICAqIGdldElucHV0SW1hZ2UoYiAsciAsYywgaykgKiBnZXRPdXRwdXRJbWFnZShiLCByLCBjLCBkKVxcbiAgICAgICAgICAgICAgICAvIG5vcm07XFxuICAgICAgICAgICAgICBpZiAoayA9PSBkKSB7XFxuICAgICAgICAgICAgICAgIGR5aSArPSBwb3cobm9ybSwgLTEuMCAqIFwiK28rXCIpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgaWYgKGsgPT0gY29vcmRzWzNdKSB7XFxuICAgICAgICAgICAgICAgIGR5aSAqPSBnZXREeShiLCByLCBjLCBkKTtcXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGR5aTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn19KCkscWE9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scixvKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwO3ZhciBhLGk9ZSxzPXRbM10tMTt0aGlzLm91dHB1dFNoYXBlPXQ7dmFyIHU9XCJmbG9hdChcIituK1wiKSArIGZsb2F0KFwiK3IrXCIpICogc3VtXCI7YT0uNT09PW8/XCJpbnZlcnNlc3FydChcIit1K1wiKVwiOjE9PT1vP1wiMS4wLyhcIit1K1wiKVwiOlwiZXhwKGxvZyhcIit1K1wiKSAqIGZsb2F0KC1cIitvK1wiKSk7XCIsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHMueDtcXG4gICAgICAgIGludCByID0gY29vcmRzLnk7XFxuICAgICAgICBpbnQgYyA9IGNvb3Jkcy56O1xcbiAgICAgICAgaW50IGQgPSBjb29yZHMudztcXG5cXG4gICAgICAgIGJvb2wgaGFzTmV4dENvbCA9IGQgPCBcIit0aGlzLm91dHB1dFNoYXBlWzNdK1wiO1xcbiAgICAgICAgYm9vbCBoYXNOZXh0Um93ID0gYyA8IFwiK3RoaXMub3V0cHV0U2hhcGVbMl0rXCI7XFxuXFxuICAgICAgICB2ZWM0IHN1bSA9IHZlYzQoMC4pO1xcbiAgICAgICAgdmVjNCB4RnJhZ0F0T3V0cHV0Q29vcmRzID0gZ2V0WChiLCByLCBjLCBkKTtcXG5cXG4gICAgICAgIHZlYzQgeEF0T3V0cHV0Q29vcmRzID0gdmVjNChcXG4gICAgICAgICAgZ2V0Q2hhbm5lbCh4RnJhZ0F0T3V0cHV0Q29vcmRzLCB2ZWMyKGMsIGQpKSxcXG4gICAgICAgICAgaGFzTmV4dENvbCA/XFxuICAgICAgICAgICAgZ2V0Q2hhbm5lbCh4RnJhZ0F0T3V0cHV0Q29vcmRzLCB2ZWMyKGMsIGQgKyAxKSkgOiAwLjAsXFxuICAgICAgICAgIGhhc05leHRSb3cgP1xcbiAgICAgICAgICAgIGdldENoYW5uZWwoeEZyYWdBdE91dHB1dENvb3JkcyAsIHZlYzIoYyArIDEsIGQpKSA6IDAuMCxcXG4gICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgP1xcbiAgICAgICAgICAgIGdldENoYW5uZWwoeEZyYWdBdE91dHB1dENvb3JkcywgdmVjMihjICsgMSwgZCArIDEpKSA6IDAuMFxcbiAgICAgICAgKTtcXG5cXG4gICAgICAgIGludCBmaXJzdENoYW5uZWwgPSBkIC0gXCIraStcIjtcXG4gICAgICAgIHZlYzIgY2FjaGUgPSB2ZWMyKDAuKTtcXG4gICAgICAgIGlmKGZpcnN0Q2hhbm5lbCA+PSAwKXtcXG4gICAgICAgICAgdmVjNCBmaXJzdENoYW5uZWxGcmFnID0gZ2V0WChiLCByLCBjLCBmaXJzdENoYW5uZWwpO1xcbiAgICAgICAgICBjYWNoZS54ID0gZ2V0Q2hhbm5lbChmaXJzdENoYW5uZWxGcmFnLCB2ZWMyKGMsIGZpcnN0Q2hhbm5lbCkpO1xcbiAgICAgICAgICAgIGlmKGhhc05leHRSb3cpe1xcbiAgICAgICAgICAgICAgY2FjaGUueSA9IGdldENoYW5uZWwoZmlyc3RDaGFubmVsRnJhZywgdmVjMihjICsgMSwgZmlyc3RDaGFubmVsKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaXZlYzIgZGVwdGggPSBpdmVjMihkLCBkICsgMSk7XFxuICAgICAgICBmb3IgKGludCBqID0gLSBcIitpK1wiOyBqIDw9IFwiK2krXCI7IGorKykge1xcbiAgICAgICAgICBpdmVjMiBpZHggPSBkZXB0aCArIGo7XFxuICAgICAgICAgIGJ2ZWMyIGFib3ZlTG93ZXJCb3VuZCA9IGdyZWF0ZXJUaGFuRXF1YWwoaWR4LCBpdmVjMigwKSk7XFxuICAgICAgICAgIGJ2ZWMyIGJlbG93VXBwZXJCb3VuZCA9IGxlc3NUaGFuRXF1YWwoaWR4LCBpdmVjMihcIitzK1wiKSk7XFxuXFxuICAgICAgICAgIGJvb2wgZGVwdGhJblJhbmdlID0gYWJvdmVMb3dlckJvdW5kLnggJiYgYmVsb3dVcHBlckJvdW5kLng7XFxuICAgICAgICAgIGJvb2wgZGVwdGhQbHVzT25lSW5SYW5nZSA9IGFib3ZlTG93ZXJCb3VuZC55ICYmIGJlbG93VXBwZXJCb3VuZC55O1xcblxcbiAgICAgICAgICBpZihkZXB0aEluUmFuZ2UgfHwgZGVwdGhQbHVzT25lSW5SYW5nZSl7XFxuICAgICAgICAgICAgdmVjNCB6ID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgdmVjNCB4RnJhZ0F0Q3VycmVudERlcHRoO1xcbiAgICAgICAgICAgIHoueHogPSBjYWNoZS54eTtcXG4gICAgICAgICAgICBpZihkZXB0aFBsdXNPbmVJblJhbmdlICYmIGhhc05leHRDb2wpe1xcbiAgICAgICAgICAgICAgeEZyYWdBdEN1cnJlbnREZXB0aCA9IGlkeC55ICE9IGQgP1xcbiAgICAgICAgICAgICAgICBnZXRYKGIsIHIsIGMsIGlkeC55KSA6IHhGcmFnQXRPdXRwdXRDb29yZHM7XFxuICAgICAgICAgICAgICB6LnkgPSBnZXRDaGFubmVsKHhGcmFnQXRDdXJyZW50RGVwdGgsIHZlYzIoYywgaWR4LnkpKTtcXG4gICAgICAgICAgICAgIGlmKGhhc05leHRSb3cpe1xcbiAgICAgICAgICAgICAgICB6LncgPSBnZXRDaGFubmVsKHhGcmFnQXRDdXJyZW50RGVwdGgsIHZlYzIoYyArIDEsIGlkeC55KSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNhY2hlLnh5ID0gei55dztcXG4gICAgICAgICAgICBzdW0gKz0geiAqIHo7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0geEF0T3V0cHV0Q29vcmRzICogXCIrYStcIjtcXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLEhhPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwibWF4UG9zXCJdLHRoaXMub3V0cHV0U2hhcGU9dC5pblNoYXBlO3ZhciBlPXQuc3RyaWRlSGVpZ2h0LG49dC5zdHJpZGVXaWR0aCxyPXQuZGlsYXRpb25IZWlnaHQsbz10LmVmZmVjdGl2ZUZpbHRlckhlaWdodCxhPXQuZWZmZWN0aXZlRmlsdGVyV2lkdGgsaT1vLTEtdC5wYWRJbmZvLnRvcCxzPWEtMS10LnBhZEluZm8ubGVmdCx1PW8qYS0xO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIraStcIiwgXCIrcytcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgZHlSQ0Nvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQpIHdpdGggcG9zIG1hc2soOiwgOiwgZCkgdG8gZ2V0IGR4KHhSLCB4QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrbytcIjtcXG4gICAgICAgICAgd1IgKz0gXCIrcitcIikge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIitlK1wiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiK3Qub3V0SGVpZ2h0K1wiLjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIithK1wiOyB3QysrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIrbitcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiK3Qub3V0V2lkdGgrXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgaWR5UiwgaWR5QywgZCk7XFxuICAgICAgICAgICAgaW50IG1heFBvc1ZhbHVlID0gXCIrdStcIiAtIGludChnZXRNYXhQb3MoYiwgaWR5UiwgaWR5QywgZCkpO1xcblxcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCB2YWx1ZSwgY2hlY2sgaXQgYWdhaW5zdCB0aGUgdmFsdWUgZnJvbSB0aGVcXG4gICAgICAgICAgICAvLyBwb3NpdGlvbiBtYXRyaXguXFxuICAgICAgICAgICAgaW50IGN1clBvc1ZhbHVlID0gd1IgKiBcIithK1wiICsgd0M7XFxuICAgICAgICAgICAgZmxvYXQgbWFzayA9IGZsb2F0KG1heFBvc1ZhbHVlID09IGN1clBvc1ZhbHVlID8gMS4wIDogMC4wKTtcXG5cXG4gICAgICAgICAgICBkb3RQcm9kICs9IGR5VmFsdWUgKiBtYXNrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn19KCksJGE9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scixvLGEpe3ZvaWQgMD09PW4mJihuPSExKSx2b2lkIDA9PT1yJiYocj0hMSksdm9pZCAwPT09byYmKG89ITEpLHZvaWQgMD09PWEmJihhPW51bGwpLHRoaXMudmFyaWFibGVOYW1lcz1bXCJtYXRyaXhBXCIsXCJtYXRyaXhCXCJdLHRoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwLHRoaXMub3V0cHV0U2hhcGU9ZTt2YXIgaT1uP3RbMV06dFsyXSxzPU1hdGguY2VpbChpLzIpLHU9bj9cImkgKiAyLCByYy55XCI6XCJyYy55LCBpICogMlwiLGw9cj9cInJjLnosIGkgKiAyXCI6XCJpICogMiwgcmMuelwiLGM9bj9bXCJhLnh4eXlcIixcImEuenp3d1wiXTpbXCJhLnh4enpcIixcImEueXl3d1wiXSxoPXI/W1wiYi54enh6XCIsXCJiLnl3eXdcIl06W1wiYi54eXh5XCIsXCJiLnp3endcIl0scD1cIlwiLGY9XCJcIjthJiYocD1cInZlYzQgYWN0aXZhdGlvbih2ZWM0IHgpIHtcXG4gICAgICAgIFwiK2ErXCJcXG4gICAgICB9XCIsZj1cInJlc3VsdCA9IGFjdGl2YXRpb24ocmVzdWx0KTtcIik7dmFyIGQ9bz9cInJlc3VsdCArPSBnZXRCaWFzQXRPdXRDb29yZHMoKTtcIjpcIlwiO28mJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwiYmlhc1wiKSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgXCIrcCtcIlxcblxcbiAgICAgIGNvbnN0IGZsb2F0IHNoYXJlZERpbWVuc2lvbiA9IFwiK3MrXCIuMDtcXG5cXG4gICAgICB2ZWM0IGRvdDJ4MkFSb3dCQ29sKGl2ZWMzIHJjKSB7XFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMCk7XFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK3MrXCI7IGkrKykge1xcbiAgICAgICAgICB2ZWM0IGEgPSBnZXRNYXRyaXhBKHJjLngsIFwiK3UrXCIpO1xcbiAgICAgICAgICB2ZWM0IGIgPSBnZXRNYXRyaXhCKHJjLngsIFwiK2wrXCIpO1xcblxcbiAgICAgICAgICByZXN1bHQgKz0gKFwiK2NbMF0rXCIgKiBcIitoWzBdK1wiKSArIChcIitjWzFdK1wiICogXCIraFsxXStcIik7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyByYyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSBkb3QyeDJBUm93QkNvbChyYyk7XFxuXFxuICAgICAgICBcIitkK1wiXFxuXFxuICAgICAgICBcIitmK1wiXFxuXFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxqYT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJwcm9ic1wiXSx0aGlzLm91dHB1dFNoYXBlPVt0LG5dLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB1bmlmb3JtIGZsb2F0IHNlZWQ7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuXFxuICAgICAgICBmbG9hdCByID0gcmFuZG9tKHNlZWQpO1xcbiAgICAgICAgZmxvYXQgY2RmID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIisoZS0xKStcIjsgaSsrKSB7XFxuICAgICAgICAgIGNkZiArPSBnZXRQcm9icyhiYXRjaCwgaSk7XFxuXFxuICAgICAgICAgIGlmIChyIDwgY2RmKSB7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KGkpKTtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIElmIG5vIG90aGVyIGV2ZW50IGhhcHBlbmVkLCBsYXN0IGV2ZW50IGhhcHBlbmVkLlxcbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiKyhlLTEpK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIn1yZXR1cm4gdC5wcm90b3R5cGUuZ2V0Q3VzdG9tU2V0dXBGdW5jPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKG4scil7bnVsbD09ZS5zZWVkTG9jJiYoZS5zZWVkTG9jPW4uZ2V0VW5pZm9ybUxvY2F0aW9uKHIsXCJzZWVkXCIpKSxuLmdsLnVuaWZvcm0xZihlLnNlZWRMb2MsdCl9fSx0fSgpLEthPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJpbmRpY2VzXCJdLHRoaXMub3V0cHV0U2hhcGU9W3QsZV0sdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZ2V0SW5kaWNlcyhjb29yZHMueCkpO1xcbiAgICAgICAgc2V0T3V0cHV0KG1peChmbG9hdChcIityK1wiKSwgZmxvYXQoXCIrbitcIiksXFxuICAgICAgICAgICAgICAgICAgICAgIGZsb2F0KGluZGV4ID09IGNvb3Jkcy55KSkpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLFhhPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMuaXNQYWNrU2hhZGVyPSEwLHRoaXMub3V0cHV0U2hhcGU9dDt2YXIgZT10Lmxlbmd0aDtpZigwPT09ZSl0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIHNldE91dHB1dCh2ZWM0KGdldEEoKSwgMC4sIDAuLCAwLikpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO2Vsc2V7dmFyIG49b28oXCJyY1wiLGUpLHI9Ym8oZSksbz1mdW5jdGlvbih0LGUsbil7aWYoMT09PXQpcmV0dXJuXCJyYyA+IFwiK2VbMF07Zm9yKHZhciByPVwiXCIsbz10LTI7bzx0O28rKylyKz1uW29dK1wiID49IFwiK2Vbb10sbzx0LTEmJihyKz1cInx8XCIpO3JldHVybiByfShlLHQsbiksYT1mdW5jdGlvbih0LGUsbixyKXtpZigxPT09dClyZXR1cm5cIlwiO3ZhciBvPXIuc2xpY2UoLTIpO3JldHVyblwiXFxuICAgIGludCByID0gXCIrb1swXStcIjtcXG4gICAgaW50IGMgPSBcIitvWzFdK1wiO1xcbiAgICBpbnQgcnAxID0gciArIDE7XFxuICAgIGludCBjcDEgPSBjICsgMTtcXG5cXG4gICAgYm9vbCBjRWRnZSA9IGNwMSA+PSBcIitlK1wiO1xcbiAgICBib29sIHJFZGdlID0gcnAxID49IFwiK24rXCI7XFxuICBcIn0oZSx0W3QubGVuZ3RoLTFdLHRbdC5sZW5ndGgtMl0sbiksaT1mdW5jdGlvbih0LGUpe3ZhciBuPXQubGVuZ3RoLHI9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49W10scj0wO3I8PTE7cisrKWZvcih2YXIgbz0wO288PTE7bysrKXtmb3IodmFyIGE9KDA9PT1yP1wiclwiOlwicnAxXCIpK1wiLCBcIisoMD09PW8/XCJjXCI6XCJjcDFcIiksaT0yO2k8dDtpKyspYT1lW2UubGVuZ3RoLTEtaV0rXCIsXCIrYTtuLnB1c2goYSl9cmV0dXJuIG59KG4sZSk7cmV0dXJuIDE9PT1uP1wiZ2V0QShyYyksXFxuICAgICAgICAgICAgcmMgKyAxID49IFwiK3RbMF0rXCIgPyAwLiA6IGdldEEocmMgKyAxKSxcXG4gICAgICAgICAgICAwLCAwXCI6XCJnZXRBKFwiK3JbMF0rXCIpLFxcbiAgICAgICAgICBjRWRnZSA/IDAuIDogZ2V0QShcIityWzFdK1wiKSxcXG4gICAgICAgICAgckVkZ2UgPyAwLiA6IGdldEEoXCIrclsyXStcIiksXFxuICAgICAgICAgIHJFZGdlIHx8IGNFZGdlID8gMC4gOiBnZXRBKFwiK3JbM10rXCIpXCJ9KHQsbik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBcIityK1wiIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgICAgIGlmKFwiK28rXCIpIHtcXG4gICAgICAgICAgICBzZXRPdXRwdXQodmVjNCgwKSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgXCIrYStcIlxcblxcbiAgICAgICAgICAgIHNldE91dHB1dCh2ZWM0KFwiK2krXCIpKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIFwifX19KCk7dmFyIFlhPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLm91dHB1dFNoYXBlPWUubWFwKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGVbMF0rdFtuXStlWzFdfSk7dmFyIHI9dC5sZW5ndGgsbz1ibyhyKSxhPWUubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0WzBdfSkuam9pbihcIixcIiksaT1lLm1hcChmdW5jdGlvbihlLG4pe3JldHVybiBlWzBdK3Rbbl19KS5qb2luKFwiLFwiKSxzPVtcImNvb3Jkc1swXVwiLFwiY29vcmRzWzFdXCIsXCJjb29yZHNbMl1cIixcImNvb3Jkc1szXVwiXS5zbGljZSgwLHIpO3RoaXMudXNlckNvZGU9MSE9PXI/XCJcXG4gICAgICBcIitvK1wiIHN0YXJ0ID0gXCIrbytcIihcIithK1wiKTtcXG4gICAgICBcIitvK1wiIGVuZCA9IFwiK28rXCIoXCIraStcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbytcIiBvdXRDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpZiAoYW55KGxlc3NUaGFuKG91dEMsIHN0YXJ0KSkgfHwgYW55KGdyZWF0ZXJUaGFuRXF1YWwob3V0QywgZW5kKSkpIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiK24rXCIpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIFwiK28rXCIgY29vcmRzID0gb3V0QyAtIHN0YXJ0O1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIitzK1wiKSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICBcIjpcIlxcbiAgICAgICAgaW50IHN0YXJ0ID0gXCIrYStcIjtcXG4gICAgICAgIGludCBlbmQgPSBcIitpK1wiO1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpbnQgb3V0QyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBpZiAob3V0QyA8IHN0YXJ0IHx8IG91dEMgPj0gZW5kKSB7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiK24rXCIpKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzZXRPdXRwdXQoZ2V0WChvdXRDIC0gc3RhcnQpKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIFwifX0oKSxRYT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy51c2VzUGFja2VkVGV4dHVyZXM9ITAsdGhpcy5vdXRwdXRTaGFwZT1lLm1hcChmdW5jdGlvbihlLG4pe3JldHVybiBlWzBdK3Rbbl0rZVsxXX0pO2Zvcih2YXIgcj10Lmxlbmd0aCxvPWJvKHIpLGE9ZS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHRbMF19KS5qb2luKFwiLFwiKSxpPWUubWFwKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGVbMF0rdFtuXX0pLmpvaW4oXCIsXCIpLHM9b28oXCJyY1wiLHIpLHU9b28oXCJzb3VyY2VcIixyKSxsPXNbci0xXStcIiA8IFwiK3RoaXMub3V0cHV0U2hhcGVbci0xXSxjPTE9PT1yP1wic291cmNlXCI6XCJ2ZWMyKFwiK3Uuc2xpY2UoLTIpLmpvaW4oKStcIilcIixoPVtvK1wiIHJjID0gb3V0cHV0TG9jO1wiLHNbci0xXStcIiArPSAxO1xcbiAgICAgICBpZihcIitsK1wiKSB7XFxuICAgICAgXCIsMT09PXI/XCJcIjpcIn1cXG4gICAgICAgcmMgPSBvdXRwdXRMb2M7XFxuICAgICAgIFwiK3Nbci0yXStcIiArPSAxO1xcbiAgICAgICBpZihcIitzW3ItMl0rXCIgPCBcIit0aGlzLm91dHB1dFNoYXBlW3ItMl0rXCIpIHtcIiwxPT09cj9cIlwiOlwiICBcIitzW3ItMV0rXCIgKz0gMTtcXG4gICAgICAgICBpZihcIitsK1wiKSB7XCJdLHA9MT09PXI/XCJyYyA8IHN0YXJ0IHx8IHJjID49IGVuZFwiOlwiYW55KGxlc3NUaGFuKHJjLCBzdGFydCkpIHx8IGFueShncmVhdGVyVGhhbkVxdWFsKHJjLCBlbmQpKVwiLGY9XCJcIixkPTAsdj0xPT09cj8yOjQ7ZDx2O2QrKylmKz1cIlxcbiAgICAgICAgXCIraFtkXStcIlxcbiAgICAgICAgaWYgKFwiK3ArXCIpIHtcXG4gICAgICAgICAgcmVzdWx0W1wiK2QrXCJdID0gZmxvYXQoXCIrbitcIik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBcIitvK1wiIHNvdXJjZSA9IHJjIC0gc3RhcnQ7XFxuICAgICAgICAgIHJlc3VsdFtcIitkK1wiXSA9IGdldENoYW5uZWwoZ2V0WChcIit1LmpvaW4oKStcIiksIFwiK2MrXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO2YrPTE9PT1yP1wifSBcIjpcIn19XCIsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IFwiK28rXCIgc3RhcnQgPSBcIitvK1wiKFwiK2ErXCIpO1xcbiAgICAgIGNvbnN0IFwiK28rXCIgZW5kID0gXCIrbytcIihcIitpK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitvK1wiIG91dHB1dExvYyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG4gICAgICAgIFwiK2YrXCJcXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLEphPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSxcImF2Z1wiPT09ZSYmbil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSBwb3NpdGlvbnMgZm9yIGF2ZXJhZ2UgcG9vbC5cIik7dmFyIHI9dC5maWx0ZXJXaWR0aCxvPXQuc3RyaWRlSGVpZ2h0LGE9dC5zdHJpZGVXaWR0aCxpPXQuZGlsYXRpb25IZWlnaHQscz10LmRpbGF0aW9uV2lkdGgsdT10LmVmZmVjdGl2ZUZpbHRlckhlaWdodCxsPXQuZWZmZWN0aXZlRmlsdGVyV2lkdGgsYz10LnBhZEluZm8udG9wLGg9dC5wYWRJbmZvLmxlZnQ7dGhpcy5vdXRwdXRTaGFwZT10Lm91dFNoYXBlO3ZhciBwPVwiYXZnXCI9PT1lLGY9XCIwLjBcIjtpZihwfHwoZj1cIi0xLjAgLyAxZS0yMFwiKSxuKXRoaXMudXNlckNvZGU9XCJcXG4gICAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIitvK1wiLCBcIithK1wiKTtcXG4gICAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIitjK1wiLCBcIitoK1wiKTtcXG5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuXFxuICAgICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy55eiAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAgIC8vIG1heC9taW4geCg/LCA/LCBkKSB0byBnZXQgeSh5UiwgeUMsIGQpLlxcbiAgICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxcbiAgICAgICAgICBmbG9hdCBtaW5NYXhWYWx1ZSA9IDAuMDtcXG4gICAgICAgICAgZmxvYXQgbWluTWF4VmFsdWVGb3VuZCA9IDAuMDtcXG4gICAgICAgICAgaW50IG1pbk1heFBvc2l0aW9uID0gMDtcXG4gICAgICAgICAgZmxvYXQgYXZnVmFsdWUgPSAwLjA7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIit1K1wiO1xcbiAgICAgICAgICAgICAgd1IgKz0gXCIraStcIikge1xcbiAgICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1I7XFxuXFxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIit0LmluSGVpZ2h0K1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK2wrXCI7XFxuICAgICAgICAgICAgICAgIHdDICs9IFwiK3MrXCIpIHtcXG4gICAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0M7XFxuXFxuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK3QuaW5XaWR0aCtcIikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkKTtcXG5cXG4gICAgICAgICAgICAgIC8vIElmIGEgbWluIC8gbWF4IHZhbHVlIGhhcyBhbHJlYWR5IGJlZW4gZm91bmQsIHVzZSBpdC4gSWYgbm90LFxcbiAgICAgICAgICAgICAgLy8gdXNlIHRoZSBjdXJyZW50IHZhbHVlLlxcbiAgICAgICAgICAgICAgZmxvYXQgY3Vyck1pbk1heFZhbHVlID0gbWl4KFxcbiAgICAgICAgICAgICAgICAgIHZhbHVlLCBtaW5NYXhWYWx1ZSwgbWluTWF4VmFsdWVGb3VuZCk7XFxuICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gY3Vyck1pbk1heFZhbHVlKSB7XFxuICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlID0gdmFsdWU7XFxuICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlRm91bmQgPSAxLjA7XFxuICAgICAgICAgICAgICAgIG1pbk1heFBvc2l0aW9uID0gd1IgKiBcIitsK1wiICsgd0M7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChtaW5NYXhQb3NpdGlvbikpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO2Vsc2V7dmFyIGQ9ZStcIihcIitlK1wiKFwiK2UrXCIobWluTWF4VmFsdWVbMF0sIG1pbk1heFZhbHVlWzFdKSwgbWluTWF4VmFsdWVbMl0pLCBtaW5NYXhWYWx1ZVszXSlcIjtcImF2Z1wiPT09ZSYmKGQ9XCJhdmdWYWx1ZSAvIGNvdW50XCIpO3ZhciB2PTQqTWF0aC5mbG9vcihyLzQpLG09ciU0LGc9XCJcXG4gICAgICBpZiAoXCIrcCtcIikge1xcbiAgICAgICAgYXZnVmFsdWUgKz0gZG90KHZhbHVlcywgb25lcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG1pbk1heFZhbHVlID0gbWF4KHZhbHVlcywgbWluTWF4VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIitvK1wiLCBcIithK1wiKTtcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIrYytcIiwgXCIraCtcIik7XFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9IFwiK2YrXCI7XFxuICAgICAgY29uc3QgdmVjNCBvbmVzID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApO1xcblxcbiAgICAgIGZsb2F0IGNvdW50ID0gMC4wO1xcblxcbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IHhSLCBpbnQgeEMsIGludCBkKSB7XFxuICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK3QuaW5XaWR0aCtcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvdW50ICs9IDEuMDtcXG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCB4UiwgeEMsIGQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sIGQpIHRvIGdldCB5KHlSLCB5QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxcbiAgICAgICAgdmVjNCBtaW5NYXhWYWx1ZSA9IHZlYzQoXCIrZitcIik7XFxuICAgICAgICBmbG9hdCBhdmdWYWx1ZSA9IDAuMDtcXG4gICAgICAgIGNvdW50ID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK3UrXCI7XFxuICAgICAgICAgICAgd1IgKz0gXCIraStcIikge1xcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK3QuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrditcIjsgd0MgKz0gNCkge1xcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0MgKiBcIitzK1wiO1xcblxcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIFwiK3MrXCIsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIDIgKiBcIitzK1wiLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAzICogXCIrcytcIiwgZClcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiK2crXCJcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIFwiK3YrXCI7XFxuICAgICAgICAgIGlmIChcIisoMT09PW0pK1wiKSB7XFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiK2crXCJcXG4gICAgICAgICAgfSBlbHNlIGlmIChcIisoMj09PW0pK1wiKSB7XFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgXCIrcytcIiwgZCksXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIrZytcIlxcbiAgICAgICAgICB9IGVsc2UgaWYgKFwiKygzPT09bSkrXCIpIHtcXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyBcIitzK1wiLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAyICogXCIrcytcIiwgZCksXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICBcIitnK1wiXFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChcIitkK1wiKTtcXG4gICAgICB9XFxuICAgIFwifX19KCksWmE9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXTt2YXIgbj10LndpbmRvd1NpemUscj10LmJhdGNoU2l6ZSxvPXQuaW5TaXplLGE9TWF0aC5jZWlsKG8vbik7dGhpcy5vdXRwdXRTaGFwZT1bcixhXTt2YXIgaT1cIjAuMFwiLHM9XCJcIjtcInByb2RcIj09PWU/aT1cIjEuMFwiOlwibWluXCI9PT1lPyhpPVwiMS4wIC8gMWUtMjBcIixzPVwibWluXCIpOlwibWF4XCI9PT1lJiYoaT1cIi0xLjAgLyAxZS0yMFwiLHM9XCJtYXhcIik7dmFyIHU9ZStcIihcIitlK1wiKFwiK2UrXCIobWluTWF4VmFsdWVbMF0sIG1pbk1heFZhbHVlWzFdKSwgbWluTWF4VmFsdWVbMl0pLCBtaW5NYXhWYWx1ZVszXSlcIjtcInN1bVwiPT09ZT91PVwic3VtVmFsdWVcIjpcInByb2RcIj09PWU/dT1cInByb2RWYWx1ZVwiOlwiYWxsXCI9PT1lP3U9XCJhbGxWYWx1ZVwiOlwiYW55XCI9PT1lJiYodT1cImFueVZhbHVlXCIpO3ZhciBsPTQqTWF0aC5mbG9vcihuLzQpLGM9biU0LGg9XCJcXG4gICAgICBpZiAoXCIrKFwic3VtXCI9PT1lKStcIikge1xcbiAgICAgICAgc3VtVmFsdWUgKz0gZG90KHZhbHVlcywgb25lcyk7XFxuICAgICAgfSBlbHNlIGlmIChcIisoXCJwcm9kXCI9PT1lKStcIikge1xcbiAgICAgICAgdmVjMiB0bXAgPSB2ZWMyKHZhbHVlc1swXSwgdmFsdWVzWzFdKSAqIHZlYzIodmFsdWVzWzJdLCB2YWx1ZXNbM10pO1xcbiAgICAgICAgcHJvZFZhbHVlICo9IHRtcFswXSAqIHRtcFsxXTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbWluTWF4VmFsdWUgPSBcIitzK1wiKHZhbHVlcywgbWluTWF4VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCIscD1cInZlYzRcIjtcImFsbFwiPT09ZT8oaT1cIjEuMFwiLGg9XCJcXG4gICAgICAgIGJvb2wgcmVkdWNlZEFsbFZhbHVlID0gYWxsKHZhbHVlcyk7XFxuICAgICAgICBmbG9hdCBmbG9hdGVkUmVkdWNlZEFsbFZhbHVlID0gZmxvYXQocmVkdWNlZEFsbFZhbHVlKTtcXG4gICAgICAgIGFsbFZhbHVlID0gZmxvYXQoYWxsVmFsdWUgPj0gMS4wICYmIGZsb2F0ZWRSZWR1Y2VkQWxsVmFsdWUgPj0gMS4wKTtcXG4gICAgICBcIixwPVwiYnZlYzRcIik6XCJhbnlcIj09PWUmJihpPVwiMC4wXCIsaD1cIlxcbiAgICAgICAgYm9vbCByZWR1Y2VkQW55VmFsdWUgPSBhbnkodmFsdWVzKTtcXG4gICAgICAgIGZsb2F0IGZsb2F0ZWRSZWR1Y2VkQW55VmFsdWUgPSBmbG9hdChyZWR1Y2VkQW55VmFsdWUpO1xcbiAgICAgICAgYW55VmFsdWUgPSBmbG9hdChhbnlWYWx1ZSA+PSAxLjAgfHwgZmxvYXRlZFJlZHVjZWRBbnlWYWx1ZSA+PSAxLjApO1xcbiAgICAgIFwiLHA9XCJidmVjNFwiKTt2YXIgZj1cIlwiO28lbj4wJiYoZj1cIlxcbiAgICAgICAgaWYgKGluSWR4IDwgMCB8fCBpbklkeCA+PSBcIitvK1wiKSB7XFxuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIFwiKSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9IFwiK2krXCI7XFxuICAgICAgY29uc3QgdmVjNCBvbmVzID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApO1xcblxcbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IGluSWR4KSB7XFxuICAgICAgICBcIitmK1wiXFxuICAgICAgICByZXR1cm4gZ2V0WChiYXRjaCwgaW5JZHgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBvdXRJZHggPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgaW5PZmZzZXQgPSBvdXRJZHggKiBcIituK1wiO1xcblxcbiAgICAgICAgdmVjNCBtaW5NYXhWYWx1ZSA9IHZlYzQoXCIraStcIik7XFxuICAgICAgICBmbG9hdCBwcm9kVmFsdWUgPSAxLjA7XFxuICAgICAgICBmbG9hdCBzdW1WYWx1ZSA9IDAuMDtcXG4gICAgICAgIGZsb2F0IGFsbFZhbHVlID0gMS4wO1xcbiAgICAgICAgZmxvYXQgYW55VmFsdWUgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK2wrXCI7IGkgKz0gNCkge1xcbiAgICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIGk7XFxuICAgICAgICAgIFwiK3ArXCIgdmFsdWVzID0gXCIrcCtcIihcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDMpXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK2grXCJcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgXCIrbCtcIjtcXG4gICAgICAgIGlmIChcIisoMT09PWMpK1wiKSB7XFxuICAgICAgICAgIFwiK3ArXCIgdmFsdWVzID0gXCIrcCtcIihcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK2grXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIrKDI9PT1jKStcIikge1xcbiAgICAgICAgICBcIitwK1wiIHZhbHVlcyA9IFwiK3ArXCIoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIraCtcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIisoMz09PWMpK1wiKSB7XFxuICAgICAgICAgIFwiK3ArXCIgdmFsdWVzID0gXCIrcCtcIihcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIraCtcIlxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KFwiK3UrXCIpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLHRpPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy51c2VzUGFja2VkVGV4dHVyZXM9ITAsdGhpcy5vdXRwdXRTaGFwZT10O2Zvcih2YXIgbj1cIlwiLHI9MDtyPDQ7cisrKXt2YXIgbz1cInRoaXNSQyA9IHJjO1wiO3IlMj09MSYmKG8rPVwidGhpc1JDLnogKz0gMTtcIikscj4xJiYobys9XCJ0aGlzUkMueSArPSAxO1wiKSxuKz1cIlxcbiAgICAgICAgXCIrbytcIlxcbiAgICAgICAgXCIrKHI+MD9cImlmKHRoaXNSQy55IDwgcm93cyAmJiB0aGlzUkMueiA8IGNvbHMpe1wiOlwiXCIpK1wiXFxuICAgICAgICAgIGludCBmbGF0SW5kZXggPSBnZXRGbGF0SW5kZXgodGhpc1JDKTtcXG5cXG4gICAgICAgICAgaXZlYzMgaW5wdXRSQyA9IGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGZsYXRJbmRleCk7XFxuICAgICAgICAgIHZlYzIgaW5wdXRSQ0lubmVyRGltcyA9IHZlYzIoZmxvYXQoaW5wdXRSQy55KSxmbG9hdChpbnB1dFJDLnopKTtcXG5cXG4gICAgICAgICAgcmVzdWx0W1wiK3IrXCJdID1cXG4gICAgICAgICAgICBnZXRDaGFubmVsKGdldEEoaW5wdXRSQy54LCBpbnB1dFJDLnksIGlucHV0UkMueiksIGlucHV0UkNJbm5lckRpbXMpO1xcbiAgICAgICAgXCIrKHI+MD9cIn1cIjpcIlwiKStcIlxcbiAgICAgIFwifXRoaXMudXNlckNvZGU9XCJcXG4gICAgICBcXG4gICAgaXZlYzMgaW5wdXRDb29yZHNGcm9tUmVzaGFwZWRPdXRDb29yZHMoaW50IGluZGV4KSB7XFxuICAgICAgXCIrbG8oW1wiclwiLFwiY1wiLFwiZFwiXSxlKStcIlxcbiAgICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcXG4gICAgfVxcbiAgXFxuICAgICAgXCIrZnVuY3Rpb24odCl7cmV0dXJuXCJcXG4gICAgaW50IGdldEZsYXRJbmRleChpdmVjMyBjb29yZHMpIHtcXG4gICAgICByZXR1cm4gcm91bmQoXCIrZnVuY3Rpb24odCxlKXtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlZlY3RvcnMgdG8gYmUgZG90dGVkIG11c3QgYmUgb2YgdGhlIHNhbWUgbGVuZ3RoIC1nb3QgXCIrdC5sZW5ndGgrXCIgYW5kIFwiK2UubGVuZ3RoKTtmb3IodmFyIG49W10scj1NYXRoLmZsb29yKHQubGVuZ3RoLzQpLG89dC5sZW5ndGglNCxhPTA7YTxyO2ErKyl7dmFyIGk9dC5zbGljZSg0KmEsNCphKzQpLHM9ZS5zbGljZSg0KmEsNCphKzQpO24ucHVzaChjbyhpKStcIiwgXCIrY28ocykpfXJldHVybiAwIT09byYmKGk9dC5zbGljZSg0KnIpLHM9ZS5zbGljZSg0KnIpLDE9PT1pLmxlbmd0aCYmKGk9aS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJmbG9hdChcIit0K1wiKVwifSkscz1zLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cImZsb2F0KFwiK3QrXCIpXCJ9KSksbi5wdXNoKGNvKGkpK1wiLCBcIitjbyhzKSkpLG4ubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJkb3QoXCIrdCtcIilcIn0pLmpvaW4oXCIrXCIpfShbXCJjb29yZHMueFwiLFwiY29vcmRzLnlcIixcImNvb3Jkcy56XCJdLFYodCkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRvU3RyaW5nKCl9KS5jb25jYXQoW1wiMS5cIl0pKStcIik7XFxuICAgIH1cXG4gIFwifSh0KStcIlxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcblxcbiAgICAgICAgaXZlYzMgdGhpc1JDO1xcbiAgICAgICAgaW50IHJvd3MgPSBcIit0WzFdK1wiO1xcbiAgICAgICAgaW50IGNvbHMgPSBcIit0WzJdK1wiO1xcblxcbiAgICAgICAgXCIrbitcIlxcblxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn19KCk7dmFyIGVpPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPWUuc2hhcGU7dmFyIHI9ZS5zaGFwZSxvPXJbMV0sYT1yWzJdLGk9dC5zaGFwZSxzPWlbMV0sdT1pWzJdLGw9W24mJnM+MT9vLTE6byxuJiZ1PjE/YS0xOmFdLGM9W24mJnM+MT9zLTE6cyxuJiZ1PjE/dS0xOnVdLGg9bFswXS9jWzBdLHA9bFsxXS9jWzFdLGY9MS9oLGQ9MS9wLHY9MipNYXRoLmNlaWwoZikrMixtPTIqTWF0aC5jZWlsKGQpKzI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XFxuXFxuICAgICAgICBmbG9hdCBhY2N1bXVsYXRvciA9IDAuMDtcXG5cXG4gICAgICAgIGNvbnN0IGZsb2F0IGhlaWdodFNjYWxlID0gZmxvYXQoXCIraCtcIik7XFxuICAgICAgICBjb25zdCBmbG9hdCB3aWR0aFNjYWxlID0gZmxvYXQoXCIrcCtcIik7XFxuXFxuICAgICAgICBjb25zdCBmbG9hdCBpbnZIZWlnaHRTY2FsZSA9IGZsb2F0KFwiK2YrXCIpO1xcbiAgICAgICAgY29uc3QgZmxvYXQgaW52V2lkdGhTY2FsZSA9IGZsb2F0KFwiK2QrXCIpO1xcblxcbiAgICAgICAgY29uc3QgaW50IHdpbkhlaWdodCA9IGludChcIit2K1wiKTtcXG4gICAgICAgIGNvbnN0IGludCB3aW5XaWR0aCA9IGludChcIittK1wiKTtcXG5cXG4gICAgICAgIC8vIENvbXB1dGUgYm91bmRzIGZvciB3aGVyZSBpbiBkeSB3ZSB3aWxsIGxvb2tcXG4gICAgICAgIGZsb2F0IHN0YXJ0UkxlcnAgPSBmbG9vcihmbG9hdChyKSAqIGludkhlaWdodFNjYWxlKTtcXG4gICAgICAgIGludCBzdGFydER5UiA9IGludChzdGFydFJMZXJwIC0gZmxvYXQod2luSGVpZ2h0IC8gMikpO1xcblxcbiAgICAgICAgZmxvYXQgc3RhcnRDTGVycCA9IGZsb29yKGZsb2F0KGMpICogaW52V2lkdGhTY2FsZSk7XFxuICAgICAgICBpbnQgc3RhcnREeUMgPSBpbnQoc3RhcnRDTGVycCAtIGZsb2F0KHdpbldpZHRoIC8gMikpO1xcblxcbiAgICAgICAgLy8gTG9vcCBvdmVyIGR5XFxuICAgICAgICBmb3IgKGludCBkeVJPZmZzZXQgPSAwOyBkeVJPZmZzZXQgPCB3aW5IZWlnaHQ7IGR5Uk9mZnNldCsrKSB7XFxuICAgICAgICAgIGludCBkeVIgPSBkeVJPZmZzZXQgKyBzdGFydER5UjtcXG5cXG4gICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgd2luZG93IGV4Y2VlZGluZyB0aGUgYm91bmRzIG9mIGR5XFxuICAgICAgICAgIGlmIChkeVIgPCAwIHx8IGR5UiA+PSBcIitzK1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgZHlDT2Zmc2V0ID0gMDsgZHlDT2Zmc2V0IDwgd2luV2lkdGg7IGR5Q09mZnNldCsrKSB7XFxuICAgICAgICAgICAgaW50IGR5QyA9IGR5Q09mZnNldCArIHN0YXJ0RHlDO1xcblxcbiAgICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIHdpbmRvdyBleGNlZWRpbmcgdGhlIGJvdW5kcyBvZiBkeVxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwIHx8IGR5QyA+PSBcIit1K1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZmxvYXQgZHhSID0gZmxvYXQoZHlSKSAqIGhlaWdodFNjYWxlO1xcbiAgICAgICAgICAgIGludCB0b3BEeFJJbmRleCA9IGludChmbG9vcihkeFIpKTtcXG4gICAgICAgICAgICBpbnQgYm90dG9tRHhSSW5kZXggPSBpbnQobWluKGNlaWwoZHhSKSwgXCIrKG8tMSkrXCIuMCkpO1xcbiAgICAgICAgICAgIGZsb2F0IGR4UkxlcnAgPSBkeFIgLSBmbG9hdCh0b3BEeFJJbmRleCk7XFxuICAgICAgICAgICAgZmxvYXQgaW52ZXJzZUR4UkxlcnAgPSAxLjAgLSBkeFJMZXJwO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGR4QyA9IGZsb2F0KGR5QykgKiB3aWR0aFNjYWxlO1xcbiAgICAgICAgICAgIGludCBsZWZ0RHhDSW5kZXggPSBpbnQoZmxvb3IoZHhDKSk7XFxuICAgICAgICAgICAgaW50IHJpZ2h0RHhDSW5kZXggPSBpbnQobWluKGNlaWwoZHhDKSwgXCIrKGEtMSkrXCIuMCkpO1xcbiAgICAgICAgICAgIGZsb2F0IGR4Q0xlcnAgPSBkeEMgLSBmbG9hdChsZWZ0RHhDSW5kZXgpO1xcbiAgICAgICAgICAgIGZsb2F0IGludmVyc2VEeENMZXJwID0gMS4wIC0gZHhDTGVycDtcXG5cXG4gICAgICAgICAgICBpZiAociA9PSB0b3BEeFJJbmRleCAmJiBjID09IGxlZnREeENJbmRleCkge1xcbiAgICAgICAgICAgICAgLy8gdG9wTGVmdFxcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz1cXG4gICAgICAgICAgICAgICAgZ2V0RHkoYiwgZHlSLCBkeUMsIGQpICogaW52ZXJzZUR4UkxlcnAgKiBpbnZlcnNlRHhDTGVycDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHIgPT0gdG9wRHhSSW5kZXggJiYgYyA9PSByaWdodER4Q0luZGV4KSB7XFxuICAgICAgICAgICAgICAvLyB0b3BSaWdodFxcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz0gZ2V0RHkoYiwgZHlSLCBkeUMsIGQpICogaW52ZXJzZUR4UkxlcnAgKiBkeENMZXJwO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAociA9PSBib3R0b21EeFJJbmRleCAmJiBjID09IGxlZnREeENJbmRleCkge1xcbiAgICAgICAgICAgICAgLy8gYm90dG9tTGVmdFxcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz0gZ2V0RHkoYiwgZHlSLCBkeUMsIGQpICogZHhSTGVycCAqIGludmVyc2VEeENMZXJwO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAociA9PSBib3R0b21EeFJJbmRleCAmJiBjID09IHJpZ2h0RHhDSW5kZXgpIHtcXG4gICAgICAgICAgICAgIC8vIGJvdHRvbVJpZ2h0XFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSBnZXREeShiLCBkeVIsIGR5QywgZCkgKiBkeFJMZXJwICogZHhDTGVycDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIC8vIEVuZCBsb29wIG92ZXIgZHlcXG5cXG4gICAgICAgIHNldE91dHB1dChhY2N1bXVsYXRvcik7XFxuICAgICAgfVxcbiAgICBcIn19KCksbmk9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXTt2YXIgbz10WzBdLGE9dFsxXSxpPXRbMl0scz10WzNdO3RoaXMub3V0cHV0U2hhcGU9W28sZSxuLHNdO3ZhciB1PVtyJiZlPjE/YS0xOmEsciYmbj4xP2ktMTppXSxsPVtyJiZlPjE/ZS0xOmUsciYmbj4xP24tMTpuXTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgdmVjMiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDID0gdmVjMihcXG4gICAgICAgICAgXCIrdVswXS9sWzBdK1wiLFxcbiAgICAgICAgICBcIit1WzFdL2xbMV0rXCIpO1xcbiAgICAgIGNvbnN0IHZlYzIgaW5wdXRTaGFwZVJDID0gdmVjMihcIithK1wiLjAsIFwiK2krXCIuMCk7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcbiAgICAgICAgaXZlYzIgeVJDID0gY29vcmRzLnl6O1xcblxcbiAgICAgICAgLy8gRnJhY3Rpb25hbCBzb3VyY2UgaW5kZXguXFxuICAgICAgICB2ZWMyIHNvdXJjZUZyYWNJbmRleFJDID0gdmVjMih5UkMpICogZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQztcXG5cXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGZvdXIgaW50ZWdlciBpbmRpY2VzLlxcbiAgICAgICAgaXZlYzIgc291cmNlRmxvb3JSQyA9IGl2ZWMyKHNvdXJjZUZyYWNJbmRleFJDKTtcXG4gICAgICAgIGl2ZWMyIHNvdXJjZUNlaWxSQyA9IGl2ZWMyKFxcbiAgICAgICAgICBtaW4oaW5wdXRTaGFwZVJDIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWNJbmRleFJDKSkpO1xcblxcbiAgICAgICAgZmxvYXQgdG9wTGVmdCA9IGdldEEoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnksIGQpO1xcbiAgICAgICAgZmxvYXQgYm90dG9tTGVmdCA9IGdldEEoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUZsb29yUkMueSwgZCk7XFxuICAgICAgICBmbG9hdCB0b3BSaWdodCA9IGdldEEoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VDZWlsUkMueSwgZCk7XFxuICAgICAgICBmbG9hdCBib3R0b21SaWdodCA9IGdldEEoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUNlaWxSQy55LCBkKTtcXG5cXG4gICAgICAgIHZlYzIgZnJhY1JDID0gc291cmNlRnJhY0luZGV4UkMgLSB2ZWMyKHNvdXJjZUZsb29yUkMpO1xcblxcbiAgICAgICAgZmxvYXQgdG9wID0gdG9wTGVmdCArICh0b3BSaWdodCAtIHRvcExlZnQpICogZnJhY1JDLnk7XFxuICAgICAgICBmbG9hdCBib3R0b20gPSBib3R0b21MZWZ0ICsgKGJvdHRvbVJpZ2h0IC0gYm90dG9tTGVmdCkgKiBmcmFjUkMueTtcXG4gICAgICAgIGZsb2F0IG5ld1ZhbHVlID0gdG9wICsgKGJvdHRvbSAtIHRvcCkgKiBmcmFjUkMueDtcXG5cXG4gICAgICAgIHNldE91dHB1dChuZXdWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIn19KCkscmk9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy51c2VzUGFja2VkVGV4dHVyZXM9ITAsdGhpcy5vdXRwdXRTaGFwZT1bXTt2YXIgbz10WzBdLGE9dFsxXSxpPXRbMl0scz10WzNdO3RoaXMub3V0cHV0U2hhcGU9W28sZSxuLHNdO3ZhciB1PVtyJiZlPjE/YS0xOmEsciYmbj4xP2ktMTppXSxsPVtyJiZlPjE/ZS0xOmUsciYmbj4xP24tMTpuXTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgdmVjMyBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDID0gdmVjMyhcXG4gICAgICAgICAgXCIrdVswXS9sWzBdK1wiLFxcbiAgICAgICAgICBcIit1WzFdL2xbMV0rXCIsXFxuICAgICAgICAgIFwiK3VbMV0vbFsxXStcIik7XFxuICAgICAgY29uc3QgdmVjMyBpbnB1dFNoYXBlUkMgPSB2ZWMzKFwiK2ErXCIuMCwgXCIraStcIi4wLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIitpK1wiLjApO1xcblxcbiAgICAgIGZsb2F0IGdldEFWYWx1ZShpbnQgYiwgaW50IHIsIGludCBjLCBpbnQgZCkge1xcbiAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoZ2V0QShiLCByLCBjLCBkKSwgdmVjMihjLCBkKSk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIC8vIENhbGN1bGF0ZSB2YWx1ZXMgZm9yIG5leHQgY29sdW1uIGluIHlSQy56LlxcbiAgICAgICAgaXZlYzMgeVJDID0gY29vcmRzLnl6eiArIGl2ZWMzKDAsIDAsIDEpO1xcblxcbiAgICAgICAgLy8gRnJhY3Rpb25hbCBzb3VyY2UgaW5kZXguXFxuICAgICAgICB2ZWMzIHNvdXJjZUZyYWNJbmRleFJDID0gdmVjMyh5UkMpICogZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQztcXG5cXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGZvdXIgaW50ZWdlciBpbmRpY2VzLlxcbiAgICAgICAgaXZlYzMgc291cmNlRmxvb3JSQyA9IGl2ZWMzKHNvdXJjZUZyYWNJbmRleFJDKTtcXG4gICAgICAgIGl2ZWMzIHNvdXJjZUNlaWxSQyA9IGl2ZWMzKFxcbiAgICAgICAgICBtaW4oaW5wdXRTaGFwZVJDIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWNJbmRleFJDKSkpO1xcbiAgICAgICAgXFxuICAgICAgICAvLyBTaG91bGQgd2UgY2FsY3VsYXRlIG5leHQgY29sdW1uIGFuZCByb3cgZWxlbWVudHMgaW4gMngyIHBhY2tlZCBjZWxsLlxcbiAgICAgICAgYm9vbCBoYXNOZXh0Q29sID0gZCA8IFwiKyhzLTEpK1wiOyBcXG4gICAgICAgIGJvb2wgaGFzTmV4dFJvdyA9IGNvb3Jkcy56IDwgXCIrKG4tMSkrXCI7XFxuXFxuICAgICAgICAvLyBJbiBwYXJhbGxlbCwgY29uc3RydWN0IGZvdXIgY29ybmVycyBmb3IgYWxsIGZvdXIgY29tcG9uZW50cyBpblxcbiAgICAgICAgLy8gcGFja2VkIDJ4MiBjZWxsLlxcbiAgICAgICAgdmVjNCB0b3BMZWZ0ID0gdmVjNChcXG4gICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy55LCBkKSxcXG4gICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUZsb29yUkMueSwgZCArIDEpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnosIGQpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID9cXG4gICAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnosIGQgKyAxKSA6IDAuMCk7XFxuXFxuICAgICAgICB2ZWM0IGJvdHRvbUxlZnQgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUZsb29yUkMueSwgZCksXFxuICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUZsb29yUkMueSwgZCArIDEpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUZsb29yUkMueiwgZClcXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcXG4gICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgP1xcbiAgICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlRmxvb3JSQy56LCBkICsgMSkgOiAwLjApO1xcblxcbiAgICAgICAgdmVjNCB0b3BSaWdodCA9IHZlYzQoXFxuICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUNlaWxSQy55LCBkKSxcXG4gICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUNlaWxSQy55LCBkICsgMSlcXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcXG4gICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUNlaWxSQy56LCBkKVxcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxcbiAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/XFxuICAgICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnosIGQgKyAxKSA6IDAuMCk7XFxuXFxuICAgICAgICB2ZWM0IGJvdHRvbVJpZ2h0ID0gdmVjNChcXG4gICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueSwgZCksXFxuICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUNlaWxSQy55LCBkICsgMSlcXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcXG4gICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlQ2VpbFJDLnosIGQpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID9cXG4gICAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUNlaWxSQy56LCBkICsgMSkgOiAwLjApO1xcblxcbiAgICAgICAgdmVjMyBmcmFjUkMgPSBzb3VyY2VGcmFjSW5kZXhSQyAtIHZlYzMoc291cmNlRmxvb3JSQyk7XFxuXFxuICAgICAgICB2ZWM0IHRvcCA9IG1peCh0b3BMZWZ0LCB0b3BSaWdodCwgZnJhY1JDLnl5enopO1xcbiAgICAgICAgdmVjNCBib3R0b20gPSBtaXgoYm90dG9tTGVmdCwgYm90dG9tUmlnaHQsIGZyYWNSQy55eXp6KTtcXG4gICAgICAgIHZlYzQgbmV3VmFsdWUgPSBtaXgodG9wLCBib3R0b20sIGZyYWNSQy54KTtcXG5cXG4gICAgICAgIHNldE91dHB1dChuZXdWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIn19KCksb2k9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9ZS5zaGFwZTt2YXIgcj1lLnNoYXBlLG89clsxXSxhPXJbMl0saT10LnNoYXBlLHM9aVsxXSx1PWlbMl0sbD1bbiYmcz4xP28tMTpvLG4mJnU+MT9hLTE6YV0sYz1bbiYmcz4xP3MtMTpzLG4mJnU+MT91LTE6dV0saD1sWzBdL2NbMF0scD1sWzFdL2NbMV0sZj0xL2gsZD0xL3Asdj0yKk1hdGguY2VpbChmKSsyLG09MipNYXRoLmNlaWwoZCkrMjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcbiAgICAgICAgaW50IHIgPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgYyA9IGNvb3Jkc1syXTtcXG5cXG4gICAgICAgIGZsb2F0IGFjY3VtdWxhdG9yID0gMC4wO1xcblxcbiAgICAgICAgY29uc3QgZmxvYXQgaGVpZ2h0U2NhbGUgPSBmbG9hdChcIitoK1wiKTtcXG4gICAgICAgIGNvbnN0IGZsb2F0IHdpZHRoU2NhbGUgPSBmbG9hdChcIitwK1wiKTtcXG5cXG4gICAgICAgIGNvbnN0IGZsb2F0IGludkhlaWdodFNjYWxlID0gZmxvYXQoXCIrZitcIik7XFxuICAgICAgICBjb25zdCBmbG9hdCBpbnZXaWR0aFNjYWxlID0gZmxvYXQoXCIrZCtcIik7XFxuXFxuICAgICAgICBjb25zdCBpbnQgd2luSGVpZ2h0ID0gaW50KFwiK3YrXCIpO1xcbiAgICAgICAgY29uc3QgaW50IHdpbldpZHRoID0gaW50KFwiK20rXCIpO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSBib3VuZHMgZm9yIHdoZXJlIGluIGR5IHdlIHdpbGwgbG9va1xcbiAgICAgICAgZmxvYXQgc3RhcnRSTGVycCA9IGZsb29yKGZsb2F0KHIpICogaW52SGVpZ2h0U2NhbGUpO1xcbiAgICAgICAgaW50IHN0YXJ0RHlSID0gaW50KGZsb29yKHN0YXJ0UkxlcnAgLSBmbG9hdCh3aW5IZWlnaHQgLyAyKSkpO1xcblxcbiAgICAgICAgZmxvYXQgc3RhcnRDTGVycCA9IGZsb29yKGZsb2F0KGMpICogaW52V2lkdGhTY2FsZSk7XFxuICAgICAgICBpbnQgc3RhcnREeUMgPSBpbnQoZmxvb3Ioc3RhcnRDTGVycCAtIGZsb2F0KHdpbldpZHRoIC8gMikpKTtcXG5cXG4gICAgICAgIC8vIExvb3Agb3ZlciBkeVxcbiAgICAgICAgZm9yIChpbnQgZHlST2Zmc2V0ID0gMDsgZHlST2Zmc2V0IDwgd2luSGVpZ2h0OyBkeVJPZmZzZXQrKykge1xcbiAgICAgICAgICBpbnQgZHlSID0gZHlST2Zmc2V0ICsgc3RhcnREeVI7XFxuXFxuICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIHdpbmRvdyBleGNlZWRpbmcgdGhlIGJvdW5kcyBvZiBkeVxcbiAgICAgICAgICBpZiAoZHlSIDwgMCB8fCBkeVIgPj0gXCIrcytcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IGR5Q09mZnNldCA9IDA7IGR5Q09mZnNldCA8IHdpbldpZHRoOyBkeUNPZmZzZXQrKykge1xcbiAgICAgICAgICAgIGludCBkeUMgPSBkeUNPZmZzZXQgKyBzdGFydER5QztcXG5cXG4gICAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHRoZSB3aW5kb3cgZXhjZWVkaW5nIHRoZSBib3VuZHMgb2YgZHlcXG4gICAgICAgICAgICBpZiAoZHlDIDwgMCB8fCBkeUMgPj0gXCIrdStcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZsb2F0IHNvdXJjZUZyYWNSb3cgPVxcbiAgICAgICAgICAgICAgZmxvYXQoXCIrbFswXStcIikgKlxcbiAgICAgICAgICAgICAgICAoZmxvYXQoZHlSKSAvIGZsb2F0KFwiK2NbMF0rXCIpKTtcXG5cXG4gICAgICAgICAgICBmbG9hdCBzb3VyY2VGcmFjQ29sID1cXG4gICAgICAgICAgICAgICAgZmxvYXQoXCIrbFsxXStcIikgKlxcbiAgICAgICAgICAgICAgICAgIChmbG9hdChkeUMpIC8gZmxvYXQoXCIrY1sxXStcIikpO1xcblxcbiAgICAgICAgICAgIGludCBzb3VyY2VOZWFyZXN0Um93ID0gaW50KG1pbihcXG4gICAgICAgICAgICAgICAgZmxvYXQoaW50KFwiK28rXCIpIC0gMSksXFxuICAgICAgICAgICAgICAgIFwiK24rXCIgPyBmbG9hdChyb3VuZChzb3VyY2VGcmFjUm93KSkgOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdChmbG9vcihzb3VyY2VGcmFjUm93KSkpKTtcXG5cXG4gICAgICAgICAgICBpbnQgc291cmNlTmVhcmVzdENvbCA9IGludChtaW4oXFxuICAgICAgICAgICAgICAgIGZsb2F0KGludChcIithK1wiKSAtIDEpLFxcbiAgICAgICAgICAgICAgICBcIituK1wiID8gZmxvYXQocm91bmQoc291cmNlRnJhY0NvbCkpIDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQoZmxvb3Ioc291cmNlRnJhY0NvbCkpKSk7XFxuXFxuICAgICAgICAgICAgaWYgKHIgPT0gc291cmNlTmVhcmVzdFJvdyAmJiBjID09IHNvdXJjZU5lYXJlc3RDb2wpIHtcXG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yICs9IGdldER5KGIsIGR5UiwgZHlDLCBkKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIC8vIEVuZCBsb29wIG92ZXIgZHlcXG5cXG4gICAgICAgIHNldE91dHB1dChhY2N1bXVsYXRvcik7XFxuICAgICAgfVxcbiAgICBcIn19KCksYWk9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXTt2YXIgbz10WzBdLGE9dFsxXSxpPXRbMl0scz10WzNdO3RoaXMub3V0cHV0U2hhcGU9W28sZSxuLHNdO3ZhciB1PVtyJiZlPjE/YS0xOmEsciYmbj4xP2ktMTppXSxsPVtyJiZlPjE/ZS0xOmUsciYmbj4xP24tMTpuXSxjPXI/XCIwLjVcIjpcIjAuMFwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCB2ZWMyIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkMgPSB2ZWMyKFxcbiAgICAgICAgICBcIit1WzBdL2xbMF0rXCIsXFxuICAgICAgICAgIFwiK3VbMV0vbFsxXStcIik7XFxuICAgICAgY29uc3QgdmVjMiBpbnB1dFNoYXBlUkMgPSB2ZWMyKFwiK2ErXCIuMCwgXCIraStcIi4wKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICBpdmVjMiB5UkMgPSBjb29yZHMueXo7XFxuXFxuICAgICAgICAvLyBGcmFjdGlvbmFsIHNvdXJjZSBpbmRleC5cXG4gICAgICAgIHZlYzIgc291cmNlRnJhY0luZGV4UkMgPSB2ZWMyKHlSQykgKiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDO1xcblxcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29vcmRpbmF0b3JzIG9mIG5lYXJlc3QgbmVpZ2hib3IgcG9pbnQuXFxuICAgICAgICBpdmVjMiBzb3VyY2VOZWFyZXN0UkMgPSBpdmVjMihcXG4gICAgICAgICAgbWluKGlucHV0U2hhcGVSQyAtIDEuMCwgZmxvb3Ioc291cmNlRnJhY0luZGV4UkMgKyBcIitjK1wiKSkpO1xcblxcbiAgICAgICAgZmxvYXQgbmV3VmFsdWUgPSBnZXRBKGIsIHNvdXJjZU5lYXJlc3RSQy54LCBzb3VyY2VOZWFyZXN0UkMueSwgZCk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLGlpPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl07dmFyIG49dC5sZW5ndGg7aWYobj40KXRocm93IG5ldyBFcnJvcihcIldlYkdMIGJhY2tlbmQ6IFJldmVyc2Ugb2YgcmFuay1cIituK1wiIHRlbnNvciBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtpZih0aGlzLm91dHB1dFNoYXBlPXQsMSE9PW4pe3ZhciByPXQubWFwKGZ1bmN0aW9uKG4scil7cmV0dXJuIGZ1bmN0aW9uKG4pe3JldHVybi0xIT09ZS5pbmRleE9mKG4pJiYxIT09dFtuXT90W25dK1wiIC0gY29vcmRzW1wiK24rXCJdIC0gMVwiOlwiY29vcmRzW1wiK24rXCJdXCJ9KHIpfSkuam9pbihcIixcIiksbz1ibyhuKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbytcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRYKFwiK3IrXCIpKTtcXG4gICAgICB9XFxuICAgIFwifWVsc2UgdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpbnQgY29vcmQgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgc2V0T3V0cHV0KGdldFgoXCIrdFswXStcIiAtIGNvb3JkIC0gMSkpO1xcbiAgICAgICAgfVxcbiAgICAgIFwifX0oKSxzaT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwO3ZhciBuPXQubGVuZ3RoO2lmKG4+NCl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBiYWNrZW5kOiBSZXZlcnNlIG9mIHJhbmstXCIrbitcIiB0ZW5zb3IgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7dGhpcy5vdXRwdXRTaGFwZT10O3ZhciByPW9vKFwicmNcIixuKSxvPXJbbi0xXStcIiArIDEgPCBcIit0aGlzLm91dHB1dFNoYXBlW24tMV0sYT1yW24tMl0rXCIgKyAxIDwgXCIrdGhpcy5vdXRwdXRTaGFwZVtuLTJdLGk9Ym8obik7ZnVuY3Rpb24gcyhuKXt2YXIgcj10Lm1hcChmdW5jdGlvbihyLG8pe3JldHVybiBmdW5jdGlvbihuLHIpe3JldHVybi0xIT09ZS5pbmRleE9mKG4pJiYxIT09dFtuXT90W25dK1wiIC0gXCIrcltuXStcIiAtIDFcIjpcIlwiK3Jbbl19KG8sbil9KTtyZXR1cm5cImdldENoYW5uZWwoZ2V0WChcIityLmpvaW4oXCIsXCIpK1wiKSwgdmVjMihcIityLnNsaWNlKC0yKS5qb2luKFwiLFwiKStcIikpXCJ9dGhpcy51c2VyQ29kZT0xPT09bj9cIlxcbiAgICAgICAgdm9pZCBtYWluKCl7XFxuICAgICAgICAgIGludCByYyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcbiAgICAgICAgICByZXN1bHQuciA9IGdldENoYW5uZWwoZ2V0WChcIit0WzBdK1wiIC0gcmMgLSAxKSxcXG4gICAgICAgICAgICBcIit0WzBdK1wiIC0gcmMgLSAxKTtcXG4gICAgICAgICAgaWYoXCIrbytcIil7XFxuICAgICAgICAgICAgICByZXN1bHQuZyA9IGdldENoYW5uZWwoZ2V0WChcIit0WzBdK1wiIC0gKHJjICArIDEpIC0gMSksXFxuICAgICAgICAgICAgICAgIFwiK3RbMF0rXCIgLSAocmMgICsgMSkgLSAxKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICAgIH1cXG4gICAgICBcIjpcIlxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBcIitpK1wiIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuICAgICAgICAgIHJlc3VsdC5yID0gXCIrZnVuY3Rpb24odCl7cmV0dXJuIHModCl9KHIuc2xpY2UoKSkrXCI7XFxuICAgICAgICAgIGlmKFwiK28rXCIpe1xcbiAgICAgICAgICAgIHJlc3VsdC5nID0gXCIrZnVuY3Rpb24odCl7cmV0dXJuIHRbbi0xXT1cIihcIit0W24tMV0rXCIgKyAxKVwiLHModCl9KHIuc2xpY2UoKSkrXCI7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYoXCIrYStcIikge1xcbiAgICAgICAgICAgIHJlc3VsdC5iID0gXCIrZnVuY3Rpb24odCl7cmV0dXJuIHRbbi0yXT1cIihcIit0W24tMl0rXCIgKyAxKVwiLHModCl9KHIuc2xpY2UoKSkrXCI7XFxuICAgICAgICAgICAgaWYoXCIrbytcIikge1xcbiAgICAgICAgICAgICAgcmVzdWx0LmEgPSBcIitmdW5jdGlvbih0KXtyZXR1cm4gdFtuLTFdPVwiKFwiK3Rbbi0xXStcIiArIDEpXCIsdFtuLTJdPVwiKFwiK3Rbbi0yXStcIiArIDEpXCIscyh0KX0oci5zbGljZSgpKStcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgICB9XFxuICAgIFwifX0oKSx1aT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1pJiYoaT0hMCksdGhpcy52YXJpYWJsZU5hbWVzPVtcInVwZGF0ZXNcIixcImluZGljZXNcIixcImRlZmF1bHRWYWx1ZVwiXSx0aGlzLm91dHB1dFNoYXBlPWE7dmFyIHM9Ym8oby5sZW5ndGgpLHU9Ym8oYS5sZW5ndGgpLGw9XCJcIjsxPT09bj9sPVwiaVwiOjI9PT1uJiYobD1cImksIGpcIik7dmFyIGM9XCJnZXRJbmRpY2VzKFwiK2wrXCIpXCIsaD1cIlwiOzE9PT1yP2g9XCJpXCI6Mj09PXImJihoPVwiaSwgY29vcmRzWzFdXCIpO3ZhciBwPVwiZ2V0VXBkYXRlcyhcIitoK1wiKVwiLGY9ZT4xP1wic3RyaWRlc1tqXVwiOlwic3RyaWRlc1wiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICAgIFwiK3MrXCIgc3RyaWRlcyA9IFwiK3MrXCIoXCIrbytcIik7XFxuXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIFwiK3UrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGZsb2F0IHN1bSA9IDAuMDtcXG4gICAgICAgICAgYm9vbCBmb3VuZCA9IGZhbHNlO1xcbiAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK3QrXCI7IGkrKykge1xcbiAgICAgICAgICAgIGludCBmbGF0dGVuZWRJbmRleCA9IDA7XFxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBcIitlK1wiOyBqKyspIHtcXG4gICAgICAgICAgICAgIGludCBpbmRleCA9IHJvdW5kKFwiK2MrXCIpO1xcbiAgICAgICAgICAgICAgZmxhdHRlbmVkSW5kZXggKz0gaW5kZXggKiBcIitmK1wiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoZmxhdHRlbmVkSW5kZXggPT0gY29vcmRzWzBdKSB7XFxuICAgICAgICAgICAgICBzdW0gKz0gXCIrcCtcIjtcXG4gICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc2V0T3V0cHV0KG1peChnZXREZWZhdWx0VmFsdWUoKSwgc3VtLCBmbG9hdChmb3VuZCkpKTtcXG4gICAgICAgIH1cXG4gICAgICBcIn19KCksbGk9ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwic2VnbWVudElkc1wiXTt2YXIgbj10LndpbmRvd1NpemUscj10LmJhdGNoU2l6ZSxvPXQuaW5TaXplLGE9dC5udW1TZWdtZW50cyxpPWEqTWF0aC5jZWlsKG8vbik7dGhpcy5vdXRwdXRTaGFwZT1bcixpXTt2YXIgcz00Kk1hdGguZmxvb3Iobi80KSx1PW4lNCxsPVwiXFxuICAgICAgICBzdW1WYWx1ZSArPSBkb3QodmFsdWVzLCBzZWdGaWx0ZXIpO1xcbiAgICBcIixjPVwiXCI7byVuPjAmJihjPVwiXFxuICAgICAgICBpZiAoaW5JZHggPCAwIHx8IGluSWR4ID49IFwiK28rXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIGluaXRpYWxpemF0aW9uVmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgXCIpO3ZhciBoPVwiXCI7byVuPjAmJihoPVwiXFxuICAgICAgICBpZiAoaW5JZHggPCAwIHx8IGluSWR4ID49IFwiK28rXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIC0xLjA7XFxuICAgICAgICB9XFxuICAgICAgXCIpLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBmbG9hdCBpbml0aWFsaXphdGlvblZhbHVlID0gMC4wO1xcblxcbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IGluSWR4KSB7XFxuICAgICAgICBcIitjK1wiXFxuICAgICAgICByZXR1cm4gZ2V0WChiYXRjaCwgaW5JZHgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBmbG9hdCBnZXRTZWdtZW50SWRBdEluZGV4KGludCBpbklkeCkge1xcbiAgICAgICAgXCIraCtcIlxcbiAgICAgICAgcmV0dXJuIGdldFNlZ21lbnRJZHMoaW5JZHgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBvdXRJZHggPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgaW5PZmZzZXQgPSBpbnQoZmxvb3IoZmxvYXQob3V0SWR4KSAvIGZsb2F0KFxcbiAgICAgICAgICBcIithK1wiKSkgKiBmbG9hdChcIituK1wiKSk7XFxuICAgICAgICBpbnQgY3VycmVudFNlZyA9IGludChtb2QoZmxvYXQob3V0SWR4KSwgZmxvYXQoXCIrYStcIikpKTtcXG5cXG4gICAgICAgIGZsb2F0IHN1bVZhbHVlID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIitzK1wiOyBpICs9IDQpIHtcXG4gICAgICAgICAgaW50IGluSWR4ID0gaW5PZmZzZXQgKyBpO1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAyKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAzKVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICB2ZWM0IHNlZ0ZpbHRlciA9IHZlYzQoXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHgpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAxKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMikpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDMpKSA9PSBjdXJyZW50U2VnID8gMSA6IDBcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIrbCtcIlxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaW50IGluSWR4ID0gaW5PZmZzZXQgKyBcIitzK1wiO1xcbiAgICAgICAgaWYgKFwiKygxPT09dSkrXCIpIHtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgaW50IGluSWR4U2VnID0gaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHgpKTtcXG5cXG4gICAgICAgICAgdmVjNCBzZWdGaWx0ZXIgPSB2ZWM0KFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4KSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIDAsXFxuICAgICAgICAgICAgMCxcXG4gICAgICAgICAgICAwXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK2wrXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIrKDI9PT11KStcIikge1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgdmVjNCBzZWdGaWx0ZXIgPSB2ZWM0KFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4KSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMSkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICAgIDAsXFxuICAgICAgICAgICAgICAwXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK2wrXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIrKDM9PT11KStcIikge1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAyKSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIHZlYzQgc2VnRmlsdGVyID0gdmVjNChcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDEpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAyKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIDBcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIrbCtcIlxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KHN1bVZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxjaT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbil7dmFyIHIsbztpZih0aGlzLnZhcmlhYmxlTmFtZXM9W1wiY1wiLFwiYVwiLFwiYlwiXSx0aGlzLm91dHB1dFNoYXBlPWUsbj40KXRocm93IEVycm9yKFwiV2hlcmUgZm9yIHJhbmsgXCIrbitcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtpZigxPT09bilvPVwicmVzUkNcIixyPVwicmVzUkNcIjtlbHNle2Zvcih2YXIgYT1bXCJyZXNSQy54XCIsXCJyZXNSQy55XCIsXCJyZXNSQy56XCIsXCJyZXNSQy53XCJdLGk9W10scz1bXSx1PTA7dTxlLmxlbmd0aDt1Kyspcy5wdXNoKFwiXCIrYVt1XSksdTx0JiZpLnB1c2goXCJcIithW3VdKTtyPWkuam9pbigpLG89cy5qb2luKCl9dmFyIGw9Ym8obik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK2wrXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGNWYWwgPSBnZXRDKFwiK3IrXCIpO1xcbiAgICAgICAgaWYgKGNWYWwgPj0gMS4wKSB7XFxuICAgICAgICAgIHNldE91dHB1dChnZXRBKFwiK28rXCIpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHNldE91dHB1dChnZXRCKFwiK28rXCIpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIFwifX0oKSxoaT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInNvdXJjZVwiXSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy5yYW5rPXQubGVuZ3RoO3ZhciBlLG49Ym8odGhpcy5yYW5rKSxyPVwidW5pZm9ybSBpbnQgc3RhcnRbXCIrdGhpcy5yYW5rK1wiXTtcIixvPWZ1bmN0aW9uKHQpe2lmKDE9PT10KXJldHVyblwic291cmNlTG9jXCI7aWYodDw9NilyZXR1cm4gcGkuc2xpY2UoMCx0KS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJzb3VyY2VMb2MuXCIrdH0pLmpvaW4oXCIsXCIpO3Rocm93IEVycm9yKFwiU2xpY2luZyBmb3IgcmFuayBcIit0K1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpfSh0aGlzLnJhbmspO2U9XCJcXG4gICAgICAgIFwiK24rXCIgc291cmNlTG9jO1xcbiAgICAgICAgXCIrbitcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIFwiK3QubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJzb3VyY2VMb2MuXCIrcGlbZV0rXCIgPSBzdGFydFtcIitlK1wiXSArIGNvb3Jkcy5cIitwaVtlXStcIjtcIn0pLmpvaW4oXCJcXG5cIikrXCJcXG4gICAgICBcIix0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgXCIrcitcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK2UrXCJcXG4gICAgICAgIHNldE91dHB1dChnZXRTb3VyY2UoXCIrbytcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO2lmKHQubGVuZ3RoIT09dGhpcy5yYW5rKXRocm93IEVycm9yKFwiVGhlIHJhbmsgKFwiK3RoaXMucmFuaytcIikgb2YgdGhlIHByb2dyYW0gbXVzdCBtYXRjaCB0aGUgbGVuZ3RoIG9mIHN0YXJ0IChcIit0Lmxlbmd0aCtcIilcIik7cmV0dXJuIGZ1bmN0aW9uKG4scil7bnVsbD09ZS5zdGFydExvYyYmKGUuc3RhcnRMb2M9bi5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KHIsXCJzdGFydFwiKSxudWxsPT1lLnN0YXJ0TG9jKXx8bi5nbC51bmlmb3JtMWl2KGUuc3RhcnRMb2MsdCl9fSx0fSgpLHBpPVtcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl07dmFyIGZpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wic291cmNlXCJdLHRoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnJhbms9dC5sZW5ndGg7dmFyIGU9Ym8odGhpcy5yYW5rKSxuPW9vKFwiY29vcmRzXCIsdGhpcy5yYW5rKSxyPW9vKFwic291cmNlTG9jXCIsdGhpcy5yYW5rKSxvPTE9PT10aGlzLnJhbms/XCJzb3VyY2VMb2NcIjpcInZlYzIoXCIrci5zbGljZSgtMikuam9pbigpK1wiKVwiLGE9XCJnZXRDaGFubmVsKGdldFNvdXJjZShcIityLmpvaW4oKStcIiksIFwiK28rXCIpXCIsaT1cIlxcbiAgICAgIHJlc3VsdC54ID0gXCIrYStcIjtcXG4gICAgICBpZiAoKytcIituW3RoaXMucmFuay0xXStcIiA8IFwiK3RbdGhpcy5yYW5rLTFdK1wiKSB7XFxuICAgICAgICArK1wiK3JbdGhpcy5yYW5rLTFdK1wiO1xcbiAgICAgICAgcmVzdWx0LnkgPSBcIithK1wiO1xcbiAgICAgICAgLS1cIityW3RoaXMucmFuay0xXStcIjtcXG4gICAgICB9XFxuICAgIFwiLHM9MT09PXRoaXMucmFuaz9cIlwiOlwiXFxuICAgICAgLS1cIituW3RoaXMucmFuay0xXStcIjtcXG4gICAgICBpZiAoKytcIituW3RoaXMucmFuay0yXStcIiA8IFwiK3RbdGhpcy5yYW5rLTJdK1wiKSB7XFxuICAgICAgICArK1wiK3JbdGhpcy5yYW5rLTJdK1wiO1xcbiAgICAgICAgcmVzdWx0LnogPSBcIithK1wiO1xcbiAgICAgICAgaWYgKCsrXCIrblt0aGlzLnJhbmstMV0rXCIgPCBcIit0W3RoaXMucmFuay0xXStcIikge1xcbiAgICAgICAgICArK1wiK3JbdGhpcy5yYW5rLTFdK1wiO1xcbiAgICAgICAgICByZXN1bHQudyA9IFwiK2ErXCI7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICBcIix1PXRoaXMucmFuazw9ND9cInNvdXJjZUxvYyA9IGNvb3JkcyArXFxuICAgICAgICAgICAgXCIrZStcIihcIit0Lm1hcChmdW5jdGlvbih0LGUpe3JldHVyblwic3RhcnRbXCIrZStcIl1cIn0pLmpvaW4oKStcIik7XCI6dC5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm4gcltlXStcIiA9IFwiK25bZV0rXCIgKyBzdGFydFtcIitlK1wiXTtcIn0pLmpvaW4oXCJcXG5cIik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHVuaWZvcm0gaW50IHN0YXJ0W1wiK3RoaXMucmFuaytcIl07XFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrZStcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIFwiK2UrXCIgc291cmNlTG9jO1xcbiAgICAgICAgXCIrdStcIiBcXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuICAgICAgICBcIitpK1wiXFxuICAgICAgICBcIitzK1wiXFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifXJldHVybiB0LnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztpZih0Lmxlbmd0aCE9PXRoaXMucmFuayl0aHJvdyBFcnJvcihcIlRoZSByYW5rIChcIit0aGlzLnJhbmsrXCIpIG9mIHRoZSBwcm9ncmFtIG11c3QgbWF0Y2ggdGhlIGxlbmd0aCBvZiBzdGFydCAoXCIrdC5sZW5ndGgrXCIpXCIpO3JldHVybiBmdW5jdGlvbihuLHIpe251bGw9PWUuc3RhcnRMb2MmJihlLnN0YXJ0TG9jPW4uZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyhyLFwic3RhcnRcIiksbnVsbD09ZS5zdGFydExvYyl8fG4uZ2wudW5pZm9ybTFpdihlLnN0YXJ0TG9jLHQpfX0sdH0oKSxkaT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXTt2YXIgbz1uLmZpbHRlcihmdW5jdGlvbih0LGUpe3JldHVybi0xPT09ci5pbmRleE9mKGUpfSk7dGhpcy5vdXRwdXRTaGFwZT1vO3ZhciBhPW4ubGVuZ3RoLGk9Ym8obi5sZW5ndGgpLHM9Ym8oby5sZW5ndGgpLHU9XCJcIjtpZigxPT09YSl1PVwiY29vcmRzICogc3RyaWRlcyArIGJlZ2luXCI7ZWxzZXt2YXIgbD0wO3U9bi5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm4tMT09PXIuaW5kZXhPZihlKT8obCsrLDE9PT1vLmxlbmd0aD9cImNvb3JkcyAqIHN0cmlkZXNbXCIrZStcIl0gKyBiZWdpbltcIitlK1wiXVwiOlwiY29vcmRzW1wiKyhsLTEpK1wiXSAqIHN0cmlkZXNbXCIrZStcIl0gKyBiZWdpbltcIitlK1wiXVwiKTpcImJlZ2luW1wiK2UrXCJdXCJ9KS5qb2luKFwiLFwiKX10aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgXCIraStcIiBiZWdpbiA9IFwiK2krXCIoXCIrdCtcIik7XFxuICAgICAgXCIraStcIiBzdHJpZGVzID0gXCIraStcIihcIitlK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIitzK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldFgoXCIrdStcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpLHZpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmdwZ3B1PXQsdGhpcy5udW1Vc2VkVGV4dHVyZXM9MCx0aGlzLm51bUZyZWVUZXh0dXJlcz0wLHRoaXMuZnJlZVRleHR1cmVzPXt9LHRoaXMubG9nRW5hYmxlZD0hMSx0aGlzLnVzZWRUZXh0dXJlcz17fX1yZXR1cm4gdC5wcm90b3R5cGUuYWNxdWlyZVRleHR1cmU9ZnVuY3Rpb24odCxlLG4pe3ZhciByLG89bWkoZSxuKSxhPWdpKHQsbyxuKTtpZihhIGluIHRoaXMuZnJlZVRleHR1cmVzfHwodGhpcy5mcmVlVGV4dHVyZXNbYV09W10pLGEgaW4gdGhpcy51c2VkVGV4dHVyZXN8fCh0aGlzLnVzZWRUZXh0dXJlc1thXT1bXSksdGhpcy5mcmVlVGV4dHVyZXNbYV0ubGVuZ3RoPjApe3RoaXMubnVtRnJlZVRleHR1cmVzLS0sdGhpcy5udW1Vc2VkVGV4dHVyZXMrKyx0aGlzLmxvZygpO3ZhciBpPXRoaXMuZnJlZVRleHR1cmVzW2FdLnNoaWZ0KCk7cmV0dXJuIHRoaXMudXNlZFRleHR1cmVzW2FdLnB1c2goaSksaX1yZXR1cm4gdGhpcy5udW1Vc2VkVGV4dHVyZXMrKyx0aGlzLmxvZygpLG89PT1sYS5QQUNLRURfMlgyX0ZMT0FUMzI/cj10aGlzLmdwZ3B1LmNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUodFswXSx0WzFdKTpvPT09bGEuUEFDS0VEXzJYMl9GTE9BVDE2P3I9dGhpcy5ncGdwdS5jcmVhdGVGbG9hdDE2UGFja2VkTWF0cml4VGV4dHVyZSh0WzBdLHRbMV0pOm89PT1sYS5VTlBBQ0tFRF9GTE9BVDMyP3I9dGhpcy5ncGdwdS5jcmVhdGVGbG9hdDMyTWF0cml4VGV4dHVyZSh0WzBdLHRbMV0pOm89PT1sYS5VTlBBQ0tFRF9GTE9BVDE2P3I9dGhpcy5ncGdwdS5jcmVhdGVGbG9hdDE2TWF0cml4VGV4dHVyZSh0WzBdLHRbMV0pOm89PT1sYS5QQUNLRURfNFgxX1VOU0lHTkVEX0JZVEUmJihyPXRoaXMuZ3BncHUuY3JlYXRlVW5zaWduZWRCeXRlc01hdHJpeFRleHR1cmUodFswXSx0WzFdKSksdGhpcy51c2VkVGV4dHVyZXNbYV0ucHVzaChyKSxyfSx0LnByb3RvdHlwZS5yZWxlYXNlVGV4dHVyZT1mdW5jdGlvbih0LGUsbixyKXtpZihudWxsIT10aGlzLmZyZWVUZXh0dXJlcyl7dmFyIG89Z2koZSxtaShuLHIpLHIpO28gaW4gdGhpcy5mcmVlVGV4dHVyZXN8fCh0aGlzLmZyZWVUZXh0dXJlc1tvXT1bXSksdGhpcy5mcmVlVGV4dHVyZXNbb10ucHVzaCh0KSx0aGlzLm51bUZyZWVUZXh0dXJlcysrLHRoaXMubnVtVXNlZFRleHR1cmVzLS07dmFyIGE9dGhpcy51c2VkVGV4dHVyZXNbb10saT1hLmluZGV4T2YodCk7aWYoaTwwKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZWxlYXNlIGEgdGV4dHVyZSB0aGF0IHdhcyBuZXZlciBwcm92aWRlZCBieSB0aGlzIHRleHR1cmUgbWFuYWdlclwiKTthLnNwbGljZShpLDEpLHRoaXMubG9nKCl9fSx0LnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24oKXtpZih0aGlzLmxvZ0VuYWJsZWQpe3ZhciB0PXRoaXMubnVtRnJlZVRleHR1cmVzK3RoaXMubnVtVXNlZFRleHR1cmVzO2NvbnNvbGUubG9nKFwiRnJlZS9Vc2VkXCIsdGhpcy5udW1GcmVlVGV4dHVyZXMrXCIgLyBcIit0aGlzLm51bVVzZWRUZXh0dXJlcyxcIihcIit0K1wiKVwiKX19LHQucHJvdG90eXBlLmdldE51bVVzZWRUZXh0dXJlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm51bVVzZWRUZXh0dXJlc30sdC5wcm90b3R5cGUuZ2V0TnVtRnJlZVRleHR1cmVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubnVtRnJlZVRleHR1cmVzfSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZihudWxsIT10aGlzLmZyZWVUZXh0dXJlcyl7Zm9yKHZhciBlIGluIHRoaXMuZnJlZVRleHR1cmVzKXRoaXMuZnJlZVRleHR1cmVzW2VdLmZvckVhY2goZnVuY3Rpb24oZSl7dC5ncGdwdS5kZWxldGVNYXRyaXhUZXh0dXJlKGUpfSk7Zm9yKHZhciBlIGluIHRoaXMudXNlZFRleHR1cmVzKXRoaXMudXNlZFRleHR1cmVzW2VdLmZvckVhY2goZnVuY3Rpb24oZSl7dC5ncGdwdS5kZWxldGVNYXRyaXhUZXh0dXJlKGUpfSk7dGhpcy5mcmVlVGV4dHVyZXM9bnVsbCx0aGlzLnVzZWRUZXh0dXJlcz1udWxsLHRoaXMubnVtVXNlZFRleHR1cmVzPTAsdGhpcy5udW1GcmVlVGV4dHVyZXM9MH19LHR9KCk7ZnVuY3Rpb24gbWkodCxlKXtpZih0PT09dWEuVVBMT0FEKXJldHVybiBlP2xhLlBBQ0tFRF8yWDJfRkxPQVQzMjpsYS5VTlBBQ0tFRF9GTE9BVDMyO2lmKHQ9PT11YS5SRU5ERVJ8fG51bGw9PXQpcmV0dXJuIGU/YS5nZXRCb29sKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRFwiKT9sYS5QQUNLRURfMlgyX0ZMT0FUMzI6bGEuUEFDS0VEXzJYMl9GTE9BVDE2OmEuZ2V0Qm9vbChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIik/bGEuVU5QQUNLRURfRkxPQVQzMjpsYS5VTlBBQ0tFRF9GTE9BVDE2O2lmKHQ9PT11YS5ET1dOTE9BRHx8dD09PXVhLlBJWEVMUylyZXR1cm4gbGEuUEFDS0VEXzRYMV9VTlNJR05FRF9CWVRFO3Rocm93IG5ldyBFcnJvcihcIlVua25vd24gbG9naWNhbCB0ZXh0dXJlIHR5cGUgXCIrdCl9ZnVuY3Rpb24gZ2kodCxlLG4pe3JldHVybiB0WzBdK1wiX1wiK3RbMV0rXCJfXCIrZStcIl9cIitufXZhciB5aT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdO2Zvcih2YXIgbj1uZXcgQXJyYXkodC5sZW5ndGgpLHI9MDtyPG4ubGVuZ3RoO3IrKyluW3JdPXRbcl0qZVtyXTt0aGlzLm91dHB1dFNoYXBlPW4sdGhpcy5yYW5rPW4ubGVuZ3RoO3ZhciBvPWJvKHRoaXMucmFuayksYT1mdW5jdGlvbih0KXt2YXIgZT10Lmxlbmd0aDtpZihlPjUpdGhyb3cgRXJyb3IoXCJUaWxlIGZvciByYW5rIFwiK2UrXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7aWYoMT09PWUpcmV0dXJuXCJpbW9kKHJlc1JDLCBcIit0WzBdK1wiKVwiO2Zvcih2YXIgbj1bXCJyZXNSQy54XCIsXCJyZXNSQy55XCIsXCJyZXNSQy56XCIsXCJyZXNSQy53XCIsXCJyZXNSQy51XCJdLHI9W10sbz0wO288dC5sZW5ndGg7bysrKXIucHVzaChcImltb2QoXCIrbltvXStcIiwgXCIrdFtvXStcIilcIik7cmV0dXJuIHIuam9pbigpfSh0KTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbytcIiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldEEoXCIrYStcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9fSgpO3ZhciB4aT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdO2Zvcih2YXIgbj1uZXcgQXJyYXkodC5sZW5ndGgpLHI9MDtyPG4ubGVuZ3RoO3IrKyluW3JdPXRbZVtyXV07dGhpcy5vdXRwdXRTaGFwZT1uLHRoaXMucmFuaz1uLmxlbmd0aDt2YXIgbz1ibyh0aGlzLnJhbmspLGE9ZnVuY3Rpb24odCl7dmFyIGU9dC5sZW5ndGg7aWYoZT42KXRocm93IEVycm9yKFwiVHJhbnNwb3NlIGZvciByYW5rIFwiK2UrXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7Zm9yKHZhciBuPVtcInJlc1JDLnhcIixcInJlc1JDLnlcIixcInJlc1JDLnpcIixcInJlc1JDLndcIixcInJlc1JDLnVcIixcInJlc1JDLnZcIl0scj1uZXcgQXJyYXkoZSksbz0wO288dC5sZW5ndGg7bysrKXJbdFtvXV09bltvXTtyZXR1cm4gci5qb2luKCl9KGUpO3RoaXMudXNlckNvZGU9XCJcXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIFwiK28rXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICBzZXRPdXRwdXQoZ2V0QShcIithK1wiKSk7XFxuICAgIH1cXG4gICAgXCJ9fSgpO3ZhciB3aT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwO2Zvcih2YXIgbj1uZXcgQXJyYXkodC5sZW5ndGgpLHI9MDtyPG4ubGVuZ3RoO3IrKyluW3JdPXRbZVtyXV07aWYodGhpcy5vdXRwdXRTaGFwZT1uLHRoaXMucmFuaz1uLmxlbmd0aCx0aGlzLnJhbms+Nil0aHJvdyBFcnJvcihcIlBhY2tlZCB0cmFuc3Bvc2UgZm9yIHJhbmsgXCIrdGhpcy5yYW5rK1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLlwiKTt2YXIgbz1ibyh0aGlzLnJhbmspLGE9cm8oXCJyY1wiLHRoaXMucmFuayksaT1uZXcgQXJyYXkodGhpcy5yYW5rKTtmb3Iocj0wO3I8ZS5sZW5ndGg7cisrKWlbZVtyXV09YVtyXTt2YXIgcz1cInZlYzIoXCIraS5zbGljZSgtMikuam9pbigpK1wiKVwiLHU9XCIrK1wiK2FbdGhpcy5yYW5rLTFdK1wiIDwgXCIrblt0aGlzLnJhbmstMV0sbD1cImdldENoYW5uZWwoZ2V0QShcIitpLmpvaW4oKStcIiksIFwiK3MrXCIpXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgXCIrbytcIiByYyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuICAgICAgcmVzdWx0WzBdID0gXCIrbCtcIjtcXG4gICAgICBpZihcIit1K1wiKSB7XFxuICAgICAgICByZXN1bHRbMV0gPSBcIitsK1wiO1xcbiAgICAgIH1cXG4gICAgICAtLVwiK2FbdGhpcy5yYW5rLTFdK1wiO1xcbiAgICAgIGlmKCsrXCIrYVt0aGlzLnJhbmstMl0rXCIgPCBcIituW3RoaXMucmFuay0yXStcIikge1xcbiAgICAgICAgcmVzdWx0WzJdID0gXCIrbCtcIjtcXG4gICAgICAgIGlmKFwiK3UrXCIpIHtcXG4gICAgICAgICAgcmVzdWx0WzNdID0gXCIrbCtcIjtcXG4gICAgICAgIH1cXG4gICAgICB9ICBcXG4gICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgfVxcbiAgICBcIn19KCksYmk9MS43NTgwOTkzNDA4NDczNzY4LENpPTEuMDUwNzAwOTg3MzU1NDgwNSxFaT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgZmxvYXQgdW5hcnlPcGVyYXRpb24oZmxvYXQgeCkge1xcbiAgICAgICAgXCIrZStcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCB4ID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCB5ID0gdW5hcnlPcGVyYXRpb24oeCk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQoeSk7XFxuICAgICAgfVxcbiAgICBcIn19KCksUmk9XCJpZiAoaXNuYW4oeCkpIHJldHVybiB4O1wiLFNpPVwicmV0dXJuIHg7XCIsTmk9UmkrXCJcXG4gIHJldHVybiAoeCA8IDAuMCkgPyAwLjAgOiB4O1xcblwiLGtpPVwiXFxuICAvLyBTdGFibGUgYW5kIEF0dHJhY3RpbmcgRml4ZWQgUG9pbnQgKDAsIDEpIGZvciBOb3JtYWxpemVkIFdlaWdodHMuXFxuICAvLyBzZWU6IGh0dHBzOi8vYXJ4aXYub3JnL2Ficy8xNzA2LjAyNTE1XFxuICBmbG9hdCBzY2FsZUFscGhhID0gXCIrYmkrXCI7XFxuICBmbG9hdCBzY2FsZSA9IFwiK0NpK1wiO1xcbiAgcmV0dXJuICh4ID49IDAuMCkgPyBzY2FsZSAqIHggOiBzY2FsZUFscGhhICogKGV4cCh4KSAtIDEuMCk7XFxuXCI7dmFyIElpPVwicmV0dXJuIGV4cCh4KTtcIixBaT1SaStcIlxcbiAgcmV0dXJuIHNpbih4KTtcXG5cIixUaT1SaStcIlxcbiAgcmV0dXJuIGNvcyh4KTtcXG5cIixEaT1SaStcIlxcbiAgcmV0dXJuIGF0YW4oeCk7XFxuXCIsT2k9UmkrXCJcXG4gIGlmICh4IDwgMS4wKSByZXR1cm4gTkFOO1xcbiAgcmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCAtIDEuMCkpO1wiLF9pPVJpK1wiXFxuICBpZiAoKHggPCAtMS4wKSB8fCAoeCA+IDEuMCkpIHJldHVybiBOQU47XFxuICByZXR1cm4gKGxvZygxLjAgKyB4KSAtIGxvZygxLjAgLSB4KSkgLyAyLjA7XCIsTWk9XCJyZXR1cm4geDtcIixGaT1cIlxcbiAgdmVjNCByZXN1bHQgPSB4ICogdmVjNChncmVhdGVyVGhhbkVxdWFsKHgsIHZlYzQoMC4wKSkpO1xcbiAgYnZlYzQgaXNOYU4gPSBpc25hbih4KTtcXG5cXG4gIHJlc3VsdC5yID0gaXNOYU4uciA/IHguciA6IHJlc3VsdC5yO1xcbiAgcmVzdWx0LmcgPSBpc05hTi5nID8geC5nIDogcmVzdWx0Lmc7XFxuICByZXN1bHQuYiA9IGlzTmFOLmIgPyB4LmIgOiByZXN1bHQuYjtcXG4gIHJlc3VsdC5hID0gaXNOYU4uYSA/IHguYSA6IHJlc3VsdC5hO1xcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIixCaT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMudXNlc1BhY2tlZFRleHR1cmVzPSEwLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdmVjNCB1bmFyeU9wZXJhdGlvbih2ZWM0IHgpIHtcXG4gICAgICAgIFwiK2UrXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgdmVjNCB4ID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IHkgPSB1bmFyeU9wZXJhdGlvbih4KTtcXG5cXG4gICAgICAgIHNldE91dHB1dCh5KTtcXG4gICAgICB9XFxuICAgIFwifX0oKSxQaT1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnVzZXNQYWNrZWRUZXh0dXJlcz0hMCx0aGlzLm91dHB1dFNoYXBlPXQ7dmFyIGU9dC5sZW5ndGgsbj1vbyhcInJjXCIsZSkscj1ibyhlKSxvPWZ1bmN0aW9uKHQsZSl7aWYoMT09PXQpcmV0dXJuXCJyY1wiO2Zvcih2YXIgbj1cIlwiLHI9MDtyPHQ7cisrKW4rPWVbcl0scjx0LTEmJihuKz1cIixcIik7cmV0dXJuIG59KGUsbiksYT1uLnNsaWNlKC0yKSxpPWU8PTE/XCJyY1wiOlwidmVjMihcIithLmpvaW4oXCIsXCIpK1wiKVwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIityK1wiIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IHBhY2tlZElucHV0ID0gZ2V0QShcIitvK1wiKTtcXG5cXG4gICAgICAgIHNldE91dHB1dChnZXRDaGFubmVsKHBhY2tlZElucHV0LCBcIitpK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIn19KCksTGk9e307dmFyIFdpPTYwMDt2YXIgVWk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKHRoaXMuZ3BncHU9dCx0aGlzLnBlbmRpbmdSZWFkPW5ldyBXZWFrTWFwLHRoaXMucGVuZGluZ0Rpc3Bvc2FsPW5ldyBXZWFrU2V0LHRoaXMuZGF0YVJlZkNvdW50PW5ldyBXZWFrTWFwLHRoaXMubnVtQnl0ZXNJbkdQVT0wLHRoaXMudXBsb2FkV2FpdE1zPTAsdGhpcy5kb3dubG9hZFdhaXRNcz0wLHRoaXMud2FybmVkQWJvdXRNZW1vcnk9ITEsdGhpcy5kaXNwb3NlZD0hMSwhYS5nZXRCb29sKFwiSEFTX1dFQkdMXCIpKXRocm93IG5ldyBFcnJvcihcIldlYkdMIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2VcIik7aWYobnVsbD09dCl7dmFyIGU9RnQoYS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKTt0aGlzLmJpbmFyeUNhY2hlPShuPWEuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSlpbiBMaT9MaVtuXTooTGlbbl09e30sTGlbbl0pLHRoaXMuZ3BncHU9bmV3IFdhKGUpLHRoaXMuY2FudmFzPWUuY2FudmFzLHRoaXMuZ3BncHVDcmVhdGVkTG9jYWxseT0hMH1lbHNlIHRoaXMuYmluYXJ5Q2FjaGU9e30sdGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5PSExLHRoaXMuY2FudmFzPXQuZ2wuY2FudmFzO3ZhciBuO3RoaXMudGV4dHVyZU1hbmFnZXI9bmV3IHZpKHRoaXMuZ3BncHUpLHRoaXMubnVtTUJCZWZvcmVXYXJuaW5nPW51bGw9PWEuZ2xvYmFsLnNjcmVlbj8xMDI0OmEuZ2xvYmFsLnNjcmVlbi5oZWlnaHQqYS5nbG9iYWwuc2NyZWVuLndpZHRoKndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKldpLzEwMjQvMTAyNCx0aGlzLnRleERhdGE9bmV3IFluKER0KX1yZXR1cm4gdC5wcm90b3R5cGUucmVnaXN0ZXI9ZnVuY3Rpb24odCxlLG4pe2lmKHRoaXMudGV4RGF0YS5oYXModCkpdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBidWZmZXIgaXMgYWxyZWFkeSByZWdpc3RlcmVkXCIpO3RoaXMudGV4RGF0YS5zZXQodCx7c2hhcGU6ZSxkdHlwZTpufSl9LHQucHJvdG90eXBlLmZyb21QaXhlbHM9ZnVuY3Rpb24odCxlKXtpZihudWxsPT10KXRocm93IG5ldyBFcnJvcihcInBpeGVscyBwYXNzZWQgdG8gdGYuYnJvd3Nlci5mcm9tUGl4ZWxzKCkgY2FuIG5vdCBiZSBudWxsXCIpO3ZhciBuPVt0LmhlaWdodCx0LndpZHRoXSxyPVt0LmhlaWdodCx0LndpZHRoLGVdO2lmKGEuZ2V0Qm9vbChcIklTX0JST1dTRVJcIikpe2lmKCEodCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnR8fHQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50fHx0IGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnR8fHQgaW5zdGFuY2VvZiBJbWFnZURhdGEpKXRocm93IG5ldyBFcnJvcihcInBpeGVscyBwYXNzZWQgdG8gdGYuYnJvd3Nlci5mcm9tUGl4ZWxzKCkgbXVzdCBiZSBlaXRoZXIgYW4gSFRNTFZpZGVvRWxlbWVudCwgSFRNTEltYWdlRWxlbWVudCwgSFRNTENhbnZhc0VsZW1lbnQgb3IgSW1hZ2VEYXRhLCBidXQgd2FzIFwiK3QuY29uc3RydWN0b3IubmFtZSk7aWYodCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpe2lmKG51bGw9PXRoaXMuZnJvbVBpeGVsczJEQ29udGV4dCl7aWYoXCJjb21wbGV0ZVwiIT09ZG9jdW1lbnQucmVhZHlTdGF0ZSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgRE9NIGlzIG5vdCByZWFkeSB5ZXQuIFBsZWFzZSBjYWxsIHRmLmJyb3dzZXIuZnJvbVBpeGVscygpIG9uY2UgdGhlIERPTSBpcyByZWFkeS4gT25lIHdheSB0byBkbyB0aGF0IGlzIHRvIGFkZCBhbiBldmVudCBsaXN0ZW5lciBmb3IgYERPTUNvbnRlbnRMb2FkZWRgIG9uIHRoZSBkb2N1bWVudCBvYmplY3RcIik7dGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpfXRoaXMuZnJvbVBpeGVsczJEQ29udGV4dC5jYW52YXMud2lkdGg9dC53aWR0aCx0aGlzLmZyb21QaXhlbHMyRENvbnRleHQuY2FudmFzLmhlaWdodD10LmhlaWdodCx0aGlzLmZyb21QaXhlbHMyRENvbnRleHQuZHJhd0ltYWdlKHQsMCwwLHQud2lkdGgsdC5oZWlnaHQpLHQ9dGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0LmNhbnZhc319dmFyIG89dGhpcy5tYWtlVGVuc29ySGFuZGxlKG4sXCJpbnQzMlwiKTt0aGlzLnRleERhdGEuZ2V0KG8uZGF0YUlkKS51c2FnZT11YS5QSVhFTFMsdGhpcy5ncGdwdS51cGxvYWRQaXhlbERhdGFUb1RleHR1cmUodGhpcy5nZXRUZXh0dXJlKG8uZGF0YUlkKSx0KTt2YXIgaT1uZXcgaWEocikscz10aGlzLmNvbXBpbGVBbmRSdW4oaSxbb10pO3JldHVybiB0aGlzLmRpc3Bvc2VEYXRhKG8uZGF0YUlkKSxzfSx0LnByb3RvdHlwZS5tYWtlVGVuc29ySGFuZGxlPWZ1bmN0aW9uKHQsZSl7dmFyIG49e307cmV0dXJuIHRoaXMucmVnaXN0ZXIobix0LGUpLHtkYXRhSWQ6bixzaGFwZTp0LGR0eXBlOmV9fSx0LnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbih0LGUpe2lmKG51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwiTWF0aEJhY2tlbmRXZWJHTC53cml0ZSgpOiB2YWx1ZXMgY2FuIG5vdCBiZSBudWxsXCIpO2lmKGEuZ2V0Qm9vbChcIkRFQlVHXCIpKWZvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO2lmKCFXdChyKSl0aHJvdyBFcnJvcihcIlRoZSB2YWx1ZSBcIityK1wiIGNhbm5vdCBiZSByZXByZXNlbnRlZCBvbiB0aGlzIGRldmljZS5cIil9dmFyIG89dGhpcy50ZXhEYXRhLmdldCh0KTtpZihcImNvbXBsZXg2NFwiPT09by5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgd3JpdGUgdG8gYSBjb21wbGV4NjQgZHR5cGUuIFBsZWFzZSB1c2UgdGYuY29tcGxleChyZWFsLCBpbWFnKS5cIik7dGhpcy5yZWxlYXNlR1BVRGF0YSh0KSxvLnVzYWdlPXVhLlVQTE9BRCxvLnZhbHVlcz1lfSx0LnByb3RvdHlwZS5yZWFkU3luYz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLnRleERhdGEuZ2V0KHQpLG49ZS52YWx1ZXMscj1lLmR0eXBlLG89ZS5jb21wbGV4VGVuc29ycyxhPWUuc2xpY2UsaT1lLnNoYXBlO2lmKG51bGwhPWEpe3ZhciBzPW5ldyBFaShpLFwicmV0dXJuIHg7XCIpLHU9dGhpcy5jb21waWxlQW5kUnVuKHMsW3tkYXRhSWQ6dCxzaGFwZTppLGR0eXBlOnJ9XSksbD10aGlzLnJlYWRTeW5jKHUuZGF0YUlkKTtyZXR1cm4gdS5kaXNwb3NlKCksbH1pZihudWxsIT1uKXJldHVybiB0aGlzLmNvbnZlcnRBbmRDYWNoZU9uQ1BVKHQpO2lmKFwic3RyaW5nXCI9PT1yKXJldHVybiBuO3ZhciBjLGgscD1udWxsIT10aGlzLmFjdGl2ZVRpbWVyczsocCYmKGM9cGVyZm9ybWFuY2Uubm93KCkpLFwiY29tcGxleDY0XCI9PT1yKT9oPWVyKG8ucmVhbC5kYXRhU3luYygpLG8uaW1hZy5kYXRhU3luYygpKTpoPXRoaXMuZ2V0VmFsdWVzRnJvbVRleHR1cmUodCk7cmV0dXJuIHAmJih0aGlzLmRvd25sb2FkV2FpdE1zKz1wZXJmb3JtYW5jZS5ub3coKS1jKSx0aGlzLmNvbnZlcnRBbmRDYWNoZU9uQ1BVKHQsaCl9LHQucHJvdG90eXBlLnJlYWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsbixyLGkscyx1LGwsYyxoLHAsZixkLHYsbSxnLHgsdyxiLEMsRSxSLFMsTixrLEksQSxULEQ7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOmlmKHRoaXMucGVuZGluZ1JlYWQuaGFzKHQpKXJldHVybiByPXRoaXMucGVuZGluZ1JlYWQuZ2V0KHQpLFsyLG5ldyBQcm9taXNlKGZ1bmN0aW9uKHQpe3JldHVybiByLnB1c2godCl9KV07aWYoaT10aGlzLnRleERhdGEuZ2V0KHQpLHM9aS50ZXh0dXJlLHU9aS52YWx1ZXMsbD1pLnRleFNoYXBlLGM9aS5pc1BhY2tlZCxoPWkuc2hhcGUscD1pLnNsaWNlLGY9aS5kdHlwZSxkPWkuY29tcGxleFRlbnNvcnMsbnVsbCE9cClyZXR1cm4gdj1uZXcgRWkoaCxcInJldHVybiB4O1wiKSxtPXRoaXMuY29tcGlsZUFuZFJ1bih2LFt7ZGF0YUlkOnQsc2hhcGU6aCxkdHlwZTpmfV0pLGc9dGhpcy5yZWFkKG0uZGF0YUlkKSxtLmRpc3Bvc2UoKSxbMixnXTtpZihudWxsIT11KXJldHVyblsyLHRoaXMuY29udmVydEFuZENhY2hlT25DUFUodCldO2lmKHRoaXMucGVuZGluZ1JlYWQuc2V0KHQsW10pLCFhLmdldEJvb2woXCJXRUJHTF9ET1dOTE9BRF9GTE9BVF9FTkFCTEVEXCIpJiYyPT09YS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKXRocm93IG5ldyBFcnJvcihcInRlbnNvci5kYXRhKCkgd2l0aCBXRUJHTF9ET1dOTE9BRF9GTE9BVF9FTkFCTEVEPWZhbHNlIGFuZCBXRUJHTF9WRVJTSU9OPTIgbm90IHlldCBzdXBwb3J0ZWQuXCIpO3JldHVybiB4PW51bGwsXCJjb21wbGV4NjRcIj09PWY/WzMsMl06KHc9bFsxXSxiPWxbMF0sYyYmKGU9ZGEobFswXSxsWzFdKSx3PWVbMF0sYj1lWzFdKSxhLmdldChcIldFQkdMX0JVRkZFUl9TVVBQT1JURURcIikmJih4PXRoaXMuZ3BncHUuY3JlYXRlQnVmZmVyRnJvbVRleHR1cmUocyxiLHcpKSxbNCx0aGlzLmdwZ3B1LmNyZWF0ZUFuZFdhaXRGb3JGZW5jZSgpXSk7Y2FzZSAxOm8uc2VudCgpLG8ubGFiZWw9MjtjYXNlIDI6cmV0dXJuXCJjb21wbGV4NjRcIiE9PWY/WzMsNF06WzQsUHJvbWlzZS5hbGwoW2QucmVhbC5kYXRhKCksZC5pbWFnLmRhdGEoKV0pXTtjYXNlIDM6cmV0dXJuIEU9by5zZW50KCksUj1FWzBdLFM9RVsxXSxDPWVyKFIsUyksWzMsNV07Y2FzZSA0Om51bGw9PXg/Qz10aGlzLmdldFZhbHVlc0Zyb21UZXh0dXJlKHQpOihOPXkoaCksYz8oaz1mZShoKSxJPTEsQT0xLGgubGVuZ3RoJiYobj1kZShoKSxJPW5bMF0sQT1uWzFdKSxDPXRoaXMuZ3BncHUuZG93bmxvYWRQYWNrZWRNYXRyaXhGcm9tQnVmZmVyKHgsayxJLEEsbFswXSxsWzFdKS5zdWJhcnJheSgwLE4pKTpDPXRoaXMuZ3BncHUuZG93bmxvYWRGbG9hdDMyTWF0cml4RnJvbUJ1ZmZlcih4LGxbMF0sbFsxXSkuc3ViYXJyYXkoMCxOKSksby5sYWJlbD01O2Nhc2UgNTpyZXR1cm4gVD10aGlzLmNvbnZlcnRBbmRDYWNoZU9uQ1BVKHQsQyksRD10aGlzLnBlbmRpbmdSZWFkLmdldCh0KSx0aGlzLnBlbmRpbmdSZWFkLmRlbGV0ZSh0KSxELmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIHQoVCl9KSx0aGlzLnBlbmRpbmdEaXNwb3NhbC5oYXModCkmJih0aGlzLnBlbmRpbmdEaXNwb3NhbC5kZWxldGUodCksdGhpcy5kaXNwb3NlRGF0YSh0KSksWzIsVF19fSl9KX0sdC5wcm90b3R5cGUuZ2V0VmFsdWVzRnJvbVRleHR1cmU9ZnVuY3Rpb24odCl7dmFyIGUsbj10aGlzLHI9dGhpcy50ZXhEYXRhLmdldCh0KSxvPXIuc2hhcGUsaT1yLmR0eXBlLHM9ci50ZXh0dXJlLHU9ci50ZXhTaGFwZSxsPXkobyk7aWYoYS5nZXRCb29sKFwiV0VCR0xfRE9XTkxPQURfRkxPQVRfRU5BQkxFRFwiKSl7aWYodGhpcy50ZXhEYXRhLmdldCh0KS5pc1BhY2tlZCl7dmFyIGM9ZmUobyksaD0xLHA9MTtyZXR1cm4gby5sZW5ndGgmJihoPShlPWRlKG8pKVswXSxwPWVbMV0pLHRoaXMuZ3BncHUuZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkVGV4dHVyZShzLGMsaCxwLHVbMF0sdVsxXSkuc3ViYXJyYXkoMCxsKX1yZXR1cm4gdGhpcy5ncGdwdS5kb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZShzLHVbMF0sdVsxXSkuc3ViYXJyYXkoMCxsKX12YXIgZj10aGlzLm1ha2VUZW5zb3JIYW5kbGUobyxcImZsb2F0MzJcIik7Zi5zaXplPXkobyksdGhpcy50ZXhEYXRhLmdldChmLmRhdGFJZCkudXNhZ2U9dWEuRE9XTkxPQUQ7dmFyIGQ9RmUoZnVuY3Rpb24oKXt2YXIgZT1uZXcgZWEobyk7cmV0dXJuIG4uY29tcGlsZUFuZFJ1bihlLFt7c2hhcGU6byxkdHlwZTppLGRhdGFJZDp0fV0sZixudWxsKX0pLHY9dGhpcy50ZXhEYXRhLmdldChkLmRhdGFJZCksbT10aGlzLmdwZ3B1LmRvd25sb2FkQnl0ZUVuY29kZWRGbG9hdE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlKHYudGV4dHVyZSx2LnRleFNoYXBlWzBdLHYudGV4U2hhcGVbMV0pLnN1YmFycmF5KDAsbCk7cmV0dXJuIHRoaXMuZGlzcG9zZURhdGEoZi5kYXRhSWQpLG19LHQucHJvdG90eXBlLnRpbWU9ZnVuY3Rpb24odCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsbixyLGEsaSxzLHU7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOnJldHVybiBlPXRoaXMuYWN0aXZlVGltZXJzLG49W10scj0hMSxudWxsPT10aGlzLnByb2dyYW1UaW1lcnNTdGFjaz8odGhpcy5wcm9ncmFtVGltZXJzU3RhY2s9bixyPSEwKTp0aGlzLmFjdGl2ZVRpbWVycy5wdXNoKG4pLHRoaXMuYWN0aXZlVGltZXJzPW4sdCgpLGE9Zyh0aGlzLmFjdGl2ZVRpbWVycy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQucXVlcnl9KSkuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT10fSksaT1nKHRoaXMuYWN0aXZlVGltZXJzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lfSkpLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9dH0pLHRoaXMuYWN0aXZlVGltZXJzPWUsciYmKHRoaXMucHJvZ3JhbVRpbWVyc1N0YWNrPW51bGwpLFs0LFByb21pc2UuYWxsKGEpXTtjYXNlIDE6cmV0dXJuIHM9by5zZW50KCksdT17dXBsb2FkV2FpdE1zOnRoaXMudXBsb2FkV2FpdE1zLGRvd25sb2FkV2FpdE1zOnRoaXMuZG93bmxvYWRXYWl0TXMsa2VybmVsTXM6ZihzKSxnZXRFeHRyYVByb2ZpbGVJbmZvOmZ1bmN0aW9uKCl7cmV0dXJuIHMubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJue25hbWU6aVtlXSxtczp0fX0pLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lK1wiOiBcIit0Lm1zfSkuam9pbihcIiwgXCIpfSx3YWxsTXM6bnVsbH0sdGhpcy51cGxvYWRXYWl0TXM9MCx0aGlzLmRvd25sb2FkV2FpdE1zPTAsWzIsdV19fSl9KX0sdC5wcm90b3R5cGUubWVtb3J5PWZ1bmN0aW9uKCl7cmV0dXJue3VucmVsaWFibGU6ITEsbnVtQnl0ZXNJbkdQVTp0aGlzLm51bUJ5dGVzSW5HUFV9fSx0LnByb3RvdHlwZS5zdGFydFRpbWVyPWZ1bmN0aW9uKCl7cmV0dXJuIGEuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIik+MD90aGlzLmdwZ3B1LmJlZ2luUXVlcnkoKTp7c3RhcnRNczpwZXJmb3JtYW5jZS5ub3coKSxlbmRNczpudWxsfX0sdC5wcm90b3R5cGUuZW5kVGltZXI9ZnVuY3Rpb24odCl7cmV0dXJuIGEuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIik+MD8odGhpcy5ncGdwdS5lbmRRdWVyeSgpLHQpOih0LmVuZE1zPXBlcmZvcm1hbmNlLm5vdygpLHQpfSx0LnByb3RvdHlwZS5nZXRRdWVyeVRpbWU9ZnVuY3Rpb24odCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihuKXtyZXR1cm4gYS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT4wP1syLHRoaXMuZ3BncHUud2FpdEZvclF1ZXJ5QW5kR2V0VGltZSh0KV06WzIsKGU9dCkuZW5kTXMtZS5zdGFydE1zXX0pfSl9LHQucHJvdG90eXBlLmRpc3Bvc2VEYXRhPWZ1bmN0aW9uKHQpe2lmKCF0aGlzLnBlbmRpbmdEaXNwb3NhbC5oYXModCkpaWYodGhpcy5wZW5kaW5nUmVhZC5oYXModCkpdGhpcy5wZW5kaW5nRGlzcG9zYWwuYWRkKHQpO2Vsc2UgaWYodGhpcy50ZXhEYXRhLmhhcyh0KSl7dGhpcy5yZWxlYXNlR1BVRGF0YSh0KTt2YXIgZT10aGlzLnRleERhdGEuZ2V0KHQpLmNvbXBsZXhUZW5zb3JzO251bGwhPWUmJihlLnJlYWwuZGlzcG9zZSgpLGUuaW1hZy5kaXNwb3NlKCkpLHRoaXMudGV4RGF0YS5kZWxldGUodCl9fSx0LnByb3RvdHlwZS5yZWxlYXNlR1BVRGF0YT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLnRleERhdGEuZ2V0KHQpLG49ZS50ZXh0dXJlLHI9ZS5kdHlwZSxvPWUudGV4U2hhcGUsYT1lLnVzYWdlLGk9ZS5pc1BhY2tlZCxzPWUuc2xpY2UsdT1zJiZzLm9yaWdEYXRhSWR8fHQsbD10aGlzLmRhdGFSZWZDb3VudC5nZXQodSk7bD4xP3RoaXMuZGF0YVJlZkNvdW50LnNldCh1LGwtMSk6KHRoaXMuZGF0YVJlZkNvdW50LmRlbGV0ZSh1KSxudWxsIT1uJiYodGhpcy5udW1CeXRlc0luR1BVLT10aGlzLmNvbXB1dGVCeXRlcyhvLHIpLHRoaXMudGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUobixvLGEsaSkpKTt2YXIgYz10aGlzLnRleERhdGEuZ2V0KHQpO2MudGV4dHVyZT1udWxsLGMudGV4U2hhcGU9bnVsbCxjLmlzUGFja2VkPSExLGMuc2xpY2U9bnVsbH0sdC5wcm90b3R5cGUuZ2V0VGV4dHVyZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy51cGxvYWRUb0dQVSh0KSx0aGlzLnRleERhdGEuZ2V0KHQpLnRleHR1cmV9LHQucHJvdG90eXBlLmdldENQVUJhY2tlbmQ9ZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXRCb29sKFwiV0VCR0xfQ1BVX0ZPUldBUkRcIik/KG51bGw9PXRoaXMuY3B1QmFja2VuZCYmKHRoaXMuY3B1QmFja2VuZD1EdC5maW5kQmFja2VuZChcImNwdVwiKSksdGhpcy5jcHVCYWNrZW5kKTpudWxsfSx0LnByb3RvdHlwZS5zaG91bGRFeGVjdXRlT25DUFU9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO3JldHVybiB2b2lkIDA9PT1lJiYoZT0xMjgpLG51bGwhPXRoaXMuZ2V0Q1BVQmFja2VuZCgpJiZ0LmV2ZXJ5KGZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT1uLnRleERhdGEuZ2V0KHQuZGF0YUlkKS50ZXh0dXJlJiZ0LnNpemU8ZX0pfSx0LnByb3RvdHlwZS5nZXRHUEdQVUNvbnRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncGdwdX0sdC5wcm90b3R5cGUuZ2V0Q2FudmFzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2FudmFzfSx0LnByb3RvdHlwZS5jb21wbGV4PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5tYWtlT3V0cHV0QXJyYXkodC5zaGFwZSxcImNvbXBsZXg2NFwiKTtyZXR1cm4gdGhpcy50ZXhEYXRhLmdldChuLmRhdGFJZCkuY29tcGxleFRlbnNvcnM9e3JlYWw6RHQua2VlcCh0LmNsb25lKCkpLGltYWc6RHQua2VlcChlLmNsb25lKCkpfSxufSx0LnByb3RvdHlwZS5yZWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKS5jb21wbGV4VGVuc29ycy5yZWFsLmNsb25lKCl9LHQucHJvdG90eXBlLmltYWc9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLmNvbXBsZXhUZW5zb3JzLmltYWcuY2xvbmUoKX0sdC5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24odCxlLG4pe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5zbGljZSh0LGUsbik7dmFyIHI9dGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCkuaXNQYWNrZWQsbz1tbih0LnNoYXBlLGUsbik7aWYocnx8IW8pe3ZhciBpPWEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiKT9uZXcgZmkobik6bmV3IGhpKG4pLHM9aS5nZXRDdXN0b21TZXR1cEZ1bmMoZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihpLFt0XSxudWxsLHMpfXJldHVybiB0aGlzLnVwbG9hZFRvR1BVKHQuZGF0YUlkKSx0aGlzLnNoYWxsb3dTbGljZSh0LGUsbil9LHQucHJvdG90eXBlLnNoYWxsb3dTbGljZT1mdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCksbz1mdC5tYWtlKG4se30sdC5kdHlwZSx0aGlzKSxhPXRoaXMudGV4RGF0YS5nZXQoby5kYXRhSWQpO09iamVjdC5hc3NpZ24oYSxyKSxhLnNoYXBlPW4sYS5kdHlwZT10LmR0eXBlO3ZhciBpPWduKGUsdC5zdHJpZGVzKTtyLnNsaWNlJiYoaSs9ci5zbGljZS5mbGF0T2Zmc2V0KSxhLnNsaWNlPXtmbGF0T2Zmc2V0Omksb3JpZ0RhdGFJZDpyLnNsaWNlJiZyLnNsaWNlLm9yaWdEYXRhSWR8fHQuZGF0YUlkfTt2YXIgcz10aGlzLmRhdGFSZWZDb3VudC5nZXQoYS5zbGljZS5vcmlnRGF0YUlkKXx8MTtyZXR1cm4gdGhpcy5kYXRhUmVmQ291bnQuc2V0KGEuc2xpY2Uub3JpZ0RhdGFJZCxzKzEpLG99LHQucHJvdG90eXBlLnN0cmlkZWRTbGljZT1mdW5jdGlvbih0LGUsbixyLG8sYSxpLHMsdSl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLnN0cmlkZWRTbGljZSh0LGUsbixyLG8sYSxpLHMsdSk7dmFyIGw9Zm4odC5zaGFwZSxlLG4scixvLGEsaSxzLHUpLGM9bFswXSxoPWxbMV0scD1sWzJdLGY9aC5maWx0ZXIoZnVuY3Rpb24odCxlKXtyZXR1cm4tMT09PXAuaW5kZXhPZihlKX0pO2lmKGYuc29tZShmdW5jdGlvbih0KXtyZXR1cm4gMD09PXR9KSlyZXR1cm4gRm4oW10sZik7dmFyIGQ9bmV3IGRpKGMscixoLHApO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZCxbdF0pfSx0LnByb3RvdHlwZS5yZXZlcnNlPWZ1bmN0aW9uKHQsZSl7dmFyIG49YS5nZXRCb29sKFwiV0VCR0xfUEFDS19BUlJBWV9PUEVSQVRJT05TXCIpP25ldyBzaSh0LnNoYXBlLGUpOm5ldyBpaSh0LnNoYXBlLGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdF0pfSx0LnByb3RvdHlwZS5jb25jYXQ9ZnVuY3Rpb24odCxlKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVSh0KSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmNvbmNhdCh0LGUpO2lmKDE9PT10Lmxlbmd0aClyZXR1cm4gdFswXTtpZih0Lmxlbmd0aD5hLmdldE51bWJlcihcIldFQkdMX01BWF9URVhUVVJFU19JTl9TSEFERVJcIikpe3ZhciBuPU1hdGguZmxvb3IodC5sZW5ndGgvMikscj10aGlzLmNvbmNhdCh0LnNsaWNlKDAsbiksZSksbz10aGlzLmNvbmNhdCh0LnNsaWNlKG4pLGUpO3JldHVybiB0aGlzLmNvbmNhdChbcixvXSxlKX1pZihhLmdldEJvb2woXCJXRUJHTF9QQUNLX0FSUkFZX09QRVJBVElPTlNcIikmJnRbMF0ucmFuaz4xKXt2YXIgaT1uZXcgVW8odC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSxlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGksdCl9dmFyIHM9c24odC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSxlKSx1PXQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFzMkQoLTEseSh0LnNoYXBlLnNsaWNlKGUpKSl9KSxsPW5ldyBXbyh1Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZX0pKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGwsdSkucmVzaGFwZShzKX0sdC5wcm90b3R5cGUubmVnPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwicmV0dXJuIC14O1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuYmF0Y2hNYXRNdWw9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89bj90LnNoYXBlWzJdOnQuc2hhcGVbMV0sYT1yP2Uuc2hhcGVbMV06ZS5zaGFwZVsyXSxpPW4/dC5zaGFwZVsxXTp0LnNoYXBlWzJdLHM9dC5zaGFwZVswXTtpZigoMT09PW98fDE9PT1hKSYmaT4xZTMpe24mJih0PXQudHJhbnNwb3NlKFswLDIsMV0pKSxyJiYoZT1lLnRyYW5zcG9zZShbMCwyLDFdKSk7dmFyIHU9MT09PWE/dDp0LmFzM0QocyxpLDEpLGw9MT09PWE/MjoxLGM9MT09PWE/ZS5hczNEKHMsMSxpKTplO3JldHVybiB0aGlzLm11bHRpcGx5KHUsYykuc3VtKGwsITApfXZhciBoPUN0KHQuZHR5cGUsZS5kdHlwZSkscD1uZXcgJGEodC5zaGFwZSxbcyxvLGFdLG4sciksZj10aGlzLm1ha2VQYWNrZWRUZW5zb3IocC5vdXRwdXRTaGFwZSxoKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHAsW3QsZV0sZil9LHQucHJvdG90eXBlLmZ1c2VkQmF0Y2hNYXRNdWw9ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBpPW4/dC5zaGFwZVsyXTp0LnNoYXBlWzFdLHM9cj9lLnNoYXBlWzFdOmUuc2hhcGVbMl0sdT10LnNoYXBlWzBdLGw9Q3QodC5kdHlwZSxlLmR0eXBlKSxjPW5ldyAkYSh0LnNoYXBlLFt1LGksc10sbixyLCEhbyxhP2Z1bmN0aW9uKHQsZSl7aWYodm9pZCAwPT09ZSYmKGU9ITEpLFwibGluZWFyXCI9PT10KXJldHVybiBlP01pOlNpO2lmKFwicmVsdVwiPT09dClyZXR1cm4gZT9GaTpOaTt0aHJvdyBuZXcgRXJyb3IoXCJBY3RpdmF0aW9uIFwiK3QrXCIgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIGZvciB0aGUgV2ViR0wgYmFja2VuZC5cIil9KGEsITApOm51bGwpLGg9dGhpcy5tYWtlUGFja2VkVGVuc29yKGMub3V0cHV0U2hhcGUsbCkscD1bdCxlXTtyZXR1cm4gbyYmcC5wdXNoKG8pLHRoaXMuY29tcGlsZUFuZFJ1bihjLHAsaCl9LHQucHJvdG90eXBlLm11bHRpcGx5PWZ1bmN0aW9uKHQsZSl7aWYoXCJjb21wbGV4NjRcIj09PXQuZHR5cGUpe3ZhciBuPXRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLHI9dGhpcy50ZXhEYXRhLmdldChlLmRhdGFJZCksbz1uZXcgVG8oSW8sdC5zaGFwZSxlLnNoYXBlKSxpPW5ldyBUbyhBbyx0LnNoYXBlLGUuc2hhcGUpLHM9W3RoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JIYW5kbGUodCxuLmNvbXBsZXhUZW5zb3JzLnJlYWwpLHRoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JIYW5kbGUodCxuLmNvbXBsZXhUZW5zb3JzLmltYWcpLHRoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JIYW5kbGUoZSxyLmNvbXBsZXhUZW5zb3JzLnJlYWwpLHRoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JIYW5kbGUoZSxyLmNvbXBsZXhUZW5zb3JzLmltYWcpXSx1PXRoaXMuY29tcGlsZUFuZFJ1bihvLHMpLGw9dGhpcy5jb21waWxlQW5kUnVuKGkscyksYz10aGlzLmNvbXBsZXgodSxsKTtyZXR1cm4gdS5kaXNwb3NlKCksbC5kaXNwb3NlKCksY31pZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdCxlXSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5tdWx0aXBseSh0LGUpO2lmKGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLF9vLHQuZHR5cGUpO3ZhciBoPW5ldyBNbyhfbyx0LnNoYXBlLGUuc2hhcGUpLHA9dGhpcy5tYWtlT3V0cHV0QXJyYXkoaC5vdXRwdXRTaGFwZSx0LmR0eXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGgsW3QsZV0scCl9LHQucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbj1mdW5jdGlvbih0LGUsbixyLG8saSl7dmFyIHM9W3QsZSxuXSx1PW51bGw7bnVsbCE9aSYmKHU9aS5zaGFwZSxzLnB1c2goaSkpO3ZhciBsPW51bGw7aWYobnVsbCE9byYmKGw9by5zaGFwZSxzLnB1c2gobykpLGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfTk9STUFMSVpBVElPTlwiKSl7dmFyIGM9bmV3IGtvKHQuc2hhcGUsZS5zaGFwZSxuLnNoYXBlLHUsbCxyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGMscyl9dmFyIGg9bmV3IE5vKHQuc2hhcGUsZS5zaGFwZSxuLnNoYXBlLHUsbCxyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGgscyl9LHQucHJvdG90eXBlLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uNEQ9ZnVuY3Rpb24odCxlLG4scixvKXt2YXIgaT1hLmdldEJvb2woXCJXRUJHTF9QQUNLX05PUk1BTElaQVRJT05cIik/bmV3IHFhKHQuc2hhcGUsZSxuLHIsbyk6bmV3IFZhKHQuc2hhcGUsZSxuLHIsbyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihpLFt0XSl9LHQucHJvdG90eXBlLkxSTkdyYWQ9ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dmFyIHM9bmV3IEdhKGUuc2hhcGUscixvLGEsaSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihzLFtlLG4sdF0pfSx0LnByb3RvdHlwZS50aWxlPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IHlpKHQuc2hhcGUsZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0XSl9LHQucHJvdG90eXBlLnBhZD1mdW5jdGlvbih0LGUsbil7dmFyIHI9YS5nZXRCb29sKFwiV0VCR0xfUEFDS19BUlJBWV9PUEVSQVRJT05TXCIpP25ldyBRYSh0LnNoYXBlLGUsbik6bmV3IFlhKHQuc2hhcGUsZSxuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3RdKX0sdC5wcm90b3R5cGUudHJhbnNwb3NlPWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLnRyYW5zcG9zZSh0LGUpO3ZhciBuPWEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiKT9uZXcgd2kodC5zaGFwZSxlKTpuZXcgeGkodC5zaGFwZSxlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3RdKX0sdC5wcm90b3R5cGUuZ2F0aGVyPWZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdCxlXSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5nYXRoZXIodCxlLG4pO3ZhciByPW5ldyBzYSh0LnNoYXBlLGUuc2l6ZSxuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSx0LnByb3RvdHlwZS5iYXRjaFRvU3BhY2VORD1mdW5jdGlvbih0LGUsbil7ZCh0LnJhbms8PTQsZnVuY3Rpb24oKXtyZXR1cm5cImJhdGNoVG9TcGFjZU5EIGZvciByYW5rID4gNCB3aXRoIGEgV2ViR0wgYmFja2VuZCBub3QgaW1wbGVtZW50ZWQgeWV0XCJ9KTt2YXIgcj1lLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSxvPUtlKHQuc2hhcGUsZSxyKSxhPVhlKG8ubGVuZ3RoLGUubGVuZ3RoKSxpPVllKHQuc2hhcGUsZSxyKSxzPVFlKG4sZS5sZW5ndGgpLHU9SmUoaSxuLGUubGVuZ3RoKTtyZXR1cm4gdC5yZXNoYXBlKG8pLnRyYW5zcG9zZShhKS5yZXNoYXBlKGkpLnNsaWNlKHMsdSl9LHQucHJvdG90eXBlLnNwYWNlVG9CYXRjaE5EPWZ1bmN0aW9uKHQsZSxuKXtkKHQucmFuazw9NCxmdW5jdGlvbigpe3JldHVyblwic3BhY2VUb0JhdGNoTkQgZm9yIHJhbmsgPiA0IHdpdGggYSBXZWJHTCBiYWNrZW5kIG5vdCBpbXBsZW1lbnRlZCB5ZXRcIn0pO3ZhciByPWUucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQqZX0pLG89W1swLDBdXTtvLnB1c2guYXBwbHkobyxuKTtmb3IodmFyIGE9MStlLmxlbmd0aDthPHQuc2hhcGUubGVuZ3RoOysrYSlvLnB1c2goWzAsMF0pO3ZhciBpPXQucGFkKG8pLHM9S2UoaS5zaGFwZSxlLHIsITEpLHU9WGUocy5sZW5ndGgsZS5sZW5ndGgsITEpLGw9WWUoaS5zaGFwZSxlLHIsITEpO3JldHVybiBpLnJlc2hhcGUocykudHJhbnNwb3NlKHUpLnJlc2hhcGUobCl9LHQucHJvdG90eXBlLnJlZHVjZT1mdW5jdGlvbih0LGUsbil7dmFyIHI9dC5zaGFwZVswXSxvPXQuc2hhcGVbMV0sYT1jbihvKSxpPW5ldyBaYSh7d2luZG93U2l6ZTphLGluU2l6ZTpvLGJhdGNoU2l6ZTpyfSxlKSxzPWkub3V0cHV0U2hhcGUsdT1zWzBdLGw9c1sxXSxjPXRoaXMubWFrZU91dHB1dEFycmF5KFt1LGxdLG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oaSxbdF0sYyksMT09PWMuc2hhcGVbMV0/Yzp0aGlzLnJlZHVjZShjLGUsbil9LHQucHJvdG90eXBlLmFyZ1JlZHVjZT1mdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49bnVsbCk7dmFyIHI9dC5zaGFwZVswXSxvPXQuc2hhcGVbMV07bnVsbCE9biYmKHI9bi5zaGFwZVswXSxvPW4uc2hhcGVbMV0pO3ZhciBhPWNuKG8pLGk9bmV3IG5vKHt3aW5kb3dTaXplOmEsaW5TaXplOm8sYmF0Y2hTaXplOnJ9LGUsbnVsbD09bikscz1pLm91dHB1dFNoYXBlLHU9c1swXSxsPXNbMV0sYz10aGlzLm1ha2VPdXRwdXRBcnJheShbdSxsXSxcImludDMyXCIpLGg9W3RdO3JldHVybiBudWxsIT1uJiZoLnB1c2gobiksdGhpcy5jb21waWxlQW5kUnVuKGksaCxjKSwxPT09Yy5zaGFwZVsxXT9jOnRoaXMuYXJnUmVkdWNlKHQsZSxjKX0sdC5wcm90b3R5cGUuYXJnUmVkdWNlUGFja2VkPWZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj1udWxsKTt2YXIgcj1udWxsIT1uP24uc2hhcGU6dC5zaGFwZSxvPWNuKHJbci5sZW5ndGgtMV0pLGE9bmV3IFJvKHIsbyxlLG51bGw9PW4pLGk9dGhpcy5tYWtlUGFja2VkVGVuc29yKGEub3V0cHV0U2hhcGUsXCJpbnQzMlwiKSxzPW51bGw9PW4/W3RdOlt0LG5dO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oYSxzLGkpLGkucmFuaz09PXQucmFuaz90aGlzLmFyZ1JlZHVjZVBhY2tlZCh0LGUsaSk6aX0sdC5wcm90b3R5cGUuc3VtPWZ1bmN0aW9uKHQsZSl7bm4oXCJzdW1cIixlLHQucmFuayk7dmFyIG49dG4odC5zaGFwZSxlKSxyPW5bMF0sbz15KG5bMV0pLGE9dC5hczJEKC0xLG8pLGk9RXQodC5kdHlwZSk7cmV0dXJuIHRoaXMucmVkdWNlKGEsXCJzdW1cIixpKS5yZXNoYXBlKHIpfSx0LnByb3RvdHlwZS5wcm9kPWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLnByb2QodCxlKTt2YXIgbj10bih0LnNoYXBlLGUpLHI9blswXSxvPXkoblsxXSksYT10LmFzMkQoLTEsbyksaT1FdCh0LmR0eXBlKTtyZXR1cm4gdGhpcy5yZWR1Y2UoYSxcInByb2RcIixpKS5yZXNoYXBlKHIpfSx0LnByb3RvdHlwZS51bnNvcnRlZFNlZ21lbnRTdW09ZnVuY3Rpb24odCxlLG4pe3ZhciByPTAsbz1ybihbcl0sdC5yYW5rKSxhPXQ7bnVsbCE9byYmKGE9dC50cmFuc3Bvc2Uobykscj1hbigxLHQucmFuaylbMF0pO3ZhciBpPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9W10sbz10Lmxlbmd0aCxhPTA7YTxvO2ErKylhIT09ZT9yLnB1c2godFthXSk6ci5wdXNoKG4pO3JldHVybiByfShhLnNoYXBlLHIsbikscz15KFthLnNoYXBlW3JdXSksdT1hLmFzMkQoLTEscyksbD1FdCh0LmR0eXBlKSxjPXRoaXMuc2VnT3BDb21wdXRlKHUsXCJ1bnNvcnRlZFNlZ21lbnRTdW1cIixlLGwsbikucmVzaGFwZShpKTtyZXR1cm4gbnVsbCE9byYmKGM9Yy50cmFuc3Bvc2Uob24obykpKSxjfSx0LnByb3RvdHlwZS5zZWdPcENvbXB1dGU9ZnVuY3Rpb24odCxlLG4scixvKXt2YXIgYT10LnNoYXBlWzBdLGk9dC5zaGFwZVsxXSxzPWZ1bmN0aW9uKHQsZSl7dmFyIG4scj0hMTtmb3IodDw9bG4/KG49dCxyPSEwKTpuPXoodCxNYXRoLmZsb29yKE1hdGguc3FydCh0KSkpOyFyOyluPmV8fG49PT10P3I9ITA6bj16KHQsbisxKTtyZXR1cm4gbn0oaSxvKSx1PW5ldyBsaSh7d2luZG93U2l6ZTpzLGluU2l6ZTppLGJhdGNoU2l6ZTphLG51bVNlZ21lbnRzOm99LGUpLGw9dS5vdXRwdXRTaGFwZSxjPWxbMF0saD1sWzFdLHA9dGhpcy5tYWtlT3V0cHV0QXJyYXkoW2MsaF0scik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih1LFt0LG5dLHApLHAuc2hhcGVbMV09PT1vP3A6KG49am4oMCxvKS50aWxlKFtpL3NdKSx0aGlzLnNlZ09wQ29tcHV0ZShwLGUsbixyLG8pKX0sdC5wcm90b3R5cGUuYXJnTWluTWF4UmVkdWNlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1bZV07aWYobm4oXCJhcmdcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSkscix0LnJhbmspLCFhLmdldEJvb2woXCJXRUJHTF9QQUNLX1JFRFVDRVwiKXx8dC5yYW5rPD0yKXt2YXIgbz10bih0LnNoYXBlLHIpLGk9b1swXSxzPXkob1sxXSksdT10LmFzMkQoLTEscyk7cmV0dXJuIHRoaXMuYXJnUmVkdWNlKHUsbikucmVzaGFwZShpKX1yZXR1cm4gdGhpcy5hcmdSZWR1Y2VQYWNrZWQodCxuKX0sdC5wcm90b3R5cGUuYXJnTWluPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYXJnTWluTWF4UmVkdWNlKHQsZSxcIm1pblwiKX0sdC5wcm90b3R5cGUuYXJnTWF4PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYXJnTWluTWF4UmVkdWNlKHQsZSxcIm1heFwiKX0sdC5wcm90b3R5cGUuY3Vtc3VtPWZ1bmN0aW9uKHQsZSxuLHIpe2lmKGUhPT10LnJhbmstMSl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBjdW1zdW0gc2hhZGVyIGV4cGVjdHMgYW4gaW5uZXItbW9zdCBheGlzPVwiKyh0LnJhbmstMSkrXCIgYnV0IGdvdCBheGlzPVwiK2UpO3ZhciBvPW5ldyBKbyh0LnNoYXBlLG4scik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihvLFt0XSl9LHQucHJvdG90eXBlLmVxdWFsPWZ1bmN0aW9uKHQsZSl7aWYoYS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIHJldHVybiB2ZWM0KGVxdWFsKGEsIGIpKTtcXG5cIixcImJvb2xcIik7dmFyIG49bmV3IE1vKFwicmV0dXJuIGZsb2F0KGEgPT0gYik7XCIsdC5zaGFwZSxlLnNoYXBlKSxyPXRoaXMubWFrZU91dHB1dEFycmF5KG4ub3V0cHV0U2hhcGUsXCJib29sXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxyKX0sdC5wcm90b3R5cGUubm90RXF1YWw9ZnVuY3Rpb24odCxlKXtpZihhLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxcIlxcbiAgcmV0dXJuIHZlYzQobm90RXF1YWwoYSwgYikpO1xcblwiLFwiYm9vbFwiKTt2YXIgbj1uZXcgTW8oXCJyZXR1cm4gZmxvYXQoYSAhPSBiKTtcIix0LnNoYXBlLGUuc2hhcGUpLHI9dGhpcy5tYWtlT3V0cHV0QXJyYXkobi5vdXRwdXRTaGFwZSxcImJvb2xcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLHIpfSx0LnByb3RvdHlwZS5sZXNzPWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3QsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQubGVzcyh0LGUpO2lmKGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICByZXR1cm4gdmVjNChsZXNzVGhhbihhLCBiKSk7XFxuXCIsXCJib29sXCIpO3ZhciBuPW5ldyBNbyhcInJldHVybiBmbG9hdChhIDwgYik7XCIsdC5zaGFwZSxlLnNoYXBlKSxyPXRoaXMubWFrZU91dHB1dEFycmF5KG4ub3V0cHV0U2hhcGUsXCJib29sXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxyKX0sdC5wcm90b3R5cGUubGVzc0VxdWFsPWZ1bmN0aW9uKHQsZSl7aWYoYS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIHJldHVybiB2ZWM0KGxlc3NUaGFuRXF1YWwoYSwgYikpO1xcblwiLFwiYm9vbFwiKTt2YXIgbj1uZXcgTW8oXCJyZXR1cm4gZmxvYXQoYSA8PSBiKTtcIix0LnNoYXBlLGUuc2hhcGUpLHI9dGhpcy5tYWtlT3V0cHV0QXJyYXkobi5vdXRwdXRTaGFwZSxcImJvb2xcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLHIpfSx0LnByb3RvdHlwZS5ncmVhdGVyPWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3QsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuZ3JlYXRlcih0LGUpO2lmKGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICByZXR1cm4gdmVjNChncmVhdGVyVGhhbihhLCBiKSk7XFxuXCIsXCJib29sXCIpO3ZhciBuPW5ldyBNbyhcInJldHVybiBmbG9hdChhID4gYik7XCIsdC5zaGFwZSxlLnNoYXBlKSxyPXRoaXMubWFrZU91dHB1dEFycmF5KG4ub3V0cHV0U2hhcGUsXCJib29sXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxyKX0sdC5wcm90b3R5cGUuZ3JlYXRlckVxdWFsPWZ1bmN0aW9uKHQsZSl7aWYoYS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIHJldHVybiB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoYSwgYikpO1xcblwiLFwiYm9vbFwiKTt2YXIgbj1uZXcgTW8oXCJyZXR1cm4gZmxvYXQoYSA+PSBiKTtcIix0LnNoYXBlLGUuc2hhcGUpLHI9dGhpcy5tYWtlT3V0cHV0QXJyYXkobi5vdXRwdXRTaGFwZSxcImJvb2xcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLHIpfSx0LnByb3RvdHlwZS5sb2dpY2FsTm90PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwicmV0dXJuIGZsb2F0KCEoeCA+PSAxLjApKTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLmxvZ2ljYWxBbmQ9ZnVuY3Rpb24odCxlKXtpZihhLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxcIlxcbiAgcmV0dXJuIHZlYzQoXFxuICAgIHZlYzQoZ3JlYXRlclRoYW5FcXVhbChhLCB2ZWM0KDEuMCkpKSAqXFxuICAgIHZlYzQoZ3JlYXRlclRoYW5FcXVhbChiLCB2ZWM0KDEuMCkpKSk7XFxuXCIsXCJib29sXCIpO3ZhciBuPW5ldyBNbyhcInJldHVybiBmbG9hdChhID49IDEuMCAmJiBiID49IDEuMCk7XCIsdC5zaGFwZSxlLnNoYXBlKSxyPXRoaXMubWFrZU91dHB1dEFycmF5KG4ub3V0cHV0U2hhcGUsXCJib29sXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxyKX0sdC5wcm90b3R5cGUubG9naWNhbE9yPWZ1bmN0aW9uKHQsZSl7aWYoYS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIHJldHVybiBtaW4oXFxuICAgIHZlYzQoZ3JlYXRlclRoYW5FcXVhbChhLCB2ZWM0KDEuMCkpKSArXFxuICAgIHZlYzQoZ3JlYXRlclRoYW5FcXVhbChiLCB2ZWM0KDEuMCkpKSxcXG4gICAgdmVjNCgxLjApKTtcXG5cIixcImJvb2xcIik7dmFyIG49bmV3IE1vKFwicmV0dXJuIGZsb2F0KGEgPj0gMS4wIHx8IGIgPj0gMS4wKTtcIix0LnNoYXBlLGUuc2hhcGUpLHI9dGhpcy5tYWtlT3V0cHV0QXJyYXkobi5vdXRwdXRTaGFwZSxcImJvb2xcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLHIpfSx0LnByb3RvdHlwZS5zZWxlY3Q9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBjaSh0LnJhbmssZS5zaGFwZSxlLnJhbmspLG89dGhpcy5tYWtlT3V0cHV0QXJyYXkoci5vdXRwdXRTaGFwZSxDdChlLmR0eXBlLG4uZHR5cGUpKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZSxuXSxvKX0sdC5wcm90b3R5cGUud2hlcmU9ZnVuY3Rpb24odCl7amUoXCJ0Zi53aGVyZSgpIGluIHdlYmdsIGxvY2tzIHRoZSBVSSB0aHJlYWQuIENhbGwgdGYud2hlcmVBc3luYygpIGluc3RlYWRcIik7dmFyIGU9dC5kYXRhU3luYygpO3JldHVybiBacih0LnNoYXBlLGUpfSx0LnByb3RvdHlwZS50b3BrPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdXIodC5kYXRhU3luYygpLHQuc2hhcGUsdC5kdHlwZSxlKX0sdC5wcm90b3R5cGUubWluPWZ1bmN0aW9uKHQsZSl7bm4oXCJtaW5cIixlLHQucmFuayk7dmFyIG49dG4odC5zaGFwZSxlKSxyPW5bMF0sbz15KG5bMV0pLGE9dC5hczJEKC0xLG8pO3JldHVybiB0aGlzLnJlZHVjZShhLFwibWluXCIsYS5kdHlwZSkucmVzaGFwZShyKX0sdC5wcm90b3R5cGUubWluaW11bT1mdW5jdGlvbih0LGUpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0LGVdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLm1pbmltdW0odCxlKTt2YXIgbj1hLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpP25ldyBGbyhcIlxcbiAgdmVjNCByZXN1bHQgPSB2ZWM0KG1pbihhLCBiKSk7XFxuICB2ZWM0IGlzTmFOID0gbWluKHZlYzQoaXNuYW4oYSkpICsgdmVjNChpc25hbihiKSksIHZlYzQoMS4wKSk7XFxuICBcXG4gIHJlc3VsdC5yID0gaXNOYU4uciA+IDAuID8gTkFOIDogcmVzdWx0LnI7XFxuICByZXN1bHQuZyA9IGlzTmFOLmcgPiAwLiA/IE5BTiA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc05hTi5iID4gMC4gPyBOQU4gOiByZXN1bHQuYjtcXG4gIHJlc3VsdC5hID0gaXNOYU4uYSA+IDAuID8gTkFOIDogcmVzdWx0LmE7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcblwiLHQuc2hhcGUsZS5zaGFwZSk6bmV3IE1vKFwiXFxuICBpZiAoaXNuYW4oYSkpIHJldHVybiBhO1xcbiAgaWYgKGlzbmFuKGIpKSByZXR1cm4gYjtcXG5cXG4gIHJldHVybiBtaW4oYSwgYik7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0pfSx0LnByb3RvdHlwZS5tb2Q9ZnVuY3Rpb24odCxlKXt2YXIgbj1hLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpP25ldyBGbyhcIlxcbiAgdmVjNCByZXN1bHQgPSBtb2QoYSwgYik7XFxuICB2ZWM0IGlzTmFOID0gdmVjNChlcXVhbChiLCB2ZWM0KDAuMCkpKTtcXG4gIFxcbiAgcmVzdWx0LnIgPSBpc05hTi5yID4gMC4gPyBOQU4gOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA+IDAuID8gTkFOIDogcmVzdWx0Lmc7XFxuICByZXN1bHQuYiA9IGlzTmFOLmIgPiAwLiA/IE5BTiA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc05hTi5hID4gMC4gPyBOQU4gOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTpuZXcgTW8oXCJpZiAoYiA9PSAwLjApIHJldHVybiBOQU47XFxuICByZXR1cm4gbW9kKGEsIGIpO1wiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdKX0sdC5wcm90b3R5cGUubWF4PWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLm1heCh0LGUpO25uKFwibWF4XCIsZSx0LnJhbmspO3ZhciBuPXRuKHQuc2hhcGUsZSkscj1uWzBdLG89eShuWzFdKSxhPXQuYXMyRCgtMSxvKTtyZXR1cm4gdGhpcy5yZWR1Y2UoYSxcIm1heFwiLGEuZHR5cGUpLnJlc2hhcGUocil9LHQucHJvdG90eXBlLm1heGltdW09ZnVuY3Rpb24odCxlKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdCxlXSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5tYXhpbXVtKHQsZSk7dmFyIG49YS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKT9uZXcgRm8oXCJcXG4gIHZlYzQgcmVzdWx0ID0gdmVjNChtYXgoYSwgYikpO1xcbiAgdmVjNCBpc05hTiA9IG1pbih2ZWM0KGlzbmFuKGEpKSArIHZlYzQoaXNuYW4oYikpLCB2ZWM0KDEuMCkpO1xcbiAgXFxuICByZXN1bHQuciA9IGlzTmFOLnIgPiAwLiA/IE5BTiA6IHJlc3VsdC5yO1xcbiAgcmVzdWx0LmcgPSBpc05hTi5nID4gMC4gPyBOQU4gOiByZXN1bHQuZztcXG4gIHJlc3VsdC5iID0gaXNOYU4uYiA+IDAuID8gTkFOIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzTmFOLmEgPiAwLiA/IE5BTiA6IHJlc3VsdC5hO1xcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIix0LnNoYXBlLGUuc2hhcGUpOm5ldyBNbyhcIlxcbiAgaWYgKGlzbmFuKGEpKSByZXR1cm4gYTtcXG4gIGlmIChpc25hbihiKSkgcmV0dXJuIGI7XFxuXFxuICByZXR1cm4gbWF4KGEsIGIpO1xcblwiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdKX0sdC5wcm90b3R5cGUuYWxsPWZ1bmN0aW9uKHQsZSl7bm4oXCJhbGxcIixlLHQucmFuayk7dmFyIG49dG4odC5zaGFwZSxlKSxyPW5bMF0sbz15KG5bMV0pLGE9dC5hczJEKC0xLG8pO3JldHVybiB0aGlzLnJlZHVjZShhLFwiYWxsXCIsYS5kdHlwZSkucmVzaGFwZShyKX0sdC5wcm90b3R5cGUuYW55PWZ1bmN0aW9uKHQsZSl7bm4oXCJhbnlcIixlLHQucmFuayk7dmFyIG49dG4odC5zaGFwZSxlKSxyPW5bMF0sbz15KG5bMV0pLGE9dC5hczJEKC0xLG8pO3JldHVybiB0aGlzLnJlZHVjZShhLFwiYW55XCIsYS5kdHlwZSkucmVzaGFwZShyKX0sdC5wcm90b3R5cGUuc3F1YXJlZERpZmZlcmVuY2U9ZnVuY3Rpb24odCxlKXt2YXIgbj1hLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpP25ldyBGbyhcInJldHVybiAoYSAtIGIpICogKGEgLSBiKTtcIix0LnNoYXBlLGUuc2hhcGUpOm5ldyBNbyhcInJldHVybiAoYSAtIGIpICogKGEgLSBiKTtcIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSl9LHQucHJvdG90eXBlLnJlYWxEaXZpZGU9ZnVuY3Rpb24odCxlKXtpZihhLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXtyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIC8vIHZlYzQgb25lID0gdmVjNChlcXVhbChhLCBiKSk7XFxuICAvLyByZXR1cm4gb25lICsgKHZlYzQoMS4wKSAtIG9uZSkgKiBhIC8gYjtcXG4gIHZlYzQgcmVzdWx0ID0gYSAvIGI7XFxuICBpZihiLnggPT0gMC4wKSB7XFxuICAgIHJlc3VsdC54ID0gTkFOO1xcbiAgfSBlbHNlIGlmKGEueCA9PSBiLngpIHtcXG4gICAgcmVzdWx0LnggPSAxLjtcXG4gIH1cXG4gIGlmKGIueSA9PSAwLjApIHtcXG4gICAgcmVzdWx0LnkgPSBOQU47XFxuICB9IGVsc2UgaWYoYS55ID09IGIueSkge1xcbiAgICByZXN1bHQueSA9IDEuO1xcbiAgfVxcbiAgaWYoYi56ID09IDAuMCkge1xcbiAgICByZXN1bHQueiA9IE5BTjtcXG4gIH0gZWxzZSBpZihhLnogPT0gYi56KSB7XFxuICAgIHJlc3VsdC56ID0gMS47XFxuICB9XFxuICBpZihiLncgPT0gMC4wKSB7XFxuICAgIHJlc3VsdC53ID0gTkFOO1xcbiAgfSBlbHNlIGlmKGEudyA9PSBiLncpIHtcXG4gICAgcmVzdWx0LncgPSAxLjtcXG4gIH1cXG4gIFxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIixcImZsb2F0MzJcIiwhMCl9dmFyIG49bmV3IE1vKFwiXFxuaWYgKGIgPT0gMC4wKSB7XFxuICByZXR1cm4gTkFOO1xcbn0gXFxuaWYgKGEgPT0gYikge1xcbiAgcmV0dXJuIDEuMDtcXG59O1xcbnJldHVybiBhIC8gYjtcIix0LnNoYXBlLGUuc2hhcGUpLHI9dGhpcy5tYWtlT3V0cHV0QXJyYXkobi5vdXRwdXRTaGFwZSxcImZsb2F0MzJcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLHIpfSx0LnByb3RvdHlwZS5mbG9vckRpdj1mdW5jdGlvbih0LGUpe2lmKGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICBpdmVjNCBpYSA9IHJvdW5kKGEpO1xcbiAgaXZlYzQgaWIgPSByb3VuZChiKTtcXG4gIGJ2ZWM0IGNvbmQgPSBub3RFcXVhbChpYiwgaXZlYzQoMCkpO1xcbiAgaXZlYzQgcmVzdWx0ID0gaXZlYzQoMCk7XFxuICB2ZWM0IHMgPSBzaWduKGEpICogc2lnbihiKTtcXG5cXG4gIC8vIFdpbmRvd3MgKEQzRCkgd2FudHMgZ3VhcmFudGVlZCBub24temVybyBpbnQgZGl2aXNpb24gYXQgY29tcGlsZS10aW1lLlxcbiAgaWYgKGNvbmRbMF0pIHtcXG4gICAgcmVzdWx0WzBdID0gaWRpdihpYVswXSwgaWJbMF0sIHNbMF0pO1xcbiAgfVxcbiAgaWYgKGNvbmRbMV0pIHtcXG4gICAgcmVzdWx0WzFdID0gaWRpdihpYVsxXSwgaWJbMV0sIHNbMV0pO1xcbiAgfVxcbiAgaWYgKGNvbmRbMl0pIHtcXG4gICAgcmVzdWx0WzJdID0gaWRpdihpYVsyXSwgaWJbMl0sIHNbMl0pO1xcbiAgfVxcbiAgaWYgKGNvbmRbM10pIHtcXG4gICAgcmVzdWx0WzNdID0gaWRpdihpYVszXSwgaWJbM10sIHNbM10pO1xcbiAgfVxcbiAgcmV0dXJuIHZlYzQocmVzdWx0KTtcXG5cIixcImludDMyXCIpO3ZhciBuPW5ldyBNbyhcIlxcbiAgZmxvYXQgcyA9IHNpZ24oYSkgKiBzaWduKGIpO1xcbiAgaW50IGlhID0gcm91bmQoYSk7XFxuICBpbnQgaWIgPSByb3VuZChiKTtcXG4gIGlmIChpYiAhPSAwKSB7XFxuICAgIC8vIFdpbmRvd3MgKEQzRCkgd2FudHMgZ3VhcmFudGVlZCBub24temVybyBpbnQgZGl2aXNpb24gYXQgY29tcGlsZS10aW1lLlxcbiAgICByZXR1cm4gZmxvYXQoaWRpdihpYSwgaWIsIHMpKTtcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBOQU47XFxuICB9XFxuXCIsdC5zaGFwZSxlLnNoYXBlKSxyPXRoaXMubWFrZU91dHB1dEFycmF5KG4ub3V0cHV0U2hhcGUsXCJpbnQzMlwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0scil9LHQucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0LGUpe2lmKFwiY29tcGxleDY0XCI9PT10LmR0eXBlJiZcImNvbXBsZXg2NFwiPT09ZS5kdHlwZSlyZXR1cm4gdGhpcy5jb21wbGV4U2VwYXJhYmxlQmluYXJ5T3AodCxlLERvKTtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdCxlXSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5hZGQodCxlKTt2YXIgbj1DdCh0LmR0eXBlLGUuZHR5cGUpO2lmKGEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLERvLG4pO3ZhciByPW5ldyBNbyhEbyx0LnNoYXBlLGUuc2hhcGUpLG89dGhpcy5tYWtlT3V0cHV0QXJyYXkoci5vdXRwdXRTaGFwZSxuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0sbyl9LHQucHJvdG90eXBlLnBhY2tlZEJpbmFyeU9wPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09byYmKG89ITEpO3ZhciBhPW5ldyBGbyhuLHQuc2hhcGUsZS5zaGFwZSxvKSxpPXRoaXMubWFrZVBhY2tlZFRlbnNvcihhLm91dHB1dFNoYXBlLHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oYSxbdCxlXSxpKX0sdC5wcm90b3R5cGUuY29tcGxleFNlcGFyYWJsZUJpbmFyeU9wPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzLG89dGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCksYT10aGlzLnRleERhdGEuZ2V0KGUuZGF0YUlkKSxpPVtbby5jb21wbGV4VGVuc29ycy5yZWFsLGEuY29tcGxleFRlbnNvcnMucmVhbF0sW28uY29tcGxleFRlbnNvcnMuaW1hZyxhLmNvbXBsZXhUZW5zb3JzLmltYWddXS5tYXAoZnVuY3Rpb24obyl7dmFyIGE9b1swXSxpPW9bMV0scz1yLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlKHQsYSksdT1yLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlKGUsaSksbD1uZXcgTW8obix0LnNoYXBlLGUuc2hhcGUpLGM9ci5tYWtlT3V0cHV0QXJyYXkobC5vdXRwdXRTaGFwZSxDdChhLmR0eXBlLGkuZHR5cGUpKTtyZXR1cm4gci5jb21waWxlQW5kUnVuKGwsW3MsdV0sYyl9KSxzPWlbMF0sdT1pWzFdLGw9dGhpcy5jb21wbGV4KHMsdSk7cmV0dXJuIHMuZGlzcG9zZSgpLHUuZGlzcG9zZSgpLGx9LHQucHJvdG90eXBlLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlPWZ1bmN0aW9uKHQsZSl7cmV0dXJue2RhdGFJZDplLmRhdGFJZCxkdHlwZTplLmR0eXBlLHNoYXBlOnQuc2hhcGV9fSx0LnByb3RvdHlwZS5hZGROPWZ1bmN0aW9uKHQpe2lmKDE9PT10Lmxlbmd0aClyZXR1cm4gdFswXTtpZih0Lmxlbmd0aD5hLmdldChcIldFQkdMX01BWF9URVhUVVJFU19JTl9TSEFERVJcIikpe3ZhciBlPU1hdGguZmxvb3IodC5sZW5ndGgvMiksbj10aGlzLmFkZE4odC5zbGljZSgwLGUpKSxyPXRoaXMuYWRkTih0LnNsaWNlKGUpKTtyZXR1cm4gdGhpcy5hZGROKFtuLHJdKX12YXIgbz10Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5kdHlwZX0pLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiBDdCh0LGUpfSksaT10Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZX0pLHM9YS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKSx1PXM/bmV3IGVvKHRbMF0uc2hhcGUsaSk6bmV3IHRvKHRbMF0uc2hhcGUsaSksbD1zP3RoaXMubWFrZVBhY2tlZFRlbnNvcih1Lm91dHB1dFNoYXBlLG8pOnRoaXMubWFrZU91dHB1dEFycmF5KHUub3V0cHV0U2hhcGUsbyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih1LHQsbCl9LHQucHJvdG90eXBlLnN1YnRyYWN0PWZ1bmN0aW9uKHQsZSl7aWYoXCJjb21wbGV4NjRcIj09PXQuZHR5cGUmJlwiY29tcGxleDY0XCI9PT1lLmR0eXBlKXJldHVybiB0aGlzLmNvbXBsZXhTZXBhcmFibGVCaW5hcnlPcCh0LGUsT28pO2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0LGVdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLnN1YnRyYWN0KHQsZSk7dmFyIG49Q3QodC5kdHlwZSxlLmR0eXBlKTtpZihhLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxPbyx0LmR0eXBlKTt2YXIgcj1uZXcgTW8oT28sdC5zaGFwZSxlLnNoYXBlKSxvPXRoaXMubWFrZU91dHB1dEFycmF5KHIub3V0cHV0U2hhcGUsbik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdLG8pfSx0LnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24odCxlKXt2YXIgbj1hLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpLHI9bj9uZXcgRm8oXCJcXG4gIC8vIGlzTW9kUm91bmQxIGhhcyAxIGZvciBjb21wb25lbnRzIHdpdGggcm91bmQobW9kKGIsIDIuMCkpID09IDEsIDAgb3RoZXJ3aXNlLlxcbiAgdmVjNCBpc01vZFJvdW5kMSA9IHZlYzQoZXF1YWwocm91bmQobW9kKGIsIDIuMCkpLCBpdmVjNCgxKSkpO1xcbiAgdmVjNCBtdWx0aXBsaWVyID0gc2lnbihhKSAqIGlzTW9kUm91bmQxICsgKHZlYzQoMS4wKSAtIGlzTW9kUm91bmQxKTtcXG4gIHZlYzQgcmVzdWx0ID0gbXVsdGlwbGllciAqIHBvdyhhYnMoYSksIGIpO1xcblxcbiAgdmVjNCBpc05hTiA9IHZlYzQobGVzc1RoYW4oYSwgdmVjNCgwLjApKSkgKiB2ZWM0KGxlc3NUaGFuKGZsb29yKGIpLCBiKSk7XFxuICBcXG4gIHJlc3VsdC5yID0gaXNOYU4uciA+IDAuID8gTkFOIDogcmVzdWx0LnI7XFxuICByZXN1bHQuZyA9IGlzTmFOLmcgPiAwLiA/IE5BTiA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc05hTi5iID4gMC4gPyBOQU4gOiByZXN1bHQuYjtcXG4gIHJlc3VsdC5hID0gaXNOYU4uYSA+IDAuID8gTkFOIDogcmVzdWx0LmE7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcblwiLHQuc2hhcGUsZS5zaGFwZSk6bmV3IE1vKFwiXFxuaWYoYSA8IDAuMCAmJiBmbG9vcihiKSA8IGIpe1xcbiAgcmV0dXJuIE5BTjtcXG59XFxucmV0dXJuIChyb3VuZChtb2QoYiwgMi4wKSkgIT0gMSkgP1xcbiAgICBwb3coYWJzKGEpLCBiKSA6IHNpZ24oYSkgKiBwb3coYWJzKGEpLCBiKTtcXG5cIix0LnNoYXBlLGUuc2hhcGUpLG89Q3QodC5kdHlwZSxlLmR0eXBlKSxpPW4/dGhpcy5tYWtlUGFja2VkVGVuc29yKHIub3V0cHV0U2hhcGUsbyk6dGhpcy5tYWtlT3V0cHV0QXJyYXkoci5vdXRwdXRTaGFwZSxvKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0saSl9LHQucHJvdG90eXBlLmNlaWw9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJyZXR1cm4gY2VpbCh4KTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwicmV0dXJuIGZsb29yKHgpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuc2lnbj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcIlxcbiAgaWYgKGlzbmFuKHgpKSB7IHJldHVybiAwLjA7IH1cXG4gIHJldHVybiBzaWduKHgpO1xcblwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuaXNOYU49ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJyZXR1cm4gZmxvYXQoaXNuYW4oeCkpO1wiKSxuPXRoaXMubWFrZU91dHB1dEFycmF5KGUub3V0cHV0U2hhcGUsXCJib29sXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0sbil9LHQucHJvdG90eXBlLmlzSW5mPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwicmV0dXJuIGZsb2F0KGlzaW5mKHgpKTtcIiksbj10aGlzLm1ha2VPdXRwdXRBcnJheShlLm91dHB1dFNoYXBlLFwiYm9vbFwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdLG4pfSx0LnByb3RvdHlwZS5pc0Zpbml0ZT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcInJldHVybiBmbG9hdCghaXNuYW4oeCkgJiYgIWlzaW5mKHgpKTtcIiksbj10aGlzLm1ha2VPdXRwdXRBcnJheShlLm91dHB1dFNoYXBlLFwiYm9vbFwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdLG4pfSx0LnByb3RvdHlwZS5yb3VuZD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcIlxcbiAgLy8gT3BlbkdMIEVTIGRvZXMgbm90IHN1cHBvcnQgcm91bmQgZnVuY3Rpb24uXFxuICAvLyBUaGUgYWxnb3JpdGhtIGlzIGJhc2VkIG9uIGJhbmtlcidzIHJvdW5kaW5nLlxcbiAgZmxvYXQgYmFzZSA9IGZsb29yKHgpO1xcbiAgaWYgKCh4IC0gYmFzZSkgPCAwLjUpIHtcXG4gICAgcmV0dXJuIGZsb29yKHgpO1xcbiAgfSBlbHNlIGlmICgoeCAtIGJhc2UpID4gMC41KSB7XFxuICAgIHJldHVybiBjZWlsKHgpO1xcbiAgfSBlbHNlIHtcXG4gICAgaWYgKG1vZChiYXNlLCAyLjApID09IDAuMCkge1xcbiAgICAgIHJldHVybiBiYXNlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBiYXNlICsgMS4wO1xcbiAgICB9XFxuICB9XFxuXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5leHA9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIGU9YS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKT9uZXcgQmkodC5zaGFwZSxJaSk6bmV3IEVpKHQuc2hhcGUsSWkpLHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLmV4cG0xPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwicmV0dXJuIGV4cCh4KSAtIDEuMDtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLmxvZz1mdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4gZT1hLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpP25ldyBCaSh0LnNoYXBlLFwiXFxuICB2ZWM0IHJlc3VsdCA9IGxvZyh4KTtcXG4gIHZlYzQgaXNOYU4gPSB2ZWM0KGxlc3NUaGFuKHgsIHZlYzQoMC4wKSkpO1xcbiAgcmVzdWx0LnIgPSBpc05hTi5yID09IDEuMCA/IE5BTiA6IHJlc3VsdC5yO1xcbiAgcmVzdWx0LmcgPSBpc05hTi5nID09IDEuMCA/IE5BTiA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc05hTi5iID09IDEuMCA/IE5BTiA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc05hTi5hID09IDEuMCA/IE5BTiA6IHJlc3VsdC5hO1xcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIik6bmV3IEVpKHQuc2hhcGUsXCJpZiAoeCA8IDAuMCkgcmV0dXJuIE5BTjtcXG4gIHJldHVybiBsb2coeCk7XCIpLHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLmxvZzFwPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwicmV0dXJuIGxvZygxLjAgKyB4KTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLnNxcnQ9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJyZXR1cm4gc3FydCh4KTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLnJzcXJ0PWZ1bmN0aW9uKHQpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5yc3FydCh0KTt2YXIgZT1uZXcgRWkodC5zaGFwZSxcInJldHVybiBpbnZlcnNlc3FydCh4KTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLnNxdWFyZT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcInJldHVybiB4ICogeDtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLnJlY2lwcm9jYWw9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJyZXR1cm4gMS4wIC8geDtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLnJlbHU9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIGU9YS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKT9uZXcgQmkodC5zaGFwZSxGaSk6bmV3IEVpKHQuc2hhcGUsTmkpLHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLnByZWx1PWZ1bmN0aW9uKHQsZSl7dmFyIG49YS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKT9uZXcgRm8oXCJcXG4gIHZlYzQgYUxlc3NUaGFuWmVybyA9IHZlYzQobGVzc1RoYW4oYSwgdmVjNCgwLikpKTtcXG4gIHJldHVybiAoYUxlc3NUaGFuWmVybyAqIChiICogYSkpICsgKCh2ZWM0KDEuMCkgLSBhTGVzc1RoYW5aZXJvKSAqIGEpO1xcblwiLHQuc2hhcGUsZS5zaGFwZSk6bmV3IE1vKFwicmV0dXJuIChhIDwgMC4pID8gYiAqIGEgOiBhO1wiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdKX0sdC5wcm90b3R5cGUuZWx1PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwicmV0dXJuICh4ID49IDAuMCkgPyB4IDogKGV4cCh4KSAtIDEuMCk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5lbHVEZXI9ZnVuY3Rpb24odCxlKXt2YXIgbj1hLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpP25ldyBGbyhcIlxcbiAgdmVjNCBiR1RFWmVybyA9IHZlYzQoZ3JlYXRlclRoYW5FcXVhbChiLCB2ZWM0KDAuKSkpO1xcbiAgcmV0dXJuIChiR1RFWmVybyAqIGEpICsgKCh2ZWM0KDEuMCkgLSBiR1RFWmVybykgKiAoYSAqIChiICsgdmVjNCgxLjApKSkpO1xcblwiLHQuc2hhcGUsZS5zaGFwZSk6bmV3IE1vKFwicmV0dXJuIChiID49IDEuMCkgPyBhIDogYSAqIChiICsgMS4wKTtcIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSl9LHQucHJvdG90eXBlLnNlbHU9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsa2kpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5pbnQ9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJyZXR1cm4gZmxvYXQoaW50KHgpKTtcIiksbj10aGlzLm1ha2VPdXRwdXRBcnJheShlLm91dHB1dFNoYXBlLFwiaW50MzJcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSxuKX0sdC5wcm90b3R5cGUuY2xpcD1mdW5jdGlvbih0LGUsbil7dmFyIHIsbz0ocj1hLmdldEJvb2woXCJXRUJHTF9QQUNLX0NMSVBcIik/bmV3IFBvKHQuc2hhcGUpOm5ldyBCbyh0LnNoYXBlKSkuZ2V0Q3VzdG9tU2V0dXBGdW5jKGUsbik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0XSxudWxsLG8pfSx0LnByb3RvdHlwZS5hYnM9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJyZXR1cm4gYWJzKHgpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuY29tcGxleEFicz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKSxuPW5ldyBMbyh0LnNoYXBlKSxyPVt0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlKHQsZS5jb21wbGV4VGVuc29ycy5yZWFsKSx0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlKHQsZS5jb21wbGV4VGVuc29ycy5pbWFnKV07cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLHIpfSx0LnByb3RvdHlwZS5zaWdtb2lkPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwicmV0dXJuIDEuMCAvICgxLjAgKyBleHAoLTEuMCAqIHgpKTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLnNvZnRwbHVzPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwiXFxuICBmbG9hdCBlcHNpbG9uID0gMS4xOTIwOTI4OTU1MDc4MTI1ZS03O1xcbiAgZmxvYXQgdGhyZXNob2xkID0gbG9nKGVwc2lsb24pICsgMi4wO1xcblxcbiAgYm9vbCB0b29fbGFyZ2UgPSB4ID4gLXRocmVzaG9sZDtcXG4gIGJvb2wgdG9vX3NtYWxsID0geCA8IHRocmVzaG9sZDtcXG5cXG4gIGZsb2F0IHJlc3VsdDtcXG4gIGZsb2F0IGV4cF94ID0gZXhwKHgpO1xcblxcbiAgaWYgKHRvb19sYXJnZSl7XFxuICAgIHJlc3VsdCA9IHg7XFxuICB9XFxuICBlbHNlIGlmICh0b29fc21hbGwpe1xcbiAgICByZXN1bHQgPSBleHBfeDtcXG4gIH1cXG4gIGVsc2V7XFxuICAgIHJlc3VsdCA9IGxvZyhleHBfeCArIDEuMCk7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0O1xcblwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuc2luPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLEFpKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuY29zPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFRpKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUudGFuPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwicmV0dXJuIHRhbih4KTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLmFzaW49ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJyZXR1cm4gYXNpbih4KTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLmFjb3M9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJyZXR1cm4gYWNvcyh4KTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLmF0YW49ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsRGkpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5hdGFuMj1mdW5jdGlvbih0LGUpe3ZhciBuPWEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIik/bmV3IEZvKFwiXFxuICB2ZWM0IHJlc3VsdCA9IGF0YW4oYSwgYik7XFxuICB2ZWM0IGlzTmFOID0gbWluKHZlYzQoaXNuYW4oYSkpICsgdmVjNChpc25hbihiKSksIHZlYzQoMS4wKSk7XFxuICBcXG4gIHJlc3VsdC5yID0gaXNOYU4uciA+IDAuID8gTkFOIDogcmVzdWx0LnI7XFxuICByZXN1bHQuZyA9IGlzTmFOLmcgPiAwLiA/IE5BTiA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc05hTi5iID4gMC4gPyBOQU4gOiByZXN1bHQuYjtcXG4gIHJlc3VsdC5hID0gaXNOYU4uYSA+IDAuID8gTkFOIDogcmVzdWx0LmE7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcblwiLHQuc2hhcGUsZS5zaGFwZSk6bmV3IE1vKFwiXFxuICBpZiAoaXNuYW4oYSkpIHJldHVybiBhO1xcbiAgaWYgKGlzbmFuKGIpKSByZXR1cm4gYjtcXG5cXG4gIHJldHVybiBhdGFuKGEsIGIpO1xcblwiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdKX0sdC5wcm90b3R5cGUuc2luaD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcIlxcbiAgZmxvYXQgZTJ4ID0gZXhwKHgpO1xcbiAgcmV0dXJuIChlMnggLSAxLjAgLyBlMngpIC8gMi4wO1xcblwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuY29zaD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxcIlxcbiAgZmxvYXQgZTJ4ID0gZXhwKC14KTtcXG4gIHJldHVybiAoZTJ4ICsgMS4wIC8gZTJ4KSAvIDIuMDtcXG5cIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLnRhbmg9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsXCJcXG4gIGZsb2F0IGUyeCA9IGV4cCgtMi4wICogYWJzKHgpKTtcXG4gIHJldHVybiBzaWduKHgpICogKDEuMCAtIGUyeCkgLyAoMS4wICsgZTJ4KTtcXG5cIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLmFzaW5oPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBFaSh0LnNoYXBlLFwicmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCArIDEuMCkpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sdC5wcm90b3R5cGUuYWNvc2g9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEVpKHQuc2hhcGUsT2kpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSx0LnByb3RvdHlwZS5hdGFuaD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSxfaSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLmVyZj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgRWkodC5zaGFwZSwnXFxuICAvLyBFcnJvciBmdW5jdGlvbiBpcyBjYWxjdWxhdGVkIGFwcHJveGltYXRlbHkgd2l0aCBlbGVtZW50YXJ5IGZ1bmN0aW9uLlxcbiAgLy8gU2VlIFwiSGFuZGJvb2sgb2YgTWF0aGVtYXRpY2FsIEZ1bmN0aW9ucyB3aXRoIEZvcm11bGFzLFxcbiAgLy8gR3JhcGhzLCBhbmQgTWF0aGVtYXRpY2FsIFRhYmxlc1wiLCBBYnJhbW93aXR6IGFuZCBTdGVndW4uXFxuICBmbG9hdCBwID0gMC4zMjc1OTExO1xcbiAgZmxvYXQgYTEgPSAwLjI1NDgyOTU5MjtcXG4gIGZsb2F0IGEyID0gLTAuMjg0NDk2NzM2O1xcbiAgZmxvYXQgYTMgPSAxLjQyMTQxMzc0MTtcXG4gIGZsb2F0IGE0ID0gLTEuNDUzMTUyMDI3O1xcbiAgZmxvYXQgYTUgPSAxLjA2MTQwNTQyOTtcXG5cXG4gIGZsb2F0IHQgPSAxLjAgLyAoMS4wICsgcCAqIHgpO1xcbiAgcmV0dXJuIDEuMCAtICgoKCgoYTUqdCArIGE0KSp0KSArIGEzKSp0ICsgYTIpKnQgKyBhMSkqdCpleHAoLXgqeCk7XFxuJyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LHQucHJvdG90eXBlLnN0ZXA9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgRWkodC5zaGFwZSxmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksUmkrXCJcXG4gICAgcmV0dXJuIHggPiAwLjAgPyAxLjAgOiBmbG9hdChcIit0K1wiKTtcXG4gIFwifShlKSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0XSl9LHQucHJvdG90eXBlLmNvbnYyZEJ5TWF0TXVsPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10LnNoYXBlLG89dGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCksaT1uLmluQ2hhbm5lbHMscz1yWzBdKnJbMV0qclsyXSx1PW4ub3V0Q2hhbm5lbHMsbD0oMT09PXN8fDE9PT11KSYmaT4xZTMsYz1yWzJdJTIhPTAmJiEhby5pc1BhY2tlZDtpZihsfHwhYS5nZXRCb29sKFwiV0VCR0xfTEFaSUxZX1VOUEFDS1wiKXx8IWEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIil8fCFjKXt2YXIgaD10aGlzLnJlc2hhcGUodCxbMSxyWzBdKnJbMV0qclsyXSxuLmluQ2hhbm5lbHNdKSxwPXRoaXMucmVzaGFwZShlLFsxLG4uaW5DaGFubmVscyxuLm91dENoYW5uZWxzXSk7cmV0dXJuIHRoaXMucmVzaGFwZSh0aGlzLmJhdGNoTWF0TXVsKGgscCwhMSwhMSksbi5vdXRTaGFwZSl9dmFyIGY9ZnQubWFrZShbMSxyWzBdKnJbMV0qKHJbMl0rMSksbi5pbkNoYW5uZWxzXSx7ZGF0YUlkOnQuZGF0YUlkfSx0LmR0eXBlLHRoaXMpLHY9by5zaGFwZTtvLnNoYXBlPW8uc2hhcGUuc2xpY2UoKSxvLnNoYXBlW28uc2hhcGUubGVuZ3RoLTJdKyssZChnZShvLnNoYXBlLGYuc2hhcGUpLGZ1bmN0aW9uKCl7cmV0dXJuXCJwYWNrZWQgcmVzaGFwZSBcIitvLnNoYXBlK1wiIHRvIFwiK2Yuc2hhcGUrXCIgaXNuJ3QgZnJlZVwifSk7dmFyIG09dGhpcy5yZXNoYXBlKGUsWzEsbi5pbkNoYW5uZWxzLG4ub3V0Q2hhbm5lbHNdKSxnPXRoaXMuYmF0Y2hNYXRNdWwoZixtLCExLCExKSx5PXRoaXMudGV4RGF0YS5nZXQoZy5kYXRhSWQpO3JldHVybiBkKHkuaXNQYWNrZWQsZnVuY3Rpb24oKXtyZXR1cm5cImJhdGNoTWF0TXVsIHJlc3VsdCBpcyBleHBlY3RlZCB0byBiZSBwYWNrZWRcIn0pLG8uc2hhcGU9dix5LnNoYXBlPW4ub3V0U2hhcGUsZnQubWFrZShuLm91dFNoYXBlLHtkYXRhSWQ6Zy5kYXRhSWR9LGcuZHR5cGUsdGhpcyl9LHQucHJvdG90eXBlLmNvbnYyZFdpdGhJbTJSb3c9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW4uZmlsdGVyV2lkdGgsbz1uLmZpbHRlckhlaWdodCxhPW4uaW5DaGFubmVscyxpPW4ub3V0V2lkdGgscz1uLm91dEhlaWdodCx1PXIqbyphLGw9cyppLGM9W3UsbF0saD10LnNxdWVlemUoWzBdKSxwPWUucmVzaGFwZShbMSx1LC0xXSksZj1uZXcgemEoYyxoLnNoYXBlLG4pLGQ9dGhpcy5jb21waWxlQW5kUnVuKGYsW2hdKS5yZXNoYXBlKFsxLGNbMF0sY1sxXV0pLHY9bmV3ICRhKGQuc2hhcGUsWzEsbCxuLm91dENoYW5uZWxzXSwhMCwhMSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bih2LFtkLHBdKS5yZXNoYXBlKFsxLHMsaSxuLm91dENoYW5uZWxzXSl9LHQucHJvdG90eXBlLmNvbnYyZD1mdW5jdGlvbih0LGUsbil7aWYoMT09PW4uZmlsdGVySGVpZ2h0JiYxPT09bi5maWx0ZXJXaWR0aCYmMT09PW4uZGlsYXRpb25IZWlnaHQmJjE9PT1uLmRpbGF0aW9uV2lkdGgmJjE9PT1uLnN0cmlkZUhlaWdodCYmMT09PW4uc3RyaWRlV2lkdGgmJihcIlNBTUVcIj09PW4ucGFkSW5mby50eXBlfHxcIlZBTElEXCI9PT1uLnBhZEluZm8udHlwZSkpcmV0dXJuIHRoaXMuY29udjJkQnlNYXRNdWwodCxlLG4pO2lmKGEuZ2V0Qm9vbChcIldFQkdMX0NPTlZfSU0yQ09MXCIpJiYxPT09dC5zaGFwZVswXSlyZXR1cm4gdGhpcy5jb252MmRXaXRoSW0yUm93KHQsZSxuKTt2YXIgcj1uZXcgam8obik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKX0sdC5wcm90b3R5cGUuY29udjJkRGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBWbyhuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSx0LnByb3RvdHlwZS5jb252MmREZXJGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyB6byhuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSx0LnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByO3JldHVybiBhLmdldEJvb2woXCJXRUJHTF9QQUNLX0RFUFRIV0lTRUNPTlZcIikmJm4uc3RyaWRlV2lkdGg8PTImJm4ub3V0Q2hhbm5lbHMvbi5pbkNoYW5uZWxzPT0xPyhyPW5ldyBZbyhuKSx0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSx0aGlzLm1ha2VQYWNrZWRUZW5zb3Iobi5vdXRTaGFwZSx0LmR0eXBlKSkpOihyPW5ldyBYbyhuKSx0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSkpfSx0LnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkREZXJJbnB1dD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3ICRvKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSl9LHQucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IEhvKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSl9LHQucHJvdG90eXBlLmNvbnYzZD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IEtvKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSl9LHQucHJvdG90eXBlLmNvbnYzZERlcklucHV0PWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgcW8obik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKX0sdC5wcm90b3R5cGUuY29udjNkRGVyRmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgR28obik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKX0sdC5wcm90b3R5cGUubWF4UG9vbD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBKYShlLFwibWF4XCIsITEpLHI9dGhpcy5tYWtlT3V0cHV0QXJyYXkobi5vdXRwdXRTaGFwZSx0LmR0eXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3RdLHIpfSx0LnByb3RvdHlwZS5hdmdQb29sPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IEphKGUsXCJhdmdcIiwhMSkscj10aGlzLm1ha2VPdXRwdXRBcnJheShuLm91dHB1dFNoYXBlLFwiZmxvYXQzMlwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3RdLHIpfSx0LnByb3RvdHlwZS5tYXhQb29sQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89bmV3IEphKHIsXCJtYXhcIiwhMCksYT10aGlzLmNvbXBpbGVBbmRSdW4obyxbZV0pLGk9bmV3IEhhKHIpLHM9dGhpcy5tYWtlT3V0cHV0QXJyYXkoaS5vdXRwdXRTaGFwZSxlLmR0eXBlKSx1PXRoaXMuY29tcGlsZUFuZFJ1bihpLFt0LGFdLHMpO3JldHVybiBhLmRpc3Bvc2UoKSx1fSx0LnByb3RvdHlwZS5hdmdQb29sQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBTbyhuKSxvPXRoaXMubWFrZU91dHB1dEFycmF5KHIub3V0cHV0U2hhcGUsZS5kdHlwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0XSxvKX0sdC5wcm90b3R5cGUuY2FzdD1mdW5jdGlvbih0LGUpe3JldHVybiBKbih0LGUsdGhpcyl9LHQucHJvdG90eXBlLnVuc3RhY2s9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5zaGFwZVtlXSxyPW5ldyBBcnJheSh0LnJhbmstMSksbz0wLGE9MDthPHQucmFuazthKyspYSE9PWUmJihyW28rK109dC5zaGFwZVthXSk7dmFyIGk9bmV3IEFycmF5KHQucmFuaykuZmlsbCgwKSxzPXQuc2hhcGUuc2xpY2UoKTtzW2VdPTE7dmFyIHU9bmV3IEFycmF5KG4pO2ZvcihhPTA7YTx1Lmxlbmd0aDthKyspaVtlXT1hLHVbYV09dGhpcy5zbGljZSh0LGkscykucmVzaGFwZShyKTtyZXR1cm4gdX0sdC5wcm90b3R5cGUucmVzaGFwZT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpO3JldHVybiFuLmlzUGFja2VkfHxnZSh0LnNoYXBlLGUpfHxudWxsIT09bi50ZXh0dXJlJiZnZShuLnNoYXBlLGUpP1puKHQsZSk6dGhpcy5wYWNrZWRSZXNoYXBlKHQsZSl9LHQucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPWEuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfSU1BR0VfT1BFUkFUSU9OU1wiKT9uZXcgcmkodC5zaGFwZSxlLG4scik6bmV3IG5pKHQuc2hhcGUsZSxuLHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obyxbdF0pfSx0LnByb3RvdHlwZS5yZXNpemVCaWxpbmVhckJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgZWkodCxlLG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdF0pfSx0LnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3I9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89bmV3IGFpKHQuc2hhcGUsZSxuLHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obyxbdF0pfSx0LnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3JCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IG9pKHQsZSxuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3RdKX0sdC5wcm90b3R5cGUubXVsdGlub21pYWw9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89ZT90OlRuKHQpLGE9by5zaGFwZVswXSxpPW8uc2hhcGVbMV0scz1uZXcgamEoYSxpLG4pLHU9dGhpcy5tYWtlT3V0cHV0QXJyYXkocy5vdXRwdXRTaGFwZSxcImludDMyXCIpLGw9cy5nZXRDdXN0b21TZXR1cEZ1bmMocik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihzLFtvXSx1LGwpfSx0LnByb3RvdHlwZS5vbmVIb3Q9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89bmV3IEthKHQuc2l6ZSxlLG4scik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihvLFt0XSl9LHQucHJvdG90eXBlLm5vbk1heFN1cHByZXNzaW9uPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIGplKFwidGYubm9uTWF4U3VwcHJlc3Npb24oKSBpbiB3ZWJnbCBsb2NrcyB0aGUgVUkgdGhyZWFkLiBDYWxsIHRmLm5vbk1heFN1cHByZXNzaW9uQXN5bmMoKSBpbnN0ZWFkXCIpLGFyKHQuZGF0YVN5bmMoKSxlLmRhdGFTeW5jKCksbixyLG8pfSx0LnByb3RvdHlwZS5jcm9wQW5kUmVzaXplPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2YXIgaT1uZXcgUW8odC5zaGFwZSxlLnNoYXBlLHIsbyxhKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGksW3QsZSxuXSl9LHQucHJvdG90eXBlLmRlcHRoVG9TcGFjZT1mdW5jdGlvbih0LGUsbil7ZChlPjEsZnVuY3Rpb24oKXtyZXR1cm5cImJsb2NrU2l6ZSBzaG91bGQgYmUgPiAxIGZvciBkZXB0aFRvU3BhY2UsIGJ1dCB3YXM6IFwiK2V9KTt2YXIgcj10LnNoYXBlWzBdLG89XCJOSFdDXCI9PT1uP3Quc2hhcGVbMV06dC5zaGFwZVsyXSxhPVwiTkhXQ1wiPT09bj90LnNoYXBlWzJdOnQuc2hhcGVbM10saT1cIk5IV0NcIj09PW4/dC5zaGFwZVszXTp0LnNoYXBlWzFdLHM9byplLHU9YSplLGw9aS8oZSplKSxjPW5ldyB0YShcIk5IV0NcIj09PW4/W3Iscyx1LGxdOltyLGwscyx1XSxlLG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oYyxbdF0pfSx0LnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHNyKHQsZSxuKX0sdC5wcm90b3R5cGUuc2NhdHRlck5EPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1wbigwLHQsbiksbz1yLnNsaWNlUmFuayxhPXIubnVtVXBkYXRlcyxpPXIuc2xpY2VTaXplLHM9ci5zdHJpZGVzLHU9ci5vdXRwdXRTaXplLGw9W3UvaSxpXSxjPXQucmVzaGFwZShbYSxvXSksaD1lLnJlc2hhcGUoW2EsaV0pO2lmKDA9PT11KXJldHVybiBabihGbihbXSksbik7dmFyIHA9Qm4oMCksZj1uZXcgdWkoYSxvLGMucmFuayxoLnJhbmsscyxsKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGYsW2gsYyxwXSkucmVzaGFwZShuKX0sdC5wcm90b3R5cGUuc3BhcnNlVG9EZW5zZT1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1wbigwLHQsbiksYT1vLnNsaWNlUmFuayxpPW8ubnVtVXBkYXRlcyxzPW8uc3RyaWRlcyx1PW8ub3V0cHV0U2l6ZSxsPW5ldyB1aShpLGEsdC5yYW5rLGUucmFuayxzLFt1LDFdLCExKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGwsW2UsdCxyXSkucmVzaGFwZShuKX0sdC5wcm90b3R5cGUuZmZ0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmZmdEltcGwodCwhMSl9LHQucHJvdG90eXBlLmlmZnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZmZ0SW1wbCh0LCEwKX0sdC5wcm90b3R5cGUuZmZ0SW1wbD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLHI9bmV3IG9hKG5hLHQuc2hhcGUsZSksbz1uZXcgb2EocmEsdC5zaGFwZSxlKSxhPVt0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlKHQsbi5jb21wbGV4VGVuc29ycy5yZWFsKSx0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySGFuZGxlKHQsbi5jb21wbGV4VGVuc29ycy5pbWFnKV0saT10aGlzLmNvbXBpbGVBbmRSdW4ocixhKSxzPXRoaXMuY29tcGlsZUFuZFJ1bihvLGEpLHU9dGhpcy5jb21wbGV4KGkscykuYXMyRCh0LnNoYXBlWzBdLHQuc2hhcGVbMV0pO3JldHVybiBpLmRpc3Bvc2UoKSxzLmRpc3Bvc2UoKSx1fSx0LnByb3RvdHlwZS5nYXRoZXJORD1mdW5jdGlvbih0LGUpe3ZhciBuPWUuc2hhcGUscj1uW24ubGVuZ3RoLTFdLG89dW4odCxlKSxhPW9bMF0saT1vWzFdLHM9b1syXSx1PW9bM10sbD1lLnJlc2hhcGUoW2kscl0pLGM9dC5yZXNoYXBlKFt0LnNpemUvcyxzXSksaD1uZXcgY2Eocix1LFtpLHNdKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGgsW2MsbF0pLnJlc2hhcGUoYSl9LHQucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24odCxlLG4pe2lmKFwic3RyaW5nXCI9PT0obj1ufHxXKGUpKSl7dmFyIHI9QShuLHkodCkpO3JldHVybiByLmZpbGwoZSksZnQubWFrZSh0LHt2YWx1ZXM6cn0sbil9dmFyIG89bmV3IGFhKHQsZSksYT1vLmdldEN1c3RvbVNldHVwRnVuYyhlKSxpPXRoaXMubWFrZU91dHB1dEFycmF5KHQsbik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihvLFtdLGksYSl9LHQucHJvdG90eXBlLm9uZXNMaWtlPWZ1bmN0aW9uKHQpe2lmKFwic3RyaW5nXCI9PT10LmR0eXBlKXRocm93IG5ldyBFcnJvcihcIm9uZXNMaWtlIGlzIG5vdCBzdXBwb3J0ZWQgdW5kZXIgc3RyaW5nIGR0eXBlXCIpO3JldHVybiB0aGlzLmZpbGwodC5zaGFwZSwxLHQuZHR5cGUpfSx0LnByb3RvdHlwZS56ZXJvc0xpa2U9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZmlsbCh0LnNoYXBlLFwic3RyaW5nXCI9PT10LmR0eXBlP1wiXCI6MCx0LmR0eXBlKX0sdC5wcm90b3R5cGUubGluc3BhY2U9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0cih0LGUsbil9LHQucHJvdG90eXBlLm1ha2VPdXRwdXRBcnJheT1mdW5jdGlvbih0LGUpe3JldHVybiBmdC5tYWtlKHQse30sZSx0aGlzKX0sdC5wcm90b3R5cGUubWFrZVBhY2tlZFRlbnNvcj1mdW5jdGlvbih0LGUpe3ZhciBuPWZ0Lm1ha2UodCx7fSxlLHRoaXMpO3JldHVybiB0aGlzLnRleERhdGEuZ2V0KG4uZGF0YUlkKS5pc1BhY2tlZD0hMCxufSx0LnByb3RvdHlwZS51bnBhY2tUZW5zb3I9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IFBpKHQuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0sZnQubWFrZShlLm91dHB1dFNoYXBlLHt9LHQuZHR5cGUsdGhpcykpfSx0LnByb3RvdHlwZS5wYWNrVGVuc29yPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBYYSh0LnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdLHRoaXMubWFrZVBhY2tlZFRlbnNvcih0LnNoYXBlLHQuZHR5cGUpKX0sdC5wcm90b3R5cGUucGFja2VkUmVzaGFwZT1mdW5jdGlvbih0LGUpe3ZhciBuPXQucmVzaGFwZShbZmUodC5zaGFwZSldLmNvbmNhdChkZSh0LnNoYXBlKSkpLHI9W2ZlKGUpXS5jb25jYXQoZGUoZSkpLG89bmV3IHRpKHIsbi5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihvLFtuXSkucmVzaGFwZShlKX0sdC5wcm90b3R5cGUuY29tcGlsZUFuZFJ1bj1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz10aGlzO2lmKG51bGw9PW4mJihuPXQudXNlc1BhY2tlZFRleHR1cmVzP3RoaXMubWFrZVBhY2tlZFRlbnNvcih0Lm91dHB1dFNoYXBlLGVbMF0uZHR5cGUpOnRoaXMubWFrZU91dHB1dEFycmF5KHQub3V0cHV0U2hhcGUsZVswXS5kdHlwZSkpLDA9PT1uLnNpemUpcmV0dXJuIHRoaXMudGV4RGF0YS5nZXQobi5kYXRhSWQpLnZhbHVlcz1JKG4uZHR5cGUsMCksbjt2YXIgaT1lLm1hcChmdW5jdGlvbihlKXtpZihcImNvbXBsZXg2NFwiPT09ZS5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJHUEdQVVByb2dyYW0gZG9lcyBub3Qgc3VwcG9ydCBjb21wbGV4NjQgaW5wdXQuIEZvciBjb21wbGV4NjQgZHR5cGVzLCBwbGVhc2Ugc2VwYXJhdGUgdGhlIHByb2dyYW0gaW50byByZWFsIGFuZCBpbWFnaW5hcnkgcGFydHMuXCIpO3ZhciBuPW8udGV4RGF0YS5nZXQoZS5kYXRhSWQpO2lmKG51bGw9PW4udGV4dHVyZSl7aWYoIXQudXNlc1BhY2tlZFRleHR1cmVzJiZ5KGUuc2hhcGUpPD1hLmdldE51bWJlcihcIldFQkdMX1NJWkVfVVBMT0FEX1VOSUZPUk1cIikpcmV0dXJue3NoYXBlOmUuc2hhcGUsdGV4RGF0YTpudWxsLGlzVW5pZm9ybTohMCx1bmlmb3JtVmFsdWVzOm4udmFsdWVzfTt0LnVzZXNQYWNrZWRUZXh0dXJlcyYmKG4uaXNQYWNrZWQ9ITAsbi5zaGFwZT1lLnNoYXBlKX1lbHNlIGlmKCEhbi5pc1BhY2tlZCE9ISF0LnVzZXNQYWNrZWRUZXh0dXJlcyllPW4uaXNQYWNrZWQ/by51bnBhY2tUZW5zb3IoZSk6by5wYWNrVGVuc29yKGUpLG49by50ZXhEYXRhLmdldChlLmRhdGFJZCk7ZWxzZSBpZihuLmlzUGFja2VkJiYhZ2Uobi5zaGFwZSxlLnNoYXBlKSl7dmFyIHI9ZSxpPWUuc2hhcGU7ZS5zaGFwZT1uLnNoYXBlLGU9by5wYWNrZWRSZXNoYXBlKGUsaSksbj1vLnRleERhdGEuZ2V0KGUuZGF0YUlkKSxyLnNoYXBlPWl9cmV0dXJuIG8udXBsb2FkVG9HUFUoZS5kYXRhSWQpLHtzaGFwZTplLnNoYXBlLHRleERhdGE6bixpc1VuaWZvcm06ITF9fSk7dGhpcy51cGxvYWRUb0dQVShuLmRhdGFJZCk7dmFyIHMsdT17c2hhcGU6bi5zaGFwZSx0ZXhEYXRhOnRoaXMudGV4RGF0YS5nZXQobi5kYXRhSWQpLGlzVW5pZm9ybTohMX0sbD1mdW5jdGlvbih0LGUsbil7dmFyIHI9XCJcIjtlLmNvbmNhdChuKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBlPW51bGwhPXQudGV4RGF0YSYmbnVsbCE9dC50ZXhEYXRhLnNsaWNlJiZ0LnRleERhdGEuc2xpY2UuZmxhdE9mZnNldD4wLG49dC5pc1VuaWZvcm0/XCJ1bmlmb3JtXCI6dC50ZXhEYXRhLnRleFNoYXBlO3IrPXQuc2hhcGUrXCJfXCIrbitcIl9cIitlfSk7dmFyIG89dC51c2VyQ29kZSxhPXQuY29uc3RydWN0b3IubmFtZTtyZXR1cm4gYSs9XCJfXCIrcitcIl9cIitvfSh0LGksdSksYz10aGlzLmdldEFuZFNhdmVCaW5hcnkobCxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyKXt2YXIgbz1lLnVzZXJDb2RlLGk9bi5tYXAoZnVuY3Rpb24odCxuKXt2YXIgcj17bG9naWNhbFNoYXBlOnQuc2hhcGUsdGV4U2hhcGU6dC5pc1VuaWZvcm0/bnVsbDp0LnRleERhdGEudGV4U2hhcGUsaXNVbmlmb3JtOnQuaXNVbmlmb3JtLGlzUGFja2VkOiF0LmlzVW5pZm9ybSYmdC50ZXhEYXRhLmlzUGFja2VkLGZsYXRPZmZzZXQ6bnVsbH07cmV0dXJuIG51bGwhPXQudGV4RGF0YSYmbnVsbCE9dC50ZXhEYXRhLnNsaWNlJiZ0LnRleERhdGEuc2xpY2UuZmxhdE9mZnNldD4wJiYoci5mbGF0T2Zmc2V0PXQudGV4RGF0YS5zbGljZS5mbGF0T2Zmc2V0KSx7bmFtZTplLnZhcmlhYmxlTmFtZXNbbl0sc2hhcGVJbmZvOnJ9fSkscz1pLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZUluZm99KSx1PXtsb2dpY2FsU2hhcGU6ci5zaGFwZSx0ZXhTaGFwZTpyLnRleERhdGEudGV4U2hhcGUsaXNVbmlmb3JtOiExLGlzUGFja2VkOnIudGV4RGF0YS5pc1BhY2tlZCxmbGF0T2Zmc2V0Om51bGx9LGw9aG8oaSx1LG8sZS51c2VzUGFja2VkVGV4dHVyZXMpLGM9dC5jcmVhdGVQcm9ncmFtKGwpLGg9bnVsbCxwPXQuZ2V0VW5pZm9ybUxvY2F0aW9uKGMsXCJOQU5cIiwhMSk7MT09PWEuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSYmKGg9dC5nZXRVbmlmb3JtTG9jYXRpb24oYyxcIklORklOSVRZXCIsITEpKTtmb3IodmFyIGY9e30sZD0wO2Q8ZS52YXJpYWJsZU5hbWVzLmxlbmd0aDtkKyspe3ZhciB2PWUudmFyaWFibGVOYW1lc1tkXTtmW3ZdPXQuZ2V0VW5pZm9ybUxvY2F0aW9uKGMsdiwhMSksZltcIm9mZnNldFwiK3ZdPXQuZ2V0VW5pZm9ybUxvY2F0aW9uKGMsXCJvZmZzZXRcIit2LCExKX1yZXR1cm57cHJvZ3JhbTplLHNvdXJjZTpsLHdlYkdMUHJvZ3JhbTpjLHVuaWZvcm1Mb2NhdGlvbnM6ZixpblNoYXBlSW5mb3M6cyxvdXRTaGFwZUluZm86dSxpbmZMb2M6aCxuYW5Mb2M6cH19KG8uZ3BncHUsdCxpLHUpfSksaD1udWxsIT10aGlzLmFjdGl2ZVRpbWVycztyZXR1cm4gaCYmKHM9dGhpcy5zdGFydFRpbWVyKCkpLGZ1bmN0aW9uKHQsZSxuLHIsbyl7VWEoZS5pblNoYXBlSW5mb3MsbiksVWEoW2Uub3V0U2hhcGVJbmZvXSxbcl0pO3ZhciBpPXIudGV4RGF0YS50ZXh0dXJlLHM9ci50ZXhEYXRhLnRleFNoYXBlO3IudGV4RGF0YS5pc1BhY2tlZD90LnNldE91dHB1dFBhY2tlZE1hdHJpeFRleHR1cmUoaSxzWzBdLHNbMV0pOnQuc2V0T3V0cHV0TWF0cml4VGV4dHVyZShpLHNbMF0sc1sxXSksdC5zZXRQcm9ncmFtKGUud2ViR0xQcm9ncmFtKSwxPT09YS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpJiZudWxsIT09ZS5pbmZMb2MmJnQuZ2wudW5pZm9ybTFmKGUuaW5mTG9jLDEvMCksbnVsbCE9PWUubmFuTG9jJiZ0LmdsLnVuaWZvcm0xZihlLm5hbkxvYyxOYU4pLG4uZm9yRWFjaChmdW5jdGlvbihuLHIpe3ZhciBvPWUucHJvZ3JhbS52YXJpYWJsZU5hbWVzW3JdLGE9ZS51bmlmb3JtTG9jYXRpb25zW29dLGk9ZS51bmlmb3JtTG9jYXRpb25zW1wib2Zmc2V0XCIrb107aWYobnVsbCE9YSlpZihuLmlzVW5pZm9ybSlpZih5KG4uc2hhcGUpPDIpdC5nbC51bmlmb3JtMWYoYSxuLnVuaWZvcm1WYWx1ZXNbMF0pO2Vsc2V7dmFyIHM9bi51bmlmb3JtVmFsdWVzO3MgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXl8fChzPW5ldyBGbG9hdDMyQXJyYXkocykpLHQuZ2wudW5pZm9ybTFmdihhLHMpfWVsc2UgbnVsbCE9bi50ZXhEYXRhLnNsaWNlJiZudWxsIT1pJiZ0LmdsLnVuaWZvcm0xaShpLG4udGV4RGF0YS5zbGljZS5mbGF0T2Zmc2V0KSx0LnNldElucHV0TWF0cml4VGV4dHVyZShuLnRleERhdGEudGV4dHVyZSxhLHIpfSksbnVsbCE9byYmbyh0LGUud2ViR0xQcm9ncmFtKSx0LmV4ZWN1dGVQcm9ncmFtKCl9KHRoaXMuZ3BncHUsYyxpLHUsciksaCYmKHM9dGhpcy5lbmRUaW1lcihzKSx0aGlzLmFjdGl2ZVRpbWVycy5wdXNoKHtuYW1lOnQuY29uc3RydWN0b3IubmFtZSxxdWVyeTp0aGlzLmdldFF1ZXJ5VGltZShzKX0pKSxhLmdldEJvb2woXCJXRUJHTF9MQVpJTFlfVU5QQUNLXCIpfHwhdGhpcy50ZXhEYXRhLmdldChuLmRhdGFJZCkuaXNQYWNrZWR8fHQuaXNQYWNrU2hhZGVyP246dGhpcy51bnBhY2tUZW5zb3Iobil9LHQucHJvdG90eXBlLmdldEFuZFNhdmVCaW5hcnk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCBpbiB0aGlzLmJpbmFyeUNhY2hlfHwodGhpcy5iaW5hcnlDYWNoZVt0XT1lKCkpLHRoaXMuYmluYXJ5Q2FjaGVbdF19LHQucHJvdG90eXBlLmdldFRleHR1cmVNYW5hZ2VyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGV4dHVyZU1hbmFnZXJ9LHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLmRpc3Bvc2VkfHwodGhpcy50ZXh0dXJlTWFuYWdlci5kaXNwb3NlKCksdGhpcy5jYW52YXMucmVtb3ZlKCksbnVsbCE9dGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0JiZ0aGlzLmZyb21QaXhlbHMyRENvbnRleHQuY2FudmFzLnJlbW92ZSgpLHRoaXMuZ3BncHVDcmVhdGVkTG9jYWxseSYmKHRoaXMuZ3BncHUucHJvZ3JhbT1udWxsLHRoaXMuZ3BncHUuZGlzcG9zZSgpKSx0aGlzLmRpc3Bvc2VkPSEwKX0sdC5wcm90b3R5cGUuZmxvYXRQcmVjaXNpb249ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiBudWxsPT10aGlzLmZsb2F0UHJlY2lzaW9uVmFsdWUmJih0aGlzLmZsb2F0UHJlY2lzaW9uVmFsdWU9RmUoZnVuY3Rpb24oKXt2YXIgZT1hLmdldEJvb2woXCJERUJVR1wiKTthLnNldChcIkRFQlVHXCIsITEpO3ZhciBuPXQuYWJzKEJuKDFlLTgpKS5kYXRhU3luYygpWzBdO3JldHVybiBhLnNldChcIkRFQlVHXCIsZSksbj4wPzMyOjE2fSkpLHRoaXMuZmxvYXRQcmVjaXNpb25WYWx1ZX0sdC5wcm90b3R5cGUuZXBzaWxvbj1mdW5jdGlvbigpe3JldHVybiAzMj09PXRoaXMuZmxvYXRQcmVjaXNpb24oKT8xZS03OjFlLTR9LHQucHJvdG90eXBlLnVwbG9hZFRvR1BVPWZ1bmN0aW9uKHQpe3ZhciBlLG49dGhpcy50ZXhEYXRhLmdldCh0KSxyPW4uc2hhcGUsbz1uLmR0eXBlLGE9bi52YWx1ZXMsaT1uLnRleHR1cmUscz1uLnVzYWdlLHU9bi5pc1BhY2tlZDtpZihudWxsPT1pKXt2YXIgbCxjPW51bGwhPXRoaXMuYWN0aXZlVGltZXJzO2MmJihsPXBlcmZvcm1hbmNlLm5vdygpKTt2YXIgaD12ZShyLHUpO24udGV4U2hhcGU9aDt2YXIgcD10aGlzLmFjcXVpcmVUZXh0dXJlKGgscyxvLHUpO2lmKG4udGV4dHVyZT1wLG51bGwhPWEpe2lmKHUpe3ZhciBmPWZlKHIpLGQ9MSx2PTE7ci5sZW5ndGgmJihkPShlPWRlKHIpKVswXSx2PWVbMV0pLHRoaXMuZ3BncHUudXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlKHAsZixkLHYsaFswXSxoWzFdLHppKGEpKX1lbHNlIHRoaXMuZ3BncHUudXBsb2FkTWF0cml4VG9UZXh0dXJlKHAsaFswXSxoWzFdLHppKGEpKTtuLnZhbHVlcz1udWxsLGMmJih0aGlzLnVwbG9hZFdhaXRNcys9cGVyZm9ybWFuY2Uubm93KCktbCl9fX0sdC5wcm90b3R5cGUuY29udmVydEFuZENhY2hlT25DUFU9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnRleERhdGEuZ2V0KHQpLHI9bi5kdHlwZTtyZXR1cm4gdGhpcy5yZWxlYXNlR1BVRGF0YSh0KSxuLnVzYWdlPXVhLlVQTE9BRCxudWxsIT1lJiYobi52YWx1ZXM9ZnVuY3Rpb24odCxlKXtpZihcImZsb2F0MzJcIj09PWV8fFwiY29tcGxleDY0XCI9PT1lKXJldHVybiB0O2lmKFwiaW50MzJcIj09PWV8fFwiYm9vbFwiPT09ZSl7Zm9yKHZhciBuPVwiaW50MzJcIj09PWU/bmV3IEludDMyQXJyYXkodC5sZW5ndGgpOm5ldyBVaW50OEFycmF5KHQubGVuZ3RoKSxyPTA7cjxuLmxlbmd0aDsrK3IpbltyXT1NYXRoLnJvdW5kKHRbcl0pO3JldHVybiBufXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZHR5cGUgXCIrZSl9KGUscikpLG4udmFsdWVzfSx0LnByb3RvdHlwZS5hY3F1aXJlVGV4dHVyZT1mdW5jdGlvbih0LGUsbixyKXtpZih0aGlzLm51bUJ5dGVzSW5HUFUrPXRoaXMuY29tcHV0ZUJ5dGVzKHQsbiksIXRoaXMud2FybmVkQWJvdXRNZW1vcnkmJnRoaXMubnVtQnl0ZXNJbkdQVT4xMDI0KnRoaXMubnVtTUJCZWZvcmVXYXJuaW5nKjEwMjQpe3ZhciBvPSh0aGlzLm51bUJ5dGVzSW5HUFUvMTAyNC8xMDI0KS50b0ZpeGVkKDIpO3RoaXMud2FybmVkQWJvdXRNZW1vcnk9ITAsY29uc29sZS53YXJuKFwiSGlnaCBtZW1vcnkgdXNhZ2UgaW4gR1BVOiBcIitvK1wiIE1CLCBtb3N0IGxpa2VseSBkdWUgdG8gYSBtZW1vcnkgbGVha1wiKX1yZXR1cm4gdGhpcy50ZXh0dXJlTWFuYWdlci5hY3F1aXJlVGV4dHVyZSh0LGUscil9LHQucHJvdG90eXBlLmNvbXB1dGVCeXRlcz1mdW5jdGlvbih0LGUpe3JldHVybiB0WzBdKnRbMV0qTShlKX0sdH0oKTtmdW5jdGlvbiB6aSh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheT90Om5ldyBGbG9hdDMyQXJyYXkodCl9T3QoKSYmRHQucmVnaXN0ZXJCYWNrZW5kKFwid2ViZ2xcIixmdW5jdGlvbigpe3JldHVybiBuZXcgVWl9LDIpO3ZhciBWaT1Bbih7YWJzXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwiYWJzXCIpO3JldHVyblwiY29tcGxleDY0XCI9PT1lLmR0eXBlP0R0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb21wbGV4QWJzKGUpfSx7JHg6ZX0pOkR0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQuYWJzKGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi50b0Zsb2F0KCkuc3RlcCgtMSkpfX19KX19KSxHaT1Bbih7YWNvc186ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImFjb3NcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQuYWNvcyhlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2U3RyaWN0KEJuKDEpLnN1YihuLnRvRmxvYXQoKS5zcXVhcmUoKSkuc3FydCgpKS5uZWcoKX19fSl9fSkscWk9QW4oe2Fjb3NoXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwiYWNvc2hcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQuYWNvc2goZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdlN0cmljdChuLnRvRmxvYXQoKS5zcXVhcmUoKS5zdWIoMSkuc3FydCgpKX19fSl9fSksSGk9QW4oe2FzaW5fOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJhc2luXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LmFzaW4oZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdlN0cmljdChCbigxKS5zdWIobi50b0Zsb2F0KCkuc3F1YXJlKCkpLnNxcnQoKSl9fX0pfX0pLCRpPUFuKHthc2luaF86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImFzaW5oXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LmFzaW5oKGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXZTdHJpY3QoQm4oMSkuYWRkKG4udG9GbG9hdCgpLnNxdWFyZSgpKS5zcXJ0KCkpfX19KX19KSxqaT1Bbih7YXRhbl86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImF0YW5cIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQuYXRhbihlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2KG4udG9GbG9hdCgpLnNxdWFyZSgpLmFkZCgxKSl9fX0pfX0pLEtpPUFuKHthdGFuaF86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImF0YW5oXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LmF0YW5oKGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXYoQm4oMSkuc3ViKG4udG9GbG9hdCgpLnNxdWFyZSgpKSl9fX0pfX0pLFhpPUFuKHtjZWlsXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwiY2VpbFwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNlaWwoZSl9LHskeDplfSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4odCl9fX0pfX0pLFlpPUFuKHtjbGlwQnlWYWx1ZV86ZnVuY3Rpb24odCxlLG4pe3ZhciByPXduKHQsXCJ4XCIsXCJjbGlwQnlWYWx1ZVwiKTtyZXR1cm4gZChlPD1uLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjbGlwOiBtaW4gKFwiK2UrXCIpIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIG1heCAoXCIrbitcIikuXCJ9KSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxvKXt2YXIgYT10LmNsaXAocixlLG4pO3JldHVybiBvKFtyXSksYX0seyR4OnJ9LGZ1bmN0aW9uKHQscil7dmFyIG89clswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC53aGVyZShvLmdyZWF0ZXJFcXVhbChlKS5sb2dpY2FsQW5kKG8ubGVzc0VxdWFsKG4pKSxYbih0KSl9fX0pfX0pLFFpPUFuKHtjb3NfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJjb3NcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQuY29zKGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gbi50b0Zsb2F0KCkuc2luKCkubmVnKCkubXVsKHQpfX19KX19KSxKaT1Bbih7Y29zaF86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImNvc2hcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQuY29zaChlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIG4udG9GbG9hdCgpLnNpbmgoKS5tdWxTdHJpY3QodCl9fX0pfX0pLFppPUFuKHtlcmZfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJlcmZcIik7cmV0dXJuIGQoXCJpbnQzMlwiPT09ZS5kdHlwZXx8XCJmbG9hdDMyXCI9PT1lLmR0eXBlLGZ1bmN0aW9uKCl7cmV0dXJuXCJJbnB1dCBkdHlwZSBtdXN0IGJlIGBpbnQzMmAgb3IgYGZsb2F0MzJgLlwifSksXCJpbnQzMlwiPT09ZS5kdHlwZSYmKGU9ZS50b0Zsb2F0KCkpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQuZXJmKGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5zcXVhcmUoKS5uZWcoKS5leHAoKS5tdWwoMi9NYXRoLnNxcnQoTWF0aC5QSSkpKX19fSl9fSksdHM9QW4oe2V4cF86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImV4cFwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5leHAoZSk7cmV0dXJuIG4oW3JdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWxTdHJpY3QoZVswXSl9fX0pfX0pLGVzPUFuKHtleHBtMV86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImV4cG0xXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LmV4cG0xKGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5leHAoKSl9fX0pfX0pLG5zPUFuKHtmbG9vcl86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcImZsb29yXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuZmxvb3IoZSl9LHskeDplfSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4odCl9fX0pfX0pLHJzPUFuKHtsb2dfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJsb2dcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQubG9nKGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXYobi50b0Zsb2F0KCkpfX19KX19KSxvcz1Bbih7bG9nMXBfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJsb2cxcFwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5sb2cxcChlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2KG4uYWRkKDEpKX19fSl9fSksYXM9QW4oe2xvZ1NpZ21vaWRfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJsb2dTaWdtb2lkXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LnNvZnRwbHVzKGUubmVnKCkpLm5lZygpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5uZWcoKS5zaWdtb2lkKCkpfX19KX19KSxpcz1Bbih7bmVnXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwibmVnXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQubmVnKGUpfSx7JHg6ZX0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubmVnKCl9fX0pfX0pLHNzPUFuKHtyZWNpcHJvY2FsXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwicmVjaXByb2NhbFwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5yZWNpcHJvY2FsKGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXYobi5zcXVhcmUoKS5uZWcoKSl9fX0pfX0pLHVzPUFuKHtyb3VuZF86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcInJvdW5kXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQucm91bmQoZSl9LHskeDplfSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4odCl9fX0pfX0pLGxzPUFuKHtyc3FydF86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcInJzcXJ0XCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LnJzcXJ0KGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXYobi5wb3coMS41KS5tdWwoMikpLm5lZygpfX19KX19KSxjcz1Bbih7c2lnbW9pZF86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcInNpZ21vaWRcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQuc2lnbW9pZChlKTtyZXR1cm4gbihbcl0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4ubXVsKEJuKDEpLnN1YihuKSkpfX19KX19KSxocz1Bbih7c2lnbl86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcInNpZ25cIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaWduKGUpfSx7JHg6ZX0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KX19KSxwcz1Bbih7aXNOYU5fOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJpc05hTlwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlzTmFOKGUpfSx7JHg6ZX0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KX19KSxmcz1Bbih7aXNJbmZfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJpc0luZlwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlzSW5mKGUpfSx7JHg6ZX0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KX19KSxkcz1Bbih7aXNGaW5pdGVfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJpc0Zpbml0ZVwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlzRmluaXRlKGUpfSx7JHg6ZX0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KX19KSx2cz1Bbih7c2luXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwic2luXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LnNpbihlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIG4udG9GbG9hdCgpLmNvcygpLm11bCh0KX19fSl9fSksbXM9QW4oe3NpbmhfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJzaW5oXCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LnNpbmgoZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBuLnRvRmxvYXQoKS5jb3NoKCkubXVsU3RyaWN0KHQpfX19KX19KSxncz1Bbih7c29mdHBsdXNfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJzb2Z0cGx1c1wiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5zb2Z0cGx1cyhlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4uc2lnbW9pZCgpKX19fSl9fSkseXM9QW4oe3NxcnRfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJzcXJ0XCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxuKXt2YXIgcj10LnNxcnQoZSk7cmV0dXJuIG4oW2VdKSxyfSx7JHg6ZX0sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdihuLnRvRmxvYXQoKS5zcXJ0KCkubXVsKDIpKX19fSl9fSkseHM9QW4oe3NxdWFyZV86ZnVuY3Rpb24odCl7dmFyIGU9d24odCxcInhcIixcInNxdWFyZVwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7cmV0dXJuIG4oW2VdKSx0LnNxdWFyZShlKX0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi50b0Zsb2F0KCkubXVsKDIpKX19fSl9fSksd3M9QW4oe3N0ZXBfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9MCk7dmFyIG49d24odCxcInhcIixcInN0ZXBcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5zdGVwKG4sZSl9LHskeDpufSxmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4odCl9fX0pfX0pLGJzPUFuKHt0YW5fOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJ0YW5cIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQudGFuKGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXYobi5jb3MoKS5zcXVhcmUoKSl9fX0pfX0pLENzPUFuKHt0YW5oXzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwidGFuaFwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC50YW5oKGUpO3JldHVybiBuKFtyXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gQm4oMSkuc3ViKG4uc3F1YXJlKCkpLm11bFN0cmljdCh0KX19fSl9fSk7ZnVuY3Rpb24gRXModCxlLG4scixvLGEpe3ZhciBpLHMsdT13bih0LFwieFwiLFwiYmF0Y2hOb3JtXCIpLGw9d24oZSxcIm1lYW5cIixcImJhdGNoTm9ybVwiKSxjPXduKG4sXCJ2YXJpYW5jZVwiLFwiYmF0Y2hOb3JtXCIpO3JldHVybiBudWxsIT1vJiYoaT13bihvLFwic2NhbGVcIixcImJhdGNoTm9ybVwiKSksbnVsbCE9ciYmKHM9d24ocixcIm9mZnNldFwiLFwiYmF0Y2hOb3JtXCIpKSxkKDI9PT11LnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTNEOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSxkKDI9PT1sLnJhbmt8fDE9PT1sLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTJEOiBtZWFuIG11c3QgYmUgcmFuayAyIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrbC5yYW5rK1wiLlwifSksZCgyPT09Yy5yYW5rfHwxPT09Yy5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0yRDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitjLnJhbmsrXCIuXCJ9KSxudWxsIT1pJiZkKDI9PT1pLnJhbmt8fDE9PT1pLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTJEOiBzY2FsZSBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2kucmFuaytcIi5cIn0pLG51bGwhPXMmJmQoMj09PXMucmFua3x8MT09PXMucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtMkQ6IG9mZnNldCBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK3MucmFuaytcIi5cIn0pLE5zKHUsbCxjLHMsaSxhKX1mdW5jdGlvbiBScyh0LGUsbixyLG8sYSl7dmFyIGkscyx1PXduKHQsXCJ4XCIsXCJiYXRjaE5vcm1cIiksbD13bihlLFwibWVhblwiLFwiYmF0Y2hOb3JtXCIpLGM9d24obixcInZhcmlhbmNlXCIsXCJiYXRjaE5vcm1cIik7cmV0dXJuIG51bGwhPW8mJihpPXduKG8sXCJzY2FsZVwiLFwiYmF0Y2hOb3JtXCIpKSxudWxsIT1yJiYocz13bihyLFwib2Zmc2V0XCIsXCJiYXRjaE5vcm1cIikpLGQoMz09PXUucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pLGQoMz09PWwucmFua3x8MT09PWwucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtM0Q6IG1lYW4gbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitsLnJhbmsrXCIuXCJ9KSxkKDM9PT1jLnJhbmt8fDE9PT1jLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTNEOiB2YXJpYW5jZSBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2MucmFuaytcIi5cIn0pLG51bGwhPWkmJmQoMz09PWkucmFua3x8MT09PWkucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtM0Q6IHNjYWxlIG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIraS5yYW5rK1wiLlwifSksbnVsbCE9cyYmZCgzPT09cy5yYW5rfHwxPT09cy5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0zRDogb2Zmc2V0IG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrcy5yYW5rK1wiLlwifSksTnModSxsLGMscyxpLGEpfWZ1bmN0aW9uIFNzKHQsZSxuLHIsbyxhKXt2YXIgaSxzLHU9d24odCxcInhcIixcImJhdGNoTm9ybVwiKSxsPXduKGUsXCJtZWFuXCIsXCJiYXRjaE5vcm1cIiksYz13bihuLFwidmFyaWFuY2VcIixcImJhdGNoTm9ybVwiKTtyZXR1cm4gbnVsbCE9byYmKGk9d24obyxcInNjYWxlXCIsXCJiYXRjaE5vcm1cIikpLG51bGwhPXImJihzPXduKHIsXCJvZmZzZXRcIixcImJhdGNoTm9ybVwiKSksZCg0PT09dS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm00RDogeCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSksZCg0PT09bC5yYW5rfHwxPT09bC5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm00RDogbWVhbiBtdXN0IGJlIHJhbmsgNCBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2wucmFuaytcIi5cIn0pLGQoND09PWMucmFua3x8MT09PWMucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtNEQ6IHZhcmlhbmNlIG11c3QgYmUgcmFuayA0IG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrYy5yYW5rK1wiLlwifSksbnVsbCE9aSYmZCg0PT09aS5yYW5rfHwxPT09aS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm00RDogc2NhbGUgbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitpLnJhbmsrXCIuXCJ9KSxudWxsIT1zJiZkKDQ9PT1zLnJhbmt8fDE9PT1zLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTREOiBvZmZzZXQgbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitzLnJhbmsrXCIuXCJ9KSxOcyh1LGwsYyxzLGksYSl9ZnVuY3Rpb24gTnModCxlLG4scixvLGEpe251bGw9PWEmJihhPS4wMDEpO3ZhciBpLHMsdSxsPXduKHQsXCJ4XCIsXCJiYXRjaE5vcm1cIiksYz13bihlLFwibWVhblwiLFwiYmF0Y2hOb3JtXCIpLGg9d24obixcInZhcmlhbmNlXCIsXCJiYXRjaE5vcm1cIik7bnVsbCE9byYmKGk9d24obyxcInNjYWxlXCIsXCJiYXRjaE5vcm1cIikpLG51bGwhPXImJihzPXduKHIsXCJvZmZzZXRcIixcImJhdGNoTm9ybVwiKSksZChjLnJhbms9PT1oLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkJhdGNoIG5vcm1hbGl6YXRpb24gZ3JhZGllbnQgcmVxdWlyZXMgbWVhbiBhbmQgdmFyaWFuY2UgdG8gaGF2ZSBlcXVhbCByYW5rcy5cIn0pLGQobnVsbD09c3x8Yy5yYW5rPT09cy5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJCYXRjaCBub3JtYWxpemF0aW9uIGdyYWRpZW50IHJlcXVpcmVzIG1lYW4gYW5kIG9mZnNldCB0byBoYXZlIGVxdWFsIHJhbmtzLlwifSksZChudWxsPT1pfHxjLnJhbms9PT1pLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkJhdGNoIG5vcm1hbGl6YXRpb24gZ3JhZGllbnQgcmVxdWlyZXMgbWVhbiBhbmQgc2NhbGUgdG8gaGF2ZSBlcXVhbCByYW5rcy5cIn0pLHU9MD09PWwucmFua3x8MT09PWwucmFuaz9sLmFzNEQoMSwxLDEsbC5zaXplKToyPT09bC5yYW5rP2wuYXM0RCgxLDEsbC5zaGFwZVswXSxsLnNoYXBlWzFdKTozPT09bC5yYW5rP2wuYXM0RCgxLGwuc2hhcGVbMF0sbC5zaGFwZVsxXSxsLnNoYXBlWzJdKTpsO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbj10LmJhdGNoTm9ybWFsaXphdGlvbih1LGtzKGMpLGtzKGgpLGEsa3MoaSksa3MocykpO3JldHVybiBlKFtsLGMsaCxpXSksbn0seyR4OmwsJG1lYW46YywkdmFyaWFuY2U6aCwkc2NhbGU6aSwkb2Zmc2V0OnN9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV0sbz1lWzJdLGk9ZVszXSxzPW51bGw9PWk/Qm4oMSk6aSxsPWlvKHIuc2hhcGUsdS5zaGFwZSksYz1bXTtpZigxPT09ci5yYW5rKXtmb3IodmFyIGg9MDtoPHUuc2hhcGUubGVuZ3RoLTE7KytoKWMucHVzaCh1LnNoYXBlW2hdKTtjLnB1c2goMSl9dmFyIHA9bi5zdWIociksZj10Lm11bChzKSxkPWxzKG8uYWRkKEJuKGEpKSksdj1kLm11bChkKS5tdWwoZCkubXVsKEJuKC0uNSkpO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiAxPT09ci5yYW5rP3QubXVsKFhyKGQuYXM0RCgxLDEsMSxyLnNoYXBlWzBdKSxjKSkubXVsKHMpLnJlc2hhcGUobi5zaGFwZSk6dC5tdWwoZCkubXVsKHMpLnJlc2hhcGUobi5zaGFwZSl9LCRtZWFuOmZ1bmN0aW9uKCl7dmFyIHQ9ZC5tdWwoQm4oLTEpKS5tdWwoZik7cmV0dXJuIDE9PT1yLnJhbmsmJih0PXQuc3VtKGwpKSx0LnJlc2hhcGUoci5zaGFwZSl9LCR2YXJpYW5jZTpmdW5jdGlvbigpe3ZhciB0PXYubXVsKHApLm11bChmKTtyZXR1cm4gMT09PXIucmFuayYmKHQ9dC5zdW0obCkpLHQucmVzaGFwZShyLnNoYXBlKX0sJHNjYWxlOmZ1bmN0aW9uKCl7dmFyIGU9cC5tdWwoZCksbj10Lm11bChlKTtyZXR1cm4gMT09PXIucmFuayYmKG49bi5zdW0obCkpLG4ucmVzaGFwZShyLnNoYXBlKX0sJG9mZnNldDpmdW5jdGlvbigpe3ZhciBlPXQ7cmV0dXJuIDE9PT1yLnJhbmsmJihlPWUuc3VtKGwpKSxlLnJlc2hhcGUoci5zaGFwZSl9fX0pLnJlc2hhcGUobC5zaGFwZSl9ZnVuY3Rpb24ga3ModCl7cmV0dXJuIG51bGw9PXQ/bnVsbDowPT09dC5yYW5rP3QuYXMxRCgpOjE9PT10LnJhbms/dDoyPT09dC5yYW5rP3QuYXM0RCgxLDEsdC5zaGFwZVswXSx0LnNoYXBlWzFdKTozPT09dC5yYW5rP3QuYXM0RCgxLHQuc2hhcGVbMF0sdC5zaGFwZVsxXSx0LnNoYXBlWzJdKTp0fWZ1bmN0aW9uIElzKCl7RGUoXCJ0Zi5iYXRjaE5vcm1hbGl6YXRpb24oKSBpcyBnb2luZyBhd2F5LiBVc2UgdGYuYmF0Y2hOb3JtKCkgaW5zdGVhZCwgYW5kIG5vdGUgdGhlIHBvc2l0aW9uYWwgYXJndW1lbnQgY2hhbmdlIG9mIHNjYWxlLCBvZmZzZXQsIGFuZCB2YXJpYW5jZUVwc2lsb25cIil9dmFyIEFzPUFuKHtiYXRjaE5vcm1hbGl6YXRpb24yZF86ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB2b2lkIDA9PT1yJiYocj0uMDAxKSxJcygpLEVzKHQsZSxuLGEsbyxyKX19KSxUcz1Bbih7YmF0Y2hOb3JtYWxpemF0aW9uM2RfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjAwMSksSXMoKSxScyh0LGUsbixhLG8scil9fSksRHM9QW4oe2JhdGNoTm9ybWFsaXphdGlvbjRkXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIHZvaWQgMD09PXImJihyPS4wMDEpLElzKCksU3ModCxlLG4sYSxvLHIpfX0pLE9zPUFuKHtiYXRjaE5vcm1hbGl6YXRpb25fOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjAwMSksSXMoKSxOcyh0LGUsbixhLG8scil9fSksX3M9QW4oe2JhdGNoTm9ybV86TnN9KSxNcz1Bbih7YmF0Y2hOb3JtMmRfOkVzfSksRnM9QW4oe2JhdGNoTm9ybTNkXzpSc30pLEJzPUFuKHtiYXRjaE5vcm00ZF86U3N9KTtmdW5jdGlvbiBQcyh0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1pJiYoaT1cImNoYW5uZWxzTGFzdFwiKTt2YXIgcyx1PVVzKGUpLGw9dVswXSxjPXVbMV07aWYoXCJjaGFubmVsc0xhc3RcIj09PWkpcz1bbCxjLHRbM10sdFszXV07ZWxzZXtpZihcImNoYW5uZWxzRmlyc3RcIiE9PWkpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhRm9ybWF0IFwiK2kpO3M9W2wsYyx0WzFdLHRbMV1dfXJldHVybiBMcyh0LHMsbixyLG8sYSwhMSxpKX1mdW5jdGlvbiBMcyh0LGUsbixyLG8sYSxpLHMpe3ZvaWQgMD09PWkmJihpPSExKSx2b2lkIDA9PT1zJiYocz1cImNoYW5uZWxzTGFzdFwiKTt2YXIgdT1bLTEsLTEsLTEsLTFdLGw9dVswXSxjPXVbMV0saD11WzJdLHA9dVszXTtpZihcImNoYW5uZWxzTGFzdFwiPT09cylsPXRbMF0sYz10WzFdLGg9dFsyXSxwPXRbM107ZWxzZXtpZihcImNoYW5uZWxzRmlyc3RcIiE9PXMpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhRm9ybWF0IFwiK3MpO2w9dFswXSxwPXRbMV0sYz10WzJdLGg9dFszXX12YXIgZix2PWVbMF0sbT1lWzFdLGc9ZVszXSx5PVVzKG4pLHg9eVswXSxiPXlbMV0sQz1VcyhyKSxFPUNbMF0sUj1DWzFdLFM9VnModixFKSxOPVZzKG0sUiksaz1mdW5jdGlvbih0LGUsbixyLG8sYSxpLHMpe3ZhciB1LGwsYztpZihcIm51bWJlclwiPT10eXBlb2YgdCl7dmFyIGg9MD09PXQ/XCJWQUxJRFwiOlwiTlVNQkVSXCI7dT17dG9wOnQsYm90dG9tOnQsbGVmdDp0LHJpZ2h0OnQsdHlwZTpofTt2YXIgcD1mdW5jdGlvbih0LGUsbixyLG8sYSl7bnVsbD09byYmKG89ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9MSk7dmFyIG89VnMoZSxyKTtyZXR1cm4gTWF0aC5mbG9vcigodFswXSoobi0xKS1uK28pLzIpfSh0LGUscikpO3ZhciBpPXRbMF0scz10WzFdLHU9R3MoKGktZSsyKm8pL3IrMSxhKTtkKHcodSksZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBvdXRwdXQgIyBvZiByb3dzIChcIit1K1wiKSBtdXN0IGJlIGFuIGludGVnZXIuIENoYW5nZSB0aGUgc3RyaWRlIGFuZC9vciB6ZXJvIHBhZCBwYXJhbWV0ZXJzXCJ9KTt2YXIgbD1Hcygocy1lKzIqbykvcisxLGEpO3JldHVybiBkKHcobCksZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBvdXRwdXQgIyBvZiBjb2x1bW5zIChcIitsK1wiKSBtdXN0IGJlIGFuIGludGVnZXIuIENoYW5nZSB0aGUgc3RyaWRlIGFuZC9vciB6ZXJvIHBhZCBwYXJhbWV0ZXJzXCJ9KSxbdSxsLG5dfShbZSxuLDFdLGEsMSxyLHQscyk7bD1wWzBdLGM9cFsxXX1lbHNlIGlmKFwic2FtZVwiPT09dCl7bD1NYXRoLmNlaWwoZS9yKSxjPU1hdGguY2VpbChuL28pO3ZhciBmPU1hdGgubWF4KDAsKGwtMSkqcithLWUpLHY9TWF0aC5tYXgoMCwoYy0xKSpvK2ktbiksbT1NYXRoLmZsb29yKGYvMiksZz1mLW0seT1NYXRoLmZsb29yKHYvMikseD12LXk7dT17dG9wOm0sYm90dG9tOmcsbGVmdDp5LHJpZ2h0OngsdHlwZTpcIlNBTUVcIn19ZWxzZXtpZihcInZhbGlkXCIhPT10KXRocm93IEVycm9yKFwiVW5rbm93biBwYWRkaW5nIHBhcmFtZXRlcjogXCIrdCk7dT17dG9wOjAsYm90dG9tOjAsbGVmdDowLHJpZ2h0OjAsdHlwZTpcIlZBTElEXCJ9LGw9TWF0aC5jZWlsKChlLWErMSkvciksYz1NYXRoLmNlaWwoKG4taSsxKS9vKX1yZXR1cm57cGFkSW5mbzp1LG91dEhlaWdodDpsLG91dFdpZHRoOmN9fShvLGMsaCx4LGIsUyxOLGEpLEk9ay5wYWRJbmZvLEE9ay5vdXRIZWlnaHQsVD1rLm91dFdpZHRoLEQ9aT9nKnA6ZztyZXR1cm5cImNoYW5uZWxzRmlyc3RcIj09PXM/Zj1bbCxELEEsVF06XCJjaGFubmVsc0xhc3RcIj09PXMmJihmPVtsLEEsVCxEXSkse2JhdGNoU2l6ZTpsLGRhdGFGb3JtYXQ6cyxpbkhlaWdodDpjLGluV2lkdGg6aCxpbkNoYW5uZWxzOnAsb3V0SGVpZ2h0OkEsb3V0V2lkdGg6VCxvdXRDaGFubmVsczpELHBhZEluZm86SSxzdHJpZGVIZWlnaHQ6eCxzdHJpZGVXaWR0aDpiLGZpbHRlckhlaWdodDp2LGZpbHRlcldpZHRoOm0sZWZmZWN0aXZlRmlsdGVySGVpZ2h0OlMsZWZmZWN0aXZlRmlsdGVyV2lkdGg6TixkaWxhdGlvbkhlaWdodDpFLGRpbGF0aW9uV2lkdGg6UixpblNoYXBlOnQsb3V0U2hhcGU6ZixmaWx0ZXJTaGFwZTplfX1mdW5jdGlvbiBXcyh0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1hJiYoYT0hMSksdm9pZCAwPT09aSYmKGk9XCJjaGFubmVsc0xhc3RcIik7dmFyIHM9Wy0xLC0xLC0xLC0xLC0xXSx1PXNbMF0sbD1zWzFdLGM9c1syXSxoPXNbM10scD1zWzRdO2lmKFwiY2hhbm5lbHNMYXN0XCI9PT1pKXU9dFswXSxsPXRbMV0sYz10WzJdLGg9dFszXSxwPXRbNF07ZWxzZXtpZihcImNoYW5uZWxzRmlyc3RcIiE9PWkpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhRm9ybWF0IFwiK2kpO3U9dFswXSxwPXRbMV0sbD10WzJdLGM9dFszXSxoPXRbNF19dmFyIGYsZD1lWzBdLHY9ZVsxXSxtPWVbMl0sZz1lWzRdLHk9enMobikseD15WzBdLHc9eVsxXSxiPXlbMl0sQz16cyhyKSxFPUNbMF0sUj1DWzFdLFM9Q1syXSxOPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkscyx1LGwpe3ZhciBjLGgscCxmO2lmKFwic2FtZVwiPT09dCl7aD1NYXRoLmNlaWwoZS9vKSxwPU1hdGguY2VpbChuL2EpLGY9TWF0aC5jZWlsKHIvaSk7dmFyIGQ9KGgtMSkqbytzLWUsdj0ocC0xKSphK3UtbixtPShmLTEpKmkrbC1yLGc9TWF0aC5mbG9vcihkLzIpLHk9ZC1nLHg9TWF0aC5mbG9vcih2LzIpLHc9di14LGI9TWF0aC5mbG9vcihtLzIpLEM9bS1iO2M9e3RvcDp4LGJvdHRvbTp3LGxlZnQ6YixyaWdodDpDLGZyb250OmcsYmFjazp5LHR5cGU6XCJTQU1FXCJ9fWVsc2V7aWYoXCJ2YWxpZFwiIT09dCl0aHJvdyBFcnJvcihcIlVua25vd24gcGFkZGluZyBwYXJhbWV0ZXI6IFwiK3QpO2M9e3RvcDowLGJvdHRvbTowLGxlZnQ6MCxyaWdodDowLGZyb250OjAsYmFjazowLHR5cGU6XCJWQUxJRFwifSxoPU1hdGguY2VpbCgoZS1zKzEpL28pLHA9TWF0aC5jZWlsKChuLXUrMSkvYSksZj1NYXRoLmNlaWwoKHItbCsxKS9pKX1yZXR1cm57cGFkSW5mbzpjLG91dERlcHRoOmgsb3V0SGVpZ2h0OnAsb3V0V2lkdGg6Zn19KG8sbCxjLGgseCx3LGIsVnMoZCxFKSxWcyh2LFIpLFZzKG0sUykpLGs9Ti5wYWRJbmZvLEk9Ti5vdXREZXB0aCxBPU4ub3V0SGVpZ2h0LFQ9Ti5vdXRXaWR0aCxEPWE/ZypwOmc7cmV0dXJuXCJjaGFubmVsc0ZpcnN0XCI9PT1pP2Y9W3UsRCxJLEEsVF06XCJjaGFubmVsc0xhc3RcIj09PWkmJihmPVt1LEksQSxULERdKSx7YmF0Y2hTaXplOnUsZGF0YUZvcm1hdDppLGluRGVwdGg6bCxpbkhlaWdodDpjLGluV2lkdGg6aCxpbkNoYW5uZWxzOnAsb3V0RGVwdGg6SSxvdXRIZWlnaHQ6QSxvdXRXaWR0aDpULG91dENoYW5uZWxzOkQscGFkSW5mbzprLHN0cmlkZURlcHRoOngsc3RyaWRlSGVpZ2h0Oncsc3RyaWRlV2lkdGg6YixmaWx0ZXJEZXB0aDpkLGZpbHRlckhlaWdodDp2LGZpbHRlcldpZHRoOm0sZGlsYXRpb25EZXB0aDpFLGRpbGF0aW9uSGVpZ2h0OlIsZGlsYXRpb25XaWR0aDpTLGluU2hhcGU6dCxvdXRTaGFwZTpmLGZpbHRlclNoYXBlOmV9fWZ1bmN0aW9uIFVzKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0P1t0LHRdOnR9ZnVuY3Rpb24genModCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/W3QsdCx0XTp0fWZ1bmN0aW9uIFZzKHQsZSl7cmV0dXJuIGU8PTE/dDp0Kyh0LTEpKihlLTEpfWZ1bmN0aW9uIEdzKHQsZSl7aWYoIWUpcmV0dXJuIHQ7c3dpdGNoKGUpe2Nhc2VcInJvdW5kXCI6cmV0dXJuIE1hdGgucm91bmQodCk7Y2FzZVwiY2VpbFwiOnJldHVybiBNYXRoLmNlaWwodCk7Y2FzZVwiZmxvb3JcIjpyZXR1cm4gTWF0aC5mbG9vcih0KTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVua25vd24gcm91bmRpbmdNb2RlIFwiK2UpfX1mdW5jdGlvbiBxcyh0KXt2YXIgZT1Vcyh0KSxuPWVbMF0scj1lWzFdO3JldHVybiAxPT09biYmMT09PXJ9ZnVuY3Rpb24gSHModCxlKXtyZXR1cm4gcXModCl8fHFzKGUpfWZ1bmN0aW9uICRzKHQsZSxuLHIsbyxhKXtkKHQubGVuZ3RoPT09ZS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJMZW5ndGggb2YgaW5TaGFwZSAoXCIrdC5sZW5ndGgrXCIpIGFuZCByYW5rIG9mIGR5IChcIitlLnJhbmsrXCIpIG11c3QgbWF0Y2hcIn0pO3ZhciBpPXQscz1lLHU9ITE7Mz09PWUucmFuayYmKHU9ITAscz1lLmFzNEQoMSxlLnNoYXBlWzBdLGUuc2hhcGVbMV0sZS5zaGFwZVsyXSksaT1bMSx0WzBdLHRbMV0sdFsyXV0pO3ZhciBsPWlbM10sYz1zLnNoYXBlWzNdO2QoND09PWkubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogaW5TaGFwZSBtdXN0IGJlIGxlbmd0aCA0LCBidXQgZ290IGxlbmd0aCBcIitpLmxlbmd0aCtcIi5cIn0pLGQoND09PXMucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGR5IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrcy5yYW5rfSksZCg0PT09bi5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrbi5yYW5rfSksZChsPT09bi5zaGFwZVsyXSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGRlcHRoIG9mIGlucHV0IChcIitsK1wiKSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIrbi5zaGFwZVsyXStcIi5cIn0pLGQoYz09PW4uc2hhcGVbM10sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBkZXB0aCBvZiBvdXRwdXQgKFwiK2MrXCIpIG11c3QgbWF0Y2ggb3V0cHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIrbi5zaGFwZVszXStcIi5cIn0pLG51bGwhPWEmJmQodyhvKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK2ErXCIgYnV0IGdvdCBwYWQgXCIrbytcIi5cIn0pO3ZhciBoPUxzKGksbi5zaGFwZSxyLDEsbyxhKSxwPUR0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciByPXQuY29udjJkRGVySW5wdXQocyxuLGgpO3JldHVybiBlKFtuLHNdKSxyfSx7ZHk0RDpzLGZpbHRlcjpufSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0saT1lWzFdO3JldHVybntkeTREOmZ1bmN0aW9uKCl7cmV0dXJuIFlzKHQsbixyLG8sXCJOSFdDXCIsMSxhKX0sZmlsdGVyOmZ1bmN0aW9uKCl7cmV0dXJuIEpzKHQsaSxuLnNoYXBlLHIsbyxhKX19fSk7cmV0dXJuIHU/cC5hczNEKHAuc2hhcGVbMV0scC5zaGFwZVsyXSxwLnNoYXBlWzNdKTpwfWZ1bmN0aW9uIGpzKHQsZSxuLHIsbyxhKXt2YXIgaT10OzM9PT10LnJhbmsmJihpPXQuYXM0RCgxLHQuc2hhcGVbMF0sdC5zaGFwZVsxXSx0LnNoYXBlWzJdKSk7dmFyIHM9ZTszPT09cy5yYW5rJiYocz1lLmFzNEQoMSxlLnNoYXBlWzBdLGUuc2hhcGVbMV0sZS5zaGFwZVsyXSkpLGQoND09PWkucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBzaGFwZSBcIitpLnNoYXBlK1wiLlwifSksZCg0PT09cy5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGR5IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHNoYXBlIFwiK3Muc2hhcGUrXCIuXCJ9KSxkKDQ9PT1uLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBmaWx0ZXJTaGFwZSBtdXN0IGJlIGxlbmd0aCA0LCBidXQgZ290IFwiK24rXCIuXCJ9KSxkKGkuc2hhcGVbM109PT1uWzJdLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGRlcHRoIG9mIGlucHV0IFwiK2kuc2hhcGVbM10rXCIpIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggaW4gZmlsdGVyIChcIituWzJdK1wiLlwifSksZChzLnNoYXBlWzNdPT09blszXSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBkZXB0aCBvZiBkeSAoXCIrcy5zaGFwZVszXStcIikgbXVzdCBtYXRjaCBvdXRwdXQgZGVwdGggZm9yIGZpbHRlciAoXCIrblszXStcIikuXCJ9KSxudWxsIT1hJiZkKHcobyksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIrYStcIiBidXQgZ290IHBhZCBcIitvK1wiLlwifSk7dmFyIHU9THMoaS5zaGFwZSxuLHIsMSxvLGEpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuY29udjJkRGVyRmlsdGVyKGkscyx1KX0se3g0RDppLGR5NEQ6c30pfWZ1bmN0aW9uIEtzKHQpe3ZhciBlPWZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0P1t0LHQsdF06Mj09PXQubGVuZ3RoP1t0WzBdLHRbMV0sMV06dH0odCksbj1lWzBdLHI9ZVsxXSxvPWVbMl07cmV0dXJuIDE9PT1uJiYxPT09ciYmMT09PW99dmFyIFhzPUFuKHtjb252MWRfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PW8mJihvPVwiTldDXCIpLHZvaWQgMD09PWEmJihhPTEpO3ZhciBzPXduKHQsXCJ4XCIsXCJjb252MWRcIiksdT13bihlLFwiZmlsdGVyXCIsXCJjb252MWRcIiksbD1zLGM9ITE7Mj09PXMucmFuayYmKGM9ITAsbD1zLmFzM0QoMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0pKSxkKDM9PT1sLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYxZDogaW5wdXQgbXVzdCBiZSByYW5rIDMsIGJ1dCBnb3QgcmFuayBcIitsLnJhbmsrXCIuXCJ9KSxkKDM9PT11LnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYxZDogZmlsdGVyIG11c3QgYmUgcmFuayAzLCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSksbnVsbCE9aSYmZCh3KHIpLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MWQ6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK2krXCIgYnV0IGdvdCBwYWQgXCIrcitcIi5cIn0pLGQobC5zaGFwZVsyXT09PXUuc2hhcGVbMV0sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYxZDogZGVwdGggb2YgaW5wdXQgKFwiK2wuc2hhcGVbMl0rXCIpIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIGZpbHRlciBcIit1LnNoYXBlWzFdK1wiLlwifSksZChIcyhuLGEpLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MUQ6IEVpdGhlciBzdHJpZGUgb3IgZGlsYXRpb24gbXVzdCBiZSAxLiBHb3Qgc3RyaWRlIFwiK24rXCIgYW5kIGRpbGF0aW9uICdcIithK1wiJ1wifSksZChcIk5XQ1wiPT09byxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjFkOiBnb3QgZGF0YUZvcm1hdCBvZiBcIitvK1wiIGJ1dCBvbmx5IE5XQyBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLlwifSk7dmFyIGg9dS5hczREKDEsdS5zaGFwZVswXSx1LnNoYXBlWzFdLHUuc2hhcGVbMl0pLHA9bC5hczREKGwuc2hhcGVbMF0sMSxsLnNoYXBlWzFdLGwuc2hhcGVbMl0pLGY9WXMocCxoLFsxLG5dLHIsXCJOSFdDXCIsWzEsYV0saSk7cmV0dXJuIGM/Zi5hczJEKGYuc2hhcGVbMl0sZi5zaGFwZVszXSk6Zi5hczNEKGYuc2hhcGVbMF0sZi5zaGFwZVsyXSxmLnNoYXBlWzNdKX19KSxZcz1Bbih7Y29udjJkXzpmdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1vJiYobz1cIk5IV0NcIiksdm9pZCAwPT09YSYmKGE9WzEsMV0pO3ZhciBzPXduKHQsXCJ4XCIsXCJjb252MmRcIiksdT13bihlLFwiZmlsdGVyXCIsXCJjb252MmRcIiksbD1zLGM9ITE7Mz09PXMucmFuayYmKGM9ITAsbD1zLmFzNEQoMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0scy5zaGFwZVsyXSkpLGQoND09PWwucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK2wucmFuaytcIi5cIn0pLGQoND09PXUucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSxudWxsIT1pJiZkKHcociksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIraStcIiBidXQgZ290IHBhZCBcIityK1wiLlwifSksZChsLnNoYXBlWzNdPT09dS5zaGFwZVsyXSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkOiBkZXB0aCBvZiBpbnB1dCAoXCIrbC5zaGFwZVszXStcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK3Uuc2hhcGVbMl0rXCIuXCJ9KSxkKEhzKG4sYSksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyRDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrbitcIiBhbmQgZGlsYXRpb25zICdcIithK1wiJ1wifSksZChcIk5IV0NcIj09PW8sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZDogZ290IGRhdGFGb3JtYXQgb2YgXCIrbytcIiBidXQgb25seSBOSFdDIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuXCJ9KTt2YXIgaD1McyhsLnNoYXBlLHUuc2hhcGUsbixhLHIsaSkscD1EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbj10LmNvbnYyZChsLHUsaCk7cmV0dXJuIGUoW3UsbF0pLG59LHt4OmwsJGZpbHRlcjp1fSxmdW5jdGlvbih0LGUpe3ZhciBvPWUsaT1vWzBdLHM9b1sxXTtyZXR1cm4gZChxcyhhKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZ3JhZGllbnQgb2YgY29udjJEOiBkaWxhdGlvbiByYXRlcyBncmVhdGVyIHRoYW4gMSBhcmUgbm90IHlldCBzdXBwb3J0ZWQgaW4gZ3JhZGllbnRzLiBHb3QgZGlsYXRpb25zICdcIithK1wiJ1wifSkse3g6ZnVuY3Rpb24oKXtyZXR1cm4gJHMocy5zaGFwZSx0LGksbixyKX0sJGZpbHRlcjpmdW5jdGlvbigpe3JldHVybiBqcyhzLHQsaS5zaGFwZSxuLHIpfX19KTtyZXR1cm4gYz9wLmFzM0QocC5zaGFwZVsxXSxwLnNoYXBlWzJdLHAuc2hhcGVbM10pOnB9fSksUXM9QW4oe2NvbnYzZF86ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZvaWQgMD09PW8mJihvPVwiTkRIV0NcIiksdm9pZCAwPT09YSYmKGE9WzEsMSwxXSk7dmFyIGk9d24odCxcInhcIixcImNvbnYzZFwiKSxzPXduKGUsXCJmaWx0ZXJcIixcImNvbnYzZFwiKSx1PWksbD0hMTs0PT09aS5yYW5rJiYobD0hMCx1PWkuYXM1RCgxLGkuc2hhcGVbMF0saS5zaGFwZVsxXSxpLnNoYXBlWzJdLGkuc2hhcGVbM10pKSxkKDU9PT11LnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZDogaW5wdXQgbXVzdCBiZSByYW5rIDUsIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSxkKDU9PT1zLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZDogZmlsdGVyIG11c3QgYmUgcmFuayA1LCBidXQgZ290IHJhbmsgXCIrcy5yYW5rK1wiLlwifSksZCh1LnNoYXBlWzRdPT09cy5zaGFwZVszXSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkOiBkZXB0aCBvZiBpbnB1dCAoXCIrdS5zaGFwZVs0XStcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK3Muc2hhcGVbM10rXCIuXCJ9KSxkKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIEtzKHQpfHxLcyhlKX0obixhKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNEOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIituK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK2ErXCInXCJ9KSxkKFwiTkRIV0NcIj09PW8sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZDogZ290IGRhdGFGb3JtYXQgb2YgXCIrbytcIiBidXQgb25seSBOREhXQyBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLlwifSk7dmFyIGM9V3ModS5zaGFwZSxzLnNoYXBlLG4sYSxyKSxoPUR0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBuPXQuY29udjNkKHUscyxjKTtyZXR1cm4gZShbdSxzXSksbn0se3g6dSwkZmlsdGVyOnN9LGZ1bmN0aW9uKHQsZSl7ZChLcyhhKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZ3JhZGllbnQgb2YgY29udjNEOiBkaWxhdGlvbiByYXRlcyBncmVhdGVyIHRoYW4gMSBhcmUgbm90IHlldCBzdXBwb3J0ZWQgaW4gZ3JhZGllbnRzLiBHb3QgZGlsYXRpb25zICdcIithK1wiJ1wifSk7dmFyIG89ZVswXSxpPWVbMV07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scixvKXtkKHQubGVuZ3RoPT09ZS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJMZW5ndGggb2YgaW5TaGFwZSAoXCIrdC5sZW5ndGgrXCIpIGFuZCByYW5rIG9mIGR5IChcIitlLnJhbmsrXCIpIG11c3QgbWF0Y2hcIn0pO3ZhciBhPXQsaT1lLHM9ITE7ND09PWUucmFuayYmKHM9ITAsaT1lLmFzNUQoMSxlLnNoYXBlWzBdLGUuc2hhcGVbMV0sZS5zaGFwZVsyXSxlLnNoYXBlWzNdKSxhPVsxLHRbMF0sdFsxXSx0WzJdLHRbM11dKTt2YXIgdT1hWzRdLGw9aS5zaGFwZVs0XTtkKDU9PT1hLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVySW5wdXQ6IGluU2hhcGUgbXVzdCBiZSBsZW5ndGggNSwgYnV0IGdvdCBsZW5ndGggXCIrYS5sZW5ndGgrXCIuXCJ9KSxkKDU9PT1pLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlcklucHV0OiBkeSBtdXN0IGJlIHJhbmsgNSwgYnV0IGdvdCByYW5rIFwiK2kucmFua30pLGQoNT09PW4ucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVySW5wdXQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNSwgYnV0IGdvdCByYW5rIFwiK24ucmFua30pLGQodT09PW4uc2hhcGVbM10sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlcklucHV0OiBkZXB0aCBvZiBpbnB1dCAoXCIrdStcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK24uc2hhcGVbM10rXCIuXCJ9KSxkKGw9PT1uLnNoYXBlWzRdLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJJbnB1dDogZGVwdGggb2Ygb3V0cHV0IChcIitsK1wiKSBtdXN0IG1hdGNoIG91dHB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK24uc2hhcGVbNF0rXCIuXCJ9KTt2YXIgYz1XcyhhLG4uc2hhcGUsciwxLG8pLGg9RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbnYzZERlcklucHV0KGksbixjKX0se2R5NUQ6aX0pO3JldHVybiBzP2guYXM0RChoLnNoYXBlWzFdLGguc2hhcGVbMl0saC5zaGFwZVszXSxoLnNoYXBlWzRdKTpofShvLnNoYXBlLHQsaSxuLHIpfSwkZmlsdGVyOmZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIsbyl7dmFyIGE9dDs0PT09dC5yYW5rJiYoYT10LmFzNUQoMSx0LnNoYXBlWzBdLHQuc2hhcGVbMV0sdC5zaGFwZVsyXSx0LnNoYXBlWzNdKSk7dmFyIGk9ZTs0PT09aS5yYW5rJiYoaT1lLmFzNUQoMSxlLnNoYXBlWzBdLGUuc2hhcGVbMV0sZS5zaGFwZVsyXSxlLnNoYXBlWzNdKSksZCg1PT09YS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJGaWx0ZXI6IGlucHV0IG11c3QgYmUgcmFuayA1LCBidXQgZ290IHNoYXBlIFwiK2Euc2hhcGUrXCIuXCJ9KSxkKDU9PT1pLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlckZpbHRlcjogZHkgbXVzdCBiZSByYW5rIDUsIGJ1dCBnb3Qgc2hhcGUgXCIraS5zaGFwZStcIi5cIn0pLGQoNT09PW4ubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJGaWx0ZXI6IGZpbHRlclNoYXBlIG11c3QgYmUgbGVuZ3RoIDUsIGJ1dCBnb3QgXCIrbitcIi5cIn0pLGQoYS5zaGFwZVs0XT09PW5bM10sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlckZpbHRlcjogZGVwdGggb2YgaW5wdXQgXCIrYS5zaGFwZVs0XStcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBpbiBmaWx0ZXIgKFwiK25bM10rXCIuXCJ9KSxkKGkuc2hhcGVbNF09PT1uWzRdLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJGaWx0ZXI6IGRlcHRoIG9mIGR5IChcIitpLnNoYXBlWzRdK1wiKSBtdXN0IG1hdGNoIG91dHB1dCBkZXB0aCBmb3IgZmlsdGVyIChcIituWzRdK1wiKS5cIn0pO3ZhciBzPVdzKGEuc2hhcGUsbixyLDEsbyk7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb252M2REZXJGaWx0ZXIoYSxpLHMpfSx7eDVEOmEsZHk1RDppfSl9KG8sdCxpLnNoYXBlLG4scil9fX0pO3JldHVybiBsP2guYXM0RChoLnNoYXBlWzFdLGguc2hhcGVbMl0saC5zaGFwZVszXSxoLnNoYXBlWzRdKTpofX0pLEpzPUFuKHtjb252MmREZXJGaWx0ZXJfOmpzfSksWnM9QW4oe2RlcHRod2lzZUNvbnYyZF86ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dm9pZCAwPT09byYmKG89XCJOSFdDXCIpLHZvaWQgMD09PWEmJihhPVsxLDFdKTt2YXIgcz13bih0LFwieFwiLFwiZGVwdGh3aXNlQ29udjJkXCIpLHU9d24oZSxcImZpbHRlclwiLFwiZGVwdGh3aXNlQ29udjJkXCIpLGw9cyxjPSExOzM9PT1zLnJhbmsmJihjPSEwLGw9cy5hczREKDEscy5zaGFwZVswXSxzLnNoYXBlWzFdLHMuc2hhcGVbMl0pKSxkKDQ9PT1sLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGRlcHRod2lzZUNvbnYyZDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIitsLnJhbmsrXCIuXCJ9KSxkKDQ9PT11LnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGRlcHRod2lzZUNvbnYyZDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSksZChsLnNoYXBlWzNdPT09dS5zaGFwZVsyXSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBudW1iZXIgb2YgaW5wdXQgY2hhbm5lbHMgKFwiK2wuc2hhcGVbM10rXCIpIG11c3QgbWF0Y2ggdGhlIGluQ2hhbm5lbHMgZGltZW5zaW9uIGluIGZpbHRlciBcIit1LnNoYXBlWzJdK1wiLlwifSksbnVsbD09YSYmKGE9WzEsMV0pLGQoSHMobixhKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIituK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK2ErXCInXCJ9KSxudWxsIT1pJiZkKHcociksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGRlcHRod2lzZUNvbnYyZDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIraStcIiBidXQgZ290IHBhZCBcIityK1wiLlwifSk7dmFyIGg9THMobC5zaGFwZSx1LnNoYXBlLG4sYSxyLGksITApLHA9RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5kZXB0aHdpc2VDb252MkQobCx1LGgpO3JldHVybiBlKFtsLHVdKSxufSx7eDpsLCRmaWx0ZXI6dX0sZnVuY3Rpb24odCxlKXtkKHFzKGEpLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBncmFkaWVudCBvZiBkZXB0aHdpc2VDb252MmQ6IGRpbGF0aW9uIHJhdGVzIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3QgeWV0IHN1cHBvcnRlZC4gR290IGRpbGF0aW9ucyAnXCIrYStcIidcIn0pO3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPWUsYT0hMTszPT09ZS5yYW5rJiYoYT0hMCxvPWUuYXM0RCgxLGUuc2hhcGVbMF0sZS5zaGFwZVsxXSxlLnNoYXBlWzJdKSk7dmFyIGk9RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmRlcHRod2lzZUNvbnYyRERlcklucHV0KG8sbixyKX0se2R5NEQ6b30pO3JldHVybiBhP2kuYXMzRChpLnNoYXBlWzFdLGkuc2hhcGVbMl0saS5zaGFwZVszXSk6aX0obi5zaGFwZSx0LHIsaCl9LCRmaWx0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scil7dmFyIG89dDszPT09dC5yYW5rJiYobz10LmFzNEQoMSx0LnNoYXBlWzBdLHQuc2hhcGVbMV0sdC5zaGFwZVsyXSkpO3ZhciBhPWU7cmV0dXJuIDM9PT1hLnJhbmsmJihhPWUuYXM0RCgxLGUuc2hhcGVbMF0sZS5zaGFwZVsxXSxlLnNoYXBlWzJdKSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmRlcHRod2lzZUNvbnYyRERlckZpbHRlcihvLGEscil9LHt4NEQ6byxkeTREOmF9KX0obix0LHIuc2hhcGUsaCl9fX0pO3JldHVybiBjP3AuYXMzRChwLnNoYXBlWzFdLHAuc2hhcGVbMl0scC5zaGFwZVszXSk6cH19KSx0dT1Bbih7c2VwYXJhYmxlQ29udjJkXzpmdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1hJiYoYT1bMSwxXSksdm9pZCAwPT09aSYmKGk9XCJOSFdDXCIpO3ZhciBzPXduKHQsXCJ4XCIsXCJzZXBhcmFibGVDb252MmRcIiksdT13bihlLFwiZGVwdGh3aXNlRmlsdGVyXCIsXCJzZXBhcmFibGVDb252MmRcIiksbD13bihuLFwicG9pbnR3aXNlRmlsdGVyXCIsXCJzZXBhcmFibGVDb252MmRcIiksYz1zLGg9ITE7aWYoMz09PXMucmFuayYmKGg9ITAsYz1zLmFzNEQoMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0scy5zaGFwZVsyXSkpLFwiTkNIV1wiPT09aSl0aHJvdyBuZXcgRXJyb3IoXCJzZXBhcmFibGVDb252MmQgY3VycmVudGx5IGRvZXMgbm90IHN1cHBvcnQgZGF0YUZvcm1hdCBOQ0hXOyBvbmx5IE5IV0MgaXMgc3VwcG9ydGVkXCIpO2QoND09PWMucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK2MucmFuaytcIi5cIn0pLGQoND09PXUucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiBkZXB0aHdpc2UgZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSksZCg0PT09bC5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IHBvaW50d2lzZSBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSxkKDE9PT1sLnNoYXBlWzBdLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IHRoZSBmaXJzdCBkaW1lbnNpb24gb2YgcG9pbnR3aXNlIGZpbHRlciAgbXVzdCBiZSAxLCBidXQgZ290IFwiK2wuc2hhcGVbMF0rXCIuXCJ9KSxkKDE9PT1sLnNoYXBlWzFdLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IHRoZSBzZWNvbmQgZGltZW5zaW9uIG9mIHBvaW50d2lzZSBmaWx0ZXIgbXVzdCBiZSAxLCBidXQgZ290IFwiK2wuc2hhcGVbMV0rXCIuXCJ9KTt2YXIgcD11LnNoYXBlWzJdLGY9dS5zaGFwZVszXTtkKGwuc2hhcGVbMl09PT1wKmYsZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogdGhlIHRoaXJkIGRpbWVuc2lvbiBvZiBwb2ludHdpc2UgZmlsdGVyIG11c3QgYmUgXCIrcCpmK1wiLCBidXQgZ290IFwiK2wuc2hhcGVbMl0rXCIuXCJ9KTt2YXIgdj1acyhjLHUscixvLGksYSksbT1Zcyh2LGwsMSxcInZhbGlkXCIsaSk7cmV0dXJuIGg/bS5hczNEKG0uc2hhcGVbMV0sbS5zaGFwZVsyXSxtLnNoYXBlWzNdKTptfX0pLGV1PUFuKHtjb252MmRUcmFuc3Bvc2VfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gJHMobix3bih0LFwieFwiLFwiY29udjJkVHJhbnNwb3NlXCIpLHduKGUsXCJmaWx0ZXJcIixcImNvbnYyZFRyYW5zcG9zZVwiKSxyLG8sYSl9fSk7dmFyIG51PUFuKHttYXRNdWxfOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvO3ZvaWQgMD09PW4mJihuPSExKSx2b2lkIDA9PT1yJiYocj0hMSk7dmFyIGE9d24odCxcImFcIixcIm1hdE11bFwiKSxpPXduKGUsXCJiXCIsXCJtYXRNdWxcIik7bz1SdChhLGkpLGE9b1swXSxpPW9bMV07dmFyIHM9bj9hLnNoYXBlW2EucmFuay0yXTphLnNoYXBlW2EucmFuay0xXSx1PXI/aS5zaGFwZVtpLnJhbmstMV06aS5zaGFwZVtpLnJhbmstMl0sbD1uP2Euc2hhcGVbYS5yYW5rLTFdOmEuc2hhcGVbYS5yYW5rLTJdLGM9cj9pLnNoYXBlW2kucmFuay0yXTppLnNoYXBlW2kucmFuay0xXSxoPWEuc2hhcGUuc2xpY2UoMCwtMikscD1pLnNoYXBlLnNsaWNlKDAsLTIpLGY9eShoKSx2PXkocCk7ZChhLnJhbms+PTImJmkucmFuaz49MiYmYS5yYW5rPT09aS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXRNdWw6IGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgcmFuayBvZiBhdCBsZWFzdCAyLCBnb3QgcmFua3MgXCIrYS5yYW5rK1wiIGFuZCBcIitpLnJhbmsrXCIuXCJ9KSxkKHgoaCxwKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF0TXVsOiBvdXRlciBkaW1lbnNpb25zIChcIitoK1wiKSBhbmQgKFwiK3ArXCIpIG9mIFRlbnNvcnMgd2l0aCBzaGFwZXMgXCIrYS5zaGFwZStcIiBhbmQgXCIraS5zaGFwZStcIiBtdXN0IG1hdGNoLlwifSksZChzPT09dSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF0TXVsOiBpbm5lciBzaGFwZXMgKFwiK3MrXCIpIGFuZCAoXCIrdStcIikgb2YgVGVuc29ycyB3aXRoIHNoYXBlcyBcIithLnNoYXBlK1wiIGFuZCBcIitpLnNoYXBlK1wiIGFuZCB0cmFuc3Bvc2VBPVwiK24rXCIgYW5kIHRyYW5zcG9zZUI9XCIrcitcIiBtdXN0IG1hdGNoLlwifSk7dmFyIG09YS5zaGFwZS5zbGljZSgwLC0yKS5jb25jYXQoW2wsY10pLGc9bj9hLmFzM0QoZixzLGwpOmEuYXMzRChmLGwscyksdz1yP2kuYXMzRCh2LGMsdSk6aS5hczNEKHYsdSxjKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG89dC5iYXRjaE1hdE11bChnLHcsbixyKTtyZXR1cm4gZShbZyx3XSksb30seyRhOmcsJGI6d30sZnVuY3Rpb24odCxlKXt2YXIgbz1lLGE9b1swXSxpPW9bMV07cmV0dXJuIG58fHI/IW4mJnI/eyRhOmZ1bmN0aW9uKCl7cmV0dXJuIHQubWF0TXVsKGksITEsITEpfSwkYjpmdW5jdGlvbigpe3JldHVybiB0Lm1hdE11bChhLCEwLCExKX19Om4mJiFyP3skYTpmdW5jdGlvbigpe3JldHVybiBpLm1hdE11bCh0LCExLCEwKX0sJGI6ZnVuY3Rpb24oKXtyZXR1cm4gYS5tYXRNdWwodCwhMSwhMSl9fTp7JGE6ZnVuY3Rpb24oKXtyZXR1cm4gaS5tYXRNdWwodCwhMCwhMCl9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIHQubWF0TXVsKGEsITAsITApfX06eyRhOmZ1bmN0aW9uKCl7cmV0dXJuIHQubWF0TXVsKGksITEsITApfSwkYjpmdW5jdGlvbigpe3JldHVybiBhLm1hdE11bCh0LCEwLCExKX19fSkucmVzaGFwZShtKX19KSxydT1Bbih7ZG90XzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJ0MVwiLFwiZG90XCIpLHI9d24oZSxcInQyXCIsXCJkb3RcIik7ZCghKDEhPT1uLnJhbmsmJjIhPT1uLnJhbmt8fDEhPT1yLnJhbmsmJjIhPT1yLnJhbmspLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBkb3Q6IGlucHV0cyBtdXN0IGFsbCBiZSByYW5rIDEgb3IgMiwgYnV0IGdvdCByYW5rcyBcIituLnJhbmsrXCIgYW5kIFwiK3IucmFuaytcIi5cIn0pO3ZhciBvPTE9PT1uLnJhbms/bi5zaXplOm4uc2hhcGVbMV0sYT0xPT09ci5yYW5rP3Iuc2l6ZTpyLnNoYXBlWzBdO3JldHVybiBkKG89PT1hLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBkb3Q6IGlubmVyIGRpbWVuc2lvbnMgb2YgaW5wdXRzIG11c3QgbWF0Y2gsIGJ1dCBnb3QgXCIrbytcIiBhbmQgXCIrYStcIi5cIn0pLDE9PT1uLnJhbmsmJjE9PT1yLnJhbms/bi5hczJEKDEsLTEpLm1hdE11bChyLmFzMkQoLTEsMSkpLmFzU2NhbGFyKCk6MT09PW4ucmFuayYmMj09PXIucmFuaz9uLmFzMkQoMSwtMSkubWF0TXVsKHIuYXMyRChyLnNoYXBlWzBdLHIuc2hhcGVbMV0pKS5hczFEKCk6Mj09PW4ucmFuayYmMT09PXIucmFuaz9uLm1hdE11bChyLmFzMkQoLTEsMSkpLmFzMUQoKTpuLm1hdE11bChyLmFzMkQoci5zaGFwZVswXSxyLnNoYXBlWzFdKSl9fSksb3U9QW4oe291dGVyUHJvZHVjdF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwidjFcIixcIm91dGVyUHJvZHVjdFwiKSxyPXduKGUsXCJ2MlwiLFwib3V0ZXJQcm9kdWN0XCIpO3JldHVybiBkKDE9PT1uLnJhbmsmJjE9PT1yLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG91dGVyUHJvZHVjdDogaW5wdXRzIG11c3QgYmUgcmFuayAxLCBidXQgZ290IHJhbmtzIFwiK24ucmFuaytcIiBhbmQgXCIrci5yYW5rK1wiLlwifSksbi5hczJEKC0xLDEpLm1hdE11bChyLmFzMkQoMSwtMSkpfX0pO3ZhciBhdT1Bbih7cmV2ZXJzZV86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwieFwiLFwicmV2ZXJzZVwiKTtpZigwPT09bi5yYW5rKXJldHVybiBuLmNsb25lKCk7dmFyIHI9TihlLG4uc2hhcGUpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQucmV2ZXJzZShuLHIpfSx7JHg6bn0sZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQucmV2ZXJzZShyKX19fSkucmVzaGFwZUFzKG4pfX0pLGl1PUFuKHtyZXZlcnNlMWRfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJyZXZlcnNlXCIpO3JldHVybiBkKDE9PT1lLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHJldmVyc2UxRDogeCBtdXN0IGJlIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrZS5yYW5rK1wiLlwifSksYXUoZSwwKX19KSxzdT1Bbih7cmV2ZXJzZTJkXzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJ4XCIsXCJyZXZlcnNlXCIpO3JldHVybiBkKDI9PT1uLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHJldmVyc2UyRDogeCBtdXN0IGJlIHJhbmsgMiBidXQgZ290IHJhbmsgXCIrbi5yYW5rK1wiLlwifSksYXUobixlKX19KSx1dT1Bbih7cmV2ZXJzZTNkXzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJ4XCIsXCJyZXZlcnNlXCIpO3JldHVybiBkKDM9PT1uLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHJldmVyc2UzRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIrbi5yYW5rK1wiLlwifSksYXUobixlKX19KSxsdT1Bbih7cmV2ZXJzZTRkXzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJ4XCIsXCJyZXZlcnNlXCIpO3JldHVybiBkKDQ9PT1uLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHJldmVyc2U0RDogeCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrbi5yYW5rK1wiLlwifSksYXUobixlKX19KTtmdW5jdGlvbiBjdSh0LGUsbixyLG8sYSl7dmFyIGk9d24odCxcInhcIixcIm1heFBvb2xcIikscz1pLHU9ITE7Mz09PWkucmFuayYmKHU9ITAscz1pLmFzNEQoMSxpLnNoYXBlWzBdLGkuc2hhcGVbMV0saS5zaGFwZVsyXSkpLG51bGw9PXImJihyPVsxLDFdKSxkKDQ9PT1zLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2w6IGlucHV0IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIitzLnJhbmsrXCIuXCJ9KSxkKEhzKG4sciksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2w6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK24rXCIgYW5kIGRpbGF0aW9ucyAnXCIrcitcIidcIn0pLG51bGwhPWEmJmQodyhvKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIrYStcIiBidXQgZ290IHBhZCBcIitvK1wiLlwifSk7dmFyIGw9UHMocy5zaGFwZSxlLG4scixvLGEpLGM9RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5tYXhQb29sKHMsbCk7cmV0dXJuIGUoW3Msbl0pLG59LHt4OnN9LGZ1bmN0aW9uKHQsYSl7dmFyIGk9YVswXSxzPWFbMV07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scixvLGEsaSxzKXt2YXIgdT13bih0LFwiZHlcIixcIm1heFBvb2xCYWNrcHJvcFwiKSxsPXduKGUsXCJpbnB1dFwiLFwibWF4UG9vbEJhY2twcm9wXCIpLGM9d24obixcIm91dHB1dFwiLFwibWF4UG9vbEJhY2twcm9wXCIpO2QobC5yYW5rPT09dS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJSYW5rIG9mIGlucHV0IChcIitsLnJhbmsrXCIpIGRvZXMgbm90IG1hdGNoIHJhbmsgb2YgZHkgKFwiK3UucmFuaytcIilcIn0pLG51bGw9PWEmJihhPVsxLDFdKSxkKEhzKG8sYSksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2xCYWNrUHJvcDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrbytcIiBhbmQgZGlsYXRpb25zICdcIithK1wiJ1wifSksZCg0PT09dS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sQmFja3Byb3A6IGR5IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSxkKDQ9PT1sLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2xCYWNrcHJvcDogaW5wdXQgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK2wucmFuaytcIi5cIn0pLG51bGwhPXMmJmQodyhpKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbEJhY2twcm9wOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitzK1wiIGJ1dCBnb3QgcGFkIFwiK2krXCIuXCJ9KTt2YXIgaD1QcyhsLnNoYXBlLHIsbyxhLGkscyk7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5tYXhQb29sQmFja3Byb3AodSxsLGMsaCl9LHskZHk6dSwkaW5wdXQ6bH0pfSh0LGkscyxlLG4scixvKX19fSk7cmV0dXJuIHU/Yy5hczNEKGMuc2hhcGVbMV0sYy5zaGFwZVsyXSxjLnNoYXBlWzNdKTpjfWZ1bmN0aW9uIGh1KHQsZSxuLHIsbyxhKXt2YXIgaT13bih0LFwieFwiLFwiYXZnUG9vbFwiLFwiZmxvYXQzMlwiKTtudWxsPT1yJiYocj1bMSwxXSksZChIcyhuLHIpLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIituK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK3IrXCInXCJ9KTt2YXIgcz1pLHU9ITE7Mz09PWkucmFuayYmKHU9ITAscz1pLmFzNEQoMSxpLnNoYXBlWzBdLGkuc2hhcGVbMV0saS5zaGFwZVsyXSkpLGQoND09PXMucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbDogeCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrcy5yYW5rK1wiLlwifSksbnVsbCE9YSYmZCh3KG8pLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIithK1wiIGJ1dCBnb3QgcGFkIFwiK28rXCIuXCJ9KTt2YXIgbD1QcyhzLnNoYXBlLGUsbixyLG8sYSksYz1EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuYXZnUG9vbChzLGwpfSx7eDpzfSxmdW5jdGlvbih0KXtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyLG8sYSl7dmFyIGk9d24odCxcImR5XCIsXCJhdmdQb29sQmFja3Byb3BcIikscz13bihlLFwiaW5wdXRcIixcImF2Z1Bvb2xCYWNrcHJvcFwiKTtkKHMucmFuaz09PWkucmFuayxmdW5jdGlvbigpe3JldHVyblwiUmFuayBvZiBpbnB1dCAoXCIrcy5yYW5rK1wiKSBkb2VzIG5vdCBtYXRjaCByYW5rIG9mIGR5IChcIitpLnJhbmsrXCIpXCJ9KSxudWxsPT1vJiYobz1bMSwxXSksZChIcyhyLG8pLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sQmFja3Byb3A6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK3IrXCIgYW5kIGRpbGF0aW9ucyAnXCIrbytcIidcIn0pO3ZhciB1PXMsbD1pLGM9ITE7Mz09PXMucmFuayYmKGM9ITAsdT1zLmFzNEQoMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0scy5zaGFwZVsyXSksbD1pLmFzNEQoMSxpLnNoYXBlWzBdLGkuc2hhcGVbMV0saS5zaGFwZVsyXSkpLGQoND09PWwucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbEJhY2twcm9wOiBkeSBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrbC5yYW5rK1wiLlwifSksZCg0PT09dS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sQmFja3Byb3A6IGlucHV0IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KTt2YXIgaD1Qcyh1LnNoYXBlLG4scixvLGEpLHA9RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmF2Z1Bvb2xCYWNrcHJvcChsLHUsaCl9LHtkeTREOmwsaW5wdXQ0RDp1fSk7cmV0dXJuIGM/cC5hczNEKHAuc2hhcGVbMV0scC5zaGFwZVsyXSxwLnNoYXBlWzNdKTpwfSh0LHMsZSxuLHIsbyl9fX0pO3JldHVybiBjPWMuY2FzdChpLmR0eXBlKSx1P2MuYXMzRChjLnNoYXBlWzFdLGMuc2hhcGVbMl0sYy5zaGFwZVszXSk6Y312YXIgcHU9QW4oe21heFBvb2xfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIGN1KHQsZSxuLDEscixvKX19KSxmdT1Bbih7YXZnUG9vbF86ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gaHUodCxlLG4sMSxyLG8pfX0pLGR1PUFuKHtwb29sXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7bnVsbD09byYmKG89WzEsMV0pLG51bGw9PWEmJihhPTEpLDA9PT1yJiYocj1cInZhbGlkXCIpO3ZhciBpPXduKHQsXCJ4XCIsXCJtYXhQb29sXCIpLHM9aSx1PSExOzM9PT1pLnJhbmsmJih1PSEwLHM9aS5hczREKDEsaS5zaGFwZVswXSxpLnNoYXBlWzFdLGkuc2hhcGVbMl0pKSxkKEhzKGEsbyksZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHBvb2w6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK2ErXCIgYW5kIGRpbGF0aW9ucyAnXCIrbytcIidcIn0pO3ZhciBsLGM9UHMocy5zaGFwZSxlLGEsbyxyKSxoPVtjLmRpbGF0aW9uSGVpZ2h0LGMuZGlsYXRpb25XaWR0aF07bD1cInNhbWVcIj09PXI/ZnVuY3Rpb24odCxlKXt2YXIgbj10Lm1hcChmdW5jdGlvbih0LG4pe3JldHVybiB0Kyh0LTEpKihlW25dLTEpfSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LTF9KSxyPW4ubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLmZsb29yKHQvMil9KSxvPW4ubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQtcltlXX0pO3JldHVybiBuLm1hcChmdW5jdGlvbih0LGUpe3JldHVybltyW2VdLG9bZV1dfSl9KFtjLmZpbHRlckhlaWdodCxjLmZpbHRlcldpZHRoXSxoKTpbWzAsMF0sWzAsMF1dO3ZhciBwPTE9PT1oWzBdJiYxPT09aFsxXSxmPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdFswXX0pLG89bi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHRbMV19KSxhPXQuY29uY2F0KHIsbyksaT1lLm1hcChmdW5jdGlvbih0LGUpe3JldHVybih0LWFbZV0ldCkldH0pLHM9by5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtpW2VdfSksdT1lLm1hcChmdW5jdGlvbih0LGUpe3JldHVybltyW2VdLHNbZV1dfSksbD1lLm1hcChmdW5jdGlvbih0LGUpe3JldHVyblswLGlbZV1dfSk7cmV0dXJuW3UsbF19KFtjLmluSGVpZ2h0LGMuaW5XaWR0aF0saCxsKSx2PWZbMF0sbT1mWzFdLGc9cD9yOlwidmFsaWRcIix5PXA/czokcihzLGgsdikseD0oXCJhdmdcIj09PW4/ZnVuY3Rpb24oKXtyZXR1cm4gaHUoeSxlLGEsMSxnKX06ZnVuY3Rpb24oKXtyZXR1cm4gY3UoeSxlLGEsMSxnKX0pKCksdz1wP3g6SXIoeCxoLG0pO3JldHVybiB1P3cuYXMzRCh3LnNoYXBlWzFdLHcuc2hhcGVbMl0sdy5zaGFwZVszXSk6d319KTt2YXIgdnU9QW4oe3NsaWNlXzpmdW5jdGlvbih0LGUsbil7dmFyIHIsbyxhPXduKHQsXCJ4XCIsXCJzbGljZVwiKTtpZigwPT09YS5yYW5rKXRocm93IG5ldyBFcnJvcihcIlNsaWNpbmcgc2NhbGFyIGlzIG5vdCBwb3NzaWJsZVwiKTtyPVwibnVtYmVyXCI9PXR5cGVvZiBlP1tlXS5jb25jYXQobmV3IEFycmF5KGEucmFuay0xKS5maWxsKDApKTplLmxlbmd0aDxhLnJhbms/ZS5jb25jYXQobmV3IEFycmF5KGEucmFuay1lLmxlbmd0aCkuZmlsbCgwKSk6ZS5zbGljZSgpLG89KG89bnVsbD09bj9uZXcgQXJyYXkoYS5yYW5rKS5maWxsKC0xKTpcIm51bWJlclwiPT10eXBlb2Ygbj9bbl0uY29uY2F0KG5ldyBBcnJheShhLnJhbmstMSkuZmlsbCgtMSkpOm4ubGVuZ3RoPGEucmFuaz9uLmNvbmNhdChuZXcgQXJyYXkoYS5yYW5rLW4ubGVuZ3RoKS5maWxsKC0xKSk6bikubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ+PTA/dDooZCgtMT09PXQsZnVuY3Rpb24oKXtyZXR1cm5cIkJhZCB2YWx1ZSBpbiBzaXplXCJ9KSxhLnNoYXBlW2VdLXJbZV0pfSksZnVuY3Rpb24odCxlLG4pe2QodC5yYW5rPT09ZS5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNsaWNlXCIrdC5yYW5rK1wiRDogTGVuZ3RoIG9mIGJlZ2luIFwiK2UrXCIgbXVzdCBtYXRjaCB0aGUgcmFuayBvZiB0aGUgYXJyYXkgKFwiK3QucmFuaytcIikuXCJ9KSxkKHQucmFuaz09PW4ubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBzbGljZVwiK3QucmFuaytcIkQ6IExlbmd0aCBvZiBzaXplIFwiK24rXCIgbXVzdCBtYXRjaCB0aGUgcmFuayBvZiB0aGUgYXJyYXkgKFwiK3QucmFuaytcIikuXCJ9KTtmb3IodmFyIHI9ZnVuY3Rpb24ocil7ZChlW3JdK25bcl08PXQuc2hhcGVbcl0sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNsaWNlXCIrdC5yYW5rK1wiRDogYmVnaW5bXCIrcitcIl0gKyBzaXplW1wiK3IrXCJdIChcIisoZVtyXStuW3JdKStcIikgd291bGQgb3ZlcmZsb3cgaW5wdXQuc2hhcGVbXCIrcitcIl0gKFwiK3Quc2hhcGVbcl0rXCIpXCJ9KX0sbz0wO288dC5yYW5rOysrbylyKG8pfShhLHIsbyk7dmFyIGk9YS5zaGFwZTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNsaWNlKGEscixvKX0seyR4OmF9LGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0LnJhbms7bisrKWUucHVzaChbcltuXSxpW25dLXJbbl0tb1tuXV0pO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LnBhZChlKX19fSl9fSksbXU9QW4oe3NsaWNlMWRfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj13bih0LFwieFwiLFwic2xpY2UxZFwiKTtyZXR1cm4gZCgxPT09ci5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJzbGljZTFkIGV4cGVjdHMgYSByYW5rLTEgdGVuc29yLCBidXQgZ290IGEgcmFuay1cIityLnJhbmsrXCIgdGVuc29yXCJ9KSx2dShyLFtlXSxbbl0pfX0pLGd1PUFuKHtzbGljZTJkXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9d24odCxcInhcIixcInNsaWNlMmRcIik7cmV0dXJuIGQoMj09PXIucmFuayxmdW5jdGlvbigpe3JldHVyblwic2xpY2UyZCBleHBlY3RzIGEgcmFuay0yIHRlbnNvciwgYnV0IGdvdCBhIHJhbmstXCIrci5yYW5rK1wiIHRlbnNvclwifSksdnUocixlLG4pfX0pLHl1PUFuKHtzbGljZTNkXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9d24odCxcInhcIixcInNsaWNlM2RcIik7cmV0dXJuIGQoMz09PXIucmFuayxmdW5jdGlvbigpe3JldHVyblwic2xpY2UzZCBleHBlY3RzIGEgcmFuay0zIHRlbnNvciwgYnV0IGdvdCBhIHJhbmstXCIrci5yYW5rK1wiIHRlbnNvclwifSksdnUocixlLG4pfX0pLHh1PUFuKHtzbGljZTRkXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9d24odCxcInhcIixcInNsaWNlNGRcIik7cmV0dXJuIGQoND09PXIucmFuayxmdW5jdGlvbigpe3JldHVyblwic2xpY2U0ZCBleHBlY3RzIGEgcmFuay00IHRlbnNvciwgYnV0IGdvdCBhIHJhbmstXCIrci5yYW5rK1wiIHRlbnNvclwifSksdnUocixlLG4pfX0pO2Z1bmN0aW9uIHd1KHQsZSxuLHIsbyl7cmV0dXJuIGUucmFuazxuLnJhbmsmJihlPWUucmVzaGFwZShlbihlLnNoYXBlLHIpKSksdC5yYW5rPG4ucmFuayYmKHQ9dC5yZXNoYXBlKGVuKHQuc2hhcGUscikpKSx7JHg6ZnVuY3Rpb24oKXt2YXIgcj10Lm11bChuLmVxdWFsKGUpLmNhc3QodC5kdHlwZSkpO3JldHVybiBudWxsPT1vP3I6ci50cmFuc3Bvc2Uobyl9fX12YXIgYnU9QW4oe2FsbF86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj13bih0LFwieFwiLFwiYWxsXCIsXCJib29sXCIpLG89TihlLHIuc2hhcGUpLGE9byxpPXJuKGEsci5yYW5rKTtudWxsIT1pJiYocj1yLnRyYW5zcG9zZShpKSxhPWFuKGEubGVuZ3RoLHIucmFuaykpO3ZhciBzPUR0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5hbGwocixhKX0seyR4OnJ9KTtpZihuKXt2YXIgdT1lbihzLnNoYXBlLG8pO3JldHVybiBzLnJlc2hhcGUodSl9cmV0dXJuIHN9fSksQ3U9QW4oe2FueV86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj13bih0LFwieFwiLFwiYW55XCIsXCJib29sXCIpLG89TihlLHIuc2hhcGUpLGE9byxpPXJuKGEsci5yYW5rKTtudWxsIT1pJiYocj1yLnRyYW5zcG9zZShpKSxhPWFuKGEubGVuZ3RoLHIucmFuaykpO3ZhciBzPUR0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5hbnkocixhKX0seyR4OnJ9KTtpZihuKXt2YXIgdT1lbihzLnNoYXBlLG8pO3JldHVybiBzLnJlc2hhcGUodSl9cmV0dXJuIHN9fSksRXU9QW4oe2FyZ01heF86ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0wKTt2YXIgbj13bih0LFwieFwiLFwiYXJnTWF4XCIpO251bGw9PWUmJihlPTApO3ZhciByPU4oZSxuLnNoYXBlKSxvPXJuKHIsbi5yYW5rKTtyZXR1cm4gbnVsbCE9byYmKG49bi50cmFuc3Bvc2Uobykscj1hbihyLmxlbmd0aCxuLnJhbmspKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbz10LmFyZ01heChuLHJbMF0pO3JldHVybiBlKFtuXSksb30seyR4Om59LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4obil9fX0pfX0pLFJ1PUFuKHthcmdNaW5fOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9MCk7dmFyIG49d24odCxcInhcIixcImFyZ01pblwiKTtudWxsPT1lJiYoZT0wKTt2YXIgcj1OKGUsbi5zaGFwZSksbz1ybihyLG4ucmFuayk7cmV0dXJuIG51bGwhPW8mJihuPW4udHJhbnNwb3NlKG8pLHI9YW4oci5sZW5ndGgsbi5yYW5rKSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG89dC5hcmdNaW4obixyWzBdKTtyZXR1cm4gZShbbl0pLG99LHskeDpufSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKG4pfX19KX19KSxTdT1Bbih7bG9nU3VtRXhwXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpO3ZhciByPXduKHQsXCJ4XCIsXCJsb2dTdW1FeHBcIiksbz1OKGUsci5zaGFwZSksYT1yLm1heChvLCEwKSxpPXIuc3ViKGEpLmV4cCgpLnN1bShvKS5sb2coKSxzPWEucmVzaGFwZShpLnNoYXBlKS5hZGQoaSk7aWYobil7dmFyIHU9ZW4ocy5zaGFwZSxvKTtyZXR1cm4gcy5yZXNoYXBlKHUpfXJldHVybiBzfX0pLE51PUFuKHttYXhfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9d24odCxcInhcIixcIm1heFwiKSxvPXIsYT1OKGUsci5zaGFwZSksaT1hLHM9cm4oaSxyLnJhbmspO251bGwhPXMmJihyPXIudHJhbnNwb3NlKHMpLGk9YW4oaS5sZW5ndGgsci5yYW5rKSk7dmFyIHU9RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5tYXgocixpKTtyZXR1cm4gZShbbyxuXSksbn0seyR4OnJ9LGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHd1KHQsZVsxXSxlWzBdLGEscyl9KTtpZihuKXt2YXIgbD1lbih1LnNoYXBlLGEpO3U9dS5yZXNoYXBlKGwpfXJldHVybiB1fX0pLGt1PUFuKHttZWFuXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpO3ZhciByPXduKHQsXCJ4XCIsXCJtZWFuXCIpLG89TihlLHIuc2hhcGUpLGE9eSh0bihyLnNoYXBlLG8pWzFdKTtyZXR1cm4ga24oZnVuY3Rpb24odCl7dmFyIHI9Qm4oYSk7cmV0dXJue3ZhbHVlOihyLmR0eXBlPT09dC5kdHlwZT90OnQuY2FzdChyLmR0eXBlKSkuZGl2KHIpLnN1bShlLG4pLGdyYWRGdW5jOmZ1bmN0aW9uKGUpe3ZhciBuPXQuc2hhcGUuc2xpY2UoKTtyZXR1cm4gby5mb3JFYWNoKGZ1bmN0aW9uKHQpe25bdF09MX0pLGUucmVzaGFwZShuKS5tdWwoR24odC5zaGFwZSxcImZsb2F0MzJcIikpLmRpdihhKX19fSkocil9fSksSXU9QW4oe21pbl86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj13bih0LFwieFwiLFwibWluXCIpLG89cixhPU4oZSxyLnNoYXBlKSxpPWEscz1ybihpLHIucmFuayk7bnVsbCE9cyYmKHI9ci50cmFuc3Bvc2UocyksaT1hbihpLmxlbmd0aCxyLnJhbmspKTt2YXIgdT1EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbj10Lm1pbihyLGkpO3JldHVybiBlKFtvLG5dKSxufSx7JHg6cn0sZnVuY3Rpb24odCxlKXtyZXR1cm4gd3UodCxlWzFdLGVbMF0sYSxzKX0pO2lmKG4pe3ZhciBsPWVuKHUuc2hhcGUsYSk7dT11LnJlc2hhcGUobCl9cmV0dXJuIHV9fSksQXU9QW4oe21vbWVudHNfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9TihlLCh0PXduKHQsXCJ4XCIsXCJtb21lbnRzXCIpKS5zaGFwZSksbz10Lm1lYW4ocixuKSxhPW8uc2hhcGU7bnx8KGE9ZW4oby5zaGFwZSxyKSk7dmFyIGk9dC50b0Zsb2F0KCkuc3ViKG8ucmVzaGFwZShhKSkuc3F1YXJlKCk7cmV0dXJue21lYW46byx2YXJpYW5jZTppLm1lYW4ocixuKX19fSksVHU9QW4oe3N1bV86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj13bih0LFwieFwiLFwic3VtXCIpO1wiYm9vbFwiPT09ci5kdHlwZSYmKHI9ci50b0ludCgpKTt2YXIgbz1OKGUsci5zaGFwZSk7cmV0dXJuIGtuKGZ1bmN0aW9uKHQpe3ZhciBlPXJuKG8sdC5yYW5rKSxyPW8sYT10O251bGwhPWUmJihhPXQudHJhbnNwb3NlKGUpLHI9YW4oci5sZW5ndGgsdC5yYW5rKSk7dmFyIGk9RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnN1bShhLHIpfSx7cGVybXV0ZWRYOmF9KTtpZihuKXt2YXIgcz1lbihpLnNoYXBlLG8pO2k9aS5yZXNoYXBlKHMpfXJldHVybnt2YWx1ZTppLGdyYWRGdW5jOmZ1bmN0aW9uKGUpe3ZhciBuPXQuc2hhcGUuc2xpY2UoKTtyZXR1cm4gby5mb3JFYWNoKGZ1bmN0aW9uKHQpe25bdF09MX0pLGUucmVzaGFwZShuKS5tdWwoR24odC5zaGFwZSxcImZsb2F0MzJcIikpfX19KShyKX19KSxEdT1Bbih7cHJvZF86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj13bih0LFwieFwiLFwicHJvZFwiKTtcImJvb2xcIj09PXIuZHR5cGUmJihyPXIudG9JbnQoKSk7dmFyIG89TihlLHIuc2hhcGUpLGE9cm4obyxyLnJhbmspLGk9byxzPXI7bnVsbCE9YSYmKHM9ci50cmFuc3Bvc2UoYSksaT1hbihpLmxlbmd0aCxyLnJhbmspKTt2YXIgdT1EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQucHJvZChzLGkpfSx7cGVybXV0ZWRYOnN9KTtpZihuKXt2YXIgbD1lbih1LnNoYXBlLG8pO3U9dS5yZXNoYXBlKGwpfXJldHVybiB1fX0pO3ZhciBPdT1Bbih7ZXF1YWxfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj13bih0LFwiYVwiLFwiZXF1YWxcIiksbz13bihlLFwiYlwiLFwiZXF1YWxcIik7cmV0dXJuIG49UnQocixvKSxyPW5bMF0sbz1uWzFdLHNvKHIuc2hhcGUsby5zaGFwZSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmVxdWFsKHIsbyl9LHskYTpyLCRiOm99KX19KSxfdT1Bbih7ZXF1YWxTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcImFcIixcImVxdWFsU3RyaWN0XCIpLHI9d24oZSxcImJcIixcImVxdWFsU3RyaWN0XCIpO3JldHVybiB2KG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIGVxdWFsU3RyaWN0OiBcIiksbi5lcXVhbChyKX19KSxNdT1Bbih7Z3JlYXRlcl86ZnVuY3Rpb24odCxlKXt2YXIgbixyPXduKHQsXCJhXCIsXCJncmVhdGVyXCIpLG89d24oZSxcImJcIixcImdyZWF0ZXJcIik7cmV0dXJuIG49UnQocixvKSxyPW5bMF0sbz1uWzFdLHNvKHIuc2hhcGUsby5zaGFwZSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmdyZWF0ZXIocixvKX0seyRhOnIsJGI6b30pfX0pLEZ1PUFuKHtncmVhdGVyRXF1YWxfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj13bih0LFwiYVwiLFwiZ3JlYXRlckVxdWFsXCIpLG89d24oZSxcImJcIixcImdyZWF0ZXJFcXVhbFwiKTtyZXR1cm4gbj1SdChyLG8pLHI9blswXSxvPW5bMV0sc28oci5zaGFwZSxvLnNoYXBlKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbj10LmdyZWF0ZXJFcXVhbChyLG8pO3JldHVybiBlKFtyLG9dKSxufSx7JGE6ciwkYjpvfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnskYTpmdW5jdGlvbigpe3JldHVybiBYbihuKX0sJGI6ZnVuY3Rpb24oKXtyZXR1cm4gWG4ocil9fX0pfX0pLEJ1PUFuKHtncmVhdGVyRXF1YWxTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcImFcIixcImdyZWF0ZXJFcXVhbFN0cmljdFwiKSxyPXduKGUsXCJiXCIsXCJncmVhdGVyRXF1YWxTdHJpY3RcIik7cmV0dXJuIHYobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gZ3JlYXRlckVxdWFsU3RyaWN0OiBcIiksbi5ncmVhdGVyRXF1YWwocil9fSksUHU9QW4oe2dyZWF0ZXJTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcImFcIixcImdyZWF0ZXJTdHJpY3RcIikscj13bihlLFwiYlwiLFwiZ3JlYXRlclN0cmljdFwiKTtyZXR1cm4gdihuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBncmVhdGVyU3RyaWN0OiBcIiksbi5ncmVhdGVyKHIpfX0pLEx1PUFuKHtsZXNzXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9d24odCxcImFcIixcImxlc3NcIiksbz13bihlLFwiYlwiLFwibGVzc1wiKTtyZXR1cm4gbj1SdChyLG8pLHI9blswXSxvPW5bMV0sc28oci5zaGFwZSxvLnNoYXBlKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQubGVzcyhyLG8pfSx7JGE6ciwkYjpvfSl9fSksV3U9QW4oe2xlc3NFcXVhbF86ZnVuY3Rpb24odCxlKXt2YXIgbixyPXduKHQsXCJhXCIsXCJsZXNzRXF1YWxcIiksbz13bihlLFwiYlwiLFwibGVzc0VxdWFsXCIpO3JldHVybiBuPVJ0KHIsbykscj1uWzBdLG89blsxXSxzbyhyLnNoYXBlLG8uc2hhcGUpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5sZXNzRXF1YWwocixvKX0seyRhOnIsJGI6b30pfX0pLFV1PUFuKHtsZXNzRXF1YWxTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcImFcIixcImxlc3NFcXVhbFN0cmljdFwiKSxyPXduKGUsXCJiXCIsXCJsZXNzRXF1YWxTdHJpY3RcIik7cmV0dXJuIHYobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gbGVzc0VxdWFsU3RyaWN0OiBcIiksbi5sZXNzRXF1YWwocil9fSksenU9QW4oe2xlc3NTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcImFcIixcImxlc3NTdHJpY3RcIikscj13bihlLFwiYlwiLFwibGVzc1N0cmljdFwiKTtyZXR1cm4gdihuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBsZXNzU3RyaWN0OiBcIiksbi5sZXNzKHIpfX0pLFZ1PUFuKHtub3RFcXVhbF86ZnVuY3Rpb24odCxlKXt2YXIgbixyPXduKHQsXCJhXCIsXCJub3RFcXVhbFwiKSxvPXduKGUsXCJiXCIsXCJub3RFcXVhbFwiKTtyZXR1cm4gbj1SdChyLG8pLHI9blswXSxvPW5bMV0sc28oci5zaGFwZSxvLnNoYXBlKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQubm90RXF1YWwocixvKX0seyRhOnIsJGI6b30pfX0pLEd1PUFuKHtub3RFcXVhbFN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwiYVwiLFwibm90RXF1YWxTdHJpY3RcIikscj13bihlLFwiYlwiLFwibm90RXF1YWxTdHJpY3RcIik7cmV0dXJuIHYobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gbm90RXF1YWxTdHJpY3Q6IFwiKSxuLm5vdEVxdWFsKHIpfX0pO3ZhciBxdT1Bbih7YWRkXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9d24odCxcImFcIixcImFkZFwiKSxvPXduKGUsXCJiXCIsXCJhZGRcIik7bj1SdChyLG8pLHI9blswXSxvPW5bMV07dmFyIGE9c28oci5zaGFwZSxvLnNoYXBlKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFkZChyLG8pfSx7JGE6ciwkYjpvfSxmdW5jdGlvbih0KXtyZXR1cm57JGE6ZnVuY3Rpb24oKXt2YXIgZT10LG49aW8oci5zaGFwZSxhKTtyZXR1cm4gbi5sZW5ndGg+MCYmKGU9ZS5zdW0obikpLGUucmVzaGFwZShyLnNoYXBlKX0sJGI6ZnVuY3Rpb24oKXt2YXIgZT10LG49aW8oby5zaGFwZSxhKTtyZXR1cm4gbi5sZW5ndGg+MCYmKGU9ZS5zdW0obikpLGUucmVzaGFwZShvLnNoYXBlKX19fSl9fSksSHU9QW4oe2FkZE5fOmZ1bmN0aW9uKHQpe2QoQXJyYXkuaXNBcnJheSh0KSxmdW5jdGlvbigpe3JldHVyblwiVGhlIGFyZ3VtZW50IHBhc3NlZCB0byB0Zi5hZGROKCkgbXVzdCBiZSBhIGxpc3Qgb2YgdGVuc29yc1wifSksZCh0Lmxlbmd0aD49MSxmdW5jdGlvbigpe3JldHVyblwiTXVzdCBwYXNzIGF0IGxlYXN0IG9uZSB0ZW5zb3IgdG8gdGYuYWRkTigpLCBidXQgZ290IFwiK3QubGVuZ3RofSk7dmFyIGU9dC5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm4gd24odCxcInRlbnNvcnNcIitlLFwiYWRkTlwiKX0pLG49ZVswXTtlLmZvckVhY2goZnVuY3Rpb24odCl7aWYodC5kdHlwZSE9PW4uZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQWxsIHRlbnNvcnMgcGFzc2VkIHRvIHRmLmFkZE4oKSBtdXN0IGhhdmUgdGhlIHNhbWUgZHR5cGVcIil9KSxlLmZvckVhY2goZnVuY3Rpb24odCl7aWYoIXgodC5zaGFwZSxuLnNoYXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJBbGwgdGVuc29ycyBwYXNzZWQgdG8gdGYuYWRkTigpIG11c3QgaGF2ZSB0aGUgc2FtZSBzaGFwZVwiKX0pO3ZhciByPWU7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5hZGROKGUpfSxyLGZ1bmN0aW9uKHQpe3ZhciBuPXt9O3JldHVybiBlLmZvckVhY2goZnVuY3Rpb24oZSxyKXtuW3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHQuY2xvbmUoKX19KSxufSl9fSksJHU9QW4oe2FkZFN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwiYVwiLFwiYWRkU3RyaWN0XCIpLHI9d24oZSxcImJcIixcImFkZFN0cmljdFwiKTtyZXR1cm4gdihuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBhZGRTdHJpY3Q6IFwiKSxuLmFkZChyKX19KSxqdT1Bbih7YXRhbjJfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj13bih0LFwiYVwiLFwiYXRhbjJcIiksbz13bihlLFwiYlwiLFwiYXRhbjJcIik7bj1SdChyLG8pLHI9blswXSxvPW5bMV07dmFyIGE9c28oci5zaGFwZSxvLnNoYXBlKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5hdGFuMihyLG8pO3JldHVybiBlKFtyLG9dKSxufSx7JGE6ciwkYjpvfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnskYTpmdW5jdGlvbigpe3ZhciBlPXF1KG4uc3F1YXJlKCksci5zcXVhcmUoKSksbz10Lm11bChyLmRpdihlKSksaT1pbyhuLnNoYXBlLGEpO3JldHVybiBpLmxlbmd0aD4wJiYobz1vLnN1bShpKSksby5yZXNoYXBlKG4uc2hhcGUpfSwkYjpmdW5jdGlvbigpe3ZhciBlPXF1KG4uc3F1YXJlKCksci5zcXVhcmUoKSksbz1pcyh0Lm11bChuLmRpdihlKSkpLGk9aW8oci5zaGFwZSxhKTtyZXR1cm4gaS5sZW5ndGg+MCYmKG89by5zdW0oaSkpLG8ucmVzaGFwZShyLnNoYXBlKX19fSl9fSksS3U9QW4oe2Rpdl86ZnVuY3Rpb24odCxlKXt2YXIgbixyPXduKHQsXCJhXCIsXCJkaXZcIiksbz13bihlLFwiYlwiLFwiZGl2XCIpO2lmKG49UnQocixvKSxyPW5bMF0sbz1uWzFdLFwiaW50MzJcIj09PXIuZHR5cGUmJlwiaW50MzJcIj09PW8uZHR5cGUpcmV0dXJuIFl1KHIsbyk7dmFyIGE9c28oci5zaGFwZSxvLnNoYXBlKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5yZWFsRGl2aWRlKHIsbyk7cmV0dXJuIGUoW3Isb10pLG59LHskYTpyLCRiOm99LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV07cmV0dXJueyRhOmZ1bmN0aW9uKCl7dmFyIGU9dC5kaXYoci50b0Zsb2F0KCkpLG89aW8obi5zaGFwZSxhKTtyZXR1cm4gby5sZW5ndGg+MD9lLnN1bShvKS5yZXNoYXBlKG4uc2hhcGUpOmV9LCRiOmZ1bmN0aW9uKCl7dmFyIGU9dC5tdWwobi50b0Zsb2F0KCkpLG89aW8oci5zaGFwZSxhKTtvLmxlbmd0aD4wJiYoZT1lLnN1bShvKS5yZXNoYXBlKHIuc2hhcGUpKTt2YXIgaT1yLnNxdWFyZSgpO3JldHVybiBlLmRpdihpLnRvRmxvYXQoKSkubmVnKCl9fX0pfX0pLFh1PUFuKHtkaXZTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcImFcIixcImRpdlwiKSxyPXduKGUsXCJiXCIsXCJkaXZcIik7cmV0dXJuIHYobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gZGl2aWRlU3RyaWN0OiBcIiksbi5kaXYocil9fSksWXU9QW4oe2Zsb29yRGl2XzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9d24odCxcImFcIixcImZsb29yRGl2XCIpLG89d24oZSxcImJcIixcImZsb29yRGl2XCIpO249UnQocixvKSxyPW5bMF0sbz1uWzFdO3ZhciBhPXNvKHIuc2hhcGUsby5zaGFwZSk7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBuPXQuZmxvb3JEaXYocixvKTtyZXR1cm4gZShbcixvXSksbn0seyRhOnIsJGI6b30sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57JGE6ZnVuY3Rpb24oKXt2YXIgZT10LmRpdihyLnRvRmxvYXQoKSksbz1pbyhuLnNoYXBlLGEpO3JldHVybiBvLmxlbmd0aD4wP2Uuc3VtKG8pLnJlc2hhcGUobi5zaGFwZSk6ZX0sJGI6ZnVuY3Rpb24oKXt2YXIgZT10Lm11bChuLnRvRmxvYXQoKSksbz1pbyhyLnNoYXBlLGEpO28ubGVuZ3RoPjAmJihlPWUuc3VtKG8pLnJlc2hhcGUoci5zaGFwZSkpO3ZhciBpPXIuc3F1YXJlKCk7cmV0dXJuIGUuZGl2KGkudG9GbG9hdCgpKS5uZWcoKX19fSl9fSksUXU9QW4oe21heGltdW1fOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj13bih0LFwiYVwiLFwibWF4aW11bVwiKSxvPXduKGUsXCJiXCIsXCJtYXhpbXVtXCIpO3JldHVybiBuPVJ0KHIsbykscj1uWzBdLG89blsxXSxcImJvb2xcIj09PXIuZHR5cGUmJihyPXIudG9JbnQoKSxvPW8udG9JbnQoKSksc28oci5zaGFwZSxvLnNoYXBlKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbj10Lm1heGltdW0ocixvKTtyZXR1cm4gZShbcixvXSksbn0seyRhOnIsJGI6b30sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57JGE6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5ncmVhdGVyRXF1YWwocikudG9GbG9hdCgpKX0sJGI6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5sZXNzKHIpLnRvRmxvYXQoKSl9fX0pfX0pLEp1PUFuKHttYXhpbXVtU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJhXCIsXCJtYXhpbXVtU3RyaWN0XCIpLHI9d24oZSxcImJcIixcIm1heGltdW1TdHJpY3RcIik7cmV0dXJuIHYobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gbWF4aW11bVN0cmljdDogXCIpLG4ubWF4aW11bShyKX19KSxadT1Bbih7bWluaW11bV86ZnVuY3Rpb24odCxlKXt2YXIgbixyPXduKHQsXCJhXCIsXCJtaW5pbXVtXCIpLG89d24oZSxcImJcIixcIm1pbmltdW1cIik7cmV0dXJuIG49UnQocixvKSxyPW5bMF0sbz1uWzFdLFwiYm9vbFwiPT09ci5kdHlwZSYmKHI9ci50b0ludCgpLG89by50b0ludCgpKSxzbyhyLnNoYXBlLG8uc2hhcGUpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBuPXQubWluaW11bShyLG8pO3JldHVybiBlKFtyLG9dKSxufSx7JGE6ciwkYjpvfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnskYTpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLmxlc3NFcXVhbChyKS50b0Zsb2F0KCkpfSwkYjpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLmdyZWF0ZXIocikudG9GbG9hdCgpKX19fSl9fSksdGw9QW4oe21pbmltdW1TdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcImFcIixcIm1pbmltdW1TdHJpY3RcIikscj13bihlLFwiYlwiLFwibWluaW11bVN0cmljdFwiKTtyZXR1cm4gdihuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBtaW5pbXVtU3RyaWN0OiBcIiksbi5taW5pbXVtKHIpfX0pLGVsPUFuKHttb2RfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj13bih0LFwiYVwiLFwibW9kXCIpLG89d24oZSxcImJcIixcIm1vZFwiKTtuPVJ0KHIsbykscj1uWzBdLG89blsxXTt2YXIgYT1zbyhyLnNoYXBlLG8uc2hhcGUpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbj10Lm1vZChyLG8pO3JldHVybiBlKFtyLG9dKSxufSx7JGE6ciwkYjpvfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnskYTpmdW5jdGlvbigpe3ZhciBlPWlvKG4uc2hhcGUsYSk7cmV0dXJuIGUubGVuZ3RoPjA/dC5zdW0oZSkucmVzaGFwZShuLnNoYXBlKTp0fSwkYjpmdW5jdGlvbigpe3ZhciBlPXQubXVsKG4uZGl2KHIpLmZsb29yKCkubmVnKCkpLG89aW8oci5zaGFwZSxhKTtyZXR1cm4gby5sZW5ndGg+MD9lLnN1bShvKS5yZXNoYXBlKHIuc2hhcGUpOmV9fX0pfX0pLG5sPUFuKHttb2RTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcImFcIixcIm1vZFN0cmljdFwiKSxyPXduKGUsXCJiXCIsXCJtb2RTdHJpY3RcIik7cmV0dXJuIHYobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gbW9kU3RyaWN0OiBcIiksbi5tb2Qocil9fSkscmw9QW4oe211bF86ZnVuY3Rpb24odCxlKXt2YXIgbixyPXduKHQsXCJhXCIsXCJtdWxcIiksbz13bihlLFwiYlwiLFwibXVsXCIpO249UnQocixvKSxyPW5bMF0sbz1uWzFdO3ZhciBhPXNvKHIuc2hhcGUsby5zaGFwZSk7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBuPXQubXVsdGlwbHkocixvKTtyZXR1cm4gZShbcixvXSksbn0seyRhOnIsJGI6b30sZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57JGE6ZnVuY3Rpb24oKXt2YXIgZT10Lm11bChyLnRvRmxvYXQoKSksbz1pbyhuLnNoYXBlLGEpO3JldHVybiBvLmxlbmd0aD4wP2Uuc3VtKG8pLnJlc2hhcGUobi5zaGFwZSk6ZX0sJGI6ZnVuY3Rpb24oKXt2YXIgZT10Lm11bChuLnRvRmxvYXQoKSksbz1pbyhyLnNoYXBlLGEpO3JldHVybiBvLmxlbmd0aD4wP2Uuc3VtKG8pLnJlc2hhcGUoci5zaGFwZSk6ZX19fSl9fSksb2w9QW4oe211bFN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwiYVwiLFwibXVsXCIpLHI9d24oZSxcImJcIixcIm11bFwiKTtyZXR1cm4gdihuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBtdWx0aXBseVN0cmljdDogXCIpLG4ubXVsKHIpfX0pLGFsPUFuKHtwb3dfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcImJhc2VcIixcInBvd1wiKSxyPXduKGUsXCJleHBcIixcInBvd1wiKSxvPXNvKG4uc2hhcGUsci5zaGFwZSk7cmV0dXJuIHQ9bi5jYXN0KEN0KG4uZHR5cGUsci5kdHlwZSkpLGU9ci5jYXN0KEN0KG4uZHR5cGUsci5kdHlwZSkpLER0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBvPXQucG93KG4scik7cmV0dXJuIGUoW24scixvXSksb30seyRiYXNlOm4sJGV4cDpyfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdLGE9ZVsyXTtyZXR1cm57JGJhc2U6ZnVuY3Rpb24oKXt2YXIgZT1yLnRvRmxvYXQoKSxhPXQubXVsKGUubXVsKG4ucG93KGUuc3ViKEJuKDEpKSkpKSxpPWlvKG4uc2hhcGUsbyk7cmV0dXJuIGkubGVuZ3RoPjAmJihhPWEuc3VtKGkpKSxhLnJlc2hhcGUobi5zaGFwZSl9LCRleHA6ZnVuY3Rpb24oKXt2YXIgZT1uLmdyZWF0ZXIoMCksaT1uLmxvZygpLndoZXJlKGUsWG4obikpLHM9dC5tdWwoYS5tdWwoaSkpLHU9aW8oci5zaGFwZSxvKTtyZXR1cm4gdS5sZW5ndGg+MCYmKHM9cy5zdW0odSkpLHMucmVzaGFwZShyLnNoYXBlKX19fSl9fSksaWw9QW4oe3Bvd1N0cmljdF86ZnVuY3Rpb24odCxlKXtyZXR1cm4gdih0LnNoYXBlLGUuc2hhcGUsXCJFcnJvciBpbiBwb3dTdHJpY3Q6IFwiKSx0LnBvdyhlKX19KSxzbD1Bbih7c3F1YXJlZERpZmZlcmVuY2VfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj13bih0LFwiYVwiLFwic3F1YXJlZERpZmZlcmVuY2VcIiksbz13bihlLFwiYlwiLFwic3F1YXJlZERpZmZlcmVuY2VcIik7cmV0dXJuIG49UnQocixvKSxyPW5bMF0sbz1uWzFdLHNvKHIuc2hhcGUsby5zaGFwZSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5zcXVhcmVkRGlmZmVyZW5jZShyLG8pO3JldHVybiBlKFtyLG9dKSxufSx7JGE6ciwkYjpvfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdLG89Qm4oMik7cmV0dXJueyRhOmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4uc3ViKHIpLm11bChvKSl9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKHIuc3ViKG4pLm11bChvKSl9fX0pfX0pLHVsPUFuKHtzcXVhcmVkRGlmZmVyZW5jZVN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwiYVwiLFwic3F1YXJlZERpZmZlcmVuY2VTdHJpY3RcIikscj13bihlLFwiYlwiLFwic3F1YXJlZERpZmZlcmVuY2VTdHJpY3RcIik7cmV0dXJuIHYobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gc3F1YXJlZERpZmZlcmVuY2VTdHJpY3Q6IFwiKSxuLnNxdWFyZWREaWZmZXJlbmNlKHIpfX0pLGxsPUFuKHtzdWJfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj13bih0LFwiYVwiLFwic3ViXCIpLG89d24oZSxcImJcIixcInN1YlwiKTtuPVJ0KHIsbykscj1uWzBdLG89blsxXTt2YXIgYT1zbyhyLnNoYXBlLG8uc2hhcGUpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3VidHJhY3QocixvKX0seyRhOnIsJGI6b30sZnVuY3Rpb24odCl7cmV0dXJueyRhOmZ1bmN0aW9uKCl7dmFyIGU9dCxuPWlvKHIuc2hhcGUsYSk7cmV0dXJuIG4ubGVuZ3RoPjAmJihlPWUuc3VtKG4pKSxlLnJlc2hhcGUoci5zaGFwZSl9LCRiOmZ1bmN0aW9uKCl7dmFyIGU9dCxuPWlvKG8uc2hhcGUsYSk7cmV0dXJuIG4ubGVuZ3RoPjAmJihlPWUuc3VtKG4pKSxlLm5lZygpLnJlc2hhcGUoby5zaGFwZSl9fX0pfX0pLGNsPUFuKHtzdWJTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49d24odCxcImFcIixcInN1YlN0cmljdFwiKSxyPXduKGUsXCJiXCIsXCJzdWJTdHJpY3RcIik7cmV0dXJuIHYobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gc3ViU3RyaWN0OiBcIiksbi5zdWIocil9fSk7dmFyIGhsPUFuKHtsb2dpY2FsQW5kXzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJhXCIsXCJsb2dpY2FsQW5kXCIsXCJib29sXCIpLHI9d24oZSxcImJcIixcImxvZ2ljYWxBbmRcIixcImJvb2xcIik7cmV0dXJuIHNvKG4uc2hhcGUsci5zaGFwZSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmxvZ2ljYWxBbmQobixyKX0seyRhOm4sJGI6cn0pfX0pLHBsPUFuKHtsb2dpY2FsTm90XzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwibG9naWNhbE5vdFwiLFwiYm9vbFwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmxvZ2ljYWxOb3QoZSl9LHskeDplfSl9fSksZmw9QW4oe2xvZ2ljYWxPcl86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwiYVwiLFwibG9naWNhbE9yXCIsXCJib29sXCIpLHI9d24oZSxcImJcIixcImxvZ2ljYWxPclwiLFwiYm9vbFwiKTtyZXR1cm4gc28obi5zaGFwZSxyLnNoYXBlKSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCl7cmV0dXJuIHQubG9naWNhbE9yKG4scil9LHskYTpuLCRiOnJ9KX19KSxkbD1Bbih7bG9naWNhbFhvcl86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwiYVwiLFwibG9naWNhbFhvclwiLFwiYm9vbFwiKSxyPXduKGUsXCJiXCIsXCJsb2dpY2FsWG9yXCIsXCJib29sXCIpO3JldHVybiBzbyhuLnNoYXBlLHIuc2hhcGUpLGZsKHQsZSkubG9naWNhbEFuZChobCh0LGUpLmxvZ2ljYWxOb3QoKSl9fSksdmw9QW4oe3doZXJlXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9d24oZSxcImFcIixcIndoZXJlXCIpLG89d24obixcImJcIixcIndoZXJlXCIpLGE9d24odCxcImNvbmRpdGlvblwiLFwid2hlcmVcIixcImJvb2xcIik7cmV0dXJuIHYoci5zaGFwZSxvLnNoYXBlLFwiRXJyb3IgaW4gd2hlcmU6IFwiKSwxPT09YS5yYW5rP2QoYS5zaGFwZVswXT09PXIuc2hhcGVbMF0sZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmaXJzdCBkaW1lbnNpb24gb2YgYGFgIG11c3QgbWF0Y2ggdGhlIHNpemUgb2YgYGNvbmRpdGlvbmAuXCJ9KTp2KGEuc2hhcGUsby5zaGFwZSxcIkVycm9yIGluIHdoZXJlOiBcIiksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5zZWxlY3QoYSxyLG8pO3JldHVybiBlKFthXSksbn0seyRjb25kaXRpb246YSwkYTpyLCRiOm99LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JGNvbmRpdGlvbjpmdW5jdGlvbigpe3JldHVybiBYbihuKS50b0Zsb2F0KCl9LCRhOmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4uY2FzdCh0LmR0eXBlKSl9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4ubG9naWNhbE5vdCgpLmNhc3QodC5kdHlwZSkpfX19KX19KSxtbD1mdW5jdGlvbih0KXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxuLHI7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOnJldHVybls0LChlPXduKHQsXCJjb25kaXRpb25cIixcIndoZXJlQXN5bmNcIixcImJvb2xcIikpLmRhdGEoKV07Y2FzZSAxOnJldHVybiBuPW8uc2VudCgpLHI9WnIoZS5zaGFwZSxuKSx0IT09ZSYmZS5kaXNwb3NlKCksWzIscl19fSl9KX07dmFyIGdsPUFuKHtlbHVfOmZ1bmN0aW9uKHQpe3ZhciBlPXduKHQsXCJ4XCIsXCJlbHVcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQuZWx1KGUpO3JldHVybiBuKFtyXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKGUpe3JldHVybiBlLmVsdURlcih0LG4pfSx7ZHk6dCx5Om59KX19fSl9fSkseWw9QW4oe2xlYWt5UmVsdV86ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0uMik7dmFyIG49d24odCxcInhcIixcImxlYWt5UmVsdVwiKTtyZXR1cm4gUXUoQm4oZSkubXVsKG4pLG4pfX0pLHhsPUFuKHtwcmVsdV86ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwieFwiLFwicHJlbHVcIikscj13bihlLFwiYWxwaGFcIixcInByZWx1XCIpO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgbz10LnByZWx1KG4scik7cmV0dXJuIGUoW24scl0pLG99LHskeDpuLCRhbHBoYTpyfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdLG89bi5ncmVhdGVyKDApO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB2bChvLHQsdC5tdWwocikpfSwkYWxwaGE6ZnVuY3Rpb24oKXt2YXIgZT12bChvLFhuKHQpLHQubXVsKG4pKSxhPWlvKHIuc2hhcGUsdC5zaGFwZSk7cmV0dXJuIGEubGVuZ3RoPjAmJihlPWUuc3VtKGEpKSxlLnJlc2hhcGUoci5zaGFwZSl9fX0pfX0pLHdsPUFuKHtyZWx1XzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwicmVsdVwiKTtyZXR1cm5cImJvb2xcIj09PWUuZHR5cGU/ZS50b0ludCgpOkR0LnJ1bktlcm5lbChmdW5jdGlvbih0LG4pe3ZhciByPXQucmVsdShlKTtyZXR1cm4gbihbZV0pLHJ9LHskeDplfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsU3RyaWN0KG4uc3RlcCgpLnRvRmxvYXQoKSl9fX0pfX0pLGJsPUFuKHtzZWx1XzpmdW5jdGlvbih0KXt2YXIgZT13bih0LFwieFwiLFwic2VsdVwiKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5zZWx1KGUpO3JldHVybiBuKFtlXSkscn0seyR4OmV9LGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXt2YXIgZT1uLmdyZWF0ZXIoQm4oMCkpLHI9Qm4oYmkpLG89Qm4oQ2kpLGE9dC5tdWwobyksaT10Lm11bChyKS5tdWwobi50b0Zsb2F0KCkuZXhwKCkpO3JldHVybiB2bChlLGEsaSl9fX0pfX0pO3ZhciBDbD1Bbih7dHJhbnNwb3NlXzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKHQsXCJ4XCIsXCJ0cmFuc3Bvc2VcIik7cmV0dXJuIG51bGw9PWUmJihlPW4uc2hhcGUubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV9KS5yZXZlcnNlKCkpLGQobi5yYW5rPT09ZS5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHRyYW5zcG9zZTogcmFuayBvZiBpbnB1dCBcIituLnJhbmsrXCIgbXVzdCBtYXRjaCBsZW5ndGggb2YgcGVybSBcIitlK1wiLlwifSksZS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2QodD49MCYmdDxuLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkFsbCBlbnRyaWVzIGluICdwZXJtJyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgXCIrKG4ucmFuay0xKStcIiBidXQgZ290IFwiK2V9KX0pLG4ucmFuazw9MT9uLmNsb25lKCk6RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRyYW5zcG9zZShuLGUpfSx7JHg6bn0sZnVuY3Rpb24odCl7dmFyIG49b24oZSk7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQudHJhbnNwb3NlKG4pfX19KX19KTt2YXIgRWw9QW4oe2xvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uXzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PWUmJihlPTUpLHZvaWQgMD09PW4mJihuPTEpLHZvaWQgMD09PXImJihyPTEpLHZvaWQgMD09PW8mJihvPS41KTt2YXIgYT13bih0LFwieFwiLFwibG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb25cIik7ZCg0PT09YS5yYW5rfHwzPT09YS5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjogeCBtdXN0IGJlIHJhbmsgMyBvciA0IGJ1dCBnb3RcXG4gICAgICAgICAgICAgICByYW5rIFwiK2EucmFuaytcIi5cIn0pLGQodyhlKSxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb246IGRlcHRoUmFkaXVzIG11c3QgYmUgYW4gaW50ZWdlciBidXQgZ290IGRlcHRoUmFkaXVzIFwiK2UrXCIuXCJ9KTt2YXIgaT1hLHM9ITE7Mz09PWEucmFuayYmKHM9ITAsaT1hLmFzNEQoMSxhLnNoYXBlWzBdLGEuc2hhcGVbMV0sYS5zaGFwZVsyXSkpO3ZhciB1PUR0LnJ1bktlcm5lbChmdW5jdGlvbih0LGEpe3ZhciBzPXQubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb240RChpLGUsbixyLG8pO3JldHVybiBhKFtpLHNdKSxzfSx7eDREOml9LGZ1bmN0aW9uKHQsYSl7dmFyIGk9YVswXSxzPWFbMV07cmV0dXJue3g0RDpmdW5jdGlvbigpe3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24oYSl7cmV0dXJuIGEuTFJOR3JhZCh0LGkscyxlLG4scixvKX0se30pfX19KTtyZXR1cm4gcz91LmFzM0QodS5zaGFwZVsxXSx1LnNoYXBlWzJdLHUuc2hhcGVbM10pOnV9fSk7dmFyIFJsPUFuKHtub3JtXzpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1lJiYoZT1cImV1Y2xpZGVhblwiKSx2b2lkIDA9PT1uJiYobj1udWxsKSx2b2lkIDA9PT1yJiYocj0hMSk7dmFyIG89ZnVuY3Rpb24gdChlLG4scil7aWYodm9pZCAwPT09ciYmKHI9bnVsbCksMD09PWUucmFuaylyZXR1cm4gZS5hYnMoKTtpZigxIT09ZS5yYW5rJiZudWxsPT09cilyZXR1cm4gdChlLnJlc2hhcGUoWy0xXSksbixyKTtpZigxPT09ZS5yYW5rfHxcIm51bWJlclwiPT10eXBlb2Ygcnx8QXJyYXkuaXNBcnJheShyKSYmMT09PXIubGVuZ3RoKXtpZigxPT09bilyZXR1cm4gZS5hYnMoKS5zdW0ocik7aWYobj09PTEvMClyZXR1cm4gZS5hYnMoKS5tYXgocik7aWYobj09PS0xLzApcmV0dXJuIGUuYWJzKCkubWluKHIpO2lmKFwiZXVjbGlkZWFuXCI9PT1ufHwyPT09bilyZXR1cm4gZS5hYnMoKS5wb3coQm4oMixcImludDMyXCIpKS5zdW0ocikuc3FydCgpO3Rocm93IG5ldyBFcnJvcihcIkVycm9yIGluIG5vcm06IGludmFsaWQgb3JkIHZhbHVlOiBcIituKX1pZihBcnJheS5pc0FycmF5KHIpJiYyPT09ci5sZW5ndGgpe2lmKDE9PT1uKXJldHVybiBlLmFicygpLnN1bShyWzBdKS5tYXgoclsxXS0xKTtpZihuPT09MS8wKXJldHVybiBlLmFicygpLnN1bShyWzFdKS5tYXgoclswXSk7aWYobj09PS0xLzApcmV0dXJuIGUuYWJzKCkuc3VtKHJbMV0pLm1pbihyWzBdKTtpZihcImZyb1wiPT09bnx8XCJldWNsaWRlYW5cIj09PW4pcmV0dXJuIGUuc3F1YXJlKCkuc3VtKHIpLnNxcnQoKTt0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBub3JtOiBpbnZhbGlkIG9yZCB2YWx1ZTogXCIrbil9dGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gbm9ybTogaW52YWxpZCBheGlzOiBcIityKX0odD13bih0LFwieFwiLFwibm9ybVwiKSxlLG4pLGE9by5zaGFwZTtpZihyKXt2YXIgaT1OKG4sdC5zaGFwZSk7YT1lbihvLnNoYXBlLGkpfXJldHVybiBvLnJlc2hhcGUoYSl9fSk7ZnVuY3Rpb24gU2wodCxlKXtmb3IodmFyIG49W10scj10O3I8ZTsrK3Ipbi5wdXNoKHIpO3JldHVybiBufWZ1bmN0aW9uIE5sKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDsrK24pZm9yKHZhciByPTA7cjx0W25dLmxlbmd0aDsrK3IpZS5wdXNoKHRbbl1bcl0pO3JldHVybiBlfXZhciBrbD1Bbih7Z2F0aGVyXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49MCk7dmFyIHI9d24odCxcInhcIixcImdhdGhlclwiKSxvPXduKGUsXCJpbmRpY2VzXCIsXCJnYXRoZXJcIixcImludDMyXCIpO249TihuLHIuc2hhcGUpWzBdO3ZhciBhPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9dC5zaGFwZVtuXSxvPVtdLGE9MSxpPTEscz0wO3M8bjtzKyspby5wdXNoKHQuc2hhcGVbc10pLGEqPXQuc2hhcGVbc107Zm9yKHM9MDtzPGUucmFuaztzKyspby5wdXNoKGUuc2hhcGVbc10pO2ZvcihzPW4rMTtzPHQucmFuaztzKyspby5wdXNoKHQuc2hhcGVbc10pLGkqPXQuc2hhcGVbc107cmV0dXJue2JhdGNoU2l6ZTphLHNsaWNlU2l6ZTppLGRpbVNpemU6cixvdXRwdXRTaGFwZTpvfX0ocixvLG4pO3JldHVybiBEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXt2YXIgYT10LmdhdGhlcihyLG8uZmxhdHRlbigpLG4pO3JldHVybiBlKFtvXSksYX0seyR4OnJ9LGZ1bmN0aW9uKHQsZSl7dmFyIG89ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXt2YXIgZT1yLnNoYXBlLGE9by5zaXplLGk9ZS5zbGljZSgwLG4pLHM9aS5sZW5ndGgsdT1lLnNsaWNlKG4sZS5sZW5ndGgpLnNsaWNlKDEpLGw9dS5sZW5ndGgsYz1TbCgwLHMpLGg9U2wocysxLHMrMStsKSxwPU5sKFtpLFthXSx1XSksZj10LnJlc2hhcGUocCksZD1vLnJlc2hhcGUoW2FdKSx2PU5sKFtbc10sYyxoXSksbT1mLnRyYW5zcG9zZSh2KSxnPUlsKG0sZCxyLnNoYXBlW25dKSx5PW9uKHYpO3JldHVybiBnPWcudHJhbnNwb3NlKHkpfX19KS5yZXNoYXBlKGEub3V0cHV0U2hhcGUpfX0pLElsPUFuKHt1bnNvcnRlZFNlZ21lbnRTdW1fOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj13bih0LFwieFwiLFwidW5zb3J0ZWRTZWdtZW50U3VtXCIpLG89d24oZSxcInNlZ21lbnRJZHNcIixcInVuc29ydGVkU2VnbWVudFN1bVwiLFwiaW50MzJcIik7cmV0dXJuIGQodyhuKSxmdW5jdGlvbigpe3JldHVyblwibnVtU2VnbWVudHMgbXVzdCBiZSBvZiBkdHlwZSBpbnRcIn0pLER0LnJ1bktlcm5lbChmdW5jdGlvbih0LGUpe3ZhciBhPXQudW5zb3J0ZWRTZWdtZW50U3VtKHIsbyxuKTtyZXR1cm4gZShbb10pLGF9LHskeDpyfSxmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPVF1KGUsWG4oZSkpLHI9a2wodCxuKSxvPUZ1KGUsQm4oMCxcImludDMyXCIpKSxhPXIucmFuay1vLnJhbmssaT0wO2k8YTsrK2kpbz1fcihvLGkrMSk7bz1obChvLEduKHIuc2hhcGUsXCJib29sXCIpKTt2YXIgcz1YbihyKTtyZXR1cm4gdmwobyxyLHMpfSh0LG4pfX19KX19KTt2YXIgQWw9QW4oe2Jhc2ljTFNUTUNlbGxfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2YXIgaT13bih0LFwiZm9yZ2V0Qmlhc1wiLFwiYmFzaWNMU1RNQ2VsbFwiKSxzPXduKGUsXCJsc3RtS2VybmVsXCIsXCJiYXNpY0xTVE1DZWxsXCIpLHU9d24obixcImxzdG1CaWFzXCIsXCJiYXNpY0xTVE1DZWxsXCIpLGw9d24ocixcImRhdGFcIixcImJhc2ljTFNUTUNlbGxcIiksYz13bihvLFwiY1wiLFwiYmFzaWNMU1RNQ2VsbFwiKSxoPXduKGEsXCJoXCIsXCJiYXNpY0xTVE1DZWxsXCIpLHA9bC5jb25jYXQoaCwxKS5tYXRNdWwocykuYWRkKHUpLGY9cC5zaGFwZVswXSxkPXAuc2hhcGVbMV0vNCx2PVtmLGRdLG09cC5zbGljZShbMCwwXSx2KSxnPXAuc2xpY2UoWzAsZF0sdikseT1wLnNsaWNlKFswLDIqZF0sdikseD1wLnNsaWNlKFswLDMqZF0sdiksdz1tLnNpZ21vaWQoKS5tdWxTdHJpY3QoZy50YW5oKCkpLmFkZFN0cmljdChjLm11bFN0cmljdChpLmFkZCh5KS5zaWdtb2lkKCkpKSxiPXcudGFuaCgpLm11bFN0cmljdCh4LnNpZ21vaWQoKSk7cmV0dXJuW3csYl19fSksVGw9QW4oe211bHRpUk5OQ2VsbF86ZnVuY3Rpb24odCxlLG4scil7Zm9yKHZhciBvPXduKGUsXCJkYXRhXCIsXCJtdWx0aVJOTkNlbGxcIiksYT1ibihuLFwiY1wiLFwibXVsdGlSTk5DZWxsXCIpLGk9Ym4ocixcImhcIixcIm11bHRpUk5OQ2VsbFwiKSxzPW8sdT1bXSxsPTA7bDx0Lmxlbmd0aDtsKyspe3ZhciBjPXRbbF0ocyxhW2xdLGlbbF0pO3UucHVzaChjWzBdKSx1LnB1c2goY1sxXSkscz1jWzFdfXZhciBoPVtdLHA9W107Zm9yKGw9MDtsPHUubGVuZ3RoO2wrPTIpaC5wdXNoKHVbbF0pLHAucHVzaCh1W2wrMV0pO3JldHVybltoLHBdfX0pO3ZhciBEbD1Bbih7bW92aW5nQXZlcmFnZV86ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1vJiYobz0hMCk7dmFyIGE9d24odCxcInZcIixcIm1vdmluZ0F2ZXJhZ2VcIiksaT13bihlLFwieFwiLFwibW92aW5nQXZlcmFnZVwiKSxzPXduKG4sXCJkZWNheVwiLFwibW92aW5nQXZlcmFnZVwiKTtTdChhLGkpLGQoeChhLnNoYXBlLGkuc2hhcGUpLGZ1bmN0aW9uKCl7cmV0dXJuXCJTaGFwZSBtaXNtYXRjaCBpbiB2IGFuZCB4XCJ9KTt2YXIgdT1CbigxKSxsPXUuc3ViKHMpLGM9aS5zdWIoYSkubXVsKGwpO2lmKG8pe2QobnVsbCE9cixmdW5jdGlvbigpe3JldHVyblwiV2hlbiB1c2luZyB6ZXJvRGViaWFzOiB0cnVlLCBzdGVwIGlzIHJlcXVpcmVkLlwifSk7dmFyIGg9d24ocixcInN0ZXBcIixcIm1vdmluZ0F2ZXJhZ2VcIik7Yz1jLmRpdih1LnN1YihhbChzLGgpKSl9cmV0dXJuIGEuYWRkKGMpfX0pO3ZhciBPbD1Bbih7c3RyaWRlZFNsaWNlXzpmdW5jdGlvbih0LGUsbixyLG8sYSxpLHMsdSl7aWYodm9pZCAwPT09byYmKG89MCksdm9pZCAwPT09YSYmKGE9MCksdm9pZCAwPT09aSYmKGk9MCksdm9pZCAwPT09cyYmKHM9MCksdm9pZCAwPT09dSYmKHU9MCksMCE9PWkpdGhyb3cgbmV3IEVycm9yKFwiZWxsaXBzaXMgbWFzayBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtpZigwIT09cyl0aHJvdyBuZXcgRXJyb3IoXCJuZXcgYXhpcyBtYXNrIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO3ZhciBsPXduKHQsXCJ4XCIsXCJzdHJpZGVkU2xpY2VcIik7aWYoci5ldmVyeShmdW5jdGlvbih0KXtyZXR1cm4gMT09PXR9KSl7dmFyIGM9Zm4obC5zaGFwZSxlLG4scixvLGEsaSxzLHUpLGg9Y1swXSxwPWNbMV0sZj1jWzJdLGQ9cC5maWx0ZXIoZnVuY3Rpb24odCxlKXtyZXR1cm4tMT09PWYuaW5kZXhPZihlKX0pO3JldHVybiB2dShsLGgscCkucmVzaGFwZShkKX1yZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnN0cmlkZWRTbGljZShsLGUsbixyLG8sYSxpLHMsdSl9LHskeDpsfSl9fSk7dmFyIF9sPUFuKHt0b3BrXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9MSksdm9pZCAwPT09biYmKG49ITApO3ZhciByPXduKHQsXCJ4XCIsXCJ0b3BrXCIpO2lmKDA9PT1yLnJhbmspdGhyb3cgbmV3IEVycm9yKFwidG9waygpIGV4cGVjdHMgdGhlIGlucHV0IHRvIGJlIG9mIHJhbmsgMSBvciBoaWdoZXJcIik7dmFyIG89ci5zaGFwZVtyLnNoYXBlLmxlbmd0aC0xXTtpZihlPm8pdGhyb3cgbmV3IEVycm9yKFwiJ2snIHBhc3NlZCB0byB0b3BrKCkgbXVzdCBiZSA8PSB0aGUgbGFzdCBkaW1lbnNpb24gKFwiK28rXCIpIGJ1dCBnb3QgXCIrZSk7dmFyIGE9RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRvcGsocixlLG4pfSx7JHg6cn0pO3JldHVybnt2YWx1ZXM6YVswXSxpbmRpY2VzOmFbMV19fX0pO3ZhciBNbD1Bbih7c2NhdHRlck5EXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9d24odCxcImluZGljZXNcIixcInNjYXR0ZXJORFwiLFwiaW50MzJcIiksbz13bihlLFwidXBkYXRlc1wiLFwic2NhdHRlck5EXCIpO3JldHVybiBobihvLHIsbiksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNjYXR0ZXJORChyLG8sbil9LHskaW5kaWNlczpyLCR1cGRhdGVzOm99KX19KTt2YXIgRmw9QW4oe2ZmdF86ZnVuY3Rpb24odCl7ZChcImNvbXBsZXg2NFwiPT09dC5kdHlwZSxmdW5jdGlvbigpe3JldHVyblwiVGhlIGR0eXBlIGZvciB0Zi5zcGVjdHJhbC5mZnQoKSBtdXN0IGJlIGNvbXBsZXg2NCBidXQgZ290IFwiK3QuZHR5cGUrXCIuXCJ9KTt2YXIgZT10LnNoYXBlW3Quc2hhcGUubGVuZ3RoLTFdLG49dC5zaXplL2Uscj10LmFzMkQobixlKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmZmdChyKX0se2lucHV0OnR9KS5yZXNoYXBlKHQuc2hhcGUpfX0pLEJsPUFuKHtpZmZ0XzpmdW5jdGlvbih0KXtkKFwiY29tcGxleDY0XCI9PT10LmR0eXBlLGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZHR5cGUgZm9yIHRmLnNwZWN0cmFsLmlmZnQoKSBtdXN0IGJlIGNvbXBsZXg2NCBidXQgZ290IFwiK3QuZHR5cGUrXCIuXCJ9KTt2YXIgZT10LnNoYXBlW3Quc2hhcGUubGVuZ3RoLTFdLG49dC5zaXplL2Uscj10LmFzMkQobixlKTtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlmZnQocil9LHtpbnB1dDp0fSkucmVzaGFwZSh0LnNoYXBlKX19KSxQbD1Bbih7cmZmdF86ZnVuY3Rpb24odCl7ZChcImZsb2F0MzJcIj09PXQuZHR5cGUsZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBkdHlwZSBmb3IgcmZmdCgpIG11c3QgYmUgcmVhbCB2YWx1ZSBidXQgZ290IFwiK3QuZHR5cGV9KTt2YXIgZT10LnNoYXBlW3Quc2hhcGUubGVuZ3RoLTFdLG49dC5zaXplL2Uscj10Lnplcm9zTGlrZSgpLG89T24odCxyKS5hczJEKG4sZSksYT1GbChvKSxpPU1hdGguZmxvb3IoZS8yKSsxLHM9X24oYSksdT1NbihhKSxsPXMuc3BsaXQoW2ksZS1pXSxzLnNoYXBlLmxlbmd0aC0xKSxjPXUuc3BsaXQoW2ksZS1pXSx1LnNoYXBlLmxlbmd0aC0xKSxoPXQuc2hhcGUuc2xpY2UoKTtyZXR1cm4gaFt0LnNoYXBlLmxlbmd0aC0xXT1pLE9uKGxbMF0sY1swXSkucmVzaGFwZShoKX19KSxMbD1Bbih7aXJmZnRfOmZ1bmN0aW9uKHQpe3ZhciBlPXQuc2hhcGVbdC5zaGFwZS5sZW5ndGgtMV0sbj10LnNpemUvZTtpZihlPD0yKXt2YXIgcj10LmFzMkQobixlKSxvPUJsKHIpO3JldHVybiBfbihvKX12YXIgYT1bbiwyKihlLTEpXSxpPV9uKHQpLmFzMkQobixlKSxzPU1uKHQpLmFzMkQobixlKSx1PWkuc2xpY2UoWzAsMV0sW24sZS0yXSkucmV2ZXJzZSgxKSxsPXMuc2xpY2UoWzAsMV0sW24sZS0yXSkucmV2ZXJzZSgxKS5tdWwoQm4oLTEpKSxjPWkuY29uY2F0KHUsMSksaD1zLmNvbmNhdChsLDEpO3JldHVybiByPU9uKGMsaCkuYXMyRChhWzBdLGFbMV0pLG89QmwociksX24obyl9fSksV2w9T2JqZWN0LmZyZWV6ZSh7ZmZ0OkZsLGlmZnQ6QmwscmZmdDpQbCxpcmZmdDpMbH0pO3ZhciBVbD1Bbih7c3BhcnNlVG9EZW5zZV86ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9MCk7dmFyIG89d24odCxcInNwYXJzZUluZGljZXNcIixcInNwYXJzZVRvRGVuc2VcIixcImludDMyXCIpLGE9d24oZSxcInNwYXJzZVZhbHVlc1wiLFwic3BhcnNlVG9EZW5zZVwiKSxpPXduKHIsXCJkZWZhdWx0VmFsdWVcIixcInNwYXJzZVRvRGVuc2VcIixhLmR0eXBlKTtyZXR1cm4gZnVuY3Rpb24odCxlLG4scil7aWYoXCJpbnQzMlwiIT09dC5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJ0Zi5zcGFyc2VUb0RlbnNlKCkgZXhwZWN0cyB0aGUgaW5kaWNlcyB0byBiZSBpbnQzMiB0eXBlLCBidXQgdGhlIGR0eXBlIHdhcyBcIit0LmR0eXBlK1wiLlwiKTtpZih0LnJhbms+Mil0aHJvdyBuZXcgRXJyb3IoXCJzcGFyc2VJbmRpY2VzIHNob3VsZCBiZSBhIHNjYWxhciwgdmVjdG9yLCBvciBtYXRyaXgsIGJ1dCBnb3Qgc2hhcGUgXCIrdC5zaGFwZStcIi5cIik7dmFyIG89dC5yYW5rPjA/dC5zaGFwZVswXToxLGE9dC5yYW5rPjE/dC5zaGFwZVsxXToxO2lmKG4ubGVuZ3RoIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJvdXRwdXRTaGFwZSBoYXMgaW5jb3JyZWN0IG51bWJlciBvZiBlbGVtZW50czosIFwiK24ubGVuZ3RoK1wiLCBzaG91bGQgYmU6IFwiK2ErXCIuXCIpO3ZhciBpPWUuc2l6ZTtpZigwIT09ZS5yYW5rJiYoMSE9PWUucmFua3x8aSE9PW8pKXRocm93IG5ldyBFcnJvcihcInNwYXJzZVZhbHVlcyBoYXMgaW5jb3JyZWN0IHNoYXBlIFwiK2Uuc2hhcGUrXCIsIHNob3VsZCBiZSBbXSBvciBbXCIrbytcIl1cIik7aWYoZS5kdHlwZSE9PXIuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwic3BhcnNlVmFsdWVzLmR0eXBlIG11c3QgbWF0Y2ggZGVmYXVsdFZhbHVlcy5kdHlwZVwiKX0obyxhLG4saSksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNwYXJzZVRvRGVuc2UobyxhLG4saSl9LHskc3BhcnNlSW5kaWNlczpvLCRzcGFyc2VWYWx1ZXM6YSwkZGVmYXVsdFZhbHVlOml9KX19KTt2YXIgemw9QW4oe2dhdGhlck5EXzpmdW5jdGlvbih0LGUpe3ZhciBuPXduKGUsXCJpbmRpY2VzXCIsXCJnYXRoZXJORFwiLFwiaW50MzJcIikscj13bih0LFwieFwiLFwiZ2F0aGVyTkRcIik7cmV0dXJuIER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5nYXRoZXJORChyLG4pfSx7JHg6ciwkaW5kaWNlczpufSl9fSk7dmFyIFZsPUFuKHtkcm9wb3V0XzpmdW5jdGlvbih0LGUsbixyKXtpZihudWxsIT1uJiYheCh0LnNoYXBlLG4pKXRocm93IG5ldyBFcnJvcihcIk5vbi1kZWZhdWx0IG5vaXNlIHNoYXBlIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQ6IFwiK0pTT04uc3RyaW5naWZ5KG4pKTt2YXIgbz1xcih0LnNoYXBlLDAsMSxcImZsb2F0MzJcIixyKS5ncmVhdGVyKGUpO3JldHVybiBvPW8uZGl2KGxsKDEsZSkpLHQubXVsKG8pfX0pO2Z1bmN0aW9uIEdsKHQsZSxuKXtmb3IodmFyIHI9MS10JTIsbz1uZXcgRmxvYXQzMkFycmF5KHQpLGE9MDthPHQ7KythKXt2YXIgaT0yKk1hdGguUEkqYS8odCtyLTEpO29bYV09ZS1uKk1hdGguY29zKGkpfXJldHVybiBQbihvLFwiZmxvYXQzMlwiKX12YXIgcWwsSGw9QW4oe2hhbm5XaW5kb3dfOmZ1bmN0aW9uKHQpe3JldHVybiBHbCh0LC41LC41KX19KSwkbD1Bbih7aGFtbWluZ1dpbmRvd186ZnVuY3Rpb24odCl7cmV0dXJuIEdsKHQsLjU0LC40Nil9fSk7IWZ1bmN0aW9uKHQpe3RbdC5OT05FPTBdPVwiTk9ORVwiLHRbdC5NRUFOPTFdPVwiTUVBTlwiLHRbdC5TVU09Ml09XCJTVU1cIix0W3QuU1VNX0JZX05PTlpFUk9fV0VJR0hUUz0zXT1cIlNVTV9CWV9OT05aRVJPX1dFSUdIVFNcIn0ocWx8fChxbD17fSkpO3ZhciBqbD1Bbih7YWJzb2x1dGVEaWZmZXJlbmNlXzpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1xbC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgbz13bih0LFwibGFiZWxzXCIsXCJhYnNvbHV0ZURpZmZlcmVuY2VcIiksYT13bihlLFwicHJlZGljdGlvbnNcIixcImFic29sdXRlRGlmZmVyZW5jZVwiKSxpPW51bGw7bnVsbCE9biYmKGk9d24obixcIndlaWdodHNcIixcImFic29sdXRlRGlmZmVyZW5jZVwiKSksdihvLnNoYXBlLGEuc2hhcGUsXCJFcnJvciBpbiBhYnNvbHV0ZURpZmZlcmVuY2U6IFwiKTt2YXIgcz1vLnN1YihhKS5hYnMoKTtyZXR1cm4gS2wocyxpLHIpfX0pLEtsPUFuKHtjb21wdXRlV2VpZ2h0ZWRMb3NzXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49cWwuU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIHI9d24odCxcImxvc3Nlc1wiLFwiY29tcHV0ZVdlaWdodGVkTG9zc1wiKSxvPW51bGw7bnVsbCE9ZSYmKG89d24oZSxcIndlaWdodHNcIixcImNvbXB1dGVXZWlnaHRlZExvc3NcIikpO3ZhciBhPW51bGw9PW8/cjpyLm11bChvKTtpZihuPT09cWwuTk9ORSlyZXR1cm4gYTtpZihuPT09cWwuU1VNKXJldHVybiBhLnN1bSgpO2lmKG49PT1xbC5NRUFOKXtpZihudWxsPT1vKXJldHVybiBhLm1lYW4oKTt2YXIgaT1yLnNpemUvby5zaXplLHM9YS5zdW0oKS5kaXYoby5zdW0oKSk7cmV0dXJuIGk+MT9zLmRpdihCbihpKSk6c31pZihuPT09cWwuU1VNX0JZX05PTlpFUk9fV0VJR0hUUyl7aWYobnVsbD09bylyZXR1cm4gYS5zdW0oKS5kaXYoQm4oci5zaXplKSk7dmFyIHU9by5tdWwoR24oci5zaGFwZSkpLm5vdEVxdWFsKEJuKDApKS5zdW0oKS50b0Zsb2F0KCk7cmV0dXJuIGEuc3VtKCkuZGl2KHUpfXRocm93IEVycm9yKFwiVW5rbm93biByZWR1Y3Rpb246IFwiK24pfX0pLFhsPUFuKHtjb3NpbmVEaXN0YW5jZV86ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1vJiYobz1xbC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgYT13bih0LFwibGFiZWxzXCIsXCJjb3NpbmVEaXN0YW5jZVwiKSxpPXduKGUsXCJwcmVkaWN0aW9uc1wiLFwiY29zaW5lRGlzdGFuY2VcIikscz1udWxsO251bGwhPXImJihzPXduKHIsXCJ3ZWlnaHRzXCIsXCJjb3NpbmVEaXN0YW5jZVwiKSksdihhLnNoYXBlLGkuc2hhcGUsXCJFcnJvciBpbiBjb3NpbmVEaXN0YW5jZTogXCIpO3ZhciB1PUJuKDEpLnN1YihhLm11bChpKS5zdW0obiwhMCkpO3JldHVybiBLbCh1LHMsbyl9fSksWWw9QW4oe2hpbmdlTG9zc186ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9cWwuU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIG89d24odCxcImxhYmVsc1wiLFwiaGluZ2VMb3NzXCIpLGE9d24oZSxcInByZWRpY3Rpb25zXCIsXCJoaW5nZUxvc3NcIiksaT1udWxsO251bGwhPW4mJihpPXduKG4sXCJ3ZWlnaHRzXCIsXCJoaW5nZUxvc3NcIikpLHYoby5zaGFwZSxhLnNoYXBlLFwiRXJyb3IgaW4gaGluZ2VMb3NzOiBcIik7dmFyIHM9Qm4oMSk7bz1CbigyKS5tdWwobykuc3ViKHMpO3ZhciB1PXMuc3ViKG8ubXVsKGEpKS5yZWx1KCk7cmV0dXJuIEtsKHUsaSxyKX19KSxRbD1Bbih7aHViZXJMb3NzXzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PXImJihyPTEpLHZvaWQgMD09PW8mJihvPXFsLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBhPXduKHQsXCJsYWJlbHNcIixcImh1YmVyTG9zc1wiKSxpPXduKGUsXCJwcmVkaWN0aW9uc1wiLFwiaHViZXJMb3NzXCIpLHM9bnVsbDtudWxsIT1uJiYocz13bihuLFwid2VpZ2h0c1wiLFwiaHViZXJMb3NzXCIpKSx2KGEuc2hhcGUsaS5zaGFwZSxcIkVycm9yIGluIGh1YmVyTG9zczogXCIpO3ZhciB1PUJuKHIpLGw9aS5zdWIoYSkuYWJzKCksYz1adShsLHUpLGg9bC5zdWIoYykscD1CbiguNSkubXVsKGMuc3F1YXJlKCkpLmFkZCh1Lm11bChoKSk7cmV0dXJuIEtsKHAscyxvKX19KSxKbD1Bbih7bG9nTG9zc186ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1yJiYocj0xZS03KSx2b2lkIDA9PT1vJiYobz1xbC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgYT13bih0LFwibGFiZWxzXCIsXCJsb2dMb3NzXCIpLGk9d24oZSxcInByZWRpY3Rpb25zXCIsXCJsb2dMb3NzXCIpLHM9bnVsbDtudWxsIT1uJiYocz13bihuLFwid2VpZ2h0c1wiLFwibG9nTG9zc1wiKSksdihhLnNoYXBlLGkuc2hhcGUsXCJFcnJvciBpbiBsb2dMb3NzOiBcIik7dmFyIHU9Qm4oMSksbD1CbihyKSxjPWEubXVsKGkuYWRkKGwpLmxvZygpKS5uZWcoKS5zdWIodS5zdWIoYSkubXVsKHUuc3ViKGkpLmFkZChsKS5sb2coKSkpO3JldHVybiBLbChjLHMsbyl9fSksWmw9QW4oe21lYW5TcXVhcmVkRXJyb3JfOmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPXFsLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBvPXduKHQsXCJsYWJlbHNcIixcIm1lYW5TcXVhcmVkRXJyb3JcIiksYT13bihlLFwicHJlZGljdGlvbnNcIixcIm1lYW5TcXVhcmVkRXJyb3JcIiksaT1udWxsO251bGwhPW4mJihpPXduKG4sXCJ3ZWlnaHRzXCIsXCJtZWFuU3F1YXJlZEVycm9yXCIpKSx2KG8uc2hhcGUsYS5zaGFwZSxcIkVycm9yIGluIG1lYW5TcXVhcmVkRXJyb3I6IFwiKTt2YXIgcz1vLnNxdWFyZWREaWZmZXJlbmNlKGEpO3JldHVybiBLbChzLGkscil9fSksdGM9QW4oe3NpZ21vaWRDcm9zc0VudHJvcHlfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09ciYmKHI9MCksdm9pZCAwPT09byYmKG89cWwuU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIGE9d24odCxcIm11bHRpQ2xhc3NMYWJlbHNcIixcInNpZ21vaWRDcm9zc0VudHJvcHlcIiksaT13bihlLFwibG9naXRzXCIsXCJzaWdtb2lkQ3Jvc3NFbnRyb3B5XCIpLHM9bnVsbDtpZihudWxsIT1uJiYocz13bihuLFwid2VpZ2h0c1wiLFwic2lnbW9pZENyb3NzRW50cm9weVwiKSksdihhLnNoYXBlLGkuc2hhcGUsXCJFcnJvciBpbiBzaWdtb2lkQ3Jvc3NFbnRyb3B5OiBcIikscj4wKXt2YXIgdT1CbihyKSxsPUJuKDEpLGM9Qm4oLjUpO2E9YS5tdWwobC5zdWIodSkpLmFkZChjLm11bCh1KSl9dmFyIGg9ZnVuY3Rpb24odCxlKXt2YXIgbj13bih0LFwibGFiZWxzXCIsXCJzaWdtb2lkQ3Jvc3NFbnRyb3B5V2l0aExvZ2l0c1wiKSxyPXduKGUsXCJsb2dpdHNcIixcInNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzXCIpO3Yobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gc2lnbW9pZENyb3NzRW50cm9weVdpdGhMb2dpdHM6IFwiKTt2YXIgbz1yLnJlbHUoKSxhPXIubXVsKG4pLGk9ci5hYnMoKS5uZWcoKS5leHAoKS5sb2cxcCgpO3JldHVybiBvLnN1YihhKS5hZGQoaSl9KGEsaSk7cmV0dXJuIEtsKGgscyxvKX19KSxlYz1Bbih7c29mdG1heENyb3NzRW50cm9weV86ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1yJiYocj0wKSx2b2lkIDA9PT1vJiYobz1xbC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgYT13bih0LFwib25laG90TGFiZWxzXCIsXCJzb2Z0bWF4Q3Jvc3NFbnRyb3B5XCIpLGk9d24oZSxcImxvZ2l0c1wiLFwic29mdG1heENyb3NzRW50cm9weVwiKSxzPW51bGw7aWYobnVsbCE9biYmKHM9d24obixcIndlaWdodHNcIixcInNvZnRtYXhDcm9zc0VudHJvcHlcIikpLHYoYS5zaGFwZSxpLnNoYXBlLFwiRXJyb3IgaW4gc29mdG1heENyb3NzRW50cm9weTogXCIpLHI+MCl7dmFyIHU9Qm4ociksbD1CbigxKSxjPUJuKGEuc2hhcGVbMV0pO2E9YS5tdWwobC5zdWIodSkpLmFkZCh1LmRpdihjKSl9dmFyIGg9ZnVuY3Rpb24odCxlLG4pe2lmKHZvaWQgMD09PW4mJihuPS0xKSwtMT09PW4mJihuPWUucmFuay0xKSxuIT09ZS5yYW5rLTEpdGhyb3cgRXJyb3IoXCJTb2Z0bWF4IGNyb3NzIGVudHJvcHkgYWxvbmcgYSBub24tbGFzdCBkaW1lbnNpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQuIExhYmVscyAvIGxvZ2l0cyB3YXMgcmFuayBcIitlLnJhbmsrXCIgYW5kIGRpbSB3YXMgXCIrbik7cmV0dXJuIGtuKGZ1bmN0aW9uKHQsZSxyKXt2YXIgbz1lLmxvZ1N1bUV4cChbbl0sITApLGE9ZS50b0Zsb2F0KCkuc3ViKG8pO3JldHVybiByKFt0LGFdKSx7dmFsdWU6YS5tdWwodCkubmVnKCkuc3VtKFtuXSksZ3JhZEZ1bmM6ZnVuY3Rpb24odCxlKXt2YXIgcj1lWzBdLG89ZVsxXSxhPWVuKHQuc2hhcGUsW25dKTtyZXR1cm5bdC5yZXNoYXBlKGEpLm11bChyLnRvRmxvYXQoKS5zdWIoby5leHAoKSkpLHQucmVzaGFwZShhKS5tdWwoby5leHAoKS5zdWIoci50b0Zsb2F0KCkpKV19fX0pKHQsZSl9KGEsaSk7cmV0dXJuIEtsKGgscyxvKX19KSxuYz1PYmplY3QuZnJlZXplKHtnZXQgUmVkdWN0aW9uKCl7cmV0dXJuIHFsfSxhYnNvbHV0ZURpZmZlcmVuY2U6amwsY29tcHV0ZVdlaWdodGVkTG9zczpLbCxjb3NpbmVEaXN0YW5jZTpYbCxoaW5nZUxvc3M6WWwsaHViZXJMb3NzOlFsLGxvZ0xvc3M6SmwsbWVhblNxdWFyZWRFcnJvcjpabCxzaWdtb2lkQ3Jvc3NFbnRyb3B5OnRjLHNvZnRtYXhDcm9zc0VudHJvcHk6ZWN9KTtmdW5jdGlvbiByYyh0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMSksRHQudGlkeShmdW5jdGlvbigpe2lmKDIhPT10LnNoYXBlLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJxcjJkKCkgcmVxdWlyZXMgYSAyRCBUZW5zb3IsIGJ1dCBnb3QgYSBcIit0LnNoYXBlLmxlbmd0aCtcIkQgVGVuc29yLlwiKTtmb3IodmFyIG49dC5zaGFwZVswXSxyPXQuc2hhcGVbMV0sbz1NcihuKSxhPXQuY2xvbmUoKSxpPUxuKFtbMV1dLFsxLDFdKSxzPWkuY2xvbmUoKSx1PW4+PXI/cjpuLGw9ZnVuY3Rpb24odCl7dmFyIGUsdT1hLGw9cyxjPW87ZT1EdC50aWR5KGZ1bmN0aW9uKCl7dmFyIGU9YS5zbGljZShbdCx0XSxbbi10LDFdKSx1PWUubm9ybSgpLGw9YS5zbGljZShbdCx0XSxbMSwxXSksYz1sLnNpZ24oKS5uZWcoKSxoPWwuc3ViKGMubXVsKHUpKSxwPWUuZGl2KGgpO3M9MT09PXAuc2hhcGVbMF0/aS5jbG9uZSgpOmkuY29uY2F0KHAuc2xpY2UoWzEsMF0sW3Auc2hhcGVbMF0tMSxwLnNoYXBlWzFdXSksMCk7dmFyIGY9Yy5tYXRNdWwoaCkuZGl2KHUpLm5lZygpLGQ9YS5zbGljZShbdCwwXSxbbi10LHJdKSx2PWYubXVsKHMpO2E9MD09PXQ/ZC5zdWIodi5tYXRNdWwocy50cmFuc3Bvc2UoKS5tYXRNdWwoZCkpKTphLnNsaWNlKFswLDBdLFt0LHJdKS5jb25jYXQoZC5zdWIodi5tYXRNdWwocy50cmFuc3Bvc2UoKS5tYXRNdWwoZCkpKSwwKTt2YXIgbT1vLnNsaWNlKFswLHRdLFtuLG8uc2hhcGVbMV0tdF0pO3JldHVybiBvPTA9PT10P20uc3ViKG0ubWF0TXVsKHMpLm1hdE11bCh2LnRyYW5zcG9zZSgpKSk6by5zbGljZShbMCwwXSxbbix0XSkuY29uY2F0KG0uc3ViKG0ubWF0TXVsKHMpLm1hdE11bCh2LnRyYW5zcG9zZSgpKSksMSksW3MsYSxvXX0pLHM9ZVswXSxhPWVbMV0sbz1lWzJdLEJlKFt1LGwsY10pfSxjPTA7Yzx1OysrYylsKGMpO3JldHVybiFlJiZuPnImJihvPW8uc2xpY2UoWzAsMF0sW24scl0pLGE9YS5zbGljZShbMCwwXSxbcixyXSkpLFtvLGFdfSl9dmFyIG9jPUFuKHtncmFtU2NobWlkdF86ZnVuY3Rpb24odCl7dmFyIGU7aWYoQXJyYXkuaXNBcnJheSh0KSl7ZT0hMSxkKG51bGwhPXQmJnQubGVuZ3RoPjAsZnVuY3Rpb24oKXtyZXR1cm5cIkdyYW0tU2NobWlkdCBwcm9jZXNzOiBpbnB1dCBtdXN0IG5vdCBiZSBudWxsLCB1bmRlZmluZWQsIG9yIGVtcHR5XCJ9KTtmb3IodmFyIG49dFswXS5zaGFwZVswXSxyPWZ1bmN0aW9uKGUpe2QodFtlXS5zaGFwZVswXT09PW4sZnVuY3Rpb24oKXtyZXR1cm5cIkdyYW0tU2NobWlkdDogTm9uLXVuaXF1ZSBsZW5ndGhzIGZvdW5kIGluIHRoZSBpbnB1dCB2ZWN0b3JzOiAoXCIrdFtlXS5zaGFwZVswXStcIiB2cy4gXCIrbitcIilcIn0pfSxvPTE7bzx0Lmxlbmd0aDsrK28pcihvKX1lbHNlIGU9ITAsdD1kcih0LHQuc2hhcGVbMF0sMCkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBqcih0LFswXSl9KTtkKHQubGVuZ3RoPD10WzBdLnNoYXBlWzBdLGZ1bmN0aW9uKCl7cmV0dXJuXCJHcmFtLVNjaG1pZHQ6IE51bWJlciBvZiB2ZWN0b3JzIChcIit0Lmxlbmd0aCtcIikgZXhjZWVkcyBudW1iZXIgb2YgZGltZW5zaW9ucyAoXCIrdFswXS5zaGFwZVswXStcIikuXCJ9KTt2YXIgYT1bXSxpPXQscz1mdW5jdGlvbih0KXthLnB1c2goRHQudGlkeShmdW5jdGlvbigpe3ZhciBlPWlbdF07aWYodD4wKWZvcih2YXIgbj0wO248dDsrK24pe3ZhciByPVR1KGFbbl0ubXVsU3RyaWN0KGUpKS5tdWwoYVtuXSk7ZT1lLnN1YihyKX1yZXR1cm4gZS5kaXYoUmwoZSxcImV1Y2xpZGVhblwiKSl9KSl9O2ZvcihvPTA7bzx0Lmxlbmd0aDsrK28pcyhvKTtyZXR1cm4gZT9LcihhLDApOmF9fSksYWM9QW4oe3FyXzpmdW5jdGlvbih0LGUpe2lmKHZvaWQgMD09PWUmJihlPSExKSx0LnJhbms8Mil0aHJvdyBuZXcgRXJyb3IoXCJxcigpIHJlcXVpcmVzIGlucHV0IHRlbnNvciB0byBoYXZlIGEgcmFuayA+PSAyLCBidXQgZ290IHJhbmsgXCIrdC5yYW5rKTtpZigyPT09dC5yYW5rKXJldHVybiByYyh0LGUpO3ZhciBuPXQuc2hhcGUuc2xpY2UoMCx0LnNoYXBlLmxlbmd0aC0yKS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSkscj1Rcih0LnJlc2hhcGUoW24sdC5zaGFwZVt0LnNoYXBlLmxlbmd0aC0yXSx0LnNoYXBlW3Quc2hhcGUubGVuZ3RoLTFdXSksMCksbz1bXSxhPVtdO3JldHVybiByLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIG49cmModCxlKSxyPW5bMF0saT1uWzFdO28ucHVzaChyKSxhLnB1c2goaSl9KSxbS3IobywwKS5yZXNoYXBlKHQuc2hhcGUpLEtyKGEsMCkucmVzaGFwZSh0LnNoYXBlKV19fSksaWM9T2JqZWN0LmZyZWV6ZSh7Z3JhbVNjaG1pZHQ6b2MscXI6YWN9KTtmdW5jdGlvbiBzYyh0LGUsbixyLG8pe251bGw9PXImJihyPS41KSxudWxsPT1vJiYobz1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO3ZhciBhPXQuc2hhcGVbMF07cmV0dXJuIG49TWF0aC5taW4obixhKSxkKDA8PXImJnI8PTEsZnVuY3Rpb24oKXtyZXR1cm5cImlvdVRocmVzaG9sZCBtdXN0IGJlIGluIFswLCAxXSwgYnV0IHdhcyAnXCIrcitcIidcIn0pLGQoMj09PXQucmFuayxmdW5jdGlvbigpe3JldHVyblwiYm94ZXMgbXVzdCBiZSBhIDJEIHRlbnNvciwgYnV0IHdhcyBvZiByYW5rICdcIit0LnJhbmsrXCInXCJ9KSxkKDQ9PT10LnNoYXBlWzFdLGZ1bmN0aW9uKCl7cmV0dXJuXCJib3hlcyBtdXN0IGhhdmUgNCBjb2x1bW5zLCBidXQgMm5kIGRpbWVuc2lvbiB3YXMgXCIrdC5zaGFwZVsxXX0pLGQoMT09PWUucmFuayxmdW5jdGlvbigpe3JldHVyblwic2NvcmVzIG11c3QgYmUgYSAxRCB0ZW5zb3JcIn0pLGQoZS5zaGFwZVswXT09PWEsZnVuY3Rpb24oKXtyZXR1cm5cInNjb3JlcyBoYXMgaW5jb21wYXRpYmxlIHNoYXBlIHdpdGggYm94ZXMuIEV4cGVjdGVkIFwiK2ErXCIsIGJ1dCB3YXMgXCIrZS5zaGFwZVswXX0pLHttYXhPdXRwdXRTaXplOm4saW91VGhyZXNob2xkOnIsc2NvcmVUaHJlc2hvbGQ6b319dmFyIHVjPUFuKHtyZXNpemVCaWxpbmVhcl86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPSExKTt2YXIgcj13bih0LFwiaW1hZ2VzXCIsXCJyZXNpemVCaWxpbmVhclwiKTtkKDM9PT1yLnJhbmt8fDQ9PT1yLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHJlc2l6ZUJpbGluZWFyOiB4IG11c3QgYmUgcmFuayAzIG9yIDQsIGJ1dCBnb3QgcmFuayBcIityLnJhbmsrXCIuXCJ9KSxkKDI9PT1lLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gcmVzaXplQmlsaW5lYXI6IG5ldyBzaGFwZSBtdXN0IDJELCBidXQgZ290IHNoYXBlIFwiK2UrXCIuXCJ9KTt2YXIgbz1yLGE9ITE7Mz09PXIucmFuayYmKGE9ITAsbz1yLmFzNEQoMSxyLnNoYXBlWzBdLHIuc2hhcGVbMV0sci5zaGFwZVsyXSkpO3ZhciBpPWVbMF0scz1lWzFdLHU9RHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUoW29dKSx0LnJlc2l6ZUJpbGluZWFyKG8saSxzLG4pfSx7YmF0Y2hJbWFnZXM6b30sZnVuY3Rpb24odCxlKXtyZXR1cm57YmF0Y2hJbWFnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHIpe3JldHVybiByLnJlc2l6ZUJpbGluZWFyQmFja3Byb3AodCxlWzBdLG4pfSx7fSl9fX0pO3JldHVybiBhP3UuYXMzRCh1LnNoYXBlWzFdLHUuc2hhcGVbMl0sdS5zaGFwZVszXSk6dX19KSxsYz1Bbih7cmVzaXplTmVhcmVzdE5laWdoYm9yXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49ITEpO3ZhciByPXduKHQsXCJpbWFnZXNcIixcInJlc2l6ZU5lYXJlc3ROZWlnaGJvclwiKTtkKDM9PT1yLnJhbmt8fDQ9PT1yLnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHJlc2l6ZU5lYXJlc3ROZWlnaGJvcjogeCBtdXN0IGJlIHJhbmsgMyBvciA0LCBidXQgZ290IHJhbmsgXCIrci5yYW5rK1wiLlwifSksZCgyPT09ZS5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHJlc2l6ZU5lYXJlc3ROZWlnaGJvcjogbmV3IHNoYXBlIG11c3QgMkQsIGJ1dCBnb3Qgc2hhcGUgXCIrZStcIi5cIn0pLGQoXCJmbG9hdDMyXCI9PT1yLmR0eXBlfHxcImludDMyXCI9PT1yLmR0eXBlLGZ1bmN0aW9uKCl7cmV0dXJuXCJgaW1hZ2VzYCBtdXN0IGhhdmUgYGludDMyYCBvciBgZmxvYXQzMmAgYXMgZHR5cGVcIn0pO3ZhciBvPXIsYT0hMTszPT09ci5yYW5rJiYoYT0hMCxvPXIuYXM0RCgxLHIuc2hhcGVbMF0sci5zaGFwZVsxXSxyLnNoYXBlWzJdKSk7dmFyIGk9ZVswXSxzPWVbMV0sdT1EdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXtyZXR1cm4gZShbb10pLHQucmVzaXplTmVhcmVzdE5laWdoYm9yKG8saSxzLG4pfSx7YmF0Y2hJbWFnZXM6b30sZnVuY3Rpb24odCxlKXtyZXR1cm57YmF0Y2hJbWFnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gRHQucnVuS2VybmVsKGZ1bmN0aW9uKHIpe3JldHVybiByLnJlc2l6ZU5lYXJlc3ROZWlnaGJvckJhY2twcm9wKHQsZVswXSxuKX0se30pfX19KTtyZXR1cm4gYT91LmFzM0QodS5zaGFwZVsxXSx1LnNoYXBlWzJdLHUuc2hhcGVbM10pOnV9fSksY2M9QW4oe25vbk1heFN1cHByZXNzaW9uXzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PXImJihyPS41KSx2b2lkIDA9PT1vJiYobz1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO3ZhciBhPXduKHQsXCJib3hlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25cIiksaT13bihlLFwic2NvcmVzXCIsXCJub25NYXhTdXBwcmVzc2lvblwiKSxzPXNjKGEsaSxuLHIsbyk7cmV0dXJuIG49cy5tYXhPdXRwdXRTaXplLHI9cy5pb3VUaHJlc2hvbGQsbz1zLnNjb3JlVGhyZXNob2xkLER0LnJ1bktlcm5lbChmdW5jdGlvbih0KXtyZXR1cm4gdC5ub25NYXhTdXBwcmVzc2lvbihhLGksbixyLG8pfSx7JGJveGVzOmF9KX19KSxoYz1mdW5jdGlvbih0LGUsbixhLGkpe3JldHVybiB2b2lkIDA9PT1hJiYoYT0uNSksdm9pZCAwPT09aSYmKGk9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSxyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciByLHMsdSxsLGMsaDtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHI9d24odCxcImJveGVzXCIsXCJub25NYXhTdXBwcmVzc2lvbkFzeW5jXCIpLHM9d24oZSxcInNjb3Jlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25Bc3luY1wiKSx1PXNjKHIscyxuLGEsaSksbj11Lm1heE91dHB1dFNpemUsYT11LmlvdVRocmVzaG9sZCxpPXUuc2NvcmVUaHJlc2hvbGQsWzQsci5kYXRhKCldO2Nhc2UgMTpyZXR1cm4gbD1vLnNlbnQoKSxbNCxzLmRhdGEoKV07Y2FzZSAyOnJldHVybiBjPW8uc2VudCgpLGg9YXIobCxjLG4sYSxpKSxyIT09dCYmci5kaXNwb3NlKCkscyE9PWUmJnMuZGlzcG9zZSgpLFsyLGhdfX0pfSl9LHBjPUFuKHtjcm9wQW5kUmVzaXplXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7dmFyIGk9d24odCxcImltYWdlXCIsXCJjcm9wQW5kUmVzaXplXCIsXCJmbG9hdDMyXCIpLHM9d24oZSxcImJveGVzXCIsXCJjcm9wQW5kUmVzaXplXCIsXCJmbG9hdDMyXCIpLHU9d24obixcImJveEluZFwiLFwiY3JvcEFuZFJlc2l6ZVwiLFwiaW50MzJcIik7bz1vfHxcImJpbGluZWFyXCIsYT1hfHwwO3ZhciBsPXMuc2hhcGVbMF07cmV0dXJuIGQoND09PWkucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY3JvcEFuZFJlc2l6ZTogaW1hZ2UgbXVzdCBiZSByYW5rIDQsYnV0IGdvdCByYW5rIFwiK2kucmFuaytcIi5cIn0pLGQoMj09PXMucmFuayYmND09PXMuc2hhcGVbMV0sZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNyb3BBbmRSZXNpemU6IGJveGVzIG11c3QgYmUgaGF2ZSBzaXplIFtcIitsK1wiLDRdIGJ1dCBoYWQgc2hhcGUgXCIrcy5zaGFwZStcIi5cIn0pLGQoMT09PXUucmFuayYmdS5zaGFwZVswXT09PWwsZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNyb3BBbmRSZXNpemU6IGJveEluZCBtdXN0IGJlIGhhdmUgc2l6ZSBbXCIrbCtcIl0gYnV0IGhhZCBzaGFwZSBcIitzLnNoYXBlK1wiLlwifSksZCgyPT09ci5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNyb3BBbmRSZXNpemU6IGNyb3BTaXplIG11c3QgYmUgb2YgbGVuZ3RoIDIsIGJ1dCBnb3QgbGVuZ3RoIFwiK3IubGVuZ3RoK1wiLlwifSksZChyWzBdPj0xJiZyWzFdPj0xLGZ1bmN0aW9uKCl7cmV0dXJuXCJjcm9wU2l6ZSBtdXN0IGJlIGF0bGVhc3QgWzEsMV0sIGJ1dCB3YXMgXCIrcn0pLGQoXCJiaWxpbmVhclwiPT09b3x8XCJuZWFyZXN0XCI9PT1vLGZ1bmN0aW9uKCl7cmV0dXJuXCJtZXRob2QgbXVzdCBiZSBiaWxpbmVhciBvciBuZWFyZXN0LCBidXQgd2FzIFwiK299KSxEdC5ydW5LZXJuZWwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5jcm9wQW5kUmVzaXplKGkscyx1LHIsbyxhKX0seyRpbWFnZTppLCRib3hlczpzfSl9fSksZmM9T2JqZWN0LmZyZWV6ZSh7cmVzaXplQmlsaW5lYXI6dWMscmVzaXplTmVhcmVzdE5laWdoYm9yOmxjLG5vbk1heFN1cHByZXNzaW9uOmNjLG5vbk1heFN1cHByZXNzaW9uQXN5bmM6aGMsY3JvcEFuZFJlc2l6ZTpwY30pO3ZhciBkYz1Bbih7bWF0TXVsXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7dmFyIGk7dm9pZCAwPT09biYmKG49ITEpLHZvaWQgMD09PXImJihyPSExKSx2b2lkIDA9PT1hJiYoYT1cImxpbmVhclwiKTt2YXIgcz13bih0LFwiYVwiLFwiZnVzZWQgbWF0TXVsXCIpLHU9d24oZSxcImJcIixcImZ1c2VkIG1hdE11bFwiKTtpPVJ0KHMsdSkscz1pWzBdLHU9aVsxXTt2YXIgbD1uP3Muc2hhcGVbcy5yYW5rLTJdOnMuc2hhcGVbcy5yYW5rLTFdLGM9cj91LnNoYXBlW3UucmFuay0xXTp1LnNoYXBlW3UucmFuay0yXSxoPW4/cy5zaGFwZVtzLnJhbmstMV06cy5zaGFwZVtzLnJhbmstMl0scD1yP3Uuc2hhcGVbdS5yYW5rLTJdOnUuc2hhcGVbdS5yYW5rLTFdLGY9cy5zaGFwZS5zbGljZSgwLC0yKSx2PXUuc2hhcGUuc2xpY2UoMCwtMiksbT15KGYpLGc9eSh2KTtkKHMucmFuaz49MiYmdS5yYW5rPj0yJiZzLnJhbms9PT11LnJhbmssZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGZ1c2VkIG1hdE11bDogaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rIG9mIGF0IGxlYXN0IDIsIGdvdCByYW5rcyBcIitzLnJhbmsrXCIgYW5kIFwiK3UucmFuaytcIi5cIn0pLGQoeChmLHYpLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBmdXNlZCBtYXRNdWw6IG91dGVyIGRpbWVuc2lvbnMgKFwiK2YrXCIpIGFuZCAoXCIrditcIikgb2YgVGVuc29ycyB3aXRoIHNoYXBlcyBcIitzLnNoYXBlK1wiIGFuZCBcIit1LnNoYXBlK1wiIG11c3QgbWF0Y2guXCJ9KSxkKGw9PT1jLGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBmdXNlZCBtYXRNdWw6IGlubmVyIHNoYXBlcyAoXCIrbCtcIikgYW5kIChcIitjK1wiKSBvZiBUZW5zb3JzIHdpdGggc2hhcGVzIFwiK3Muc2hhcGUrXCIgYW5kIFwiK3Uuc2hhcGUrXCIgYW5kIHRyYW5zcG9zZUE9XCIrbitcIiBhbmQgdHJhbnNwb3NlQj1cIityK1wiIG11c3QgbWF0Y2guXCJ9KTt2YXIgdyxiPXMuc2hhcGUuc2xpY2UoMCwtMikuY29uY2F0KFtoLHBdKSxDPW4/cy5hczNEKG0sbCxoKTpzLmFzM0QobSxoLGwpLEU9cj91LmFzM0QoZyxwLGMpOnUuYXMzRChnLGMscCk7bnVsbCE9byYmc28oYiwodz1SdCh3PXduKG8sXCJiaWFzXCIsXCJmdXNlZCBtYXRNdWxcIikscylbMF0pLnNoYXBlKTt2YXIgUj17JGE6QywkYjpFfTtyZXR1cm4gbnVsbCE9byYmKFIuJGJpYXM9dyksRHQucnVuS2VybmVsKGZ1bmN0aW9uKHQsZSl7dmFyIG89dC5mdXNlZEJhdGNoTWF0TXVsKEMsRSxuLHIsdyxhKTtyZXR1cm4gZShbQyxFLG9dKSxvfSxSLGZ1bmN0aW9uKHQsZSl7dmFyIGkscz1lWzBdLHU9ZVsxXSxsPWVbMl07aWYobnVsbD09YXx8XCJsaW5lYXJcIj09PWEpaT10O2Vsc2V7aWYoXCJyZWx1XCIhPT1hKXRocm93IG5ldyBFcnJvcihcIkdyYWRpZW50IGZvciBhY3RpdmF0aW9uIFwiK2ErXCIgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIHlldC5cIik7aT10Lm11bChsLnN0ZXAoKSl9dmFyIGM9e307cmV0dXJuIG51bGwhPW8mJihjPXskYmlhczpmdW5jdGlvbigpe3ZhciB0PWksZT1pbyh3LnNoYXBlLGkuc2hhcGUpO3JldHVybiBlLmxlbmd0aD4wJiYodD10LnN1bShlKSksdC5yZXNoYXBlKHcuc2hhcGUpfX0pLG58fHI/IW4mJnI/T2JqZWN0LmFzc2lnbih7JGE6ZnVuY3Rpb24oKXtyZXR1cm4gaS5tYXRNdWwodSwhMSwhMSl9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIGkubWF0TXVsKHMsITAsITEpfX0sYyk6biYmIXI/T2JqZWN0LmFzc2lnbih7JGE6ZnVuY3Rpb24oKXtyZXR1cm4gdS5tYXRNdWwoaSwhMSwhMCl9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIHMubWF0TXVsKGksITEsITEpfX0sYyk6T2JqZWN0LmFzc2lnbih7JGE6ZnVuY3Rpb24oKXtyZXR1cm4gdS5tYXRNdWwoaSwhMCwhMCl9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIGkubWF0TXVsKHMsITAsITApfX0sYyk6T2JqZWN0LmFzc2lnbih7JGE6ZnVuY3Rpb24oKXtyZXR1cm4gaS5tYXRNdWwodSwhMSwhMCl9LCRiOmZ1bmN0aW9uKCl7cmV0dXJuIHMubWF0TXVsKGksITAsITEpfX0sYyl9KS5yZXNoYXBlKGIpfX0pLHZjPU9iamVjdC5mcmVlemUoe21hdE11bDpkY30pLG1jPU9iamVjdC5mcmVlemUoe2ltYWdlOmZjLGxpbmFsZzppYyxsb3NzZXM6bmMsc3BlY3RyYWw6V2wsZnVzZWQ6dmMsb3A6QW4sYmF0Y2hOb3JtYWxpemF0aW9uMmQ6QXMsYmF0Y2hOb3JtYWxpemF0aW9uM2Q6VHMsYmF0Y2hOb3JtYWxpemF0aW9uNGQ6RHMsYmF0Y2hOb3JtYWxpemF0aW9uOk9zLGJhdGNoTm9ybTpfcyxiYXRjaE5vcm0yZDpNcyxiYXRjaE5vcm0zZDpGcyxiYXRjaE5vcm00ZDpCcyxjb21wbGV4Ok9uLHJlYWw6X24saW1hZzpNbixjb25jYXQ6bHIsY29uY2F0MWQ6Y3IsY29uY2F0MmQ6aHIsY29uY2F0M2Q6cHIsY29uY2F0NGQ6ZnIsc3BsaXQ6ZHIsY29udjFkOlhzLGNvbnYyZDpZcyxjb252M2Q6UXMsY29udjJkRGVyRmlsdGVyOkpzLGRlcHRod2lzZUNvbnYyZDpacyxzZXBhcmFibGVDb252MmQ6dHUsY29udjJkVHJhbnNwb3NlOmV1LG1hdE11bDpudSxkb3Q6cnUsb3V0ZXJQcm9kdWN0Om91LHJldmVyc2U6YXUscmV2ZXJzZTFkOml1LHJldmVyc2UyZDpzdSxyZXZlcnNlM2Q6dXUscmV2ZXJzZTRkOmx1LG1heFBvb2w6cHUsYXZnUG9vbDpmdSxwb29sOmR1LHNsaWNlOnZ1LHNsaWNlMWQ6bXUsc2xpY2UyZDpndSxzbGljZTNkOnl1LHNsaWNlNGQ6eHUsYWJzOlZpLGFjb3M6R2ksYWNvc2g6cWksYXNpbjpIaSxhc2luaDokaSxhdGFuOmppLGF0YW5oOktpLGNlaWw6WGksY2xpcEJ5VmFsdWU6WWksY29zOlFpLGNvc2g6SmksZXJmOlppLGV4cDp0cyxleHBtMTplcyxmbG9vcjpucyxsb2c6cnMsbG9nMXA6b3MsbG9nU2lnbW9pZDphcyxuZWc6aXMscmVjaXByb2NhbDpzcyxyb3VuZDp1cyxyc3FydDpscyxzaWdtb2lkOmNzLHNpZ246aHMsaXNOYU46cHMsaXNJbmY6ZnMsaXNGaW5pdGU6ZHMsc2luOnZzLHNpbmg6bXMsc29mdHBsdXM6Z3Msc3FydDp5cyxzcXVhcmU6eHMsc3RlcDp3cyx0YW46YnMsdGFuaDpDcyxhbGw6YnUsYW55OkN1LGFyZ01heDpFdSxhcmdNaW46UnUsbG9nU3VtRXhwOlN1LG1heDpOdSxtZWFuOmt1LG1pbjpJdSxtb21lbnRzOkF1LHN1bTpUdSxwcm9kOkR1LGVxdWFsOk91LGVxdWFsU3RyaWN0Ol91LGdyZWF0ZXI6TXUsZ3JlYXRlckVxdWFsOkZ1LGdyZWF0ZXJFcXVhbFN0cmljdDpCdSxncmVhdGVyU3RyaWN0OlB1LGxlc3M6THUsbGVzc0VxdWFsOld1LGxlc3NFcXVhbFN0cmljdDpVdSxsZXNzU3RyaWN0Onp1LG5vdEVxdWFsOlZ1LG5vdEVxdWFsU3RyaWN0Okd1LGFkZDpxdSxhZGROOkh1LGFkZFN0cmljdDokdSxhdGFuMjpqdSxkaXY6S3UsZGl2U3RyaWN0Olh1LGZsb29yRGl2Oll1LG1heGltdW06UXUsbWF4aW11bVN0cmljdDpKdSxtaW5pbXVtOlp1LG1pbmltdW1TdHJpY3Q6dGwsbW9kOmVsLG1vZFN0cmljdDpubCxtdWw6cmwsbXVsU3RyaWN0Om9sLHBvdzphbCxwb3dTdHJpY3Q6aWwsc3F1YXJlZERpZmZlcmVuY2U6c2wsc3F1YXJlZERpZmZlcmVuY2VTdHJpY3Q6dWwsc3ViOmxsLHN1YlN0cmljdDpjbCxlbHU6Z2wsbGVha3lSZWx1OnlsLHByZWx1OnhsLHJlbHU6d2wsc2VsdTpibCxsb2dpY2FsQW5kOmhsLGxvZ2ljYWxOb3Q6cGwsbG9naWNhbE9yOmZsLGxvZ2ljYWxYb3I6ZGwsd2hlcmU6dmwsd2hlcmVBc3luYzptbCxidWZmZXI6TnIscHJpbnQ6a3IsYmF0Y2hUb1NwYWNlTkQ6SXIsY2FzdDpBcixjbG9uZTpUcixjdW1zdW06RHIsZGVwdGhUb1NwYWNlOk9yLGV4cGFuZERpbXM6X3IsZXllOk1yLG11bHRpbm9taWFsOkZyLG9uZUhvdDpCcixwYWQ6UHIscGFkMWQ6THIscGFkMmQ6V3IscGFkM2Q6VXIscGFkNGQ6enIscmFuZDpWcixyYW5kb21Ob3JtYWw6R3IscmFuZG9tVW5pZm9ybTpxcixyZXNoYXBlOkhyLHNwYWNlVG9CYXRjaE5EOiRyLHNxdWVlemU6anIsc3RhY2s6S3IsdGlsZTpYcix0cnVuY2F0ZWROb3JtYWw6WXIsdW5zdGFjazpRcixzZXRkaWZmMWRBc3luYzpKcixmaWxsOkhuLGxpbnNwYWNlOiRuLG9uZXM6R24scmFuZ2U6am4sc2NhbGFyOkJuLHRlbnNvcjpGbix0ZW5zb3IxZDpQbix0ZW5zb3IyZDpMbix0ZW5zb3IzZDpXbix0ZW5zb3I0ZDpVbix0ZW5zb3I1ZDp6bix0ZW5zb3I2ZDpWbix6ZXJvczpxbixvbmVzTGlrZTpLbix6ZXJvc0xpa2U6WG4sdHJhbnNwb3NlOkNsLHNvZnRtYXg6VG4sbG9nU29mdG1heDpEbixsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjpFbCxub3JtOlJsLGdhdGhlcjprbCx1bnNvcnRlZFNlZ21lbnRTdW06SWwsYmFzaWNMU1RNQ2VsbDpBbCxtdWx0aVJOTkNlbGw6VGwsbW92aW5nQXZlcmFnZTpEbCxzdHJpZGVkU2xpY2U6T2wsdG9wazpfbCxzY2F0dGVyTkQ6TWwsZmZ0OkZsLGlmZnQ6QmwscmZmdDpQbCxpcmZmdDpMbCxzcGFyc2VUb0RlbnNlOlVsLGdhdGhlck5EOnpsLGRyb3BvdXQ6VmwsaGFubldpbmRvdzpIbCxoYW1taW5nV2luZG93OiRsfSk7dmFyIGdjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMuYmxvY2tTaXplPTQ4LHRoaXMuZmlyc3RVc2U9ITAsYS5nZXQoXCJJU19CUk9XU0VSXCIpJiYodGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpKSx0aGlzLmRhdGE9bmV3IFluKER0KX1yZXR1cm4gdC5wcm90b3R5cGUucmVnaXN0ZXI9ZnVuY3Rpb24odCxlLG4pe2lmKHRoaXMuZmlyc3RVc2UmJih0aGlzLmZpcnN0VXNlPSExLGEuZ2V0KFwiSVNfTk9ERVwiKSYmamUoXCJcXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuSGkgdGhlcmUg8J+Riy4gTG9va3MgbGlrZSB5b3UgYXJlIHJ1bm5pbmcgVGVuc29yRmxvdy5qcyBpbiBOb2RlLmpzLiBUbyBzcGVlZCB0aGluZ3MgdXAgZHJhbWF0aWNhbGx5LCBpbnN0YWxsIG91ciBub2RlIGJhY2tlbmQsIHdoaWNoIGJpbmRzIHRvIFRlbnNvckZsb3cgQysrLCBieSBydW5uaW5nIG5wbSBpIEB0ZW5zb3JmbG93L3RmanMtbm9kZSwgb3IgbnBtIGkgQHRlbnNvcmZsb3cvdGZqcy1ub2RlLWdwdSBpZiB5b3UgaGF2ZSBDVURBLiBUaGVuIGNhbGwgcmVxdWlyZSgnQHRlbnNvcmZsb3cvdGZqcy1ub2RlJyk7ICgtZ3B1IHN1ZmZpeCBmb3IgQ1VEQSkgYXQgdGhlIHN0YXJ0IG9mIHlvdXIgcHJvZ3JhbS4gVmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGZqcy1ub2RlIGZvciBtb3JlIGRldGFpbHMuXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcblwiKSksdGhpcy5kYXRhLmhhcyh0KSl0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIGJ1ZmZlciBpcyBhbHJlYWR5IHJlZ2lzdGVyZWRcIik7dGhpcy5kYXRhLnNldCh0LHtkdHlwZTpufSl9LHQucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKHQsZSl7aWYobnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJNYXRoQmFja2VuZENQVS53cml0ZSgpOiB2YWx1ZXMgY2FuIG5vdCBiZSBudWxsXCIpO3RoaXMuZGF0YS5nZXQodCkudmFsdWVzPWV9LHQucHJvdG90eXBlLmZyb21QaXhlbHM9ZnVuY3Rpb24odCxlKXtpZihudWxsPT10KXRocm93IG5ldyBFcnJvcihcInBpeGVscyBwYXNzZWQgdG8gdGYuYnJvd3Nlci5mcm9tUGl4ZWxzKCkgY2FuIG5vdCBiZSBudWxsXCIpO3ZhciBuLHI7aWYoYS5nZXQoXCJJU19OT0RFXCIpJiZudWxsPT10LmdldENvbnRleHQpdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBydW5uaW5nIGluIG5vZGUsIHBpeGVscyBtdXN0IGJlIGFuIEhUTUxDYW52YXNFbGVtZW50IGxpa2UgdGhlIG9uZSByZXR1cm5lZCBieSB0aGUgYGNhbnZhc2AgbnBtIHBhY2thZ2VcIik7aWYobnVsbCE9dC5nZXRDb250ZXh0KW49dC5nZXRDb250ZXh0KFwiMmRcIikuZ2V0SW1hZ2VEYXRhKDAsMCx0LndpZHRoLHQuaGVpZ2h0KS5kYXRhO2Vsc2UgaWYodCBpbnN0YW5jZW9mIEltYWdlRGF0YSluPXQuZGF0YTtlbHNle2lmKCEodCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnR8fHQgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSl0aHJvdyBuZXcgRXJyb3IoXCJwaXhlbHMgcGFzc2VkIHRvIHRmLmJyb3dzZXIuZnJvbVBpeGVscygpIG11c3QgYmUgZWl0aGVyIGFuIEhUTUxWaWRlb0VsZW1lbnQsIEhUTUxJbWFnZUVsZW1lbnQsIEhUTUxDYW52YXNFbGVtZW50IG9yIEltYWdlRGF0YSwgYnV0IHdhcyBcIit0LmNvbnN0cnVjdG9yLm5hbWUpO2lmKG51bGw9PXRoaXMuZnJvbVBpeGVsczJEQ29udGV4dCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCByZWFkIHBpeGVscyBmcm9tIEhUTUxJbWFnZUVsZW1lbnQgb3V0c2lkZSB0aGUgYnJvd3Nlci5cIik7dGhpcy5mcm9tUGl4ZWxzMkRDb250ZXh0LmNhbnZhcy53aWR0aD10LndpZHRoLHRoaXMuZnJvbVBpeGVsczJEQ29udGV4dC5jYW52YXMuaGVpZ2h0PXQuaGVpZ2h0LHRoaXMuZnJvbVBpeGVsczJEQ29udGV4dC5kcmF3SW1hZ2UodCwwLDAsdC53aWR0aCx0LmhlaWdodCksbj10aGlzLmZyb21QaXhlbHMyRENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsMCx0LndpZHRoLHQuaGVpZ2h0KS5kYXRhfWlmKDQ9PT1lKXI9bmV3IEludDMyQXJyYXkobik7ZWxzZXt2YXIgbz10LndpZHRoKnQuaGVpZ2h0O3I9bmV3IEludDMyQXJyYXkobyplKTtmb3IodmFyIGk9MDtpPG87aSsrKWZvcih2YXIgcz0wO3M8ZTsrK3MpcltpKmUrc109bls0Kmkrc119cmV0dXJuIFduKHIsW3QuaGVpZ2h0LHQud2lkdGgsZV0sXCJpbnQzMlwiKX0sdC5wcm90b3R5cGUucmVhZD1mdW5jdGlvbih0KXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKGUpe3JldHVyblsyLHRoaXMucmVhZFN5bmModCldfSl9KX0sdC5wcm90b3R5cGUucmVhZFN5bmM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5kYXRhLmdldCh0KSxuPWUuZHR5cGUscj1lLmNvbXBsZXhUZW5zb3JzO3JldHVyblwiY29tcGxleDY0XCI9PT1uP2VyKHIucmVhbC5kYXRhU3luYygpLHIuaW1hZy5kYXRhU3luYygpKTp0aGlzLmRhdGEuZ2V0KHQpLnZhbHVlc30sdC5wcm90b3R5cGUuZGlzcG9zZURhdGE9ZnVuY3Rpb24odCl7aWYodGhpcy5kYXRhLmhhcyh0KSl7dmFyIGU9dGhpcy5kYXRhLmdldCh0KS5jb21wbGV4VGVuc29ycztudWxsIT1lJiYoZS5yZWFsLmRpc3Bvc2UoKSxlLmltYWcuZGlzcG9zZSgpKSx0aGlzLmRhdGEuZGVsZXRlKHQpfX0sdC5wcm90b3R5cGUudGltZT1mdW5jdGlvbih0KXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG4pe3JldHVybiBlPWooKSx0KCksWzIse2tlcm5lbE1zOmooKS1lfV19KX0pfSx0LnByb3RvdHlwZS5tZW1vcnk9ZnVuY3Rpb24oKXtyZXR1cm57dW5yZWxpYWJsZTohMCxyZWFzb25zOltcIlRoZSByZXBvcnRlZCBtZW1vcnkgaXMgYW4gdXBwZXIgYm91bmQuIER1ZSB0byBhdXRvbWF0aWMgZ2FyYmFnZSBjb2xsZWN0aW9uLCB0aGUgdHJ1ZSBhbGxvY2F0ZWQgbWVtb3J5IG1heSBiZSBsZXNzLlwiXX19LHQucHJvdG90eXBlLmNvbXBsZXg9ZnVuY3Rpb24odCxlKXt2YXIgbj1mdC5tYWtlKHQuc2hhcGUse30sXCJjb21wbGV4NjRcIik7cmV0dXJuIHRoaXMuZGF0YS5nZXQobi5kYXRhSWQpLmNvbXBsZXhUZW5zb3JzPXtyZWFsOkR0LmtlZXAodC5jbG9uZSgpKSxpbWFnOkR0LmtlZXAoZS5jbG9uZSgpKX0sbn0sdC5wcm90b3R5cGUucmVhbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kYXRhLmdldCh0LmRhdGFJZCkuY29tcGxleFRlbnNvcnMucmVhbC5jbG9uZSgpfSx0LnByb3RvdHlwZS5pbWFnPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRhdGEuZ2V0KHQuZGF0YUlkKS5jb21wbGV4VGVuc29ycy5pbWFnLmNsb25lKCl9LHQucHJvdG90eXBlLmFzc2VydE5vdENvbXBsZXg9ZnVuY3Rpb24odCxlKXtBcnJheS5pc0FycmF5KHQpfHwodD1bdF0pLHQuZm9yRWFjaChmdW5jdGlvbih0KXtudWxsIT10JiZkKFwiY29tcGxleDY0XCIhPT10LmR0eXBlLGZ1bmN0aW9uKCl7cmV0dXJuIGUrXCIgZG9lcyBub3Qgc3VwcG9ydCBjb21wbGV4NjQgdGVuc29ycy5cIn0pfSl9LHQucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInNsaWNlXCIpLG1uKHQuc2hhcGUsZSxuKSl7dmFyIHI9Z24oZSx0LnN0cmlkZXMpLG89eShuKTtyZXR1cm4gRm4odC5kYXRhU3luYygpLnN1YmFycmF5KHIscitvKSxuLHQuZHR5cGUpfWZvcih2YXIgYT1OcihuLHQuZHR5cGUpLGk9dC5idWZmZXJTeW5jKCkscz0wO3M8YS5zaXplOysrcyl7dmFyIHU9YS5pbmRleFRvTG9jKHMpLm1hcChmdW5jdGlvbih0LG4pe3JldHVybiB0K2Vbbl19KTthLnZhbHVlc1tzXT1pLmdldC5hcHBseShpLHUpfXJldHVybiBhLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLnN0cmlkZWRTbGljZT1mdW5jdGlvbih0LGUsbixyLG8sYSxpLHMsdSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJzdHJpZGVkU2xpY2VcIik7dmFyIGw9Zm4odC5zaGFwZSxlLG4scixvLGEsaSxzLHUpLGM9bFswXSxoPWxbMV0scD1sWzJdLGY9aC5maWx0ZXIoZnVuY3Rpb24odCxlKXtyZXR1cm4tMT09PXAuaW5kZXhPZihlKX0pO2lmKGYuc29tZShmdW5jdGlvbih0KXtyZXR1cm4gMD09PXR9KSlyZXR1cm4gRm4oW10sZik7Zm9yKHZhciBkPU5yKGgsdC5kdHlwZSksdj10LmJ1ZmZlclN5bmMoKSxtPTA7bTxkLnNpemU7bSsrKXtmb3IodmFyIGc9ZC5pbmRleFRvTG9jKG0pLHk9bmV3IEFycmF5KGcubGVuZ3RoKSx4PTA7eDx5Lmxlbmd0aDt4KyspeVt4XT1nW3hdKnJbeF0rY1t4XTtkLnNldC5hcHBseShkLFt2LmdldC5hcHBseSh2LHkpXS5jb25jYXQoZykpfXJldHVybiBkLnRvVGVuc29yKCkucmVzaGFwZShmKX0sdC5wcm90b3R5cGUudW5zdGFjaz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LnNoYXBlW2VdLHI9bmV3IEFycmF5KHQucmFuay0xKSxvPTAsYT0wO2E8dC5yYW5rO2ErKylhIT09ZSYmKHJbbysrXT10LnNoYXBlW2FdKTt2YXIgaT1uZXcgQXJyYXkodC5yYW5rKS5maWxsKDApLHM9dC5zaGFwZS5zbGljZSgpO3NbZV09MTt2YXIgdT1uZXcgQXJyYXkobik7Zm9yKGE9MDthPHUubGVuZ3RoO2ErKylpW2VdPWEsdVthXT10aGlzLnNsaWNlKHQsaSxzKS5yZXNoYXBlKHIpO3JldHVybiB1fSx0LnByb3RvdHlwZS5yZXZlcnNlPWZ1bmN0aW9uKHQsZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJyZXZlcnNlXCIpO2Zvcih2YXIgbj1Ocih0LnNoYXBlLHQuZHR5cGUpLHI9dC5idWZmZXJTeW5jKCksbz1mdW5jdGlvbihvKXt2YXIgYT1uLmluZGV4VG9Mb2MobyksaT1hLnNsaWNlKCk7ZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBpW2VdPXQuc2hhcGVbZV0tMS1pW2VdfSksbi5zZXQuYXBwbHkobixbci5nZXQuYXBwbHkocixpKV0uY29uY2F0KGEpKX0sYT0wO2E8bi5zaXplO2ErKylvKGEpO3JldHVybiBuLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLmNvbmNhdD1mdW5jdGlvbih0LGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiY29uY2F0XCIpO3ZhciBuPXQubWFwKGZ1bmN0aW9uKHQpe3ZhciBuPXkodC5zaGFwZS5zbGljZShlKSk7cmV0dXJuIHQuYXMyRCgtMSxuKX0pLHI9c24obi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSwxKSxvPU5yKHIsdFswXS5kdHlwZSkudmFsdWVzO2lmKDE9PT1uWzBdLnNoYXBlWzBdKXt2YXIgYT0wO24uZm9yRWFjaChmdW5jdGlvbih0KXtvLnNldCh0LmRhdGFTeW5jKCksYSksYSs9dC5zaXplfSl9ZWxzZXt2YXIgaT0wO24uZm9yRWFjaChmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5kYXRhU3luYygpLG49MCxhPTA7YTx0LnNoYXBlWzBdOysrYSlmb3IodmFyIHM9YSpyWzFdK2ksdT0wO3U8dC5zaGFwZVsxXTsrK3Upb1tzK3VdPWVbbisrXTtpKz10LnNoYXBlWzFdfSl9dmFyIHM9c24odC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSxlKTtyZXR1cm4gRm4obyxzLHRbMF0uZHR5cGUpfSx0LnByb3RvdHlwZS5uZWc9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwibmVnXCIpLHRoaXMubXVsdGlwbHkoQm4oLTEpLHQpfSx0LnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCxlKXtyZXR1cm5cImNvbXBsZXg2NFwiPT09dC5kdHlwZXx8XCJjb21wbGV4NjRcIj09PWUuZHR5cGU/dGhpcy5icm9hZGNhc3RlZEJpbmFyeUNvbXBsZXhPcCh0LmNhc3QoXCJjb21wbGV4NjRcIiksZS5jYXN0KFwiY29tcGxleDY0XCIpLGZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybntyZWFsOnQrbixpbWFnOmUrcn19KTp0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLEN0KHQuZHR5cGUsZS5kdHlwZSksZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtlfSl9LHQucHJvdG90eXBlLmFkZE49ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJhZGROXCIpO2Zvcih2YXIgZT10Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5kYXRhU3luYygpfSksbj1Ocih0WzBdLnNoYXBlLHRbMF0uZHR5cGUpLHI9bi52YWx1ZXMsbz0wO288dC5sZW5ndGg7bysrKWZvcih2YXIgYT1lW29dLGk9MDtpPHIubGVuZ3RoO2krKylyW2ldKz1hW2ldO3JldHVybiBuLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLnN1YnRyYWN0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJjb21wbGV4NjRcIj09PXQuZHR5cGV8fFwiY29tcGxleDY0XCI9PT1lLmR0eXBlP3RoaXMuYnJvYWRjYXN0ZWRCaW5hcnlDb21wbGV4T3AodC5jYXN0KFwiY29tcGxleDY0XCIpLGUuY2FzdChcImNvbXBsZXg2NFwiKSxmdW5jdGlvbih0LGUsbixyKXtyZXR1cm57cmVhbDp0LW4saW1hZzplLXJ9fSk6dGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxDdCh0LmR0eXBlLGUuZHR5cGUpLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQtZX0pfSx0LnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwicG93XCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsdC5kdHlwZSxmdW5jdGlvbih0LGUpe3JldHVybiBNYXRoLnBvdyh0LGUpfSl9LHQucHJvdG90eXBlLmJhdGNoTWF0TXVsPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcIm1hdE11bFwiKTtmb3IodmFyIG89bj90LnNoYXBlWzFdOnQuc2hhcGVbMl0sYT1uP3Quc2hhcGVbMl06dC5zaGFwZVsxXSxpPXI/ZS5zaGFwZVsxXTplLnNoYXBlWzJdLHM9dC5zaGFwZVswXSx1PXQuZGF0YVN5bmMoKSxsPWUuZGF0YVN5bmMoKSxjPW4/W3Quc3RyaWRlc1swXSwxLHQuc3RyaWRlc1sxXV06W3Quc3RyaWRlc1swXSx0LnN0cmlkZXNbMV0sMV0saD1jWzBdLHA9Y1sxXSxmPWNbMl0sZD1yP1sxLGUuc3RyaWRlc1sxXSxlLnN0cmlkZXNbMF1dOltlLnN0cmlkZXNbMV0sMSxlLnN0cmlkZXNbMF1dLHY9ZFswXSxtPWRbMV0sZz1kWzJdLHk9YSppLHg9TnIoW3MsYSxpXSx0LmR0eXBlKSx3PXgudmFsdWVzLGI9dGhpcy5ibG9ja1NpemUsQz0wO0M8cztDKyspZm9yKHZhciBFPTA7RTxhO0UrPWIpZm9yKHZhciBSPTA7UjxpO1IrPWIpZm9yKHZhciBTPTA7UzxvO1MrPWIpZm9yKHZhciBOPU1hdGgubWluKEUrYixhKSxrPU1hdGgubWluKFIrYixpKSxJPU1hdGgubWluKFMrYixvKSxBPUU7QTxOO0ErKylmb3IodmFyIFQ9UjtUPGs7VCsrKXtmb3IodmFyIEQ9MCxPPVM7TzxJO08rKylEKz11W0MqaCtBKnArTypmXSpsW08qditUKm0rQypnXTt3W0MqeSsoQSppK1QpXSs9RH1yZXR1cm4geC50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5mdXNlZEJhdGNoTWF0TXVsPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2YXIgaT10aGlzLmJhdGNoTWF0TXVsKHQsZSxuLHIpO3JldHVybiBvJiYoaT10aGlzLmFkZChpLG8pKSxhJiYoaT1mdW5jdGlvbih0LGUsbil7aWYoXCJsaW5lYXJcIj09PWUpcmV0dXJuIHQubGluZWFyKG4pO2lmKFwicmVsdVwiPT09ZSlyZXR1cm4gdC5yZWx1KG4pO3Rocm93IG5ldyBFcnJvcihcIkFjdGl2YXRpb24gXCIrZStcIiBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWQgZm9yIHRoZSBDUFUgYmFja2VuZC5cIil9KHRoaXMsYSxpKSksaX0sdC5wcm90b3R5cGUubXVsdGlwbHk9ZnVuY3Rpb24odCxlKXtyZXR1cm5cImNvbXBsZXg2NFwiPT09dC5kdHlwZXx8XCJjb21wbGV4NjRcIj09PWUuZHR5cGU/dGhpcy5icm9hZGNhc3RlZEJpbmFyeUNvbXBsZXhPcCh0LmNhc3QoXCJjb21wbGV4NjRcIiksZS5jYXN0KFwiY29tcGxleDY0XCIpLGZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybntyZWFsOnQqbi1lKnIsaW1hZzp0KnIrZSpufX0pOnRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsQ3QodC5kdHlwZSxlLmR0eXBlKSxmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KX0sdC5wcm90b3R5cGUucmVhbERpdmlkZT1mdW5jdGlvbih0LGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcInJlYWxEaXZpZGVcIik7cmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJmbG9hdDMyXCIsZnVuY3Rpb24odCxlKXtyZXR1cm4gdC9lfSl9LHQucHJvdG90eXBlLmZsb29yRGl2PWZ1bmN0aW9uKHQsZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwiZmxvb3JEaXZcIik7cmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJpbnQzMlwiLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIE1hdGguZmxvb3IodC9lKX0pfSx0LnByb3RvdHlwZS5zdW09ZnVuY3Rpb24odCxlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInN1bVwiKSxubihcInN1bVwiLGUsdC5yYW5rKTtmb3IodmFyIG49dG4odC5zaGFwZSxlKSxyPW5bMF0sbz1uWzFdLGE9cW4ocixDdCh0LmR0eXBlLFwiaW50MzJcIikpLGk9eShvKSxzPWEuZGF0YVN5bmMoKSx1PXQuZGF0YVN5bmMoKSxsPTA7bDxzLmxlbmd0aDsrK2wpe2Zvcih2YXIgYz1sKmksaD0wLHA9MDtwPGk7KytwKWgrPXVbYytwXTtzW2xdPWh9cmV0dXJuIGF9LHQucHJvdG90eXBlLnByb2Q9ZnVuY3Rpb24odCxlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInN1bVwiKTtmb3IodmFyIG49dG4odC5zaGFwZSxlKSxyPW5bMF0sbz1uWzFdLGE9cW4ocixDdCh0LmR0eXBlLFwiaW50MzJcIikpLGk9eShvKSxzPWEuZGF0YVN5bmMoKSx1PXQuZGF0YVN5bmMoKSxsPTA7bDxzLmxlbmd0aDsrK2wpe2Zvcih2YXIgYz1sKmksaD0xLHA9MDtwPGk7KytwKWgqPXVbYytwXTtzW2xdPWh9cmV0dXJuIGF9LHQucHJvdG90eXBlLnVuc29ydGVkU2VnbWVudFN1bT1mdW5jdGlvbih0LGUsbil7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJ1bnNvcnRlZFNlZ21lbnRTdW1cIik7Zm9yKHZhciByPVtdLG89dC5yYW5rLWUucmFuayxhPTA7YTxvOysrYSllPWUuZXhwYW5kRGltcyhhKzEpO2ZvcihhPTA7YTxuOysrYSl7dmFyIGk9Qm4oYSxcImludDMyXCIpLHM9T3UoaSxlKS5hc1R5cGUoXCJmbG9hdDMyXCIpLm11bCh0KS5zdW0oMCk7ci5wdXNoKHMpfXJldHVybiBLcihyKX0sdC5wcm90b3R5cGUuYXJnTWluPWZ1bmN0aW9uKHQsZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJhcmdNaW5cIik7dmFyIG49W2VdO25uKFwiYXJnTWluXCIsbix0LnJhbmspO2Zvcih2YXIgcj10bih0LnNoYXBlLG4pLG89clswXSxhPXJbMV0saT1xbihvLFwiaW50MzJcIikscz15KGEpLHU9aS5kYXRhU3luYygpLGw9dC5kYXRhU3luYygpLGM9MDtjPHUubGVuZ3RoOysrYyl7Zm9yKHZhciBoPWMqcyxwPWxbaF0sZj0wLGQ9MDtkPHM7KytkKXt2YXIgdj1sW2grZF07djxwJiYocD12LGY9ZCl9dVtjXT1mfXJldHVybiBpfSx0LnByb3RvdHlwZS5hcmdNYXg9ZnVuY3Rpb24odCxlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImFyZ01heFwiKTt2YXIgbj1bZV07bm4oXCJhcmdNYXhcIixuLHQucmFuayk7Zm9yKHZhciByPXRuKHQuc2hhcGUsbiksbz1yWzBdLGE9clsxXSxpPXFuKG8sXCJpbnQzMlwiKSxzPXkoYSksdT1pLmRhdGFTeW5jKCksbD10LmRhdGFTeW5jKCksYz0wO2M8dS5sZW5ndGg7KytjKXtmb3IodmFyIGg9YypzLHA9bFtoXSxmPTAsZD0wO2Q8czsrK2Qpe3ZhciB2PWxbaCtkXTt2PnAmJihwPXYsZj1kKX11W2NdPWZ9cmV0dXJuIGl9LHQucHJvdG90eXBlLmN1bXN1bT1mdW5jdGlvbih0LGUsbixyKXtpZih0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImN1bXN1bVwiKSxlIT09dC5yYW5rLTEpdGhyb3cgbmV3IEVycm9yKFwiYmFja2VuZC5jdW1zdW0gaW4gQ1BVIGV4cGVjdHMgYW4gaW5uZXItbW9zdCBheGlzPVwiKyh0LnJhbmstMSkrXCIgYnV0IGdvdCBheGlzPVwiK2UpO2Zvcih2YXIgbz1DdCh0LmR0eXBlLFwiaW50MzJcIiksYT1xbih0LnNoYXBlLG8pLGk9YS5kYXRhU3luYygpLHM9dC5kYXRhU3luYygpLHU9dC5zaGFwZVt0LnJhbmstMV0sbD1yP2Z1bmN0aW9uKHQsZSl7cmV0dXJuIHQrdS1lLTF9OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQrZX0sYz0wO2M8cy5sZW5ndGg7Yys9dSlmb3IodmFyIGg9MDtoPHU7aCsrKXt2YXIgcD1sKGMsaCk7aWYoMD09PWgpaVtwXT1uPzA6c1twXTtlbHNle3ZhciBmPWwoYyxoLTEpO2lbcF09bj9zW2ZdK2lbZl06c1twXStpW2ZdfX1yZXR1cm4gYX0sdC5wcm90b3R5cGUuZXF1YWw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwiZXF1YWxcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImJvb2xcIixmdW5jdGlvbih0LGUpe3JldHVybiB0PT09ZT8xOjB9KX0sdC5wcm90b3R5cGUubm90RXF1YWw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwibm90RXF1YWxcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImJvb2xcIixmdW5jdGlvbih0LGUpe3JldHVybiB0IT09ZT8xOjB9KX0sdC5wcm90b3R5cGUubGVzcz1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJsZXNzXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJib29sXCIsZnVuY3Rpb24odCxlKXtyZXR1cm4gdDxlPzE6MH0pfSx0LnByb3RvdHlwZS5sZXNzRXF1YWw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwibGVzc0VxdWFsXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJib29sXCIsZnVuY3Rpb24odCxlKXtyZXR1cm4gdDw9ZT8xOjB9KX0sdC5wcm90b3R5cGUuZ3JlYXRlcj1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJncmVhdGVyXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJib29sXCIsZnVuY3Rpb24odCxlKXtyZXR1cm4gdD5lPzE6MH0pfSx0LnByb3RvdHlwZS5ncmVhdGVyRXF1YWw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwiZ3JlYXRlckVxdWFsXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJib29sXCIsZnVuY3Rpb24odCxlKXtyZXR1cm4gdD49ZT8xOjB9KX0sdC5wcm90b3R5cGUubG9naWNhbE5vdD1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImxvZ2ljYWxOb3RcIik7Zm9yKHZhciBlPXQuZGF0YVN5bmMoKSxuPW5ldyBVaW50OEFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpbltyXT1lW3JdPzA6MTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6bn0sXCJib29sXCIpfSx0LnByb3RvdHlwZS5sb2dpY2FsQW5kPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcImxvZ2ljYWxBbmRcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImJvb2xcIixmdW5jdGlvbih0LGUpe3JldHVybiB0JiZlfSl9LHQucHJvdG90eXBlLmxvZ2ljYWxPcj1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJsb2dpY2FsT3JcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImJvb2xcIixmdW5jdGlvbih0LGUpe3JldHVybiB0fHxlfSl9LHQucHJvdG90eXBlLnNlbGVjdD1mdW5jdGlvbih0LGUsbil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGUsbl0sXCJzZWxlY3RcIik7Zm9yKHZhciByPXQuZGF0YVN5bmMoKSxvPWUuZGF0YVN5bmMoKSxhPW4uZGF0YVN5bmMoKSxpPXFuKGUuc2hhcGUsQ3QoZS5kdHlwZSxuLmR0eXBlKSkscz1pLmRhdGFTeW5jKCksdT0wLGw9MD09PXQucmFua3x8dC5yYW5rPjF8fDE9PT1lLnJhbms/MTplLnNoYXBlWzFdLGM9MDtjPHIubGVuZ3RoO2MrKylmb3IodmFyIGg9MDtoPGw7aCsrKTE9PT1yW2NdP3NbdSsrXT1vW2NdOnNbdSsrXT1hW2NdO3JldHVybiBpfSx0LnByb3RvdHlwZS53aGVyZT1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW3RdLFwid2hlcmVcIik7dmFyIGU9dC5kYXRhU3luYygpO3JldHVybiBacih0LnNoYXBlLGUpfSx0LnByb3RvdHlwZS50b3BrPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJ0b3BrXCIpLHVyKHQuZGF0YVN5bmMoKSx0LnNoYXBlLHQuZHR5cGUsZSl9LHQucHJvdG90eXBlLm1pbj1mdW5jdGlvbih0LGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwibWluXCIpLG5uKFwibWluXCIsZSx0LnJhbmspO2Zvcih2YXIgbj10bih0LnNoYXBlLGUpLHI9blswXSxvPW5bMV0sYT1xbihyLHQuZHR5cGUpLGk9eShvKSxzPWEuZGF0YVN5bmMoKSx1PXQuZGF0YVN5bmMoKSxsPTA7bDxzLmxlbmd0aDsrK2wpe2Zvcih2YXIgYz1sKmksaD11W2NdLHA9MDtwPGk7KytwKXt2YXIgZj11W2MrcF07ZjxoJiYoaD1mKX1zW2xdPWh9cmV0dXJuIGF9LHQucHJvdG90eXBlLm1pbmltdW09ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwibWluaW11bVwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLHQuZHR5cGUsZnVuY3Rpb24odCxlKXtyZXR1cm4gTWF0aC5taW4odCxlKX0pfSx0LnByb3RvdHlwZS5tb2Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwibW9kXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsdC5kdHlwZSxmdW5jdGlvbih0LGUpe3ZhciBuPXQlZTtyZXR1cm4gdDwwJiZlPDB8fHQ+PTAmJmU+PTA/bjoobitlKSVlfSl9LHQucHJvdG90eXBlLm1heD1mdW5jdGlvbih0LGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwibWF4XCIpLG5uKFwibWF4XCIsZSx0LnJhbmspO2Zvcih2YXIgbj10bih0LnNoYXBlLGUpLHI9blswXSxvPW5bMV0sYT1xbihyLHQuZHR5cGUpLGk9eShvKSxzPWEuZGF0YVN5bmMoKSx1PXQuZGF0YVN5bmMoKSxsPTA7bDxzLmxlbmd0aDsrK2wpe2Zvcih2YXIgYz1sKmksaD11W2NdLHA9MDtwPGk7KytwKXt2YXIgZj11W2MrcF07Zj5oJiYoaD1mKX1zW2xdPWh9cmV0dXJuIGF9LHQucHJvdG90eXBlLm1heGltdW09ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwibWF4aW11bVwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLHQuZHR5cGUsZnVuY3Rpb24odCxlKXtyZXR1cm4gTWF0aC5tYXgodCxlKX0pfSx0LnByb3RvdHlwZS5hbGw9ZnVuY3Rpb24odCxlKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImFsbFwiKSxubihcImFsbFwiLGUsdC5yYW5rKTtmb3IodmFyIG49dG4odC5zaGFwZSxlKSxyPW5bMF0sbz1uWzFdLGE9cW4ocix0LmR0eXBlKSxpPXkobykscz1hLmRhdGFTeW5jKCksdT10LmRhdGFTeW5jKCksbD0wO2w8cy5sZW5ndGg7KytsKXtmb3IodmFyIGM9bCppLGg9dVtjXSxwPTA7cDxpOysrcCl7dmFyIGY9dVtjK3BdO2g9aCYmZn1zW2xdPWh9cmV0dXJuIGF9LHQucHJvdG90eXBlLmFueT1mdW5jdGlvbih0LGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiYW55XCIpLG5uKFwiYW55XCIsZSx0LnJhbmspO2Zvcih2YXIgbj10bih0LnNoYXBlLGUpLHI9blswXSxvPW5bMV0sYT1xbihyLHQuZHR5cGUpLGk9eShvKSxzPWEuZGF0YVN5bmMoKSx1PXQuZGF0YVN5bmMoKSxsPTA7bDxzLmxlbmd0aDsrK2wpe2Zvcih2YXIgYz1sKmksaD11W2NdLHA9MDtwPGk7KytwKXt2YXIgZj11W2MrcF07aD1ofHxmfXNbbF09aH1yZXR1cm4gYX0sdC5wcm90b3R5cGUuc3F1YXJlZERpZmZlcmVuY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwic3F1YXJlZERpZmZlcmVuY2VcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSx0LmR0eXBlLGZ1bmN0aW9uKHQsZSl7dmFyIG49dC1lO3JldHVybiBuKm59KX0sdC5wcm90b3R5cGUuY2VpbD1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImNlaWxcIik7Zm9yKHZhciBlPXQuZGF0YVN5bmMoKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrciluW3JdPU1hdGguY2VpbChlW3JdKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6bn0pfSx0LnByb3RvdHlwZS5mbG9vcj1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImZsb29yXCIpO2Zvcih2YXIgZT10LmRhdGFTeW5jKCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpbltyXT1NYXRoLmZsb29yKGVbcl0pO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczpufSl9LHQucHJvdG90eXBlLnNpZ249ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJ4XCIpO2Zvcih2YXIgZT10LmRhdGFTeW5jKCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpZVtyXTwwP25bcl09LTE6ZVtyXT4wP25bcl09MTpuW3JdPTA7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOm59KX0sdC5wcm90b3R5cGUuaXNOYU49ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJ4XCIpO2Zvcih2YXIgZT10LmRhdGFTeW5jKCksbj1uZXcgVWludDhBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKU51bWJlci5pc05hTihlW3JdKSYmKG5bcl09MSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOm59LFwiYm9vbFwiKX0sdC5wcm90b3R5cGUuaXNJbmY9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJ4XCIpO2Zvcih2YXIgZT10LmRhdGFTeW5jKCksbj1uZXcgVWludDhBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKU1hdGguYWJzKGVbcl0pPT09MS8wJiYobltyXT0xKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6bn0sXCJib29sXCIpfSx0LnByb3RvdHlwZS5pc0Zpbml0ZT1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInhcIik7Zm9yKHZhciBlPXQuZGF0YVN5bmMoKSxuPW5ldyBVaW50OEFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpTnVtYmVyLmlzRmluaXRlKGVbcl0pJiYobltyXT0xKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6bn0sXCJib29sXCIpfSx0LnByb3RvdHlwZS5yb3VuZD1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInJvdW5kXCIpO2Zvcih2YXIgZT10LmRhdGFTeW5jKCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3Ipe3ZhciBvPU1hdGguZmxvb3IoZVtyXSk7ZVtyXS1vPC41P25bcl09TWF0aC5mbG9vcihlW3JdKTplW3JdLW8+LjU/bltyXT1NYXRoLmNlaWwoZVtyXSk6bltyXT1vJTI9PTA/bzpvKzF9cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOm59KX0sdC5wcm90b3R5cGUuZXhwPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiZXhwXCIpO2Zvcih2YXIgZT10LmRhdGFTeW5jKCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpbltyXT1NYXRoLmV4cChlW3JdKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6bn0pfSx0LnByb3RvdHlwZS5leHBtMT1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImV4cG0xXCIpO2Zvcih2YXIgZT10LmRhdGFTeW5jKCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpbltyXT1NYXRoLmV4cG0xKGVbcl0pO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczpufSl9LHQucHJvdG90eXBlLmxvZz1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImxvZ1wiKTtmb3IodmFyIGU9dC5kYXRhU3luYygpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKXt2YXIgbz1lW3JdO25bcl09TWF0aC5sb2cobyl9cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOm59KX0sdC5wcm90b3R5cGUubG9nMXA9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJsb2cxcFwiKTtmb3IodmFyIGU9dC5kYXRhU3luYygpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKXt2YXIgbz1lW3JdO25bcl09TWF0aC5sb2cxcChvKX1yZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6bn0pfSx0LnByb3RvdHlwZS5zcXJ0PWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwic3FydFwiKTtmb3IodmFyIGU9dC5kYXRhU3luYygpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKXt2YXIgbz1lW3JdO25bcl09TWF0aC5zcXJ0KG8pfXJldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczpufSl9LHQucHJvdG90eXBlLnJzcXJ0PWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwicnNxcnRcIik7Zm9yKHZhciBlPXQuZGF0YVN5bmMoKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcil7dmFyIG89ZVtyXTtuW3JdPTEvTWF0aC5zcXJ0KG8pfXJldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczpufSl9LHQucHJvdG90eXBlLnNxdWFyZT1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInNxdWFyZVwiKTtmb3IodmFyIGU9dC5kYXRhU3luYygpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKXt2YXIgbz1lW3JdO25bcl09bypvfXJldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczpufSl9LHQucHJvdG90eXBlLnJlY2lwcm9jYWw9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJyZWNpcHJvY2FsXCIpO2Zvcih2YXIgZT10LmRhdGFTeW5jKCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpbltyXT0xL2Vbcl07cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOm59KX0sdC5wcm90b3R5cGUubGluZWFyPWZ1bmN0aW9uKHQpe3JldHVybiB0fSx0LnByb3RvdHlwZS5yZWx1PWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwicmVsdVwiKTtmb3IodmFyIGU9cW4odC5zaGFwZSx0LmR0eXBlKSxuPWUuZGF0YVN5bmMoKSxyPXQuZGF0YVN5bmMoKSxvPTA7bzxyLmxlbmd0aDsrK28pbltvXT1NYXRoLm1heCgwLHJbb10pO3JldHVybiBlfSx0LnByb3RvdHlwZS5wcmVsdT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJwcmVsdVwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLHQuZHR5cGUsZnVuY3Rpb24odCxlKXtyZXR1cm4gdDwwP2UqdDp0fSl9LHQucHJvdG90eXBlLmVsdT1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImVsdVwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dC5kYXRhU3luYygpLHI9MDtyPG4ubGVuZ3RoOysrcil7dmFyIG89bltyXTtlW3JdPW8+PTA/bzpNYXRoLmV4cChvKS0xfXJldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLmVsdURlcj1mdW5jdGlvbih0LGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcImVsdURlclwiKTtmb3IodmFyIG49bmV3IEZsb2F0MzJBcnJheShlLnNpemUpLHI9ZS5kYXRhU3luYygpLG89dC5kYXRhU3luYygpLGE9MDthPHIubGVuZ3RoOysrYSl7dmFyIGk9clthXTtuW2FdPWk+PTE/b1thXTpvW2FdKihpKzEpfXJldHVybiBmdC5tYWtlKGUuc2hhcGUse3ZhbHVlczpufSl9LHQucHJvdG90eXBlLnNlbHU9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJzZWx1XCIpO2Zvcih2YXIgZT1iaSxuPUNpLHI9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG89dC5kYXRhU3luYygpLGE9MDthPG8ubGVuZ3RoOysrYSl7dmFyIGk9b1thXTtyW2FdPWk+PTA/bippOmUqKE1hdGguZXhwKGkpLTEpfXJldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczpyfSl9LHQucHJvdG90eXBlLmNsaXA9ZnVuY3Rpb24odCxlLG4pe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiY2xpcFwiKTtmb3IodmFyIHI9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG89dC5kYXRhU3luYygpLGE9MDthPG8ubGVuZ3RoOysrYSl7dmFyIGk9b1thXTtyW2FdPWk+bj9uOmk8ZT9lOml9cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOnJ9KX0sdC5wcm90b3R5cGUuYWJzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10LmRhdGFTeW5jKCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5hYnMobltyXSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOmV9KX0sdC5wcm90b3R5cGUuY29tcGxleEFicz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dC5kYXRhU3luYygpLHI9MDtyPHQuc2l6ZTsrK3Ipe3ZhciBvPW5bMipyXSxhPW5bMipyKzFdO2Vbcl09TWF0aC5oeXBvdChvLGEpfXJldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLmludD1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImludFwiKTtmb3IodmFyIGU9bmV3IEludDMyQXJyYXkodC5zaXplKSxuPXQuZGF0YVN5bmMoKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1uW3JdO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczplfSxcImludDMyXCIpfSx0LnByb3RvdHlwZS5zaWdtb2lkPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwic2lnbW9pZFwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dC5kYXRhU3luYygpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPTEvKDErTWF0aC5leHAoLW5bcl0pKTtyZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS5zb2Z0cGx1cz1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInNvZnRwbHVzXCIpO2Zvcih2YXIgZT1NYXRoLmxvZygxLjE5MjA5Mjg5NTUwNzgxMjVlLTcpKzIsbj1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSkscj10LmRhdGFTeW5jKCksbz0wO288ci5sZW5ndGg7KytvKXt2YXIgYT1yW29dPi1lLGk9cltvXTxlLHM9TWF0aC5leHAocltvXSksdT12b2lkIDA7dT1pP3M6YT9yW29dOk1hdGgubG9nKDErcyksbltvXT11fXJldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczpufSl9LHQucHJvdG90eXBlLnNpbj1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInNpblwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dC5kYXRhU3luYygpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguc2luKG5bcl0pO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLmNvcz1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImNvc1wiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dC5kYXRhU3luYygpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguY29zKG5bcl0pO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLnRhbj1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInRhblwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dC5kYXRhU3luYygpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGgudGFuKG5bcl0pO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLmFzaW49ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJhc2luXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10LmRhdGFTeW5jKCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5hc2luKG5bcl0pO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLmFjb3M9ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJhY29zXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10LmRhdGFTeW5jKCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5hY29zKG5bcl0pO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLmF0YW49ZnVuY3Rpb24odCl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJhdGFuXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10LmRhdGFTeW5jKCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5hdGFuKG5bcl0pO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLmF0YW4yPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcImF0YW4yXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsdC5kdHlwZSxmdW5jdGlvbih0LGUpe3JldHVybiBNYXRoLmF0YW4yKHQsZSl9KX0sdC5wcm90b3R5cGUuc2luaD1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInNpbmhcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXQuZGF0YVN5bmMoKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLnNpbmgobltyXSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOmV9KX0sdC5wcm90b3R5cGUuY29zaD1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImNvc2hcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXQuZGF0YVN5bmMoKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmNvc2gobltyXSk7cmV0dXJuIGZ0Lm1ha2UodC5zaGFwZSx7dmFsdWVzOmV9KX0sdC5wcm90b3R5cGUudGFuaD1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInRhbmhcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXQuZGF0YVN5bmMoKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1iKG5bcl0pO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLmFzaW5oPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiYXNpbmhcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXQuZGF0YVN5bmMoKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmFzaW5oKG5bcl0pO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLmFjb3NoPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiYWNvc2hcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXQuZGF0YVN5bmMoKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmFjb3NoKG5bcl0pO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLmF0YW5oPWZ1bmN0aW9uKHQpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwiYXRhbmhcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXQuZGF0YVN5bmMoKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmF0YW5oKG5bcl0pO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczplfSl9LHQucHJvdG90eXBlLmVyZj1mdW5jdGlvbih0KXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcImVyZlwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dC5kYXRhU3luYygpLHI9MDtyPG4ubGVuZ3RoOysrcil7dmFyIG89bltyXSxhPTEvKDErLjMyNzU5MTEqbyk7ZVtyXT0xLSgoKCgxLjA2MTQwNTQyOSphLTEuNDUzMTUyMDI3KSphKzEuNDIxNDEzNzQxKSphLS4yODQ0OTY3MzYpKmErLjI1NDgyOTU5MikqYSpNYXRoLmV4cCgtbypvKX1yZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6ZX0pfSx0LnByb3RvdHlwZS5zdGVwPWZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9MCksdGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJzdGVwXCIpO2Zvcih2YXIgbj1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSkscj10LmRhdGFTeW5jKCksbz0wO288ci5sZW5ndGg7KytvKXt2YXIgYT1yW29dO2lzTmFOKGEpP25bb109TmFOOm5bb109YT4wPzE6ZX1yZXR1cm4gZnQubWFrZSh0LnNoYXBlLHt2YWx1ZXM6bn0pfSx0LnByb3RvdHlwZS5jb252MmQ9ZnVuY3Rpb24odCxlLG4pe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbdCxlXSxcImNvbnYyZFwiKTtmb3IodmFyIHI9bi5maWx0ZXJIZWlnaHQsbz1uLmZpbHRlcldpZHRoLGE9bi5kaWxhdGlvbkhlaWdodCxpPW4uZGlsYXRpb25XaWR0aCxzPW4ucGFkSW5mby5sZWZ0LHU9bi5wYWRJbmZvLnRvcCxsPU5yKG4ub3V0U2hhcGUsdC5kdHlwZSksYz10LmRhdGFTeW5jKCksaD1lLmRhdGFTeW5jKCkscD1sLnZhbHVlcyxmPTA7ZjxuLmJhdGNoU2l6ZTsrK2YpZm9yKHZhciBkPWYqdC5zdHJpZGVzWzBdLHY9ZipsLnN0cmlkZXNbMF0sbT0wO208bi5vdXRIZWlnaHQ7KyttKWZvcih2YXIgZz12K20qbC5zdHJpZGVzWzFdLHk9bSpuLnN0cmlkZUhlaWdodC1zLHg9MDt4PHI7eCsrKXt2YXIgdz15K3gqYTtpZighKHc8MHx8dz49bi5pbkhlaWdodCkpZm9yKHZhciBiPXgqZS5zdHJpZGVzWzBdLEM9ZCt3KnQuc3RyaWRlc1sxXSxFPTA7RTxuLm91dFdpZHRoOysrRSlmb3IodmFyIFI9ZytFKm4ub3V0Q2hhbm5lbHMsUz1FKm4uc3RyaWRlV2lkdGgtdSxOPTA7TjxvO04rKyl7dmFyIGs9UytOKmk7aWYoIShrPDB8fGs+PW4uaW5XaWR0aCkpZm9yKHZhciBJPWIrTiplLnN0cmlkZXNbMV0sQT1DK2sqbi5pbkNoYW5uZWxzLFQ9SSxEPTA7RDxuLmluQ2hhbm5lbHM7KytEKXtmb3IodmFyIE89Y1tBK0RdLF89MDtfPG4ub3V0Q2hhbm5lbHM7KytfKXBbUitfXSs9TypoW1QrX107VCs9bi5vdXRDaGFubmVsc319fXJldHVybiBsLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLmNvbnYzZD1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPW4uZmlsdGVyRGVwdGgsbz1uLmZpbHRlckhlaWdodCxhPW4uZmlsdGVyV2lkdGgsaT1uLmRpbGF0aW9uRGVwdGgscz1uLmRpbGF0aW9uSGVpZ2h0LHU9bi5kaWxhdGlvbldpZHRoLGw9bi5wYWRJbmZvLmZyb250LGM9bi5wYWRJbmZvLmxlZnQsaD1uLnBhZEluZm8udG9wLHA9TnIobi5vdXRTaGFwZSx0LmR0eXBlKSxmPXQuZGF0YVN5bmMoKSxkPWUuZGF0YVN5bmMoKSx2PXAudmFsdWVzLG09MDttPG4uYmF0Y2hTaXplOysrbSlmb3IodmFyIGc9bSp0LnN0cmlkZXNbMF0seT1tKnAuc3RyaWRlc1swXSx4PTA7eDxuLm91dERlcHRoOysreClmb3IodmFyIHc9eSt4KnAuc3RyaWRlc1sxXSxiPXgqbi5zdHJpZGVEZXB0aC1sLEM9MDtDPHI7QysrKXt2YXIgRT1iK0MqaTtpZighKEU8MHx8RT49bi5pbkRlcHRoKSlmb3IodmFyIFI9QyplLnN0cmlkZXNbMF0sUz1nK0UqdC5zdHJpZGVzWzFdLE49MDtOPG4ub3V0SGVpZ2h0OysrTilmb3IodmFyIGs9dytOKnAuc3RyaWRlc1syXSxJPU4qbi5zdHJpZGVIZWlnaHQtaCxBPTA7QTxvO0ErKyl7dmFyIFQ9SStBKnM7aWYoIShUPDB8fFQ+PW4uaW5IZWlnaHQpKWZvcih2YXIgRD1SK0EqZS5zdHJpZGVzWzFdLE89UytUKnQuc3RyaWRlc1syXSxfPTA7XzxuLm91dFdpZHRoOysrXylmb3IodmFyIE09aytfKm4ub3V0Q2hhbm5lbHMsRj1fKm4uc3RyaWRlV2lkdGgtYyxCPTA7QjxhO0IrKyl7dmFyIFA9RitCKnU7aWYoIShQPDB8fFA+PW4uaW5XaWR0aCkpZm9yKHZhciBMPUQrQiplLnN0cmlkZXNbMl0sVz1PK1Aqbi5pbkNoYW5uZWxzLFU9TCx6PTA7ejxuLmluQ2hhbm5lbHM7Kyt6KXtmb3IodmFyIFY9ZltXK3pdLEc9MDtHPG4ub3V0Q2hhbm5lbHM7KytHKXZbTStHXSs9VipkW1UrR107VSs9bi5vdXRDaGFubmVsc319fX1yZXR1cm4gcC50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5jb252MmREZXJJbnB1dD1mdW5jdGlvbih0LGUsbil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwiY29udjJkRGVySW5wdXRcIik7Zm9yKHZhciByPU5yKG4uaW5TaGFwZSxcImZsb2F0MzJcIiksbz1yLnZhbHVlcyxhPXIuc3RyaWRlcyxpPWFbMF0scz1hWzFdLHU9YVsyXSxsPXQuZGF0YVN5bmMoKSxjPXQuc3RyaWRlcyxoPWNbMF0scD1jWzFdLGY9Y1syXSxkPWUuZGF0YVN5bmMoKSx2PWUuc3RyaWRlcyxtPXZbMF0sZz12WzFdLHk9dlsyXSx4PW4uYmF0Y2hTaXplLHc9bi5maWx0ZXJIZWlnaHQsYj1uLmZpbHRlcldpZHRoLEM9bi5pbkNoYW5uZWxzLEU9bi5pbkhlaWdodCxSPW4uaW5XaWR0aCxTPW4ub3V0Q2hhbm5lbHMsTj1uLm91dEhlaWdodCxrPW4ub3V0V2lkdGgsST1uLnN0cmlkZUhlaWdodCxBPW4uc3RyaWRlV2lkdGgsVD13LTEtbi5wYWRJbmZvLnRvcCxEPWItMS1uLnBhZEluZm8ubGVmdCxPPTA7Tzx4OysrTylmb3IodmFyIF89MDtfPEM7KytfKWZvcih2YXIgTT0wO008RTsrK00pZm9yKHZhciBGPU0tVCxCPU1hdGgubWF4KDAsTWF0aC5jZWlsKEYvSSkpLFA9TWF0aC5taW4oTiwodytGKS9JKSxMPTA7TDxSOysrTCl7Zm9yKHZhciBXPUwtRCxVPU1hdGgubWF4KDAsTWF0aC5jZWlsKFcvQSkpLHo9TWF0aC5taW4oaywoYitXKS9BKSxWPTAsRz1CO0c8UDsrK0cpZm9yKHZhciBxPUcqSS1GLEg9VTtIPHo7KytIKWZvcih2YXIgJD1oKk8rcCpHK2YqSCxqPW0qKHctMS1xKStnKihiLTEtKEgqQS1XKSkreSpfLEs9MDtLPFM7KytLKXtWKz1sWyQrS10qZFtqK0tdfW9baSpPK3MqTSt1KkwrX109Vn1yZXR1cm4gci50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5jb252M2REZXJJbnB1dD1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPU5yKG4uaW5TaGFwZSxcImZsb2F0MzJcIiksbz1yLnZhbHVlcyxhPXIuc3RyaWRlcyxpPWFbMF0scz1hWzFdLHU9YVsyXSxsPWFbM10sYz10LmRhdGFTeW5jKCksaD10LnN0cmlkZXMscD1oWzBdLGY9aFsxXSxkPWhbMl0sdj1oWzNdLG09ZS5kYXRhU3luYygpLGc9ZS5zdHJpZGVzLHk9Z1swXSx4PWdbMV0sdz1nWzJdLGI9Z1szXSxDPW4uYmF0Y2hTaXplLEU9bi5maWx0ZXJEZXB0aCxSPW4uZmlsdGVySGVpZ2h0LFM9bi5maWx0ZXJXaWR0aCxOPW4uaW5DaGFubmVscyxrPW4uaW5EZXB0aCxJPW4uaW5IZWlnaHQsQT1uLmluV2lkdGgsVD1uLm91dENoYW5uZWxzLEQ9bi5vdXREZXB0aCxPPW4ub3V0SGVpZ2h0LF89bi5vdXRXaWR0aCxNPW4uc3RyaWRlRGVwdGgsRj1uLnN0cmlkZUhlaWdodCxCPW4uc3RyaWRlV2lkdGgsUD1FLTEtbi5wYWRJbmZvLmZyb250LEw9Ui0xLW4ucGFkSW5mby50b3AsVz1TLTEtbi5wYWRJbmZvLmxlZnQsVT0wO1U8QzsrK1UpZm9yKHZhciB6PTA7ejxOOysreilmb3IodmFyIFY9MDtWPGs7KytWKWZvcih2YXIgRz1WLVAscT1NYXRoLm1heCgwLE1hdGguY2VpbChHL00pKSxIPU1hdGgubWluKEQsKEUrRykvTSksJD0wOyQ8STsrKyQpZm9yKHZhciBqPSQtTCxLPU1hdGgubWF4KDAsTWF0aC5jZWlsKGovRikpLFg9TWF0aC5taW4oTywoUitqKS9GKSxZPTA7WTxBOysrWSl7Zm9yKHZhciBRPVktVyxKPU1hdGgubWF4KDAsTWF0aC5jZWlsKFEvQikpLFo9TWF0aC5taW4oXywoUytRKS9CKSx0dD0wLGV0PXE7ZXQ8SDsrK2V0KWZvcih2YXIgbnQ9ZXQqTS1HLHJ0PUs7cnQ8WDsrK3J0KWZvcih2YXIgb3Q9cnQqRi1qLGF0PUo7YXQ8WjsrK2F0KWZvcih2YXIgaXQ9cCpVK2YqZXQrZCpydCt2KmF0LHN0PXkqKEUtMS1udCkreCooUi0xLW90KSt3KihTLTEtKGF0KkItUSkpK2Iqeix1dD0wO3V0PFQ7Kyt1dCl7dHQrPWNbaXQrdXRdKm1bc3QrdXRdfW9baSpVK3MqVit1KiQrbCpZK3pdPXR0fXJldHVybiByLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLmNvbnYyZERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwiY29udjJkRGVyRmlsdGVyXCIpO2Zvcih2YXIgcj1uLnN0cmlkZUhlaWdodCxvPW4uc3RyaWRlV2lkdGgsYT1uLmZpbHRlckhlaWdodCxpPW4uZmlsdGVyV2lkdGgscz1OcihuLmZpbHRlclNoYXBlLFwiZmxvYXQzMlwiKSx1PW4ucGFkSW5mby5sZWZ0LGw9bi5wYWRJbmZvLnRvcCxjPXQuYnVmZmVyU3luYygpLGg9ZS5idWZmZXJTeW5jKCkscD0wO3A8YTsrK3ApZm9yKHZhciBmPU1hdGgubWF4KDAsTWF0aC5jZWlsKChsLXApL3IpKSxkPU1hdGgubWluKG4ub3V0SGVpZ2h0LChuLmluSGVpZ2h0K2wtcCkvciksdj0wO3Y8aTsrK3YpZm9yKHZhciBtPU1hdGgubWF4KDAsTWF0aC5jZWlsKCh1LXYpL28pKSxnPU1hdGgubWluKG4ub3V0V2lkdGgsKG4uaW5XaWR0aCt1LXYpL28pLHk9MDt5PG4uaW5DaGFubmVsczsrK3kpZm9yKHZhciB4PTA7eDxuLm91dENoYW5uZWxzOysreCl7Zm9yKHZhciB3PTAsYj0wO2I8bi5iYXRjaFNpemU7KytiKWZvcih2YXIgQz1mO0M8ZDsrK0MpZm9yKHZhciBFPXArQypyLWwsUj1tO1I8ZzsrK1Ipe3ZhciBTPXYrUipvLXU7dys9Yy5nZXQoYixFLFMseSkqaC5nZXQoYixDLFIseCl9cy5zZXQodyxwLHYseSx4KX1yZXR1cm4gcy50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5jb252M2REZXJGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj1uLnN0cmlkZURlcHRoLG89bi5zdHJpZGVIZWlnaHQsYT1uLnN0cmlkZVdpZHRoLGk9bi5maWx0ZXJEZXB0aCxzPW4uZmlsdGVySGVpZ2h0LHU9bi5maWx0ZXJXaWR0aCxsPU5yKG4uZmlsdGVyU2hhcGUsXCJmbG9hdDMyXCIpLGM9bC52YWx1ZXMsaD1sLnN0cmlkZXMscD1oWzBdLGY9aFsxXSxkPWhbMl0sdj1oWzNdLG09ZS5kYXRhU3luYygpLGc9ZS5zdHJpZGVzLHk9Z1swXSx4PWdbMV0sdz1nWzJdLGI9Z1szXSxDPXQuZGF0YVN5bmMoKSxFPXQuc3RyaWRlcyxSPUVbMF0sUz1FWzFdLE49RVsyXSxrPUVbM10sST1uLnBhZEluZm8uZnJvbnQsQT1uLnBhZEluZm8ubGVmdCxUPW4ucGFkSW5mby50b3AsRD0wO0Q8aTsrK0QpZm9yKHZhciBPPU1hdGgubWF4KDAsTWF0aC5jZWlsKChJLUQpL3IpKSxfPU1hdGgubWluKG4ub3V0RGVwdGgsKG4uaW5EZXB0aCtJLUQpL3IpLE09RCpwLEY9MDtGPHM7KytGKWZvcih2YXIgQj1NYXRoLm1heCgwLE1hdGguY2VpbCgoVC1GKS9vKSksUD1NYXRoLm1pbihuLm91dEhlaWdodCwobi5pbkhlaWdodCtULUYpL28pLEw9RipmK00sVz0wO1c8dTsrK1cpZm9yKHZhciBVPU1hdGgubWF4KDAsTWF0aC5jZWlsKChBLVcpL2EpKSx6PU1hdGgubWluKG4ub3V0V2lkdGgsKG4uaW5XaWR0aCtBLVcpL2EpLFY9VypkK0wsRz0wO0c8bi5pbkNoYW5uZWxzOysrRylmb3IodmFyIHE9Ryp2K1YsSD0wO0g8bi5vdXRDaGFubmVsczsrK0gpe2Zvcih2YXIgJD0wLGo9MDtqPG4uYmF0Y2hTaXplOysrailmb3IodmFyIEs9aipSLFg9aip5LFk9TztZPF87KytZKWZvcih2YXIgUT0oRCtZKnItSSkqUytLLEo9WSp4K1gsWj1CO1o8UDsrK1opZm9yKHZhciB0dD0oRitaKm8tVCkqTitRLGV0PVoqdytKLG50PVU7bnQ8ejsrK250KXt2YXIgcnQ9bnQqYitldDskKz1DWyhXK250KmEtQSkqayt0dCtHXSptW3J0K0hdfWNbcStIXT0kfXJldHVybiBsLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRD1mdW5jdGlvbih0LGUsbil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwiZGVwdGh3aXNlQ29udjJEXCIpO2Zvcih2YXIgcj1uLmZpbHRlckhlaWdodCxvPW4uZmlsdGVyV2lkdGgsYT1uLmRpbGF0aW9uSGVpZ2h0LGk9bi5kaWxhdGlvbldpZHRoLHM9bi5wYWRJbmZvLmxlZnQsdT1uLnBhZEluZm8udG9wLGw9bi5vdXRDaGFubmVscy9uLmluQ2hhbm5lbHMsYz1OcihuLm91dFNoYXBlLHQuZHR5cGUpLGg9dC5kYXRhU3luYygpLHA9ZS5kYXRhU3luYygpLGY9Yy52YWx1ZXMsZD0wO2Q8bi5iYXRjaFNpemU7KytkKWZvcih2YXIgdj1kKnQuc3RyaWRlc1swXSxtPWQqYy5zdHJpZGVzWzBdLGc9MDtnPG4ub3V0SGVpZ2h0OysrZylmb3IodmFyIHk9bStnKmMuc3RyaWRlc1sxXSx4PWcqbi5zdHJpZGVIZWlnaHQtcyx3PTA7dzxyOysrdyl7dmFyIGI9eCt3KmE7aWYoIShiPDB8fGI+PW4uaW5IZWlnaHQpKWZvcih2YXIgQz13KmUuc3RyaWRlc1swXSxFPXYrYip0LnN0cmlkZXNbMV0sUj0wO1I8bi5vdXRXaWR0aDsrK1IpZm9yKHZhciBTPXkrUipjLnN0cmlkZXNbMl0sTj1SKm4uc3RyaWRlV2lkdGgtdSxrPTA7azxvOysrayl7dmFyIEk9TitrKmk7aWYoIShJPDB8fEk+PW4uaW5XaWR0aCkpZm9yKHZhciBBPUMrayplLnN0cmlkZXNbMV0sVD1FK0kqbi5pbkNoYW5uZWxzLEQ9UyxPPUEsXz0wO188bi5pbkNoYW5uZWxzOysrXyl7Zm9yKHZhciBNPWhbVCtfXSxGPTA7RjxsOysrRilmW0QrRl0rPU0qcFtPK0ZdO0QrPWwsTys9bH19fXJldHVybiBjLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRERlcklucHV0PWZ1bmN0aW9uKHQsZSxuKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW3QsZV0sXCJkZXB0aHdpc2VDb252MkREZXJJbnB1dFwiKTtmb3IodmFyIHI9TnIobi5pblNoYXBlLFwiZmxvYXQzMlwiKSxvPXIudmFsdWVzLGE9ci5zdHJpZGVzLGk9YVswXSxzPWFbMV0sdT1hWzJdLGw9dC5kYXRhU3luYygpLGM9dC5zdHJpZGVzLGg9Y1swXSxwPWNbMV0sZj1jWzJdLGQ9ZS5kYXRhU3luYygpLHY9ZS5zdHJpZGVzLG09dlswXSxnPXZbMV0seT12WzJdLHg9bi5iYXRjaFNpemUsdz1uLmZpbHRlckhlaWdodCxiPW4uZmlsdGVyV2lkdGgsQz1uLmluQ2hhbm5lbHMsRT1uLmluSGVpZ2h0LFI9bi5pbldpZHRoLFM9bi5vdXRDaGFubmVscyxOPW4ub3V0SGVpZ2h0LGs9bi5vdXRXaWR0aCxJPW4uc3RyaWRlSGVpZ2h0LEE9bi5zdHJpZGVXaWR0aCxUPXctMS1uLnBhZEluZm8udG9wLEQ9Yi0xLW4ucGFkSW5mby5sZWZ0LE89Uy9DLF89MDtfPHg7KytfKWZvcih2YXIgTT0wO008QzsrK00pZm9yKHZhciBGPTA7RjxFOysrRilmb3IodmFyIEI9Ri1ULFA9TWF0aC5tYXgoMCxNYXRoLmNlaWwoQi9JKSksTD1NYXRoLm1pbihOLCh3K0IpL0kpLFc9MDtXPFI7KytXKXtmb3IodmFyIFU9Vy1ELHo9TWF0aC5tYXgoMCxNYXRoLmNlaWwoVS9BKSksVj1NYXRoLm1pbihrLChiK1UpL0EpLEc9MCxxPVA7cTxMOysrcSlmb3IodmFyIEg9cSpJLUIsJD16OyQ8VjsrKyQpZm9yKHZhciBqPWgqXytwKnErZiokLEs9bSoody0xLUgpK2cqKGItMS0oJCpBLVUpKSt5Kk0sWD0wO1g8TzsrK1gpe0crPWxbaisoTSpPK1gpXSpkW0srWF19b1tpKl8rcypGK3UqVytNXT1HfXJldHVybiByLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwiZGVwdGh3aXNlQ29udjJERGVyRmlsdGVyXCIpO2Zvcih2YXIgcj1uLnN0cmlkZUhlaWdodCxvPW4uc3RyaWRlV2lkdGgsYT1uLmZpbHRlckhlaWdodCxpPW4uZmlsdGVyV2lkdGgscz1OcihuLmZpbHRlclNoYXBlLFwiZmxvYXQzMlwiKSx1PW4ucGFkSW5mby5sZWZ0LGw9bi5wYWRJbmZvLnRvcCxjPW4ub3V0Q2hhbm5lbHMvbi5pbkNoYW5uZWxzLGg9dC5idWZmZXJTeW5jKCkscD1lLmJ1ZmZlclN5bmMoKSxmPTA7ZjxhOysrZilmb3IodmFyIGQ9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKGwtZikvcikpLHY9TWF0aC5taW4obi5vdXRIZWlnaHQsKG4uaW5IZWlnaHQrbC1mKS9yKSxtPTA7bTxpOysrbSlmb3IodmFyIGc9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKHUtbSkvbykpLHk9TWF0aC5taW4obi5vdXRXaWR0aCwobi5pbldpZHRoK3UtbSkvbykseD0wO3g8bi5vdXRDaGFubmVsczsrK3gpe2Zvcih2YXIgdz1NYXRoLnRydW5jKHgvYyksYj14JWMsQz0wLEU9MDtFPG4uYmF0Y2hTaXplOysrRSlmb3IodmFyIFI9ZDtSPHY7KytSKWZvcih2YXIgUz1mK1Iqci1sLE49ZztOPHk7KytOKXt2YXIgaz1tK04qby11O0MrPWguZ2V0KEUsUyxrLHcpKnAuZ2V0KEUsUixOLHgpfXMuc2V0KEMsZixtLHcsYil9cmV0dXJuIHMudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUudGlsZT1mdW5jdGlvbih0LGUpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwidGlsZVwiKTtmb3IodmFyIG49bmV3IEFycmF5KHQucmFuaykscj0wO3I8bi5sZW5ndGg7cisrKW5bcl09dC5zaGFwZVtyXSplW3JdO3ZhciBvPU5yKG4sdC5kdHlwZSksYT10LmJ1ZmZlclN5bmMoKTtmb3Iocj0wO3I8by52YWx1ZXMubGVuZ3RoOysrcil7Zm9yKHZhciBpPW8uaW5kZXhUb0xvYyhyKSxzPW5ldyBBcnJheSh0LnJhbmspLHU9MDt1PHMubGVuZ3RoO3UrKylzW3VdPWlbdV0ldC5zaGFwZVt1XTt2YXIgbD1hLmxvY1RvSW5kZXgocyk7by52YWx1ZXNbcl09YS52YWx1ZXNbbF19cmV0dXJuIG8udG9UZW5zb3IoKX0sdC5wcm90b3R5cGUucGFkPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInBhZFwiKTt2YXIgcj1lLm1hcChmdW5jdGlvbihlLG4pe3JldHVybiBlWzBdK3Quc2hhcGVbbl0rZVsxXX0pLG89ZS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHRbMF19KSxhPXQuYnVmZmVyU3luYygpLGk9TnIocix0LmR0eXBlKTswIT09biYmaS52YWx1ZXMuZmlsbChuKTtmb3IodmFyIHM9MDtzPHQuc2l6ZTtzKyspe3ZhciB1PWEuaW5kZXhUb0xvYyhzKSxsPXUubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQrb1tlXX0pO2kuc2V0LmFwcGx5KGksW2EuZ2V0LmFwcGx5KGEsdSldLmNvbmNhdChsKSl9cmV0dXJuIGkudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUudHJhbnNwb3NlPWZ1bmN0aW9uKHQsZSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJ0cmFuc3Bvc2VcIik7Zm9yKHZhciBuPW5ldyBBcnJheSh0LnJhbmspLHI9MDtyPG4ubGVuZ3RoO3IrKyluW3JdPXQuc2hhcGVbZVtyXV07dmFyIG89dC5kYXRhU3luYygpLGE9TnIobix0LmR0eXBlKSxpPXQuYnVmZmVyU3luYygpO2ZvcihyPTA7cjx0LnNpemU7KytyKXtmb3IodmFyIHM9aS5pbmRleFRvTG9jKHIpLHU9bmV3IEFycmF5KHMubGVuZ3RoKSxsPTA7bDx1Lmxlbmd0aDtsKyspdVtsXT1zW2VbbF1dO3ZhciBjPWEubG9jVG9JbmRleCh1KTthLnZhbHVlc1tjXT1vW3JdfXJldHVybiBhLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLmdhdGhlcj1mdW5jdGlvbih0LGUsbil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwiZ2F0aGVyXCIpO3ZhciByPXQuc2hhcGUuc2xpY2UoKSxvPWUuZGF0YVN5bmMoKTtyW25dPW8ubGVuZ3RoO2Zvcih2YXIgYT1OcihyLHQuZHR5cGUpLGk9dC5idWZmZXJTeW5jKCkscz0wO3M8YS5zaXplOysrcyl7dmFyIHU9YS5pbmRleFRvTG9jKHMpLGw9dS5zbGljZSgpO2xbbl09b1t1W25dXTt2YXIgYz1pLmxvY1RvSW5kZXgobCk7YS52YWx1ZXNbc109aS52YWx1ZXNbY119cmV0dXJuIGEudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUuYmF0Y2hUb1NwYWNlTkQ9ZnVuY3Rpb24odCxlLG4pe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbdF0sXCJiYXRjaFRvU3BhY2VORFwiKTt2YXIgcj1lLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSxvPUtlKHQuc2hhcGUsZSxyKSxhPVhlKG8ubGVuZ3RoLGUubGVuZ3RoKSxpPVllKHQuc2hhcGUsZSxyKSxzPVFlKG4sZS5sZW5ndGgpLHU9SmUoaSxuLGUubGVuZ3RoKTtyZXR1cm4gdC5yZXNoYXBlKG8pLnRyYW5zcG9zZShhKS5yZXNoYXBlKGkpLnNsaWNlKHMsdSl9LHQucHJvdG90eXBlLnNwYWNlVG9CYXRjaE5EPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLmFzc2VydE5vdENvbXBsZXgoW3RdLFwic3BhY2VUb0JhdGNoTkRcIik7dmFyIHI9ZS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSksbz1bWzAsMF1dO28ucHVzaC5hcHBseShvLG4pO2Zvcih2YXIgYT0xK2UubGVuZ3RoO2E8dC5zaGFwZS5sZW5ndGg7KythKW8ucHVzaChbMCwwXSk7dmFyIGk9dC5wYWQobykscz1LZShpLnNoYXBlLGUsciwhMSksdT1YZShzLmxlbmd0aCxlLmxlbmd0aCwhMSksbD1ZZShpLnNoYXBlLGUsciwhMSk7cmV0dXJuIGkucmVzaGFwZShzKS50cmFuc3Bvc2UodSkucmVzaGFwZShsKX0sdC5wcm90b3R5cGUucG9vbD1mdW5jdGlvbih0LGUsbil7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJwb29sXCIpO2Zvcih2YXIgcj1lLnN0cmlkZUhlaWdodCxvPWUuc3RyaWRlV2lkdGgsYT1lLmRpbGF0aW9uSGVpZ2h0LGk9ZS5kaWxhdGlvbldpZHRoLHM9ZS5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsdT1lLmVmZmVjdGl2ZUZpbHRlcldpZHRoLGw9ZS5wYWRJbmZvLnRvcCxjPWUucGFkSW5mby5sZWZ0LGg9XCJtYXhcIj09PW4/TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZOk51bWJlci5QT1NJVElWRV9JTkZJTklUWSxwPXQuZGF0YVN5bmMoKSxmPU5yKGUub3V0U2hhcGUsdC5kdHlwZSksZD1mLnZhbHVlcyx2PWUub3V0U2hhcGVbMV0qZS5vdXRTaGFwZVsyXSplLm91dFNoYXBlWzNdLG09ZS5vdXRTaGFwZVsyXSplLm91dFNoYXBlWzNdLGc9ZS5vdXRTaGFwZVszXSx5PTA7eTxlLmJhdGNoU2l6ZTsrK3kpZm9yKHZhciB4PXkqdix3PXkqdC5zdHJpZGVzWzBdLGI9MDtiPGUuaW5DaGFubmVsczsrK2IpZm9yKHZhciBDPTA7QzxlLm91dEhlaWdodDsrK0MpZm9yKHZhciBFPUMqci1sLFI9TWF0aC5tYXgoMCxFKSxTPU1hdGgubWluKGUuaW5IZWlnaHQscytFKSxOPXgrQyptLGs9MDtrPGUub3V0V2lkdGg7KytrKXtmb3IodmFyIEk9aypvLWMsQT1NYXRoLm1heCgwLEkpLFQ9TWF0aC5taW4oZS5pbldpZHRoLHUrSSksRD1oLE89MCxfPTAsTT1SO008UztNKz1hKXtmb3IodmFyIEY9dytNKnQuc3RyaWRlc1sxXSxCPUE7QjxUO0IrPWkpe3ZhciBQPXBbRitCKnQuc3RyaWRlc1syXStiXTtcIm1heFwiPT09biYmUD5EP0Q9UDpcImF2Z1wiPT09biYmKE8rPVAsXysrKX1pZihpc05hTihEKSlicmVha31kW04raypnK2JdPVwiYXZnXCI9PT1uP08vXzpEfXJldHVybiBmLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLm1heFBvb2w9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5wb29sKHQsZSxcIm1heFwiKX0sdC5wcm90b3R5cGUubWF4UG9vbFBvc2l0aW9ucz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1OcihlLm91dFNoYXBlLFwiaW50MzJcIikscj1lLnN0cmlkZUhlaWdodCxvPWUuc3RyaWRlV2lkdGgsYT1lLmRpbGF0aW9uSGVpZ2h0LGk9ZS5kaWxhdGlvbldpZHRoLHM9ZS5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsdT1lLmVmZmVjdGl2ZUZpbHRlcldpZHRoLGw9ZS5wYWRJbmZvLnRvcCxjPWUucGFkSW5mby5sZWZ0LGg9dC5idWZmZXJTeW5jKCkscD0wO3A8ZS5iYXRjaFNpemU7KytwKWZvcih2YXIgZj0wO2Y8ZS5pbkNoYW5uZWxzOysrZilmb3IodmFyIGQ9MDtkPGUub3V0SGVpZ2h0OysrZCl7Zm9yKHZhciB2PWQqci1sLG09djttPDA7KW0rPWE7Zm9yKHZhciBnPU1hdGgubWluKGUuaW5IZWlnaHQscyt2KSx5PTA7eTxlLm91dFdpZHRoOysreSl7Zm9yKHZhciB4PXkqby1jLHc9eDt3PDA7KXcrPWk7Zm9yKHZhciBiPU1hdGgubWluKGUuaW5XaWR0aCx1K3gpLEM9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLEU9LTEsUj1tO1I8ZztSKz1hKWZvcih2YXIgUz1SLXYsTj13O048YjtOKz1pKXt2YXIgaz1OLXgsST1oLmdldChwLFIsTixmKTtJPkMmJihDPUksRT1TKnUrayl9bi5zZXQoRSxwLGQseSxmKX19cmV0dXJuIG4udG9UZW5zb3IoKX0sdC5wcm90b3R5cGUubWF4UG9vbEJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleChbZSxuXSxcIm1heFBvb2xCYWNrcHJvcFwiKTtmb3IodmFyIG89dGhpcy5tYXhQb29sUG9zaXRpb25zKGUsciksYT1yLnN0cmlkZUhlaWdodCxpPXIuc3RyaWRlV2lkdGgscz1yLmRpbGF0aW9uSGVpZ2h0LHU9ci5kaWxhdGlvbldpZHRoLGw9ci5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsYz1yLmVmZmVjdGl2ZUZpbHRlcldpZHRoLGg9Yy0xLXIucGFkSW5mby5sZWZ0LHA9bC0xLXIucGFkSW5mby50b3AsZj1OcihlLnNoYXBlLFwiZmxvYXQzMlwiKSxkPW8uYnVmZmVyU3luYygpLHY9dC5idWZmZXJTeW5jKCksbT0wO208ci5iYXRjaFNpemU7KyttKWZvcih2YXIgZz0wO2c8ci5pbkNoYW5uZWxzOysrZylmb3IodmFyIHk9MDt5PHIuaW5IZWlnaHQ7Kyt5KWZvcih2YXIgeD0wO3g8ci5pbldpZHRoOysreCl7Zm9yKHZhciB3PXktcCxiPXgtaCxDPTAsRT0wO0U8bDtFKz1zKXt2YXIgUj0odytFKS9hO2lmKCEoUjwwfHxSPj1yLm91dEhlaWdodHx8TWF0aC5mbG9vcihSKSE9PVIpKWZvcih2YXIgUz0wO1M8YztTKz11KXt2YXIgTj0oYitTKS9pO2lmKCEoTjwwfHxOPj1yLm91dFdpZHRofHxNYXRoLmZsb29yKE4pIT09Tikpe3ZhciBrPWwqYy0xLWQuZ2V0KG0sUixOLGcpPT09RSpjK1M/MTowO2lmKDAhPT1rKUMrPXYuZ2V0KG0sUixOLGcpKmt9fX1mLnNldChDLG0seSx4LGcpfXJldHVybiBmLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLmF2Z1Bvb2xCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwiYXZnUG9vbEJhY2twcm9wXCIpO2Zvcih2YXIgcj1uLnN0cmlkZUhlaWdodCxvPW4uc3RyaWRlV2lkdGgsYT1uLmZpbHRlckhlaWdodCxpPW4uZmlsdGVyV2lkdGgscz1uLmRpbGF0aW9uSGVpZ2h0LHU9bi5kaWxhdGlvbldpZHRoLGw9bi5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsYz1uLmVmZmVjdGl2ZUZpbHRlcldpZHRoLGg9Yy0xLW4ucGFkSW5mby5sZWZ0LHA9bC0xLW4ucGFkSW5mby50b3AsZj1OcihlLnNoYXBlLFwiZmxvYXQzMlwiKSxkPTEvKGEqaSksdj10LmJ1ZmZlclN5bmMoKSxtPTA7bTxuLmJhdGNoU2l6ZTsrK20pZm9yKHZhciBnPTA7ZzxuLmluQ2hhbm5lbHM7KytnKWZvcih2YXIgeT0wO3k8bi5pbkhlaWdodDsrK3kpZm9yKHZhciB4PTA7eDxuLmluV2lkdGg7Kyt4KXtmb3IodmFyIHc9eS1wLGI9eC1oLEM9MCxFPTA7RTxsO0UrPXMpe3ZhciBSPSh3K0UpL3I7aWYoIShSPDB8fFI+PW4ub3V0SGVpZ2h0fHxNYXRoLmZsb29yKFIpIT09UikpZm9yKHZhciBTPTA7UzxjO1MrPXUpe3ZhciBOPShiK1MpL287aWYoIShOPDB8fE4+PW4ub3V0V2lkdGh8fE1hdGguZmxvb3IoTikhPT1OKSlDKz12LmdldChtLFIsTixnKX19Zi5zZXQoQypkLG0seSx4LGcpfXJldHVybiBmLnRvVGVuc29yKCl9LHQucHJvdG90eXBlLmNhc3Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gSm4odCxlLHRoaXMpfSx0LnByb3RvdHlwZS5yZXNoYXBlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIFpuKHQsZSl9LHQucHJvdG90eXBlLmF2Z1Bvb2w9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJhdmdQb29sXCIpLHRoaXMucG9vbCh0LGUsXCJhdmdcIikudG9GbG9hdCgpfSx0LnByb3RvdHlwZS5yZXNpemVCaWxpbmVhcj1mdW5jdGlvbih0LGUsbixyKXt0aGlzLmFzc2VydE5vdENvbXBsZXgodCxcInJlc2l6ZUJpbGluZWFyXCIpO2Zvcih2YXIgbz10LnNoYXBlLGE9b1swXSxpPW9bMV0scz1vWzJdLHU9b1szXSxsPXQuZGF0YVN5bmMoKSxjPW5ldyBGbG9hdDMyQXJyYXkoeShbYSxlLG4sdV0pKSxoPVtyJiZlPjE/aS0xOmksciYmbj4xP3MtMTpzXSxwPVtyJiZlPjE/ZS0xOmUsciYmbj4xP24tMTpuXSxmPTAsZD1oWzBdL3BbMF0sdj1oWzFdL3BbMV0sbT0wO208YTttKyspZm9yKHZhciBnPTA7ZzxlO2crKylmb3IodmFyIHg9ZCpnLHc9TWF0aC5mbG9vcih4KSxiPXgtdyxDPU1hdGgubWluKGktMSxNYXRoLmNlaWwoeCkpLEU9bSp0LnN0cmlkZXNbMF0rdyp0LnN0cmlkZXNbMV0sUj1tKnQuc3RyaWRlc1swXStDKnQuc3RyaWRlc1sxXSxTPTA7UzxuO1MrKylmb3IodmFyIE49dipTLGs9TWF0aC5mbG9vcihOKSxJPU4tayxBPU1hdGgubWluKHMtMSxNYXRoLmNlaWwoTikpLFQ9RStrKnQuc3RyaWRlc1syXSxEPVIrayp0LnN0cmlkZXNbMl0sTz1FKyArQSp0LnN0cmlkZXNbMl0sXz1SK0EqdC5zdHJpZGVzWzJdLE09MDtNPHU7TSsrKXt2YXIgRj1sW1QrTV0sQj1sW0QrTV0sUD1GKyhsW08rTV0tRikqSSxMPVArKEIrKGxbXytNXS1CKSpJLVApKmI7Y1tmKytdPUx9cmV0dXJuIEZuKGMsW2EsZSxuLHVdKX0sdC5wcm90b3R5cGUucmVzaXplQmlsaW5lYXJCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwicmVzaXplQmlsaW5lYXJCYWNrcHJvcFwiKTtmb3IodmFyIHI9ZS5zaGFwZSxvPXJbMF0sYT1yWzFdLGk9clsyXSxzPXJbM10sdT10LnNoYXBlLGw9dVsxXSxjPXVbMl0saD1uZXcgRmxvYXQzMkFycmF5KG8qYSppKnMpLHA9W24mJmw+MT9hLTE6YSxuJiZjPjE/aS0xOmldLGY9W24mJmw+MT9sLTE6bCxuJiZjPjE/Yy0xOmNdLGQ9cFswXS9mWzBdLHY9cFsxXS9mWzFdLG09dC5kYXRhU3luYygpLGc9MCx5PTA7eTxvO3krKylmb3IodmFyIHg9eSplLnN0cmlkZXNbMF0sdz0wO3c8bDt3KyspZm9yKHZhciBiPXcqZCxDPU1hdGguZmxvb3IoYiksRT1NYXRoLm1pbihNYXRoLmNlaWwoYiksYS0xKSxSPXgrQyplLnN0cmlkZXNbMV0sUz14K0UqZS5zdHJpZGVzWzFdLE49Yi1DLGs9MS1OLEk9MDtJPGM7SSsrKWZvcih2YXIgQT1JKnYsVD1NYXRoLmZsb29yKEEpLEQ9TWF0aC5taW4oTWF0aC5jZWlsKEEpLGktMSksTz1BLVQsXz0xLU8sTT1SK1QqZS5zdHJpZGVzWzJdLEY9UitEKmUuc3RyaWRlc1syXSxCPVMrVCplLnN0cmlkZXNbMl0sUD1TK0QqZS5zdHJpZGVzWzJdLEw9aypfLFc9aypPLFU9TipfLHo9TipPLFY9MDtWPHM7VisrKXt2YXIgRz1tW2crK107aFtNK1ZdKz1HKkwsaFtGK1ZdKz1HKlcsaFtCK1ZdKz1HKlUsaFtQK1ZdKz1HKnp9cmV0dXJuIFVuKGgsW28saSxhLHNdLGUuZHR5cGUpfSx0LnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3I9ZnVuY3Rpb24odCxlLG4scil7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJyZXNpemVOZWFyZXN0TmVpZ2hib3JcIik7Zm9yKHZhciBvPXQuc2hhcGUsYT1vWzBdLGk9b1sxXSxzPW9bMl0sdT1vWzNdLGw9dC5kYXRhU3luYygpLGM9bmV3IEZsb2F0MzJBcnJheShhKmUqbip1KSxoPVtyJiZlPjE/aS0xOmksciYmbj4xP3MtMTpzXSxwPVtyJiZlPjE/ZS0xOmUsciYmbj4xP24tMTpuXSxmPWhbMF0vcFswXSxkPWhbMV0vcFsxXSx2PTAsbT0wO208YTttKyspZm9yKHZhciBnPW0qdC5zdHJpZGVzWzBdLHk9MDt5PGU7eSsrKWZvcih2YXIgeD1mKnksdz1nK01hdGgubWluKGktMSxyP01hdGgucm91bmQoeCk6TWF0aC5mbG9vcih4KSkqdC5zdHJpZGVzWzFdLGI9MDtiPG47YisrKWZvcih2YXIgQz1kKmIsRT13K01hdGgubWluKHMtMSxyP01hdGgucm91bmQoQyk6TWF0aC5mbG9vcihDKSkqdC5zdHJpZGVzWzJdLFI9MDtSPHU7UisrKXt2YXIgUz1sW0UrUl07Y1t2KytdPVN9cmV0dXJuIEZuKGMsW2EsZSxuLHVdLHQuZHR5cGUpfSx0LnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3JCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7dGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGVdLFwicmVzaXplTmVhcmVzdE5laWdoYm9yQmFja3Byb3BcIik7Zm9yKHZhciByPWUuc2hhcGUsbz1yWzBdLGE9clsxXSxpPXJbMl0scz1yWzNdLHU9dC5zaGFwZSxsPXVbMV0sYz11WzJdLGg9bmV3IEZsb2F0MzJBcnJheShvKmEqaSpzKSxwPXQuZGF0YVN5bmMoKSxmPVtuJiZsPjE/YS0xOmEsbiYmYz4xP2ktMTppXSxkPVtuJiZsPjE/bC0xOmwsbiYmYz4xP2MtMTpjXSx2PWZbMF0vZFswXSxtPWZbMV0vZFsxXSxnPTEvdix5PTEvbSx4PTIqTWF0aC5jZWlsKGcpKzIsdz0yKk1hdGguY2VpbCh5KSsyLGI9MDtiPG87YisrKWZvcih2YXIgQz1iKmUuc3RyaWRlc1swXSxFPTA7RTxhO0UrKylmb3IodmFyIFI9QytFKmUuc3RyaWRlc1sxXSxTPU1hdGguZmxvb3IoRSpnKSxOPU1hdGguZmxvb3IoUy14LzIpLGs9MDtrPGk7aysrKWZvcih2YXIgST1SK2sqZS5zdHJpZGVzWzJdLEE9TWF0aC5mbG9vcihrKnkpLFQ9TWF0aC5mbG9vcihBLXcvMiksRD0wO0Q8cztEKyspe2Zvcih2YXIgTz0wLF89MDtfPHg7XysrKXt2YXIgTT1fK047aWYoIShNPDB8fE0+PWwpKXt2YXIgRj1DK00qdC5zdHJpZGVzWzFdLEI9TSp2O2lmKEU9PT1NYXRoLm1pbihhLTEsbj9NYXRoLnJvdW5kKEIpOk1hdGguZmxvb3IoQikpKWZvcih2YXIgUD0wO1A8dztQKyspe3ZhciBMPVArVDtpZighKEw8MHx8TD49Yykpe3ZhciBXPUYrTCp0LnN0cmlkZXNbMl0sVT1MKm07az09PU1hdGgubWluKGktMSxuP01hdGgucm91bmQoVSk6TWF0aC5mbG9vcihVKSkmJihPKz1wW1crRF0pfX19fWhbSStEXT1PfXJldHVybiBVbihoLGUuc2hhcGUsZS5kdHlwZSl9LHQucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbj1mdW5jdGlvbih0LGUsbixyLG8sYSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KFt0LGUsbixvLGFdLFwiYmF0Y2hOb3JtXCIpO2Zvcih2YXIgaT10LmRhdGFTeW5jKCkscz1lLmRhdGFTeW5jKCksdT1uLmRhdGFTeW5jKCksbD1vP28uZGF0YVN5bmMoKTpuZXcgRmxvYXQzMkFycmF5KFsxXSksYz1hP2EuZGF0YVN5bmMoKTpuZXcgRmxvYXQzMkFycmF5KFswXSksaD1uZXcgRmxvYXQzMkFycmF5KGkubGVuZ3RoKSxwPWMubGVuZ3RoLGY9bC5sZW5ndGgsZD11Lmxlbmd0aCx2PXMubGVuZ3RoLG09MCxnPTAseT0wLHg9MCx3PTA7dzxpLmxlbmd0aDsrK3cpaFt3XT1jW20rK10rKGlbd10tc1tnKytdKSpsW3krK10vTWF0aC5zcXJ0KHVbeCsrXStyKSxtPj1wJiYobT0wKSxnPj12JiYoZz0wKSx5Pj1mJiYoeT0wKSx4Pj1kJiYoeD0wKTtyZXR1cm4gVW4oaCx0LnNoYXBlKX0sdC5wcm90b3R5cGUubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb240RD1mdW5jdGlvbih0LGUsbixyLG8pe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwibG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb240RFwiKTt2YXIgYT10LnNoYXBlWzNdLGk9YS0xLHM9dC5kYXRhU3luYygpLHU9dC5zaXplLGw9bmV3IEZsb2F0MzJBcnJheSh1KTtmdW5jdGlvbiBjKHQpe2Zvcih2YXIgbj10JWEscj10LW4rTWF0aC5tYXgoMCxuLWUpLG89dC1uK01hdGgubWluKG4rZSxpKSx1PTA7cjw9bztyKyspe3ZhciBsPXNbcl07dSs9bCpsfXJldHVybiB1fWZvcih2YXIgaD0wO2g8dTtoKyspe3ZhciBwPWMoaCksZj1zW2hdKk1hdGgucG93KG4rcipwLC1vKTtsW2hdPWZ9cmV0dXJuIFVuKGwsdC5zaGFwZSl9LHQucHJvdG90eXBlLkxSTkdyYWQ9ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJMUk5HcmFkXCIpO2Zvcih2YXIgcz10LnNoYXBlWzNdLHU9dC5kYXRhU3luYygpLGw9ZS5kYXRhU3luYygpLGM9bi5kYXRhU3luYygpLGg9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLHA9dC5zaXplLGY9MDtmPHA7ZisrKXtmb3IodmFyIGQ9ZiVzLHY9Zi1kK01hdGgubWF4KDAsZC1yKSxtPWYtZCtNYXRoLm1pbihzLGQrcisxKSxnPTAseT12O3k8bTt5KyspZys9TWF0aC5wb3cobFt5XSwyKTtnPWEqZytvO2Zvcih5PXY7eTxtO3krKyl7dmFyIHg9LTIqYSppKmxbeV0qY1tmXS9nO2Y9PT15JiYoeCs9TWF0aC5wb3coZywtaSkpLHgqPXVbZl0saFt5XSs9eH19cmV0dXJuIFVuKGgsdC5zaGFwZSl9LHQucHJvdG90eXBlLm11bHRpbm9taWFsPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwibXVsdGlub21pYWxcIik7Zm9yKHZhciBvPWU/dDpUbih0KSxhPW8uc2hhcGVbMF0saT1vLnNoYXBlWzFdLHM9cW4oW2Esbl0sXCJpbnQzMlwiKSx1PXMuZGF0YVN5bmMoKSxsPW8uZGF0YVN5bmMoKSxjPTA7YzxhOysrYyl7dmFyIGg9YyppLHA9bmV3IEZsb2F0MzJBcnJheShpLTEpO3BbMF09bFtoXTtmb3IodmFyIGY9MTtmPHAubGVuZ3RoOysrZilwW2ZdPXBbZi0xXStsW2grZl07Zm9yKHZhciBkPUVyKHIudG9TdHJpbmcoKSksdj1jKm4sbT0wO208bjsrK20pe3ZhciBnPWQoKTt1W3YrbV09cC5sZW5ndGg7Zm9yKHZhciB5PTA7eTxwLmxlbmd0aDt5KyspaWYoZzxwW3ldKXt1W3YrbV09eTticmVha319fXJldHVybiBzfSx0LnByb3RvdHlwZS5vbmVIb3Q9ZnVuY3Rpb24odCxlLG4scil7dGhpcy5hc3NlcnROb3RDb21wbGV4KHQsXCJvbmVIb3RcIik7dmFyIG89bmV3IEZsb2F0MzJBcnJheSh0LnNpemUqZSk7by5maWxsKHIpO2Zvcih2YXIgYT10LmRhdGFTeW5jKCksaT0wO2k8dC5zaXplOysraSlhW2ldPj0wJiZhW2ldPGUmJihvW2kqZSthW2ldXT1uKTtyZXR1cm4gTG4obyxbdC5zaXplLGVdLFwiaW50MzJcIil9LHQucHJvdG90eXBlLm5vbk1heFN1cHByZXNzaW9uPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90Q29tcGxleCh0LFwibm9uTWF4U3VwcHJlc3Npb25cIiksYXIodC5kYXRhU3luYygpLGUuZGF0YVN5bmMoKSxuLHIsbyl9LHQucHJvdG90eXBlLmZmdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5mZnRCYXRjaCh0LCExKX0sdC5wcm90b3R5cGUuaWZmdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5mZnRCYXRjaCh0LCEwKX0sdC5wcm90b3R5cGUuZmZ0QmF0Y2g9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5zaGFwZVswXSxyPXQuc2hhcGVbMV0sbz1Ocih0LnNoYXBlLFwiZmxvYXQzMlwiKSxhPU5yKHQuc2hhcGUsXCJmbG9hdDMyXCIpLGk9X24odCkuYXMyRChuLHIpLHM9TW4odCkuYXMyRChuLHIpLHU9MDt1PG47dSsrKWZvcih2YXIgbD1pLnNsaWNlKFt1LDBdLFsxLHJdKSxjPXMuc2xpY2UoW3UsMF0sWzEscl0pLGg9T24obCxjKSxwPXRoaXMuZmZ0SW1wbChoLGUpLmRhdGFTeW5jKCksZj0wO2Y8cjtmKyspe3ZhciBkPW5yKHAsZik7by52YWx1ZXNbdSpyK2ZdPWQucmVhbCxhLnZhbHVlc1t1KnIrZl09ZC5pbWFnfXJldHVybiBPbihvLnRvVGVuc29yKCksYS50b1RlbnNvcigpKS5hczJEKG4scil9LHQucHJvdG90eXBlLmZmdEltcGw9ZnVuY3Rpb24odCxlKXt2YXIgbj10LmFzMUQoKSxyPW4uc2l6ZTtpZih0aGlzLmlzRXhwb25lbnRPZjIocikpe3ZhciBvPXRoaXMuZmZ0UmFkaXgyKG4scixlKS5hczJEKHQuc2hhcGVbMF0sdC5zaGFwZVsxXSk7cmV0dXJuIGUmJihvPU9uKF9uKG8pLmRpdihCbihyKSksTW4obykuZGl2KEJuKHIpKSkpLG99dmFyIGE9dC5kYXRhU3luYygpLGk9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5sZW5ndGgvMiksbj1uZXcgRmxvYXQzMkFycmF5KHQubGVuZ3RoLzIpLHI9MDtyPHQubGVuZ3RoO3IrPTIpZVtyLzJdPXRbcl0sbltyLzJdPXRbcisxXTtyZXR1cm57cmVhbDplLGltYWc6bn19KHRoaXMuZm91cmllclRyYW5zZm9ybUJ5TWF0bXVsKGEscixlKSk7cmV0dXJuIE9uKGkucmVhbCxpLmltYWcpLmFzMkQodC5zaGFwZVswXSx0LnNoYXBlWzFdKX0sdC5wcm90b3R5cGUuaXNFeHBvbmVudE9mMj1mdW5jdGlvbih0KXtyZXR1cm4gMD09KHQmdC0xKX0sdC5wcm90b3R5cGUuZmZ0UmFkaXgyPWZ1bmN0aW9uKHQsZSxuKXtpZigxPT09ZSlyZXR1cm4gdDt2YXIgcj10LmRhdGFTeW5jKCksbz1lLzIsYT1mdW5jdGlvbih0KXtmb3IodmFyIGU9TWF0aC5jZWlsKHQubGVuZ3RoLzQpLG49bmV3IEZsb2F0MzJBcnJheShlKSxyPW5ldyBGbG9hdDMyQXJyYXkoZSksbz0wO288dC5sZW5ndGg7bys9NCluW01hdGguZmxvb3Ioby80KV09dFtvXSxyW01hdGguZmxvb3Ioby80KV09dFtvKzFdO3JldHVybntyZWFsOm4saW1hZzpyfX0ociksaT1PbihhLnJlYWwsYS5pbWFnKS5hczFEKCkscz1mdW5jdGlvbih0KXtmb3IodmFyIGU9TWF0aC5mbG9vcih0Lmxlbmd0aC80KSxuPW5ldyBGbG9hdDMyQXJyYXkoZSkscj1uZXcgRmxvYXQzMkFycmF5KGUpLG89MjtvPHQubGVuZ3RoO28rPTQpbltNYXRoLmZsb29yKG8vNCldPXRbb10scltNYXRoLmZsb29yKG8vNCldPXRbbysxXTtyZXR1cm57cmVhbDpuLGltYWc6cn19KHIpLHU9T24ocy5yZWFsLHMuaW1hZykuYXMxRCgpO2k9dGhpcy5mZnRSYWRpeDIoaSxvLG4pLHU9dGhpcy5mZnRSYWRpeDIodSxvLG4pO3ZhciBsPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBGbG9hdDMyQXJyYXkodC8yKSxyPW5ldyBGbG9hdDMyQXJyYXkodC8yKSxvPTA7bzxNYXRoLmNlaWwodC8yKTtvKyspe3ZhciBhPShlPzI6LTIpKk1hdGguUEkqKG8vdCk7bltvXT1NYXRoLmNvcyhhKSxyW29dPU1hdGguc2luKGEpfXJldHVybntyZWFsOm4saW1hZzpyfX0oZSxuKSxjPU9uKGwucmVhbCxsLmltYWcpLm11bCh1KSxoPWkuYWRkKGMpLHA9aS5zdWIoYyksZj1fbihoKS5jb25jYXQoX24ocCkpLGQ9TW4oaCkuY29uY2F0KE1uKHApKTtyZXR1cm4gT24oZixkKS5hczFEKCl9LHQucHJvdG90eXBlLmZvdXJpZXJUcmFuc2Zvcm1CeU1hdG11bD1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPW5ldyBGbG9hdDMyQXJyYXkoMiplKSxvPTA7bzxlO28rKyl7Zm9yKHZhciBhPTAsaT0wLHM9MDtzPGU7cysrKXt2YXIgdT1vcihvKnMsZSxuKSxsPW5yKHQscyk7YSs9bC5yZWFsKnUucmVhbC1sLmltYWcqdS5pbWFnLGkrPWwucmVhbCp1LmltYWcrbC5pbWFnKnUucmVhbH1uJiYoYS89ZSxpLz1lKSxycihyLGEsaSxvKX1yZXR1cm4gcn0sdC5wcm90b3R5cGUuZGVwdGhUb1NwYWNlPWZ1bmN0aW9uKHQsZSxuKXtkKFwiTkhXQ1wiPT09bixmdW5jdGlvbigpe3JldHVyblwiT25seSBOSFdDIGRhdGFGb3JtYXQgc3VwcG9ydGVkIG9uIENQVSBmb3IgZGVwdGhUb1NwYWNlLiBHb3QgXCIrbn0pLGQoZT4xLGZ1bmN0aW9uKCl7cmV0dXJuXCJibG9ja1NpemUgc2hvdWxkIGJlID4gMSBmb3IgZGVwdGhUb1NwYWNlLCBidXQgd2FzOiBcIitlfSk7Zm9yKHZhciByPXQuc2hhcGVbMF0sbz10LnNoYXBlWzFdLGE9dC5zaGFwZVsyXSxpPXQuc2hhcGVbM10scz1vKmUsdT1hKmUsbD1pLyhlKmUpLGM9dC5kYXRhU3luYygpLGg9bmV3IEZsb2F0MzJBcnJheShyKnMqdSpsKSxwPTAsZj0wO2Y8cjsrK2YpZm9yKHZhciB2PTA7djxzOysrdilmb3IodmFyIG09TWF0aC5mbG9vcih2L2UpLGc9diVlLHk9MDt5PHU7Kyt5KWZvcih2YXIgeD1NYXRoLmZsb29yKHkvZSksdz0oZyplK3klZSkqbCxiPTA7YjxsOysrYil7dmFyIEM9Yit3K2kqKHgrYSoobStvKmYpKTtoW3ArK109Y1tDXX1yZXR1cm4gVW4oaCxbcixzLHUsbF0pfSx0LnByb3RvdHlwZS5icm9hZGNhc3RlZEJpbmFyeU9wPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPXNvKHQuc2hhcGUsZS5zaGFwZSksYT1OcihvLG4pLGk9dC5kYXRhU3luYygpLHM9ZS5kYXRhU3luYygpLHU9YW8odC5zaGFwZSxvKSxsPWFvKGUuc2hhcGUsbyksYz1hLnZhbHVlcztpZih1Lmxlbmd0aCtsLmxlbmd0aD09PTApZm9yKHZhciBoPTA7aDxjLmxlbmd0aDsrK2gpY1toXT1yKGlbaCVpLmxlbmd0aF0sc1toJXMubGVuZ3RoXSk7ZWxzZXt2YXIgcD10LmJ1ZmZlclN5bmMoKSxmPWUuYnVmZmVyU3luYygpLGQ9ZnVuY3Rpb24obil7dmFyIG89YS5pbmRleFRvTG9jKG4pLGg9by5zbGljZSgtdC5yYW5rKTt1LmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIGhbdF09MH0pO3ZhciBkPXAubG9jVG9JbmRleChoKSx2PW8uc2xpY2UoLWUucmFuayk7bC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiB2W3RdPTB9KTt2YXIgbT1mLmxvY1RvSW5kZXgodik7Y1tuXT1yKGlbZF0sc1ttXSl9O2ZvcihoPTA7aDxjLmxlbmd0aDsrK2gpZChoKX1yZXR1cm4gYS50b1RlbnNvcigpfSx0LnByb3RvdHlwZS5icm9hZGNhc3RlZEJpbmFyeUNvbXBsZXhPcD1mdW5jdGlvbih0LGUsbil7dmFyIHI9c28odC5zaGFwZSxlLnNoYXBlKSxvPU5yKHIsXCJmbG9hdDMyXCIpLGE9TnIocixcImZsb2F0MzJcIiksaT10LmRhdGFTeW5jKCkscz1lLmRhdGFTeW5jKCksdT1hbyh0LnNoYXBlLHIpLGw9YW8oZS5zaGFwZSxyKSxjPW8udmFsdWVzLGg9YS52YWx1ZXM7aWYodS5sZW5ndGgrbC5sZW5ndGg9PT0wKWZvcih2YXIgcD0wO3A8Yy5sZW5ndGg7cCsrKXt2YXIgZj1wJWkubGVuZ3RoLGQ9cCVzLmxlbmd0aCx2PW4oaVsyKmZdLGlbMipmKzFdLHNbMipkXSxzWzIqZCsxXSk7Y1twXT12LnJlYWwsaFtwXT12LmltYWd9ZWxzZXt2YXIgbT10aGlzLmRhdGEuZ2V0KHQuZGF0YUlkKS5jb21wbGV4VGVuc29ycy5yZWFsLmJ1ZmZlclN5bmMoKSxnPXRoaXMuZGF0YS5nZXQoZS5kYXRhSWQpLmNvbXBsZXhUZW5zb3JzLnJlYWwuYnVmZmVyU3luYygpLHk9ZnVuY3Rpb24ocil7dmFyIGE9by5pbmRleFRvTG9jKHIpLHA9YS5zbGljZSgtdC5yYW5rKTt1LmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIHBbdF09MH0pO3ZhciBmPW0ubG9jVG9JbmRleChwKSxkPWEuc2xpY2UoLWUucmFuayk7bC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiBkW3RdPTB9KTt2YXIgdj1nLmxvY1RvSW5kZXgoZCkseT1uKGlbMipmXSxpWzIqZisxXSxzWzIqdl0sc1syKnYrMV0pO2Nbcl09eS5yZWFsLGhbcl09eS5pbWFnfTtmb3IocD0wO3A8Yy5sZW5ndGg7cCsrKXkocCl9cmV0dXJuIHRoaXMuY29tcGxleChvLnRvVGVuc29yKCksYS50b1RlbnNvcigpKX0sdC5wcm90b3R5cGUuc3BsaXQ9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBzcih0LGUsbil9LHQucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt9LHQucHJvdG90eXBlLmZsb2F0UHJlY2lzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuIDMyfSx0LnByb3RvdHlwZS5lcHNpbG9uPWZ1bmN0aW9uKCl7cmV0dXJuIDFlLTd9LHQucHJvdG90eXBlLmNyb3BBbmRSZXNpemU9ZnVuY3Rpb24odCxlLG4scixvLGEpe2Zvcih2YXIgaT10LnNoYXBlLHM9aVswXSx1PWlbMV0sbD1pWzJdLGM9aVszXSxoPWUuc2hhcGVbMF0scD1yWzBdLGY9clsxXSxkPU5yKFtoLHAsZixjXSx0LmR0eXBlKSx2PWUuZGF0YVN5bmMoKSxtPW4uZGF0YVN5bmMoKSxnPXQuZGF0YVN5bmMoKSx5PXQuc3RyaWRlcyx4PWQuc3RyaWRlcyx3PTA7dzxoO3crKyl7dmFyIGI9NCp3LEM9dltiXSxFPXZbYisxXSxSPXZbYisyXSxTPXZbYiszXSxOPW1bd107aWYoIShOPj1zKSlmb3IodmFyIGs9cD4xPyhSLUMpKih1LTEpLyhwLTEpOjAsST1mPjE/KFMtRSkqKGwtMSkvKGYtMSk6MCxBPTA7QTxwO0ErKyl7dmFyIFQ9cD4xP0MqKHUtMSkrQSprOi41KihDK1IpKih1LTEpO2lmKFQ8MHx8VD51LTEpZm9yKHZhciBEPTA7RDxmO0QrKylmb3IodmFyIE89MDtPPGM7TysrKXt2YXIgXz1PK0QqeFsyXStBKnhbMV0rdyp4WzBdO2QudmFsdWVzW19dPWF9ZWxzZSBpZihcImJpbGluZWFyXCI9PT1vKXt2YXIgTT1NYXRoLmZsb29yKFQpLEY9TWF0aC5jZWlsKFQpLEI9VC1NO2ZvcihEPTA7RDxmO0QrKyl7aWYoKEg9Zj4xP0UqKGwtMSkrRCpJOi41KihFK1MpKihsLTEpKTwwfHxIPmwtMSlmb3IoTz0wO088YztPKyspe189TytEKnhbMl0rQSp4WzFdK3cqeFswXTtkLnZhbHVlc1tfXT1hfWVsc2V7dmFyIFA9TWF0aC5mbG9vcihIKSxMPU1hdGguY2VpbChIKSxXPUgtUDtmb3IoTz0wO088YztPKyspe3ZhciBVPWdbXz1PK1AqeVsyXStNKnlbMV0rTip5WzBdXSx6PWdbXz1PK0wqeVsyXStNKnlbMV0rTip5WzBdXSxWPWdbXz1PK1AqeVsyXStGKnlbMV0rTip5WzBdXSxHPVUrKHotVSkqVyxxPVYrKGdbXz1PK0wqeVsyXStGKnlbMV0rTip5WzBdXS1WKSpXO189TytEKnhbMl0rQSp4WzFdK3cqeFswXSxkLnZhbHVlc1tfXT1HKyhxLUcpKkJ9fX19ZWxzZSBmb3IoRD0wO0Q8ZjsrK0Qpe3ZhciBIO2lmKChIPWY+MT9FKihsLTEpK0QqSTouNSooRStTKSoobC0xKSk8MHx8SD5sLTEpZm9yKE89MDtPPGM7TysrKXtfPU8rRCp4WzJdK0EqeFsxXSt3KnhbMF07ZC52YWx1ZXNbX109YX1lbHNle3ZhciAkPU1hdGgucm91bmQoSCksaj1NYXRoLnJvdW5kKFQpO2ZvcihPPTA7TzxjO08rKyl7dmFyIEs9TyskKnlbMl0raip5WzFdK04qeVswXSxYPU8rRCp4WzJdK0EqeFsxXSt3KnhbMF07ZC52YWx1ZXNbWF09Z1tLXX19fX19cmV0dXJuIGQudG9UZW5zb3IoKX0sdC5wcm90b3R5cGUuc3BhcnNlVG9EZW5zZT1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1wbigwLHQsbiksYT1vLnNsaWNlUmFuayxpPW8ubnVtVXBkYXRlcyxzPW8uc2xpY2VTaXplLHU9by5zdHJpZGVzLGw9by5vdXRwdXRTaXplO3JldHVybiB0aGlzLnNjYXR0ZXIodCxlLG4sbCxzLGksYSx1LHIsITEpfSx0LnByb3RvdHlwZS5nYXRoZXJORD1mdW5jdGlvbih0LGUpe3ZhciBuPWUuc2hhcGUscj1uW24ubGVuZ3RoLTFdLG89dW4odCxlKSxhPW9bMF0saT1vWzFdLHM9b1syXSx1PW9bM107aWYoMD09PWkpcmV0dXJuIEZuKFtdLGEsdC5kdHlwZSk7Zm9yKHZhciBsPW5ldyBsdChbaSxzXSx0LmR0eXBlKSxjPWUuZGF0YVN5bmMoKSxoPXQuZGF0YVN5bmMoKSxwPTA7cDxpO3ArKyl7Zm9yKHZhciBmPVtdLGQ9MCx2PTA7djxyO3YrKyl7dmFyIG09Y1twKnIrdl07ZCs9bSp1W3ZdLGYucHVzaChtKX1pZihkPDB8fGQ+PXQuc2l6ZS9zKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5kaWNlczogXCIrZitcIiBkb2VzIG5vdCBpbmRleCBpbnRvIFwiK3Quc2hhcGUpO2Zvcih2YXIgZz0wO2c8cztnKyspbC52YWx1ZXNbcCpzK2ddPWhbZCpzK2ddfXJldHVybiBsLnRvVGVuc29yKCkucmVzaGFwZShhKX0sdC5wcm90b3R5cGUuc2NhdHRlck5EPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1wbigwLHQsbiksbz1yLnNsaWNlUmFuayxhPXIubnVtVXBkYXRlcyxpPXIuc2xpY2VTaXplLHM9ci5zdHJpZGVzLHU9ci5vdXRwdXRTaXplLGw9Qm4oMCk7cmV0dXJuIHRoaXMuc2NhdHRlcih0LGUsbix1LGksYSxvLHMsbCwhMCl9LHQucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24odCxlLG4pe3ZhciByPUEobj1ufHxXKGUpLHkodCkpO3JldHVybiByLmZpbGwoZSksZnQubWFrZSh0LHt2YWx1ZXM6cn0sbil9LHQucHJvdG90eXBlLm9uZXNMaWtlPWZ1bmN0aW9uKHQpe2lmKFwic3RyaW5nXCI9PT10LmR0eXBlKXRocm93IG5ldyBFcnJvcihcIm9uZXNMaWtlIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHN0cmluZyB0ZW5zb3JzXCIpO3JldHVybiB0aGlzLmZpbGwodC5zaGFwZSwxLHQuZHR5cGUpfSx0LnByb3RvdHlwZS56ZXJvc0xpa2U9ZnVuY3Rpb24odCl7dmFyIGU9QSh0LmR0eXBlLHkodC5zaGFwZSkpO3JldHVybiBmdC5tYWtlKHQuc2hhcGUse3ZhbHVlczplfSx0LmR0eXBlKX0sdC5wcm90b3R5cGUubGluc3BhY2U9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0cih0LGUsbil9LHQucHJvdG90eXBlLnNjYXR0ZXI9ZnVuY3Rpb24odCxlLG4scixvLGEsaSxzLHUsbCl7dmFyIGM9W3IvbyxvXSxoPXQuZGF0YVN5bmMoKSxwPWUuZGF0YVN5bmMoKTtpZigwPT09cilyZXR1cm4gRm4oW10sbixlLmR0eXBlKTt2YXIgZj1uZXcgbHQoYyxlLmR0eXBlKTtmLnZhbHVlcy5maWxsKHUuZGF0YVN5bmMoKVswXSk7Zm9yKHZhciBkPTA7ZDxhO2QrKyl7Zm9yKHZhciB2PVtdLG09MCxnPTA7ZzxpO2crKyl7dmFyIHk9aFtkKmkrZ107di5wdXNoKHkpLG0rPXkqc1tnXX1pZihtPDB8fG0+PXIvbyl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluZGljZXM6IFwiK3YrXCIgZG9lcyBub3QgaW5kZXggaW50byBcIituKTtmb3IodmFyIHg9MDt4PG87eCsrKWw/Zi52YWx1ZXNbbSpvK3hdKz1wW2Qqbyt4XTpmLnZhbHVlc1ttKm8reF09MD09PWUucmFuaz9wWzBdOnBbZCpvK3hdfXJldHVybiBmLnRvVGVuc29yKCkucmVzaGFwZShuKX0sdH0oKTtEdC5yZWdpc3RlckJhY2tlbmQoXCJjcHVcIixmdW5jdGlvbigpe3JldHVybiBuZXcgZ2N9LDEpO3ZhciB5Yz17ZmxvYXQzMjo0LGludDMyOjQsdWludDE2OjIsdWludDg6MSxib29sOjF9O2Z1bmN0aW9uIHhjKHQsZSl7Zm9yKHZhciBuPXt9LHI9MCxvPWZ1bmN0aW9uKGUpe3ZhciBvPWUubmFtZSxhPWUuZHR5cGUsaT1lLnNoYXBlLHM9eShpKSx1PXZvaWQgMDtpZihcInF1YW50aXphdGlvblwiaW4gZSl7dmFyIGw9ZS5xdWFudGl6YXRpb247aWYoXCJ1aW50OFwiIT09bC5kdHlwZSYmXCJ1aW50MTZcIiE9PWwuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiV2VpZ2h0IFwiK2UubmFtZStcIiBoYXMgdW5rbm93biBxdWFudGl6YXRpb24gZHR5cGUgXCIrbC5kdHlwZStcIi4gU3VwcG9ydGVkIHF1YW50aXphdGlvbiBkdHlwZXMgYXJlOiAndWludDgnIGFuZCAndWludDE2Jy5cIik7dmFyIGM9eWNbbC5kdHlwZV0saD10LnNsaWNlKHIscitzKmMpLHA9XCJ1aW50OFwiPT09bC5kdHlwZT9uZXcgVWludDhBcnJheShoKTpuZXcgVWludDE2QXJyYXkoaCk7aWYoXCJmbG9hdDMyXCI9PT1hKXU9RmxvYXQzMkFycmF5LmZyb20ocCxmdW5jdGlvbih0KXtyZXR1cm4gdCpsLnNjYWxlK2wubWlufSk7ZWxzZXtpZihcImludDMyXCIhPT1hKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGR0eXBlIGluIHdlaWdodCAnXCIrbytcIic6IFwiK2EpO3U9SW50MzJBcnJheS5mcm9tKHAsZnVuY3Rpb24odCl7cmV0dXJuIE1hdGgucm91bmQodCpsLnNjYWxlK2wubWluKX0pfXIrPXMqY31lbHNle3ZhciBmPXljW2FdO2g9dC5zbGljZShyLHIrcypmKTtpZihcImZsb2F0MzJcIj09PWEpdT1uZXcgRmxvYXQzMkFycmF5KGgpO2Vsc2UgaWYoXCJpbnQzMlwiPT09YSl1PW5ldyBJbnQzMkFycmF5KGgpO2Vsc2V7aWYoXCJib29sXCIhPT1hKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGR0eXBlIGluIHdlaWdodCAnXCIrbytcIic6IFwiK2EpO3U9bmV3IFVpbnQ4QXJyYXkoaCl9cis9cypmfXZhciBkPXZvaWQgMDtpZihcImZsb2F0MzJcIj09PWEpZD1Gbih1LGksXCJmbG9hdDMyXCIpO2Vsc2UgaWYoXCJpbnQzMlwiPT09YSlkPUZuKHUsaSxcImludDMyXCIpO2Vsc2V7aWYoXCJib29sXCIhPT1hKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGR0eXBlIGluIHdlaWdodCAnXCIrbytcIic6IFwiK2EpO2Q9Rm4odSxpLFwiYm9vbFwiKX1uW29dPWR9LGE9MCxpPWU7YTxpLmxlbmd0aDthKyspe28oaVthXSl9cmV0dXJuIG59ZnVuY3Rpb24gd2ModCl7aWYobnVsbD09PXQpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB2YWx1ZTogXCIrSlNPTi5zdHJpbmdpZnkodCkpO3ZhciBlPTAsbj1bXTt0LmZvckVhY2goZnVuY3Rpb24odCl7aWYoZSs9dC5ieXRlTGVuZ3RoLG4ucHVzaCh0LmJ5dGVMZW5ndGg9PT10LmJ1ZmZlci5ieXRlTGVuZ3RoP3Q6bmV3IHQuY29uc3RydWN0b3IodCkpLCEodCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8dCBpbnN0YW5jZW9mIEludDMyQXJyYXl8fHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSl0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBUeXBlZEFycmF5IHN1YnR5cGU6IFwiK3QuY29uc3RydWN0b3IubmFtZSl9KTt2YXIgcj1uZXcgVWludDhBcnJheShlKSxvPTA7cmV0dXJuIG4uZm9yRWFjaChmdW5jdGlvbih0KXtyLnNldChuZXcgVWludDhBcnJheSh0LmJ1ZmZlciksbyksbys9dC5ieXRlTGVuZ3RofSksci5idWZmZXJ9dmFyIGJjPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBCdWZmZXImJihcInVuZGVmaW5lZFwiPT10eXBlb2YgQmxvYnx8XCJ1bmRlZmluZWRcIj09dHlwZW9mIGF0b2J8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBidG9hKTtmdW5jdGlvbiBDYyh0KXtyZXR1cm4gYmM/QnVmZmVyLmJ5dGVMZW5ndGgodCk6bmV3IEJsb2IoW3RdKS5zaXplfWZ1bmN0aW9uIEVjKHQpe3ZhciBlPTA7dC5mb3JFYWNoKGZ1bmN0aW9uKHQpe2UrPXQuYnl0ZUxlbmd0aH0pO3ZhciBuPW5ldyBVaW50OEFycmF5KGUpLHI9MDtyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe24uc2V0KG5ldyBVaW50OEFycmF5KHQpLHIpLHIrPXQuYnl0ZUxlbmd0aH0pLG4uYnVmZmVyfWZ1bmN0aW9uIFJjKHQpe2Zvcih0PXQudHJpbSgpO3QuZW5kc1dpdGgoXCIvXCIpOyl0PXQuc2xpY2UoMCx0Lmxlbmd0aC0xKTt2YXIgZT10LnNwbGl0KFwiL1wiKTtyZXR1cm4gZVtlLmxlbmd0aC0xXX1mdW5jdGlvbiBTYyh0KXtpZih0Lm1vZGVsVG9wb2xvZ3kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBKU09OIG1vZGVsIHRvcG9sb2d5LCByZWNlaXZlZCBBcnJheUJ1ZmZlci5cIik7cmV0dXJue2RhdGVTYXZlZDpuZXcgRGF0ZSxtb2RlbFRvcG9sb2d5VHlwZTpcIkpTT05cIixtb2RlbFRvcG9sb2d5Qnl0ZXM6bnVsbD09dC5tb2RlbFRvcG9sb2d5PzA6Q2MoSlNPTi5zdHJpbmdpZnkodC5tb2RlbFRvcG9sb2d5KSksd2VpZ2h0U3BlY3NCeXRlczpudWxsPT10LndlaWdodFNwZWNzPzA6Q2MoSlNPTi5zdHJpbmdpZnkodC53ZWlnaHRTcGVjcykpLHdlaWdodERhdGFCeXRlczpudWxsPT10LndlaWdodERhdGE/MDp0LndlaWdodERhdGEuYnl0ZUxlbmd0aH19dmFyIE5jPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMuc2F2ZVJvdXRlcnM9W10sdGhpcy5sb2FkUm91dGVycz1bXX1yZXR1cm4gdC5nZXRJbnN0YW5jZT1mdW5jdGlvbigpe3JldHVybiBudWxsPT10Lmluc3RhbmNlJiYodC5pbnN0YW5jZT1uZXcgdCksdC5pbnN0YW5jZX0sdC5yZWdpc3RlclNhdmVSb3V0ZXI9ZnVuY3Rpb24oZSl7dC5nZXRJbnN0YW5jZSgpLnNhdmVSb3V0ZXJzLnB1c2goZSl9LHQucmVnaXN0ZXJMb2FkUm91dGVyPWZ1bmN0aW9uKGUpe3QuZ2V0SW5zdGFuY2UoKS5sb2FkUm91dGVycy5wdXNoKGUpfSx0LmdldFNhdmVIYW5kbGVycz1mdW5jdGlvbihlKXtyZXR1cm4gdC5nZXRIYW5kbGVycyhlLFwic2F2ZVwiKX0sdC5nZXRMb2FkSGFuZGxlcnM9ZnVuY3Rpb24oZSxuKXtyZXR1cm4gdC5nZXRIYW5kbGVycyhlLFwibG9hZFwiLG4pfSx0LmdldEhhbmRsZXJzPWZ1bmN0aW9uKGUsbixyKXt2YXIgbz1bXTtyZXR1cm4oXCJsb2FkXCI9PT1uP3QuZ2V0SW5zdGFuY2UoKS5sb2FkUm91dGVyczp0LmdldEluc3RhbmNlKCkuc2F2ZVJvdXRlcnMpLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIG49dChlLHIpO251bGwhPT1uJiZvLnB1c2gobil9KSxvfSx0fSgpLGtjPVwiOi8vXCIsSWM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5tYW5hZ2Vycz17fX1yZXR1cm4gdC5nZXRJbnN0YW5jZT1mdW5jdGlvbigpe3JldHVybiBudWxsPT10Lmluc3RhbmNlJiYodC5pbnN0YW5jZT1uZXcgdCksdC5pbnN0YW5jZX0sdC5yZWdpc3Rlck1hbmFnZXI9ZnVuY3Rpb24oZSxuKXtkKG51bGwhPWUsZnVuY3Rpb24oKXtyZXR1cm5cInNjaGVtZSBtdXN0IG5vdCBiZSB1bmRlZmluZWQgb3IgbnVsbC5cIn0pLGUuZW5kc1dpdGgoa2MpJiYoZT1lLnNsaWNlKDAsZS5pbmRleE9mKGtjKSkpLGQoZS5sZW5ndGg+MCxmdW5jdGlvbigpe3JldHVyblwic2NoZW1lIG11c3Qgbm90IGJlIGFuIGVtcHR5IHN0cmluZy5cIn0pO3ZhciByPXQuZ2V0SW5zdGFuY2UoKTtkKG51bGw9PXIubWFuYWdlcnNbZV0sZnVuY3Rpb24oKXtyZXR1cm5cIkEgbW9kZWwgc3RvcmUgbWFuYWdlciBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yIHNjaGVtZSAnXCIrZStcIicuXCJ9KSxyLm1hbmFnZXJzW2VdPW59LHQuZ2V0TWFuYWdlcj1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldEluc3RhbmNlKCkubWFuYWdlcnNbdF07aWYobnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2RlbCBtYW5hZ2VyIGZvciBzY2hlbWUgJ1wiK3QrXCInXCIpO3JldHVybiBlfSx0LmdldFNjaGVtZXM9ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5nZXRJbnN0YW5jZSgpLm1hbmFnZXJzKX0sdH0oKTtmdW5jdGlvbiBBYyh0KXtpZigtMT09PXQuaW5kZXhPZihrYykpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHVybCBzdHJpbmcgcHJvdmlkZWQgZG9lcyBub3QgY29udGFpbiBhIHNjaGVtZS4gU3VwcG9ydGVkIHNjaGVtZXMgYXJlOiBcIitJYy5nZXRTY2hlbWVzKCkuam9pbihcIixcIikpO3JldHVybntzY2hlbWU6dC5zcGxpdChrYylbMF0scGF0aDp0LnNwbGl0KGtjKVsxXX19ZnVuY3Rpb24gVGModCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0hMSkscih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgcixhLGkscyx1LGwsYyxoLHA7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOnJldHVybiBkKHQhPT1lLGZ1bmN0aW9uKCl7cmV0dXJuXCJPbGQgcGF0aCBhbmQgbmV3IHBhdGggYXJlIHRoZSBzYW1lOiAnXCIrdCtcIidcIn0pLGQoKHI9TmMuZ2V0TG9hZEhhbmRsZXJzKHQpKS5sZW5ndGg+MCxmdW5jdGlvbigpe3JldHVyblwiQ29weWluZyBmYWlsZWQgYmVjYXVzZSBubyBsb2FkIGhhbmRsZXIgaXMgZm91bmQgZm9yIHNvdXJjZSBVUkwgXCIrdCtcIi5cIn0pLGQoci5sZW5ndGg8MixmdW5jdGlvbigpe3JldHVyblwiQ29weWluZyBmYWlsZWQgYmVjYXVzZSBtb3JlIHRoYW4gb25lIChcIityLmxlbmd0aCtcIikgbG9hZCBoYW5kbGVycyBmb3Igc291cmNlIFVSTCBcIit0K1wiLlwifSksYT1yWzBdLGQoKGk9TmMuZ2V0U2F2ZUhhbmRsZXJzKGUpKS5sZW5ndGg+MCxmdW5jdGlvbigpe3JldHVyblwiQ29weWluZyBmYWlsZWQgYmVjYXVzZSBubyBzYXZlIGhhbmRsZXIgaXMgZm91bmQgZm9yIGRlc3RpbmF0aW9uIFVSTCBcIitlK1wiLlwifSksZChpLmxlbmd0aDwyLGZ1bmN0aW9uKCl7cmV0dXJuXCJDb3B5aW5nIGZhaWxlZCBiZWNhdXNlIG1vcmUgdGhhbiBvbmUgKFwiK3IubGVuZ3RoK1wiKSBzYXZlIGhhbmRsZXJzIGZvciBkZXN0aW5hdGlvbiBVUkwgXCIrZStcIi5cIn0pLHM9aVswXSx1PUFjKHQpLnNjaGVtZSxsPUFjKHQpLnBhdGgsYz11PT09QWModCkuc2NoZW1lLFs0LGEubG9hZCgpXTtjYXNlIDE6cmV0dXJuIGg9by5zZW50KCksbiYmYz9bNCxJYy5nZXRNYW5hZ2VyKHUpLnJlbW92ZU1vZGVsKGwpXTpbMywzXTtjYXNlIDI6by5zZW50KCksby5sYWJlbD0zO2Nhc2UgMzpyZXR1cm5bNCxzLnNhdmUoaCldO2Nhc2UgNDpyZXR1cm4gcD1vLnNlbnQoKSwhbnx8Yz9bMyw2XTpbNCxJYy5nZXRNYW5hZ2VyKHUpLnJlbW92ZU1vZGVsKGwpXTtjYXNlIDU6by5zZW50KCksby5sYWJlbD02O2Nhc2UgNjpyZXR1cm5bMixwLm1vZGVsQXJ0aWZhY3RzSW5mb119fSl9KX12YXIgRGM9XCJtb2RlbHNfc3RvcmVcIixPYz1cIm1vZGVsX2luZm9fc3RvcmVcIjtmdW5jdGlvbiBfYygpe2lmKCFhLmdldEJvb2woXCJJU19CUk9XU0VSXCIpKXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBvYnRhaW4gSW5kZXhlZERCIGZhY3RvcnkgYmVjYXVzZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudGlzIG5vdCBhIHdlYiBicm93c2VyLlwiKTt2YXIgdD13aW5kb3csZT10LmluZGV4ZWREQnx8dC5tb3pJbmRleGVkREJ8fHQud2Via2l0SW5kZXhlZERCfHx0Lm1zSW5kZXhlZERCfHx0LnNoaW1JbmRleGVkREI7aWYobnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY3VycmVudCBicm93c2VyIGRvZXMgbm90IGFwcGVhciB0byBzdXBwb3J0IEluZGV4ZWREQi5cIik7cmV0dXJuIGV9ZnVuY3Rpb24gTWModCl7dmFyIGU9dC5yZXN1bHQ7ZS5jcmVhdGVPYmplY3RTdG9yZShEYyx7a2V5UGF0aDpcIm1vZGVsUGF0aFwifSksZS5jcmVhdGVPYmplY3RTdG9yZShPYyx7a2V5UGF0aDpcIm1vZGVsUGF0aFwifSl9dmFyIEZjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLmluZGV4ZWREQj1fYygpLG51bGw9PXR8fCF0KXRocm93IG5ldyBFcnJvcihcIkZvciBJbmRleGVkREIsIG1vZGVsUGF0aCBtdXN0IG5vdCBiZSBudWxsLCB1bmRlZmluZWQgb3IgZW1wdHkuXCIpO3RoaXMubW9kZWxQYXRoPXR9cmV0dXJuIHQucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24odCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihlKXtpZih0Lm1vZGVsVG9wb2xvZ3kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyTG9jYWxTdG9yYWdlLnNhdmUoKSBkb2VzIG5vdCBzdXBwb3J0IHNhdmluZyBtb2RlbCB0b3BvbG9neSBpbiBiaW5hcnkgZm9ybWF0cyB5ZXQuXCIpO3JldHVyblsyLHRoaXMuZGF0YWJhc2VBY3Rpb24odGhpcy5tb2RlbFBhdGgsdCldfSl9KX0sdC5wcm90b3R5cGUubG9hZD1mdW5jdGlvbigpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBvKHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuWzIsdGhpcy5kYXRhYmFzZUFjdGlvbih0aGlzLm1vZGVsUGF0aCldfSl9KX0sdC5wcm90b3R5cGUuZGF0YWJhc2VBY3Rpb249ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbih0LHIpe3ZhciBvPW4uaW5kZXhlZERCLm9wZW4oXCJ0ZW5zb3JmbG93anNcIiwxKTtvLm9udXBncmFkZW5lZWRlZD1mdW5jdGlvbigpe3JldHVybiBNYyhvKX0sby5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgYT1vLnJlc3VsdDtpZihudWxsPT1lKXt2YXIgaT1hLnRyYW5zYWN0aW9uKERjLFwicmVhZG9ubHlcIikscz1pLm9iamVjdFN0b3JlKERjKS5nZXQobi5tb2RlbFBhdGgpO3Mub25zdWNjZXNzPWZ1bmN0aW9uKCl7aWYobnVsbD09cy5yZXN1bHQpcmV0dXJuIGEuY2xvc2UoKSxyKG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZGVsIHdpdGggcGF0aCAnXCIrbi5tb2RlbFBhdGgrXCInIGluIEluZGV4ZWREQi5cIikpO3Qocy5yZXN1bHQubW9kZWxBcnRpZmFjdHMpfSxzLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIGEuY2xvc2UoKSxyKHMuZXJyb3IpfSxpLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtyZXR1cm4gYS5jbG9zZSgpfX1lbHNle3ZhciB1LGw9U2MoZSksYz1hLnRyYW5zYWN0aW9uKE9jLFwicmVhZHdyaXRlXCIpLGg9Yy5vYmplY3RTdG9yZShPYykscD1oLnB1dCh7bW9kZWxQYXRoOm4ubW9kZWxQYXRoLG1vZGVsQXJ0aWZhY3RzSW5mbzpsfSk7cC5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgbz0odT1hLnRyYW5zYWN0aW9uKERjLFwicmVhZHdyaXRlXCIpKS5vYmplY3RTdG9yZShEYykucHV0KHttb2RlbFBhdGg6bi5tb2RlbFBhdGgsbW9kZWxBcnRpZmFjdHM6ZSxtb2RlbEFydGlmYWN0c0luZm86bH0pO28ub25zdWNjZXNzPWZ1bmN0aW9uKCl7cmV0dXJuIHQoe21vZGVsQXJ0aWZhY3RzSW5mbzpsfSl9LG8ub25lcnJvcj1mdW5jdGlvbih0KXt2YXIgZT0oaD1jLm9iamVjdFN0b3JlKE9jKSkuZGVsZXRlKG4ubW9kZWxQYXRoKTtlLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3JldHVybiBhLmNsb3NlKCkscihvLmVycm9yKX0sZS5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiBhLmNsb3NlKCkscihvLmVycm9yKX19fSxwLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIGEuY2xvc2UoKSxyKHAuZXJyb3IpfSxjLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtudWxsPT11P2EuY2xvc2UoKTp1Lm9uY29tcGxldGU9ZnVuY3Rpb24oKXtyZXR1cm4gYS5jbG9zZSgpfX19fSxvLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIHIoby5lcnJvcil9fSl9LHQuVVJMX1NDSEVNRT1cImluZGV4ZWRkYjovL1wiLHR9KCksQmM9ZnVuY3Rpb24odCl7cmV0dXJuIGEuZ2V0Qm9vbChcIklTX0JST1dTRVJcIikmJiFBcnJheS5pc0FycmF5KHQpJiZ0LnN0YXJ0c1dpdGgoRmMuVVJMX1NDSEVNRSk/KGU9dC5zbGljZShGYy5VUkxfU0NIRU1FLmxlbmd0aCksbmV3IEZjKGUpKTpudWxsO3ZhciBlfTtOYy5yZWdpc3RlclNhdmVSb3V0ZXIoQmMpLE5jLnJlZ2lzdGVyTG9hZFJvdXRlcihCYyk7dmFyIFBjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMuaW5kZXhlZERCPV9jKCl9cmV0dXJuIHQucHJvdG90eXBlLmxpc3RNb2RlbHM9ZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiBvKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuWzIsbmV3IFByb21pc2UoZnVuY3Rpb24oZSxuKXt2YXIgcj10LmluZGV4ZWREQi5vcGVuKFwidGVuc29yZmxvd2pzXCIsMSk7ci5vbnVwZ3JhZGVuZWVkZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gTWMocil9LHIub25zdWNjZXNzPWZ1bmN0aW9uKCl7dmFyIHQ9ci5yZXN1bHQsbz10LnRyYW5zYWN0aW9uKE9jLFwicmVhZG9ubHlcIiksYT1vLm9iamVjdFN0b3JlKE9jKS5nZXRBbGwoKTthLm9uc3VjY2Vzcz1mdW5jdGlvbigpe2Zvcih2YXIgdD17fSxuPTAscj1hLnJlc3VsdDtuPHIubGVuZ3RoO24rKyl7dmFyIG89cltuXTt0W28ubW9kZWxQYXRoXT1vLm1vZGVsQXJ0aWZhY3RzSW5mb31lKHQpfSxhLm9uZXJyb3I9ZnVuY3Rpb24oZSl7cmV0dXJuIHQuY2xvc2UoKSxuKGEuZXJyb3IpfSxvLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtyZXR1cm4gdC5jbG9zZSgpfX0sci5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiBuKHIuZXJyb3IpfX0pXX0pfSl9LHQucHJvdG90eXBlLnJlbW92ZU1vZGVsPWZ1bmN0aW9uKHQpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gdD0ocj10KS5zdGFydHNXaXRoKEZjLlVSTF9TQ0hFTUUpP3Iuc2xpY2UoRmMuVVJMX1NDSEVNRS5sZW5ndGgpOnIsWzIsbmV3IFByb21pc2UoZnVuY3Rpb24obixyKXt2YXIgbz1lLmluZGV4ZWREQi5vcGVuKFwidGVuc29yZmxvd2pzXCIsMSk7by5vbnVwZ3JhZGVuZWVkZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gTWMobyl9LG8ub25zdWNjZXNzPWZ1bmN0aW9uKCl7dmFyIGUsYT1vLnJlc3VsdCxpPWEudHJhbnNhY3Rpb24oT2MsXCJyZWFkd3JpdGVcIikscz1pLm9iamVjdFN0b3JlKE9jKSx1PXMuZ2V0KHQpO3Uub25zdWNjZXNzPWZ1bmN0aW9uKCl7aWYobnVsbD09dS5yZXN1bHQpcmV0dXJuIGEuY2xvc2UoKSxyKG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZGVsIHdpdGggcGF0aCAnXCIrdCtcIicgaW4gSW5kZXhlZERCLlwiKSk7dmFyIG89cy5kZWxldGUodCksaT1mdW5jdGlvbigpe3ZhciBvPShlPWEudHJhbnNhY3Rpb24oRGMsXCJyZWFkd3JpdGVcIikpLm9iamVjdFN0b3JlKERjKS5kZWxldGUodCk7by5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXtyZXR1cm4gbih1LnJlc3VsdC5tb2RlbEFydGlmYWN0c0luZm8pfSxvLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIHIodS5lcnJvcil9fTtvLm9uc3VjY2Vzcz1pLG8ub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gaSgpLGEuY2xvc2UoKSxyKHUuZXJyb3IpfX0sdS5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiBhLmNsb3NlKCkscih1LmVycm9yKX0saS5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7bnVsbD09ZT9hLmNsb3NlKCk6ZS5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7cmV0dXJuIGEuY2xvc2UoKX19fSxvLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIHIoby5lcnJvcil9fSldfSl9KX0sdH0oKTtpZihhLmdldEJvb2woXCJJU19CUk9XU0VSXCIpKXRyeXtJYy5yZWdpc3Rlck1hbmFnZXIoRmMuVVJMX1NDSEVNRSxuZXcgUGMpfWNhdGNoKHQpe312YXIgTGM9XCIvXCIsV2M9XCJ0ZW5zb3JmbG93anNfbW9kZWxzXCIsVWM9XCJpbmZvXCIsemM9XCJtb2RlbF90b3BvbG9neVwiLFZjPVwid2VpZ2h0X3NwZWNzXCIsR2M9XCJ3ZWlnaHRfZGF0YVwiLHFjPVwibW9kZWxfbWV0YWRhdGFcIjtmdW5jdGlvbiBIYyh0KXtyZXR1cm57aW5mbzpbV2MsdCxVY10uam9pbihMYyksdG9wb2xvZ3k6W1djLHQsemNdLmpvaW4oTGMpLHdlaWdodFNwZWNzOltXYyx0LFZjXS5qb2luKExjKSx3ZWlnaHREYXRhOltXYyx0LEdjXS5qb2luKExjKSxtb2RlbE1ldGFkYXRhOltXYyx0LHFjXS5qb2luKExjKX19ZnVuY3Rpb24gJGModCl7dmFyIGU9dC5zcGxpdChMYyk7aWYoZS5sZW5ndGg8Myl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGtleSBmb3JtYXQ6IFwiK3QpO3JldHVybiBlLnNsaWNlKDEsZS5sZW5ndGgtMSkuam9pbihMYyl9dmFyIGpjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZighYS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKXx8dm9pZCAwPT09d2luZG93LmxvY2FsU3RvcmFnZSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IGxvY2FsIHN0b3JhZ2UuXCIpO2lmKHRoaXMuTFM9d2luZG93LmxvY2FsU3RvcmFnZSxudWxsPT10fHwhdCl0aHJvdyBuZXcgRXJyb3IoXCJGb3IgbG9jYWwgc3RvcmFnZSwgbW9kZWxQYXRoIG11c3Qgbm90IGJlIG51bGwsIHVuZGVmaW5lZCBvciBlbXB0eS5cIik7dGhpcy5tb2RlbFBhdGg9dCx0aGlzLmtleXM9SGModGhpcy5tb2RlbFBhdGgpfXJldHVybiB0LnByb3RvdHlwZS5zYXZlPWZ1bmN0aW9uKHQpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLG4scjtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG8pe2lmKHQubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXJMb2NhbFN0b3JhZ2Uuc2F2ZSgpIGRvZXMgbm90IHN1cHBvcnQgc2F2aW5nIG1vZGVsIHRvcG9sb2d5IGluIGJpbmFyeSBmb3JtYXRzIHlldC5cIik7ZT1KU09OLnN0cmluZ2lmeSh0Lm1vZGVsVG9wb2xvZ3kpLG49SlNPTi5zdHJpbmdpZnkodC53ZWlnaHRTcGVjcykscj1TYyh0KTt0cnl7cmV0dXJuIHRoaXMuTFMuc2V0SXRlbSh0aGlzLmtleXMuaW5mbyxKU09OLnN0cmluZ2lmeShyKSksdGhpcy5MUy5zZXRJdGVtKHRoaXMua2V5cy50b3BvbG9neSxlKSx0aGlzLkxTLnNldEl0ZW0odGhpcy5rZXlzLndlaWdodFNwZWNzLG4pLHRoaXMuTFMuc2V0SXRlbSh0aGlzLmtleXMud2VpZ2h0RGF0YSwoYT10LndlaWdodERhdGEsYmM/QnVmZmVyLmZyb20oYSkudG9TdHJpbmcoXCJiYXNlNjRcIik6YnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsbmV3IFVpbnQ4QXJyYXkoYSkpKSkpLHRoaXMuTFMuc2V0SXRlbSh0aGlzLmtleXMubW9kZWxNZXRhZGF0YSxKU09OLnN0cmluZ2lmeSh7Zm9ybWF0OnQuZm9ybWF0LGdlbmVyYXRlZEJ5OnQuZ2VuZXJhdGVkQnksY29udmVydGVkQnk6dC5jb252ZXJ0ZWRCeX0pKSxbMix7bW9kZWxBcnRpZmFjdHNJbmZvOnJ9XX1jYXRjaCh0KXt0aHJvdyB0aGlzLkxTLnJlbW92ZUl0ZW0odGhpcy5rZXlzLmluZm8pLHRoaXMuTFMucmVtb3ZlSXRlbSh0aGlzLmtleXMudG9wb2xvZ3kpLHRoaXMuTFMucmVtb3ZlSXRlbSh0aGlzLmtleXMud2VpZ2h0U3BlY3MpLHRoaXMuTFMucmVtb3ZlSXRlbSh0aGlzLmtleXMud2VpZ2h0RGF0YSksdGhpcy5MUy5yZW1vdmVJdGVtKHRoaXMua2V5cy5tb2RlbE1ldGFkYXRhKSxuZXcgRXJyb3IoXCJGYWlsZWQgdG8gc2F2ZSBtb2RlbCAnXCIrdGhpcy5tb2RlbFBhdGgrXCInIHRvIGxvY2FsIHN0b3JhZ2U6IHNpemUgcXVvdGEgYmVpbmcgZXhjZWVkZWQgaXMgYSBwb3NzaWJsZSBjYXVzZSBvZiB0aGlzIGZhaWx1cmU6IG1vZGVsVG9wb2xvZ3lCeXRlcz1cIityLm1vZGVsVG9wb2xvZ3lCeXRlcytcIiwgd2VpZ2h0U3BlY3NCeXRlcz1cIityLndlaWdodFNwZWNzQnl0ZXMrXCIsIHdlaWdodERhdGFCeXRlcz1cIityLndlaWdodERhdGFCeXRlcytcIi5cIil9dmFyIGE7cmV0dXJuWzJdfSl9KX0sdC5wcm90b3R5cGUubG9hZD1mdW5jdGlvbigpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGUsbixyLGEsaSxzO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obyl7aWYobnVsbD09KHQ9SlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLmluZm8pKSkpdGhyb3cgbmV3IEVycm9yKFwiSW4gbG9jYWwgc3RvcmFnZSwgdGhlcmUgaXMgbm8gbW9kZWwgd2l0aCBuYW1lICdcIit0aGlzLm1vZGVsUGF0aCtcIidcIik7aWYoXCJKU09OXCIhPT10Lm1vZGVsVG9wb2xvZ3lUeXBlKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXJMb2NhbFN0b3JhZ2UgZG9lcyBub3Qgc3VwcG9ydCBsb2FkaW5nIG5vbi1KU09OIG1vZGVsIHRvcG9sb2d5IHlldC5cIik7aWYoZT17fSxudWxsPT0obj1KU09OLnBhcnNlKHRoaXMuTFMuZ2V0SXRlbSh0aGlzLmtleXMudG9wb2xvZ3kpKSkpdGhyb3cgbmV3IEVycm9yKFwiSW4gbG9jYWwgc3RvcmFnZSwgdGhlIHRvcG9sb2d5IG9mIG1vZGVsICdcIit0aGlzLm1vZGVsUGF0aCtcIicgaXMgbWlzc2luZy5cIik7aWYoZS5tb2RlbFRvcG9sb2d5PW4sbnVsbD09KHI9SlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLndlaWdodFNwZWNzKSkpKXRocm93IG5ldyBFcnJvcihcIkluIGxvY2FsIHN0b3JhZ2UsIHRoZSB3ZWlnaHQgc3BlY3Mgb2YgbW9kZWwgJ1wiK3RoaXMubW9kZWxQYXRoK1wiJyBhcmUgbWlzc2luZy5cIik7aWYoZS53ZWlnaHRTcGVjcz1yLG51bGwhPShhPXRoaXMuTFMuZ2V0SXRlbSh0aGlzLmtleXMubW9kZWxNZXRhZGF0YSkpJiYoaT1KU09OLnBhcnNlKGEpLGUuZm9ybWF0PWkuZm9ybWF0LGUuZ2VuZXJhdGVkQnk9aS5nZW5lcmF0ZWRCeSxlLmNvbnZlcnRlZEJ5PWkuY29udmVydGVkQnkpLG51bGw9PShzPXRoaXMuTFMuZ2V0SXRlbSh0aGlzLmtleXMud2VpZ2h0RGF0YSkpKXRocm93IG5ldyBFcnJvcihcIkluIGxvY2FsIHN0b3JhZ2UsIHRoZSBiaW5hcnkgd2VpZ2h0IHZhbHVlcyBvZiBtb2RlbCAnXCIrdGhpcy5tb2RlbFBhdGgrXCInIGFyZSBtaXNzaW5nLlwiKTtyZXR1cm4gZS53ZWlnaHREYXRhPWZ1bmN0aW9uKHQpe2lmKGJjKXt2YXIgZT1CdWZmZXIuZnJvbSh0LFwiYmFzZTY0XCIpO3JldHVybiBlLmJ1ZmZlci5zbGljZShlLmJ5dGVPZmZzZXQsZS5ieXRlT2Zmc2V0K2UuYnl0ZUxlbmd0aCl9Zm9yKHZhciBuPWF0b2IodCkscj1uZXcgVWludDhBcnJheShuLmxlbmd0aCksbz0wO288bi5sZW5ndGg7KytvKXIuc2V0KFtuLmNoYXJDb2RlQXQobyldLG8pO3JldHVybiByLmJ1ZmZlcn0ocyksWzIsZV19KX0pfSx0LlVSTF9TQ0hFTUU9XCJsb2NhbHN0b3JhZ2U6Ly9cIix0fSgpLEtjPWZ1bmN0aW9uKHQpe3JldHVybiBhLmdldEJvb2woXCJJU19CUk9XU0VSXCIpJiYhQXJyYXkuaXNBcnJheSh0KSYmdC5zdGFydHNXaXRoKGpjLlVSTF9TQ0hFTUUpPyhlPXQuc2xpY2UoamMuVVJMX1NDSEVNRS5sZW5ndGgpLG5ldyBqYyhlKSk6bnVsbDt2YXIgZX07TmMucmVnaXN0ZXJTYXZlUm91dGVyKEtjKSxOYy5yZWdpc3RlckxvYWRSb3V0ZXIoS2MpO3ZhciBYYz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXtkKGEuZ2V0Qm9vbChcIklTX0JST1dTRVJcIiksZnVuY3Rpb24oKXtyZXR1cm5cIkN1cnJlbnQgZW52aXJvbm1lbnQgaXMgbm90IGEgd2ViIGJyb3dzZXJcIn0pLGQodm9pZCAwIT09d2luZG93LmxvY2FsU3RvcmFnZSxmdW5jdGlvbigpe3JldHVyblwiQ3VycmVudCBicm93c2VyIGRvZXMgbm90IGFwcGVhciB0byBzdXBwb3J0IGxvY2FsU3RvcmFnZVwifSksdGhpcy5MUz13aW5kb3cubG9jYWxTdG9yYWdlfXJldHVybiB0LnByb3RvdHlwZS5saXN0TW9kZWxzPWZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZSxuLHIsYSxpO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obyl7Zm9yKHQ9e30sZT1XYytMYyxuPUxjK1VjLHI9MDtyPHRoaXMuTFMubGVuZ3RoOysrcikoYT10aGlzLkxTLmtleShyKSkuc3RhcnRzV2l0aChlKSYmYS5lbmRzV2l0aChuKSYmKGk9JGMoYSksdFtpXT1KU09OLnBhcnNlKHRoaXMuTFMuZ2V0SXRlbShhKSkpO3JldHVyblsyLHRdfSl9KX0sdC5wcm90b3R5cGUucmVtb3ZlTW9kZWw9ZnVuY3Rpb24odCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsbjtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKHIpe3ZhciBvO2lmKHQ9KG89dCkuc3RhcnRzV2l0aChqYy5VUkxfU0NIRU1FKT9vLnNsaWNlKGpjLlVSTF9TQ0hFTUUubGVuZ3RoKTpvLGU9SGModCksbnVsbD09dGhpcy5MUy5nZXRJdGVtKGUuaW5mbykpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kZWwgYXQgcGF0aCAnXCIrdCtcIidcIik7cmV0dXJuIG49SlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0oZS5pbmZvKSksdGhpcy5MUy5yZW1vdmVJdGVtKGUuaW5mbyksdGhpcy5MUy5yZW1vdmVJdGVtKGUudG9wb2xvZ3kpLHRoaXMuTFMucmVtb3ZlSXRlbShlLndlaWdodFNwZWNzKSx0aGlzLkxTLnJlbW92ZUl0ZW0oZS53ZWlnaHREYXRhKSxbMixuXX0pfSl9LHR9KCk7aWYoYS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSl0cnl7SWMucmVnaXN0ZXJNYW5hZ2VyKGpjLlVSTF9TQ0hFTUUsbmV3IFhjKX1jYXRjaCh0KXt9dmFyIFljPVwibW9kZWxcIixRYz1cIi5qc29uXCIsSmM9XCIud2VpZ2h0cy5iaW5cIjtmdW5jdGlvbiBaYyh0KXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24odCl7cmV0dXJuIHNldFRpbWVvdXQodCl9KS50aGVuKHQpfXZhciB0aD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7aWYoIWEuZ2V0Qm9vbChcIklTX0JST1dTRVJcIikpdGhyb3cgbmV3IEVycm9yKFwiYnJvd3NlckRvd25sb2FkcygpIGNhbm5vdCBwcm9jZWVkIGJlY2F1c2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgaXMgbm90IGEgYnJvd3Nlci5cIik7ZS5zdGFydHNXaXRoKHQuVVJMX1NDSEVNRSkmJihlPWUuc2xpY2UodC5VUkxfU0NIRU1FLmxlbmd0aCkpLG51bGwhPWUmJjAhPT1lLmxlbmd0aHx8KGU9WWMpLHRoaXMubW9kZWxUb3BvbG9neUZpbGVOYW1lPWUrUWMsdGhpcy53ZWlnaHREYXRhRmlsZU5hbWU9ZStKY31yZXR1cm4gdC5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbih0KXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxuLHIsYSxpLHM7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOmlmKGU9d2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3Qud2VpZ2h0RGF0YV0se3R5cGU6XCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIn0pKSwhKHQubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSlyZXR1cm5bMywxXTt0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyRG93bmxvYWRzLnNhdmUoKSBkb2VzIG5vdCBzdXBwb3J0IHNhdmluZyBtb2RlbCB0b3BvbG9neSBpbiBiaW5hcnkgZm9ybWF0cyB5ZXQuXCIpO2Nhc2UgMTpyZXR1cm4gbj1be3BhdGhzOltcIi4vXCIrdGhpcy53ZWlnaHREYXRhRmlsZU5hbWVdLHdlaWdodHM6dC53ZWlnaHRTcGVjc31dLHI9e21vZGVsVG9wb2xvZ3k6dC5tb2RlbFRvcG9sb2d5LGZvcm1hdDp0LmZvcm1hdCxnZW5lcmF0ZWRCeTp0LmdlbmVyYXRlZEJ5LGNvbnZlcnRlZEJ5OnQuY29udmVydGVkQnksd2VpZ2h0c01hbmlmZXN0Om59LGE9d2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KHIpXSx7dHlwZTpcImFwcGxpY2F0aW9uL2pzb25cIn0pKSwoaT1udWxsPT10aGlzLmpzb25BbmNob3I/ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik6dGhpcy5qc29uQW5jaG9yKS5kb3dubG9hZD10aGlzLm1vZGVsVG9wb2xvZ3lGaWxlTmFtZSxpLmhyZWY9YSxbNCxaYyhmdW5jdGlvbigpe3JldHVybiBpLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiKSl9KV07Y2FzZSAyOnJldHVybiBvLnNlbnQoKSxudWxsPT10LndlaWdodERhdGE/WzMsNF06KChzPW51bGw9PXRoaXMud2VpZ2h0RGF0YUFuY2hvcj9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTp0aGlzLndlaWdodERhdGFBbmNob3IpLmRvd25sb2FkPXRoaXMud2VpZ2h0RGF0YUZpbGVOYW1lLHMuaHJlZj1lLFs0LFpjKGZ1bmN0aW9uKCl7cmV0dXJuIHMuZGlzcGF0Y2hFdmVudChuZXcgTW91c2VFdmVudChcImNsaWNrXCIpKX0pXSk7Y2FzZSAzOm8uc2VudCgpLG8ubGFiZWw9NDtjYXNlIDQ6cmV0dXJuWzIse21vZGVsQXJ0aWZhY3RzSW5mbzpTYyh0KX1dfX0pfSl9LHQuVVJMX1NDSEVNRT1cImRvd25sb2FkczovL1wiLHR9KCksZWg9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKG51bGw9PXR8fHQubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBjYWxsaW5nIGJyb3dzZXJGaWxlcywgYXQgbGVhc3QgMSBmaWxlIGlzIHJlcXVpcmVkLCBidXQgcmVjZWl2ZWQgXCIrdCk7dGhpcy5maWxlcz10fXJldHVybiB0LnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZSxuPXRoaXM7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihyKXtyZXR1cm4gdD10aGlzLmZpbGVzWzBdLGU9dGhpcy5maWxlcy5zbGljZSgxKSxbMixuZXcgUHJvbWlzZShmdW5jdGlvbihyLG8pe3ZhciBhPW5ldyBGaWxlUmVhZGVyO2Eub25sb2FkPWZ1bmN0aW9uKGEpe3ZhciBpPUpTT04ucGFyc2UoYS50YXJnZXQucmVzdWx0KSxzPWkubW9kZWxUb3BvbG9neTtpZihudWxsIT1zKXswPT09ZS5sZW5ndGgmJnIoe21vZGVsVG9wb2xvZ3k6c30pO3ZhciB1PWkud2VpZ2h0c01hbmlmZXN0O2lmKG51bGwhPXUpe3ZhciBsO3RyeXtsPW4uY2hlY2tNYW5pZmVzdEFuZFdlaWdodEZpbGVzKHUsZSl9Y2F0Y2godCl7cmV0dXJuIHZvaWQgbyh0KX12YXIgYz1bXSxoPVtdLHA9W107dS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QucGF0aHMuZm9yRWFjaChmdW5jdGlvbih0KXtoLnB1c2godCkscC5wdXNoKG51bGwpfSksYy5wdXNoLmFwcGx5KGMsdC53ZWlnaHRzKX0pLHUuZm9yRWFjaChmdW5jdGlvbih0KXt0LnBhdGhzLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIGU9bmV3IEZpbGVSZWFkZXI7ZS5vbmxvYWQ9ZnVuY3Rpb24oZSl7dmFyIG49ZS50YXJnZXQucmVzdWx0LG89aC5pbmRleE9mKHQpO3Bbb109biwtMT09PXAuaW5kZXhPZihudWxsKSYmcih7bW9kZWxUb3BvbG9neTpzLHdlaWdodFNwZWNzOmMsd2VpZ2h0RGF0YTpFYyhwKX0pfSxlLm9uZXJyb3I9ZnVuY3Rpb24oZSl7cmV0dXJuIG8oXCJGYWlsZWQgdG8gd2VpZ2h0cyBkYXRhIGZyb20gZmlsZSBvZiBwYXRoICdcIit0K1wiJy5cIil9LGUucmVhZEFzQXJyYXlCdWZmZXIobFt0XSl9KX0pfWVsc2UgbyhuZXcgRXJyb3IoXCJ3ZWlnaHRNYW5pZmVzdCBmaWVsZCBpcyBtaXNzaW5nIGZyb20gZmlsZSBcIit0Lm5hbWUpKX1lbHNlIG8obmV3IEVycm9yKFwibW9kZWxUb3BvbG9neSBmaWVsZCBpcyBtaXNzaW5nIGZyb20gZmlsZSBcIit0Lm5hbWUpKX0sYS5vbmVycm9yPWZ1bmN0aW9uKGUpe3JldHVybiBvKFwiRmFpbGVkIHRvIHJlYWQgbW9kZWwgdG9wb2xvZ3kgYW5kIHdlaWdodHMgbWFuaWZlc3QgSlNPTiBmcm9tIGZpbGUgJ1wiK3QubmFtZStcIicuIEJyb3dzZXJGaWxlcyBzdXBwb3J0cyBsb2FkaW5nIEtlcmFzLXN0eWxlIHRmLk1vZGVsIGFydGlmYWN0cyBvbmx5LlwiKX0sYS5yZWFkQXNUZXh0KHQpfSldfSl9KX0sdC5wcm90b3R5cGUuY2hlY2tNYW5pZmVzdEFuZFdlaWdodEZpbGVzPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPVtdLHI9ZS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIFJjKHQubmFtZSl9KSxvPXt9LGE9MCxpPXQ7YTxpLmxlbmd0aDthKyspe2lbYV0ucGF0aHMuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgYT1SYyh0KTtpZigtMSE9PW4uaW5kZXhPZihhKSl0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgZmlsZSBiYXNlbmFtZSBmb3VuZCBpbiB3ZWlnaHRzIG1hbmlmZXN0OiAnXCIrYStcIidcIik7aWYobi5wdXNoKGEpLC0xPT09ci5pbmRleE9mKGEpKXRocm93IG5ldyBFcnJvcihcIldlaWdodCBmaWxlIHdpdGggYmFzZW5hbWUgJ1wiK2ErXCInIGlzIG5vdCBwcm92aWRlZC5cIik7b1t0XT1lW3IuaW5kZXhPZihhKV19KX1pZihuLmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoIGluIHRoZSBudW1iZXIgb2YgZmlsZXMgaW4gd2VpZ2h0cyBtYW5pZmVzdCAoXCIrbi5sZW5ndGgrXCIpIGFuZCB0aGUgbnVtYmVyIG9mIHdlaWdodCBmaWxlcyBwcm92aWRlZCAoXCIrZS5sZW5ndGgrXCIpLlwiKTtyZXR1cm4gb30sdH0oKTtmdW5jdGlvbiBuaCh0LGUsbixyKXshZnVuY3Rpb24odCl7ZChudWxsIT10JiZBcnJheS5pc0FycmF5KHQpJiZ0Lmxlbmd0aD4wLGZ1bmN0aW9uKCl7cmV0dXJuXCJwcm9taXNlcyBtdXN0IGJlIGEgbm9uZSBlbXB0eSBhcnJheVwifSl9KHQpLGZ1bmN0aW9uKHQsZSl7ZCh0Pj0wJiZ0PD0xLGZ1bmN0aW9uKCl7cmV0dXJuXCJQcm9ncmVzcyBmcmFjdGlvbiBtdXN0IGJlIGluIHJhbmdlIFswLCAxXSwgYnV0IGdvdCBzdGFydEZyYWN0aW9uIFwiK3R9KSxkKGU+PTAmJmU8PTEsZnVuY3Rpb24oKXtyZXR1cm5cIlByb2dyZXNzIGZyYWN0aW9uIG11c3QgYmUgaW4gcmFuZ2UgWzAsIDFdLCBidXQgZ290IGVuZEZyYWN0aW9uIFwiK2V9KSxkKGU+PXQsZnVuY3Rpb24oKXtyZXR1cm5cInN0YXJ0RnJhY3Rpb24gbXVzdCBiZSBubyBtb3JlIHRoYW4gZW5kRnJhY3Rpb24sIGJ1dCBnb3Qgc3RhcnRGcmFjdGlvbiBcIit0K1wiIGFuZCBlbmRGcmFjdGlvbiBcIitlfSl9KG49bnVsbD09bj8wOm4scj1udWxsPT1yPzE6cik7dmFyIG89MDtyZXR1cm4gUHJvbWlzZS5hbGwodC5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIGEudGhlbihmdW5jdGlvbihhKXt2YXIgaT1uKyArK28vdC5sZW5ndGgqKHItbik7cmV0dXJuIGUoaSksYX0pLGF9KSl9ZnVuY3Rpb24gcmgodCxlKXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbixyLGEsaSxzLHUsbCxjLGg7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOnJldHVybiBudWxsPT1lJiYoZT17fSksbj1udWxsPT1lLmZldGNoRnVuYz9KOmUuZmV0Y2hGdW5jLHI9dC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIG4odCxlLnJlcXVlc3RJbml0KX0pLGE9MCxpPS41LG51bGwhPWUub25Qcm9ncmVzcz9bMywyXTpbNCxQcm9taXNlLmFsbChyKV07Y2FzZSAxOnJldHVybiBzPW8uc2VudCgpLFszLDRdO2Nhc2UgMjpyZXR1cm5bNCxuaChyLGUub25Qcm9ncmVzcyxhLGkpXTtjYXNlIDM6cz1vLnNlbnQoKSxvLmxhYmVsPTQ7Y2FzZSA0OnJldHVybiB1PXMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFycmF5QnVmZmVyKCl9KSxsPS41LGM9MSxudWxsIT1lLm9uUHJvZ3Jlc3M/WzMsNl06WzQsUHJvbWlzZS5hbGwodSldO2Nhc2UgNTpyZXR1cm4gaD1vLnNlbnQoKSxbMyw4XTtjYXNlIDY6cmV0dXJuWzQsbmgodSxlLm9uUHJvZ3Jlc3MsbCxjKV07Y2FzZSA3Omg9by5zZW50KCksby5sYWJlbD04O2Nhc2UgODpyZXR1cm5bMixoXX19KX0pfWZ1bmN0aW9uIG9oKHQpe3ZhciBlPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKG4sYSxpKXtyZXR1cm4gdm9pZCAwPT09YSYmKGE9XCJcIikscihlLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxyLHMsdSxsLGMsaCxwLGYsZDtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6aWYoZT1uLm1hcChmdW5jdGlvbigpe3JldHVybiExfSkscj17fSxzPW51bGwhPWk/aS5tYXAoZnVuY3Rpb24oKXtyZXR1cm4hMX0pOltdLHU9W10sbi5mb3JFYWNoKGZ1bmN0aW9uKHQsbil7dmFyIG89MDt0LndlaWdodHMuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgYT1cInF1YW50aXphdGlvblwiaW4gdD90LnF1YW50aXphdGlvbi5kdHlwZTp0LmR0eXBlLGw9eWNbYV0qeSh0LnNoYXBlKSxjPWZ1bmN0aW9uKCl7ZVtuXT0hMCxudWxsPT1yW25dJiYocltuXT1bXSkscltuXS5wdXNoKHttYW5pZmVzdEVudHJ5OnQsZ3JvdXBPZmZzZXQ6byxzaXplQnl0ZXM6bH0pfTtudWxsIT1pP2kuZm9yRWFjaChmdW5jdGlvbihlLG4pe2U9PT10Lm5hbWUmJihjKCksc1tuXT0hMCl9KTpjKCksdS5wdXNoKHQubmFtZSksbys9bH0pfSksIXMuZXZlcnkoZnVuY3Rpb24odCl7cmV0dXJuIHR9KSl0aHJvdyBsPWkuZmlsdGVyKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIXNbZV19KSxuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCB3ZWlnaHRzIGluIG1hbmlmZXN0IHdpdGggbmFtZXM6IFwiK2wuam9pbihcIiwgXCIpK1wiLiBcXG5NYW5pZmVzdCBKU09OIGhhcyB3ZWlnaHRzIHdpdGggbmFtZXM6IFwiK3Uuam9pbihcIiwgXCIpK1wiLlwiKTtyZXR1cm4gYz1lLnJlZHVjZShmdW5jdGlvbih0LGUsbil7cmV0dXJuIGUmJnQucHVzaChuKSx0fSxbXSksaD1bXSxjLmZvckVhY2goZnVuY3Rpb24odCl7blt0XS5wYXRocy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBlPWErKGEuZW5kc1dpdGgoXCIvXCIpP1wiXCI6XCIvXCIpK3Q7aC5wdXNoKGUpfSl9KSxbNCx0KGgpXTtjYXNlIDE6cmV0dXJuIHA9by5zZW50KCksZj17fSxkPTAsYy5mb3JFYWNoKGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uW3RdLnBhdGhzLmxlbmd0aCxvPTAsYT0wO2E8ZTthKyspbys9cFtkK2FdLmJ5dGVMZW5ndGg7Zm9yKHZhciBpPW5ldyBBcnJheUJ1ZmZlcihvKSxzPW5ldyBVaW50OEFycmF5KGkpLHU9MCxsPTA7bDxlO2wrKyl7dmFyIGM9bmV3IFVpbnQ4QXJyYXkocFtkK2xdKTtzLnNldChjLHUpLHUrPWMuYnl0ZUxlbmd0aH1yW3RdLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIGU9eGMoaS5zbGljZSh0Lmdyb3VwT2Zmc2V0LHQuZ3JvdXBPZmZzZXQrdC5zaXplQnl0ZXMpLFt0Lm1hbmlmZXN0RW50cnldKTtmb3IodmFyIG4gaW4gZSlmW25dPWVbbl19KSxkKz1lfSksWzIsZl19fSl9KX19TmMucmVnaXN0ZXJTYXZlUm91dGVyKGZ1bmN0aW9uKHQpe3JldHVybiBhLmdldEJvb2woXCJJU19CUk9XU0VSXCIpJiYhQXJyYXkuaXNBcnJheSh0KSYmdC5zdGFydHNXaXRoKHRoLlVSTF9TQ0hFTUUpPyhlPXQuc2xpY2UodGguVVJMX1NDSEVNRS5sZW5ndGgpLHZvaWQgMD09PWUmJihlPVwibW9kZWxcIiksbmV3IHRoKGUpKTpudWxsO3ZhciBlfSk7dmFyIGFoPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2lmKHRoaXMuREVGQVVMVF9NRVRIT0Q9XCJQT1NUXCIsbnVsbD09ZSYmKGU9e30pLHRoaXMud2VpZ2h0UGF0aFByZWZpeD1lLndlaWdodFBhdGhQcmVmaXgsdGhpcy5vblByb2dyZXNzPWUub25Qcm9ncmVzcyxudWxsIT1lLmZldGNoRnVuYz8oZChcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmZldGNoRnVuYyxmdW5jdGlvbigpe3JldHVyblwiTXVzdCBwYXNzIGEgZnVuY3Rpb24gdGhhdCBtYXRjaGVzIHRoZSBzaWduYXR1cmUgb2YgYGZldGNoYCAoc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkpXCJ9KSx0aGlzLmZldGNoPWUuZmV0Y2hGdW5jKTp0aGlzLmZldGNoPUosZChudWxsIT10JiZ0Lmxlbmd0aD4wLGZ1bmN0aW9uKCl7cmV0dXJuXCJVUkwgcGF0aCBmb3IgaHR0cCBtdXN0IG5vdCBiZSBudWxsLCB1bmRlZmluZWQgb3IgZW1wdHkuXCJ9KSxBcnJheS5pc0FycmF5KHQpJiZkKDI9PT10Lmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiVVJMIHBhdGhzIGZvciBodHRwIG11c3QgaGF2ZSBhIGxlbmd0aCBvZiAyLCAoYWN0dWFsIGxlbmd0aCBpcyBcIit0Lmxlbmd0aCtcIikuXCJ9KSx0aGlzLnBhdGg9dCxudWxsIT1lLnJlcXVlc3RJbml0JiZudWxsIT1lLnJlcXVlc3RJbml0LmJvZHkpdGhyb3cgbmV3IEVycm9yKFwicmVxdWVzdEluaXQgaXMgZXhwZWN0ZWQgdG8gaGF2ZSBubyBwcmUtZXhpc3RpbmcgYm9keSwgYnV0IGhhcyBvbmUuXCIpO3RoaXMucmVxdWVzdEluaXQ9ZS5yZXF1ZXN0SW5pdHx8e319cmV0dXJuIHQucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24odCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsbixyLGE7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOmlmKHQubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXJIVFRQUmVxdWVzdC5zYXZlKCkgZG9lcyBub3Qgc3VwcG9ydCBzYXZpbmcgbW9kZWwgdG9wb2xvZ3kgaW4gYmluYXJ5IGZvcm1hdHMgeWV0LlwiKTtyZXR1cm4oZT1PYmplY3QuYXNzaWduKHttZXRob2Q6dGhpcy5ERUZBVUxUX01FVEhPRH0sdGhpcy5yZXF1ZXN0SW5pdCkpLmJvZHk9bmV3IEZvcm1EYXRhLG49W3twYXRoczpbXCIuL21vZGVsLndlaWdodHMuYmluXCJdLHdlaWdodHM6dC53ZWlnaHRTcGVjc31dLHI9e21vZGVsVG9wb2xvZ3k6dC5tb2RlbFRvcG9sb2d5LGZvcm1hdDp0LmZvcm1hdCxnZW5lcmF0ZWRCeTp0LmdlbmVyYXRlZEJ5LGNvbnZlcnRlZEJ5OnQuY29udmVydGVkQnksd2VpZ2h0c01hbmlmZXN0Om59LGUuYm9keS5hcHBlbmQoXCJtb2RlbC5qc29uXCIsbmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KHIpXSx7dHlwZTpcImFwcGxpY2F0aW9uL2pzb25cIn0pLFwibW9kZWwuanNvblwiKSxudWxsIT10LndlaWdodERhdGEmJmUuYm9keS5hcHBlbmQoXCJtb2RlbC53ZWlnaHRzLmJpblwiLG5ldyBCbG9iKFt0LndlaWdodERhdGFdLHt0eXBlOlwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJ9KSxcIm1vZGVsLndlaWdodHMuYmluXCIpLFs0LHRoaXMuZmV0Y2godGhpcy5wYXRoLGUpXTtjYXNlIDE6aWYoKGE9by5zZW50KCkpLm9rKXJldHVyblsyLHttb2RlbEFydGlmYWN0c0luZm86U2ModCkscmVzcG9uc2VzOlthXX1dO3Rocm93IG5ldyBFcnJvcihcIkJyb3dzZXJIVFRQUmVxdWVzdC5zYXZlKCkgZmFpbGVkIGR1ZSB0byBIVFRQIHJlc3BvbnNlIHN0YXR1cyBcIithLnN0YXR1cytcIi5cIil9fSl9KX0sdC5wcm90b3R5cGUubG9hZD1mdW5jdGlvbigpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGUsbixyLGEsaSxzLHU7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMuZmV0Y2godGhpcy5wYXRoLHRoaXMucmVxdWVzdEluaXQpXTtjYXNlIDE6aWYoISh0PW8uc2VudCgpKS5vayl0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0IHRvIFwiK3RoaXMucGF0aCtcIiBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSBcIit0LnN0YXR1cytcIi4gUGxlYXNlIHZlcmlmeSB0aGlzIFVSTCBwb2ludHMgdG8gdGhlIG1vZGVsIEpTT04gb2YgdGhlIG1vZGVsIHRvIGxvYWQuXCIpO28ubGFiZWw9MjtjYXNlIDI6cmV0dXJuIG8udHJ5cy5wdXNoKFsyLDQsLDVdKSxbNCx0Lmpzb24oKV07Y2FzZSAzOnJldHVybiBlPW8uc2VudCgpLFszLDVdO2Nhc2UgNDp0aHJvdyBvLnNlbnQoKSxuPVwiRmFpbGVkIHRvIHBhcnNlIG1vZGVsIEpTT04gb2YgcmVzcG9uc2UgZnJvbSBcIit0aGlzLnBhdGgrXCIuXCIsdGhpcy5wYXRoLmVuZHNXaXRoKFwiLnBiXCIpP24rPVwiIFlvdXIgcGF0aCBjb250YWlucyBhIC5wYiBmaWxlIGV4dGVuc2lvbi4gU3VwcG9ydCBmb3IgLnBiIG1vZGVscyBoYXZlIGJlZW4gcmVtb3ZlZCBpbiBUZW5zb3JGbG93LmpzIDEuMCBpbiBmYXZvciBvZiAuanNvbiBtb2RlbHMuIFlvdSBjYW4gcmUtY29udmVydCB5b3VyIFB5dGhvbiBUZW5zb3JGbG93IG1vZGVsIHVzaW5nIHRoZSBUZW5zb3JGbG93LmpzIDEuMCBjb252ZXJzaW9uIHNjcmlwdHMgb3IgeW91IGNhbiBjb252ZXJ0IHlvdXIucGIgbW9kZWxzIHdpdGggdGhlICdwYjJqc29uJ05QTSBzY3JpcHQgaW4gdGhlIHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIgcmVwb3NpdG9yeS5cIjpuKz1cIiBQbGVhc2UgbWFrZSBzdXJlIHRoZSBzZXJ2ZXIgaXMgc2VydmluZyB2YWxpZCBKU09OIGZvciB0aGlzIHJlcXVlc3QuXCIsbmV3IEVycm9yKG4pO2Nhc2UgNTppZihyPWUubW9kZWxUb3BvbG9neSxhPWUud2VpZ2h0c01hbmlmZXN0LG51bGw9PXImJm51bGw9PWEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIEpTT04gZnJvbSBIVFRQIHBhdGggXCIrdGhpcy5wYXRoK1wiIGNvbnRhaW5zIG5laXRoZXIgbW9kZWwgdG9wb2xvZ3kgb3IgbWFuaWZlc3QgZm9yIHdlaWdodHMuXCIpO3JldHVybiBudWxsPT1hP1szLDddOls0LHRoaXMubG9hZFdlaWdodHMoYSldO2Nhc2UgNjp1PW8uc2VudCgpLGk9dVswXSxzPXVbMV0sby5sYWJlbD03O2Nhc2UgNzpyZXR1cm5bMix7bW9kZWxUb3BvbG9neTpyLHdlaWdodFNwZWNzOmksd2VpZ2h0RGF0YTpzfV19fSl9KX0sdC5wcm90b3R5cGUubG9hZFdlaWdodHM9ZnVuY3Rpb24odCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsbixyLGEsaSxzLHUsbCxjLGgscDtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6Zm9yKGU9QXJyYXkuaXNBcnJheSh0aGlzLnBhdGgpP3RoaXMucGF0aFsxXTp0aGlzLnBhdGgsbj1mdW5jdGlvbih0KXt2YXIgZT10Lmxhc3RJbmRleE9mKFwiL1wiKSxuPXQubGFzdEluZGV4T2YoXCI/XCIpLHI9dC5zdWJzdHJpbmcoMCxlKSxvPW4+ZT90LnN1YnN0cmluZyhuKTpcIlwiO3JldHVybltyK1wiL1wiLG9dfShlKSxyPW5bMF0sYT1uWzFdLGk9dGhpcy53ZWlnaHRQYXRoUHJlZml4fHxyLHM9W10sdT0wLGw9dDt1PGwubGVuZ3RoO3UrKyljPWxbdV0scy5wdXNoLmFwcGx5KHMsYy53ZWlnaHRzKTtyZXR1cm4gaD1bXSx0LmZvckVhY2goZnVuY3Rpb24odCl7dC5wYXRocy5mb3JFYWNoKGZ1bmN0aW9uKHQpe2gucHVzaChpK3QrYSl9KX0pLFs0LHJoKGgse3JlcXVlc3RJbml0OnRoaXMucmVxdWVzdEluaXQsZmV0Y2hGdW5jOnRoaXMuZmV0Y2gsb25Qcm9ncmVzczp0aGlzLm9uUHJvZ3Jlc3N9KV07Y2FzZSAxOnJldHVybiBwPW8uc2VudCgpLFsyLFtzLEVjKHApXV19fSl9KX0sdC5VUkxfU0NIRU1FX1JFR0VYPS9eaHR0cHM/OlxcL1xcLy8sdH0oKTtmdW5jdGlvbiBpaCh0KXtyZXR1cm4gbnVsbCE9dC5tYXRjaChhaC5VUkxfU0NIRU1FX1JFR0VYKX12YXIgc2g9ZnVuY3Rpb24odCxlKXtyZXR1cm4oQXJyYXkuaXNBcnJheSh0KT90LmV2ZXJ5KGZ1bmN0aW9uKHQpe3JldHVybiBpaCh0KX0pOmloKHQpKT91aCh0LHtvblByb2dyZXNzOmV9KTpudWxsfTtmdW5jdGlvbiB1aCh0LGUpe3JldHVybiBuZXcgYWgodCxlKX1OYy5yZWdpc3RlclNhdmVSb3V0ZXIoc2gpLE5jLnJlZ2lzdGVyTG9hZFJvdXRlcihzaCk7dmFyIGxoPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUsbil7dGhpcy5tb2RlbFRvcG9sb2d5PXQsdGhpcy53ZWlnaHRTcGVjcz1lLHRoaXMud2VpZ2h0RGF0YT1ufXJldHVybiB0LnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gdD17fSxudWxsIT10aGlzLm1vZGVsVG9wb2xvZ3kmJih0PW4oe21vZGVsVG9wb2xvZ3k6dGhpcy5tb2RlbFRvcG9sb2d5fSx0KSksbnVsbCE9dGhpcy53ZWlnaHRTcGVjcyYmdGhpcy53ZWlnaHRTcGVjcy5sZW5ndGg+MCYmKHQ9bih7d2VpZ2h0U3BlY3M6dGhpcy53ZWlnaHRTcGVjc30sdCkpLG51bGwhPXRoaXMud2VpZ2h0RGF0YSYmdGhpcy53ZWlnaHREYXRhLmJ5dGVMZW5ndGg+MCYmKHQ9bih7d2VpZ2h0RGF0YTp0aGlzLndlaWdodERhdGF9LHQpKSxbMix0XX0pfSl9LHR9KCksY2g9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuc2F2ZUhhbmRsZXI9dH1yZXR1cm4gdC5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbih0KXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKGUpe3JldHVyblsyLHRoaXMuc2F2ZUhhbmRsZXIodCldfSl9KX0sdH0oKTt2YXIgaGg9T2JqZWN0LmZyZWV6ZSh7YnJvd3NlckZpbGVzOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZWgodCl9LGJyb3dzZXJIVFRQUmVxdWVzdDpmdW5jdGlvbih0LGUpe3JldHVybiB1aCh0LGUpfSxjb25jYXRlbmF0ZUFycmF5QnVmZmVyczpFYyxkZWNvZGVXZWlnaHRzOnhjLGVuY29kZVdlaWdodHM6ZnVuY3Rpb24odCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsbixyLGE7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOmZvcihyIGluIGU9W10sbj1bXSx0KXtpZihcImZsb2F0MzJcIiE9PShhPXRbcl0pLmR0eXBlJiZcImludDMyXCIhPT1hLmR0eXBlJiZcImJvb2xcIiE9PWEuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZHR5cGUgaW4gd2VpZ2h0ICdcIityK1wiJzogXCIrYS5kdHlwZSk7ZS5wdXNoKHtuYW1lOnIsc2hhcGU6YS5zaGFwZSxkdHlwZTphLmR0eXBlfSksbi5wdXNoKGEuZGF0YSgpKX1yZXR1cm5bNCxQcm9taXNlLmFsbChuKV07Y2FzZSAxOnJldHVyblsyLHtkYXRhOndjKG8uc2VudCgpKSxzcGVjczplfV19fSl9KX0sZnJvbU1lbW9yeTpmdW5jdGlvbih0LGUsbil7cmV0dXJuIG5ldyBsaCh0LGUsbil9LGdldExvYWRIYW5kbGVyczpmdW5jdGlvbih0LGUpe3JldHVybiBOYy5nZXRMb2FkSGFuZGxlcnModCl9LGdldE1vZGVsQXJ0aWZhY3RzSW5mb0ZvckpTT046U2MsZ2V0U2F2ZUhhbmRsZXJzOmZ1bmN0aW9uKHQpe3JldHVybiBOYy5nZXRTYXZlSGFuZGxlcnModCl9LGh0dHA6dWgsaXNIVFRQU2NoZW1lOmloLGxvYWRXZWlnaHRzOmZ1bmN0aW9uKHQsZSxuLGEpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1cIlwiKSxyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBvKHRoaXMsZnVuY3Rpb24ocil7cmV0dXJuWzIsb2goZnVuY3Rpb24odCl7cmV0dXJuIHJoKHQse3JlcXVlc3RJbml0OmF9KX0pKHQsZSxuKV19KX0pfSxyZWdpc3RlckxvYWRSb3V0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIE5jLnJlZ2lzdGVyTG9hZFJvdXRlcih0KX0scmVnaXN0ZXJTYXZlUm91dGVyOmZ1bmN0aW9uKHQpe3JldHVybiBOYy5yZWdpc3RlclNhdmVSb3V0ZXIodCl9LHdlaWdodHNMb2FkZXJGYWN0b3J5Om9oLHdpdGhTYXZlSGFuZGxlcjpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGNoKHQpfSxjb3B5TW9kZWw6ZnVuY3Rpb24odCxlKXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG4pe3JldHVyblsyLFRjKHQsZSwhMSldfSl9KX0sbGlzdE1vZGVsczpmdW5jdGlvbigpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGUsbixyLGEsaSxzO3JldHVybiBvKHRoaXMsZnVuY3Rpb24obyl7c3dpdGNoKG8ubGFiZWwpe2Nhc2UgMDp0PUljLmdldFNjaGVtZXMoKSxlPXt9LG49MCxyPXQsby5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gbjxyLmxlbmd0aD8oYT1yW25dLFs0LEljLmdldE1hbmFnZXIoYSkubGlzdE1vZGVscygpXSk6WzMsNF07Y2FzZSAyOmZvcihzIGluIGk9by5zZW50KCkpZVthK2tjK3NdPWlbc107by5sYWJlbD0zO2Nhc2UgMzpyZXR1cm4gbisrLFszLDFdO2Nhc2UgNDpyZXR1cm5bMixlXX19KX0pfSxtb3ZlTW9kZWw6ZnVuY3Rpb24odCxlKXtyZXR1cm4gcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG4pe3JldHVyblsyLFRjKHQsZSwhMCldfSl9KX0scmVtb3ZlTW9kZWw6ZnVuY3Rpb24odCl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuIG8odGhpcyxmdW5jdGlvbihuKXtyZXR1cm4gZT1BYyh0KSxbMixJYy5nZXRNYW5hZ2VyKGUuc2NoZW1lKS5yZW1vdmVNb2RlbChlLnBhdGgpXX0pfSl9fSk7dmFyIHBoPUFuKHtjb25mdXNpb25NYXRyaXhfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj13bih0LFwibGFiZWxzXCIsXCJjb25mdXNpb25NYXRyaXhcIiksbz13bihlLFwicHJlZGljdGlvbnNcIixcImNvbmZ1c2lvbk1hdHJpeFwiKTtkKG51bGw9PW58fG4+MCYmTnVtYmVyLmlzSW50ZWdlcihuKSxmdW5jdGlvbigpe3JldHVyblwiSWYgcHJvdmlkZWQsIG51bUNsYXNzZXMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCBnb3QgXCIrbn0pLGQoMT09PXIucmFuayxmdW5jdGlvbigpe3JldHVyblwiRXhwZWN0ZWQgdGhlIHJhbmsgb2YgbGFiZWxzIHRvIGJlIDEsIGJ1dCBnb3QgXCIrci5yYW5rfSksZCgxPT09by5yYW5rLGZ1bmN0aW9uKCl7cmV0dXJuXCJFeHBlY3RlZCB0aGUgcmFuayBvZiBwcmVkaWN0aW9ucyB0byBiZSAxLCBidXQgZ290IFwiK28ucmFua30pLGQoci5zaGFwZVswXT09PW8uc2hhcGVbMF0sZnVuY3Rpb24oKXtyZXR1cm5cIk1pc21hdGNoIGluIHRoZSBudW1iZXIgb2YgZXhhbXBsZXM6IFwiK3Iuc2hhcGVbMF0rXCIgdnMuIFwiK28uc2hhcGVbMF0rXCIuIExhYmVscyBhbmQgcHJlZGljdGlvbnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLlwifSksZChuPjAmJk51bWJlci5pc0ludGVnZXIobiksZnVuY3Rpb24oKXtyZXR1cm5cIm51bUNsYXNzZXMgaXMgcmVxdWlyZWQgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBidXQgZ290IFwiK259KTt2YXIgYT1CcihyLmFzVHlwZShcImludDMyXCIpLG4pLGk9QnIoby5hc1R5cGUoXCJpbnQzMlwiKSxuKTtyZXR1cm4gYS50cmFuc3Bvc2UoKS5tYXRNdWwoaSkuYXNUeXBlKFwiaW50MzJcIil9fSksZmg9T2JqZWN0LmZyZWV6ZSh7Y29uZnVzaW9uTWF0cml4OnBofSk7dmFyIGRoPUFuKHtmcm9tUGl4ZWxzXzpmdW5jdGlvbih0LGUpe2lmKHZvaWQgMD09PWUmJihlPTMpLGU+NCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29uc3RydWN0IFRlbnNvciB3aXRoIG1vcmUgdGhhbiA0IGNoYW5uZWxzIGZyb20gcGl4ZWxzLlwiKTtyZXR1cm4gRHQuZnJvbVBpeGVscyh0LGUpfX0pLHZoPU9iamVjdC5mcmVlemUoe3RvUGl4ZWxzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIG4scixhLGkscyx1LGwsYyxoLHAsZixkLHYsbSxnLHkseCx3LGIsQyxFLFIsUztyZXR1cm4gbyh0aGlzLGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6aWYobj13bih0LFwiaW1nXCIsXCJ0b1BpeGVsc1wiKSx0IGluc3RhbmNlb2YgZnR8fChuPW4udG9JbnQoKSksMiE9PW4ucmFuayYmMyE9PW4ucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJ0b1BpeGVscyBvbmx5IHN1cHBvcnRzIHJhbmsgMiBvciAzIHRlbnNvcnMsIGdvdCByYW5rIFwiK24ucmFuaytcIi5cIik7aWYocj1uLnNoYXBlLnNsaWNlKDAsMiksYT1yWzBdLGk9clsxXSwocz0yPT09bi5yYW5rPzE6bi5zaGFwZVsyXSk+NHx8Mj09PXMpdGhyb3cgbmV3IEVycm9yKFwidG9QaXhlbHMgb25seSBzdXBwb3J0cyBkZXB0aCBvZiBzaXplIDEsIDMgb3IgNCBidXQgZ290IFwiK3MpO3JldHVybls0LG4uZGF0YSgpXTtjYXNlIDE6cmV0dXJuIHU9by5zZW50KCksbD1uLm1pbigpLGM9bi5tYXgoKSxbNCxQcm9taXNlLmFsbChbbC5kYXRhKCksYy5kYXRhKCldKV07Y2FzZSAyOmlmKGg9by5zZW50KCkscD1oWzBdLGY9aFsxXSxkPXBbMF0sdj1mWzBdLGwuZGlzcG9zZSgpLGMuZGlzcG9zZSgpLFwiZmxvYXQzMlwiPT09bi5kdHlwZSl7aWYoZDwwfHx2PjEpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIHZhbHVlcyBmb3IgYSBmbG9hdDMyIFRlbnNvciBtdXN0IGJlIGluIHRoZSByYW5nZSBbMCAtIDFdIGJ1dCBnb3QgcmFuZ2UgW1wiK2QrXCIgLSBcIit2K1wiXS5cIil9ZWxzZXtpZihcImludDMyXCIhPT1uLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHR5cGUgZm9yIHRvUGl4ZWxzOiBcIituLmR0eXBlK1wiLiBQbGVhc2UgdXNlIGZsb2F0MzIgb3IgaW50MzIgdGVuc29ycy5cIik7aWYoZDwwfHx2PjI1NSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgdmFsdWVzIGZvciBhIGludDMyIFRlbnNvciBtdXN0IGJlIGluIHRoZSByYW5nZSBbMCAtIDI1NV0gYnV0IGdvdCByYW5nZSBbXCIrZCtcIiAtIFwiK3YrXCJdLlwiKX1mb3IobT1cImZsb2F0MzJcIj09PW4uZHR5cGU/MjU1OjEsZz1uZXcgVWludDhDbGFtcGVkQXJyYXkoaSphKjQpLHk9MDt5PGEqaTsrK3kpeD12b2lkIDAsdz12b2lkIDAsYj12b2lkIDAsQz12b2lkIDAsMT09PXM/KHg9dVt5XSptLHc9dVt5XSptLGI9dVt5XSptLEM9MjU1KTozPT09cz8oeD11WzMqeV0qbSx3PXVbMyp5KzFdKm0sYj11WzMqeSsyXSptLEM9MjU1KTo0PT09cyYmKHg9dVs0KnldKm0sdz11WzQqeSsxXSptLGI9dVs0KnkrMl0qbSxDPXVbNCp5KzNdKm0pLGdbMCsoRT00KnkpXT1NYXRoLnJvdW5kKHgpLGdbRSsxXT1NYXRoLnJvdW5kKHcpLGdbRSsyXT1NYXRoLnJvdW5kKGIpLGdbRSszXT1NYXRoLnJvdW5kKEMpO3JldHVybiBudWxsIT1lJiYoZS53aWR0aD1pLGUuaGVpZ2h0PWEsUj1lLmdldENvbnRleHQoXCIyZFwiKSxTPW5ldyBJbWFnZURhdGEoZyxpLGEpLFIucHV0SW1hZ2VEYXRhKFMsMCwwKSksbiE9PXQmJm4uZGlzcG9zZSgpLFsyLGddfX0pfSl9LGZyb21QaXhlbHM6ZGh9KSxtaD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLmdldENsYXNzTmFtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLmNsYXNzTmFtZX0sdC5mcm9tQ29uZmlnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyB0KGUpfSx0fSgpLGdoPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMuY2xhc3NOYW1lTWFwPXt9fXJldHVybiB0LmdldE1hcD1mdW5jdGlvbigpe3JldHVybiBudWxsPT10Lmluc3RhbmNlJiYodC5pbnN0YW5jZT1uZXcgdCksdC5pbnN0YW5jZX0sdC5yZWdpc3Rlcj1mdW5jdGlvbihlKXt0LmdldE1hcCgpLmNsYXNzTmFtZU1hcFtlLmNsYXNzTmFtZV09W2UsZS5mcm9tQ29uZmlnXX0sdH0oKTtmdW5jdGlvbiB5aCh0KXtkKG51bGwhPXQuY2xhc3NOYW1lLGZ1bmN0aW9uKCl7cmV0dXJuXCJDbGFzcyBiZWluZyByZWdpc3RlcmVkIGRvZXMgbm90IGhhdmUgdGhlIHN0YXRpYyBjbGFzc05hbWUgcHJvcGVydHkgZGVmaW5lZC5cIn0pLGQoXCJzdHJpbmdcIj09dHlwZW9mIHQuY2xhc3NOYW1lLGZ1bmN0aW9uKCl7cmV0dXJuXCJjbGFzc05hbWUgaXMgcmVxdWlyZWQgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgdHlwZSBcIit0eXBlb2YgdC5jbGFzc05hbWV9KSxkKHQuY2xhc3NOYW1lLmxlbmd0aD4wLGZ1bmN0aW9uKCl7cmV0dXJuXCJDbGFzcyBiZWluZyByZWdpc3RlcmVkIGhhcyBhbiBlbXB0eS1zdHJpbmcgYXMgaXRzIGNsYXNzTmFtZSwgd2hpY2ggaXMgZGlzYWxsb3dlZC5cIn0pLGdoLnJlZ2lzdGVyKHQpfXZhciB4aD1PYmplY3QuZnJlZXplKHtTZXJpYWxpemFibGU6bWgsU2VyaWFsaXphdGlvbk1hcDpnaCxyZWdpc3RlckNsYXNzOnlofSksd2g9LjAwMSxiaD0uMTtmdW5jdGlvbiBDaCgpe3JldHVybiAzMj09PUR0LmJhY2tlbmQuZmxvYXRQcmVjaXNpb24oKT93aDpiaH1mdW5jdGlvbiBFaCh0LGUsbil7dmFyIHI9ITA7aWYoKF8odCl8fF8oZSkpJiYocj0hMSksXyh0KSYmXyhlKSYmKHI9ITApLHIpe3ZhciBvPXQuY29uc3RydWN0b3IubmFtZSxhPWUuY29uc3RydWN0b3IubmFtZTtpZihvIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgYXJlIG9mIGRpZmZlcmVudCB0eXBlLiBBY3R1YWw6IFwiK28rXCIuIEV4cGVjdGVkOiBcIithKX1pZihBcnJheS5pc0FycmF5KHQpJiZBcnJheS5pc0FycmF5KGUpKXt2YXIgaT15bih0KSxzPXluKGUpO2lmKCF4KGkscykpdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlzIGhhdmUgZGlmZmVyZW50IHNoYXBlcy4gQWN0dWFsOiBbXCIraStcIl0uIEV4cGVjdGVkOiBbXCIrcytcIl1cIil9dmFyIHU9Xyh0KT90OmcodCksbD1fKGUpP2U6ZyhlKTtpZih1Lmxlbmd0aCE9PWwubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkFycmF5cyBoYXZlIGRpZmZlcmVudCBsZW5ndGhzIGFjdHVhbDogXCIrdS5sZW5ndGgrXCIgdnMgZXhwZWN0ZWQ6IFwiK2wubGVuZ3RoK1wiLlxcbkFjdHVhbDogICBcIit1K1wiLlxcbkV4cGVjdGVkOiBcIitsK1wiLlwiKTtmb3IodmFyIGM9MDtjPGwubGVuZ3RoOysrYyl7dmFyIGg9dVtjXSxwPWxbY107aWYoIW4oaCxwKSl0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgZGlmZmVyOiBhY3R1YWxbXCIrYytcIl0gPSBcIitoK1wiLCBleHBlY3RlZFtcIitjK1wiXSA9IFwiK3ArXCIuXFxuQWN0dWFsOiAgIFwiK3UrXCIuXFxuRXhwZWN0ZWQ6IFwiK2wrXCIuXCIpfX1mdW5jdGlvbiBSaCh0LGUsbil7cmV0dXJuIWlzRmluaXRlKHQpJiYhaXNGaW5pdGUoZSl8fCEoaXNOYU4odCl8fGlzTmFOKGUpfHxNYXRoLmFicyh0LWUpPm4pfXZhciBTaD1PYmplY3QuZnJlZXplKHtURVNUX0VQU0lMT05fRkxPQVQxNjpiaCxleHBlY3RBcnJheXNDbG9zZTpmdW5jdGlvbih0LGUsbil7cmV0dXJuIG51bGw9PW4mJihuPUNoKCkpLEVoKHQsZSxmdW5jdGlvbih0LGUpe3JldHVybiBSaCh0LGUsbil9KX0sdGVzdEVwc2lsb246Q2gsZXhwZWN0UHJvbWlzZVRvRmFpbDpmdW5jdGlvbih0LGUpe3QoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGUuZmFpbCgpfSxmdW5jdGlvbigpe3JldHVybiBlKCl9KX0sZXhwZWN0QXJyYXlzRXF1YWw6ZnVuY3Rpb24odCxlKXt2YXIgbj1cInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGV8fFwiYm9vbGVhblwiPT10eXBlb2YgZT9bZV06ZTtyZXR1cm4gQih0KXx8Qih0WzBdKXx8QihlKXx8QihlWzBdKT9FaCh0LG4sZnVuY3Rpb24odCxlKXtyZXR1cm4gdD09ZX0pOkVoKHQsZSxmdW5jdGlvbih0LGUpe3JldHVybiBSaCh0LGUsMCl9KX0sZXhwZWN0TnVtYmVyc0Nsb3NlOmZ1bmN0aW9uKHQsZSxuKXtpZihudWxsPT1uJiYobj1DaCgpKSwhUmgodCxlLG4pKXRocm93IG5ldyBFcnJvcihcIk51bWJlcnMgZGlmZmVyOiBhY3R1YWwgPT09IFwiK3QrXCIsIGV4cGVjdGVkID09PSBcIitlKX0sZXhwZWN0VmFsdWVzSW5SYW5nZTpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspaWYodFtyXTxlfHx0W3JdPm4pdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgb3V0IG9mIHJhbmdlOlwiK3Rbcl0rXCIgbG93OiBcIitlK1wiLCBoaWdoOiBcIituKX0sZXhwZWN0QXJyYXlCdWZmZXJzRXF1YWw6ZnVuY3Rpb24odCxlKXtleHBlY3QobmV3IEZsb2F0MzJBcnJheSh0KSkudG9FcXVhbChuZXcgRmxvYXQzMkFycmF5KGUpKX19KSxOaD1cIjEuMS4yXCIsa2g9T2JqZWN0LmZyZWV6ZSh7Z3BncHVfdXRpbDpMYSx3ZWJnbF91dGlsOmtlLE1hdGhCYWNrZW5kV2ViR0w6VWksR1BHUFVDb250ZXh0OldhfSksSWg9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbigpe3JldHVybiBudWxsIT09dCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIGUobix0KSxuLnByb3RvdHlwZS5taW5pbWl6ZT1mdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9ITEpO3ZhciByPXRoaXMuY29tcHV0ZUdyYWRpZW50cyh0LG4pLG89ci52YWx1ZSxhPXIuZ3JhZHM7cmV0dXJuIHRoaXMuYXBwbHlHcmFkaWVudHMoYSksT2JqZWN0LmtleXMoYSkuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gYVt0XS5kaXNwb3NlKCl9KSxlP286KG8uZGlzcG9zZSgpLG51bGwpfSxuLnByb3RvdHlwZS5jb21wdXRlR3JhZGllbnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIE5uKHQsZSl9LG4ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt9LG59KG1oKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSWgsU3ltYm9sLmhhc0luc3RhbmNlLHt2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9dC5taW5pbWl6ZSYmbnVsbCE9dC5jb21wdXRlR3JhZGllbnRzJiZudWxsIT10LmFwcGx5R3JhZGllbnRzfX0pO3ZhciBBaD1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKGUsbixyKXt2b2lkIDA9PT1yJiYocj1udWxsKTt2YXIgbz10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG8ubGVhcm5pbmdSYXRlPWUsby5yaG89bixvLmVwc2lsb249cixvLmFjY3VtdWxhdGVkR3JhZHM9e30sby5hY2N1bXVsYXRlZFVwZGF0ZXM9e30sbnVsbD09ciYmKG8uZXBzaWxvbj1EdC5iYWNrZW5kLmVwc2lsb24oKSksb31yZXR1cm4gZShuLHQpLG4ucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj1mdW5jdGlvbihuKXt2YXIgbz1EdC5yZWdpc3RlcmVkVmFyaWFibGVzW25dO2lmKG51bGw9PXIuYWNjdW11bGF0ZWRHcmFkc1tuXSl7RmUoZnVuY3Rpb24oKXtlLmFjY3VtdWxhdGVkR3JhZHNbbl09WG4obykudmFyaWFibGUoITEpfSl9aWYobnVsbD09ci5hY2N1bXVsYXRlZFVwZGF0ZXNbbl0pe0ZlKGZ1bmN0aW9uKCl7ZS5hY2N1bXVsYXRlZFVwZGF0ZXNbbl09WG4obykudmFyaWFibGUoITEpfSl9dmFyIGE9dFtuXSxpPXIuYWNjdW11bGF0ZWRHcmFkc1tuXSxzPXIuYWNjdW11bGF0ZWRVcGRhdGVzW25dO0ZlKGZ1bmN0aW9uKCl7dmFyIHQ9aS5tdWwoZS5yaG8pLmFkZChhLnNxdWFyZSgpLm11bCgxLWUucmhvKSkscj1zLmFkZChlLmVwc2lsb24pLnNxcnQoKS5kaXYoaS5hZGQoZS5lcHNpbG9uKS5zcXJ0KCkpLm11bChhKSx1PXMubXVsKGUucmhvKS5hZGQoci5zcXVhcmUoKS5tdWwoMS1lLnJobykpO2UuYWNjdW11bGF0ZWRHcmFkc1tuXS5hc3NpZ24odCksZS5hY2N1bXVsYXRlZFVwZGF0ZXNbbl0uYXNzaWduKHUpO3ZhciBsPXIubXVsKC1lLmxlYXJuaW5nUmF0ZSkuYWRkKG8pO28uYXNzaWduKGwpfSl9LHI9dGhpcztmb3IodmFyIG8gaW4gdCluKG8pfSxuLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztudWxsIT10aGlzLmFjY3VtdWxhdGVkVXBkYXRlcyYmKE9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRVcGRhdGVzKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0LmFjY3VtdWxhdGVkVXBkYXRlc1tlXS5kaXNwb3NlKCl9KSxPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkR3JhZHMpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQuYWNjdW11bGF0ZWRHcmFkc1tlXS5kaXNwb3NlKCl9KSl9LG4ucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGUscmhvOnRoaXMucmhvLGVwc2lsb246dGhpcy5lcHNpbG9ufX0sbi5mcm9tQ29uZmlnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyB0KGUubGVhcm5pbmdSYXRlLGUucmhvLGUuZXBzaWxvbil9LG4uY2xhc3NOYW1lPVwiQWRhZGVsdGFPcHRpbWl6ZXJcIixufShJaCk7eWgoQWgpO3ZhciBUaD1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKGUsbil7dm9pZCAwPT09biYmKG49LjEpO3ZhciByPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gci5sZWFybmluZ1JhdGU9ZSxyLmluaXRpYWxBY2N1bXVsYXRvclZhbHVlPW4sci5hY2N1bXVsYXRlZEdyYWRzPXt9LHJ9cmV0dXJuIGUobix0KSxuLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLG49ZnVuY3Rpb24obil7dmFyIG89RHQucmVnaXN0ZXJlZFZhcmlhYmxlc1tuXTtpZihudWxsPT1yLmFjY3VtdWxhdGVkR3JhZHNbbl0pe0ZlKGZ1bmN0aW9uKCl7ZS5hY2N1bXVsYXRlZEdyYWRzW25dPUhuKG8uc2hhcGUsZS5pbml0aWFsQWNjdW11bGF0b3JWYWx1ZSkudmFyaWFibGUoITEpfSl9dmFyIGE9dFtuXSxpPXIuYWNjdW11bGF0ZWRHcmFkc1tuXTtGZShmdW5jdGlvbigpe3ZhciB0PWkuYWRkKGEuc3F1YXJlKCkpO2UuYWNjdW11bGF0ZWRHcmFkc1tuXS5hc3NpZ24odCk7dmFyIHI9YS5kaXYodC5hZGQoRHQuYmFja2VuZC5lcHNpbG9uKCkpLnNxcnQoKSkubXVsKC1lLmxlYXJuaW5nUmF0ZSkuYWRkKG8pO28uYXNzaWduKHIpfSl9LHI9dGhpcztmb3IodmFyIG8gaW4gdCluKG8pfSxuLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztudWxsIT10aGlzLmFjY3VtdWxhdGVkR3JhZHMmJk9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRHcmFkcykuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdC5hY2N1bXVsYXRlZEdyYWRzW2VdLmRpc3Bvc2UoKX0pfSxuLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLGluaXRpYWxBY2N1bXVsYXRvclZhbHVlOnRoaXMuaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWV9fSxuLmZyb21Db25maWc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IHQoZS5sZWFybmluZ1JhdGUsZS5pbml0aWFsQWNjdW11bGF0b3JWYWx1ZSl9LG4uY2xhc3NOYW1lPVwiQWRhZ3JhZE9wdGltaXplclwiLG59KEloKTt5aChUaCk7dmFyIERoPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oZSxuLHIsbyl7dm9pZCAwPT09byYmKG89bnVsbCk7dmFyIGE9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBhLmxlYXJuaW5nUmF0ZT1lLGEuYmV0YTE9bixhLmJldGEyPXIsYS5lcHNpbG9uPW8sYS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50PXt9LGEuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnQ9e30sRmUoZnVuY3Rpb24oKXthLmFjY0JldGExPUJuKG4pLnZhcmlhYmxlKCksYS5hY2NCZXRhMj1CbihyKS52YXJpYWJsZSgpfSksbnVsbD09byYmKGEuZXBzaWxvbj1EdC5iYWNrZW5kLmVwc2lsb24oKSksYX1yZXR1cm4gZShuLHQpLG4ucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7RmUoZnVuY3Rpb24oKXt2YXIgbj1sbCgxLGUuYWNjQmV0YTEpLHI9bGwoMSxlLmFjY0JldGEyKTtmb3IodmFyIG8gaW4gdCl7dmFyIGE9RHQucmVnaXN0ZXJlZFZhcmlhYmxlc1tvXTtpZihudWxsPT1lLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbb10pe3ZhciBpPSExO2UuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFtvXT1YbihhKS52YXJpYWJsZShpKX1pZihudWxsPT1lLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50W29dKXtpPSExO2UuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRbb109WG4oYSkudmFyaWFibGUoaSl9dmFyIHM9dFtvXSx1PWUuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFtvXSxsPWUuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRbb10sYz11Lm11bChlLmJldGExKS5hZGQocy5tdWwoMS1lLmJldGExKSksaD1sLm11bChlLmJldGEyKS5hZGQocy5zcXVhcmUoKS5tdWwoMS1lLmJldGEyKSkscD1jLmRpdihuKSxmPWguZGl2KHIpO2UuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFtvXS5hc3NpZ24oYyksZS5hY2N1bXVsYXRlZFNlY29uZE1vbWVudFtvXS5hc3NpZ24oaCk7dmFyIGQ9cC5kaXYoZi5zcXJ0KCkuYWRkKGUuZXBzaWxvbikpLm11bCgtZS5sZWFybmluZ1JhdGUpLmFkZChhKTthLmFzc2lnbihkKX1lLmFjY0JldGExLmFzc2lnbihlLmFjY0JldGExLm11bChlLmJldGExKSksZS5hY2NCZXRhMi5hc3NpZ24oZS5hY2NCZXRhMi5tdWwoZS5iZXRhMikpfSl9LG4ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuYWNjQmV0YTEuZGlzcG9zZSgpLHRoaXMuYWNjQmV0YTIuZGlzcG9zZSgpLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudCYmT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0LmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbZV0uZGlzcG9zZSgpfSksbnVsbCE9dGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudCYmT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudCkuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdC5hY2N1bXVsYXRlZFNlY29uZE1vbWVudFtlXS5kaXNwb3NlKCl9KX0sbi5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxiZXRhMTp0aGlzLmJldGExLGJldGEyOnRoaXMuYmV0YTIsZXBzaWxvbjp0aGlzLmVwc2lsb259fSxuLmZyb21Db25maWc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IHQoZS5sZWFybmluZ1JhdGUsZS5iZXRhMSxlLmJldGEyLGUuZXBzaWxvbil9LG4uY2xhc3NOYW1lPVwiQWRhbU9wdGltaXplclwiLG59KEloKTt5aChEaCk7dmFyIE9oPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oZSxuLHIsbyxhKXt2b2lkIDA9PT1vJiYobz1udWxsKSx2b2lkIDA9PT1hJiYoYT0wKTt2YXIgaT10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIGkubGVhcm5pbmdSYXRlPWUsaS5iZXRhMT1uLGkuYmV0YTI9cixpLmVwc2lsb249byxpLmRlY2F5PWEsaS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50PXt9LGkuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm09e30sRmUoZnVuY3Rpb24oKXtpLml0ZXJhdGlvbj1CbigwKS52YXJpYWJsZSgpLGkuYWNjQmV0YTE9Qm4obikudmFyaWFibGUoKX0pLG51bGw9PW8mJihpLmVwc2lsb249RHQuYmFja2VuZC5lcHNpbG9uKCkpLGl9cmV0dXJuIGUobix0KSxuLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO0ZlKGZ1bmN0aW9uKCl7dmFyIG49bGwoMSxlLmFjY0JldGExKSxyPUt1KC1lLmxlYXJuaW5nUmF0ZSxlLml0ZXJhdGlvbi5tdWwoZS5kZWNheSkuYWRkKDEpKTtmb3IodmFyIG8gaW4gdCl7dmFyIGE9RHQucmVnaXN0ZXJlZFZhcmlhYmxlc1tvXTtpZihudWxsPT1lLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbb10pe3ZhciBpPSExO2UuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFtvXT1YbihhKS52YXJpYWJsZShpKX1pZihudWxsPT1lLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtW29dKXtpPSExO2UuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bb109WG4oYSkudmFyaWFibGUoaSl9dmFyIHM9dFtvXSx1PWUuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFtvXSxsPWUuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bb10sYz11Lm11bChlLmJldGExKS5hZGQocy5tdWwoMS1lLmJldGExKSksaD1sLm11bChlLmJldGEyKSxwPXMuYWJzKCksZj1oLm1heGltdW0ocCk7ZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W29dLmFzc2lnbihjKSxlLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtW29dLmFzc2lnbihmKTt2YXIgZD1yLmRpdihuKS5tdWwoYy5kaXYoZi5hZGQoZS5lcHNpbG9uKSkpLmFkZChhKTthLmFzc2lnbihkKX1lLml0ZXJhdGlvbi5hc3NpZ24oZS5pdGVyYXRpb24uYWRkKDEpKSxlLmFjY0JldGExLmFzc2lnbihlLmFjY0JldGExLm11bChlLmJldGExKSl9KX0sbi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy5hY2NCZXRhMS5kaXNwb3NlKCksdGhpcy5pdGVyYXRpb24uZGlzcG9zZSgpLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudCYmT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0LmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbZV0uZGlzcG9zZSgpfSksbnVsbCE9dGhpcy5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybSYmT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybSkuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdC5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybVtlXS5kaXNwb3NlKCl9KX0sbi5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxiZXRhMTp0aGlzLmJldGExLGJldGEyOnRoaXMuYmV0YTIsZXBzaWxvbjp0aGlzLmVwc2lsb24sZGVjYXk6dGhpcy5kZWNheX19LG4uZnJvbUNvbmZpZz1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgdChlLmxlYXJuaW5nUmF0ZSxlLmJldGExLGUuYmV0YTIsZS5lcHNpbG9uLGUuZGVjYXkpfSxuLmNsYXNzTmFtZT1cIkFkYW1heE9wdGltaXplclwiLG59KEloKTt5aChPaCk7dmFyIF9oPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oZSl7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLmxlYXJuaW5nUmF0ZT1lLG4uc2V0TGVhcm5pbmdSYXRlKGUpLG59cmV0dXJuIGUobix0KSxuLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO09iamVjdC5rZXlzKHQpLmZvckVhY2goZnVuY3Rpb24obil7dmFyIHI9dFtuXSxvPUR0LnJlZ2lzdGVyZWRWYXJpYWJsZXNbbl07RmUoZnVuY3Rpb24oKXt2YXIgdD1lLmMubXVsKHIpLmFkZChvKTtvLmFzc2lnbih0KX0pfSl9LG4ucHJvdG90eXBlLnNldExlYXJuaW5nUmF0ZT1mdW5jdGlvbih0KXt0aGlzLmxlYXJuaW5nUmF0ZT10LG51bGwhPXRoaXMuYyYmdGhpcy5jLmRpc3Bvc2UoKSx0aGlzLmM9UGUoQm4oLXQpKX0sbi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMuYy5kaXNwb3NlKCl9LG4ucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGV9fSxuLmZyb21Db25maWc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IHQoZS5sZWFybmluZ1JhdGUpfSxuLmNsYXNzTmFtZT1cIlNHRE9wdGltaXplclwiLG59KEloKTt5aChfaCk7dmFyIE1oPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oZSxuLHIpe3ZvaWQgMD09PXImJihyPSExKTt2YXIgbz10LmNhbGwodGhpcyxlKXx8dGhpcztyZXR1cm4gby5sZWFybmluZ1JhdGU9ZSxvLm1vbWVudHVtPW4sby51c2VOZXN0ZXJvdj1yLG8ubT1CbihvLm1vbWVudHVtKSxvLmFjY3VtdWxhdGlvbnM9e30sb31yZXR1cm4gZShuLHQpLG4ucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj1mdW5jdGlvbihuKXt2YXIgbz1EdC5yZWdpc3RlcmVkVmFyaWFibGVzW25dO2lmKG51bGw9PXIuYWNjdW11bGF0aW9uc1tuXSl7RmUoZnVuY3Rpb24oKXtlLmFjY3VtdWxhdGlvbnNbbl09WG4obykudmFyaWFibGUoITEpfSl9dmFyIGE9ci5hY2N1bXVsYXRpb25zW25dLGk9dFtuXTtGZShmdW5jdGlvbigpe3ZhciB0LHI9ZS5tLm11bChhKS5hZGQoaSk7dD1lLnVzZU5lc3Rlcm92P2UuYy5tdWwoaS5hZGQoci5tdWwoZS5tKSkpLmFkZChvKTplLmMubXVsKHIpLmFkZChvKSxlLmFjY3VtdWxhdGlvbnNbbl0uYXNzaWduKHIpLG8uYXNzaWduKHQpfSl9LHI9dGhpcztmb3IodmFyIG8gaW4gdCluKG8pfSxuLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7aWYodC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpLHRoaXMubS5kaXNwb3NlKCksbnVsbCE9dGhpcy5hY2N1bXVsYXRpb25zKWZvcih2YXIgZSBpbiB0aGlzLmFjY3VtdWxhdGlvbnMpdGhpcy5hY2N1bXVsYXRpb25zW2VdLmRpc3Bvc2UoKX0sbi5wcm90b3R5cGUuc2V0TW9tZW50dW09ZnVuY3Rpb24odCl7dGhpcy5tb21lbnR1bT10fSxuLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLG1vbWVudHVtOnRoaXMubW9tZW50dW0sdXNlTmVzdGVyb3Y6dGhpcy51c2VOZXN0ZXJvdn19LG4uZnJvbUNvbmZpZz1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgdChlLmxlYXJuaW5nUmF0ZSxlLm1vbWVudHVtLGUudXNlTmVzdGVyb3YpfSxuLmNsYXNzTmFtZT1cIk1vbWVudHVtT3B0aW1pemVyXCIsbn0oX2gpO3loKE1oKTt2YXIgRmg9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbihlLG4scixvLGEpe3ZvaWQgMD09PW4mJihuPS45KSx2b2lkIDA9PT1yJiYocj0wKSx2b2lkIDA9PT1vJiYobz1udWxsKSx2b2lkIDA9PT1hJiYoYT0hMSk7dmFyIGk9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBpLmxlYXJuaW5nUmF0ZT1lLGkuZGVjYXk9bixpLm1vbWVudHVtPXIsaS5lcHNpbG9uPW8saS5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzPXt9LGkuYWNjdW11bGF0ZWRNZWFuR3JhZHM9e30saS5hY2N1bXVsYXRlZE1vbWVudHM9e30saS5jZW50ZXJlZD1hLG51bGw9PW8mJihpLmVwc2lsb249RHQuYmFja2VuZC5lcHNpbG9uKCkpLGl9cmV0dXJuIGUobix0KSxuLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLG49ZnVuY3Rpb24obil7dmFyIG89RHQucmVnaXN0ZXJlZFZhcmlhYmxlc1tuXTtpZihudWxsPT1yLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbbl0pe0ZlKGZ1bmN0aW9uKCl7ZS5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW25dPVhuKG8pLnZhcmlhYmxlKCExKX0pfWlmKG51bGw9PXIuYWNjdW11bGF0ZWRNZWFuR3JhZHNbbl0mJnIuY2VudGVyZWQpe0ZlKGZ1bmN0aW9uKCl7ZS5hY2N1bXVsYXRlZE1lYW5HcmFkc1tuXT1YbihvKS52YXJpYWJsZSghMSl9KX1pZihudWxsPT1yLmFjY3VtdWxhdGVkTW9tZW50c1tuXSl7RmUoZnVuY3Rpb24oKXtlLmFjY3VtdWxhdGVkTW9tZW50c1tuXT1YbihvKS52YXJpYWJsZSghMSl9KX12YXIgYT1yLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbbl0saT1yLmFjY3VtdWxhdGVkTWVhbkdyYWRzW25dLHM9ci5hY2N1bXVsYXRlZE1vbWVudHNbbl0sdT10W25dO0ZlKGZ1bmN0aW9uKCl7dmFyIHQ9YS5tdWwoZS5kZWNheSkuYWRkKHUuc3F1YXJlKCkubXVsKDEtZS5kZWNheSkpO2lmKGUuY2VudGVyZWQpe3ZhciByPWkubXVsKGUuZGVjYXkpLmFkZCh1Lm11bCgxLWUuZGVjYXkpKSxsPXMubXVsKGUubW9tZW50dW0pLmFkZCh1Lm11bChlLmxlYXJuaW5nUmF0ZSkuZGl2KHQuc3ViKHIuc3F1YXJlKCkuYWRkKGUuZXBzaWxvbikpLnNxcnQoKSkpO2UuYWNjdW11bGF0ZWRNZWFuU3F1YXJlc1tuXS5hc3NpZ24odCksZS5hY2N1bXVsYXRlZE1lYW5HcmFkc1tuXS5hc3NpZ24ociksZS5hY2N1bXVsYXRlZE1vbWVudHNbbl0uYXNzaWduKGwpO3ZhciBjPW8uc3ViKGwpO28uYXNzaWduKGMpfWVsc2V7dmFyIGg9YS5tdWwoZS5kZWNheSkuYWRkKHUuc3F1YXJlKCkubXVsKDEtZS5kZWNheSkpO2w9cy5tdWwoZS5tb21lbnR1bSkuYWRkKHUubXVsKGUubGVhcm5pbmdSYXRlKS5kaXYoaC5hZGQoZS5lcHNpbG9uKS5zcXJ0KCkpKTtlLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbbl0uYXNzaWduKGgpLGUuYWNjdW11bGF0ZWRNb21lbnRzW25dLmFzc2lnbihsKTtjPW8uc3ViKGwpO28uYXNzaWduKGMpfX0pfSxyPXRoaXM7Zm9yKHZhciBvIGluIHQpbihvKX0sbi5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3ZhciB0PXRoaXM7bnVsbCE9dGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzJiZPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXMpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQuYWNjdW11bGF0ZWRNZWFuU3F1YXJlc1tlXS5kaXNwb3NlKCl9KSxudWxsIT10aGlzLmFjY3VtdWxhdGVkTWVhbkdyYWRzJiZ0aGlzLmNlbnRlcmVkJiZPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkTWVhbkdyYWRzKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0LmFjY3VtdWxhdGVkTWVhbkdyYWRzW2VdLmRpc3Bvc2UoKX0pLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRNb21lbnRzJiZPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkTW9tZW50cykuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdC5hY2N1bXVsYXRlZE1vbWVudHNbZV0uZGlzcG9zZSgpfSl9LG4ucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGUsZGVjYXk6dGhpcy5kZWNheSxtb21lbnR1bTp0aGlzLm1vbWVudHVtLGVwc2lsb246dGhpcy5lcHNpbG9uLGNlbnRlcmVkOnRoaXMuY2VudGVyZWR9fSxuLmZyb21Db25maWc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IHQoZS5sZWFybmluZ1JhdGUsZS5kZWNheSxlLm1vbWVudHVtLGUuZXBzaWxvbixlLmNlbnRlcmVkKX0sbi5jbGFzc05hbWU9XCJSTVNQcm9wT3B0aW1pemVyXCIsbn0oSWgpO3loKEZoKTt2YXIgQmg9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnNnZD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IF9oKHQpfSx0Lm1vbWVudHVtPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49ITEpLG5ldyBNaCh0LGUsbil9LHQucm1zcHJvcD1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB2b2lkIDA9PT1lJiYoZT0uOSksdm9pZCAwPT09biYmKG49MCksdm9pZCAwPT09ciYmKHI9bnVsbCksdm9pZCAwPT09byYmKG89ITEpLG5ldyBGaCh0LGUsbixyLG8pfSx0LmFkYW09ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHZvaWQgMD09PXQmJih0PS4wMDEpLHZvaWQgMD09PWUmJihlPS45KSx2b2lkIDA9PT1uJiYobj0uOTk5KSx2b2lkIDA9PT1yJiYocj1udWxsKSxuZXcgRGgodCxlLG4scil9LHQuYWRhZGVsdGE9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT10JiYodD0uMDAxKSx2b2lkIDA9PT1lJiYoZT0uOTUpLHZvaWQgMD09PW4mJihuPW51bGwpLG5ldyBBaCh0LGUsbil9LHQuYWRhbWF4PWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIHZvaWQgMD09PXQmJih0PS4wMDIpLHZvaWQgMD09PWUmJihlPS45KSx2b2lkIDA9PT1uJiYobj0uOTk5KSx2b2lkIDA9PT1yJiYocj1udWxsKSx2b2lkIDA9PT1vJiYobz0wKSxuZXcgT2godCxlLG4scixvKX0sdC5hZGFncmFkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPS4xKSxuZXcgVGgodCxlKX0sdH0oKSxQaD17c2dkOkJoLnNnZCxtb21lbnR1bTpCaC5tb21lbnR1bSxhZGFkZWx0YTpCaC5hZGFkZWx0YSxhZGFncmFkOkJoLmFkYWdyYWQscm1zcHJvcDpCaC5ybXNwcm9wLGFkYW1heDpCaC5hZGFtYXgsYWRhbTpCaC5hZGFtfSxMaD1cInVuZGVmaW5lZFwiIT10eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lP3JlcXVlc3RBbmltYXRpb25GcmFtZTpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2V0SW1tZWRpYXRlP3NldEltbWVkaWF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdCgpfTtmdW5jdGlvbiBXaCgpe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbih0KXtyZXR1cm4gTGgoZnVuY3Rpb24oKXtyZXR1cm4gdCgpfSl9KX1odD1tYztleHBvcnR7QWggYXMgQWRhZGVsdGFPcHRpbWl6ZXIsVGggYXMgQWRhZ3JhZE9wdGltaXplcixEaCBhcyBBZGFtT3B0aW1pemVyLE9oIGFzIEFkYW1heE9wdGltaXplcixZbiBhcyBEYXRhU3RvcmFnZSxhIGFzIEVOVixpIGFzIEVudmlyb25tZW50LFFuIGFzIEtlcm5lbEJhY2tlbmQsTWggYXMgTW9tZW50dW1PcHRpbWl6ZXIsSWggYXMgT3B0aW1pemVyLEZoIGFzIFJNU1Byb3BPcHRpbWl6ZXIsdnQgYXMgUmFuayxxbCBhcyBSZWR1Y3Rpb24sX2ggYXMgU0dET3B0aW1pemVyLGZ0IGFzIFRlbnNvcixsdCBhcyBUZW5zb3JCdWZmZXIsZHQgYXMgVmFyaWFibGUsVmkgYXMgYWJzLEdpIGFzIGFjb3MscWkgYXMgYWNvc2gscXUgYXMgYWRkLEh1IGFzIGFkZE4sJHUgYXMgYWRkU3RyaWN0LGJ1IGFzIGFsbCxDdSBhcyBhbnksRXUgYXMgYXJnTWF4LFJ1IGFzIGFyZ01pbixIaSBhcyBhc2luLCRpIGFzIGFzaW5oLGppIGFzIGF0YW4sanUgYXMgYXRhbjIsS2kgYXMgYXRhbmgsZnUgYXMgYXZnUG9vbCwkZSBhcyBiYWNrZW5kLEFsIGFzIGJhc2ljTFNUTUNlbGwsX3MgYXMgYmF0Y2hOb3JtLE1zIGFzIGJhdGNoTm9ybTJkLEZzIGFzIGJhdGNoTm9ybTNkLEJzIGFzIGJhdGNoTm9ybTRkLE9zIGFzIGJhdGNoTm9ybWFsaXphdGlvbixBcyBhcyBiYXRjaE5vcm1hbGl6YXRpb24yZCxUcyBhcyBiYXRjaE5vcm1hbGl6YXRpb24zZCxEcyBhcyBiYXRjaE5vcm1hbGl6YXRpb240ZCxJciBhcyBiYXRjaFRvU3BhY2VORCx2aCBhcyBicm93c2VyLE5yIGFzIGJ1ZmZlcixBciBhcyBjYXN0LFhpIGFzIGNlaWwsWWkgYXMgY2xpcEJ5VmFsdWUsVHIgYXMgY2xvbmUsT24gYXMgY29tcGxleCxsciBhcyBjb25jYXQsY3IgYXMgY29uY2F0MWQsaHIgYXMgY29uY2F0MmQscHIgYXMgY29uY2F0M2QsZnIgYXMgY29uY2F0NGQsWHMgYXMgY29udjFkLFlzIGFzIGNvbnYyZCxKcyBhcyBjb252MmREZXJGaWx0ZXIsZXUgYXMgY29udjJkVHJhbnNwb3NlLFFzIGFzIGNvbnYzZCxRaSBhcyBjb3MsSmkgYXMgY29zaCxEciBhcyBjdW1zdW0sa24gYXMgY3VzdG9tR3JhZCxEZSBhcyBkZXByZWNhdGlvbldhcm4sT3IgYXMgZGVwdGhUb1NwYWNlLFpzIGFzIGRlcHRod2lzZUNvbnYyZCxUZSBhcyBkaXNhYmxlRGVwcmVjYXRpb25XYXJuaW5ncyxCZSBhcyBkaXNwb3NlLE9lIGFzIGRpc3Bvc2VWYXJpYWJsZXMsS3UgYXMgZGl2LFh1IGFzIGRpdlN0cmljdCxydSBhcyBkb3QsVmwgYXMgZHJvcG91dCxnbCBhcyBlbHUsQWUgYXMgZW5hYmxlRGVidWdNb2RlLEllIGFzIGVuYWJsZVByb2RNb2RlLGwgYXMgZW52aXJvbm1lbnQsT3UgYXMgZXF1YWwsX3UgYXMgZXF1YWxTdHJpY3QsWmkgYXMgZXJmLHRzIGFzIGV4cCxfciBhcyBleHBhbmREaW1zLGVzIGFzIGV4cG0xLE1yIGFzIGV5ZSxGbCBhcyBmZnQsSG4gYXMgZmlsbCxHZSBhcyBmaW5kQmFja2VuZCxxZSBhcyBmaW5kQmFja2VuZEZhY3RvcnksbnMgYXMgZmxvb3IsWXUgYXMgZmxvb3JEaXYsdmMgYXMgZnVzZWQsa2wgYXMgZ2F0aGVyLHpsIGFzIGdhdGhlck5ELHplIGFzIGdldEJhY2tlbmQsQ24gYXMgZ3JhZCxFbiBhcyBncmFkcyxNdSBhcyBncmVhdGVyLEZ1IGFzIGdyZWF0ZXJFcXVhbCxCdSBhcyBncmVhdGVyRXF1YWxTdHJpY3QsUHUgYXMgZ3JlYXRlclN0cmljdCwkbCBhcyBoYW1taW5nV2luZG93LEhsIGFzIGhhbm5XaW5kb3csQmwgYXMgaWZmdCxNbiBhcyBpbWFnLGZjIGFzIGltYWdlLGhoIGFzIGlvLExsIGFzIGlyZmZ0LGRzIGFzIGlzRmluaXRlLGZzIGFzIGlzSW5mLHBzIGFzIGlzTmFOLFBlIGFzIGtlZXAseWwgYXMgbGVha3lSZWx1LEx1IGFzIGxlc3MsV3UgYXMgbGVzc0VxdWFsLFV1IGFzIGxlc3NFcXVhbFN0cmljdCx6dSBhcyBsZXNzU3RyaWN0LGljIGFzIGxpbmFsZywkbiBhcyBsaW5zcGFjZSxFbCBhcyBsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbixycyBhcyBsb2csb3MgYXMgbG9nMXAsYXMgYXMgbG9nU2lnbW9pZCxEbiBhcyBsb2dTb2Z0bWF4LFN1IGFzIGxvZ1N1bUV4cCxobCBhcyBsb2dpY2FsQW5kLHBsIGFzIGxvZ2ljYWxOb3QsZmwgYXMgbG9naWNhbE9yLGRsIGFzIGxvZ2ljYWxYb3IsbmMgYXMgbG9zc2VzLG51IGFzIG1hdE11bCxmaCBhcyBtYXRoLE51IGFzIG1heCxwdSBhcyBtYXhQb29sLFF1IGFzIG1heGltdW0sSnUgYXMgbWF4aW11bVN0cmljdCxrdSBhcyBtZWFuLF9lIGFzIG1lbW9yeSxJdSBhcyBtaW4sWnUgYXMgbWluaW11bSx0bCBhcyBtaW5pbXVtU3RyaWN0LGVsIGFzIG1vZCxubCBhcyBtb2RTdHJpY3QsQXUgYXMgbW9tZW50cyxEbCBhcyBtb3ZpbmdBdmVyYWdlLHJsIGFzIG11bCxvbCBhcyBtdWxTdHJpY3QsVGwgYXMgbXVsdGlSTk5DZWxsLEZyIGFzIG11bHRpbm9taWFsLGlzIGFzIG5lZyxXaCBhcyBuZXh0RnJhbWUsUmwgYXMgbm9ybSxWdSBhcyBub3RFcXVhbCxHdSBhcyBub3RFcXVhbFN0cmljdCxCciBhcyBvbmVIb3QsR24gYXMgb25lcyxLbiBhcyBvbmVzTGlrZSxBbiBhcyBvcCxvdSBhcyBvdXRlclByb2R1Y3QsUHIgYXMgcGFkLExyIGFzIHBhZDFkLFdyIGFzIHBhZDJkLFVyIGFzIHBhZDNkLHpyIGFzIHBhZDRkLGR1IGFzIHBvb2wsYWwgYXMgcG93LGlsIGFzIHBvd1N0cmljdCx4bCBhcyBwcmVsdSxrciBhcyBwcmludCxEdSBhcyBwcm9kLE1lIGFzIHByb2ZpbGUsVnIgYXMgcmFuZCxHciBhcyByYW5kb21Ob3JtYWwscXIgYXMgcmFuZG9tVW5pZm9ybSxqbiBhcyByYW5nZSxVZSBhcyByZWFkeSxfbiBhcyByZWFsLHNzIGFzIHJlY2lwcm9jYWwsSGUgYXMgcmVnaXN0ZXJCYWNrZW5kLHdsIGFzIHJlbHUsVmUgYXMgcmVtb3ZlQmFja2VuZCxIciBhcyByZXNoYXBlLGF1IGFzIHJldmVyc2UsaXUgYXMgcmV2ZXJzZTFkLHN1IGFzIHJldmVyc2UyZCx1dSBhcyByZXZlcnNlM2QsbHUgYXMgcmV2ZXJzZTRkLFBsIGFzIHJmZnQsdXMgYXMgcm91bmQsbHMgYXMgcnNxcnQsQm4gYXMgc2NhbGFyLE1sIGFzIHNjYXR0ZXJORCxibCBhcyBzZWx1LHR1IGFzIHNlcGFyYWJsZUNvbnYyZCx4aCBhcyBzZXJpYWxpemF0aW9uLFdlIGFzIHNldEJhY2tlbmQsSnIgYXMgc2V0ZGlmZjFkQXN5bmMsY3MgYXMgc2lnbW9pZCxocyBhcyBzaWduLHZzIGFzIHNpbixtcyBhcyBzaW5oLHZ1IGFzIHNsaWNlLG11IGFzIHNsaWNlMWQsZ3UgYXMgc2xpY2UyZCx5dSBhcyBzbGljZTNkLHh1IGFzIHNsaWNlNGQsVG4gYXMgc29mdG1heCxncyBhcyBzb2Z0cGx1cywkciBhcyBzcGFjZVRvQmF0Y2hORCxVbCBhcyBzcGFyc2VUb0RlbnNlLFdsIGFzIHNwZWN0cmFsLGRyIGFzIHNwbGl0LHlzIGFzIHNxcnQseHMgYXMgc3F1YXJlLHNsIGFzIHNxdWFyZWREaWZmZXJlbmNlLHVsIGFzIHNxdWFyZWREaWZmZXJlbmNlU3RyaWN0LGpyIGFzIHNxdWVlemUsS3IgYXMgc3RhY2ssd3MgYXMgc3RlcCxPbCBhcyBzdHJpZGVkU2xpY2UsbGwgYXMgc3ViLGNsIGFzIHN1YlN0cmljdCxUdSBhcyBzdW0sYnMgYXMgdGFuLENzIGFzIHRhbmgsRm4gYXMgdGVuc29yLFBuIGFzIHRlbnNvcjFkLExuIGFzIHRlbnNvcjJkLFduIGFzIHRlbnNvcjNkLFVuIGFzIHRlbnNvcjRkLHpuIGFzIHRlbnNvcjVkLFZuIGFzIHRlbnNvcjZkLEl0IGFzIHRlbnNvcl91dGlsLFNoIGFzIHRlc3RfdXRpbCxGZSBhcyB0aWR5LFhyIGFzIHRpbGUsTGUgYXMgdGltZSxfbCBhcyB0b3BrLFBoIGFzIHRyYWluLENsIGFzIHRyYW5zcG9zZSxZciBhcyB0cnVuY2F0ZWROb3JtYWwsSWwgYXMgdW5zb3J0ZWRTZWdtZW50U3VtLFFyIGFzIHVuc3RhY2ssWiBhcyB1dGlsLFJuIGFzIHZhbHVlQW5kR3JhZCxTbiBhcyB2YWx1ZUFuZEdyYWRzLHd0IGFzIHZhcmlhYmxlLE5uIGFzIHZhcmlhYmxlR3JhZHMsTmggYXMgdmVyc2lvbl9jb3JlLGtoIGFzIHdlYmdsLHZsIGFzIHdoZXJlLG1sIGFzIHdoZXJlQXN5bmMscW4gYXMgemVyb3MsWG4gYXMgemVyb3NMaWtlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRmLWNvcmUuZXNtLmpzLm1hcFxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuaW1wb3J0e3V0aWwsdGlkeSxkZXByZWNhdGlvbldhcm4sVGVuc29yLHN0YWNrLHRlbnNvcixFTlYsY2xvbmUsZGlzcG9zZSx0ZW5zb3JfdXRpbCx0ZW5zb3IxZCx0ZW5zb3IyZCxicm93c2VyLGltYWdlfWZyb21cIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiO3ZhciBleHRlbmRTdGF0aWNzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuKGV4dGVuZFN0YXRpY3M9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZX18fGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShyKSYmKHRbcl09ZVtyXSl9KSh0LGUpfTtmdW5jdGlvbiBfX2V4dGVuZHModCxlKXtmdW5jdGlvbiByKCl7dGhpcy5jb25zdHJ1Y3Rvcj10fWV4dGVuZFN0YXRpY3ModCxlKSx0LnByb3RvdHlwZT1udWxsPT09ZT9PYmplY3QuY3JlYXRlKGUpOihyLnByb3RvdHlwZT1lLnByb3RvdHlwZSxuZXcgcil9ZnVuY3Rpb24gX19hd2FpdGVyKHQsZSxyLG4pe3JldHVybiBuZXcocnx8KHI9UHJvbWlzZSkpKGZ1bmN0aW9uKGksbyl7ZnVuY3Rpb24gYSh0KXt0cnl7cyhuLm5leHQodCkpfWNhdGNoKHQpe28odCl9fWZ1bmN0aW9uIHUodCl7dHJ5e3Mobi50aHJvdyh0KSl9Y2F0Y2godCl7byh0KX19ZnVuY3Rpb24gcyh0KXt0LmRvbmU/aSh0LnZhbHVlKTpuZXcgcihmdW5jdGlvbihlKXtlKHQudmFsdWUpfSkudGhlbihhLHUpfXMoKG49bi5hcHBseSh0LGV8fFtdKSkubmV4dCgpKX0pfWZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHQsZSl7dmFyIHIsbixpLG8sYT17bGFiZWw6MCxzZW50OmZ1bmN0aW9uKCl7aWYoMSZpWzBdKXRocm93IGlbMV07cmV0dXJuIGlbMV19LHRyeXM6W10sb3BzOltdfTtyZXR1cm4gbz17bmV4dDp1KDApLHRocm93OnUoMSkscmV0dXJuOnUoMil9LFwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmKG9bU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSksbztmdW5jdGlvbiB1KG8pe3JldHVybiBmdW5jdGlvbih1KXtyZXR1cm4gZnVuY3Rpb24obyl7aWYocil0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtmb3IoO2E7KXRyeXtpZihyPTEsbiYmKGk9MiZvWzBdP24ucmV0dXJuOm9bMF0/bi50aHJvd3x8KChpPW4ucmV0dXJuKSYmaS5jYWxsKG4pLDApOm4ubmV4dCkmJiEoaT1pLmNhbGwobixvWzFdKSkuZG9uZSlyZXR1cm4gaTtzd2l0Y2gobj0wLGkmJihvPVsyJm9bMF0saS52YWx1ZV0pLG9bMF0pe2Nhc2UgMDpjYXNlIDE6aT1vO2JyZWFrO2Nhc2UgNDpyZXR1cm4gYS5sYWJlbCsrLHt2YWx1ZTpvWzFdLGRvbmU6ITF9O2Nhc2UgNTphLmxhYmVsKyssbj1vWzFdLG89WzBdO2NvbnRpbnVlO2Nhc2UgNzpvPWEub3BzLnBvcCgpLGEudHJ5cy5wb3AoKTtjb250aW51ZTtkZWZhdWx0OmlmKCEoaT0oaT1hLnRyeXMpLmxlbmd0aD4wJiZpW2kubGVuZ3RoLTFdKSYmKDY9PT1vWzBdfHwyPT09b1swXSkpe2E9MDtjb250aW51ZX1pZigzPT09b1swXSYmKCFpfHxvWzFdPmlbMF0mJm9bMV08aVszXSkpe2EubGFiZWw9b1sxXTticmVha31pZig2PT09b1swXSYmYS5sYWJlbDxpWzFdKXthLmxhYmVsPWlbMV0saT1vO2JyZWFrfWlmKGkmJmEubGFiZWw8aVsyXSl7YS5sYWJlbD1pWzJdLGEub3BzLnB1c2gobyk7YnJlYWt9aVsyXSYmYS5vcHMucG9wKCksYS50cnlzLnBvcCgpO2NvbnRpbnVlfW89ZS5jYWxsKHQsYSl9Y2F0Y2godCl7bz1bNix0XSxuPTB9ZmluYWxseXtyPWk9MH1pZig1Jm9bMF0pdGhyb3cgb1sxXTtyZXR1cm57dmFsdWU6b1swXT9vWzFdOnZvaWQgMCxkb25lOiEwfX0oW28sdV0pfX19dmFyIGNvbW1vbmpzR2xvYmFsPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6e307ZnVuY3Rpb24gdW53cmFwRXhwb3J0cyh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxcImRlZmF1bHRcIik/dC5kZWZhdWx0OnR9ZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUodCxlKXtyZXR1cm4gdChlPXtleHBvcnRzOnt9fSxlLmV4cG9ydHMpLGUuZXhwb3J0c312YXIgYWxlYT1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbih0KXshZnVuY3Rpb24odCxlLHIpe2Z1bmN0aW9uIG4odCxlKXtyZXR1cm4gZS5jPXQuYyxlLnMwPXQuczAsZS5zMT10LnMxLGUuczI9dC5zMixlfWZ1bmN0aW9uIGkodCxlKXt2YXIgcj1uZXcgZnVuY3Rpb24odCl7dmFyIGUscj10aGlzLG49KGU9NDAyMjg3MTE5NyxmdW5jdGlvbih0KXt0PXQudG9TdHJpbmcoKTtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG49LjAyNTE5NjAzMjgyNDE2OTM4KihlKz10LmNoYXJDb2RlQXQocikpO24tPWU9bj4+PjAsZT0obio9ZSk+Pj4wLGUrPTQyOTQ5NjcyOTYqKG4tPWUpfXJldHVybiAyLjMyODMwNjQzNjUzODY5NjNlLTEwKihlPj4+MCl9KTtyLm5leHQ9ZnVuY3Rpb24oKXt2YXIgdD0yMDkxNjM5KnIuczArMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMCpyLmM7cmV0dXJuIHIuczA9ci5zMSxyLnMxPXIuczIsci5zMj10LShyLmM9MHx0KX0sci5jPTEsci5zMD1uKFwiIFwiKSxyLnMxPW4oXCIgXCIpLHIuczI9bihcIiBcIiksci5zMC09bih0KSxyLnMwPDAmJihyLnMwKz0xKSxyLnMxLT1uKHQpLHIuczE8MCYmKHIuczErPTEpLHIuczItPW4odCksci5zMjwwJiYoci5zMis9MSksbj1udWxsfSh0KSxpPWUmJmUuc3RhdGUsbz1yLm5leHQ7cmV0dXJuIG8uaW50MzI9ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDk2NzI5NipyLm5leHQoKXwwfSxvLmRvdWJsZT1mdW5jdGlvbigpe3JldHVybiBvKCkrMS4xMTAyMjMwMjQ2MjUxNTY1ZS0xNiooMjA5NzE1MipvKCl8MCl9LG8ucXVpY2s9byxpJiYoXCJvYmplY3RcIj09dHlwZW9mIGkmJm4oaSxyKSxvLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG4ocix7fSl9KSxvfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9aTpyJiZyLmFtZD9yKGZ1bmN0aW9uKCl7cmV0dXJuIGl9KTp0aGlzLmFsZWE9aX0oMCx0LCExKX0pLHhvcjEyOD1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbih0KXshZnVuY3Rpb24odCxlLHIpe2Z1bmN0aW9uIG4odCxlKXtyZXR1cm4gZS54PXQueCxlLnk9dC55LGUuej10LnosZS53PXQudyxlfWZ1bmN0aW9uIGkodCxlKXt2YXIgcj1uZXcgZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPVwiXCI7ZS54PTAsZS55PTAsZS56PTAsZS53PTAsZS5uZXh0PWZ1bmN0aW9uKCl7dmFyIHQ9ZS54XmUueDw8MTE7cmV0dXJuIGUueD1lLnksZS55PWUueixlLno9ZS53LGUud149ZS53Pj4+MTledF50Pj4+OH0sdD09PSgwfHQpP2UueD10OnIrPXQ7Zm9yKHZhciBuPTA7bjxyLmxlbmd0aCs2NDtuKyspZS54Xj0wfHIuY2hhckNvZGVBdChuKSxlLm5leHQoKX0odCksaT1lJiZlLnN0YXRlLG89ZnVuY3Rpb24oKXtyZXR1cm4oci5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2fTtyZXR1cm4gby5kb3VibGU9ZnVuY3Rpb24oKXtkb3t2YXIgdD0oKHIubmV4dCgpPj4+MTEpKyhyLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYpLygxPDwyMSl9d2hpbGUoMD09PXQpO3JldHVybiB0fSxvLmludDMyPXIubmV4dCxvLnF1aWNrPW8saSYmKFwib2JqZWN0XCI9PXR5cGVvZiBpJiZuKGksciksby5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBuKHIse30pfSksb31lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPWk6ciYmci5hbWQ/cihmdW5jdGlvbigpe3JldHVybiBpfSk6dGhpcy54b3IxMjg9aX0oMCx0LCExKX0pLHhvcndvdz1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbih0KXshZnVuY3Rpb24odCxlLHIpe2Z1bmN0aW9uIG4odCxlKXtyZXR1cm4gZS54PXQueCxlLnk9dC55LGUuej10LnosZS53PXQudyxlLnY9dC52LGUuZD10LmQsZX1mdW5jdGlvbiBpKHQsZSl7dmFyIHI9bmV3IGZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMscj1cIlwiO2UubmV4dD1mdW5jdGlvbigpe3ZhciB0PWUueF5lLng+Pj4yO3JldHVybiBlLng9ZS55LGUueT1lLnosZS56PWUudyxlLnc9ZS52LChlLmQ9ZS5kKzM2MjQzN3wwKSsoZS52PWUudl5lLnY8PDRedF50PDwxKXwwfSxlLng9MCxlLnk9MCxlLno9MCxlLnc9MCxlLnY9MCx0PT09KDB8dCk/ZS54PXQ6cis9dDtmb3IodmFyIG49MDtuPHIubGVuZ3RoKzY0O24rKyllLnhePTB8ci5jaGFyQ29kZUF0KG4pLG49PXIubGVuZ3RoJiYoZS5kPWUueDw8MTBeZS54Pj4+NCksZS5uZXh0KCl9KHQpLGk9ZSYmZS5zdGF0ZSxvPWZ1bmN0aW9uKCl7cmV0dXJuKHIubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIG8uZG91YmxlPWZ1bmN0aW9uKCl7ZG97dmFyIHQ9KChyLm5leHQoKT4+PjExKSsoci5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2KS8oMTw8MjEpfXdoaWxlKDA9PT10KTtyZXR1cm4gdH0sby5pbnQzMj1yLm5leHQsby5xdWljaz1vLGkmJihcIm9iamVjdFwiPT10eXBlb2YgaSYmbihpLHIpLG8uc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbihyLHt9KX0pLG99ZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1pOnImJnIuYW1kP3IoZnVuY3Rpb24oKXtyZXR1cm4gaX0pOnRoaXMueG9yd293PWl9KDAsdCwhMSl9KSx4b3JzaGlmdDc9Y3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxyKXtmdW5jdGlvbiBuKHQsZSl7cmV0dXJuIGUueD10Lnguc2xpY2UoKSxlLmk9dC5pLGV9ZnVuY3Rpb24gaSh0LGUpe251bGw9PXQmJih0PStuZXcgRGF0ZSk7dmFyIHI9bmV3IGZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7ZS5uZXh0PWZ1bmN0aW9uKCl7dmFyIHQscixuPWUueCxpPWUuaTtyZXR1cm4gdD1uW2ldLHI9KHRePXQ+Pj43KV50PDwyNCxyXj0odD1uW2krMSY3XSledD4+PjEwLHJePSh0PW5baSszJjddKV50Pj4+MyxyXj0odD1uW2krNCY3XSledDw8Nyx0PW5baSs3JjddLHJePSh0Xj10PDwxMyledDw8OSxuW2ldPXIsZS5pPWkrMSY3LHJ9LGZ1bmN0aW9uKHQsZSl7dmFyIHIsbj1bXTtpZihlPT09KDB8ZSkpblswXT1lO2Vsc2UgZm9yKGU9XCJcIitlLHI9MDtyPGUubGVuZ3RoOysrciluWzcmcl09bls3JnJdPDwxNV5lLmNoYXJDb2RlQXQocikrbltyKzEmN108PDEzO2Zvcig7bi5sZW5ndGg8ODspbi5wdXNoKDApO2ZvcihyPTA7cjw4JiYwPT09bltyXTsrK3IpO2Zvcig4PT1yP25bN109LTE6bltyXSx0Lng9bix0Lmk9MCxyPTI1NjtyPjA7LS1yKXQubmV4dCgpfShlLHQpfSh0KSxpPWUmJmUuc3RhdGUsbz1mdW5jdGlvbigpe3JldHVybihyLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBvLmRvdWJsZT1mdW5jdGlvbigpe2Rve3ZhciB0PSgoci5uZXh0KCk+Pj4xMSkrKHIubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvKDE8PDIxKX13aGlsZSgwPT09dCk7cmV0dXJuIHR9LG8uaW50MzI9ci5uZXh0LG8ucXVpY2s9byxpJiYoaS54JiZuKGksciksby5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBuKHIse30pfSksb31lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPWk6ciYmci5hbWQ/cihmdW5jdGlvbigpe3JldHVybiBpfSk6dGhpcy54b3JzaGlmdDc9aX0oMCx0LCExKX0pLHhvcjQwOTY9Y3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxyKXtmdW5jdGlvbiBuKHQsZSl7cmV0dXJuIGUuaT10LmksZS53PXQudyxlLlg9dC5YLnNsaWNlKCksZX1mdW5jdGlvbiBpKHQsZSl7bnVsbD09dCYmKHQ9K25ldyBEYXRlKTt2YXIgcj1uZXcgZnVuY3Rpb24odCl7dmFyIGU9dGhpcztlLm5leHQ9ZnVuY3Rpb24oKXt2YXIgdCxyLG49ZS53LGk9ZS5YLG89ZS5pO3JldHVybiBlLnc9bj1uKzE2NDA1MzE1Mjd8MCxyPWlbbyszNCYxMjddLHQ9aVtvPW8rMSYxMjddLHJePXI8PDEzLHRePXQ8PDE3LHJePXI+Pj4xNSx0Xj10Pj4+MTIscj1pW29dPXJedCxlLmk9byxyKyhuXm4+Pj4xNil8MH0sZnVuY3Rpb24odCxlKXt2YXIgcixuLGksbyxhLHU9W10scz0xMjg7Zm9yKGU9PT0oMHxlKT8obj1lLGU9bnVsbCk6KGUrPVwiXFwwXCIsbj0wLHM9TWF0aC5tYXgocyxlLmxlbmd0aCkpLGk9MCxvPS0zMjtvPHM7KytvKWUmJihuXj1lLmNoYXJDb2RlQXQoKG8rMzIpJWUubGVuZ3RoKSksMD09PW8mJihhPW4pLG5ePW48PDEwLG5ePW4+Pj4xNSxuXj1uPDw0LG5ePW4+Pj4xMyxvPj0wJiYoYT1hKzE2NDA1MzE1Mjd8MCxpPTA9PShyPXVbMTI3Jm9dXj1uK2EpP2krMTowKTtmb3IoaT49MTI4JiYodVsxMjcmKGUmJmUubGVuZ3RofHwwKV09LTEpLGk9MTI3LG89NTEyO28+MDstLW8pbj11W2krMzQmMTI3XSxyPXVbaT1pKzEmMTI3XSxuXj1uPDwxMyxyXj1yPDwxNyxuXj1uPj4+MTUscl49cj4+PjEyLHVbaV09bl5yO3Qudz1hLHQuWD11LHQuaT1pfShlLHQpfSh0KSxpPWUmJmUuc3RhdGUsbz1mdW5jdGlvbigpe3JldHVybihyLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBvLmRvdWJsZT1mdW5jdGlvbigpe2Rve3ZhciB0PSgoci5uZXh0KCk+Pj4xMSkrKHIubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvKDE8PDIxKX13aGlsZSgwPT09dCk7cmV0dXJuIHR9LG8uaW50MzI9ci5uZXh0LG8ucXVpY2s9byxpJiYoaS5YJiZuKGksciksby5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBuKHIse30pfSksb31lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPWk6ciYmci5hbWQ/cihmdW5jdGlvbigpe3JldHVybiBpfSk6dGhpcy54b3I0MDk2PWl9KDAsdCwhMSl9KSx0eWNoZWk9Y3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxyKXtmdW5jdGlvbiBuKHQsZSl7cmV0dXJuIGUuYT10LmEsZS5iPXQuYixlLmM9dC5jLGUuZD10LmQsZX1mdW5jdGlvbiBpKHQsZSl7dmFyIHI9bmV3IGZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMscj1cIlwiO2UubmV4dD1mdW5jdGlvbigpe3ZhciB0PWUuYixyPWUuYyxuPWUuZCxpPWUuYTtyZXR1cm4gdD10PDwyNV50Pj4+N15yLHI9ci1ufDAsbj1uPDwyNF5uPj4+OF5pLGk9aS10fDAsZS5iPXQ9dDw8MjBedD4+PjEyXnIsZS5jPXI9ci1ufDAsZS5kPW48PDE2XnI+Pj4xNl5pLGUuYT1pLXR8MH0sZS5hPTAsZS5iPTAsZS5jPS0xNjQwNTMxNTI3LGUuZD0xMzY3MTMwNTUxLHQ9PT1NYXRoLmZsb29yKHQpPyhlLmE9dC80Mjk0OTY3Mjk2fDAsZS5iPTB8dCk6cis9dDtmb3IodmFyIG49MDtuPHIubGVuZ3RoKzIwO24rKyllLmJePTB8ci5jaGFyQ29kZUF0KG4pLGUubmV4dCgpfSh0KSxpPWUmJmUuc3RhdGUsbz1mdW5jdGlvbigpe3JldHVybihyLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBvLmRvdWJsZT1mdW5jdGlvbigpe2Rve3ZhciB0PSgoci5uZXh0KCk+Pj4xMSkrKHIubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvKDE8PDIxKX13aGlsZSgwPT09dCk7cmV0dXJuIHR9LG8uaW50MzI9ci5uZXh0LG8ucXVpY2s9byxpJiYoXCJvYmplY3RcIj09dHlwZW9mIGkmJm4oaSxyKSxvLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG4ocix7fSl9KSxvfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9aTpyJiZyLmFtZD9yKGZ1bmN0aW9uKCl7cmV0dXJuIGl9KTp0aGlzLnR5Y2hlaT1pfSgwLHQsITEpfSksc2VlZHJhbmRvbT1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbih0KXshZnVuY3Rpb24oZSxyKXt2YXIgbixpPXRoaXMsbz0yNTYsYT02LHU9XCJyYW5kb21cIixzPXIucG93KG8sYSksYz1yLnBvdygyLDUyKSxsPTIqYyxmPW8tMTtmdW5jdGlvbiBoKHQsaCx2KXt2YXIgeT1bXSxfPWQoZnVuY3Rpb24gdChlLHIpe3ZhciBuLGk9W10sbz10eXBlb2YgZTtpZihyJiZcIm9iamVjdFwiPT1vKWZvcihuIGluIGUpdHJ5e2kucHVzaCh0KGVbbl0sci0xKSl9Y2F0Y2godCl7fXJldHVybiBpLmxlbmd0aD9pOlwic3RyaW5nXCI9PW8/ZTplK1wiXFwwXCJ9KChoPTE9PWg/e2VudHJvcHk6ITB9Omh8fHt9KS5lbnRyb3B5P1t0LG0oZSldOm51bGw9PXQ/ZnVuY3Rpb24oKXt0cnl7dmFyIHQ7cmV0dXJuIG4mJih0PW4ucmFuZG9tQnl0ZXMpP3Q9dChvKToodD1uZXcgVWludDhBcnJheShvKSwoaS5jcnlwdG98fGkubXNDcnlwdG8pLmdldFJhbmRvbVZhbHVlcyh0KSksbSh0KX1jYXRjaCh0KXt2YXIgcj1pLm5hdmlnYXRvcixhPXImJnIucGx1Z2lucztyZXR1cm5bK25ldyBEYXRlLGksYSxpLnNjcmVlbixtKGUpXX19KCk6dCwzKSx5KSx3PW5ldyBmdW5jdGlvbih0KXt2YXIgZSxyPXQubGVuZ3RoLG49dGhpcyxpPTAsYT1uLmk9bi5qPTAsdT1uLlM9W107cnx8KHQ9W3IrK10pO2Zvcig7aTxvOyl1W2ldPWkrKztmb3IoaT0wO2k8bztpKyspdVtpXT11W2E9ZiZhK3RbaSVyXSsoZT11W2ldKV0sdVthXT1lOyhuLmc9ZnVuY3Rpb24odCl7Zm9yKHZhciBlLHI9MCxpPW4uaSxhPW4uaix1PW4uUzt0LS07KWU9dVtpPWYmaSsxXSxyPXIqbyt1W2YmKHVbaV09dVthPWYmYStlXSkrKHVbYV09ZSldO3JldHVybiBuLmk9aSxuLmo9YSxyfSkobyl9KHkpLGc9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dy5nKGEpLGU9cyxyPTA7dDxjOyl0PSh0K3IpKm8sZSo9byxyPXcuZygxKTtmb3IoO3Q+PWw7KXQvPTIsZS89MixyPj4+PTE7cmV0dXJuKHQrcikvZX07cmV0dXJuIGcuaW50MzI9ZnVuY3Rpb24oKXtyZXR1cm4gMHx3LmcoNCl9LGcucXVpY2s9ZnVuY3Rpb24oKXtyZXR1cm4gdy5nKDQpLzQyOTQ5NjcyOTZ9LGcuZG91YmxlPWcsZChtKHcuUyksZSksKGgucGFzc3x8dnx8ZnVuY3Rpb24odCxlLG4saSl7cmV0dXJuIGkmJihpLlMmJnAoaSx3KSx0LnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHAodyx7fSl9KSxuPyhyW3VdPXQsZSk6dH0pKGcsXyxcImdsb2JhbFwiaW4gaD9oLmdsb2JhbDp0aGlzPT1yLGguc3RhdGUpfWZ1bmN0aW9uIHAodCxlKXtyZXR1cm4gZS5pPXQuaSxlLmo9dC5qLGUuUz10LlMuc2xpY2UoKSxlfWZ1bmN0aW9uIGQodCxlKXtmb3IodmFyIHIsbj10K1wiXCIsaT0wO2k8bi5sZW5ndGg7KWVbZiZpXT1mJihyXj0xOSplW2YmaV0pK24uY2hhckNvZGVBdChpKyspO3JldHVybiBtKGUpfWZ1bmN0aW9uIG0odCl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoMCx0KX1pZihyW1wic2VlZFwiK3VdPWgsZChyLnJhbmRvbSgpLGUpLHQuZXhwb3J0cyl7dC5leHBvcnRzPWg7dHJ5e249cmVxdWlyZShcImNyeXB0b1wiKX1jYXRjaCh0KXt9fWVsc2UgMH0oW10sTWF0aCl9KTtzZWVkcmFuZG9tLmFsZWE9YWxlYSxzZWVkcmFuZG9tLnhvcjEyOD14b3IxMjgsc2VlZHJhbmRvbS54b3J3b3c9eG9yd293LHNlZWRyYW5kb20ueG9yc2hpZnQ3PXhvcnNoaWZ0NyxzZWVkcmFuZG9tLnhvcjQwOTY9eG9yNDA5NixzZWVkcmFuZG9tLnR5Y2hlaT10eWNoZWk7dmFyIHNlZWRyYW5kb20kMT1zZWVkcmFuZG9tLHNlZWRyYW5kb21fMT1zZWVkcmFuZG9tJDEuYWxlYTtmdW5jdGlvbiBkZWVwTWFwSW50ZXJuYWwodCxlLHIsbil7aWYodm9pZCAwPT09ciYmKHI9bmV3IE1hcCksdm9pZCAwPT09biYmKG49bmV3IFNldCksbnVsbD09dClyZXR1cm4gbnVsbDtpZihuLmhhcyh0KSl0aHJvdyBuZXcgRXJyb3IoXCJDaXJjdWxhciByZWZlcmVuY2VzIGFyZSBub3Qgc3VwcG9ydGVkLlwiKTtpZihyLmhhcyh0KSlyZXR1cm4gci5nZXQodCk7dmFyIGk9ZSh0KTtpZihpLnJlY3Vyc2UmJm51bGwhPT1pLnZhbHVlKXRocm93IG5ldyBFcnJvcihcIkEgZGVlcCBtYXAgZnVuY3Rpb24gbWF5IG5vdCByZXR1cm4gYm90aCBhIHZhbHVlIGFuZCByZWN1cnNlPXRydWUuXCIpO2lmKGkucmVjdXJzZSl7aWYoaXNJdGVyYWJsZSh0KSl7dmFyIG89QXJyYXkuaXNBcnJheSh0KT9bXTp7fTtmb3IodmFyIGEgaW4gbi5hZGQodCksdCl7dmFyIHU9ZGVlcE1hcEludGVybmFsKHRbYV0sZSxyLG4pO29bYV09dX1yZXR1cm4gbi5kZWxldGUodCksb310aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCByZWN1cnNlIGludG8gbm9uLWl0ZXJhYmxlIHR5cGU6IFwiK3QpfXJldHVybiByLnNldCh0LGkudmFsdWUpLGkudmFsdWV9ZnVuY3Rpb24gZGVlcFppcCh0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT16aXBUb0xpc3QpLGRlZXBaaXBJbnRlcm5hbCh0LGUpfWZ1bmN0aW9uIGRlZXBaaXBJbnRlcm5hbCh0LGUscil7dm9pZCAwPT09ciYmKHI9bmV3IFNldCk7dmFyIG49dFswXTtpZihyLmhhcyhuKSl0aHJvdyBuZXcgRXJyb3IoXCJDaXJjdWxhciByZWZlcmVuY2VzIGFyZSBub3Qgc3VwcG9ydGVkLlwiKTt2YXIgaT1lKHQpO2lmKGkucmVjdXJzZSYmbnVsbCE9PWkudmFsdWUpdGhyb3cgbmV3IEVycm9yKFwiQSBkZWVwIHppcCBmdW5jdGlvbiBtYXkgbm90IHJldHVybiBib3RoIGEgdmFsdWUgYW5kIHJlY3Vyc2U9dHJ1ZS5cIik7aWYoaS5yZWN1cnNlKXtpZihpc0l0ZXJhYmxlKG4pKXt2YXIgbz1BcnJheS5pc0FycmF5KG4pP1tdOnt9O3IuYWRkKG4pO3ZhciBhPWZ1bmN0aW9uKG4pe3ZhciBpPWRlZXBaaXBJbnRlcm5hbCh0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdFtuXX0pLGUscik7b1tuXT1pfTtmb3IodmFyIHUgaW4gbilhKHUpO3JldHVybiByLmRlbGV0ZShuKSxvfXRocm93IG5ldyBFcnJvcihcIkNhbid0IHJlY3Vyc2UgaW50byBub24taXRlcmFibGUgdHlwZTogXCIrbil9cmV0dXJuIGkudmFsdWV9ZnVuY3Rpb24gemlwVG9MaXN0KHQpe3JldHVybiBudWxsPT09dD9udWxsOmlzSXRlcmFibGUodFswXSk/e3ZhbHVlOm51bGwscmVjdXJzZTohMH06e3ZhbHVlOnQscmVjdXJzZTohMX19ZnVuY3Rpb24gZGVlcE1hcEFuZEF3YWl0QWxsKHQsZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgcixuLGksbyxhLHU7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocyl7c3dpdGNoKHMubGFiZWwpe2Nhc2UgMDpyPW5ldyBNYXAsZGVlcE1hcEludGVybmFsKHQsZSxyKSxuPTAsaT1BcnJheS5mcm9tKHIua2V5cygpKSxzLmxhYmVsPTE7Y2FzZSAxOnJldHVybiBuPGkubGVuZ3RoPyhvPWlbbl0sKGE9ci5nZXQobykpaW5zdGFuY2VvZiBQcm9taXNlP1s0LGFdOlszLDNdKTpbMyw0XTtjYXNlIDI6dT1zLnNlbnQoKSxyLnNldChvLHUpLHMubGFiZWw9MztjYXNlIDM6cmV0dXJuIG4rKyxbMywxXTtjYXNlIDQ6cmV0dXJuWzIsZGVlcE1hcEludGVybmFsKHQsZSxyKV19fSl9KX1mdW5jdGlvbiBpc0l0ZXJhYmxlKHQpe3JldHVybiBudWxsIT10JiYoQXJyYXkuaXNBcnJheSh0KXx8XCJvYmplY3RcIj09dHlwZW9mIHQmJiEodCBpbnN0YW5jZW9mIFRlbnNvcikpfWZ1bmN0aW9uIGNhblRlbnNvcmlmeSh0KXtyZXR1cm4gbnVsbD09dHx8aXNQcmltaXRpdmUodCl8fEFycmF5LmlzQXJyYXkodCl8fFwib2JqZWN0XCI9PXR5cGVvZiB0JiZ0IGluc3RhbmNlb2YgVGVuc29yfHx1dGlsLmlzVHlwZWRBcnJheSh0KX1mdW5jdGlvbiBpc1ByaW1pdGl2ZSh0KXtyZXR1cm4gbnVsbD09PXR8fFwib2JqZWN0XCIhPXR5cGVvZiB0JiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0fXZhciBSaW5nQnVmZmVyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLmNhcGFjaXR5PXQsdGhpcy5iZWdpbj0wLHRoaXMuZW5kPTAsbnVsbD09dCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IGNyZWF0ZSBhIHJpbmcgYnVmZmVyIG9mIHVua25vd24gY2FwYWNpdHkuXCIpO2lmKHQ8MSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IGNyZWF0ZSByaW5nIGJ1ZmZlciBvZiBjYXBhY2l0eSA8IDEuXCIpO3RoaXMuZGF0YT1uZXcgQXJyYXkodCksdGhpcy5kb3VibGVkQ2FwYWNpdHk9Mip0fXJldHVybiB0LnByb3RvdHlwZS53cmFwPWZ1bmN0aW9uKHQpe2Zvcig7dDwwOyl0Kz10aGlzLmRvdWJsZWRDYXBhY2l0eTtyZXR1cm4gdCV0aGlzLmRvdWJsZWRDYXBhY2l0eX0sdC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe2lmKHQ8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IGdldCBpdGVtIGF0IGEgbmVnYXRpdmUgaW5kZXguXCIpO3JldHVybiB0aGlzLmRhdGFbdCV0aGlzLmNhcGFjaXR5XX0sdC5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKHQsZSl7aWYodDwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3Qgc2V0IGl0ZW0gYXQgYSBuZWdhdGl2ZSBpbmRleC5cIik7dGhpcy5kYXRhW3QldGhpcy5jYXBhY2l0eV09ZX0sdC5wcm90b3R5cGUubGVuZ3RoPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5lbmQtdGhpcy5iZWdpbjtyZXR1cm4gdDwwJiYodD10aGlzLmRvdWJsZWRDYXBhY2l0eSt0KSx0fSx0LnByb3RvdHlwZS5pc0Z1bGw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZW5ndGgoKT09PXRoaXMuY2FwYWNpdHl9LHQucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMubGVuZ3RoKCl9LHQucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24odCl7aWYodGhpcy5pc0Z1bGwoKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJpbmcgYnVmZmVyIGlzIGZ1bGwuXCIpO3RoaXMuc2V0KHRoaXMuZW5kLHQpLHRoaXMuZW5kPXRoaXMud3JhcCh0aGlzLmVuZCsxKX0sdC5wcm90b3R5cGUucHVzaEFsbD1mdW5jdGlvbih0KXtmb3IodmFyIGU9MCxyPXQ7ZTxyLmxlbmd0aDtlKyspe3ZhciBuPXJbZV07dGhpcy5wdXNoKG4pfX0sdC5wcm90b3R5cGUucG9wPWZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSaW5nIGJ1ZmZlciBpcyBlbXB0eS5cIik7dGhpcy5lbmQ9dGhpcy53cmFwKHRoaXMuZW5kLTEpO3ZhciB0PXRoaXMuZ2V0KHRoaXMuZW5kKTtyZXR1cm4gdGhpcy5zZXQodGhpcy5lbmQsdm9pZCAwKSx0fSx0LnByb3RvdHlwZS51bnNoaWZ0PWZ1bmN0aW9uKHQpe2lmKHRoaXMuaXNGdWxsKCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSaW5nIGJ1ZmZlciBpcyBmdWxsLlwiKTt0aGlzLmJlZ2luPXRoaXMud3JhcCh0aGlzLmJlZ2luLTEpLHRoaXMuc2V0KHRoaXMuYmVnaW4sdCl9LHQucHJvdG90eXBlLnNoaWZ0PWZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSaW5nIGJ1ZmZlciBpcyBlbXB0eS5cIik7dmFyIHQ9dGhpcy5nZXQodGhpcy5iZWdpbik7cmV0dXJuIHRoaXMuc2V0KHRoaXMuYmVnaW4sdm9pZCAwKSx0aGlzLmJlZ2luPXRoaXMud3JhcCh0aGlzLmJlZ2luKzEpLHR9LHQucHJvdG90eXBlLnNodWZmbGVFeGNpc2U9ZnVuY3Rpb24odCl7aWYodGhpcy5pc0VtcHR5KCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSaW5nIGJ1ZmZlciBpcyBlbXB0eS5cIik7dmFyIGU9dGhpcy53cmFwKHRoaXMuYmVnaW4rdCkscj10aGlzLmdldChlKTtyZXR1cm4gdGhpcy5zZXQoZSx0aGlzLnBvcCgpKSxyfSx0fSgpLEdyb3dpbmdSaW5nQnVmZmVyPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gdC5jYWxsKHRoaXMsZS5JTklUSUFMX0NBUEFDSVRZKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuaXNGdWxsPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGUucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24oZSl7dC5wcm90b3R5cGUuaXNGdWxsLmNhbGwodGhpcykmJnRoaXMuZXhwYW5kKCksdC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsZSl9LGUucHJvdG90eXBlLnVuc2hpZnQ9ZnVuY3Rpb24oZSl7dC5wcm90b3R5cGUuaXNGdWxsLmNhbGwodGhpcykmJnRoaXMuZXhwYW5kKCksdC5wcm90b3R5cGUudW5zaGlmdC5jYWxsKHRoaXMsZSl9LGUucHJvdG90eXBlLmV4cGFuZD1mdW5jdGlvbigpe2Zvcih2YXIgdD0yKnRoaXMuY2FwYWNpdHksZT1uZXcgQXJyYXkodCkscj10aGlzLmxlbmd0aCgpLG49MDtuPHI7bisrKWVbbl09dGhpcy5nZXQodGhpcy53cmFwKHRoaXMuYmVnaW4rbikpO3RoaXMuZGF0YT1lLHRoaXMuY2FwYWNpdHk9dCx0aGlzLmRvdWJsZWRDYXBhY2l0eT0yKnRoaXMuY2FwYWNpdHksdGhpcy5iZWdpbj0wLHRoaXMuZW5kPXJ9LGUuSU5JVElBTF9DQVBBQ0lUWT0zMixlfShSaW5nQnVmZmVyKTtmdW5jdGlvbiBpdGVyYXRvckZyb21JdGVtcyh0KXtyZXR1cm4gbmV3IEFycmF5SXRlcmF0b3IodCl9ZnVuY3Rpb24gaXRlcmF0b3JGcm9tRnVuY3Rpb24odCl7cmV0dXJuIG5ldyBGdW5jdGlvbkNhbGxJdGVyYXRvcih0KX1mdW5jdGlvbiBpdGVyYXRvckZyb21Db25jYXRlbmF0ZWQodCxlKXtyZXR1cm4gbmV3IENoYWluZWRJdGVyYXRvcih0LGUpfWZ1bmN0aW9uIGl0ZXJhdG9yRnJvbVppcHBlZCh0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1aaXBNaXNtYXRjaE1vZGUuRkFJTCksbmV3IFppcEl0ZXJhdG9yKHQsZSl9dmFyIFppcE1pc21hdGNoTW9kZSxMYXp5SXRlcmF0b3I9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHQ9W10sWzQsdGhpcy5uZXh0KCldO2Nhc2UgMTplPXIuc2VudCgpLHIubGFiZWw9MjtjYXNlIDI6cmV0dXJuIGUuZG9uZT9bMyw0XToodC5wdXNoKGUudmFsdWUpLFs0LHRoaXMubmV4dCgpXSk7Y2FzZSAzOnJldHVybiBlPXIuc2VudCgpLFszLDJdO2Nhc2UgNDpyZXR1cm5bMix0XX19KX0pfSx0LnByb3RvdHlwZS50b0FycmF5Rm9yVGVzdD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZSxyO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHQ9dGhpcy5wcmVmZXRjaCgxMDApLGU9W10sWzQsdC5uZXh0KCldO2Nhc2UgMTpyPW4uc2VudCgpLG4ubGFiZWw9MjtjYXNlIDI6cmV0dXJuIHIuZG9uZT9bMyw0XTooZS5wdXNoKHIudmFsdWUpLFs0LHQubmV4dCgpXSk7Y2FzZSAzOnJldHVybiByPW4uc2VudCgpLFszLDJdO2Nhc2UgNDpyZXR1cm5bMixlXX19KX0pfSx0LnByb3RvdHlwZS5yZXNvbHZlRnVsbHk9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0O3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5uZXh0KCldO2Nhc2UgMTp0PWUuc2VudCgpLGUubGFiZWw9MjtjYXNlIDI6cmV0dXJuIHQuZG9uZT9bMyw0XTpbNCx0aGlzLm5leHQoKV07Y2FzZSAzOnJldHVybiB0PWUuc2VudCgpLFszLDJdO2Nhc2UgNDpyZXR1cm5bMl19fSl9KX0sdC5wcm90b3R5cGUucmVzb2x2ZVdoaWxlPWZ1bmN0aW9uKHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUscjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMubmV4dCgpXTtjYXNlIDE6ZT1uLnNlbnQoKSxyPXQoZS52YWx1ZSksbi5sYWJlbD0yO2Nhc2UgMjpyZXR1cm4gZS5kb25lfHwhcj9bMyw0XTpbNCx0aGlzLm5leHQoKV07Y2FzZSAzOnJldHVybiBlPW4uc2VudCgpLHI9dChlLnZhbHVlKSxbMywyXTtjYXNlIDQ6cmV0dXJuWzJdfX0pfSl9LHQucHJvdG90eXBlLmhhbmRsZUVycm9ycz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IEVycm9ySGFuZGxpbmdMYXp5SXRlcmF0b3IodGhpcyx0KX0sdC5wcm90b3R5cGUuZmlsdGVyPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgRmlsdGVySXRlcmF0b3IodGhpcyx0KX0sdC5wcm90b3R5cGUubWFwPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcyx0KX0sdC5wcm90b3R5cGUubWFwQXN5bmM9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBBc3luY01hcEl0ZXJhdG9yKHRoaXMsdCl9LHQucHJvdG90eXBlLnNlcmlhbE1hcEFzeW5jPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgQXN5bmNNYXBJdGVyYXRvcih0aGlzLHQpLnNlcmlhbCgpfSx0LnByb3RvdHlwZS5mbGF0bWFwPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgRmxhdG1hcEl0ZXJhdG9yKHRoaXMsdCl9LHQucHJvdG90eXBlLmZvckVhY2hBc3luYz1mdW5jdGlvbih0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVyblsyLHRoaXMubWFwKHQpLnJlc29sdmVGdWxseSgpXX0pfSl9LHQucHJvdG90eXBlLnNlcmlhbEZvckVhY2g9ZnVuY3Rpb24odCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm5bMix0aGlzLnNlcmlhbE1hcEFzeW5jKHQpLnJlc29sdmVXaGlsZShmdW5jdGlvbih0KXtyZXR1cm4hMD09PXR9KV19KX0pfSx0LnByb3RvdHlwZS5yb3dNYWpvckJhdGNoPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPSEwKSxuZXcgUm93TWFqb3JCYXRjaEl0ZXJhdG9yKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuY29sdW1uTWFqb3JCYXRjaD1mdW5jdGlvbih0LGUscil7cmV0dXJuIHZvaWQgMD09PWUmJihlPSEwKSx2b2lkIDA9PT1yJiYocj16aXBUb0xpc3QpLHRoaXMucm93TWFqb3JCYXRjaCh0LGUpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZGVlcFppcCh0LHIpfSl9LHQucHJvdG90eXBlLmNvbmNhdGVuYXRlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyBDaGFpbmVkSXRlcmF0b3IoaXRlcmF0b3JGcm9tSXRlbXMoW3RoaXMsdF0pLGUpfSx0LnByb3RvdHlwZS50YWtlPWZ1bmN0aW9uKHQpe3JldHVybiB0PDB8fG51bGw9PXQ/dGhpczpuZXcgVGFrZUl0ZXJhdG9yKHRoaXMsdCl9LHQucHJvdG90eXBlLnNraXA9ZnVuY3Rpb24odCl7cmV0dXJuIHQ8MHx8bnVsbD09dD90aGlzOm5ldyBTa2lwSXRlcmF0b3IodGhpcyx0KX0sdC5wcm90b3R5cGUucHJlZmV0Y2g9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBQcmVmZXRjaEl0ZXJhdG9yKHRoaXMsdCl9LHQucHJvdG90eXBlLnNodWZmbGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IFNodWZmbGVJdGVyYXRvcih0aGlzLHQsZSl9LHQucHJvdG90eXBlLnNlcmlhbD1mdW5jdGlvbigpe3JldHVybiBuZXcgU2VyaWFsSXRlcmF0b3IodGhpcyl9LHR9KCksQXJyYXlJdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciByPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gci5pdGVtcz1lLHIudHJhdj0wLHJ9cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oKXtyZXR1cm5cIkFycmF5IG9mIFwiK3RoaXMuaXRlbXMubGVuZ3RoK1wiIGl0ZW1zXCJ9LGUucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGU7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7cmV0dXJuIHRoaXMudHJhdj49dGhpcy5pdGVtcy5sZW5ndGg/WzIse3ZhbHVlOm51bGwsZG9uZTohMH1dOih0PXRoaXMuaXRlbXNbdGhpcy50cmF2XSxlPXQgaW5zdGFuY2VvZiBUZW5zb3I/Y2xvbmUodCk6dCx0aGlzLnRyYXYrKyxbMix7dmFsdWU6ZSxkb25lOiExfV0pfSl9KX0sZX0oTGF6eUl0ZXJhdG9yKSxGdW5jdGlvbkNhbGxJdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciByPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gci5uZXh0Rm49ZSxyfXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuXCJGdW5jdGlvbiBjYWxsXCJ9LGUucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHQpe3RyeXtyZXR1cm5bMix0aGlzLm5leHRGbigpXX1jYXRjaCh0KXt0aHJvdyB0Lm1lc3NhZ2U9XCJFcnJvciB0aHJvd24gd2hpbGUgaXRlcmF0aW5nIHRocm91Z2ggYSBkYXRhc2V0OiBcIit0Lm1lc3NhZ2UsdH1yZXR1cm5bMl19KX0pfSxlfShMYXp5SXRlcmF0b3IpLFNlcmlhbEl0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIHI9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiByLnVwc3RyZWFtPWUsci5sYXN0UmVhZD1Qcm9taXNlLnJlc29sdmUoe3ZhbHVlOm51bGwsZG9uZTohMX0pLHJ9cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51cHN0cmVhbS5zdW1tYXJ5KCkrXCIgLT4gU2VyaWFsXCJ9LGUucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubGFzdFJlYWQ9dGhpcy5sYXN0UmVhZC50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHQuc2VyaWFsTmV4dCgpfSksWzIsdGhpcy5sYXN0UmVhZF19KX0pfSxlLnByb3RvdHlwZS5zZXJpYWxOZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtyZXR1cm5bMix0aGlzLnVwc3RyZWFtLm5leHQoKV19KX0pfSxlfShMYXp5SXRlcmF0b3IpLFNraXBJdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscil7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLnVwc3RyZWFtPWUsbi5tYXhDb3VudD1yLG4uY291bnQ9MCxuLmxhc3RSZWFkPVByb21pc2UucmVzb2x2ZSh7dmFsdWU6bnVsbCxkb25lOiExfSksbn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVwc3RyZWFtLnN1bW1hcnkoKStcIiAtPiBTa2lwXCJ9LGUucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubGFzdFJlYWQ9dGhpcy5sYXN0UmVhZC50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHQuc2VyaWFsTmV4dCgpfSksWzIsdGhpcy5sYXN0UmVhZF19KX0pfSxlLnByb3RvdHlwZS5zZXJpYWxOZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybiB0aGlzLmNvdW50Kys8dGhpcy5tYXhDb3VudD9bNCx0aGlzLnVwc3RyZWFtLm5leHQoKV06WzMsMl07Y2FzZSAxOnJldHVybih0PWUuc2VudCgpKS5kb25lP1syLHRdOihkaXNwb3NlKHQudmFsdWUpLFszLDBdKTtjYXNlIDI6cmV0dXJuWzIsdGhpcy51cHN0cmVhbS5uZXh0KCldfX0pfSl9LGV9KExhenlJdGVyYXRvciksVGFrZUl0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyKXt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4udXBzdHJlYW09ZSxuLm1heENvdW50PXIsbi5jb3VudD0wLG59cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51cHN0cmVhbS5zdW1tYXJ5KCkrXCIgLT4gVGFrZVwifSxlLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb3VudCsrPj10aGlzLm1heENvdW50P1syLHt2YWx1ZTpudWxsLGRvbmU6ITB9XTpbMix0aGlzLnVwc3RyZWFtLm5leHQoKV19KX0pfSxlfShMYXp5SXRlcmF0b3IpLFJvd01ham9yQmF0Y2hJdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscixuKXt2b2lkIDA9PT1uJiYobj0hMCk7dmFyIGk9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBpLnVwc3RyZWFtPWUsaS5iYXRjaFNpemU9cixpLmVuYWJsZVNtYWxsTGFzdEJhdGNoPW4saS5sYXN0UmVhZD1Qcm9taXNlLnJlc29sdmUoe3ZhbHVlOm51bGwsZG9uZTohMX0pLGl9cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51cHN0cmVhbS5zdW1tYXJ5KCkrXCIgLT4gUm93TWFqb3JCYXRjaFwifSxlLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmxhc3RSZWFkPXRoaXMubGFzdFJlYWQudGhlbihmdW5jdGlvbigpe3JldHVybiB0LnNlcmlhbE5leHQoKX0pLFsyLHRoaXMubGFzdFJlYWRdfSl9KX0sZS5wcm90b3R5cGUuc2VyaWFsTmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnQ9W10sci5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gdC5sZW5ndGg8dGhpcy5iYXRjaFNpemU/WzQsdGhpcy51cHN0cmVhbS5uZXh0KCldOlszLDNdO2Nhc2UgMjpyZXR1cm4oZT1yLnNlbnQoKSkuZG9uZT90aGlzLmVuYWJsZVNtYWxsTGFzdEJhdGNoJiZ0Lmxlbmd0aD4wP1syLHt2YWx1ZTp0LGRvbmU6ITF9XTpbMix7dmFsdWU6bnVsbCxkb25lOiEwfV06KHQucHVzaChlLnZhbHVlKSxbMywxXSk7Y2FzZSAzOnJldHVyblsyLHt2YWx1ZTp0LGRvbmU6ITF9XX19KX0pfSxlfShMYXp5SXRlcmF0b3IpLEZpbHRlckl0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyKXt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4udXBzdHJlYW09ZSxuLnByZWRpY2F0ZT1yLG4ubGFzdFJlYWQ9UHJvbWlzZS5yZXNvbHZlKHt2YWx1ZTpudWxsLGRvbmU6ITF9KSxufXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudXBzdHJlYW0uc3VtbWFyeSgpK1wiIC0+IEZpbHRlclwifSxlLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmxhc3RSZWFkPXRoaXMubGFzdFJlYWQudGhlbihmdW5jdGlvbigpe3JldHVybiB0LnNlcmlhbE5leHQoKX0pLFsyLHRoaXMubGFzdFJlYWRdfSl9KX0sZS5wcm90b3R5cGUuc2VyaWFsTmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLnVwc3RyZWFtLm5leHQoKV07Y2FzZSAxOnJldHVybih0PWUuc2VudCgpKS5kb25lfHx0aGlzLnByZWRpY2F0ZSh0LnZhbHVlKT9bMix0XTooZGlzcG9zZSh0LnZhbHVlKSxbMywwXSk7Y2FzZSAyOnJldHVyblsyXX19KX0pfSxlfShMYXp5SXRlcmF0b3IpLE1hcEl0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyKXt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4udXBzdHJlYW09ZSxuLnRyYW5zZm9ybT1yLG59cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51cHN0cmVhbS5zdW1tYXJ5KCkrXCIgLT4gTWFwXCJ9LGUucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGUscixuLGksbyxhO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHUpe3N3aXRjaCh1LmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy51cHN0cmVhbS5uZXh0KCldO2Nhc2UgMTppZigodD11LnNlbnQoKSkuZG9uZSlyZXR1cm5bMix7dmFsdWU6bnVsbCxkb25lOiEwfV07Zm9yKGU9dGVuc29yX3V0aWwuZ2V0VGVuc29yc0luQ29udGFpbmVyKHQudmFsdWUpLHI9dGhpcy50cmFuc2Zvcm0odC52YWx1ZSksbj10ZW5zb3JfdXRpbC5nZXRUZW5zb3JzSW5Db250YWluZXIociksaT0wLG89ZTtpPG8ubGVuZ3RoO2krKylhPW9baV0sdGVuc29yX3V0aWwuaXNUZW5zb3JJbkxpc3QoYSxuKXx8YS5kaXNwb3NlKCk7cmV0dXJuWzIse3ZhbHVlOnIsZG9uZTohMX1dfX0pfSl9LGV9KExhenlJdGVyYXRvciksRXJyb3JIYW5kbGluZ0xhenlJdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscil7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLnVwc3RyZWFtPWUsbi5oYW5kbGVyPXIsbi5jb3VudD0wLG4ubGFzdFJlYWQ9UHJvbWlzZS5yZXNvbHZlKHt2YWx1ZTpudWxsLGRvbmU6ITF9KSxufXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudXBzdHJlYW0uc3VtbWFyeSgpK1wiIC0+IGhhbmRsZUVycm9yc1wifSxlLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmxhc3RSZWFkPXRoaXMubGFzdFJlYWQudGhlbihmdW5jdGlvbigpe3JldHVybiB0LnNlcmlhbE5leHQoKX0pLFsyLHRoaXMubGFzdFJlYWRdfSl9KX0sZS5wcm90b3R5cGUuc2VyaWFsTmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDplLmxhYmVsPTE7Y2FzZSAxOnJldHVybiBlLnRyeXMucHVzaChbMSwzLCw0XSksWzQsdGhpcy51cHN0cmVhbS5uZXh0KCldO2Nhc2UgMjpyZXR1cm5bMixlLnNlbnQoKV07Y2FzZSAzOnJldHVybiB0PWUuc2VudCgpLHRoaXMuaGFuZGxlcih0KT9bMyw0XTpbMix7dmFsdWU6bnVsbCxkb25lOiEwfV07Y2FzZSA0OnJldHVyblszLDBdO2Nhc2UgNTpyZXR1cm5bMl19fSl9KX0sZX0oTGF6eUl0ZXJhdG9yKSxBc3luY01hcEl0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyKXt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4udXBzdHJlYW09ZSxuLnRyYW5zZm9ybT1yLG59cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51cHN0cmVhbS5zdW1tYXJ5KCkrXCIgLT4gQXN5bmNNYXBcIn0sZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZSxyLG4saSxvLGE7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odSl7c3dpdGNoKHUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLnVwc3RyZWFtLm5leHQoKV07Y2FzZSAxOnJldHVybih0PXUuc2VudCgpKS5kb25lP1syLHt2YWx1ZTpudWxsLGRvbmU6ITB9XTooZT10ZW5zb3JfdXRpbC5nZXRUZW5zb3JzSW5Db250YWluZXIodC52YWx1ZSksWzQsdGhpcy50cmFuc2Zvcm0odC52YWx1ZSldKTtjYXNlIDI6Zm9yKHI9dS5zZW50KCksbj10ZW5zb3JfdXRpbC5nZXRUZW5zb3JzSW5Db250YWluZXIociksaT0wLG89ZTtpPG8ubGVuZ3RoO2krKylhPW9baV0sdGVuc29yX3V0aWwuaXNUZW5zb3JJbkxpc3QoYSxuKXx8YS5kaXNwb3NlKCk7cmV0dXJuWzIse3ZhbHVlOnIsZG9uZTohMX1dfX0pfSl9LGV9KExhenlJdGVyYXRvciksT25lVG9NYW55SXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciBlPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gZS5vdXRwdXRRdWV1ZT1uZXcgR3Jvd2luZ1JpbmdCdWZmZXIsZS5sYXN0UmVhZD1Qcm9taXNlLnJlc29sdmUoe3ZhbHVlOm51bGwsZG9uZTohMX0pLGV9cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubGFzdFJlYWQ9dGhpcy5sYXN0UmVhZC50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHQuc2VyaWFsTmV4dCgpfSksWzIsdGhpcy5sYXN0UmVhZF19KX0pfSxlLnByb3RvdHlwZS5zZXJpYWxOZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOnJldHVybiAwIT09dGhpcy5vdXRwdXRRdWV1ZS5sZW5ndGgoKT9bMywyXTpbNCx0aGlzLnB1bXAoKV07Y2FzZSAxOnJldHVybiB0LnNlbnQoKT9bMywwXTpbMix7dmFsdWU6bnVsbCxkb25lOiEwfV07Y2FzZSAyOnJldHVyblsyLHt2YWx1ZTp0aGlzLm91dHB1dFF1ZXVlLnNoaWZ0KCksZG9uZTohMX1dfX0pfSl9LGV9KExhenlJdGVyYXRvciksRmxhdG1hcEl0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyKXt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4udXBzdHJlYW09ZSxuLnRyYW5zZm9ybT1yLG59cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51cHN0cmVhbS5zdW1tYXJ5KCkrXCIgLT4gRmxhdG1hcFwifSxlLnByb3RvdHlwZS5wdW1wPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlLHIsbixpLG8sYTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih1KXtzd2l0Y2godS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMudXBzdHJlYW0ubmV4dCgpXTtjYXNlIDE6aWYoKHQ9dS5zZW50KCkpLmRvbmUpcmV0dXJuWzIsITFdO2ZvcihlPXRlbnNvcl91dGlsLmdldFRlbnNvcnNJbkNvbnRhaW5lcih0LnZhbHVlKSxyPXRoaXMudHJhbnNmb3JtKHQudmFsdWUpLG49dGVuc29yX3V0aWwuZ2V0VGVuc29yc0luQ29udGFpbmVyKHIpLHRoaXMub3V0cHV0UXVldWUucHVzaEFsbChyKSxpPTAsbz1lO2k8by5sZW5ndGg7aSsrKWE9b1tpXSx0ZW5zb3JfdXRpbC5pc1RlbnNvckluTGlzdChhLG4pfHxhLmRpc3Bvc2UoKTtyZXR1cm5bMiwhMF19fSl9KX0sZX0oT25lVG9NYW55SXRlcmF0b3IpLENoYWluZWRJdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscil7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLmJhc2VFcnJvckhhbmRsZXI9cixuLmxhc3RSZWFkPW51bGwsbi5pdGVyYXRvcj1udWxsLG4ubW9yZUl0ZXJhdG9ycz1lLG59cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oKXtyZXR1cm5cIlRPRE86IGZpbGwgaW4gdXBzdHJlYW0gb2YgY2hhaW5lZCBzdW1tYXJpZXMgLT4gQ2hhaW5lZFwifSxlLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5sYXN0UmVhZD10aGlzLnJlYWRGcm9tQ2hhaW4odGhpcy5sYXN0UmVhZCksWzIsdGhpcy5sYXN0UmVhZF19KX0pfSxlLnByb3RvdHlwZS5yZWFkRnJvbUNoYWluPWZ1bmN0aW9uKHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUscjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRdO2Nhc2UgMTpyZXR1cm4gbi5zZW50KCksbnVsbCE9dGhpcy5pdGVyYXRvcj9bMywzXTpbNCx0aGlzLm1vcmVJdGVyYXRvcnMubmV4dCgpXTtjYXNlIDI6aWYoKGU9bi5zZW50KCkpLmRvbmUpcmV0dXJuWzIse3ZhbHVlOm51bGwsZG9uZTohMH1dO3RoaXMuaXRlcmF0b3I9ZS52YWx1ZSxudWxsIT10aGlzLmJhc2VFcnJvckhhbmRsZXImJih0aGlzLml0ZXJhdG9yPXRoaXMuaXRlcmF0b3IuaGFuZGxlRXJyb3JzKHRoaXMuYmFzZUVycm9ySGFuZGxlcikpLG4ubGFiZWw9MztjYXNlIDM6cmV0dXJuWzQsdGhpcy5pdGVyYXRvci5uZXh0KCldO2Nhc2UgNDpyZXR1cm4ocj1uLnNlbnQoKSkuZG9uZT8odGhpcy5pdGVyYXRvcj1udWxsLFsyLHRoaXMucmVhZEZyb21DaGFpbih0KV0pOlsyLHJdfX0pfSl9LGV9KExhenlJdGVyYXRvcik7IWZ1bmN0aW9uKHQpe3RbdC5GQUlMPTBdPVwiRkFJTFwiLHRbdC5TSE9SVEVTVD0xXT1cIlNIT1JURVNUXCIsdFt0LkxPTkdFU1Q9Ml09XCJMT05HRVNUXCJ9KFppcE1pc21hdGNoTW9kZXx8KFppcE1pc21hdGNoTW9kZT17fSkpO3ZhciBaaXBJdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscil7dm9pZCAwPT09ciYmKHI9WmlwTWlzbWF0Y2hNb2RlLkZBSUwpO3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5pdGVyYXRvcnM9ZSxuLm1pc21hdGNoTW9kZT1yLG4uY291bnQ9MCxuLmN1cnJlbnRQcm9taXNlPW51bGwsbn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbigpe3JldHVyblwie1RPRE86IGZpbGwgaW4gdXBzdHJlYW0gb2YgemlwIHN1bW1hcmllc30gLT4gWmlwXCJ9LGUucHJvdG90eXBlLm5leHRTdGF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBMYXp5SXRlcmF0b3I/e3ZhbHVlOnQubmV4dCgpLnRoZW4oZnVuY3Rpb24odCl7cmV0dXJuIHIrKyx0LmRvbmUmJm4rKyx0LnZhbHVlfSkscmVjdXJzZTohMX06e3ZhbHVlOm51bGwscmVjdXJzZTohMH19dmFyIHIsbixpO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG8pe3N3aXRjaChvLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdF07Y2FzZSAxOnJldHVybiBvLnNlbnQoKSxyPTAsbj0wLFs0LGRlZXBNYXBBbmRBd2FpdEFsbCh0aGlzLml0ZXJhdG9ycyxlKV07Y2FzZSAyOmlmKGk9by5zZW50KCkscj09PW4pcmV0dXJuWzIse3ZhbHVlOm51bGwsZG9uZTohMH1dO2lmKG4+MClzd2l0Y2godGhpcy5taXNtYXRjaE1vZGUpe2Nhc2UgWmlwTWlzbWF0Y2hNb2RlLkZBSUw6dGhyb3cgbmV3IEVycm9yKFwiWmlwcGVkIHN0cmVhbXMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLiBNaXNtYXRjaGVkIGF0IGVsZW1lbnQgXCIrdGhpcy5jb3VudCtcIi5cIik7Y2FzZSBaaXBNaXNtYXRjaE1vZGUuU0hPUlRFU1Q6cmV0dXJuWzIse3ZhbHVlOm51bGwsZG9uZTohMH1dO2Nhc2UgWmlwTWlzbWF0Y2hNb2RlLkxPTkdFU1Q6fXJldHVybiB0aGlzLmNvdW50KyssWzIse3ZhbHVlOmksZG9uZTohMX1dfX0pfSl9LGUucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6cmV0dXJuIHRoaXMuY3VycmVudFByb21pc2U9dGhpcy5uZXh0U3RhdGUodGhpcy5jdXJyZW50UHJvbWlzZSksWzQsdGhpcy5jdXJyZW50UHJvbWlzZV07Y2FzZSAxOnJldHVyblsyLHQuc2VudCgpXX19KX0pfSxlfShMYXp5SXRlcmF0b3IpLFByZWZldGNoSXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLHIpe3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi51cHN0cmVhbT1lLG4uYnVmZmVyU2l6ZT1yLG4uYnVmZmVyPW5ldyBSaW5nQnVmZmVyKHIpLG59cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51cHN0cmVhbS5zdW1tYXJ5KCkrXCIgLT4gUHJlZmV0Y2hcIn0sZS5wcm90b3R5cGUucmVmaWxsPWZ1bmN0aW9uKCl7Zm9yKDshdGhpcy5idWZmZXIuaXNGdWxsKCk7KXt2YXIgdD10aGlzLnVwc3RyZWFtLm5leHQoKTt0aGlzLmJ1ZmZlci5wdXNoKHQpfX0sZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlZmlsbCgpLHRoaXMuYnVmZmVyLnNoaWZ0KCl9LGV9KExhenlJdGVyYXRvciksU2h1ZmZsZUl0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyLG4pe3ZhciBpPXQuY2FsbCh0aGlzLGUscil8fHRoaXM7cmV0dXJuIGkudXBzdHJlYW09ZSxpLndpbmRvd1NpemU9cixpLnVwc3RyZWFtRXhoYXVzdGVkPSExLGkucmFuZG9tPXNlZWRyYW5kb21fMShufHx1dGlsLm5vdygpLnRvU3RyaW5nKCkpLGkubGFzdFJlYWQ9UHJvbWlzZS5yZXNvbHZlKHt2YWx1ZTpudWxsLGRvbmU6ITF9KSxpfXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmxhc3RSZWFkPXRoaXMubGFzdFJlYWQudGhlbihmdW5jdGlvbigpe3JldHVybiB0LnNlcmlhbE5leHQoKX0pLFsyLHRoaXMubGFzdFJlYWRdfSl9KX0sZS5wcm90b3R5cGUucmFuZG9tSW50PWZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLmZsb29yKHRoaXMucmFuZG9tKCkqdCl9LGUucHJvdG90eXBlLmNob29zZUluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmFuZG9tSW50KHRoaXMuYnVmZmVyLmxlbmd0aCgpKX0sZS5wcm90b3R5cGUuc2VyaWFsTmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsZTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnRoaXMudXBzdHJlYW1FeGhhdXN0ZWR8fHRoaXMucmVmaWxsKCksci5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gdGhpcy5idWZmZXIuaXNFbXB0eSgpP1szLDNdOih0PXRoaXMuY2hvb3NlSW5kZXgoKSxbNCx0aGlzLmJ1ZmZlci5zaHVmZmxlRXhjaXNlKHQpXSk7Y2FzZSAyOnJldHVybihlPXIuc2VudCgpKS5kb25lPyh0aGlzLnVwc3RyZWFtRXhoYXVzdGVkPSEwLFszLDFdKToodGhpcy5yZWZpbGwoKSxbMixlXSk7Y2FzZSAzOnJldHVyblsyLHt2YWx1ZTpudWxsLGRvbmU6ITB9XX19KX0pfSxlfShQcmVmZXRjaEl0ZXJhdG9yKSxEYXRhc2V0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMuc2l6ZT1udWxsfXJldHVybiB0LnByb3RvdHlwZS5iYXRjaD1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXM7dm9pZCAwPT09ZSYmKGU9ITApO3ZhciBuPXRoaXM7cmV0dXJuIHV0aWwuYXNzZXJ0KHQ+MCxmdW5jdGlvbigpe3JldHVyblwiYmF0Y2hTaXplIG5lZWRzIHRvIGJlIHBvc2l0aXZlLCBidXQgaXQgaXNcXG4gICAgICBcIit0fSksZGF0YXNldEZyb21JdGVyYXRvckZuKGZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcihyLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybls0LG4uaXRlcmF0b3IoKV07Y2FzZSAxOnJldHVyblsyLHIuc2VudCgpLmNvbHVtbk1ham9yQmF0Y2godCxlLGRlZXBCYXRjaENvbmNhdCldfX0pfSl9LHRoaXMuc2l6ZT09PTEvMHx8bnVsbD09dGhpcy5zaXplP3RoaXMuc2l6ZTplP01hdGguY2VpbCh0aGlzLnNpemUvdCk6TWF0aC5mbG9vcih0aGlzLnNpemUvdCkpfSx0LnByb3RvdHlwZS5jb25jYXRlbmF0ZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLHI9dGhpcztyZXR1cm4gZGF0YXNldEZyb21JdGVyYXRvckZuKGZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcihlLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZSxuO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGkpe3N3aXRjaChpLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsci5pdGVyYXRvcigpXTtjYXNlIDE6cmV0dXJuIG49KGU9aS5zZW50KCkpLmNvbmNhdGVuYXRlLFs0LHQuaXRlcmF0b3IoKV07Y2FzZSAyOnJldHVyblsyLG4uYXBwbHkoZSxbaS5zZW50KCldKV19fSl9KX0sdGhpcy5zaXplPT09MS8wfHx0LnNpemU9PT0xLzA/MS8wOm51bGwhPXRoaXMuc2l6ZSYmbnVsbCE9dC5zaXplP3RoaXMuc2l6ZSt0LnNpemU6bnVsbCl9LHQucHJvdG90eXBlLmZpbHRlcj1mdW5jdGlvbih0KXt2YXIgZT10aGlzLHI9dGhpcztyZXR1cm4gZGF0YXNldEZyb21JdGVyYXRvckZuKGZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcihlLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHIuaXRlcmF0b3IoKV07Y2FzZSAxOnJldHVyblsyLGUuc2VudCgpLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiB0KGUpfSl9KV19fSl9KX0sdGhpcy5zaXplPT09MS8wPzEvMDpudWxsKX0sdC5wcm90b3R5cGUuZm9yRWFjaEFzeW5jPWZ1bmN0aW9uKHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLml0ZXJhdG9yKCldO2Nhc2UgMTpyZXR1cm5bMixlLnNlbnQoKS5mb3JFYWNoQXN5bmModCldfX0pfSl9LHQucHJvdG90eXBlLmZvckVhY2g9ZnVuY3Rpb24odCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gZGVwcmVjYXRpb25XYXJuKFwiZGF0YXNldC5mb3JFYWNoKCkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkLiBQbGVhc2UgdXNlIGRhdGFzZXQuZm9yRWFjaEFzeW5jKCkgaW5zdGVhZFwiKSxbMix0aGlzLmZvckVhY2hBc3luYyh0KV19KX0pfSx0LnByb3RvdHlwZS5tYXA9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPXRoaXM7cmV0dXJuIGRhdGFzZXRGcm9tSXRlcmF0b3JGbihmdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIoZSx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxyLml0ZXJhdG9yKCldO2Nhc2UgMTpyZXR1cm5bMixlLnNlbnQoKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gdChlKX0pfSldfX0pfSl9LHRoaXMuc2l6ZSl9LHQucHJvdG90eXBlLm1hcEFzeW5jPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMscj10aGlzO3JldHVybiBkYXRhc2V0RnJvbUl0ZXJhdG9yRm4oZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKGUsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsci5pdGVyYXRvcigpXTtjYXNlIDE6cmV0dXJuWzIsZS5zZW50KCkubWFwQXN5bmModCldfX0pfSl9LHRoaXMuc2l6ZSl9LHQucHJvdG90eXBlLnByZWZldGNoPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7aWYobnVsbD09dCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImBEYXRhc2V0LnByZWZldGNoKClgIHJlcXVpcmVzIGJ1ZmZlclNpemUgdG8gYmUgc3BlY2lmaWVkLlwiKTt2YXIgcj10aGlzO3JldHVybiBkYXRhc2V0RnJvbUl0ZXJhdG9yRm4oZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKGUsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsci5pdGVyYXRvcigpXTtjYXNlIDE6cmV0dXJuWzIsZS5zZW50KCkucHJlZmV0Y2godCldfX0pfSl9LHRoaXMuc2l6ZSl9LHQucHJvdG90eXBlLnJlcGVhdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLHI9dGhpcztyZXR1cm4gZGF0YXNldEZyb21JdGVyYXRvckZuKGZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcihlLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3JldHVyblsyLGl0ZXJhdG9yRnJvbUNvbmNhdGVuYXRlZChpdGVyYXRvckZyb21GdW5jdGlvbihmdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIoZSx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm4gdD17fSxbNCxyLml0ZXJhdG9yKCldO2Nhc2UgMTpyZXR1cm5bMiwodC52YWx1ZT1lLnNlbnQoKSx0LmRvbmU9ITEsdCldfX0pfSl9KS50YWtlKHQpKV19KX0pfSxudWxsIT10aGlzLnNpemUmJnQ+MD90aGlzLnNpemUqdDowPT09dD8wOm51bGwhPXRoaXMuc2l6ZSYmKHZvaWQgMD09PXR8fHQ8MCk/MS8wOm51bGwpfSx0LnByb3RvdHlwZS5za2lwPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMscj10aGlzO3JldHVybiBkYXRhc2V0RnJvbUl0ZXJhdG9yRm4oZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKGUsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsci5pdGVyYXRvcigpXTtjYXNlIDE6cmV0dXJuWzIsZS5zZW50KCkuc2tpcCh0KV19fSl9KX0sbnVsbCE9dGhpcy5zaXplJiZ0Pj0wJiZ0aGlzLnNpemU+PXQ/dGhpcy5zaXplLXQ6bnVsbCE9dGhpcy5zaXplJiYodGhpcy5zaXplPHR8fHZvaWQgMD09PXR8fHQ8MCk/MDpudWxsKX0sdC5wcm90b3R5cGUuc2h1ZmZsZT1mdW5jdGlvbih0LGUscil7dmFyIG49dGhpcztpZih2b2lkIDA9PT1yJiYocj0hMCksbnVsbD09dHx8dDwwKXRocm93IG51bGw9PXRoaXMuc2l6ZT9uZXcgUmFuZ2VFcnJvcihcImBEYXRhc2V0LnNodWZmbGUoKWAgcmVxdWlyZXMgYnVmZmVyU2l6ZSB0byBiZSBzcGVjaWZpZWQuXCIpOm5ldyBSYW5nZUVycm9yKFwiYERhdGFzZXQuc2h1ZmZsZSgpYCByZXF1aXJlcyBidWZmZXJTaXplIHRvIGJlIHNwZWNpZmllZC4gIElmIHlvdXIgZGF0YSBmaXRzIGluIG1haW4gbWVtb3J5IChmb3IgcmVndWxhciBKUyBvYmplY3RzKSwgYW5kL29yIEdQVSBtZW1vcnkgKGZvciBgdGYuVGVuc29yYHMpLCBjb25zaWRlciBzZXR0aW5nIGJ1ZmZlclNpemUgdG8gdGhlIGRhdGFzZXQgc2l6ZSAoXCIrdGhpcy5zaXplK1wiIGVsZW1lbnRzKVwiKTt2YXIgaT10aGlzLG89c2VlZHJhbmRvbV8xKGV8fHV0aWwubm93KCkudG9TdHJpbmcoKSk7cmV0dXJuIGRhdGFzZXRGcm9tSXRlcmF0b3JGbihmdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIobix2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm4gZT1vLmludDMyKCksciYmKGUrPW8uaW50MzIoKSksWzQsaS5pdGVyYXRvcigpXTtjYXNlIDE6cmV0dXJuWzIsbi5zZW50KCkuc2h1ZmZsZSh0LGUudG9TdHJpbmcoKSldfX0pfSl9LHRoaXMuc2l6ZSl9LHQucHJvdG90eXBlLnRha2U9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPXRoaXM7cmV0dXJuIGRhdGFzZXRGcm9tSXRlcmF0b3JGbihmdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIoZSx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxyLml0ZXJhdG9yKCldO2Nhc2UgMTpyZXR1cm5bMixlLnNlbnQoKS50YWtlKHQpXX19KX0pfSxudWxsIT10aGlzLnNpemUmJnRoaXMuc2l6ZT50P3Q6bnVsbCE9dGhpcy5zaXplJiZ0aGlzLnNpemU8PXQ/dGhpcy5zaXplOm51bGwpfSx0LnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOmlmKHRoaXMuc2l6ZT09PTEvMCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGNvbnZlcnQgaW5maW5pdGUgZGF0YSBzdHJlYW0gdG8gYXJyYXkuXCIpO3JldHVybls0LHRoaXMuaXRlcmF0b3IoKV07Y2FzZSAxOnJldHVyblsyLHQuc2VudCgpLnRvQXJyYXkoKV19fSl9KX0sdC5wcm90b3R5cGUudG9BcnJheUZvclRlc3Q9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6aWYodGhpcy5zaXplPT09MS8wKXRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgY29udmVydCBpbmZpbml0ZSBkYXRhIHN0cmVhbSB0byBhcnJheS5cIik7cmV0dXJuWzQsdGhpcy5pdGVyYXRvcigpXTtjYXNlIDE6cmV0dXJuWzIsdC5zZW50KCkudG9BcnJheUZvclRlc3QoKV19fSl9KX0sdC5NQVhfQlVGRkVSX1NJWkU9MWU0LHR9KCk7ZnVuY3Rpb24gZGF0YXNldEZyb21JdGVyYXRvckZuKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPW51bGwpLG5ldyhmdW5jdGlvbihyKXtmdW5jdGlvbiBuKCl7dmFyIHQ9bnVsbCE9PXImJnIuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzO3JldHVybiB0LnNpemU9ZSx0fXJldHVybiBfX2V4dGVuZHMobixyKSxuLnByb3RvdHlwZS5pdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuWzIsdCgpXX0pfSl9LG59KERhdGFzZXQpKX1mdW5jdGlvbiBhcnJheSh0KXt2YXIgZT10aGlzO3JldHVybiBkYXRhc2V0RnJvbUl0ZXJhdG9yRm4oZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKGUsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVyblsyLGl0ZXJhdG9yRnJvbUl0ZW1zKHQpXX0pfSl9LHQubGVuZ3RoKX1mdW5jdGlvbiB6aXAodCl7dmFyIGUscj10aGlzO2lmKCFpc0l0ZXJhYmxlKHQpKXRocm93IG5ldyBFcnJvcihcIlRoZSBhcmd1bWVudCB0byB6aXAoKSBtdXN0IGJlIGFuIG9iamVjdCBvciBhcnJheS5cIik7aWYoQXJyYXkuaXNBcnJheSh0KSlmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyllPW51bGw9PWU/dFtuXS5zaXplOk1hdGgubWluKGUsdFtuXS5zaXplKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBPYmplY3QpZm9yKHZhciBpIGluIHQpZT1udWxsPT1lP3RbaV0uc2l6ZTpNYXRoLm1pbihlLHRbaV0uc2l6ZSk7cmV0dXJuIGRhdGFzZXRGcm9tSXRlcmF0b3JGbihmdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIocix2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7c3dpdGNoKGUubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxkZWVwTWFwQW5kQXdhaXRBbGwodCxmdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgRGF0YXNldClyZXR1cm57dmFsdWU6dC5pdGVyYXRvcigpLHJlY3Vyc2U6ITF9O2lmKGlzSXRlcmFibGUodCkpcmV0dXJue3ZhbHVlOm51bGwscmVjdXJzZTohMH07dGhyb3cgbmV3IEVycm9yKFwiTGVhdmVzIG9mIHRoZSBzdHJ1Y3R1cmUgcGFzc2VkIHRvIHppcCgpIG11c3QgYmUgRGF0YXNldHMsIG5vdCBwcmltaXRpdmVzLlwiKX0pXTtjYXNlIDE6cmV0dXJuWzIsaXRlcmF0b3JGcm9tWmlwcGVkKGUuc2VudCgpLFppcE1pc21hdGNoTW9kZS5TSE9SVEVTVCldfX0pfSl9LGUpfWZ1bmN0aW9uIGRlZXBCYXRjaENvbmNhdCh0KXtyZXR1cm4gbnVsbD09PXQ/bnVsbDpjYW5UZW5zb3JpZnkodFswXSk/e3ZhbHVlOmJhdGNoQ29uY2F0KHQpLHJlY3Vyc2U6ITF9Ont2YWx1ZTpudWxsLHJlY3Vyc2U6ITB9fWZ1bmN0aW9uIGJhdGNoQ29uY2F0KHQpe2lmKDA9PT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBtYWtlIGEgYmF0Y2ggb2YgemVybyBlbGVtZW50cy5cIik7cmV0dXJuIHRbMF1pbnN0YW5jZW9mIFRlbnNvcj9zdGFjayh0KTp0ZW5zb3IodCl9dmFyIFRleHRMaW5lRGF0YXNldD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciByPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gci5pbnB1dD1lLHJ9cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLml0ZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5pbnB1dC5pdGVyYXRvcigpXTtjYXNlIDE6cmV0dXJuIHQ9ci5zZW50KCksZT10LmRlY29kZVVURjgoKSxbMixlLnNwbGl0KFwiXFxuXCIpXX19KX0pfSxlfShEYXRhc2V0KSxDT0RFX1FVT1RFPSdcIicsU1RBVEVfT1VUPVN5bWJvbChcIm91dFwiKSxTVEFURV9GSUVMRD1TeW1ib2woXCJmaWVsZFwiKSxTVEFURV9RVU9URT1TeW1ib2woXCJxdW90ZVwiKSxTVEFURV9RVU9URV9BRlRFUl9RVU9URT1TeW1ib2woXCJxdW90ZWFmdGVycXVvdGVcIiksU1RBVEVfV0lUSElOX1FVT1RFX0lOX1FVT1RFPVN5bWJvbChcInF1b3RlaW5xdW90ZVwiKSxDU1ZEYXRhc2V0PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyKXt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4uaW5wdXQ9ZSxuLmhhc0hlYWRlcj0hMCxuLmZ1bGxDb2x1bW5OYW1lcz1udWxsLG4uY29sdW1uTmFtZXNWYWxpZGF0ZWQ9ITEsbi5jb2x1bW5Db25maWdzPW51bGwsbi5jb25maWd1cmVkQ29sdW1uc09ubHk9ITEsbi5kZWxpbWl0ZXI9XCIsXCIsbi5kZWxpbVdoaXRlc3BhY2U9ITEsbi5iYXNlPW5ldyBUZXh0TGluZURhdGFzZXQoZSkscnx8KHI9e30pLG4uaGFzSGVhZGVyPSExIT09ci5oYXNIZWFkZXIsbi5mdWxsQ29sdW1uTmFtZXM9ci5jb2x1bW5OYW1lcyxuLmNvbHVtbkNvbmZpZ3M9ci5jb2x1bW5Db25maWdzLG4uY29uZmlndXJlZENvbHVtbnNPbmx5PXIuY29uZmlndXJlZENvbHVtbnNPbmx5LHIuZGVsaW1XaGl0ZXNwYWNlPyh1dGlsLmFzc2VydChudWxsPT1yLmRlbGltaXRlcixmdW5jdGlvbigpe3JldHVyblwiRGVsaW1pdGVyIHNob3VsZCBub3QgYmUgcHJvdmlkZWQgd2hlbiBkZWxpbVdoaXRlc3BhY2UgaXMgdHJ1ZS5cIn0pLG4uZGVsaW1XaGl0ZXNwYWNlPSEwLG4uZGVsaW1pdGVyPVwiIFwiKTpuLmRlbGltaXRlcj1yLmRlbGltaXRlcj9yLmRlbGltaXRlcjpcIixcIixufXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5jb2x1bW5OYW1lcz1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm4gdGhpcy5jb2x1bW5OYW1lc1ZhbGlkYXRlZD9bMywyXTpbNCx0aGlzLnNldENvbHVtbk5hbWVzKCldO2Nhc2UgMTp0LnNlbnQoKSx0LmxhYmVsPTI7Y2FzZSAyOnJldHVyblsyLHRoaXMuY29uZmlndXJlZENvbHVtbnNPbmx5P09iamVjdC5rZXlzKHRoaXMuY29sdW1uQ29uZmlncyk6dGhpcy5mdWxsQ29sdW1uTmFtZXNdfX0pfSl9LGUucHJvdG90eXBlLnNldENvbHVtbk5hbWVzPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlLHIsbixpLG8sYT10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHUpe3N3aXRjaCh1LmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5tYXliZVJlYWRIZWFkZXJMaW5lKCldO2Nhc2UgMTppZih0PXUuc2VudCgpLCF0aGlzLmZ1bGxDb2x1bW5OYW1lcyYmIXQpdGhyb3cgbmV3IEVycm9yKFwiQ29sdW1uIG5hbWVzIG11c3QgYmUgcHJvdmlkZWQgaWYgdGhlcmUgaXMgbm8gaGVhZGVyIGxpbmUuXCIpO2lmKHRoaXMuZnVsbENvbHVtbk5hbWVzJiZ0JiZ1dGlsLmFzc2VydCh0Lmxlbmd0aD09PXRoaXMuZnVsbENvbHVtbk5hbWVzLmxlbmd0aCxmdW5jdGlvbigpe3JldHVyblwiVGhlIGxlbmd0aCBvZiBwcm92aWRlZCBjb2x1bW5OYW1lcyAoXCIrYS5mdWxsQ29sdW1uTmFtZXMubGVuZ3RoLnRvU3RyaW5nKCkrXCIpIGRvZXMgbm90IG1hdGNoIHRoZSBsZW5ndGggb2YgdGhlIGhlYWRlciBsaW5lIHJlYWQgZnJvbSBmaWxlIChcIit0Lmxlbmd0aC50b1N0cmluZygpK1wiKS5cIn0pLHRoaXMuZnVsbENvbHVtbk5hbWVzfHwodGhpcy5mdWxsQ29sdW1uTmFtZXM9dCksZT10aGlzLmZ1bGxDb2x1bW5OYW1lcy5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdFtlXT10W2VdKzF8fDEsdH0se30pLHI9T2JqZWN0LmtleXMoZSkuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdPjF9KSx1dGlsLmFzc2VydCgwPT09ci5sZW5ndGgsZnVuY3Rpb24oKXtyZXR1cm5cIkR1cGxpY2F0ZSBjb2x1bW4gbmFtZXMgZm91bmQ6IFwiK3IudG9TdHJpbmcoKX0pLHRoaXMuY29sdW1uQ29uZmlncylmb3Iobj0wLGk9T2JqZWN0LmtleXModGhpcy5jb2x1bW5Db25maWdzKTtuPGkubGVuZ3RoO24rKylpZihvPWlbbl0sLTE9PT10aGlzLmZ1bGxDb2x1bW5OYW1lcy5pbmRleE9mKG8pKXRocm93IG5ldyBFcnJvcignVGhlIGtleSBcIicrbysnXCIgcHJvdmlkZWQgaW4gY29sdW1uQ29uZmlncyBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIGNvbHVtbiBuYW1lcyAoJyt0aGlzLmZ1bGxDb2x1bW5OYW1lcy50b1N0cmluZygpK1wiKS5cIik7cmV0dXJuIHRoaXMuY29sdW1uTmFtZXNWYWxpZGF0ZWQ9ITAsWzJdfX0pfSl9LGUucHJvdG90eXBlLm1heWJlUmVhZEhlYWRlckxpbmU9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGU7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm4gdGhpcy5oYXNIZWFkZXI/WzQsdGhpcy5iYXNlLml0ZXJhdG9yKCldOlszLDNdO2Nhc2UgMTpyZXR1cm5bNCxyLnNlbnQoKS5uZXh0KCldO2Nhc2UgMjppZigodD1yLnNlbnQoKSkuZG9uZSl0aHJvdyBuZXcgRXJyb3IoXCJObyBkYXRhIHdhcyBmb3VuZCBmb3IgQ1NWIHBhcnNpbmcuXCIpO3JldHVybiBlPXQudmFsdWUsWzIsdGhpcy5wYXJzZVJvdyhlLCExKV07Y2FzZSAzOnJldHVyblsyLG51bGxdfX0pfSl9LGUucHJvdG90eXBlLml0ZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlPXRoaXM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm4gdGhpcy5jb2x1bW5OYW1lc1ZhbGlkYXRlZD9bMywyXTpbNCx0aGlzLnNldENvbHVtbk5hbWVzKCldO2Nhc2UgMTpyLnNlbnQoKSxyLmxhYmVsPTI7Y2FzZSAyOnJldHVybls0LHRoaXMuYmFzZS5pdGVyYXRvcigpXTtjYXNlIDM6cmV0dXJuIHQ9ci5zZW50KCksdGhpcy5oYXNIZWFkZXImJih0PXQuc2tpcCgxKSksWzIsdC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGUubWFrZURhdGFFbGVtZW50KHQpfSldfX0pfSl9LGUucHJvdG90eXBlLm1ha2VEYXRhRWxlbWVudD1mdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5wYXJzZVJvdyh0KSxyPXt9LG49e30saT0wO2k8dGhpcy5mdWxsQ29sdW1uTmFtZXMubGVuZ3RoO2krKyl7dmFyIG89dGhpcy5mdWxsQ29sdW1uTmFtZXNbaV0sYT10aGlzLmNvbHVtbkNvbmZpZ3M/dGhpcy5jb2x1bW5Db25maWdzW29dOm51bGw7aWYoIXRoaXMuY29uZmlndXJlZENvbHVtbnNPbmx5fHxhKXt2YXIgdT1lW2ldLHM9bnVsbDtpZihcIlwiPT09dSlpZihhJiZ2b2lkIDAhPT1hLmRlZmF1bHQpcz1hLmRlZmF1bHQ7ZWxzZXtpZihhJiYoYS5yZXF1aXJlZHx8YS5pc0xhYmVsKSl0aHJvdyBuZXcgRXJyb3IoXCJSZXF1aXJlZCBjb2x1bW4gXCIrbytcIiBpcyBlbXB0eSBpbiB0aGlzIGxpbmU6IFwiK3QpO3M9dm9pZCAwfWVsc2V7dmFyIGM9TnVtYmVyKHUpO2lmKGlzTmFOKGMpKXM9YSYmXCJib29sXCI9PT1hLmR0eXBlP3RoaXMuZ2V0Qm9vbGVhbih1KTp1O2Vsc2UgaWYoYSYmYS5kdHlwZSlzd2l0Y2goYS5kdHlwZSl7Y2FzZVwiZmxvYXQzMlwiOnM9YzticmVhaztjYXNlXCJpbnQzMlwiOnM9TWF0aC5mbG9vcihjKTticmVhaztjYXNlXCJib29sXCI6cz10aGlzLmdldEJvb2xlYW4odSk7YnJlYWs7ZGVmYXVsdDpzPWN9ZWxzZSBzPWN9YSYmYS5pc0xhYmVsP25bb109czpyW29dPXN9fXJldHVybiAwPT09T2JqZWN0LmtleXMobikubGVuZ3RoP3I6e3hzOnIseXM6bn19LGUucHJvdG90eXBlLmdldEJvb2xlYW49ZnVuY3Rpb24odCl7cmV0dXJuXCIxXCI9PT10fHxcInRydWVcIj09PXQudG9Mb3dlckNhc2UoKT8xOjB9LGUucHJvdG90eXBlLnBhcnNlUm93PWZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9ITApO2Zvcih2YXIgcj1bXSxuPTAsaT10Lmxlbmd0aCxvPVNUQVRFX09VVCxhPTA7YTxpO2ErKylzd2l0Y2gobyl7Y2FzZSBTVEFURV9PVVQ6c3dpdGNoKHQuY2hhckF0KGEpKXtjYXNlIENPREVfUVVPVEU6bj1hKzEsbz1TVEFURV9RVU9URTticmVhaztjYXNlIHRoaXMuZGVsaW1pdGVyOmlmKG49YSsxLFwiIFwiPT09dGhpcy5kZWxpbWl0ZXImJnRoaXMuZGVsaW1XaGl0ZXNwYWNlKWJyZWFrO3IucHVzaChcIlwiKSxvPVNUQVRFX09VVDticmVhaztkZWZhdWx0Om89U1RBVEVfRklFTEQsbj1hfWJyZWFrO2Nhc2UgU1RBVEVfRklFTEQ6c3dpdGNoKHQuY2hhckF0KGEpKXtjYXNlIHRoaXMuZGVsaW1pdGVyOnIucHVzaCh0LnN1YnN0cmluZyhuLGEpKSxvPVNUQVRFX09VVCxuPWErMX1icmVhaztjYXNlIFNUQVRFX1FVT1RFOnN3aXRjaCh0LmNoYXJBdChhKSl7Y2FzZSBDT0RFX1FVT1RFOm89U1RBVEVfUVVPVEVfQUZURVJfUVVPVEV9YnJlYWs7Y2FzZSBTVEFURV9RVU9URV9BRlRFUl9RVU9URTpzd2l0Y2godC5jaGFyQXQoYSkpe2Nhc2UgdGhpcy5kZWxpbWl0ZXI6ci5wdXNoKHQuc3Vic3RyaW5nKG4sYS0xKSksbz1TVEFURV9PVVQsbj1hKzE7YnJlYWs7Y2FzZSBDT0RFX1FVT1RFOm89U1RBVEVfUVVPVEU7YnJlYWs7ZGVmYXVsdDpvPVNUQVRFX1dJVEhJTl9RVU9URV9JTl9RVU9URX1icmVhaztjYXNlIFNUQVRFX1dJVEhJTl9RVU9URV9JTl9RVU9URTpzd2l0Y2godC5jaGFyQXQoYSkpe2Nhc2UgQ09ERV9RVU9URTpvPVNUQVRFX1FVT1RFfX1pZihvPT09U1RBVEVfUVVPVEVfQUZURVJfUVVPVEU/ci5wdXNoKHQuc3Vic3RyaW5nKG4saS0xKSk6ci5wdXNoKHQuc3Vic3RyaW5nKG4pKSxlJiZyLmxlbmd0aCE9PXRoaXMuZnVsbENvbHVtbk5hbWVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvdyBpbiBjc3YgZmlsZS4gU2hvdWxkIGhhdmUgXCIrdGhpcy5mdWxsQ29sdW1uTmFtZXMubGVuZ3RoK1wiIGVsZW1lbnRzIGluIGEgcm93LCBidXQgZ290IFwiK3IpO3JldHVybiByfSxlfShEYXRhc2V0KSxlbnZpcm9ubWVudD1jcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbih0LGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmdsb2JhbD10LHRoaXMuZmxhZ3M9e30sdGhpcy5mbGFnUmVnaXN0cnk9e30sdGhpcy51cmxGbGFncz17fSx0aGlzLnBvcHVsYXRlVVJMRmxhZ3MoKX1yZXR1cm4gdC5wcm90b3R5cGUucmVnaXN0ZXJGbGFnPWZ1bmN0aW9uKHQsZSxyKXtpZih0aGlzLmZsYWdSZWdpc3RyeVt0XT17ZXZhbHVhdGlvbkZuOmUsc2V0SG9vazpyfSxudWxsIT10aGlzLnVybEZsYWdzW3RdKXt2YXIgbj10aGlzLnVybEZsYWdzW3RdO2NvbnNvbGUud2FybihcIlNldHRpbmcgZmVhdHVyZSBvdmVycmlkZSBmcm9tIFVSTCBcIit0K1wiOiBcIituK1wiLlwiKSx0aGlzLnNldCh0LG4pfX0sdC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe3JldHVybiB0IGluIHRoaXMuZmxhZ3M/dGhpcy5mbGFnc1t0XToodGhpcy5mbGFnc1t0XT10aGlzLmV2YWx1YXRlRmxhZyh0KSx0aGlzLmZsYWdzW3RdKX0sdC5wcm90b3R5cGUuZ2V0TnVtYmVyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldCh0KX0sdC5wcm90b3R5cGUuZ2V0Qm9vbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZXQodCl9LHQucHJvdG90eXBlLmdldEZsYWdzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmxhZ3N9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImZlYXR1cmVzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZsYWdzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLnNldD1mdW5jdGlvbih0LGUpe2lmKG51bGw9PXRoaXMuZmxhZ1JlZ2lzdHJ5W3RdKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgZmxhZyBcIit0K1wiIGFzIGl0IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkLlwiKTt0aGlzLmZsYWdzW3RdPWUsbnVsbCE9dGhpcy5mbGFnUmVnaXN0cnlbdF0uc2V0SG9vayYmdGhpcy5mbGFnUmVnaXN0cnlbdF0uc2V0SG9vayhlKX0sdC5wcm90b3R5cGUuZXZhbHVhdGVGbGFnPWZ1bmN0aW9uKHQpe2lmKG51bGw9PXRoaXMuZmxhZ1JlZ2lzdHJ5W3RdKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBldmFsdWF0ZSBmbGFnICdcIit0K1wiJzogbm8gZXZhbHVhdGlvbiBmdW5jdGlvbiBmb3VuZC5cIik7cmV0dXJuIHRoaXMuZmxhZ1JlZ2lzdHJ5W3RdLmV2YWx1YXRpb25GbigpfSx0LnByb3RvdHlwZS5zZXRGbGFncz1mdW5jdGlvbih0KXt0aGlzLmZsYWdzPU9iamVjdC5hc3NpZ24oe30sdCl9LHQucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5mbGFncz17fSx0aGlzLnVybEZsYWdzPXt9LHRoaXMucG9wdWxhdGVVUkxGbGFncygpfSx0LnByb3RvdHlwZS5wb3B1bGF0ZVVSTEZsYWdzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZih2b2lkIDAhPT10aGlzLmdsb2JhbCYmdm9pZCAwIT09dGhpcy5nbG9iYWwubG9jYXRpb24mJnZvaWQgMCE9PXRoaXMuZ2xvYmFsLmxvY2F0aW9uLnNlYXJjaCl7dmFyIGU9bih0aGlzLmdsb2JhbC5sb2NhdGlvbi5zZWFyY2gpO2lmKFwidGZqc2ZsYWdzXCJpbiBlKWUudGZqc2ZsYWdzLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciByPWUuc3BsaXQoXCI6XCIpLG49clswXSxpPXJbMV07dC51cmxGbGFnc1tuXT1mdW5jdGlvbih0LGUpe2lmKFwidHJ1ZVwiPT09KGU9ZS50b0xvd2VyQ2FzZSgpKXx8XCJmYWxzZVwiPT09ZSlyZXR1cm5cInRydWVcIj09PWU7aWYoXCJcIisgK2U9PT1lKXJldHVybitlO3Rocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSB2YWx1ZSBmbGFnIHZhbHVlIFwiK2UrXCIgZm9yIGZsYWcgXCIrdCtcIi5cIil9KG4saSl9KX19LHR9KCk7ZnVuY3Rpb24gbih0KXt2YXIgZT17fTtyZXR1cm4gdC5yZXBsYWNlKC9bPyZdKFtePT8mXSspKD86PShbXiZdKikpPy9nLGZ1bmN0aW9uKHQpe2Zvcih2YXIgcj1bXSxuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKylyW24tMV09YXJndW1lbnRzW25dO3JldHVybiBmdW5jdGlvbih0LGUscil7dFtkZWNvZGVVUklDb21wb25lbnQoZSldPWRlY29kZVVSSUNvbXBvbmVudChyfHxcIlwiKX0oZSxyWzBdLHJbMV0pLHIuam9pbihcIj1cIil9KSxlfWUuRW52aXJvbm1lbnQ9cixlLmdldFF1ZXJ5UGFyYW1zPW4sZS5zZXRFbnZpcm9ubWVudEdsb2JhbD1mdW5jdGlvbih0KXtlLkVOVj10fX0pO3Vud3JhcEV4cG9ydHMoZW52aXJvbm1lbnQpO3ZhciBlbnZpcm9ubWVudF8xPWVudmlyb25tZW50LkVudmlyb25tZW50LGVudmlyb25tZW50XzI9ZW52aXJvbm1lbnQuZ2V0UXVlcnlQYXJhbXMsZW52aXJvbm1lbnRfMz1lbnZpcm9ubWVudC5FTlYsZW52aXJvbm1lbnRfND1lbnZpcm9ubWVudC5zZXRFbnZpcm9ubWVudEdsb2JhbCx1dGlsJDE9Y3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24odCxlKXtmdW5jdGlvbiByKHQpe2Zvcih2YXIgZT10Lmxlbmd0aCxyPTAsbj0wO2U+MDspbj1NYXRoLnJhbmRvbSgpKmV8MCxyPXRbLS1lXSx0W2VdPXRbbl0sdFtuXT1yfWZ1bmN0aW9uIG4odCxlKXtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmdcIj09dHlwZW9mIGU/ZTplKCkpfWZ1bmN0aW9uIGkodCxlKXtpZih2b2lkIDA9PT1lJiYoZT1bXSksbnVsbD09ZSYmKGU9W10pLEFycmF5LmlzQXJyYXkodCl8fGModCkpZm9yKHZhciByPTA7cjx0Lmxlbmd0aDsrK3IpaSh0W3JdLGUpO2Vsc2UgZS5wdXNoKHQpO3JldHVybiBlfWZ1bmN0aW9uIG8odCxlKXtpZih0PT09ZSlyZXR1cm4hMDtpZihudWxsPT10fHxudWxsPT1lKXJldHVybiExO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpcmV0dXJuITE7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspaWYodFtyXSE9PWVbcl0pcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gYSh0KXtyZXR1cm4gdCUxPT0wfWZ1bmN0aW9uIHUodCxlKXt2YXIgcj1lLmxlbmd0aDtyZXR1cm4gbigodD1udWxsPT10P2UubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV9KTpbXS5jb25jYXQodCkpLmV2ZXJ5KGZ1bmN0aW9uKHQpe3JldHVybiB0Pj0tciYmdDxyfSksZnVuY3Rpb24oKXtyZXR1cm5cIkFsbCB2YWx1ZXMgaW4gYXhpcyBwYXJhbSBtdXN0IGJlIGluIHJhbmdlIFstXCIrcitcIiwgXCIrcitcIikgYnV0IGdvdCBheGlzIFwiK3R9KSxuKHQuZXZlcnkoZnVuY3Rpb24odCl7cmV0dXJuIGEodCl9KSxmdW5jdGlvbigpe3JldHVyblwiQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW50ZWdlcnMgYnV0IGdvdCBheGlzIFwiK3R9KSx0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdDwwP3IrdDp0fSl9ZnVuY3Rpb24gcyh0LGUpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbj10W3JdO2lmKGlzTmFOKG4pfHwhaXNGaW5pdGUobikpdGhyb3cgRXJyb3IoXCJBIHRlbnNvciBvZiB0eXBlIFwiK2UrXCIgYmVpbmcgdXBsb2FkZWQgY29udGFpbnMgXCIrbitcIi5cIil9fWZ1bmN0aW9uIGModCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXl8fHQgaW5zdGFuY2VvZiBJbnQzMkFycmF5fHx0IGluc3RhbmNlb2YgVWludDhBcnJheX1mdW5jdGlvbiBsKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0fHx0IGluc3RhbmNlb2YgU3RyaW5nfWZ1bmN0aW9uIGYodCl7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiB0fWZ1bmN0aW9uIGgodCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHR9ZnVuY3Rpb24gcCh0LGUpe2lmKG51bGw9PWV8fFwiZmxvYXQzMlwiPT09ZXx8XCJjb21wbGV4NjRcIj09PWUpcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodCk7aWYoXCJpbnQzMlwiPT09ZSlyZXR1cm4gbmV3IEludDMyQXJyYXkodCk7aWYoXCJib29sXCI9PT1lKXJldHVybiBuZXcgVWludDhBcnJheSh0KTt0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBcIitlKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnNodWZmbGU9cixlLmNsYW1wPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gTWF0aC5tYXgodCxNYXRoLm1pbihlLHIpKX0sZS5uZWFyZXN0TGFyZ2VyRXZlbj1mdW5jdGlvbih0KXtyZXR1cm4gdCUyPT0wP3Q6dCsxfSxlLnN1bT1mdW5jdGlvbih0KXtmb3IodmFyIGU9MCxyPTA7cjx0Lmxlbmd0aDtyKyspZSs9dFtyXTtyZXR1cm4gZX0sZS5yYW5kVW5pZm9ybT1mdW5jdGlvbih0LGUpe3ZhciByPU1hdGgucmFuZG9tKCk7cmV0dXJuIGUqcisoMS1yKSp0fSxlLmRpc3RTcXVhcmVkPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPTAsbj0wO248dC5sZW5ndGg7bisrKXt2YXIgaT1OdW1iZXIodFtuXSktTnVtYmVyKGVbbl0pO3IrPWkqaX1yZXR1cm4gcn0sZS5hc3NlcnQ9bixlLmFzc2VydFNoYXBlc01hdGNoPWZ1bmN0aW9uKHQsZSxyKXt2b2lkIDA9PT1yJiYocj1cIlwiKSxuKG8odCxlKSxmdW5jdGlvbigpe3JldHVybiByK1wiIFNoYXBlcyBcIit0K1wiIGFuZCBcIitlK1wiIG11c3QgbWF0Y2hcIn0pfSxlLmFzc2VydE5vbk51bGw9ZnVuY3Rpb24odCl7bihudWxsIT10LGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgaW5wdXQgdG8gdGhlIHRlbnNvciBjb25zdHJ1Y3RvciBtdXN0IGJlIGEgbm9uLW51bGwgdmFsdWUuXCJ9KX0sZS5mbGF0dGVuPWksZS5zaXplRnJvbVNoYXBlPWZ1bmN0aW9uKHQpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gMTtmb3IodmFyIGU9dFswXSxyPTE7cjx0Lmxlbmd0aDtyKyspZSo9dFtyXTtyZXR1cm4gZX0sZS5pc1NjYWxhclNoYXBlPWZ1bmN0aW9uKHQpe3JldHVybiAwPT09dC5sZW5ndGh9LGUuYXJyYXlzRXF1YWw9byxlLmlzSW50PWEsZS50YW5oPWZ1bmN0aW9uKHQpe2lmKG51bGwhPU1hdGgudGFuaClyZXR1cm4gTWF0aC50YW5oKHQpO2lmKHQ9PT0xLzApcmV0dXJuIDE7aWYodD09PS0xLzApcmV0dXJuLTE7dmFyIGU9TWF0aC5leHAoMip0KTtyZXR1cm4oZS0xKS8oZSsxKX0sZS5zaXplVG9TcXVhcmlzaFNoYXBlPWZ1bmN0aW9uKHQpe3ZhciBlPU1hdGguY2VpbChNYXRoLnNxcnQodCkpO3JldHVybltlLE1hdGguY2VpbCh0L2UpXX0sZS5jcmVhdGVTaHVmZmxlZEluZGljZXM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBVaW50MzJBcnJheSh0KSxuPTA7bjx0OysrbillW25dPW47cmV0dXJuIHIoZSksZX0sZS5yaWdodFBhZD1mdW5jdGlvbih0LGUpe3JldHVybiBlPD10Lmxlbmd0aD90OnQrXCIgXCIucmVwZWF0KGUtdC5sZW5ndGgpfSxlLnJlcGVhdGVkVHJ5PWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ZnVuY3Rpb24odCl7cmV0dXJuIDB9KSxuZXcgUHJvbWlzZShmdW5jdGlvbihuLGkpe3ZhciBvPTAsYT1mdW5jdGlvbigpe2lmKHQoKSluKCk7ZWxzZXt2YXIgdT1lKCsrbyk7bnVsbCE9ciYmbz49cj9pKCk6c2V0VGltZW91dChhLHUpfX07YSgpfSl9LGUuaW5mZXJGcm9tSW1wbGljaXRTaGFwZT1mdW5jdGlvbih0LGUpe2Zvcih2YXIgcj0xLG49LTEsaT0wO2k8dC5sZW5ndGg7KytpKWlmKHRbaV0+PTApcio9dFtpXTtlbHNlIGlmKC0xPT09dFtpXSl7aWYoLTEhPT1uKXRocm93IEVycm9yKFwiU2hhcGVzIGNhbiBvbmx5IGhhdmUgMSBpbXBsaWNpdCBzaXplLiBGb3VuZCAtMSBhdCBkaW0gXCIrbitcIiBhbmQgZGltIFwiK2kpO249aX1lbHNlIGlmKHRbaV08MCl0aHJvdyBFcnJvcihcIlNoYXBlcyBjYW4gbm90IGJlIDwgMC4gRm91bmQgXCIrdFtpXStcIiBhdCBkaW0gXCIraSk7aWYoLTE9PT1uKXtpZihlPjAmJmUhPT1yKXRocm93IEVycm9yKFwiU2l6ZShcIitlK1wiKSBtdXN0IG1hdGNoIHRoZSBwcm9kdWN0IG9mIHNoYXBlIFwiK3QpO3JldHVybiB0fWlmKDA9PT1yKXRocm93IEVycm9yKFwiQ2Fubm90IGluZmVyIHRoZSBtaXNzaW5nIHNpemUgaW4gW1wiK3QrXCJdIHdoZW4gdGhlcmUgYXJlIDAgZWxlbWVudHNcIik7aWYoZSVyIT0wKXRocm93IEVycm9yKFwiVGhlIGltcGxpY2l0IHNoYXBlIGNhbid0IGJlIGEgZnJhY3Rpb25hbCBudW1iZXIuIEdvdCBcIitlK1wiIC8gXCIrcik7dmFyIG89dC5zbGljZSgpO3JldHVybiBvW25dPWUvcixvfSxlLnBhcnNlQXhpc1BhcmFtPXUsZS5zcXVlZXplU2hhcGU9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9W10sbj1bXSxpPW51bGw9PWU/bnVsbDp1KGUsdCkuc29ydCgpLG89MCxhPTA7YTx0Lmxlbmd0aDsrK2Epe2lmKG51bGwhPWkpe2lmKGlbb109PT1hJiYxIT09dFthXSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzcXVlZXplIGF4aXMgXCIrYStcIiBzaW5jZSBpdHMgZGltICdcIit0W2FdK1wiJyBpcyBub3QgMVwiKTsobnVsbD09aVtvXXx8aVtvXT5hKSYmMT09PXRbYV0mJihyLnB1c2godFthXSksbi5wdXNoKGEpKSxpW29dPD1hJiZvKyt9MSE9PXRbYV0mJihyLnB1c2godFthXSksbi5wdXNoKGEpKX1yZXR1cm57bmV3U2hhcGU6cixrZXB0RGltczpufX0sZS5nZXRUeXBlZEFycmF5RnJvbURUeXBlPWZ1bmN0aW9uKHQsZSl7dmFyIHI9bnVsbDtpZihudWxsPT10fHxcImZsb2F0MzJcIj09PXQpcj1uZXcgRmxvYXQzMkFycmF5KGUpO2Vsc2UgaWYoXCJpbnQzMlwiPT09dClyPW5ldyBJbnQzMkFycmF5KGUpO2Vsc2V7aWYoXCJib29sXCIhPT10KXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiK3QpO3I9bmV3IFVpbnQ4QXJyYXkoZSl9cmV0dXJuIHJ9LGUuZ2V0QXJyYXlGcm9tRFR5cGU9ZnVuY3Rpb24odCxlKXt2YXIgcj1udWxsO2lmKG51bGw9PXR8fFwiZmxvYXQzMlwiPT09dClyPW5ldyBGbG9hdDMyQXJyYXkoZSk7ZWxzZSBpZihcImludDMyXCI9PT10KXI9bmV3IEludDMyQXJyYXkoZSk7ZWxzZSBpZihcImJvb2xcIj09PXQpcj1uZXcgVWludDhBcnJheShlKTtlbHNle2lmKFwic3RyaW5nXCIhPT10KXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiK3QpO3I9bmV3IEFycmF5KGUpfXJldHVybiByfSxlLmNoZWNrQ29tcHV0YXRpb25Gb3JFcnJvcnM9ZnVuY3Rpb24odCxlLHIpe2lmKFwiZmxvYXQzMlwiPT09ZSlmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIGk9dFtuXTtpZihpc05hTihpKXx8IWlzRmluaXRlKGkpKXRocm93IEVycm9yKFwiVGhlIHJlc3VsdCBvZiB0aGUgJ1wiK3IrXCInIGlzIFwiK2krXCIuXCIpfX0sZS5jaGVja0NvbnZlcnNpb25Gb3JFcnJvcnM9cyxlLmhhc0VuY29kaW5nTG9zcz1mdW5jdGlvbih0LGUpe3JldHVybiEoXCJjb21wbGV4NjRcIj09PWV8fFwiZmxvYXQzMlwiPT09ZSYmXCJjb21wbGV4NjRcIiE9PXR8fFwiaW50MzJcIj09PWUmJlwiZmxvYXQzMlwiIT09dCYmXCJjb21wbGV4NjRcIiE9PXR8fFwiYm9vbFwiPT09ZSYmXCJib29sXCI9PT10KX0sZS5pc1R5cGVkQXJyYXk9YyxlLmJ5dGVzUGVyRWxlbWVudD1mdW5jdGlvbih0KXtpZihcImZsb2F0MzJcIj09PXR8fFwiaW50MzJcIj09PXQpcmV0dXJuIDQ7aWYoXCJjb21wbGV4NjRcIj09PXQpcmV0dXJuIDg7aWYoXCJib29sXCI9PT10KXJldHVybiAxO3Rocm93IG5ldyBFcnJvcihcIlVua25vd24gZHR5cGUgXCIrdCl9LGUuYnl0ZXNGcm9tU3RyaW5nQXJyYXk9ZnVuY3Rpb24odCl7aWYobnVsbD09dClyZXR1cm4gMDt2YXIgZT0wO3JldHVybiB0LmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIGUrPTIqdC5sZW5ndGh9KSxlfSxlLmlzU3RyaW5nPWwsZS5pc0Jvb2xlYW49ZixlLmlzTnVtYmVyPWgsZS5pbmZlckR0eXBlPWZ1bmN0aW9uIHQoZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/dChlWzBdKTplIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5P1wiZmxvYXQzMlwiOmUgaW5zdGFuY2VvZiBJbnQzMkFycmF5fHxlIGluc3RhbmNlb2YgVWludDhBcnJheT9cImludDMyXCI6aChlKT9cImZsb2F0MzJcIjpsKGUpP1wic3RyaW5nXCI6ZihlKT9cImJvb2xcIjpcImZsb2F0MzJcIn0sZS5pc0Z1bmN0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiEhKHQmJnQuY29uc3RydWN0b3ImJnQuY2FsbCYmdC5hcHBseSl9LGUubmVhcmVzdERpdmlzb3I9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9ZTtyPHQ7KytyKWlmKHQlcj09MClyZXR1cm4gcjtyZXR1cm4gdH0sZS5jb21wdXRlU3RyaWRlcz1mdW5jdGlvbih0KXt2YXIgZT10Lmxlbmd0aDtpZihlPDIpcmV0dXJuW107dmFyIHI9bmV3IEFycmF5KGUtMSk7cltlLTJdPXRbZS0xXTtmb3IodmFyIG49ZS0zO24+PTA7LS1uKXJbbl09cltuKzFdKnRbbisxXTtyZXR1cm4gcn0sZS50b1R5cGVkQXJyYXk9ZnVuY3Rpb24odCxlLHIpe2lmKFwic3RyaW5nXCI9PT1lKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IGEgc3RyaW5nW10gdG8gYSBUeXBlZEFycmF5XCIpO2lmKEFycmF5LmlzQXJyYXkodCkmJih0PWkodCkpLHImJnModCxlKSxmdW5jdGlvbih0LGUpe3JldHVybiB0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5JiZcImZsb2F0MzJcIj09PWV8fHQgaW5zdGFuY2VvZiBJbnQzMkFycmF5JiZcImludDMyXCI9PT1lfHx0IGluc3RhbmNlb2YgVWludDhBcnJheSYmXCJib29sXCI9PT1lfSh0LGUpKXJldHVybiB0O2lmKG51bGw9PWV8fFwiZmxvYXQzMlwiPT09ZXx8XCJjb21wbGV4NjRcIj09PWUpcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodCk7aWYoXCJpbnQzMlwiPT09ZSlyZXR1cm4gbmV3IEludDMyQXJyYXkodCk7aWYoXCJib29sXCI9PT1lKXtmb3IodmFyIG49bmV3IFVpbnQ4QXJyYXkodC5sZW5ndGgpLG89MDtvPG4ubGVuZ3RoOysrbykwIT09TWF0aC5yb3VuZCh0W29dKSYmKG5bb109MSk7cmV0dXJuIG59dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIrZSl9LGUudG9OZXN0ZWRBcnJheT1mdW5jdGlvbih0LGUpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gZVswXTt2YXIgcj10LnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KTtpZigwPT09cilyZXR1cm5bXTtpZihyIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiW1wiK3QrXCJdIGRvZXMgbm90IG1hdGNoIHRoZSBpbnB1dCBzaXplLlwiKTtyZXR1cm4gZnVuY3Rpb24gdChlLHIsbil7dmFyIGk9bmV3IEFycmF5O2lmKDE9PT1yLmxlbmd0aClmb3IodmFyIG89clswXSxhPTA7YTxvO2ErKylpW2FdPW5bZSthXTtlbHNle289clswXTt2YXIgdT1yLnNsaWNlKDEpLHM9dS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSk7Zm9yKGE9MDthPG87YSsrKWlbYV09dChlK2Eqcyx1LG4pfXJldHVybiBpfSgwLHQsZSl9LGUubWFrZU9uZXNUeXBlZEFycmF5PWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPXAodCxlKSxuPTA7bjxyLmxlbmd0aDtuKyspcltuXT0xO3JldHVybiByfSxlLm1ha2VaZXJvc1R5cGVkQXJyYXk9cCxlLm5vdz1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBwZXJmb3JtYW5jZSlyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHByb2Nlc3Mpe3ZhciB0PXByb2Nlc3MuaHJ0aW1lKCk7cmV0dXJuIDFlMyp0WzBdK3RbMV0vMWU2fXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtZWFzdXJlIHRpbWUgaW4gdGhpcyBlbnZpcm9ubWVudC4gWW91IHNob3VsZCBydW4gdGYuanMgaW4gdGhlIGJyb3dzZXIgb3IgaW4gTm9kZS5qc1wiKX0sZS5hc3NlcnROb25OZWdhdGl2ZUludGVnZXJEaW1lbnNpb25zPWZ1bmN0aW9uKHQpe3QuZm9yRWFjaChmdW5jdGlvbihlKXtuKE51bWJlci5pc0ludGVnZXIoZSkmJmU+PTAsZnVuY3Rpb24oKXtyZXR1cm5cIlRlbnNvciBtdXN0IGhhdmUgYSBzaGFwZSBjb21wcmlzZWQgb2YgcG9zaXRpdmUgaW50ZWdlcnMgYnV0IGdvdCBzaGFwZSBbXCIrdCtcIl0uXCJ9KX0pfTt2YXIgZD1mdW5jdGlvbigpe2lmKG51bGwhPWVudmlyb25tZW50LkVOVi5nbG9iYWwuZmV0Y2gpcmV0dXJuIGVudmlyb25tZW50LkVOVi5nbG9iYWwuZmV0Y2g7aWYoZW52aXJvbm1lbnQuRU5WLmdldChcIklTX05PREVcIikpcmV0dXJuIGUuZ2V0Tm9kZUZldGNoLmZldGNoSW1wb3J0KCk7dGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgdGhlIGZldGNoKCkgbWV0aG9kLiBQbGVhc2UgYWRkIHlvdXIgb3duIGZldGNoKCkgZnVuY3Rpb24gdG8gdGhlIGdsb2JhbCBuYW1lc3BhY2UuXCIpfTtlLmdldE5vZGVGZXRjaD17ZmV0Y2hJbXBvcnQ6ZnVuY3Rpb24oKXtyZXR1cm4gcmVxdWlyZShcIm5vZGUtZmV0Y2hcIil9fSxlLmZldGNoPWZ1bmN0aW9uKHQscil7cmV0dXJuIG51bGw9PWUuc3lzdGVtRmV0Y2gmJihlLnN5c3RlbUZldGNoPWQoKSksZS5zeXN0ZW1GZXRjaCh0LHIpfX0pO3Vud3JhcEV4cG9ydHModXRpbCQxKTt2YXIgdXRpbF8xPXV0aWwkMS5zaHVmZmxlLHV0aWxfMj11dGlsJDEuY2xhbXAsdXRpbF8zPXV0aWwkMS5uZWFyZXN0TGFyZ2VyRXZlbix1dGlsXzQ9dXRpbCQxLnN1bSx1dGlsXzU9dXRpbCQxLnJhbmRVbmlmb3JtLHV0aWxfNj11dGlsJDEuZGlzdFNxdWFyZWQsdXRpbF83PXV0aWwkMS5hc3NlcnQsdXRpbF84PXV0aWwkMS5hc3NlcnRTaGFwZXNNYXRjaCx1dGlsXzk9dXRpbCQxLmFzc2VydE5vbk51bGwsdXRpbF8xMD11dGlsJDEuZmxhdHRlbix1dGlsXzExPXV0aWwkMS5zaXplRnJvbVNoYXBlLHV0aWxfMTI9dXRpbCQxLmlzU2NhbGFyU2hhcGUsdXRpbF8xMz11dGlsJDEuYXJyYXlzRXF1YWwsdXRpbF8xND11dGlsJDEuaXNJbnQsdXRpbF8xNT11dGlsJDEudGFuaCx1dGlsXzE2PXV0aWwkMS5zaXplVG9TcXVhcmlzaFNoYXBlLHV0aWxfMTc9dXRpbCQxLmNyZWF0ZVNodWZmbGVkSW5kaWNlcyx1dGlsXzE4PXV0aWwkMS5yaWdodFBhZCx1dGlsXzE5PXV0aWwkMS5yZXBlYXRlZFRyeSx1dGlsXzIwPXV0aWwkMS5pbmZlckZyb21JbXBsaWNpdFNoYXBlLHV0aWxfMjE9dXRpbCQxLnBhcnNlQXhpc1BhcmFtLHV0aWxfMjI9dXRpbCQxLnNxdWVlemVTaGFwZSx1dGlsXzIzPXV0aWwkMS5nZXRUeXBlZEFycmF5RnJvbURUeXBlLHV0aWxfMjQ9dXRpbCQxLmdldEFycmF5RnJvbURUeXBlLHV0aWxfMjU9dXRpbCQxLmNoZWNrQ29tcHV0YXRpb25Gb3JFcnJvcnMsdXRpbF8yNj11dGlsJDEuY2hlY2tDb252ZXJzaW9uRm9yRXJyb3JzLHV0aWxfMjc9dXRpbCQxLmhhc0VuY29kaW5nTG9zcyx1dGlsXzI4PXV0aWwkMS5pc1R5cGVkQXJyYXksdXRpbF8yOT11dGlsJDEuYnl0ZXNQZXJFbGVtZW50LHV0aWxfMzA9dXRpbCQxLmJ5dGVzRnJvbVN0cmluZ0FycmF5LHV0aWxfMzE9dXRpbCQxLmlzU3RyaW5nLHV0aWxfMzI9dXRpbCQxLmlzQm9vbGVhbix1dGlsXzMzPXV0aWwkMS5pc051bWJlcix1dGlsXzM0PXV0aWwkMS5pbmZlckR0eXBlLHV0aWxfMzU9dXRpbCQxLmlzRnVuY3Rpb24sdXRpbF8zNj11dGlsJDEubmVhcmVzdERpdmlzb3IsdXRpbF8zNz11dGlsJDEuY29tcHV0ZVN0cmlkZXMsdXRpbF8zOD11dGlsJDEudG9UeXBlZEFycmF5LHV0aWxfMzk9dXRpbCQxLnRvTmVzdGVkQXJyYXksdXRpbF80MD11dGlsJDEubWFrZU9uZXNUeXBlZEFycmF5LHV0aWxfNDE9dXRpbCQxLm1ha2VaZXJvc1R5cGVkQXJyYXksdXRpbF80Mj11dGlsJDEubm93LHV0aWxfNDM9dXRpbCQxLmFzc2VydE5vbk5lZ2F0aXZlSW50ZWdlckRpbWVuc2lvbnMsdXRpbF80ND11dGlsJDEuZ2V0Tm9kZUZldGNoLHV0aWxfNDU9dXRpbCQxLnN5c3RlbUZldGNoLHV0aWxfNDY9dXRpbCQxLmZldGNoLFdlYmNhbUl0ZXJhdG9yPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyKXt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7aWYobi53ZWJjYW1WaWRlb0VsZW1lbnQ9ZSxuLndlYmNhbUNvbmZpZz1yLG4uaXNDbG9zZWQ9ITAsbi5yZXNpemU9ITEsbi5uZWVkVG9SZXNpemUoKSlpZihuLnJlc2l6ZT0hMCxuLmNyb3BTaXplPVtuLndlYmNhbUNvbmZpZy5yZXNpemVIZWlnaHQsbi53ZWJjYW1Db25maWcucmVzaXplV2lkdGhdLG4uY3JvcEJveEluZD10ZW5zb3IxZChbMF0sXCJpbnQzMlwiKSxuLndlYmNhbUNvbmZpZy5jZW50ZXJDcm9wKXt2YXIgaT0xKm4ud2ViY2FtQ29uZmlnLnJlc2l6ZVdpZHRoL24ud2ViY2FtVmlkZW9FbGVtZW50LndpZHRoLG89MSpuLndlYmNhbUNvbmZpZy5yZXNpemVIZWlnaHQvbi53ZWJjYW1WaWRlb0VsZW1lbnQuaGVpZ2h0LGE9KDEtaSkvMix1PSgxLW8pLzIscz1hK2ksYz1vK3U7bi5jcm9wQm94PXRlbnNvcjJkKFt1LGEsYyxzXSxbMSw0XSl9ZWxzZSBuLmNyb3BCb3g9dGVuc29yMmQoWzAsMCwxLDFdLFsxLDRdKTtyZXR1cm4gbn1yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbigpe3JldHVyblwid2ViY2FtXCJ9LGUuY3JlYXRlPWZ1bmN0aW9uKHQscil7cmV0dXJuIHZvaWQgMD09PXImJihyPXt9KSxfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oaSl7c3dpdGNoKGkubGFiZWwpe2Nhc2UgMDppZihFTlYuZ2V0KFwiSVNfTk9ERVwiKSl0aHJvdyBuZXcgRXJyb3IoXCJ0Zi5kYXRhLndlYmNhbSBpcyBvbmx5IHN1cHBvcnRlZCBpbiBicm93c2VyIGVudmlyb25tZW50LlwiKTtpZighdCl7aWYodD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIiksIXIucmVzaXplV2lkdGh8fCFyLnJlc2l6ZUhlaWdodCl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSB3ZWJjYW0gdmlkZW8gZWxlbWVudCwgb3IgcmVzaXplV2lkdGggYW5kIHJlc2l6ZUhlaWdodCB0byBjcmVhdGUgYSBoaWRkZW4gdmlkZW8gZWxlbWVudC5cIik7dC53aWR0aD1yLnJlc2l6ZVdpZHRoLHQuaGVpZ2h0PXIucmVzaXplSGVpZ2h0fXJldHVybls0LChuPW5ldyBlKHQscikpLnN0YXJ0KCldO2Nhc2UgMTpyZXR1cm4gaS5zZW50KCksWzIsbl19fSl9KX0sZS5wcm90b3R5cGUuc3RhcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGUscj10aGlzO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6dGhpcy53ZWJjYW1Db25maWcuZmFjaW5nTW9kZSYmdXRpbF83KFwidXNlclwiPT09dGhpcy53ZWJjYW1Db25maWcuZmFjaW5nTW9kZXx8XCJlbnZpcm9ubWVudFwiPT09dGhpcy53ZWJjYW1Db25maWcuZmFjaW5nTW9kZSxmdW5jdGlvbigpe3JldHVyblwiSW52YWxpZCB3ZWJjYW0gZmFjaW5nIG1vZGU6IFwiK3Iud2ViY2FtQ29uZmlnLmZhY2luZ01vZGUrXCIuIFBsZWFzZSBwcm92aWRlICd1c2VyJyBvciAnZW52aXJvbm1lbnQnXCJ9KSxuLmxhYmVsPTE7Y2FzZSAxOnJldHVybiBuLnRyeXMucHVzaChbMSwzLCw0XSksdD10aGlzLFs0LG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHt2aWRlbzp7ZGV2aWNlSWQ6dGhpcy53ZWJjYW1Db25maWcuZGV2aWNlSWQsZmFjaW5nTW9kZTp0aGlzLndlYmNhbUNvbmZpZy5mYWNpbmdNb2RlP3RoaXMud2ViY2FtQ29uZmlnLmZhY2luZ01vZGU6XCJ1c2VyXCIsd2lkdGg6dGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQud2lkdGgsaGVpZ2h0OnRoaXMud2ViY2FtVmlkZW9FbGVtZW50LmhlaWdodH19KV07Y2FzZSAyOnJldHVybiB0LnN0cmVhbT1uLnNlbnQoKSxbMyw0XTtjYXNlIDM6dGhyb3coZT1uLnNlbnQoKSkubWVzc2FnZT1cIkVycm9yIHRocm93biB3aGlsZSBpbml0aWFsaXppbmcgdmlkZW8gc3RyZWFtOiBcIitlLm1lc3NhZ2UsZTtjYXNlIDQ6aWYoIXRoaXMuc3RyZWFtKXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBvYnRhaW4gdmlkZW8gZnJvbSB3ZWJjYW0uXCIpO3RyeXt0aGlzLndlYmNhbVZpZGVvRWxlbWVudC5zcmNPYmplY3Q9dGhpcy5zdHJlYW19Y2F0Y2godCl7Y29uc29sZS5sb2codCksdGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQuc3JjPXdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKHRoaXMuc3RyZWFtKX1yZXR1cm4gdGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQucGxheSgpLHRoaXMuaXNDbG9zZWQ9ITEsWzIsbmV3IFByb21pc2UoZnVuY3Rpb24odCl7ci53ZWJjYW1WaWRlb0VsZW1lbnQub25sb2FkZWRtZXRhZGF0YT1mdW5jdGlvbigpe3QoKX19KV19fSl9KX0sZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7aWYodGhpcy5pc0Nsb3NlZClyZXR1cm5bMix7dmFsdWU6bnVsbCxkb25lOiEwfV07dHJ5e3Q9YnJvd3Nlci5mcm9tUGl4ZWxzKHRoaXMud2ViY2FtVmlkZW9FbGVtZW50KX1jYXRjaCh0KXt0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB0aHJvd24gY29udmVydGluZyB2aWRlbyB0byBwaXhlbHM6IFwiK0pTT04uc3RyaW5naWZ5KHQpKX1pZighdGhpcy5yZXNpemUpcmV0dXJuWzIse3ZhbHVlOnQsZG9uZTohMX1dO3RyeXtyZXR1cm5bMix7dmFsdWU6dGhpcy5jcm9wQW5kUmVzaXplRnJhbWUodCksZG9uZTohMX1dfWNhdGNoKHQpe3Rocm93IG5ldyBFcnJvcihcIkVycm9yIHRocm93biBjcm9wcGluZyB0aGUgdmlkZW86IFwiK3QubWVzc2FnZSl9cmV0dXJuWzJdfSl9KX0sZS5wcm90b3R5cGUubmVlZFRvUmVzaXplPWZ1bmN0aW9uKCl7cmV0dXJuISghdGhpcy53ZWJjYW1Db25maWcucmVzaXplV2lkdGh8fCF0aGlzLndlYmNhbUNvbmZpZy5yZXNpemVIZWlnaHR8fHRoaXMud2ViY2FtVmlkZW9FbGVtZW50LndpZHRoPT09dGhpcy53ZWJjYW1Db25maWcucmVzaXplV2lkdGgmJnRoaXMud2ViY2FtVmlkZW9FbGVtZW50LmhlaWdodD09PXRoaXMud2ViY2FtQ29uZmlnLnJlc2l6ZUhlaWdodCl9LGUucHJvdG90eXBlLmNyb3BBbmRSZXNpemVGcmFtZT1mdW5jdGlvbih0KXt2YXIgZSxyPXQudG9GbG9hdCgpLmV4cGFuZERpbXMoMCksbj0oZT1pbWFnZS5jcm9wQW5kUmVzaXplKHIsdGhpcy5jcm9wQm94LHRoaXMuY3JvcEJveEluZCx0aGlzLmNyb3BTaXplLFwiYmlsaW5lYXJcIikpLnNoYXBlO3JldHVybiBlLnJlc2hhcGUobi5zbGljZSgxKSl9LGUucHJvdG90eXBlLmNhcHR1cmU9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5uZXh0KCldO2Nhc2UgMTpyZXR1cm5bMix0LnNlbnQoKS52YWx1ZV19fSl9KX0sZS5wcm90b3R5cGUuc3RvcD1mdW5jdGlvbigpe3RoaXMuc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIHQuc3RvcCgpfSk7dHJ5e3RoaXMud2ViY2FtVmlkZW9FbGVtZW50LnNyY09iamVjdD1udWxsfWNhdGNoKHQpe2NvbnNvbGUubG9nKHQpLHRoaXMud2ViY2FtVmlkZW9FbGVtZW50LnNyYz1udWxsfXRoaXMuaXNDbG9zZWQ9ITB9LGUucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGNvbnZlcnQgaW5maW5pdGUgdmlkZW8gc3RyZWFtIHRvIGFycmF5LlwiKX0sZX0oTGF6eUl0ZXJhdG9yKSxEYXRhU291cmNlPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKCl7fX0oKSxTdHJpbmdJdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIG51bGwhPT10JiZ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuc3BsaXQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBTcGxpdEl0ZXJhdG9yKHRoaXMsdCl9LGV9KExhenlJdGVyYXRvciksU3BsaXRJdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscil7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLnVwc3RyZWFtPWUsbi5pbXBsPW5ldyBTcGxpdEl0ZXJhdG9ySW1wbChlLHIpLG59cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbXBsLnN1bW1hcnkoKX0sZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuWzIsdGhpcy5pbXBsLm5leHQoKV19KX0pfSxlfShTdHJpbmdJdGVyYXRvciksU3BsaXRJdGVyYXRvckltcGw9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLHIpe3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi51cHN0cmVhbT1lLG4uc2VwYXJhdG9yPXIsbi5jYXJyeW92ZXI9XCJcIixufXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudXBzdHJlYW0uc3VtbWFyeSgpK1wiIC0+IFNwbGl0KCdcIit0aGlzLnNlcGFyYXRvcitcIicpXCJ9LGUucHJvdG90eXBlLnB1bXA9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciB0LGUscixuLGk7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obyl7c3dpdGNoKG8ubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLnVwc3RyZWFtLm5leHQoKV07Y2FzZSAxOmlmKCh0PW8uc2VudCgpKS5kb25lKXJldHVyblwiXCI9PT10aGlzLmNhcnJ5b3Zlcj9bMiwhMV06KHRoaXMub3V0cHV0UXVldWUucHVzaCh0aGlzLmNhcnJ5b3ZlciksdGhpcy5jYXJyeW92ZXI9XCJcIixbMiwhMF0pO2ZvcigoZT10LnZhbHVlLnNwbGl0KHRoaXMuc2VwYXJhdG9yKSlbMF09dGhpcy5jYXJyeW92ZXIrZVswXSxyPTAsbj1lLnNsaWNlKDAsLTEpO3I8bi5sZW5ndGg7cisrKWk9bltyXSx0aGlzLm91dHB1dFF1ZXVlLnB1c2goaSk7cmV0dXJuIHRoaXMuY2FycnlvdmVyPWVbZS5sZW5ndGgtMV0sWzIsITBdfX0pfSl9LGV9KE9uZVRvTWFueUl0ZXJhdG9yKSxCeXRlQ2h1bmtJdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIG51bGwhPT10JiZ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKGUsdCksZS5wcm90b3R5cGUuZGVjb2RlVVRGOD1mdW5jdGlvbigpe3JldHVybiBuZXcgVXRmOEl0ZXJhdG9yKHRoaXMpfSxlfShMYXp5SXRlcmF0b3IpLFV0ZjhJdGVyYXRvcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciByPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gci51cHN0cmVhbT1lLHIuaW1wbD1uZXcgVXRmOEl0ZXJhdG9ySW1wbChlKSxyfXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW1wbC5zdW1tYXJ5KCl9LGUucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHQpe3JldHVyblsyLHRoaXMuaW1wbC5uZXh0KCldfSl9KX0sZX0oU3RyaW5nSXRlcmF0b3IpLFV0ZjhJdGVyYXRvckltcGw9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXt2YXIgcj10LmNhbGwodGhpcyl8fHRoaXM7aWYoci51cHN0cmVhbT1lLEVOVi5nZXQoXCJJU19CUk9XU0VSXCIpKXIuZGVjb2Rlcj1uZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTtlbHNle3ZhciBuPXJlcXVpcmUoXCJzdHJpbmdfZGVjb2RlclwiKS5TdHJpbmdEZWNvZGVyO3IuZGVjb2Rlcj1uZXcgbihcInV0ZjhcIil9cmV0dXJuIHJ9cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51cHN0cmVhbS5zdW1tYXJ5KCkrXCIgLT4gVXRmOFwifSxlLnByb3RvdHlwZS5wdW1wPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlLHI7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLnVwc3RyZWFtLm5leHQoKV07Y2FzZSAxOnJldHVybih0PW4uc2VudCgpKS5kb25lP1syLCExXTooZT10LnZhbHVlLHI9RU5WLmdldChcIklTX0JST1dTRVJcIik/dGhpcy5kZWNvZGVyLmRlY29kZShlLHtzdHJlYW06ITB9KTp0aGlzLmRlY29kZXIud3JpdGUoQnVmZmVyLmZyb20oZS5idWZmZXIpKSx0aGlzLm91dHB1dFF1ZXVlLnB1c2gociksWzIsITBdKX19KX0pfSxlfShPbmVUb01hbnlJdGVyYXRvciksRmlsZUNodW5rSXRlcmF0b3I9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLHIpe3ZvaWQgMD09PXImJihyPXt9KTt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4uZmlsZT1lLG4ub3B0aW9ucz1yLHV0aWwuYXNzZXJ0KGUgaW5zdGFuY2VvZiBVaW50OEFycmF5fHwhIUVOVi5nZXQoXCJJU19CUk9XU0VSXCIpJiYoZSBpbnN0YW5jZW9mIEZpbGV8fGUgaW5zdGFuY2VvZiBCbG9iKSxmdW5jdGlvbigpe3JldHVyblwiRmlsZUNodW5rSXRlcmF0b3Igb25seSBzdXBwb3J0cyBGaWxlLCBCbG9iIGFuZCBVaW50OEFycmF5IHJpZ2h0IG5vdy5cIn0pLG4ub2Zmc2V0PXIub2Zmc2V0fHwwLG4uY2h1bmtTaXplPXIuY2h1bmtTaXplfHwxMDQ4NTc2LG59cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLnN1bW1hcnk9ZnVuY3Rpb24oKXtyZXR1cm5cIkZpbGVDaHVua3MgXCIrdGhpcy5maWxlfSxlLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxlLHI9dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOnJldHVybiB0aGlzLm9mZnNldD49KHRoaXMuZmlsZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk/dGhpcy5maWxlLmJ5dGVMZW5ndGg6dGhpcy5maWxlLnNpemUpP1syLHt2YWx1ZTpudWxsLGRvbmU6ITB9XToodD1uZXcgUHJvbWlzZShmdW5jdGlvbih0LGUpe3ZhciBuPXIub2Zmc2V0K3IuY2h1bmtTaXplO2lmKHIuZmlsZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpdChuZXcgVWludDhBcnJheShyLmZpbGUuc2xpY2Uoci5vZmZzZXQsbikpKTtlbHNle3ZhciBpPW5ldyBGaWxlUmVhZGVyO2kub25sb2FkPWZ1bmN0aW9uKHIpe3ZhciBuPWkucmVzdWx0O2lmKG4gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciYmKG49bmV3IFVpbnQ4QXJyYXkobikpLCEobiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKXJldHVybiBlKG5ldyBUeXBlRXJyb3IoXCJGaWxlUmVhZGVyIHJldHVybmVkIHVua25vd24gdHlwZS5cIikpO3Qobil9LGkub25hYm9ydD1mdW5jdGlvbih0KXtyZXR1cm4gZShuZXcgRXJyb3IoXCJBYm9ydGVkXCIpKX0saS5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiBlKG5ldyBFcnJvcih0LnR5cGUpKX07dmFyIG89ci5maWxlLnNsaWNlKHIub2Zmc2V0LG4pO2kucmVhZEFzQXJyYXlCdWZmZXIobyl9ci5vZmZzZXQ9bn0pLGU9e30sWzQsdF0pO2Nhc2UgMTpyZXR1cm5bMiwoZS52YWx1ZT1uLnNlbnQoKSxlLmRvbmU9ITEsZSldfX0pfSl9LGV9KEJ5dGVDaHVua0l0ZXJhdG9yKTtmdW5jdGlvbiB1cmxDaHVua0l0ZXJhdG9yKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPXt9KSxfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHIsbixpLG87cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oYSl7c3dpdGNoKGEubGFiZWwpe2Nhc2UgMDpyZXR1cm4gRU5WLmdldChcIklTX0JST1dTRVJcIik/WzQsZmV0Y2godCldOlszLDVdO2Nhc2UgMTpyZXR1cm4ocj1hLnNlbnQoKSkub2s/WzQsci5ibG9iKCldOlszLDNdO2Nhc2UgMjpyZXR1cm4gbj1hLnNlbnQoKSxbMixuZXcgRmlsZUNodW5rSXRlcmF0b3IobixlKV07Y2FzZSAzOnRocm93IG5ldyBFcnJvcihyLnN0YXR1c1RleHQpO2Nhc2UgNDpyZXR1cm5bMyw5XTtjYXNlIDU6aWYoaT1yZXF1aXJlKFwibm9kZS1mZXRjaFwiKSxcInN0cmluZ1wiIT10eXBlb2YgdCl0aHJvdyBuZXcgRXJyb3IoXCJVUkwgbXVzdCBiZSBhIHN0cmluZy4gUmVxdWVzdCBvYmplY3RzIGFyZSBub3Qgc3VwcG9ydGVkIGluIHRoZSBub2RlLmpzIGVudmlyb25tZW50IHlldC5cIik7cmV0dXJuWzQsaSh0KV07Y2FzZSA2OnJldHVybihyPWEuc2VudCgpKS5vaz9bNCxyLmJ1ZmZlcigpXTpbMyw4XTtjYXNlIDc6cmV0dXJuIG89YS5zZW50KCksWzIsbmV3IEZpbGVDaHVua0l0ZXJhdG9yKG8sZSldO2Nhc2UgODp0aHJvdyBuZXcgRXJyb3Ioci5zdGF0dXNUZXh0KTtjYXNlIDk6cmV0dXJuWzJdfX0pfSl9ZnVuY3Rpb24gaXNMb2NhbFBhdGgodCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHQmJlwiZmlsZTovL1wiPT09dC5zdWJzdHIoMCw3KX12YXIgRmlsZURhdGFTb3VyY2U9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLHIpe3ZvaWQgMD09PXImJihyPXt9KTt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4uaW5wdXQ9ZSxuLm9wdGlvbnM9cixufXJldHVybiBfX2V4dGVuZHMoZSx0KSxlLnByb3RvdHlwZS5pdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuIGlzTG9jYWxQYXRoKHRoaXMuaW5wdXQpJiZFTlYuZ2V0KFwiSVNfTk9ERVwiKSYmKHQ9cmVxdWlyZShcImZzXCIpLHRoaXMuaW5wdXQ9dC5yZWFkRmlsZVN5bmModGhpcy5pbnB1dC5zdWJzdHIoNykpKSxbMixuZXcgRmlsZUNodW5rSXRlcmF0b3IodGhpcy5pbnB1dCx0aGlzLm9wdGlvbnMpXX0pfSl9LGV9KERhdGFTb3VyY2UpLFVSTERhdGFTb3VyY2U9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLHIpe3ZvaWQgMD09PXImJihyPXt9KTt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4udXJsPWUsbi5maWxlT3B0aW9ucz1yLG59cmV0dXJuIF9fZXh0ZW5kcyhlLHQpLGUucHJvdG90eXBlLml0ZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gaXNMb2NhbFBhdGgodGhpcy51cmwpP1syLG5ldyBGaWxlRGF0YVNvdXJjZSh0aGlzLnVybCx0aGlzLmZpbGVPcHRpb25zKS5pdGVyYXRvcigpXTpbMix1cmxDaHVua0l0ZXJhdG9yKHRoaXMudXJsLHRoaXMuZmlsZU9wdGlvbnMpXX0pfSl9LGV9KERhdGFTb3VyY2UpO2Z1bmN0aW9uIGNzdih0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT17fSksbmV3IENTVkRhdGFzZXQobmV3IFVSTERhdGFTb3VyY2UodCksZSl9ZnVuY3Rpb24gZnVuYyh0KXt2YXIgZT10aGlzLHI9aXRlcmF0b3JGcm9tRnVuY3Rpb24odCk7cmV0dXJuIGRhdGFzZXRGcm9tSXRlcmF0b3JGbihmdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIoZSx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuWzIscl19KX0pfSl9ZnVuY3Rpb24gZ2VuZXJhdG9yKHQpe3ZhciBlPXRoaXM7cmV0dXJuIGRhdGFzZXRGcm9tSXRlcmF0b3JGbihmdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIoZSx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0KCldO2Nhc2UgMTpyZXR1cm4gZT1yLnNlbnQoKSxbMixpdGVyYXRvckZyb21GdW5jdGlvbihmdW5jdGlvbigpe3JldHVybiBlLm5leHQoKX0pXX19KX0pfSl9ZnVuY3Rpb24gd2ViY2FtKHQsZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtyZXR1cm5bMixXZWJjYW1JdGVyYXRvci5jcmVhdGUodCxlKV19KX0pfXZhciB2ZXJzaW9uPVwiMS4xLjJcIjtleHBvcnR7YXJyYXksRGF0YXNldCx6aXAsQ1NWRGF0YXNldCxUZXh0TGluZURhdGFzZXQsY3N2LGZ1bmMsZ2VuZXJhdG9yLHdlYmNhbSxGaWxlRGF0YVNvdXJjZSxVUkxEYXRhU291cmNlLHZlcnNpb24gYXMgdmVyc2lvbl9kYXRhfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRmLWRhdGEuZXNtLmpzLm1hcFxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuaW1wb3J0e2JhY2tlbmQsdXRpbCx0aWR5LG9uZXNMaWtlLHNjYWxhcix0ZW5zb3IxZCx3aGVyZSx6ZXJvc0xpa2UsdHJhaW4sY2FzdCxkaXNwb3NlLG1lbW9yeSxzZXJpYWxpemF0aW9uLGFkZCxtdWwsZGl2LGtlZXAsbmV4dEZyYW1lLFRlbnNvcixPcHRpbWl6ZXIsY29uY2F0LG1lYW4saW8sdHJhbnNwb3NlLGV4cGFuZERpbXMscmV2ZXJzZSx1bnN0YWNrLHN0YWNrLHplcm9zLHN1bSxzcGxpdCxuZWcsdmFyaWFibGUsb25lcyxleWUscmFuZG9tVW5pZm9ybSx0cnVuY2F0ZWROb3JtYWwscmFuZG9tTm9ybWFsLHN1YixzcXJ0LG11bFN0cmljdCxjbGlwQnlWYWx1ZSxyZWx1LGxpbmFsZyxsZWFreVJlbHUscHJlbHUsZWx1LGNvbnYxZCxjb252MmQsY29udjNkLGNvbnYyZFRyYW5zcG9zZSxzZXBhcmFibGVDb252MmQsZGVwdGh3aXNlQ29udjJkLGFueSxub3RFcXVhbCxsb2dpY2FsQW5kLG1heGltdW0sbWluaW11bSxhbGwsYmF0Y2hOb3JtMmQsYmF0Y2hOb3JtM2QsYmF0Y2hOb3JtNGQsbW9tZW50cyxwYWQsbWF4UG9vbCxhdmdQb29sLHNxdWVlemUsbWF4LGdyZWF0ZXJFcXVhbCxmaWxsLGFicyxsb2csc29mdHBsdXMsc29mdG1heCxmbG9vcixvbmVIb3QsZ3JlYXRlcixlcXVhbCxhcmdNYXgsc2xpY2UxZCxzbGljZTJkLHNsaWNlM2Qsc2xpY2U0ZCxjb25jYXQxZCxjb25jYXQyZCxjb25jYXQzZCxjb25jYXQ0ZCx0aWxlLGZ1c2VkLGdhdGhlcixzdGVwLG1pbixzZWx1LHNpZ21vaWQsdGFuaH1mcm9tXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIjt2YXIgZXh0ZW5kU3RhdGljcz1mdW5jdGlvbihlLHQpe3JldHVybihleHRlbmRTdGF0aWNzPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihlLHQpe2UuX19wcm90b19fPXR9fHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgbiBpbiB0KXQuaGFzT3duUHJvcGVydHkobikmJihlW25dPXRbbl0pfSkoZSx0KX07ZnVuY3Rpb24gX19leHRlbmRzKGUsdCl7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9ZX1leHRlbmRTdGF0aWNzKGUsdCksZS5wcm90b3R5cGU9bnVsbD09PXQ/T2JqZWN0LmNyZWF0ZSh0KToobi5wcm90b3R5cGU9dC5wcm90b3R5cGUsbmV3IG4pfXZhciBfZXBzaWxvbixfX2Fzc2lnbj1mdW5jdGlvbigpe3JldHVybihfX2Fzc2lnbj1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihlKXtmb3IodmFyIHQsbj0xLHI9YXJndW1lbnRzLmxlbmd0aDtuPHI7bisrKWZvcih2YXIgaSBpbiB0PWFyZ3VtZW50c1tuXSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxpKSYmKGVbaV09dFtpXSk7cmV0dXJuIGV9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIF9fYXdhaXRlcihlLHQsbixyKXtyZXR1cm4gbmV3KG58fChuPVByb21pc2UpKShmdW5jdGlvbihpLGEpe2Z1bmN0aW9uIG8oZSl7dHJ5e2woci5uZXh0KGUpKX1jYXRjaChlKXthKGUpfX1mdW5jdGlvbiBzKGUpe3RyeXtsKHIudGhyb3coZSkpfWNhdGNoKGUpe2EoZSl9fWZ1bmN0aW9uIGwoZSl7ZS5kb25lP2koZS52YWx1ZSk6bmV3IG4oZnVuY3Rpb24odCl7dChlLnZhbHVlKX0pLnRoZW4obyxzKX1sKChyPXIuYXBwbHkoZSx0fHxbXSkpLm5leHQoKSl9KX1mdW5jdGlvbiBfX2dlbmVyYXRvcihlLHQpe3ZhciBuLHIsaSxhLG89e2xhYmVsOjAsc2VudDpmdW5jdGlvbigpe2lmKDEmaVswXSl0aHJvdyBpWzFdO3JldHVybiBpWzFdfSx0cnlzOltdLG9wczpbXX07cmV0dXJuIGE9e25leHQ6cygwKSx0aHJvdzpzKDEpLHJldHVybjpzKDIpfSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihhW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLGE7ZnVuY3Rpb24gcyhhKXtyZXR1cm4gZnVuY3Rpb24ocyl7cmV0dXJuIGZ1bmN0aW9uKGEpe2lmKG4pdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7Zm9yKDtvOyl0cnl7aWYobj0xLHImJihpPTImYVswXT9yLnJldHVybjphWzBdP3IudGhyb3d8fCgoaT1yLnJldHVybikmJmkuY2FsbChyKSwwKTpyLm5leHQpJiYhKGk9aS5jYWxsKHIsYVsxXSkpLmRvbmUpcmV0dXJuIGk7c3dpdGNoKHI9MCxpJiYoYT1bMiZhWzBdLGkudmFsdWVdKSxhWzBdKXtjYXNlIDA6Y2FzZSAxOmk9YTticmVhaztjYXNlIDQ6cmV0dXJuIG8ubGFiZWwrKyx7dmFsdWU6YVsxXSxkb25lOiExfTtjYXNlIDU6by5sYWJlbCsrLHI9YVsxXSxhPVswXTtjb250aW51ZTtjYXNlIDc6YT1vLm9wcy5wb3AoKSxvLnRyeXMucG9wKCk7Y29udGludWU7ZGVmYXVsdDppZighKGk9KGk9by50cnlzKS5sZW5ndGg+MCYmaVtpLmxlbmd0aC0xXSkmJig2PT09YVswXXx8Mj09PWFbMF0pKXtvPTA7Y29udGludWV9aWYoMz09PWFbMF0mJighaXx8YVsxXT5pWzBdJiZhWzFdPGlbM10pKXtvLmxhYmVsPWFbMV07YnJlYWt9aWYoNj09PWFbMF0mJm8ubGFiZWw8aVsxXSl7by5sYWJlbD1pWzFdLGk9YTticmVha31pZihpJiZvLmxhYmVsPGlbMl0pe28ubGFiZWw9aVsyXSxvLm9wcy5wdXNoKGEpO2JyZWFrfWlbMl0mJm8ub3BzLnBvcCgpLG8udHJ5cy5wb3AoKTtjb250aW51ZX1hPXQuY2FsbChlLG8pfWNhdGNoKGUpe2E9WzYsZV0scj0wfWZpbmFsbHl7bj1pPTB9aWYoNSZhWzBdKXRocm93IGFbMV07cmV0dXJue3ZhbHVlOmFbMF0/YVsxXTp2b2lkIDAsZG9uZTohMH19KFthLHNdKX19fWZ1bmN0aW9uIGVwc2lsb24oKXtyZXR1cm4gbnVsbD09X2Vwc2lsb24mJihfZXBzaWxvbj1iYWNrZW5kKCkuZXBzaWxvbigpKSxfZXBzaWxvbn1mdW5jdGlvbiBpbWFnZURhdGFGb3JtYXQoKXtyZXR1cm5cImNoYW5uZWxzTGFzdFwifXZhciBBdHRyaWJ1dGVFcnJvcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KG4pe3ZhciByPWUuY2FsbCh0aGlzLG4pfHx0aGlzO3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2Yocix0LnByb3RvdHlwZSkscn1yZXR1cm4gX19leHRlbmRzKHQsZSksdH0oRXJyb3IpLFJ1bnRpbWVFcnJvcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KG4pe3ZhciByPWUuY2FsbCh0aGlzLG4pfHx0aGlzO3JldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2Yocix0LnByb3RvdHlwZSkscn1yZXR1cm4gX19leHRlbmRzKHQsZSksdH0oRXJyb3IpLFZhbHVlRXJyb3I9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuKXt2YXIgcj1lLmNhbGwodGhpcyxuKXx8dGhpcztyZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKHIsdC5wcm90b3R5cGUpLHJ9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHR9KEVycm9yKSxOb3RJbXBsZW1lbnRlZEVycm9yPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobil7dmFyIHI9ZS5jYWxsKHRoaXMsbil8fHRoaXM7cmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihyLHQucHJvdG90eXBlKSxyfXJldHVybiBfX2V4dGVuZHModCxlKSx0fShFcnJvciksQXNzZXJ0aW9uRXJyb3I9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuKXt2YXIgcj1lLmNhbGwodGhpcyxuKXx8dGhpcztyZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKHIsdC5wcm90b3R5cGUpLHJ9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHR9KEVycm9yKSxJbmRleEVycm9yPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobil7dmFyIHI9ZS5jYWxsKHRoaXMsbil8fHRoaXM7cmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihyLHQucHJvdG90eXBlKSxyfXJldHVybiBfX2V4dGVuZHModCxlKSx0fShFcnJvcik7ZnVuY3Rpb24gcHlMaXN0UmVwZWF0KGUsdCl7aWYoQXJyYXkuaXNBcnJheShlKSl7Zm9yKHZhciBuPVtdLHI9MDtyPHQ7cisrKW49bi5jb25jYXQoZSk7cmV0dXJuIG59cmV0dXJuKG49bmV3IEFycmF5KHQpKS5maWxsKGUpLG59ZnVuY3Rpb24gYXNzZXJ0KGUsdCl7aWYoIWUpdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKHQpfWZ1bmN0aW9uIGNvdW50KGUsdCl7Zm9yKHZhciBuPTAscj0wLGk9ZTtyPGkubGVuZ3RoO3IrKyl7aVtyXT09PXQmJm4rK31yZXR1cm4gbn1mdW5jdGlvbiBzaW5nbGV0b25PckFycmF5KGUpe3JldHVybiAxPT09ZS5sZW5ndGg/ZVswXTplfWZ1bmN0aW9uIHRvTGlzdChlKXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKT9lOltlXX1mdW5jdGlvbiB0b1NuYWtlQ2FzZShlKXt2YXIgdD1lLnJlcGxhY2UoLyguKShbQS1aXVthLXowLTldKykvZyxcIiQxXyQyXCIpLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csXCIkMV8kMlwiKS50b0xvd2VyQ2FzZSgpO3JldHVyblwiX1wiIT09dFswXT90OlwicHJpdmF0ZVwiK3R9ZnVuY3Rpb24gdG9DYW1lbENhc2UoZSl7cmV0dXJuIGUubGVuZ3RoPD0xP2U6LTE9PT1lLmluZGV4T2YoXCJfXCIpP2U6ZS5yZXBsYWNlKC9bX10rKFxcd3wkKS9nLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQudG9VcHBlckNhc2UoKX0pfXZhciBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTPXt9O2Z1bmN0aW9uIHNlcmlhbGl6ZUtlcmFzT2JqZWN0KGUpe2lmKG51bGw9PT1lfHx2b2lkIDA9PT1lKXJldHVybiBudWxsO3ZhciB0PXt9O3JldHVybiB0LmNsYXNzTmFtZT1lLmdldENsYXNzTmFtZSgpLHQuY29uZmlnPWUuZ2V0Q29uZmlnKCksdH1mdW5jdGlvbiBjb252ZXJ0TkRBcnJheVNjYWxhcnNJbkNvbmZpZyhlKXtpZihudWxsIT1lJiZcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKWUuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gY29udmVydE5EQXJyYXlTY2FsYXJzSW5Db25maWcoZSl9KTtlbHNlIGZvcih2YXIgdD0wLG49T2JqZWN0LmtleXMoZSk7dDxuLmxlbmd0aDt0Kyspe3ZhciByPW5bdF0saT1lW3JdO251bGwhPWkmJlwib2JqZWN0XCI9PXR5cGVvZiBpJiYoQXJyYXkuaXNBcnJheShpKXx8XCJuZGFycmF5XCIhPT1pLnR5cGV8fFwibnVtYmVyXCIhPXR5cGVvZiBpLnZhbHVlP2NvbnZlcnROREFycmF5U2NhbGFyc0luQ29uZmlnKGkpOmVbcl09aS52YWx1ZSl9fWZ1bmN0aW9uIGRlc2VyaWFsaXplS2VyYXNPYmplY3QoZSx0LG4scixpKXt2YXIgYSxvLHM7aWYodm9pZCAwPT09dCYmKHQ9e30pLHZvaWQgMD09PW4mJihuPXt9KSx2b2lkIDA9PT1yJiYocj1cIm9iamVjdFwiKSx2b2lkIDA9PT1pJiYoaT0hMSksXCJzdHJpbmdcIj09dHlwZW9mIGUpe3ZhciBsPWUsdT12b2lkIDA7aWYobCBpbiBuKXU9bltsXTtlbHNlIGlmKGwgaW4gX0dMT0JBTF9DVVNUT01fT0JKRUNUUyl1PV9HTE9CQUxfQ1VTVE9NX09CSkVDVFNbbF07ZWxzZSBpZihudWxsPT0odT10W2xdKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlVua25vd24gXCIrcitcIjogXCIrZStcIi4gVGhpcyBtYXkgYmUgZHVlIHRvIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gVGhlIFwiK3IrXCIgaXMgZGVmaW5lZCBpbiBQeXRob24sIGluIHdoaWNoIGNhc2UgaXQgbmVlZHMgdG8gYmUgcG9ydGVkIHRvIFRlbnNvckZsb3cuanMgb3IgeW91ciBKYXZhU2NyaXB0IGNvZGUuXFxuMi4gVGhlIGN1c3RvbSBcIityK1wiIGlzIGRlZmluZWQgaW4gSmF2YVNjcmlwdCwgYnV0IGlzIG5vdCByZWdpc3RlcmVkIHByb3Blcmx5IHdpdGggdGYuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKCkuXCIpO3JldHVybiB1fXZhciBjPWU7aWYobnVsbD09Yy5jbGFzc05hbWV8fG51bGw9PWMuY29uZmlnKXRocm93IG5ldyBWYWx1ZUVycm9yKHIrXCI6IEltcHJvcGVyIGNvbmZpZyBmb3JtYXQ6IFwiK0pTT04uc3RyaW5naWZ5KGMpK1wiLlxcbidjbGFzc05hbWUnIGFuZCAnY29uZmlnJyBtdXN0IHNldC5cIik7dmFyIHA9Yy5jbGFzc05hbWUsaD12b2lkIDAsZD12b2lkIDA7aWYocCBpbiBuPyhoPShhPW5bcF0pWzBdLGQ9YVsxXSk6cCBpbiBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTPyhoPShvPV9HTE9CQUxfQ1VTVE9NX09CSkVDVFMuY2xhc3NOYW1lKVswXSxkPW9bMV0pOnAgaW4gdCYmKGg9KHM9dFtwXSlbMF0sZD1zWzFdKSxudWxsPT1oKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVW5rbm93biBcIityK1wiOiBcIitwK1wiLiBUaGlzIG1heSBiZSBkdWUgdG8gb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBUaGUgXCIrcitcIiBpcyBkZWZpbmVkIGluIFB5dGhvbiwgaW4gd2hpY2ggY2FzZSBpdCBuZWVkcyB0byBiZSBwb3J0ZWQgdG8gVGVuc29yRmxvdy5qcyBvciB5b3VyIEphdmFTY3JpcHQgY29kZS5cXG4yLiBUaGUgY3VzdG9tIFwiK3IrXCIgaXMgZGVmaW5lZCBpbiBKYXZhU2NyaXB0LCBidXQgaXMgbm90IHJlZ2lzdGVyZWQgcHJvcGVybHkgd2l0aCB0Zi5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoKS5cIik7aWYobnVsbCE9ZCl7Zm9yKHZhciBmPXt9LGc9MCxtPU9iamVjdC5rZXlzKF9HTE9CQUxfQ1VTVE9NX09CSkVDVFMpO2c8bS5sZW5ndGg7ZysrKXtmW1M9bVtnXV09X0dMT0JBTF9DVVNUT01fT0JKRUNUU1tTXX1mb3IodmFyIHk9MCx2PU9iamVjdC5rZXlzKG4pO3k8di5sZW5ndGg7eSsrKXtmW1M9dlt5XV09bltTXX1jLmNvbmZpZy5jdXN0b21PYmplY3RzPWY7Zm9yKHZhciBiPV9fYXNzaWduKHt9LF9HTE9CQUxfQ1VTVE9NX09CSkVDVFMpLHc9MCx6PU9iamVjdC5rZXlzKG4pO3c8ei5sZW5ndGg7dysrKXt2YXIgUz16W3ddO19HTE9CQUxfQ1VTVE9NX09CSkVDVFNbU109bltTXX1jb252ZXJ0TkRBcnJheVNjYWxhcnNJbkNvbmZpZyhjLmNvbmZpZyk7dmFyIEk9ZChoLGMuY29uZmlnLG4saSk7cmV0dXJuIF9HTE9CQUxfQ1VTVE9NX09CSkVDVFM9X19hc3NpZ24oe30sYiksSX1iPV9fYXNzaWduKHt9LF9HTE9CQUxfQ1VTVE9NX09CSkVDVFMpO2Zvcih2YXIgQT0wLF89T2JqZWN0LmtleXMobik7QTxfLmxlbmd0aDtBKyspe1M9X1tBXTtfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTW1NdPW5bU119ST1uZXcgaChjLmNvbmZpZyk7cmV0dXJuIF9HTE9CQUxfQ1VTVE9NX09CSkVDVFM9X19hc3NpZ24oe30sYiksSX1mdW5jdGlvbiBudW1iZXJDb21wYXJlKGUsdCl7cmV0dXJuIGU8dD8tMTplPnQ/MTowfWZ1bmN0aW9uIHJldmVyc2VOdW1iZXJDb21wYXJlKGUsdCl7cmV0dXJuLTEqbnVtYmVyQ29tcGFyZShlLHQpfWZ1bmN0aW9uIHVuaXF1ZShlKXtpZihudWxsPT1lKXJldHVybiBlO2Zvcih2YXIgdD1bXSxuPTAscj1lO248ci5sZW5ndGg7bisrKXt2YXIgaT1yW25dOy0xPT09dC5pbmRleE9mKGkpJiZ0LnB1c2goaSl9cmV0dXJuIHR9ZnVuY3Rpb24gaXNPYmplY3RFbXB0eShlKXtpZihudWxsPT1lKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW52YWxpZCB2YWx1ZSBpbiBvYmo6IFwiK0pTT04uc3RyaW5naWZ5KGUpKTtmb3IodmFyIHQgaW4gZSlpZihlLmhhc093blByb3BlcnR5KHQpKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIGNoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWUoZSx0LG4pe2lmKG51bGwhPW4mJmUuaW5kZXhPZihuKTwwKXRocm93IG5ldyBWYWx1ZUVycm9yKG4rXCIgaXMgbm90IGEgdmFsaWQgXCIrdCtcIi4gIFZhbGlkIHZhbHVlcyBhcmUgXCIrZStcIiBvciBudWxsL3VuZGVmaW5lZC5cIil9ZnVuY3Rpb24gY2hlY2tBcnJheVR5cGVBbmRMZW5ndGgoZSx0LG4scil7cmV0dXJuIHZvaWQgMD09PW4mJihuPTApLHZvaWQgMD09PXImJihyPTEvMCksYXNzZXJ0KG4+PTApLGFzc2VydChyPj1uKSxBcnJheS5pc0FycmF5KGUpJiZlLmxlbmd0aD49biYmZS5sZW5ndGg8PXImJmUuZXZlcnkoZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlPT09dH0pfWZ1bmN0aW9uIGFzc2VydFBvc2l0aXZlSW50ZWdlcihlLHQpe0FycmF5LmlzQXJyYXkoZSk/KHV0aWwuYXNzZXJ0KGUubGVuZ3RoPjAsZnVuY3Rpb24oKXtyZXR1cm4gdCtcIiBpcyB1bmV4cGVjdGVkbHkgYW4gZW1wdHkgYXJyYXkuXCJ9KSxlLmZvckVhY2goZnVuY3Rpb24oZSxuKXtyZXR1cm4gYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKGUsXCJlbGVtZW50IFwiKyhuKzEpK1wiIG9mIFwiK3QpfSkpOnV0aWwuYXNzZXJ0KE51bWJlci5pc0ludGVnZXIoZSkmJmU+MCxmdW5jdGlvbigpe3JldHVyblwiRXhwZWN0ZWQgXCIrdCtcIiB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCBnb3QgXCIrZm9ybWF0QXNGcmllbmRseVN0cmluZyhlKStcIi5cIn0pfWZ1bmN0aW9uIGZvcm1hdEFzRnJpZW5kbHlTdHJpbmcoZSl7cmV0dXJuIG51bGw9PT1lP1wibnVsbFwiOkFycmF5LmlzQXJyYXkoZSk/XCJbXCIrZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGZvcm1hdEFzRnJpZW5kbHlTdHJpbmcoZSl9KS5qb2luKFwiLFwiKStcIl1cIjpcInN0cmluZ1wiPT10eXBlb2YgZT8nXCInK2UrJ1wiJzpcIlwiK2V9ZnVuY3Rpb24gZGVib3VuY2UoZSx0KXt2YXIgbixyPXV0aWwubm93KCk7cmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciBpPVtdLGE9MDthPGFyZ3VtZW50cy5sZW5ndGg7YSsrKWlbYV09YXJndW1lbnRzW2FdO3ZhciBvPXV0aWwubm93KCk7cmV0dXJuIG8tcjx0P246KHI9byxuPWUuYXBwbHkodm9pZCAwLGkpKX19ZnVuY3Rpb24gY2FsY0wyTm9ybXMoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBzcXJ0KHN1bShtdWxTdHJpY3QoZSxlKSx0LCEwKSl9KX12YXIgQ29uc3RyYWludD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue319LHR9KHNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlKSxNYXhOb3JtPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLmRlZmF1bHRNYXhWYWx1ZT0yLG4uZGVmYXVsdEF4aXM9MCxuLm1heFZhbHVlPW51bGwhPXQubWF4VmFsdWU/dC5tYXhWYWx1ZTpuLmRlZmF1bHRNYXhWYWx1ZSxuLmF4aXM9bnVsbCE9dC5heGlzP3QuYXhpczpuLmRlZmF1bHRBeGlzLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj1jYWxjTDJOb3JtcyhlLHQuYXhpcykscj1jbGlwQnlWYWx1ZShuLDAsdC5tYXhWYWx1ZSk7cmV0dXJuIG11bChlLGRpdihyLGFkZChlcHNpbG9uKCksbikpKX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bWF4VmFsdWU6dGhpcy5tYXhWYWx1ZSxheGlzOnRoaXMuYXhpc319LHQuY2xhc3NOYW1lPVwiTWF4Tm9ybVwiLHR9KENvbnN0cmFpbnQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhNYXhOb3JtKTt2YXIgVW5pdE5vcm09ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4uZGVmYXVsdEF4aXM9MCxuLmF4aXM9bnVsbCE9dC5heGlzP3QuYXhpczpuLmRlZmF1bHRBeGlzLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gZGl2KGUsYWRkKGVwc2lsb24oKSxjYWxjTDJOb3JtcyhlLHQuYXhpcykpKX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57YXhpczp0aGlzLmF4aXN9fSx0LmNsYXNzTmFtZT1cIlVuaXROb3JtXCIsdH0oQ29uc3RyYWludCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFVuaXROb3JtKTt2YXIgTm9uTmVnPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlKXtyZXR1cm4gcmVsdShlKX0sdC5jbGFzc05hbWU9XCJOb25OZWdcIix0fShDb25zdHJhaW50KTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTm9uTmVnKTt2YXIgTWluTWF4Tm9ybT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5kZWZhdWx0TWluVmFsdWU9MCxuLmRlZmF1bHRNYXhWYWx1ZT0xLG4uZGVmYXVsdFJhdGU9MSxuLmRlZmF1bHRBeGlzPTAsbi5taW5WYWx1ZT1udWxsIT10Lm1pblZhbHVlP3QubWluVmFsdWU6bi5kZWZhdWx0TWluVmFsdWUsbi5tYXhWYWx1ZT1udWxsIT10Lm1heFZhbHVlP3QubWF4VmFsdWU6bi5kZWZhdWx0TWF4VmFsdWUsbi5yYXRlPW51bGwhPXQucmF0ZT90LnJhdGU6bi5kZWZhdWx0UmF0ZSxuLmF4aXM9bnVsbCE9dC5heGlzP3QuYXhpczpuLmRlZmF1bHRBeGlzLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj1jYWxjTDJOb3JtcyhlLHQuYXhpcykscj1hZGQobXVsKHQucmF0ZSxjbGlwQnlWYWx1ZShuLHQubWluVmFsdWUsdC5tYXhWYWx1ZSkpLG11bCgxLXQucmF0ZSxuKSk7cmV0dXJuIG11bChlLGRpdihyLGFkZChlcHNpbG9uKCksbikpKX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bWluVmFsdWU6dGhpcy5taW5WYWx1ZSxtYXhWYWx1ZTp0aGlzLm1heFZhbHVlLHJhdGU6dGhpcy5yYXRlLGF4aXM6dGhpcy5heGlzfX0sdC5jbGFzc05hbWU9XCJNaW5NYXhOb3JtXCIsdH0oQ29uc3RyYWludCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE1pbk1heE5vcm0pO3ZhciBDT05TVFJBSU5UX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUD17bWF4Tm9ybTpcIk1heE5vcm1cIixtaW5NYXhOb3JtOlwiTWluTWF4Tm9ybVwiLG5vbk5lZzpcIk5vbk5lZ1wiLHVuaXROb3JtOlwiVW5pdE5vcm1cIn07ZnVuY3Rpb24gc2VyaWFsaXplQ29uc3RyYWludChlKXtyZXR1cm4gc2VyaWFsaXplS2VyYXNPYmplY3QoZSl9ZnVuY3Rpb24gZGVzZXJpYWxpemVDb25zdHJhaW50KGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PXt9KSxkZXNlcmlhbGl6ZUtlcmFzT2JqZWN0KGUsc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLmdldE1hcCgpLmNsYXNzTmFtZU1hcCx0LFwiY29uc3RyYWludFwiKX1mdW5jdGlvbiBnZXRDb25zdHJhaW50KGUpe3JldHVybiBudWxsPT1lP251bGw6XCJzdHJpbmdcIj09dHlwZW9mIGU/ZGVzZXJpYWxpemVDb25zdHJhaW50KHtjbGFzc05hbWU6ZSBpbiBDT05TVFJBSU5UX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUD9DT05TVFJBSU5UX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUFtlXTplLGNvbmZpZzp7fX0pOmUgaW5zdGFuY2VvZiBDb25zdHJhaW50P2U6ZGVzZXJpYWxpemVDb25zdHJhaW50KGUpfWZ1bmN0aW9uIG1heE5vcm0oZSl7cmV0dXJuIG5ldyBNYXhOb3JtKGUpfWZ1bmN0aW9uIHVuaXROb3JtKGUpe3JldHVybiBuZXcgVW5pdE5vcm0oZSl9ZnVuY3Rpb24gbm9uTmVnKCl7cmV0dXJuIG5ldyBOb25OZWd9ZnVuY3Rpb24gbWluTWF4Tm9ybShlKXtyZXR1cm4gbmV3IE1pbk1heE5vcm0oZSl9dmFyIGV4cG9ydHNfY29uc3RyYWludHM9T2JqZWN0LmZyZWV6ZSh7bWF4Tm9ybTptYXhOb3JtLHVuaXROb3JtOnVuaXROb3JtLG5vbk5lZzpub25OZWcsbWluTWF4Tm9ybTptaW5NYXhOb3JtfSksVkFMSURfREFUQV9GT1JNQVRfVkFMVUVTPVtcImNoYW5uZWxzRmlyc3RcIixcImNoYW5uZWxzTGFzdFwiXSxWQUxJRF9QQURESU5HX01PREVfVkFMVUVTPVtcInZhbGlkXCIsXCJzYW1lXCIsXCJjYXVzYWxcIl0sVkFMSURfUE9PTF9NT0RFX1ZBTFVFUz1bXCJtYXhcIixcImF2Z1wiXSxWQUxJRF9CSURJUkVDVElPTkFMX01FUkdFX01PREVTPVtcInN1bVwiLFwibXVsXCIsXCJjb25jYXRcIixcImF2ZVwiXSxuYW1lTWFwPW5ldyBNYXA7ZnVuY3Rpb24gY2hlY2tEYXRhRm9ybWF0KGUpe2NoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWUoVkFMSURfREFUQV9GT1JNQVRfVkFMVUVTLFwiRGF0YUZvcm1hdFwiLGUpfWZ1bmN0aW9uIGNoZWNrUGFkZGluZ01vZGUoZSl7Y2hlY2tTdHJpbmdUeXBlVW5pb25WYWx1ZShWQUxJRF9QQURESU5HX01PREVfVkFMVUVTLFwiUGFkZGluZ01vZGVcIixlKX1mdW5jdGlvbiBjaGVja1Bvb2xNb2RlKGUpe2NoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWUoVkFMSURfUE9PTF9NT0RFX1ZBTFVFUyxcIlBvb2xNb2RlXCIsZSl9dmFyIF9uYW1lU2NvcGVTdGFjaz1bXSxfbmFtZVNjb3BlRGl2aWRlcj1cIi9cIjtmdW5jdGlvbiBuYW1lU2NvcGUoZSx0KXtfbmFtZVNjb3BlU3RhY2sucHVzaChlKTt0cnl7dmFyIG49dCgpO3JldHVybiBfbmFtZVNjb3BlU3RhY2sucG9wKCksbn1jYXRjaChlKXt0aHJvdyBfbmFtZVNjb3BlU3RhY2sucG9wKCksZX19ZnVuY3Rpb24gY3VycmVudE5hbWVTY29wZVByZWZpeCgpe3JldHVybiAwPT09X25hbWVTY29wZVN0YWNrLmxlbmd0aD9cIlwiOl9uYW1lU2NvcGVTdGFjay5qb2luKF9uYW1lU2NvcGVEaXZpZGVyKStfbmFtZVNjb3BlRGl2aWRlcn1mdW5jdGlvbiBnZXRTY29wZWRUZW5zb3JOYW1lKGUpe2lmKCFpc1ZhbGlkVGVuc29yTmFtZShlKSl0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSB2YWxpZCB0ZW5zb3IgbmFtZTogJ1wiK2UrXCInXCIpO3JldHVybiBjdXJyZW50TmFtZVNjb3BlUHJlZml4KCkrZX1mdW5jdGlvbiBnZXRVbmlxdWVUZW5zb3JOYW1lKGUpe2lmKCFpc1ZhbGlkVGVuc29yTmFtZShlKSl0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSB2YWxpZCB0ZW5zb3IgbmFtZTogJ1wiK2UrXCInXCIpO25hbWVNYXAuaGFzKGUpfHxuYW1lTWFwLnNldChlLDApO3ZhciB0PW5hbWVNYXAuZ2V0KGUpO2lmKG5hbWVNYXAuc2V0KGUsbmFtZU1hcC5nZXQoZSkrMSksdD4wKXt2YXIgbj1lK1wiX1wiK3Q7cmV0dXJuIG5hbWVNYXAuc2V0KG4sMSksbn1yZXR1cm4gZX12YXIgdGVuc29yTmFtZVJlZ2V4PW5ldyBSZWdFeHAoL15bQS1aYS16XVstQS1aYS16MC05XFwuX1xcL10qJC8pO2Z1bmN0aW9uIGlzVmFsaWRUZW5zb3JOYW1lKGUpe3JldHVybiEhZS5tYXRjaCh0ZW5zb3JOYW1lUmVnZXgpfWZ1bmN0aW9uIGlzSW50ZWdlcihlKXtyZXR1cm4gZT09PXBhcnNlSW50KGUudG9TdHJpbmcoKSwxMCl9ZnVuY3Rpb24gYXJyYXlQcm9kKGUsdCxuKXtudWxsPT10JiYodD0wKSxudWxsPT1uJiYobj1lLmxlbmd0aCk7Zm9yKHZhciByPTEsaT10O2k8bjsrK2kpcio9ZVtpXTtyZXR1cm4gcn1mdW5jdGlvbiB0b0FycmF5MUQoZSl7cmV0dXJuIGU9QXJyYXkuaXNBcnJheShlKT9uZXcgRmxvYXQzMkFycmF5KGUpOmUsdGVuc29yMWQoZSl9ZnVuY3Rpb24gbWluJDEoZSl7cmV0dXJuIG1pbih0b0FycmF5MUQoZSkpLmRhdGFTeW5jKClbMF19ZnVuY3Rpb24gbWF4JDEoZSl7cmV0dXJuIG1heCh0b0FycmF5MUQoZSkpLmRhdGFTeW5jKClbMF19ZnVuY3Rpb24gcmFuZ2UoZSx0KXtpZih0PGUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJlbmQgKFwiK3QrXCIpIDwgYmVnaW4gKFwiK2UrXCIpIGlzIGZvcmJpZGRlbi5cIik7Zm9yKHZhciBuPVtdLHI9ZTtyPHQ7KytyKW4ucHVzaChyKTtyZXR1cm4gbn1mdW5jdGlvbiBjYXN0JDEoZSx0KXtyZXR1cm4gZS5hc1R5cGUodCl9ZnVuY3Rpb24gZXhwYW5kRGltcyQxKGUsdCl7dm9pZCAwPT09dCYmKHQ9LTEpO3ZhciBuPWUuc2hhcGUuc2xpY2UoKTtyZXR1cm4gdDwwJiYodD1uLmxlbmd0aCt0KzEpLG4uc3BsaWNlKHQsMCwxKSxlLnJlc2hhcGUobil9ZnVuY3Rpb24gcmVwZWF0KGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtpZigyIT09ZS5zaGFwZS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJyZXBlYXQoKSBleHBlY3RzIGEgcmFuay0yIHRlbnNvciwgYnV0IHJlY2VpdmVkIGEgcmFuay1cIitlLnNoYXBlLmxlbmd0aCtcIiB0ZW5zb3IuXCIpO3JldHVybiB0aWxlJDEoZXhwYW5kRGltcyQxKGUsMSksWzEsdCwxXSl9KX1mdW5jdGlvbiBmbGF0dGVuKGUpe3ZhciB0PVthcnJheVByb2QoZS5zaGFwZSldO3JldHVybiBlLnJlc2hhcGUodCl9ZnVuY3Rpb24gYmF0Y2hGbGF0dGVuKGUpe2lmKGUucmFuazw9MSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImJhdGNoRmxhdHRlbiByZXF1aXJlcyBhIG1pbmltdW0gcmFuayBvZiAyLiBHb3QgcmFuazogXCIrZS5yYW5rK1wiLlwiKTt2YXIgdD1bZS5zaGFwZVswXSxhcnJheVByb2QoZS5zaGFwZSwxKV07cmV0dXJuIGUucmVzaGFwZSh0KX1mdW5jdGlvbiBzbGljZUFsb25nRmlyc3RBeGlzKGUsdCxuKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3N3aXRjaChlLnJhbmspe2Nhc2UgMTpyZXR1cm4gc2xpY2UxZChlLHQsbik7Y2FzZSAyOnJldHVybiBzbGljZTJkKGUsW3QsMF0sW24sZS5zaGFwZVsxXV0pO2Nhc2UgMzpyZXR1cm4gc2xpY2UzZChlLFt0LDAsMF0sW24sZS5zaGFwZVsxXSxlLnNoYXBlWzJdXSk7Y2FzZSA0OnJldHVybiBzbGljZTRkKGUsW3QsMCwwLDBdLFtuLGUuc2hhcGVbMV0sZS5zaGFwZVsyXSxlLnNoYXBlWzNdXSk7ZGVmYXVsdDp0aHJvdyBuZXcgVmFsdWVFcnJvcihcInNsaWNlQWxvbmdGaXJzdEF4aXMoKSByZWNlaXZlZCBhbiB1bnN1cHBvcnRlZCB0ZW5zb3IgcmFuazogXCIrZS5yYW5rKX19KX1mdW5jdGlvbiBzbGljZUFsb25nTGFzdEF4aXMoZSx0LG4pe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7c3dpdGNoKGUucmFuayl7Y2FzZSAxOnJldHVybiBzbGljZTFkKGUsdCxuKTtjYXNlIDI6cmV0dXJuIHNsaWNlMmQoZSxbMCx0XSxbZS5zaGFwZVswXSxuXSk7Y2FzZSAzOnJldHVybiBzbGljZTNkKGUsWzAsMCx0XSxbZS5zaGFwZVswXSxlLnNoYXBlWzFdLG5dKTtjYXNlIDQ6cmV0dXJuIHNsaWNlNGQoZSxbMCwwLDAsdF0sW2Uuc2hhcGVbMF0sZS5zaGFwZVsxXSxlLnNoYXBlWzJdLG5dKTtkZWZhdWx0OnRocm93IG5ldyBWYWx1ZUVycm9yKFwic2xpY2VBbG9uZ0xhc3RBeGlzKCkgcmVjZWl2ZWQgYW4gdW5zdXBwb3J0ZWQgdGVuc29yIHJhbms6IFwiK2UucmFuayl9fSl9ZnVuY3Rpb24gc2xpY2VBbG9uZ0F4aXMoZSx0LG4scil7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtzd2l0Y2goZS5yYW5rKXtjYXNlIDE6cmV0dXJuIHNsaWNlMWQoZSx0LG4pO2Nhc2UgMjpzd2l0Y2gocil7Y2FzZSAxOnJldHVybiBzbGljZUFsb25nRmlyc3RBeGlzKGUsdCxuKTtjYXNlIDI6cmV0dXJuIHNsaWNlQWxvbmdMYXN0QXhpcyhlLHQsbik7ZGVmYXVsdDp0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBheGlzIGlzIG5vdCB3aXRoaW4gdGhlIHJhbmsgb2YgdGhlIHRlbnNvciBcIityKX1jYXNlIDM6c3dpdGNoKHIpe2Nhc2UgMTpyZXR1cm4gc2xpY2VBbG9uZ0ZpcnN0QXhpcyhlLHQsbik7Y2FzZSAyOnJldHVybiBzbGljZTNkKGUsWzAsdCwwXSxbZS5zaGFwZVswXSxuLGUuc2hhcGVbMl1dKTtjYXNlIDM6cmV0dXJuIHNsaWNlQWxvbmdMYXN0QXhpcyhlLHQsbik7ZGVmYXVsdDp0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBheGlzIGlzIG5vdCB3aXRoaW4gdGhlIHJhbmsgb2YgdGhlIHRlbnNvciBcIityKX1jYXNlIDQ6c3dpdGNoKHIpe2Nhc2UgMTpyZXR1cm4gc2xpY2VBbG9uZ0ZpcnN0QXhpcyhlLHQsbik7Y2FzZSAyOnJldHVybiBzbGljZTRkKGUsWzAsdCwwLDBdLFtlLnNoYXBlWzBdLG4sZS5zaGFwZVsyXSxlLnNoYXBlWzNdXSk7Y2FzZSAzOnJldHVybiBzbGljZTRkKGUsWzAsMCx0LDBdLFtlLnNoYXBlWzBdLGUuc2hhcGVbMV0sbixlLnNoYXBlWzNdXSk7Y2FzZSA0OnJldHVybiBzbGljZUFsb25nTGFzdEF4aXMoZSx0LG4pO2RlZmF1bHQ6dGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgYXhpcyBpcyBub3Qgd2l0aGluIHRoZSByYW5rIG9mIHRoZSB0ZW5zb3IgXCIrcil9ZGVmYXVsdDp0aHJvdyBuZXcgVmFsdWVFcnJvcihcInNsaWNlQWxvbmdMYXN0QXhpcygpIHJlY2VpdmVkIGFuIHVuc3VwcG9ydGVkIHRlbnNvciByYW5rOiBcIitlLnJhbmspfX0pfWZ1bmN0aW9uIGNvbmNhdGVuYXRlKGUsdCl7dmFyIG47cmV0dXJuIHZvaWQgMD09PXQmJih0PS0xKSx0PDAmJih0PTAhPT0obj1lWzBdLnJhbmspP246MCksdD09PWVbMF0ucmFuayYmKHQ9LTEpLGNvbmNhdChlLHQpfWZ1bmN0aW9uIGNvbmNhdEFsb25nRmlyc3RBeGlzKGUsdCl7c3dpdGNoKGUucmFuayl7Y2FzZSAxOnJldHVybiBjb25jYXQxZChbZSx0XSk7Y2FzZSAyOnJldHVybiBjb25jYXQyZChbZSx0XSwwKTtjYXNlIDM6cmV0dXJuIGNvbmNhdDNkKFtlLHRdLDApO2Nhc2UgNDpyZXR1cm4gY29uY2F0NGQoW2UsdF0sMCk7ZGVmYXVsdDp0aHJvdyBuZXcgVmFsdWVFcnJvcihcImNvbmNhdEFsb25nRmlyc3RBeGlzKCkgcmVjZWl2ZWQgYW4gdW5zdXBwb3J0ZWQgdGVuc29yIHJhbms6IFwiK2UucmFuayl9fWZ1bmN0aW9uIHRpbGUkMShlLHQpe2lmKEFycmF5LmlzQXJyYXkodCl8fCh0PVt0XSksZS5yYW5rIT09dC5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgbGVuZ3RoIG9mIGlucHV0IG4gKFwiK3QubGVuZ3RoK1wiKSBkb2VzIG5vdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGRpbWVuc2lvbnMgaW4gaW5wdXQgeCAoXCIrZS5yYW5rK1wiKVwiKTtyZXR1cm4gdGlsZShlLHQpfWZ1bmN0aW9uIHJhbmRvbU5vcm1hbCQxKGUsdCxuLHIsaSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLHZvaWQgMD09PW4mJihuPTEpLHJhbmRvbU5vcm1hbChlLHQsbixyLGkpfWZ1bmN0aW9uIGRvdChlLHQsbixyKXtpZihlLnJhbms8Mnx8dC5yYW5rPDIpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJkb3QgcmVxdWlyZXMgYm90aCBpbnB1dHMgdG8gYmUgcmFuayA+PSAyIGJ1dCBnb3QgeCBzaGFwZSA9IFwiK2Uuc2hhcGUrXCIgYW5kIHkgc2hhcGUgPSBcIit0LnNoYXBlKTtpZih0LnJhbms+PTMmJihzPWUuc2hhcGUuc2xpY2UoLTEpWzBdKSE9PShjPXQuc2hhcGUuc2xpY2UoLTIpWzBdKSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIklmIHJhbmsgeSA+PSAzLCB0aGVuIHRoZSBzZWNvbmQgbGFzdCBkaW0gb2YgeSBtdXN0IGVxdWFsIHRoZSBsYXN0IGRpbSBvZiB4IGJ1dCBnb3QgeCBzaGFwZSA9IFwiK2Uuc2hhcGUrXCIgYW5kICB5IHNoYXBlID0gXCIrdC5zaGFwZSk7aWYoMj09PWUucmFuayYmMj09PXQucmFuayl7dmFyIGk9ITEsYT0hMTtyZXR1cm4gZnVzZWQubWF0TXVsKGUsdCxpLGEscj9yZXNoYXBlQmlhcyhlLnJhbmsscixpbWFnZURhdGFGb3JtYXQoKSk6bnVsbCxuKX12YXIgbz1lLnNoYXBlLnNsaWNlKCkscz1vLnBvcCgpO2U9ZS5yZXNoYXBlKFstMSxzXSk7dmFyIGw9dC5zaGFwZS5zbGljZSgpLHU9bC5wb3AoKSxjPWwucG9wKCkscD1sLmNvbmNhdChbdV0pLGg9QXJyYXkuZnJvbSh7bGVuZ3RoOnQucmFua30sZnVuY3Rpb24oZSxuKXtyZXR1cm4gMD09PW4/dC5yYW5rLTI6bjw9dC5yYW5rLTI/bi0xOm59KTt0PXQudHJhbnNwb3NlKGgpLnJlc2hhcGUoW2MsLTFdKTt2YXIgZD1vLmNvbmNhdChwKTtpPSExLGE9ITE7cmV0dXJuIGZ1c2VkLm1hdE11bChlLHQsaSxhLHI/cmVzaGFwZUJpYXMoZS5yYW5rLHIsaW1hZ2VEYXRhRm9ybWF0KCkpOm51bGwsbikucmVzaGFwZShkKX1mdW5jdGlvbiBnYXRoZXIkMShlLHQsbil7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gdD1BcnJheS5pc0FycmF5KHQpP3RlbnNvcjFkKHQsXCJpbnQzMlwiKTp0LnRvSW50KCksZ2F0aGVyKGUsdCxuKX0pfWZ1bmN0aW9uIHNxdWFyZShlKXtyZXR1cm4gbXVsU3RyaWN0KGUsZSl9ZnVuY3Rpb24gcmVzaGFwZUJpYXMoZSx0LG4pe3ZhciByPXQuc2hhcGU7aWYoMSE9PXQucmFuayYmdC5yYW5rIT09ZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlVuZXhwZWN0ZWQgYmlhcyBkaW1lbnNpb25zOiBcIit0LnJhbmsrXCI7IGV4cGVjdGVkIGl0IHRvIGJlIDEgb3IgXCIrZSk7aWYoNT09PWUpe2lmKFwiY2hhbm5lbHNGaXJzdFwiPT09bilyZXR1cm4gMT09PXIubGVuZ3RoP3QucmVzaGFwZShbMSxyWzBdLDEsMSwxXSk6dC5yZXNoYXBlKFsxLHJbM10sclswXSxyWzFdLHJbMl1dKTtpZihcImNoYW5uZWxzTGFzdFwiPT09bilyZXR1cm4gMT09PXIubGVuZ3RoP3QucmVzaGFwZShbMSwxLDEsMSxyWzBdXSk6dC5yZXNoYXBlKFsxXS5jb25jYXQocikpfWVsc2UgaWYoND09PWUpe2lmKFwiY2hhbm5lbHNGaXJzdFwiPT09bilyZXR1cm4gMT09PXIubGVuZ3RoP3QucmVzaGFwZShbMSxyWzBdLDEsMV0pOnQucmVzaGFwZShbMSxyWzJdLHJbMF0sclsxXV0pO2lmKFwiY2hhbm5lbHNMYXN0XCI9PT1uKXJldHVybiAxPT09ci5sZW5ndGg/dC5yZXNoYXBlKFsxLDEsMSxyWzBdXSk6dC5yZXNoYXBlKFsxXS5jb25jYXQocikpfWVsc2UgaWYoMz09PWUpe2lmKFwiY2hhbm5lbHNGaXJzdFwiPT09bilyZXR1cm4gMT09PXIubGVuZ3RoP3QucmVzaGFwZShbMSxyWzBdLDFdKTp0LnJlc2hhcGUoWzEsclsxXSxyWzBdXSk7aWYoXCJjaGFubmVsc0xhc3RcIj09PW4pcmV0dXJuIDE9PT1yLmxlbmd0aD90LnJlc2hhcGUoWzEsMSxyWzBdXSk6dC5yZXNoYXBlKFsxXS5jb25jYXQocikpfWVsc2UgaWYoZTwzKXJldHVybiB0O3Rocm93IG5ldyBWYWx1ZUVycm9yKFwiVW5zdXBwb3J0ZWQgaW5wdXQgcmFuayBieSBiaWFzQWRkOiBcIit0LnJhbmspfWZ1bmN0aW9uIGJpYXNBZGQoZSx0LG4pe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PW4mJihuPWltYWdlRGF0YUZvcm1hdCgpKSxjaGVja0RhdGFGb3JtYXQobiksZS5hZGQocmVzaGFwZUJpYXMoZS5yYW5rLHQsbikpfSl9ZnVuY3Rpb24gZWx1JDEoZSx0KXtpZih2b2lkIDA9PT10JiYodD0xKSwxIT09dCl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlN1cHBvcnQgZm9yIGFscGhhIHZhbHVlcyBvdGhlciB0aGFuIDEgKFwiK3QrXCIpIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO3JldHVybiBlbHUoZSl9ZnVuY3Rpb24gc29mdHNpZ24oZSl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gZGl2KGUsYWJzKGUpLmFkZCgxKSl9KX1mdW5jdGlvbiBkcm9wb3V0KGUsdCxuLHIpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7aWYobnVsbCE9biYmIXV0aWwuYXJyYXlzRXF1YWwoZS5zaGFwZSxuKSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIk5vbi1kZWZhdWx0IG5vaXNlIHNoYXBlIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQ6IFwiK0pTT04uc3RyaW5naWZ5KG4pKTtpZihudWxsIT1yKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwic2VlZCBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIGRyb3BvdXQgeWV0LlwiKTt2YXIgaT1zdGVwKGFkZCgtdCxyYW5kb21Vbmlmb3JtKGUuc2hhcGUsMCwxLFwiZmxvYXQzMlwiKSkpO3JldHVybiBpPW11bCgxLygxLXQpLGkpLG11bChlLGkpfSl9ZnVuY3Rpb24gaGFyZFNpZ21vaWQoZSl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgdD1hZGQoLjUsbXVsKC4yLGUpKTtyZXR1cm4gY2xpcEJ5VmFsdWUodCwwLDEpfSl9ZnVuY3Rpb24gaW5UcmFpblBoYXNlKGUsdCxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49ITEpLG4/ZSgpOnQoKX12YXIgVkFMSURfRkFOX01PREVfVkFMVUVTPVtcImZhbkluXCIsXCJmYW5PdXRcIixcImZhbkF2Z1wiXSxWQUxJRF9ESVNUUklCVVRJT05fVkFMVUVTPVtcIm5vcm1hbFwiLFwidW5pZm9ybVwiLFwidHJ1bmNhdGVkTm9ybWFsXCJdO2Z1bmN0aW9uIGNoZWNrRmFuTW9kZShlKXtjaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKFZBTElEX0ZBTl9NT0RFX1ZBTFVFUyxcIkZhbk1vZGVcIixlKX1mdW5jdGlvbiBjaGVja0Rpc3RyaWJ1dGlvbihlKXtjaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKFZBTElEX0RJU1RSSUJVVElPTl9WQUxVRVMsXCJEaXN0cmlidXRpb25cIixlKX12YXIgSW5pdGlhbGl6ZXI9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmZyb21Db25maWdVc2VzQ3VzdG9tT2JqZWN0cz1mdW5jdGlvbigpe3JldHVybiExfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57fX0sdH0oc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGUpLFplcm9zPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLHQpe3JldHVybiB6ZXJvcyhlLHQpfSx0LmNsYXNzTmFtZT1cIlplcm9zXCIsdH0oSW5pdGlhbGl6ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhaZXJvcyk7dmFyIE9uZXM9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG9uZXMoZSx0KX0sdC5jbGFzc05hbWU9XCJPbmVzXCIsdH0oSW5pdGlhbGl6ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhPbmVzKTt2YXIgQ29uc3RhbnQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyl8fHRoaXM7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJFeHBlY3RlZCBhcmd1bWVudCBvZiB0eXBlIENvbnN0YW50Q29uZmlnIGJ1dCBnb3QgXCIrdCk7aWYodm9pZCAwPT09dC52YWx1ZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImNvbmZpZyBtdXN0IGhhdmUgdmFsdWUgc2V0IGJ1dCBnb3QgXCIrdCk7cmV0dXJuIG4udmFsdWU9dC52YWx1ZSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gbXVsKHNjYWxhcihuLnZhbHVlKSxvbmVzKGUsdCkpfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybnt2YWx1ZTp0aGlzLnZhbHVlfX0sdC5jbGFzc05hbWU9XCJDb25zdGFudFwiLHR9KEluaXRpYWxpemVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQ29uc3RhbnQpO3ZhciBSYW5kb21Vbmlmb3JtPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLkRFRkFVTFRfTUlOVkFMPS0uMDUsbi5ERUZBVUxUX01BWFZBTD0uMDUsbi5taW52YWw9dC5taW52YWx8fG4uREVGQVVMVF9NSU5WQUwsbi5tYXh2YWw9dC5tYXh2YWx8fG4uREVGQVVMVF9NQVhWQUwsbi5zZWVkPXQuc2VlZCxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLHQpe3JldHVybiByYW5kb21Vbmlmb3JtKGUsdGhpcy5taW52YWwsdGhpcy5tYXh2YWwsdCl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybnttaW52YWw6dGhpcy5taW52YWwsbWF4dmFsOnRoaXMubWF4dmFsLHNlZWQ6dGhpcy5zZWVkfX0sdC5jbGFzc05hbWU9XCJSYW5kb21Vbmlmb3JtXCIsdH0oSW5pdGlhbGl6ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhSYW5kb21Vbmlmb3JtKTt2YXIgUmFuZG9tTm9ybWFsPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLkRFRkFVTFRfTUVBTj0wLG4uREVGQVVMVF9TVERERVY9LjA1LG4ubWVhbj10Lm1lYW58fG4uREVGQVVMVF9NRUFOLG4uc3RkZGV2PXQuc3RkZGV2fHxuLkRFRkFVTFRfU1REREVWLG4uc2VlZD10LnNlZWQsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0KXtpZihcImZsb2F0MzJcIiE9PSh0PXR8fFwiZmxvYXQzMlwiKSYmXCJpbnQzMlwiIT09dCl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcInJhbmRvbU5vcm1hbCBkb2VzIG5vdCBzdXBwb3J0IGRUeXBlIFwiK3QrXCIuXCIpO3JldHVybiByYW5kb21Ob3JtYWwkMShlLHRoaXMubWVhbix0aGlzLnN0ZGRldix0LHRoaXMuc2VlZCl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybnttZWFuOnRoaXMubWVhbixzdGRkZXY6dGhpcy5zdGRkZXYsc2VlZDp0aGlzLnNlZWR9fSx0LmNsYXNzTmFtZT1cIlJhbmRvbU5vcm1hbFwiLHR9KEluaXRpYWxpemVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoUmFuZG9tTm9ybWFsKTt2YXIgVHJ1bmNhdGVkTm9ybWFsPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLkRFRkFVTFRfTUVBTj0wLG4uREVGQVVMVF9TVERERVY9LjA1LG4ubWVhbj10Lm1lYW58fG4uREVGQVVMVF9NRUFOLG4uc3RkZGV2PXQuc3RkZGV2fHxuLkRFRkFVTFRfU1REREVWLG4uc2VlZD10LnNlZWQsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0KXtpZihcImZsb2F0MzJcIiE9PSh0PXR8fFwiZmxvYXQzMlwiKSYmXCJpbnQzMlwiIT09dCl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcInRydW5jYXRlZE5vcm1hbCBkb2VzIG5vdCBzdXBwb3J0IGRUeXBlIFwiK3QrXCIuXCIpO3JldHVybiB0cnVuY2F0ZWROb3JtYWwoZSx0aGlzLm1lYW4sdGhpcy5zdGRkZXYsdCx0aGlzLnNlZWQpfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bWVhbjp0aGlzLm1lYW4sc3RkZGV2OnRoaXMuc3RkZGV2LHNlZWQ6dGhpcy5zZWVkfX0sdC5jbGFzc05hbWU9XCJUcnVuY2F0ZWROb3JtYWxcIix0fShJbml0aWFsaXplcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFRydW5jYXRlZE5vcm1hbCk7dmFyIElkZW50aXR5PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLmdhaW49bnVsbCE9dC5nYWluP3QuZ2FpbjoxLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe2lmKDIhPT1lLmxlbmd0aHx8ZVswXSE9PWVbMV0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJZGVudGl0eSBtYXRyaXggaW5pdGlhbGl6ZXIgY2FuIG9ubHkgYmUgdXNlZCBmb3IgMkQgc3F1YXJlIG1hdHJpY2VzLlwiKTtyZXR1cm4gbXVsKG4uZ2FpbixleWUoZVswXSkpfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntnYWluOnRoaXMuZ2Fpbn19LHQuY2xhc3NOYW1lPVwiSWRlbnRpdHlcIix0fShJbml0aWFsaXplcik7ZnVuY3Rpb24gY29tcHV0ZUZhbnMoZSx0KXt2YXIgbixyO2lmKHZvaWQgMD09PXQmJih0PVwiY2hhbm5lbHNMYXN0XCIpLGNoZWNrRGF0YUZvcm1hdCh0KSwyPT09ZS5sZW5ndGgpbj1lWzBdLHI9ZVsxXTtlbHNlIGlmKC0xIT09WzMsNCw1XS5pbmRleE9mKGUubGVuZ3RoKSl7aWYoXCJjaGFubmVsc0ZpcnN0XCI9PT10KXt2YXIgaT1hcnJheVByb2QoZSwyKTtuPWVbMV0qaSxyPWVbMF0qaX1lbHNlIGlmKFwiY2hhbm5lbHNMYXN0XCI9PT10KXtpPWFycmF5UHJvZChlLDAsZS5sZW5ndGgtMik7bj1lW2UubGVuZ3RoLTJdKmkscj1lW2UubGVuZ3RoLTFdKml9fWVsc2V7dmFyIGE9YXJyYXlQcm9kKGUpO249TWF0aC5zcXJ0KGEpLHI9TWF0aC5zcXJ0KGEpfXJldHVybltuLHJdfXNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhJZGVudGl0eSk7dmFyIFZhcmlhbmNlU2NhbGluZz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzKXx8dGhpcztpZih0LnNjYWxlPDApdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJzY2FsZSBtdXN0IGJlIGEgcG9zaXRpdmUgZmxvYXQuIEdvdDogXCIrdC5zY2FsZSk7cmV0dXJuIG4uc2NhbGU9bnVsbD09dC5zY2FsZT8xOnQuc2NhbGUsbi5tb2RlPW51bGw9PXQubW9kZT9cImZhbkluXCI6dC5tb2RlLGNoZWNrRmFuTW9kZShuLm1vZGUpLG4uZGlzdHJpYnV0aW9uPW51bGw9PXQuZGlzdHJpYnV0aW9uP1wibm9ybWFsXCI6dC5kaXN0cmlidXRpb24sY2hlY2tEaXN0cmlidXRpb24obi5kaXN0cmlidXRpb24pLG4uc2VlZD10LnNlZWQsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSx0KXt2YXIgbj1jb21wdXRlRmFucyhlKSxyPW5bMF0saT1uWzFdLGE9dGhpcy5zY2FsZTtpZihcImZhbkluXCI9PT10aGlzLm1vZGU/YS89TWF0aC5tYXgoMSxyKTpcImZhbk91dFwiPT09dGhpcy5tb2RlP2EvPU1hdGgubWF4KDEsaSk6YS89TWF0aC5tYXgoMSwocitpKS8yKSxcIm5vcm1hbFwiPT09dGhpcy5kaXN0cmlidXRpb24pe3ZhciBvPU1hdGguc3FydChhKTtpZihcImZsb2F0MzJcIiE9PSh0PXR8fFwiZmxvYXQzMlwiKSYmXCJpbnQzMlwiIT09dCl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcih0aGlzLmdldENsYXNzTmFtZSgpK1wiIGRvZXMgbm90IHN1cHBvcnQgZFR5cGUgXCIrdCtcIi5cIik7cmV0dXJuIHRydW5jYXRlZE5vcm1hbChlLDAsbyx0LHRoaXMuc2VlZCl9dmFyIHM9TWF0aC5zcXJ0KDMqYSk7cmV0dXJuIHJhbmRvbVVuaWZvcm0oZSwtcyxzLHQpfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57c2NhbGU6dGhpcy5zY2FsZSxtb2RlOnRoaXMubW9kZSxkaXN0cmlidXRpb246dGhpcy5kaXN0cmlidXRpb24sc2VlZDp0aGlzLnNlZWR9fSx0LmNsYXNzTmFtZT1cIlZhcmlhbmNlU2NhbGluZ1wiLHR9KEluaXRpYWxpemVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoVmFyaWFuY2VTY2FsaW5nKTt2YXIgR2xvcm90VW5pZm9ybT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcyx7c2NhbGU6MSxtb2RlOlwiZmFuQXZnXCIsZGlzdHJpYnV0aW9uOlwidW5pZm9ybVwiLHNlZWQ6bnVsbD09dD9udWxsOnQuc2VlZH0pfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5nZXRDbGFzc05hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gVmFyaWFuY2VTY2FsaW5nLmNsYXNzTmFtZX0sdC5jbGFzc05hbWU9XCJHbG9yb3RVbmlmb3JtXCIsdH0oVmFyaWFuY2VTY2FsaW5nKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR2xvcm90VW5pZm9ybSk7dmFyIEdsb3JvdE5vcm1hbD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcyx7c2NhbGU6MSxtb2RlOlwiZmFuQXZnXCIsZGlzdHJpYnV0aW9uOlwibm9ybWFsXCIsc2VlZDpudWxsPT10P251bGw6dC5zZWVkfSl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmdldENsYXNzTmFtZT1mdW5jdGlvbigpe3JldHVybiBWYXJpYW5jZVNjYWxpbmcuY2xhc3NOYW1lfSx0LmNsYXNzTmFtZT1cIkdsb3JvdE5vcm1hbFwiLHR9KFZhcmlhbmNlU2NhbGluZyk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEdsb3JvdE5vcm1hbCk7dmFyIEhlTm9ybWFsPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLHtzY2FsZToyLG1vZGU6XCJmYW5JblwiLGRpc3RyaWJ1dGlvbjpcIm5vcm1hbFwiLHNlZWQ6bnVsbD09dD9udWxsOnQuc2VlZH0pfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5nZXRDbGFzc05hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gVmFyaWFuY2VTY2FsaW5nLmNsYXNzTmFtZX0sdC5jbGFzc05hbWU9XCJIZU5vcm1hbFwiLHR9KFZhcmlhbmNlU2NhbGluZyk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEhlTm9ybWFsKTt2YXIgSGVVbmlmb3JtPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLHtzY2FsZToyLG1vZGU6XCJmYW5JblwiLGRpc3RyaWJ1dGlvbjpcInVuaWZvcm1cIixzZWVkOm51bGw9PXQ/bnVsbDp0LnNlZWR9KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIFZhcmlhbmNlU2NhbGluZy5jbGFzc05hbWV9LHQuY2xhc3NOYW1lPVwiSGVVbmlmb3JtXCIsdH0oVmFyaWFuY2VTY2FsaW5nKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoSGVVbmlmb3JtKTt2YXIgTGVDdW5Ob3JtYWw9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMse3NjYWxlOjEsbW9kZTpcImZhbkluXCIsZGlzdHJpYnV0aW9uOlwibm9ybWFsXCIsc2VlZDpudWxsPT10P251bGw6dC5zZWVkfSl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmdldENsYXNzTmFtZT1mdW5jdGlvbigpe3JldHVybiBWYXJpYW5jZVNjYWxpbmcuY2xhc3NOYW1lfSx0LmNsYXNzTmFtZT1cIkxlQ3VuTm9ybWFsXCIsdH0oVmFyaWFuY2VTY2FsaW5nKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTGVDdW5Ob3JtYWwpO3ZhciBMZUN1blVuaWZvcm09ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMse3NjYWxlOjEsbW9kZTpcImZhbkluXCIsZGlzdHJpYnV0aW9uOlwidW5pZm9ybVwiLHNlZWQ6bnVsbD09dD9udWxsOnQuc2VlZH0pfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5nZXRDbGFzc05hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gVmFyaWFuY2VTY2FsaW5nLmNsYXNzTmFtZX0sdC5jbGFzc05hbWU9XCJMZUN1bk5vcm1hbFwiLHR9KFZhcmlhbmNlU2NhbGluZyk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKExlQ3VuVW5pZm9ybSk7dmFyIE9ydGhvZ29uYWw9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyl8fHRoaXM7aWYobi5ERUZBVUxUX0dBSU49MSxuLmdhaW49bnVsbD09dC5nYWluP24uREVGQVVMVF9HQUlOOnQuZ2FpbixuLnNlZWQ9dC5zZWVkLG51bGwhPW4uc2VlZCl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlJhbmRvbSBzZWVkIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgT3J0aG9nb25hbCBJbml0aWFsaXplciB5ZXQuXCIpO3JldHVybiBufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtpZigyIT09ZS5sZW5ndGgpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJUaGUgT3J0aG9nb25hbCBJbml0aWFsaXplciBkb2VzIG5vdCBzdXBwb3J0IG5vbi0yRCBzaGFwZXMgeWV0LlwiKTtlWzBdKmVbMV0+MmUzJiZjb25zb2xlLndhcm4oXCJPcnRob2dvbmFsIGluaXRpYWxpemVyIGlzIGJlaW5nIGNhbGxlZCBvbiBhIG1hdHJpeCB3aXRoIG1vcmUgdGhhbiAyMDAwIChcIitlWzBdKmVbMV0rXCIpIGVsZW1lbnRzOiBTbG93bmVzcyBtYXkgcmVzdWx0LlwiKTt2YXIgdD1yYW5kb21Ob3JtYWwkMShlWzBdPmVbMV0/W2VbMV0sZVswXV06ZSwwLDEsXCJmbG9hdDMyXCIpLHI9bGluYWxnLmdyYW1TY2htaWR0KHQpO3JldHVybiBlWzBdPmVbMV0mJihyPXIudHJhbnNwb3NlKCkpLG11bChuLmdhaW4scil9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2dhaW46dGhpcy5nYWluLHNlZWQ6dGhpcy5zZWVkfX0sdC5jbGFzc05hbWU9XCJPcnRob2dvbmFsXCIsdH0oSW5pdGlhbGl6ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhPcnRob2dvbmFsKTt2YXIgSU5JVElBTElaRVJfSURFTlRJRklFUl9SRUdJU1RSWV9TWU1CT0xfTUFQPXtjb25zdGFudDpcIkNvbnN0YW50XCIsZ2xvcm90Tm9ybWFsOlwiR2xvcm90Tm9ybWFsXCIsZ2xvcm90VW5pZm9ybTpcIkdsb3JvdFVuaWZvcm1cIixoZU5vcm1hbDpcIkhlTm9ybWFsXCIsaGVVbmlmb3JtOlwiSGVVbmlmb3JtXCIsaWRlbnRpdHk6XCJJZGVudGl0eVwiLGxlQ3VuTm9ybWFsOlwiTGVDdW5Ob3JtYWxcIixsZUN1blVuaWZvcm06XCJMZUN1blVuaWZvcm1cIixvbmVzOlwiT25lc1wiLG9ydGhvZ29uYWw6XCJPcnRob2dvbmFsXCIscmFuZG9tTm9ybWFsOlwiUmFuZG9tTm9ybWFsXCIscmFuZG9tVW5pZm9ybTpcIlJhbmRvbVVuaWZvcm1cIix0cnVuY2F0ZWROb3JtYWw6XCJUcnVuY2F0ZWROb3JtYWxcIix2YXJpYW5jZVNjYWxpbmc6XCJWYXJpYW5jZVNjYWxpbmdcIix6ZXJvczpcIlplcm9zXCJ9O2Z1bmN0aW9uIGRlc2VyaWFsaXplSW5pdGlhbGl6ZXIoZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9e30pLGRlc2VyaWFsaXplS2VyYXNPYmplY3QoZSxzZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAuZ2V0TWFwKCkuY2xhc3NOYW1lTWFwLHQsXCJpbml0aWFsaXplclwiKX1mdW5jdGlvbiBzZXJpYWxpemVJbml0aWFsaXplcihlKXtyZXR1cm4gc2VyaWFsaXplS2VyYXNPYmplY3QoZSl9ZnVuY3Rpb24gZ2V0SW5pdGlhbGl6ZXIoZSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe3ZhciB0PWUgaW4gSU5JVElBTElaRVJfSURFTlRJRklFUl9SRUdJU1RSWV9TWU1CT0xfTUFQP0lOSVRJQUxJWkVSX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUFtlXTplO2lmKFwiR2xvcm90Tm9ybWFsXCI9PT10KXJldHVybiBuZXcgR2xvcm90Tm9ybWFsO2lmKFwiR2xvcm90VW5pZm9ybVwiPT09dClyZXR1cm4gbmV3IEdsb3JvdFVuaWZvcm07aWYoXCJIZU5vcm1hbFwiPT09dClyZXR1cm4gbmV3IEhlTm9ybWFsO2lmKFwiSGVVbmlmb3JtXCI9PT10KXJldHVybiBuZXcgSGVVbmlmb3JtO2lmKFwiTGVDdW5Ob3JtYWxcIj09PXQpcmV0dXJuIG5ldyBMZUN1bk5vcm1hbDtpZihcIkxlQ3VuVW5pZm9ybVwiPT09dClyZXR1cm4gbmV3IExlQ3VuVW5pZm9ybTt2YXIgbj17fTtyZXR1cm4gbi5jbGFzc05hbWU9dCxuLmNvbmZpZz17fSxkZXNlcmlhbGl6ZUluaXRpYWxpemVyKG4pfXJldHVybiBlIGluc3RhbmNlb2YgSW5pdGlhbGl6ZXI/ZTpkZXNlcmlhbGl6ZUluaXRpYWxpemVyKGUpfWZ1bmN0aW9uIHplcm9zJDEoKXtyZXR1cm4gbmV3IFplcm9zfWZ1bmN0aW9uIG9uZXMkMSgpe3JldHVybiBuZXcgT25lc31mdW5jdGlvbiBjb25zdGFudChlKXtyZXR1cm4gbmV3IENvbnN0YW50KGUpfWZ1bmN0aW9uIHJhbmRvbVVuaWZvcm0kMShlKXtyZXR1cm4gbmV3IFJhbmRvbVVuaWZvcm0oZSl9ZnVuY3Rpb24gcmFuZG9tTm9ybWFsJDIoZSl7cmV0dXJuIG5ldyBSYW5kb21Ob3JtYWwoZSl9ZnVuY3Rpb24gdHJ1bmNhdGVkTm9ybWFsJDEoZSl7cmV0dXJuIG5ldyBUcnVuY2F0ZWROb3JtYWwoZSl9ZnVuY3Rpb24gaWRlbnRpdHkoZSl7cmV0dXJuIG5ldyBJZGVudGl0eShlKX1mdW5jdGlvbiB2YXJpYW5jZVNjYWxpbmcoZSl7cmV0dXJuIG5ldyBWYXJpYW5jZVNjYWxpbmcoZSl9ZnVuY3Rpb24gZ2xvcm90VW5pZm9ybShlKXtyZXR1cm4gbmV3IEdsb3JvdFVuaWZvcm0oZSl9ZnVuY3Rpb24gZ2xvcm90Tm9ybWFsKGUpe3JldHVybiBuZXcgR2xvcm90Tm9ybWFsKGUpfWZ1bmN0aW9uIGhlTm9ybWFsKGUpe3JldHVybiBuZXcgSGVOb3JtYWwoZSl9ZnVuY3Rpb24gaGVVbmlmb3JtKGUpe3JldHVybiBuZXcgSGVVbmlmb3JtKGUpfWZ1bmN0aW9uIGxlQ3VuTm9ybWFsKGUpe3JldHVybiBuZXcgTGVDdW5Ob3JtYWwoZSl9ZnVuY3Rpb24gbGVDdW5Vbmlmb3JtKGUpe3JldHVybiBuZXcgTGVDdW5Vbmlmb3JtKGUpfWZ1bmN0aW9uIG9ydGhvZ29uYWwoZSl7cmV0dXJuIG5ldyBPcnRob2dvbmFsKGUpfXZhciBleHBvcnRzX2luaXRpYWxpemVycz1PYmplY3QuZnJlZXplKHt6ZXJvczp6ZXJvcyQxLG9uZXM6b25lcyQxLGNvbnN0YW50OmNvbnN0YW50LHJhbmRvbVVuaWZvcm06cmFuZG9tVW5pZm9ybSQxLHJhbmRvbU5vcm1hbDpyYW5kb21Ob3JtYWwkMix0cnVuY2F0ZWROb3JtYWw6dHJ1bmNhdGVkTm9ybWFsJDEsaWRlbnRpdHk6aWRlbnRpdHksdmFyaWFuY2VTY2FsaW5nOnZhcmlhbmNlU2NhbGluZyxnbG9yb3RVbmlmb3JtOmdsb3JvdFVuaWZvcm0sZ2xvcm90Tm9ybWFsOmdsb3JvdE5vcm1hbCxoZU5vcm1hbDpoZU5vcm1hbCxoZVVuaWZvcm06aGVVbmlmb3JtLGxlQ3VuTm9ybWFsOmxlQ3VuTm9ybWFsLGxlQ3VuVW5pZm9ybTpsZUN1blVuaWZvcm0sb3J0aG9nb25hbDpvcnRob2dvbmFsfSksX25leHRVbmlxdWVUZW5zb3JJZD0wO2Z1bmN0aW9uIGdldE5leHRVbmlxdWVUZW5zb3JJZCgpe3JldHVybiBfbmV4dFVuaXF1ZVRlbnNvcklkKyt9dmFyIF91aWRQcmVmaXhlcz17fTtmdW5jdGlvbiBnZXRVaWQoZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPVwiXCIpLGUgaW4gX3VpZFByZWZpeGVzfHwoX3VpZFByZWZpeGVzW2VdPTApLF91aWRQcmVmaXhlc1tlXSs9MSxlK191aWRQcmVmaXhlc1tlXS50b1N0cmluZygpfWZ1bmN0aW9uIGlzQXJyYXlPZlNoYXBlcyhlKXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKSYmQXJyYXkuaXNBcnJheShlWzBdKX1mdW5jdGlvbiBub3JtYWxpemVTaGFwZUxpc3QoZSl7cmV0dXJuIDA9PT1lLmxlbmd0aD9bXTpBcnJheS5pc0FycmF5KGVbMF0pP2U6W2VdfWZ1bmN0aW9uIGdldEV4YWN0bHlPbmVUZW5zb3IoZSl7dmFyIHQ7aWYoQXJyYXkuaXNBcnJheShlKSl7aWYoMSE9PWUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRXhwZWN0ZWQgVGVuc29yIGxlbmd0aCB0byBiZSAxOyBnb3QgXCIrZS5sZW5ndGgpO3Q9ZVswXX1lbHNlIHQ9ZTtyZXR1cm4gdH1mdW5jdGlvbiBnZXRFeGFjdGx5T25lU2hhcGUoZSl7aWYoQXJyYXkuaXNBcnJheShlKSYmQXJyYXkuaXNBcnJheShlWzBdKSl7aWYoMT09PWUubGVuZ3RoKXJldHVybihlPWUpWzBdO3Rocm93IG5ldyBWYWx1ZUVycm9yKFwiRXhwZWN0ZWQgZXhhY3RseSAxIFNoYXBlOyBnb3QgXCIrZS5sZW5ndGgpfXJldHVybiBlfWZ1bmN0aW9uIGNvdW50UGFyYW1zSW5XZWlnaHRzKGUpe2Zvcih2YXIgdD0wLG49MCxyPWU7bjxyLmxlbmd0aDtuKyspe3ZhciBpPXJbbl07MD09PWkuc2hhcGUubGVuZ3RoP3QrPTE6dCs9aS5zaGFwZS5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSp0fSl9cmV0dXJuIHR9dmFyIERFRkFVTFRfVkFSSUFCTEVfTkFNRV9QUkVGSVg9XCJWYXJpYWJsZVwiLExheWVyVmFyaWFibGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCxuLHIsaSl7dm9pZCAwPT09dCYmKHQ9XCJmbG9hdDMyXCIpLHZvaWQgMD09PW4mJihuPURFRkFVTFRfVkFSSUFCTEVfTkFNRV9QUkVGSVgpLHZvaWQgMD09PXImJihyPSEwKSx2b2lkIDA9PT1pJiYoaT1udWxsKSx0aGlzLmR0eXBlPW51bGw9PXQ/XCJmbG9hdDMyXCI6dCx0aGlzLnNoYXBlPWUuc2hhcGUsdGhpcy5pZD1nZXROZXh0VW5pcXVlVGVuc29ySWQoKSxuPW51bGw9PW4/REVGQVVMVF9WQVJJQUJMRV9OQU1FX1BSRUZJWDpuLHRoaXMub3JpZ2luYWxOYW1lPWdldFNjb3BlZFRlbnNvck5hbWUobiksdGhpcy5uYW1lPWdldFVuaXF1ZVRlbnNvck5hbWUodGhpcy5vcmlnaW5hbE5hbWUpLHRoaXMudHJhaW5hYmxlXz1yLHRoaXMuY29uc3RyYWludD1pLHRoaXMudmFsPXZhcmlhYmxlKGUsdGhpcy50cmFpbmFibGVfLHRoaXMubmFtZSx0aGlzLmR0eXBlKX1yZXR1cm4gZS5wcm90b3R5cGUucmVhZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFzc2VydE5vdERpc3Bvc2VkKCksdGhpcy52YWx9LGUucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmFzc2VydE5vdERpc3Bvc2VkKCksY2hlY2tTaGFwZXNNYXRjaCh0aGlzLnZhbCxlKSx0aGlzLnZhbC5pZCE9PWUuaWQmJih0aGlzLnZhbC5hc3NpZ24oZSksbnVsbCE9dGhpcy5jb25zdHJhaW50JiZ0aGlzLnZhbC5hc3NpZ24odGhpcy5jb25zdHJhaW50LmFwcGx5KHRoaXMudmFsKSkpLHRoaXN9LGUucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLmFzc2VydE5vdERpc3Bvc2VkKCksdGhpcy52YWwuZGlzcG9zZSgpfSxlLnByb3RvdHlwZS5hc3NlcnROb3REaXNwb3NlZD1mdW5jdGlvbigpe2lmKHRoaXMudmFsLmlzRGlzcG9zZWQpdGhyb3cgbmV3IEVycm9yKFwiTGF5ZXJzVmFyaWFibGUgXCIrdGhpcy5uYW1lK1wiIGlzIGFscmVhZHkgZGlzcG9zZWQuXCIpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJ0cmFpbmFibGVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhaW5hYmxlX30sc2V0OmZ1bmN0aW9uKGUpe3RoaXMudHJhaW5hYmxlXz1lLHRoaXMudmFsLnRyYWluYWJsZT1lfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGV9KCk7ZnVuY3Rpb24gY2hlY2tTaGFwZXNNYXRjaChlLHQpe2lmKGUuc2hhcGUudG9TdHJpbmcoKSE9PXQuc2hhcGUudG9TdHJpbmcoKSl0aHJvdyBuZXcgRXJyb3IoXCJTaGFwZSBtaXNtYXRjaDogXCIrSlNPTi5zdHJpbmdpZnkoZS5zaGFwZSkrXCIgdnMuIFwiK0pTT04uc3RyaW5naWZ5KHQuc2hhcGUpKX1mdW5jdGlvbiBiYXRjaEdldFZhbHVlKGUpe3JldHVybiBlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5yZWFkKCl9KX1mdW5jdGlvbiBiYXRjaFNldFZhbHVlKGUpe2UuZm9yRWFjaChmdW5jdGlvbihlKXtlWzBdLndyaXRlKGVbMV0pfSl9dmFyIElucHV0U3BlYz1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXt0aGlzLmR0eXBlPWUuZHR5cGUsdGhpcy5zaGFwZT1lLnNoYXBlLG51bGwhPWUuc2hhcGU/dGhpcy5uZGltPWUuc2hhcGUubGVuZ3RoOnRoaXMubmRpbT1lLm5kaW0sdGhpcy5tYXhORGltPWUubWF4TkRpbSx0aGlzLm1pbk5EaW09ZS5taW5ORGltLHRoaXMuYXhlcz1lLmF4ZXN8fHt9fX0oKSxTeW1ib2xpY1RlbnNvcj1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlLHQsbixyLGksYSxvKXt0aGlzLmR0eXBlPWUsdGhpcy5zaGFwZT10LHRoaXMuc291cmNlTGF5ZXI9bix0aGlzLmlucHV0cz1yLHRoaXMuY2FsbEFyZ3M9aSx0aGlzLm91dHB1dFRlbnNvckluZGV4PW8sdGhpcy5pZD1nZXROZXh0VW5pcXVlVGVuc29ySWQoKSxudWxsIT1hJiYodGhpcy5vcmlnaW5hbE5hbWU9Z2V0U2NvcGVkVGVuc29yTmFtZShhKSx0aGlzLm5hbWU9Z2V0VW5pcXVlVGVuc29yTmFtZSh0aGlzLm9yaWdpbmFsTmFtZSkpLHRoaXMucmFuaz10Lmxlbmd0aH19KCksX25leHROb2RlSUQ9MCxOb2RlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3RoaXMuY2FsbEFyZ3M9dCx0aGlzLmlkPV9uZXh0Tm9kZUlEKyssdGhpcy5vdXRib3VuZExheWVyPWUub3V0Ym91bmRMYXllcix0aGlzLmluYm91bmRMYXllcnM9ZS5pbmJvdW5kTGF5ZXJzLHRoaXMubm9kZUluZGljZXM9ZS5ub2RlSW5kaWNlcyx0aGlzLnRlbnNvckluZGljZXM9ZS50ZW5zb3JJbmRpY2VzLHRoaXMuaW5wdXRUZW5zb3JzPWUuaW5wdXRUZW5zb3JzLHRoaXMub3V0cHV0VGVuc29ycz1lLm91dHB1dFRlbnNvcnMsdGhpcy5pbnB1dE1hc2tzPWUuaW5wdXRNYXNrcyx0aGlzLm91dHB1dE1hc2tzPWUub3V0cHV0TWFza3MsdGhpcy5pbnB1dFNoYXBlcz1lLmlucHV0U2hhcGVzLHRoaXMub3V0cHV0U2hhcGVzPWUub3V0cHV0U2hhcGVzO2Zvcih2YXIgbj0wLHI9ZS5pbmJvdW5kTGF5ZXJzO248ci5sZW5ndGg7bisrKXt2YXIgaT1yW25dO251bGwhPWkmJmkub3V0Ym91bmROb2Rlcy5wdXNoKHRoaXMpfWUub3V0Ym91bmRMYXllci5pbmJvdW5kTm9kZXMucHVzaCh0aGlzKX1yZXR1cm4gZS5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MCxuPXRoaXMuaW5ib3VuZExheWVyczt0PG4ubGVuZ3RoO3QrKyl7dmFyIHI9blt0XTtudWxsIT1yP2UucHVzaChyLm5hbWUpOmUucHVzaChudWxsKX1yZXR1cm57b3V0Ym91bmRMYXllcjp0aGlzLm91dGJvdW5kTGF5ZXI/dGhpcy5vdXRib3VuZExheWVyLm5hbWU6bnVsbCxpbmJvdW5kTGF5ZXJzOmUsbm9kZUluZGljZXM6dGhpcy5ub2RlSW5kaWNlcyx0ZW5zb3JJbmRpY2VzOnRoaXMudGVuc29ySW5kaWNlc319LGV9KCksX25leHRMYXllcklEPTAsTGF5ZXI9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyl8fHRoaXM7bi5fY2FsbEhvb2s9bnVsbCxuLl9hZGRlZFdlaWdodE5hbWVzPVtdLG4uX3N0YXRlZnVsPSExLG4uaWQ9X25leHRMYXllcklEKyssbi5hY3Rpdml0eVJlZ3VsYXJpemVyPW51bGwsbi5pbnB1dFNwZWM9bnVsbCxuLnN1cHBvcnRzTWFza2luZz0hMSxuLl90cmFpbmFibGVXZWlnaHRzPVtdLG4uX25vblRyYWluYWJsZVdlaWdodHM9W10sbi5fbG9zc2VzPVtdLG4uX3VwZGF0ZXM9W10sbi5fYnVpbHQ9ITEsbi5pbmJvdW5kTm9kZXM9W10sbi5vdXRib3VuZE5vZGVzPVtdO3ZhciByPXQubmFtZTtpZighcil7dmFyIGk9bi5nZXRDbGFzc05hbWUoKTtyPXRvU25ha2VDYXNlKGkpK1wiX1wiK2dldFVpZChpKX1pZihuLm5hbWU9cixuLnRyYWluYWJsZV89bnVsbD09dC50cmFpbmFibGV8fHQudHJhaW5hYmxlLG4udXBkYXRhYmxlPW51bGw9PXQudXBkYXRhYmxlfHx0LnVwZGF0YWJsZSxudWxsIT10LmlucHV0U2hhcGV8fG51bGwhPXQuYmF0Y2hJbnB1dFNoYXBlKXt2YXIgYT12b2lkIDA7aWYobnVsbCE9dC5iYXRjaElucHV0U2hhcGUpYT10LmJhdGNoSW5wdXRTaGFwZTtlbHNlIGlmKG51bGwhPXQuaW5wdXRTaGFwZSl7dmFyIG89bnVsbDtudWxsIT10LmJhdGNoU2l6ZSYmKG89dC5iYXRjaFNpemUpLGE9W29dLmNvbmNhdCh0LmlucHV0U2hhcGUpfW4uYmF0Y2hJbnB1dFNoYXBlPWE7dmFyIHM9dC5kdHlwZTtudWxsPT1zJiYocz10LmlucHV0RFR5cGUpLG51bGw9PXMmJihzPVwiZmxvYXQzMlwiKSxuLmR0eXBlPXN9cmV0dXJuIG51bGwhPXQud2VpZ2h0cz9uLmluaXRpYWxXZWlnaHRzPXQud2VpZ2h0czpuLmluaXRpYWxXZWlnaHRzPW51bGwsbi5fcmVmQ291bnQ9bnVsbCxuLmZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQ9ITEsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5ub2RlS2V5PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUubmFtZStcIl9pYi1cIit0LnRvU3RyaW5nKCl9LHQucHJvdG90eXBlLmdldE5vZGVBdEluZGV4PWZ1bmN0aW9uKGUsdCl7aWYoMD09PXRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aCl0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiVGhlIGxheWVyIGhhcyBuZXZlciBiZWVuIGNhbGxlZCBhbmQgdGh1cyBoYXMgbm8gZGVmaW5lZCBcIit0K1wiLlwiKTtpZih0aGlzLmluYm91bmROb2Rlcy5sZW5ndGg8PWUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBc2tlZCB0byBnZXQgXCIrdCtcIiBhdCBub2RlIFwiK2UrXCIsIGJ1dCB0aGUgbGF5ZXIgaGFzIG9ubHkgXCIrdGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoK1wiIGluYm91bmQgbm9kZXMuXCIpO3JldHVybiB0aGlzLmluYm91bmROb2Rlc1tlXX0sdC5wcm90b3R5cGUuZ2V0SW5wdXRBdD1mdW5jdGlvbihlKXtyZXR1cm4gc2luZ2xldG9uT3JBcnJheSh0aGlzLmdldE5vZGVBdEluZGV4KGUsXCJpbnB1dFwiKS5pbnB1dFRlbnNvcnMpfSx0LnByb3RvdHlwZS5nZXRPdXRwdXRBdD1mdW5jdGlvbihlKXtyZXR1cm4gc2luZ2xldG9uT3JBcnJheSh0aGlzLmdldE5vZGVBdEluZGV4KGUsXCJvdXRwdXRcIikub3V0cHV0VGVuc29ycyl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImlucHV0XCIse2dldDpmdW5jdGlvbigpe2lmKHRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aD4xKXRocm93IG5ldyBBdHRyaWJ1dGVFcnJvcihcIkxheWVyIFwiK3RoaXMubmFtZSsnIGhhcyBtdWx0aXBsZSBpbmJvdW5kIG5vZGVzLCBoZW5jZSB0aGUgbm90aW9uIG9mIFwibGF5ZXIgaW5wdXRcIiBpcyBpbGwtZGVmaW5lZC4gVXNlIGBnZXRJbnB1dEF0KG5vZGVJbmRleClgIGluc3RlYWQuJyk7aWYoMD09PXRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aCl0aHJvdyBuZXcgQXR0cmlidXRlRXJyb3IoXCJMYXllciBcIit0aGlzLm5hbWUrXCIgaXMgbm90IGNvbm5lY3RlZCwgbm8gaW5wdXQgdG8gcmV0dXJuLlwiKTtyZXR1cm4gc2luZ2xldG9uT3JBcnJheSh0aGlzLmdldE5vZGVBdEluZGV4KDAsXCJpbnB1dFwiKS5pbnB1dFRlbnNvcnMpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIm91dHB1dFwiLHtnZXQ6ZnVuY3Rpb24oKXtpZigwPT09dGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoKXRocm93IG5ldyBBdHRyaWJ1dGVFcnJvcihcIkxheWVyIFwiK3RoaXMubmFtZStcIiBoYXMgbm8gaW5ib3VuZCBub2Rlcy5cIik7aWYodGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoPjEpdGhyb3cgbmV3IEF0dHJpYnV0ZUVycm9yKFwiTGF5ZXIgXCIrdGhpcy5uYW1lKycgaGFzIG11bHRpcGxlIGluYm91bmQgbm9kZXMsIGhlbmNlIHRoZSBub3Rpb24gb2YgXCJsYXllciBvdXRwdXRcIiBpcyBpbGwtZGVmaW5lZC4gVXNlIGBnZXRPdXRwdXRBdChub2RlSW5kZXgpYCBpbnN0ZWFkLicpO3JldHVybiBzaW5nbGV0b25PckFycmF5KHRoaXMuZ2V0Tm9kZUF0SW5kZXgoMCxcIm91dHB1dFwiKS5vdXRwdXRUZW5zb3JzKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJsb3NzZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2xvc3Nlc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5jYWxjdWxhdGVMb3NzZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sb3NzZXMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlKCl9KX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidXBkYXRlc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdXBkYXRlc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJidWlsdFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYnVpbHR9LHNldDpmdW5jdGlvbihlKXt0aGlzLl9idWlsdD1lfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInRyYWluYWJsZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFpbmFibGVffSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fdHJhaW5hYmxlV2VpZ2h0cy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRyYWluYWJsZT1lfSksdGhpcy50cmFpbmFibGVfPWV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidHJhaW5hYmxlV2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFpbmFibGVfP3RoaXMuX3RyYWluYWJsZVdlaWdodHMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLnRyYWluYWJsZX0pOltdfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fdHJhaW5hYmxlV2VpZ2h0cz1lfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIm5vblRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhaW5hYmxlP3RoaXMuX3RyYWluYWJsZVdlaWdodHMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiFlLnRyYWluYWJsZX0pLmNvbmNhdCh0aGlzLl9ub25UcmFpbmFibGVXZWlnaHRzKTp0aGlzLl90cmFpbmFibGVXZWlnaHRzLmNvbmNhdCh0aGlzLl9ub25UcmFpbmFibGVXZWlnaHRzKX0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX25vblRyYWluYWJsZVdlaWdodHM9ZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ3ZWlnaHRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyYWluYWJsZVdlaWdodHMuY29uY2F0KHRoaXMubm9uVHJhaW5hYmxlV2VpZ2h0cyl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwic3RhdGVmdWxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N0YXRlZnVsfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLnJlc2V0U3RhdGVzPWZ1bmN0aW9uKCl7aWYoIXRoaXMuc3RhdGVmdWwpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgdGhlIHJlc2V0U3RhdGVzKCkgbWV0aG9kIG9mIGEgbm9uLXN0YXRlZnVsIExheWVyIG9iamVjdC5cIil9LHQucHJvdG90eXBlLmFzc2VydElucHV0Q29tcGF0aWJpbGl0eT1mdW5jdGlvbihlKXtpZihlPXRvTGlzdChlKSxudWxsIT10aGlzLmlucHV0U3BlYyYmMCE9PXRoaXMuaW5wdXRTcGVjLmxlbmd0aCl7dmFyIHQ9dG9MaXN0KHRoaXMuaW5wdXRTcGVjKTtpZihlLmxlbmd0aCE9PXQubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTGF5ZXIgXCIrdGhpcy5uYW1lK1wiIGV4cGVjdHMgXCIrdC5sZW5ndGgrXCIgaW5wdXRzLCBidXQgaXQgcmVjZWl2ZWQgXCIrZS5sZW5ndGgrXCIgaW5wdXQgdGVuc29ycy4gSW5wdXQgcmVjZWl2ZWQ6IFwiK2UpO2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dLGk9dFtuXTtpZihudWxsIT1pKXt2YXIgYT1yLnJhbms7aWYobnVsbCE9aS5uZGltJiZhIT09aS5uZGltKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW5wdXQgXCIrbitcIiBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciBcIit0aGlzLm5hbWUrXCI6IGV4cGVjdGVkIG5kaW09XCIraS5uZGltK1wiLCBmb3VuZCBuZGltPVwiK2EpO2lmKG51bGwhPWkubWF4TkRpbSYmYT5pLm1heE5EaW0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnB1dCBcIituK1wiIGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyIFwiK3RoaXMubmFtZStcIjogZXhwZWN0ZWQgbWF4X25kaW09XCIraS5tYXhORGltK1wiLCBmb3VuZCBuZGltPVwiK2EpO2lmKG51bGwhPWkubWluTkRpbSYmYTxpLm1pbk5EaW0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnB1dCBcIituK1wiIGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyIFwiK3RoaXMubmFtZStcIjogZXhwZWN0ZWQgbWluX25kaW09XCIraS5taW5ORGltK1wiLCBmb3VuZCBuZGltPVwiK2ErXCIuXCIpO2lmKG51bGwhPWkuZHR5cGUmJnIuZHR5cGUhPT1pLmR0eXBlKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW5wdXQgXCIrbitcIiBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciBcIit0aGlzLm5hbWUrXCIgOiBleHBlY3RlZCBkdHlwZT1cIitpLmR0eXBlK1wiLCBmb3VuZCBkdHlwZT1cIityLmR0eXBlK1wiLlwiKTtpZihpLmF4ZXMpe3ZhciBvPXIuc2hhcGU7Zm9yKHZhciBzIGluIGkuYXhlcyl7dmFyIGw9TnVtYmVyKHMpLHU9aS5heGVzW3NdLGM9bD49MD9vW2xdOm9bby5sZW5ndGgrbF07aWYobnVsbCE9dSYmLTE9PT1bdSxudWxsXS5pbmRleE9mKGMpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSW5wdXQgXCIrbitcIiBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciBcIit0aGlzLm5hbWUrXCI6IGV4cGVjdGVkIGF4aXMgXCIrbCtcIiBvZiBpbnB1dCBzaGFwZSB0byBoYXZlIHZhbHVlIFwiK3UrXCIgYnV0IGdvdCBzaGFwZSBcIitvK1wiLlwiKX19aWYobnVsbCE9aS5zaGFwZSlmb3IodmFyIHA9MDtwPGkuc2hhcGUubGVuZ3RoOysrcCl7dmFyIGg9aS5zaGFwZVtwXSxkPXIuc2hhcGVbcF07aWYobnVsbCE9aCYmbnVsbCE9ZCYmaCE9PWQpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnB1dCBcIituK1wiIGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyIFwiK3RoaXMubmFtZStcIjogZXhwZWN0ZWQgc2hhcGU9XCIraS5zaGFwZStcIiwgZm91bmQgc2hhcGU9XCIrci5zaGFwZStcIi5cIil9fX19fSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGV9LHQucHJvdG90eXBlLmludm9rZUNhbGxIb29rPWZ1bmN0aW9uKGUsdCl7bnVsbCE9dGhpcy5fY2FsbEhvb2smJnRoaXMuX2NhbGxIb29rKGUsdCl9LHQucHJvdG90eXBlLnNldENhbGxIb29rPWZ1bmN0aW9uKGUpe3RoaXMuX2NhbGxIb29rPWV9LHQucHJvdG90eXBlLmNsZWFyQ2FsbEhvb2s9ZnVuY3Rpb24oKXt0aGlzLl9jYWxsSG9vaz1udWxsfSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7dD10fHx7fSx0aGlzLmFzc2VydE5vdERpc3Bvc2VkKCk7Zm9yKHZhciByPXRvTGlzdChlKSxpPSEwLGE9MCxvPXI7YTxvLmxlbmd0aDthKyspe2lmKCEob1thXWluc3RhbmNlb2YgU3ltYm9saWNUZW5zb3IpKXtpPSExO2JyZWFrfX1mb3IodmFyIHM9ITAsbD0wLHU9cjtsPHUubGVuZ3RoO2wrKyl7aWYodVtsXWluc3RhbmNlb2YgU3ltYm9saWNUZW5zb3Ipe3M9ITE7YnJlYWt9fWlmKGk9PT1zKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQXJndW1lbnRzIHRvIGFwcGx5KCkgbXVzdCBiZSBhbGwgU3ltYm9saWNUZW5zb3JzIG9yIGFsbCBUZW5zb3JzXCIpO3JldHVybiBuYW1lU2NvcGUodGhpcy5uYW1lLGZ1bmN0aW9uKCl7aWYoIW4uYnVpbHQpe24uYXNzZXJ0SW5wdXRDb21wYXRpYmlsaXR5KGUpO2Zvcih2YXIgaT1bXSxhPTAsbz10b0xpc3QoZSk7YTxvLmxlbmd0aDthKyspe3ZhciBsPW9bYV07aS5wdXNoKGwuc2hhcGUpfW4uYnVpbGQoc2luZ2xldG9uT3JBcnJheShpKSksbi5idWlsdD0hMCxuLmluaXRpYWxXZWlnaHRzJiZuLnNldFdlaWdodHMobi5pbml0aWFsV2VpZ2h0cyksbnVsbD09PW4uX3JlZkNvdW50JiZzJiYobi5fcmVmQ291bnQ9MSl9aWYobi5hc3NlcnRJbnB1dENvbXBhdGliaWxpdHkoZSkscyl7Zm9yKHZhciB1PVtdLGM9MCxwPXRvTGlzdChnPW4uY2FsbChlLHQpKTtjPHAubGVuZ3RoO2MrKyl7dmFyIGg9cFtjXTstMSE9PXIuaW5kZXhPZihoKSYmKGg9aC5jbG9uZSgpKSx1LnB1c2goaCl9aWYoZz1zaW5nbGV0b25PckFycmF5KHUpLG51bGwhPW4uYWN0aXZpdHlSZWd1bGFyaXplcil0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIkxheWVyIGludm9jYXRpb24gaW4gdGhlIHByZXNlbmNlIG9mIGFjdGl2aXR5IHJlZ3VsYXJpemVyKHMpIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtyZXR1cm4gZ312YXIgZD1jb2xsZWN0SW5wdXRTaGFwZShlKSxmPW4uY29tcHV0ZU91dHB1dFNoYXBlKGQpLGc9dm9pZCAwLG09Z3Vlc3NPdXRwdXREVHlwZShlKTtpZihuLndhcm5PbkluY29tcGF0aWJsZUlucHV0U2hhcGUoQXJyYXkuaXNBcnJheShlKT9kWzBdOmQpLGc9bnVsbCE9ZiYmZi5sZW5ndGg+MCYmQXJyYXkuaXNBcnJheShmWzBdKT9mLm1hcChmdW5jdGlvbihyLGkpe3JldHVybiBuZXcgU3ltYm9saWNUZW5zb3IobSxyLG4sdG9MaXN0KGUpLHQsbi5uYW1lLGkpfSk6bmV3IFN5bWJvbGljVGVuc29yKG0sZixuLHRvTGlzdChlKSx0LG4ubmFtZSksbi5hZGRJbmJvdW5kTm9kZShlLGcsbnVsbCxudWxsLGQsZix0KSxuLl9yZWZDb3VudCsrLG51bGwhPW4uYWN0aXZpdHlSZWd1bGFyaXplcil0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIkxheWVyIGludm9jYXRpb24gaW4gdGhlIHByZXNlbmNlIG9mIGFjdGl2aXR5IHJlZ3VsYXJpemVyKHMpIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtyZXR1cm4gZ30pfSx0LnByb3RvdHlwZS53YXJuT25JbmNvbXBhdGlibGVJbnB1dFNoYXBlPWZ1bmN0aW9uKGUpe2lmKG51bGwhPXRoaXMuYmF0Y2hJbnB1dFNoYXBlKWlmKGUubGVuZ3RoIT09dGhpcy5iYXRjaElucHV0U2hhcGUubGVuZ3RoKWNvbnNvbGUud2FybihcIlRoZSByYW5rIG9mIHRoZSBpbnB1dCB0ZW5zb3IgcHJvdmlkZWQgKHNoYXBlOiBcIitKU09OLnN0cmluZ2lmeShlKStcIikgZG9lcyBub3QgbWF0Y2ggdGhhdCBvZiB0aGUgYmF0Y2hJbnB1dFNoYXBlIChcIitKU09OLnN0cmluZ2lmeSh0aGlzLmJhdGNoSW5wdXRTaGFwZSkrXCIpIG9mIHRoZSBsYXllciBcIit0aGlzLm5hbWUpO2Vsc2V7dmFyIHQ9ITE7dGhpcy5iYXRjaElucHV0U2hhcGUuZm9yRWFjaChmdW5jdGlvbihuLHIpe251bGwhPW4mJm51bGwhPWVbcl0mJmVbcl0hPT1uJiYodD0hMCl9KSx0JiZjb25zb2xlLndhcm4oXCJUaGUgc2hhcGUgb2YgdGhlIGlucHV0IHRlbnNvciAoXCIrSlNPTi5zdHJpbmdpZnkoZSkrXCIpIGRvZXMgbm90IG1hdGNoIHRoZSBleHBlY3RhdGlvbiBvZiBsYXllciBcIit0aGlzLm5hbWUrXCI6IFwiK0pTT04uc3RyaW5naWZ5KHRoaXMuYmF0Y2hJbnB1dFNoYXBlKSl9fSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJvdXRwdXRTaGFwZVwiLHtnZXQ6ZnVuY3Rpb24oKXtpZihudWxsPT10aGlzLmluYm91bmROb2Rlc3x8MD09PXRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aCl0aHJvdyBuZXcgQXR0cmlidXRlRXJyb3IoXCJUaGUgbGF5ZXIgXCIrdGhpcy5uYW1lK1wiIGhhcyBuZXZlciBiZWVuIGNhbGxlZCBhbmQgdGh1cyBoYXMgbm8gZGVmaW5lZCBvdXRwdXQgc2hhcGUuXCIpO2Zvcih2YXIgZT1bXSx0PTAsbj10aGlzLmluYm91bmROb2Rlczt0PG4ubGVuZ3RoO3QrKyl7dmFyIHI9blt0XSxpPUpTT04uc3RyaW5naWZ5KHIub3V0cHV0U2hhcGVzKTstMT09PWUuaW5kZXhPZihpKSYmZS5wdXNoKGkpfWlmKDE9PT1lLmxlbmd0aCl7dmFyIGE9dGhpcy5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0U2hhcGVzO3JldHVybiBBcnJheS5pc0FycmF5KGEpJiZBcnJheS5pc0FycmF5KGFbMF0pJiYxPT09YS5sZW5ndGg/YVswXTphfXRocm93IG5ldyBBdHRyaWJ1dGVFcnJvcihcIlRoZSBsYXllciBcIit0aGlzLm5hbWUrJyBoYXMgbXVsdGlwbGUgaW5ib3VuZCBub2RlcyB3aXRoIGRpZmZlcmVudCBvdXRwdXQgc2hhcGVzLiBIZW5jZSB0aGUgbm90aW9uIG9mIFwib3V0dXQgc2hhcGVcIiBpcyBpbGwtZGVmaW5lZCBmb3IgdGhlIGxheWVyLicpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmNvdW50UGFyYW1zPWZ1bmN0aW9uKCl7aWYoIXRoaXMuYnVpbHQpdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcIllvdSB0cmllZCB0byBjYWxsIGNvdW50UGFyYW1zKCkgb24gXCIrdGhpcy5uYW1lK1wiLCBidXQgdGhlIGxheWVyIGlzIG5vdCBidWlsdCB5ZXQuIEJ1aWxkIGl0IGZpcnN0IGJ5IGNhbGxpbmcgYnVpbGQoYmF0Y2hJbnB1dFNoYXBlKS5cIik7cmV0dXJuIGNvdW50UGFyYW1zSW5XZWlnaHRzKHRoaXMud2VpZ2h0cyl9LHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe3RoaXMuYnVpbHQ9ITB9LHQucHJvdG90eXBlLmdldFdlaWdodHM9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPSExKSxiYXRjaEdldFZhbHVlKGU/dGhpcy50cmFpbmFibGVXZWlnaHRzOnRoaXMud2VpZ2h0cyl9LHQucHJvdG90eXBlLnNldFdlaWdodHM9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpczt0aWR5KGZ1bmN0aW9uKCl7dmFyIG49dC53ZWlnaHRzO2lmKG4ubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ1lvdSBjYWxsZWQgc2V0V2VpZ2h0cyh3ZWlnaHRzKSBvbiBsYXllciBcIicrdC5uYW1lKydcIiB3aXRoIGEgd2VpZ2h0IGxpc3Qgb2YgbGVuZ3RoICcrZS5sZW5ndGgrXCIsIGJ1dCB0aGUgbGF5ZXIgd2FzIGV4cGVjdGluZyBcIituLmxlbmd0aCtcIiB3ZWlnaHRzLiBQcm92aWRlZCB3ZWlnaHRzOiBcIitlK1wiLi4uXCIpO2lmKDAhPT1uLmxlbmd0aCl7Zm9yKHZhciByPVtdLGk9YmF0Y2hHZXRWYWx1ZShuKSxhPTA7YTxpLmxlbmd0aDsrK2Epe3ZhciBvPWlbYV0scz1uW2FdLGw9ZVthXTtpZighdXRpbC5hcnJheXNFcXVhbChvLnNoYXBlLGwuc2hhcGUpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTGF5ZXIgd2VpZ2h0IHNoYXBlIFwiK28uc2hhcGUrXCIgbm90IGNvbXBhdGlibGUgd2l0aCBwcm92aWRlZCB3ZWlnaHQgc2hhcGUgXCIrbC5zaGFwZSk7ci5wdXNoKFtzLGxdKX1iYXRjaFNldFZhbHVlKHIpfX0pfSx0LnByb3RvdHlwZS5hZGRXZWlnaHQ9ZnVuY3Rpb24oZSx0LG4scixpLGEsbyl7aWYoLTEhPT10aGlzLl9hZGRlZFdlaWdodE5hbWVzLmluZGV4T2YoZSkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJEdXBsaWNhdGUgd2VpZ2h0IG5hbWUgXCIrZStcIiBmb3IgbGF5ZXIgXCIrdGhpcy5uYW1lKTt0aGlzLl9hZGRlZFdlaWdodE5hbWVzLnB1c2goZSksbnVsbD09biYmKG49XCJmbG9hdDMyXCIpLHRoaXMuZmFzdFdlaWdodEluaXREdXJpbmdCdWlsZCYmKHI9Z2V0SW5pdGlhbGl6ZXIoXCJ6ZXJvc1wiKSk7dmFyIHM9ci5hcHBseSh0LG4pLGw9bmV3IExheWVyVmFyaWFibGUocyxuLGUsYSxvKTtyZXR1cm4gcy5kaXNwb3NlKCksbnVsbCE9aSYmdGhpcy5hZGRMb3NzKGZ1bmN0aW9uKCl7cmV0dXJuIGkuYXBwbHkobC5yZWFkKCkpfSksbnVsbD09YSYmKGE9ITApLGE/dGhpcy5fdHJhaW5hYmxlV2VpZ2h0cy5wdXNoKGwpOnRoaXMuX25vblRyYWluYWJsZVdlaWdodHMucHVzaChsKSxsfSx0LnByb3RvdHlwZS5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkPWZ1bmN0aW9uKGUpe3RoaXMuZmFzdFdlaWdodEluaXREdXJpbmdCdWlsZD1lfSx0LnByb3RvdHlwZS5hZGRMb3NzPWZ1bmN0aW9uKGUpe3ZhciB0O251bGw9PWV8fEFycmF5LmlzQXJyYXkoZSkmJjA9PT1lLmxlbmd0aHx8KGU9dG9MaXN0KGUpLHZvaWQgMCE9PXRoaXMuX2xvc3NlcyYmbnVsbCE9PXRoaXMuX2xvc3NlcyYmKHQ9dGhpcy5sb3NzZXMpLnB1c2guYXBwbHkodCxlKSl9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtyZXR1cm4gZX0sdC5wcm90b3R5cGUuY29tcHV0ZU1hc2s9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO2lmKCF0aGlzLnN1cHBvcnRzTWFza2luZyl7aWYobnVsbCE9dCl7aWYoIUFycmF5LmlzQXJyYXkodCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkxheWVyIFwiK3RoaXMubmFtZStcIiBkb2VzIG5vdCBzdXBwb3J0IG1hc2tpbmcsIGJ1dCB3YXMgcGFzc2VkIGFuIGlucHV0TWFzay5cIik7dC5mb3JFYWNoKGZ1bmN0aW9uKGUpe2lmKG51bGwhPWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkxheWVyIFwiK24ubmFtZStcIiBkb2VzIG5vdCBzdXBwb3J0IG1hc2tpbmcsIGJ1dCB3YXMgcGFzc2VkIGFuIGlucHV0TWFzay5cIil9KX1yZXR1cm4gbnVsbH1yZXR1cm4gdH0sdC5wcm90b3R5cGUuYWRkSW5ib3VuZE5vZGU9ZnVuY3Rpb24oZSx0LG4scixpLGEsbyl7dm9pZCAwPT09byYmKG89bnVsbCk7dmFyIHM9dG9MaXN0KGUpO3Q9dG9MaXN0KHQpLG49dG9MaXN0KG4pLHI9dG9MaXN0KHIpLGk9bm9ybWFsaXplU2hhcGVMaXN0KGkpLGE9bm9ybWFsaXplU2hhcGVMaXN0KGEpO2Zvcih2YXIgbD1bXSx1PVtdLGM9W10scD0wLGg9cztwPGgubGVuZ3RoO3ArKyl7dmFyIGQ9aFtwXTtsLnB1c2goZC5zb3VyY2VMYXllciksdS5wdXNoKGQubm9kZUluZGV4KSxjLnB1c2goZC50ZW5zb3JJbmRleCl9bmV3IE5vZGUoe291dGJvdW5kTGF5ZXI6dGhpcyxpbmJvdW5kTGF5ZXJzOmwsbm9kZUluZGljZXM6dSx0ZW5zb3JJbmRpY2VzOmMsaW5wdXRUZW5zb3JzOnMsb3V0cHV0VGVuc29yczp0LGlucHV0TWFza3M6bixvdXRwdXRNYXNrczpyLGlucHV0U2hhcGVzOmksb3V0cHV0U2hhcGVzOmF9LG8pO2Zvcih2YXIgZj0wO2Y8dC5sZW5ndGg7ZisrKXRbZl0uc291cmNlTGF5ZXI9dGhpcyx0W2ZdLm5vZGVJbmRleD10aGlzLmluYm91bmROb2Rlcy5sZW5ndGgtMSx0W2ZdLnRlbnNvckluZGV4PWZ9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciBlPXtuYW1lOnRoaXMubmFtZSx0cmFpbmFibGU6dGhpcy50cmFpbmFibGV9O3JldHVybiBudWxsIT10aGlzLmJhdGNoSW5wdXRTaGFwZSYmKGUuYmF0Y2hJbnB1dFNoYXBlPXRoaXMuYmF0Y2hJbnB1dFNoYXBlKSxudWxsIT10aGlzLmR0eXBlJiYoZS5kdHlwZT10aGlzLmR0eXBlKSxlfSx0LnByb3RvdHlwZS5kaXNwb3NlV2VpZ2h0cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLndlaWdodHMuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gZS5kaXNwb3NlKCl9KSx0aGlzLndlaWdodHMubGVuZ3RofSx0LnByb3RvdHlwZS5hc3NlcnROb3REaXNwb3NlZD1mdW5jdGlvbigpe2lmKDA9PT10aGlzLl9yZWZDb3VudCl0aHJvdyBuZXcgRXJyb3IoXCJMYXllciAnXCIrdGhpcy5uYW1lK1wiJyBpcyBhbHJlYWR5IGRpc3Bvc2VkLlwiKX0sdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe2lmKCF0aGlzLmJ1aWx0KXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkaXNwb3NlIExheWVyIFwiK3RoaXMubmFtZStcIiBiZWNhdXNlIGl0IGhhcyBub3QgYmVlbiBidWlsdCB5ZXQuXCIpO2lmKG51bGw9PT10aGlzLl9yZWZDb3VudCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZGlzcG9zZSBMYXllciBcIit0aGlzLm5hbWUrXCIgYmVjYXVzZSBpdCBoYXMgbm90IGJlZW4gdXNlZCB5ZXQuXCIpO3RoaXMuYXNzZXJ0Tm90RGlzcG9zZWQoKTt2YXIgZT0wO3JldHVybiAwPT0tLXRoaXMuX3JlZkNvdW50JiYoZT10aGlzLmRpc3Bvc2VXZWlnaHRzKCkpLHtyZWZDb3VudEFmdGVyRGlzcG9zZTp0aGlzLl9yZWZDb3VudCxudW1EaXNwb3NlZFZhcmlhYmxlczplfX0sdH0oc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGUpO2Z1bmN0aW9uIGNvbGxlY3RJbnB1dFNoYXBlKGUpe2Zvcih2YXIgdD1bXSxuPTAscj1lPXRvTGlzdChlKTtuPHIubGVuZ3RoO24rKyl7dmFyIGk9cltuXTt0LnB1c2goaS5zaGFwZSl9cmV0dXJuIHNpbmdsZXRvbk9yQXJyYXkodCl9ZnVuY3Rpb24gZ3Vlc3NPdXRwdXREVHlwZShlKXtyZXR1cm5cImZsb2F0MzJcIn1mdW5jdGlvbiBnZXRTb3VyY2VJbnB1dHMoZSx0LG4pe2lmKChudWxsPT10fHxudWxsIT1uJiZuPjApJiYodD1lLnNvdXJjZUxheWVyLG49ZS5ub2RlSW5kZXgpLDA9PT10LmluYm91bmROb2Rlcy5sZW5ndGgpcmV0dXJuW2VdO3ZhciByPXQuaW5ib3VuZE5vZGVzW25dO2lmKDA9PT1yLmluYm91bmRMYXllcnMubGVuZ3RoKXJldHVybiByLmlucHV0VGVuc29ycztmb3IodmFyIGk9W10sYT0wO2E8ci5pbmJvdW5kTGF5ZXJzLmxlbmd0aDthKyspZm9yKHZhciBvPTAscz1nZXRTb3VyY2VJbnB1dHMoci5pbnB1dFRlbnNvcnNbYV0sci5pbmJvdW5kTGF5ZXJzW2FdLHIubm9kZUluZGljZXNbYV0pO288cy5sZW5ndGg7bysrKXt2YXIgbD1zW29dOy0xPT09aS5pbmRleE9mKGwpJiZpLnB1c2gobCl9cmV0dXJuIGl9dmFyIE1vZGVsTG9nZ2luZ1ZlcmJvc2l0eSxJbnB1dExheWVyPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMse2R0eXBlOnQuZHR5cGUsbmFtZTpudWxsIT10Lm5hbWU/dC5uYW1lOmdldFVpZChcImlucHV0XCIpLnRvU3RyaW5nKCl9KXx8dGhpcztpZihudWxsPT10LmJhdGNoU2l6ZSYmKHQuYmF0Y2hTaXplPW51bGwpLG51bGw9PXQuc3BhcnNlJiYodC5zcGFyc2U9ITEpLG4udHJhaW5hYmxlPSExLG4uYnVpbHQ9ITAsbi5zcGFyc2U9dC5zcGFyc2UsbnVsbCE9dC5pbnB1dFNoYXBlJiZudWxsIT10LmJhdGNoSW5wdXRTaGFwZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIk9ubHkgcHJvdmlkZSB0aGUgaW5wdXRTaGFwZSBPUiBiYXRjaElucHV0U2hhcGUgYXJndW1lbnQgdG8gaW5wdXRMYXllciwgbm90IGJvdGggYXQgdGhlIHNhbWUgdGltZS5cIik7dmFyIHI9dC5iYXRjaElucHV0U2hhcGU7aWYobnVsbD09cil7aWYobnVsbD09dC5pbnB1dFNoYXBlKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQW4gSW5wdXRMYXllciBzaG91bGQgYmUgcGFzc2VkIGVpdGhlciBhIGBiYXRjaElucHV0U2hhcGVgIG9yIGFuIGBpbnB1dFNoYXBlYC5cIik7cj1bdC5iYXRjaFNpemVdLmNvbmNhdCh0LmlucHV0U2hhcGUpfWVsc2UgaWYobnVsbCE9dC5iYXRjaFNpemUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDYW5ub3Qgc3BlY2lmeSBiYXRjaFNpemUgaWYgYmF0Y2hJbnB1dFNoYXBlIGlzIHNwZWNpZmllZCB3aGVuIGNyZWF0aW5nIGFuIElucHV0TGF5ZXIuXCIpO3ZhciBpPXQuZHR5cGV8fFwiZmxvYXQzMlwiO24uYmF0Y2hJbnB1dFNoYXBlPXIsbi5kdHlwZT1pLG4uaW5wdXRTcGVjPVt7c2hhcGU6cn1dO3ZhciBhPW5ldyBTeW1ib2xpY1RlbnNvcihuLmR0eXBlLG4uYmF0Y2hJbnB1dFNoYXBlLG4sW10se30sbi5uYW1lKTtyZXR1cm4gYS5ub2RlSW5kZXg9MCxhLnRlbnNvckluZGV4PTAsbmV3IE5vZGUoe291dGJvdW5kTGF5ZXI6bixpbmJvdW5kTGF5ZXJzOltdLG5vZGVJbmRpY2VzOltdLHRlbnNvckluZGljZXM6W10saW5wdXRUZW5zb3JzOlthXSxvdXRwdXRUZW5zb3JzOlthXSxpbnB1dE1hc2tzOltudWxsXSxvdXRwdXRNYXNrczpbbnVsbF0saW5wdXRTaGFwZXM6W3JdLG91dHB1dFNoYXBlczpbcl19KSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlLHQpe3Rocm93IG5ldyBWYWx1ZUVycm9yKFwiQ2Fubm90IHBhc3MgYW55IGlucHV0IHRvIGFuIElucHV0TGF5ZXIncyBhcHBseSgpIG1ldGhvZC4gSW5wdXRMYXllciBuYW1lOiBcIit0aGlzLm5hbWUpfSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7cmV0dXJue3JlZkNvdW50QWZ0ZXJEaXNwb3NlOnRoaXMuX3JlZkNvdW50LG51bURpc3Bvc2VkVmFyaWFibGVzOjB9fSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57YmF0Y2hJbnB1dFNoYXBlOnRoaXMuYmF0Y2hJbnB1dFNoYXBlLGR0eXBlOnRoaXMuZHR5cGUsc3BhcnNlOnRoaXMuc3BhcnNlLG5hbWU6dGhpcy5uYW1lfX0sdC5jbGFzc05hbWU9XCJJbnB1dExheWVyXCIsdH0oTGF5ZXIpO2Z1bmN0aW9uIElucHV0KGUpe2lmKG51bGw9PWUuYmF0Y2hTaGFwZSYmbnVsbD09ZS5zaGFwZSl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSB0byBJbnB1dCBlaXRoZXIgYSBgc2hhcGVgIG9yIGEgYGJhdGNoU2hhcGVgIGFyZ3VtZW50LiBOb3RlIHRoYXQgYHNoYXBlYCBkb2VzIG5vdCBpbmNsdWRlIHRoZSBiYXRjaCBkaW1lbnNpb24uXCIpO2lmKG51bGwhPWUuYmF0Y2hTaGFwZSYmbnVsbCE9ZS5zaGFwZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlBsZWFzZSBwcm92aWRlIGVpdGhlciBhIGBzaGFwZWAgb3IgYGJhdGNoU2hhcGVgIGFyZ3VtZW50IHRvIElucHV0LCBidXQgbm90IGJvdGguXCIpO3ZhciB0PWUuYmF0Y2hTaGFwZTtudWxsIT1lLnNoYXBlJiZudWxsPT10JiYodD1bbnVsbF0uY29uY2F0KGUuc2hhcGUpKTt2YXIgbj1lLmR0eXBlO3JldHVybiBudWxsPT1uJiYobj1cImZsb2F0MzJcIiksbmV3IElucHV0TGF5ZXIoe2JhdGNoSW5wdXRTaGFwZTp0LG5hbWU6ZS5uYW1lLGR0eXBlOm4sc3BhcnNlOmUuc3BhcnNlfSkuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFRlbnNvcnNbMF19ZnVuY3Rpb24gcmVzb2x2ZVNjYWxhcnNJbkxvZ3MoZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxuLHIsaSxhLG8scyxsO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHUpe3N3aXRjaCh1LmxhYmVsKXtjYXNlIDA6aWYobnVsbD09ZSlyZXR1cm5bMl07Zm9yKGkgaW4gdD1bXSxuPVtdLHI9W10sZSlcIm51bWJlclwiIT10eXBlb2YoYT1lW2ldKSYmKG89YSx0LnB1c2goby5kYXRhKCkpLG4ucHVzaChpKSxyLnB1c2gobykpO3JldHVybiB0Lmxlbmd0aD4wP1s0LFByb21pc2UuYWxsKHQpXTpbMywyXTtjYXNlIDE6Zm9yKHM9dS5zZW50KCksbD0wO2w8cy5sZW5ndGg7KytsKWVbbltsXV09c1tsXVswXTtkaXNwb3NlKHIpLHUubGFiZWw9MjtjYXNlIDI6cmV0dXJuWzJdfX0pfSl9ZnVuY3Rpb24gZGlzcG9zZVRlbnNvcnNJbkxvZ3MoZSl7aWYobnVsbCE9ZSlmb3IodmFyIHQgaW4gZSl7dmFyIG49ZVt0XTtcIm51bWJlclwiIT10eXBlb2YgbiYmbi5kaXNwb3NlKCl9fXNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhJbnB1dExheWVyKSxmdW5jdGlvbihlKXtlW2UuU0lMRU5UPTBdPVwiU0lMRU5UXCIsZVtlLlZFUkJPU0U9MV09XCJWRVJCT1NFXCJ9KE1vZGVsTG9nZ2luZ1ZlcmJvc2l0eXx8KE1vZGVsTG9nZ2luZ1ZlcmJvc2l0eT17fSkpO3ZhciBERUZBVUxUX1lJRUxEX0VWRVJZX01TPTEyNSxCYXNlQ2FsbGJhY2s9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7dGhpcy52YWxpZGF0aW9uRGF0YT1udWxsfXJldHVybiBlLnByb3RvdHlwZS5zZXRQYXJhbXM9ZnVuY3Rpb24oZSl7dGhpcy5wYXJhbXM9ZX0sZS5wcm90b3R5cGUub25FcG9jaEJlZ2luPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm5bMl19KX0pfSxlLnByb3RvdHlwZS5vbkVwb2NoRW5kPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm5bMl19KX0pfSxlLnByb3RvdHlwZS5vbkJhdGNoQmVnaW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVyblsyXX0pfSl9LGUucHJvdG90eXBlLm9uQmF0Y2hFbmQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVyblsyXX0pfSl9LGUucHJvdG90eXBlLm9uVHJhaW5CZWdpbj1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVyblsyXX0pfSl9LGUucHJvdG90eXBlLm9uVHJhaW5FbmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm5bMl19KX0pfSxlLnByb3RvdHlwZS5zZXRNb2RlbD1mdW5jdGlvbihlKXt9LGV9KCksQ2FsbGJhY2tMaXN0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3ZvaWQgMD09PXQmJih0PTEwKSxudWxsPT1lJiYoZT1bXSksdGhpcy5jYWxsYmFja3M9ZSx0aGlzLnF1ZXVlTGVuZ3RoPXR9cmV0dXJuIGUucHJvdG90eXBlLmFwcGVuZD1mdW5jdGlvbihlKXt0aGlzLmNhbGxiYWNrcy5wdXNoKGUpfSxlLnByb3RvdHlwZS5zZXRQYXJhbXM9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTAsbj10aGlzLmNhbGxiYWNrczt0PG4ubGVuZ3RoO3QrKyl7blt0XS5zZXRQYXJhbXMoZSl9fSxlLnByb3RvdHlwZS5zZXRNb2RlbD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9MCxuPXRoaXMuY2FsbGJhY2tzO3Q8bi5sZW5ndGg7dCsrKXtuW3RdLnNldE1vZGVsKGUpfX0sZS5wcm90b3R5cGUub25FcG9jaEJlZ2luPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbixyO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGkpe3N3aXRjaChpLmxhYmVsKXtjYXNlIDA6bnVsbD09dCYmKHQ9e30pLG49MCxyPXRoaXMuY2FsbGJhY2tzLGkubGFiZWw9MTtjYXNlIDE6cmV0dXJuIG48ci5sZW5ndGg/WzQscltuXS5vbkVwb2NoQmVnaW4oZSx0KV06WzMsNF07Y2FzZSAyOmkuc2VudCgpLGkubGFiZWw9MztjYXNlIDM6cmV0dXJuIG4rKyxbMywxXTtjYXNlIDQ6cmV0dXJuWzJdfX0pfSl9LGUucHJvdG90eXBlLm9uRXBvY2hFbmQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBuLHI7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oaSl7c3dpdGNoKGkubGFiZWwpe2Nhc2UgMDpudWxsPT10JiYodD17fSksbj0wLHI9dGhpcy5jYWxsYmFja3MsaS5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gbjxyLmxlbmd0aD9bNCxyW25dLm9uRXBvY2hFbmQoZSx0KV06WzMsNF07Y2FzZSAyOmkuc2VudCgpLGkubGFiZWw9MztjYXNlIDM6cmV0dXJuIG4rKyxbMywxXTtjYXNlIDQ6cmV0dXJuWzJdfX0pfSl9LGUucHJvdG90eXBlLm9uQmF0Y2hCZWdpbj1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIG4scjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihpKXtzd2l0Y2goaS5sYWJlbCl7Y2FzZSAwOm51bGw9PXQmJih0PXt9KSxuPTAscj10aGlzLmNhbGxiYWNrcyxpLmxhYmVsPTE7Y2FzZSAxOnJldHVybiBuPHIubGVuZ3RoP1s0LHJbbl0ub25CYXRjaEJlZ2luKGUsdCldOlszLDRdO2Nhc2UgMjppLnNlbnQoKSxpLmxhYmVsPTM7Y2FzZSAzOnJldHVybiBuKyssWzMsMV07Y2FzZSA0OnJldHVyblsyXX19KX0pfSxlLnByb3RvdHlwZS5vbkJhdGNoRW5kPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbixyO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGkpe3N3aXRjaChpLmxhYmVsKXtjYXNlIDA6bnVsbD09dCYmKHQ9e30pLG49MCxyPXRoaXMuY2FsbGJhY2tzLGkubGFiZWw9MTtjYXNlIDE6cmV0dXJuIG48ci5sZW5ndGg/WzQscltuXS5vbkJhdGNoRW5kKGUsdCldOlszLDRdO2Nhc2UgMjppLnNlbnQoKSxpLmxhYmVsPTM7Y2FzZSAzOnJldHVybiBuKyssWzMsMV07Y2FzZSA0OnJldHVyblsyXX19KX0pfSxlLnByb3RvdHlwZS5vblRyYWluQmVnaW49ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgdCxuO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6bnVsbD09ZSYmKGU9e30pLHQ9MCxuPXRoaXMuY2FsbGJhY2tzLHIubGFiZWw9MTtjYXNlIDE6cmV0dXJuIHQ8bi5sZW5ndGg/WzQsblt0XS5vblRyYWluQmVnaW4oZSldOlszLDRdO2Nhc2UgMjpyLnNlbnQoKSxyLmxhYmVsPTM7Y2FzZSAzOnJldHVybiB0KyssWzMsMV07Y2FzZSA0OnJldHVyblsyXX19KX0pfSxlLnByb3RvdHlwZS5vblRyYWluRW5kPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQsbjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOm51bGw9PWUmJihlPXt9KSx0PTAsbj10aGlzLmNhbGxiYWNrcyxyLmxhYmVsPTE7Y2FzZSAxOnJldHVybiB0PG4ubGVuZ3RoP1s0LG5bdF0ub25UcmFpbkVuZChlKV06WzMsNF07Y2FzZSAyOnIuc2VudCgpLHIubGFiZWw9MztjYXNlIDM6cmV0dXJuIHQrKyxbMywxXTtjYXNlIDQ6cmV0dXJuWzJdfX0pfSl9LGV9KCksQmFzZUxvZ2dlcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIGUuY2FsbCh0aGlzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUub25FcG9jaEJlZ2luPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuc2Vlbj0wLHRoaXMudG90YWxzPXt9LFsyXX0pfSl9LHQucHJvdG90eXBlLm9uQmF0Y2hFbmQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLG4scixpLGE9dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihvKXtmb3IoaSBpbiBudWxsPT10JiYodD17fSksZT1udWxsPT10LnNpemU/MDp0LnNpemUsdGhpcy5zZWVuKz1lLG49ZnVuY3Rpb24obil7dmFyIGk9dFtuXTtpZihcIm51bWJlclwiPT10eXBlb2YgaSlyLnRvdGFscy5oYXNPd25Qcm9wZXJ0eShuKXx8KHIudG90YWxzW25dPTApLHIudG90YWxzW25dPXIudG90YWxzW25dK2kqZTtlbHNle3ZhciBvPXZvaWQgMDtuIGluIHIudG90YWxzP289ci50b3RhbHNbbl06ci50b3RhbHNbbl09MCxyLnRvdGFsc1tuXT10aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGFkZChhLnRvdGFsc1tuXSxtdWwoaSxlKSl9KSxudWxsIT1vJiZvLmRpc3Bvc2UoKX19LHI9dGhpcyx0KW4oaSk7cmV0dXJuWzJdfSl9KX0sdC5wcm90b3R5cGUub25FcG9jaEVuZD1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsbixyLGksYSxvPXRoaXM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocyl7aWYobnVsbCE9dClmb3IoZT1mdW5jdGlvbihlKXtpZihudWxsPT1uLnRvdGFsc1tlXSlyZXR1cm5cImNvbnRpbnVlXCI7XCJudW1iZXJcIj09dHlwZW9mIG4udG90YWxzW2VdP3RbZV09bi50b3RhbHNbZV0vbi5zZWVuOnRpZHkoZnVuY3Rpb24oKXt0W2VdPW11bChkaXYoMSxvLnNlZW4pLG8udG90YWxzW2VdKSxvLnRvdGFsc1tlXS5kaXNwb3NlKCksa2VlcCh0W2VdKX0pfSxuPXRoaXMscj0wLGk9dGhpcy5wYXJhbXMubWV0cmljcztyPGkubGVuZ3RoO3IrKylhPWlbcl0sZShhKTtyZXR1cm5bMl19KX0pfSx0fShCYXNlQ2FsbGJhY2spLEhpc3Rvcnk9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLm9uVHJhaW5CZWdpbj1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVwb2NoPVtdLHRoaXMuaGlzdG9yeT17fSxbMl19KX0pfSx0LnByb3RvdHlwZS5vbkVwb2NoRW5kPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtmb3IobiBpbiBudWxsPT10JiYodD17fSksdGhpcy5lcG9jaC5wdXNoKGUpLHQpbnVsbD09dGhpcy5oaXN0b3J5W25dJiYodGhpcy5oaXN0b3J5W25dPVtdKSx0aGlzLmhpc3Rvcnlbbl0ucHVzaCh0W25dKTtyZXR1cm5bMl19KX0pfSx0LnByb3RvdHlwZS5zeW5jRGF0YT1mdW5jdGlvbigpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIGUsdCxuLHIsaSxhLG8scyxsO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHUpe3N3aXRjaCh1LmxhYmVsKXtjYXNlIDA6Zm9yKHIgaW4gZT1bXSx0PVtdLG49W10sdGhpcy5oaXN0b3J5KWZvcihpPXRoaXMuaGlzdG9yeVtyXSxhPTA7YTxpLmxlbmd0aDsrK2EpXCJudW1iZXJcIiE9dHlwZW9mIGlbYV0mJihvPWlbYV0sZS5wdXNoKG8uZGF0YSgpKSx0LnB1c2gociksbi5wdXNoKGEpKTtyZXR1cm5bNCxQcm9taXNlLmFsbChlKV07Y2FzZSAxOmZvcihzPXUuc2VudCgpLGw9MDtsPHMubGVuZ3RoOysrbCl0aGlzLmhpc3RvcnlbdFtsXV1bbltsXV0uZGlzcG9zZSgpLHRoaXMuaGlzdG9yeVt0W2xdXVtuW2xdXT1zW2xdWzBdO3JldHVyblsyXX19KX0pfSx0fShCYXNlQ2FsbGJhY2spLEN1c3RvbUNhbGxiYWNrPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCxuKXt2YXIgcj1lLmNhbGwodGhpcyl8fHRoaXM7aWYoci5jdXJyZW50RXBvY2g9MCxyLnlpZWxkRXZlcnk9bnx8XCJhdXRvXCIsXCJhdXRvXCI9PT1yLnlpZWxkRXZlcnkmJihyLnlpZWxkRXZlcnk9REVGQVVMVF9ZSUVMRF9FVkVSWV9NUyksXCJuZXZlclwiPT09ci55aWVsZEV2ZXJ5JiZudWxsIT10Lm9uWWllbGQpdGhyb3cgbmV3IEVycm9yKFwieWllbGRFdmVyeSBpcyBgbmV2ZXJgIGJ1dCB5b3UgcHJvdmlkZWQgYW4gYG9uWWllbGRgIGNhbGxiYWNrLiBFaXRoZXIgY2hhbmdlIGB5aWVsZEV2ZXJ5YCBvciByZW1vdmUgdGhlIGNhbGxiYWNrXCIpO3JldHVybiB1dGlsLmlzTnVtYmVyKHIueWllbGRFdmVyeSkmJihyLm1heWJlV2FpdD1kZWJvdW5jZShyLm1heWJlV2FpdC5iaW5kKHIpLHIueWllbGRFdmVyeSkpLHIudHJhaW5CZWdpbj10Lm9uVHJhaW5CZWdpbixyLnRyYWluRW5kPXQub25UcmFpbkVuZCxyLmVwb2NoQmVnaW49dC5vbkVwb2NoQmVnaW4sci5lcG9jaEVuZD10Lm9uRXBvY2hFbmQsci5iYXRjaEJlZ2luPXQub25CYXRjaEJlZ2luLHIuYmF0Y2hFbmQ9dC5vbkJhdGNoRW5kLHIueWllbGQ9dC5vbllpZWxkLHJ9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLm1heWJlV2FpdD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgcjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihpKXtzd2l0Y2goaS5sYWJlbCl7Y2FzZSAwOnJldHVybiByPVtdLG51bGw9PXRoaXMueWllbGQ/WzMsMl06WzQscmVzb2x2ZVNjYWxhcnNJbkxvZ3MobildO2Nhc2UgMTppLnNlbnQoKSxyLnB1c2godGhpcy55aWVsZChlLHQsbikpLGkubGFiZWw9MjtjYXNlIDI6cmV0dXJuIHIucHVzaChuZXh0RnJhbWUoKSksWzQsUHJvbWlzZS5hbGwocildO2Nhc2UgMzpyZXR1cm4gaS5zZW50KCksWzJdfX0pfSl9LHQucHJvdG90eXBlLm9uRXBvY2hCZWdpbj1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm4gdGhpcy5jdXJyZW50RXBvY2g9ZSxudWxsPT10aGlzLmVwb2NoQmVnaW4/WzMsM106WzQscmVzb2x2ZVNjYWxhcnNJbkxvZ3ModCldO2Nhc2UgMTpyZXR1cm4gbi5zZW50KCksWzQsdGhpcy5lcG9jaEJlZ2luKGUsdCldO2Nhc2UgMjpuLnNlbnQoKSxuLmxhYmVsPTM7Y2FzZSAzOnJldHVyblsyXX19KX0pfSx0LnByb3RvdHlwZS5vbkVwb2NoRW5kPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybiBuPVtdLG51bGw9PXRoaXMuZXBvY2hFbmQ/WzMsMl06WzQscmVzb2x2ZVNjYWxhcnNJbkxvZ3ModCldO2Nhc2UgMTpyLnNlbnQoKSxuLnB1c2godGhpcy5lcG9jaEVuZChlLHQpKSxyLmxhYmVsPTI7Y2FzZSAyOnJldHVyblwiZXBvY2hcIj09PXRoaXMueWllbGRFdmVyeSYmbi5wdXNoKG5leHRGcmFtZSgpKSxbNCxQcm9taXNlLmFsbChuKV07Y2FzZSAzOnJldHVybiByLnNlbnQoKSxbMl19fSl9KX0sdC5wcm90b3R5cGUub25CYXRjaEJlZ2luPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihuKXtzd2l0Y2gobi5sYWJlbCl7Y2FzZSAwOnJldHVybiBudWxsPT10aGlzLmJhdGNoQmVnaW4/WzMsM106WzQscmVzb2x2ZVNjYWxhcnNJbkxvZ3ModCldO2Nhc2UgMTpyZXR1cm4gbi5zZW50KCksWzQsdGhpcy5iYXRjaEJlZ2luKGUsdCldO2Nhc2UgMjpuLnNlbnQoKSxuLmxhYmVsPTM7Y2FzZSAzOnJldHVyblsyXX19KX0pfSx0LnByb3RvdHlwZS5vbkJhdGNoRW5kPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybiBuPVtdLG51bGw9PXRoaXMuYmF0Y2hFbmQ/WzMsMl06WzQscmVzb2x2ZVNjYWxhcnNJbkxvZ3ModCldO2Nhc2UgMTpyLnNlbnQoKSxuLnB1c2godGhpcy5iYXRjaEVuZChlLHQpKSxyLmxhYmVsPTI7Y2FzZSAyOnJldHVyblwiYmF0Y2hcIj09PXRoaXMueWllbGRFdmVyeT9uLnB1c2gobmV4dEZyYW1lKCkpOnV0aWwuaXNOdW1iZXIodGhpcy55aWVsZEV2ZXJ5KSYmbi5wdXNoKHRoaXMubWF5YmVXYWl0KHRoaXMuY3VycmVudEVwb2NoLGUsdCkpLFs0LFByb21pc2UuYWxsKG4pXTtjYXNlIDM6cmV0dXJuIHIuc2VudCgpLFsyXX19KX0pfSx0LnByb3RvdHlwZS5vblRyYWluQmVnaW49ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih0KXtzd2l0Y2godC5sYWJlbCl7Y2FzZSAwOnJldHVybiBudWxsPT10aGlzLnRyYWluQmVnaW4/WzMsM106WzQscmVzb2x2ZVNjYWxhcnNJbkxvZ3MoZSldO2Nhc2UgMTpyZXR1cm4gdC5zZW50KCksWzQsdGhpcy50cmFpbkJlZ2luKGUpXTtjYXNlIDI6dC5zZW50KCksdC5sYWJlbD0zO2Nhc2UgMzpyZXR1cm5bMl19fSl9KX0sdC5wcm90b3R5cGUub25UcmFpbkVuZD1mdW5jdGlvbihlKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6cmV0dXJuIG51bGw9PXRoaXMudHJhaW5FbmQ/WzMsM106WzQscmVzb2x2ZVNjYWxhcnNJbkxvZ3MoZSldO2Nhc2UgMTpyZXR1cm4gdC5zZW50KCksWzQsdGhpcy50cmFpbkVuZChlKV07Y2FzZSAyOnQuc2VudCgpLHQubGFiZWw9MztjYXNlIDM6cmV0dXJuWzJdfX0pfSl9LHR9KEJhc2VDYWxsYmFjayk7ZnVuY3Rpb24gc3RhbmRhcmRpemVDYWxsYmFja3MoZSx0KXtyZXR1cm4gbnVsbD09ZSYmKGU9e30pLGUgaW5zdGFuY2VvZiBCYXNlQ2FsbGJhY2s/W2VdOkFycmF5LmlzQXJyYXkoZSkmJmVbMF1pbnN0YW5jZW9mIEJhc2VDYWxsYmFjaz9lOnRvTGlzdChlKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBDdXN0b21DYWxsYmFjayhlLHQpfSl9dmFyIENhbGxiYWNrQ29uc3RydWN0b3JSZWdpc3RyeT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt9cmV0dXJuIGUucmVnaXN0ZXJDYWxsYmFja0NvbnN0cnVjdG9yPWZ1bmN0aW9uKHQsbil7dXRpbC5hc3NlcnQodD49MCYmTnVtYmVyLmlzSW50ZWdlcih0KSxmdW5jdGlvbigpe3JldHVyblwiVmVyYm9zaXR5IGxldmVsIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGludGVnZXIgPj0gMCwgYnV0IGdvdCBcIit0fSksZS5jaGVja0ZvckR1cGxpY2F0ZShuKSxudWxsPT1lLmNvbnN0cnVjdG9yc1t0XSYmKGUuY29uc3RydWN0b3JzW3RdPVtdKSxlLmNvbnN0cnVjdG9yc1t0XS5wdXNoKG4pfSxlLmNoZWNrRm9yRHVwbGljYXRlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgbiBpbiBlLmNvbnN0cnVjdG9ycyl7ZS5jb25zdHJ1Y3RvcnNbK25dLmZvckVhY2goZnVuY3Rpb24oZSl7aWYoZT09PXQpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJEdXBsaWNhdGUgY2FsbGJhY2sgY29uc3RydWN0b3IuXCIpfSl9fSxlLmNsZWFyPWZ1bmN0aW9uKCl7ZS5jb25zdHJ1Y3RvcnM9e319LGUuY3JlYXRlQ2FsbGJhY2tzPWZ1bmN0aW9uKHQpe3ZhciBuPVtdO2Zvcih2YXIgciBpbiBlLmNvbnN0cnVjdG9ycyl7dmFyIGk9K3I7dD49aSYmbi5wdXNoLmFwcGx5KG4sZS5jb25zdHJ1Y3RvcnNbaV0pfXJldHVybiBuLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gbmV3IGV9KX0sZS5jb25zdHJ1Y3RvcnM9e30sZX0oKTtmdW5jdGlvbiBjb25maWd1cmVDYWxsYmFja3MoZSx0LG4scixpLGEsbyxzLGwpe3ZhciB1PW5ldyBIaXN0b3J5LGM9W25ldyBCYXNlTG9nZ2VyXS5jb25jYXQoQ2FsbGJhY2tDb25zdHJ1Y3RvclJlZ2lzdHJ5LmNyZWF0ZUNhbGxiYWNrcyh0KSk7bnVsbCE9ZSYmYy5wdXNoLmFwcGx5KGMsZSksYy5wdXNoKHUpO3ZhciBwPW5ldyBDYWxsYmFja0xpc3QoYyk7cmV0dXJuIHAuc2V0UGFyYW1zKHtlcG9jaHM6bixpbml0aWFsRXBvY2g6cixzYW1wbGVzOmksc3RlcHM6YSxiYXRjaFNpemU6byx2ZXJib3NlOnQsZG9WYWxpZGF0aW9uOnMsbWV0cmljczpsfSkse2NhbGxiYWNrTGlzdDpwLGhpc3Rvcnk6dX19ZnVuY3Rpb24gbDJOb3JtYWxpemUoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe1wiZmxvYXQzMlwiIT09ZS5kdHlwZSYmKGU9ZS5hc1R5cGUoXCJmbG9hdDMyXCIpKTt2YXIgbj1zdW0oc3F1YXJlKGUpLHQsITApLHI9ZmlsbChuLnNoYXBlLGVwc2lsb24oKSksaT1zcXJ0KG1heGltdW0obixyKSk7cmV0dXJuIGRpdihlLGkpfSl9ZnVuY3Rpb24gbWVhblNxdWFyZWRFcnJvcihlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIG1lYW4oc3F1YXJlKHN1Yih0LGUpKSwtMSl9KX1mdW5jdGlvbiBtZWFuQWJzb2x1dGVFcnJvcihlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIG1lYW4oYWJzKHN1Yih0LGUpKSwtMSl9KX1mdW5jdGlvbiBtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3IoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPXN1YihlLHQpLHI9Y2xpcEJ5VmFsdWUoYWJzKGUpLGVwc2lsb24oKSxOdW1iZXIuTUFYX1ZBTFVFKSxpPWFicyhkaXYobixyKSk7cmV0dXJuIG11bCgxMDAsbWVhbihpLC0xKSl9KX1mdW5jdGlvbiBtZWFuU3F1YXJlZExvZ2FyaXRobWljRXJyb3IoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPWNsaXBCeVZhbHVlKHQsZXBzaWxvbigpLE51bWJlci5NQVhfVkFMVUUpLHI9bG9nKGFkZCgxLG4pKSxpPWNsaXBCeVZhbHVlKGUsZXBzaWxvbigpLE51bWJlci5NQVhfVkFMVUUpLGE9bG9nKGFkZCgxLGkpKTtyZXR1cm4gbWVhbihzcXVhcmUoc3ViKHIsYSkpLC0xKX0pfWZ1bmN0aW9uIHNxdWFyZWRIaW5nZShlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49bWF4aW11bSgwLHN1YigxLG11bChlLHQpKSk7cmV0dXJuIG1lYW4oc3F1YXJlKG4pLC0xKX0pfWZ1bmN0aW9uIGhpbmdlKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj1tYXhpbXVtKDAsc3ViKDEsbXVsKGUsdCkpKTtyZXR1cm4gbWVhbihuLC0xKX0pfWZ1bmN0aW9uIGNhdGVnb3JpY2FsSGluZ2UoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPXN1bShtdWwoZSx0KSwtMSkscj1tYXgobXVsKHN1YigxLGUpLHQpLC0xKTtyZXR1cm4gbWF4aW11bSgwLGFkZCgxLHN1YihyLG4pKSl9KX1mdW5jdGlvbiBsb2djb3NoKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj1NYXRoLmxvZygyKSxyPXN1Yih0LGUpLGk9c3ViKGFkZChyLHNvZnRwbHVzKG11bCgtMixyKSkpLG4pO3JldHVybiBtZWFuKGksLTEpfSl9ZnVuY3Rpb24gY2F0ZWdvcmljYWxDcm9zc2VudHJvcHkoZSx0LG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0hMSksdGlkeShmdW5jdGlvbigpe2lmKG4pdD1zb2Z0bWF4KHQpO2Vsc2V7dmFyIHI9c3VtKHQsdC5zaGFwZS5sZW5ndGgtMSwhMCk7dD1kaXYodCxyKX1yZXR1cm4gdD1jbGlwQnlWYWx1ZSh0LGVwc2lsb24oKSwxLWVwc2lsb24oKSksbmVnKHN1bShtdWwoZS50b0Zsb2F0KCksbG9nKHQpKSx0LnNoYXBlLmxlbmd0aC0xKSl9KX1mdW5jdGlvbiBzcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weShlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49Zmxvb3IoZmxhdHRlbihlKSkudG9JbnQoKSxyPSh0PWNsaXBCeVZhbHVlKHQsZXBzaWxvbigpLDEtZXBzaWxvbigpKSkuc2hhcGU7cmV0dXJuIGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5KG9uZUhvdChuLHJbci5sZW5ndGgtMV0pLnJlc2hhcGUociksdCwhMSl9KX1mdW5jdGlvbiBzaWdtb2lkQ3Jvc3NFbnRyb3B5V2l0aExvZ2l0cyhlLHQpe2lmKCF1dGlsLmFycmF5c0VxdWFsKGUuc2hhcGUsdC5zaGFwZSkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJsb2dpdHMgYW5kIGxhYmVscyBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGUsIGJ1dCBnb3Qgc2hhcGVzIFwiK0pTT04uc3RyaW5naWZ5KGUuc2hhcGUpK1wiIGFuZCBcIitKU09OLnN0cmluZ2lmeSh0LnNoYXBlKSk7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj10LnJlbHUoKSxyPXQuYWJzKCkubmVnKCk7cmV0dXJuIG4uc3ViKHQubXVsKGUpKS5hZGQoci5leHAoKS5sb2cxcCgpKX0pfWZ1bmN0aW9uIGJpbmFyeUNyb3NzZW50cm9weShlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49Y2xpcEJ5VmFsdWUodCxlcHNpbG9uKCksMS1lcHNpbG9uKCkpLG49bG9nKGRpdihuLHN1YigxLG4pKSksbWVhbihzaWdtb2lkQ3Jvc3NFbnRyb3B5V2l0aExvZ2l0cyhlLG4pLC0xKX0pfWZ1bmN0aW9uIGt1bGxiYWNrTGVpYmxlckRpdmVyZ2VuY2UoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPWNsaXBCeVZhbHVlKGUsZXBzaWxvbigpLDEpLHI9Y2xpcEJ5VmFsdWUodCxlcHNpbG9uKCksMSk7cmV0dXJuIHN1bShtdWwoZSxsb2coZGl2KG4scikpKSwtMSl9KX1mdW5jdGlvbiBwb2lzc29uKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj1sb2coYWRkKGVwc2lsb24oKSx0KSk7cmV0dXJuIG1lYW4oc3ViKHQsbXVsKGUsbikpLC0xKX0pfWZ1bmN0aW9uIGNvc2luZVByb3hpbWl0eShlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49bDJOb3JtYWxpemUoZSwtMSkscj1sMk5vcm1hbGl6ZSh0LC0xKSxpPW11bChuLHIpO3JldHVybiBuZWcoc3VtKGksLTEpKX0pfWZ1bmN0aW9uIGdldChlKXt2YXIgdD17bWVhblNxdWFyZWRFcnJvcjptZWFuU3F1YXJlZEVycm9yLG1lYW5BYnNvbHV0ZUVycm9yOm1lYW5BYnNvbHV0ZUVycm9yLG1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcjptZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3IsbWVhblNxdWFyZWRMb2dhcml0aG1pY0Vycm9yOm1lYW5TcXVhcmVkTG9nYXJpdGhtaWNFcnJvcixzcXVhcmVkSGluZ2U6c3F1YXJlZEhpbmdlLGhpbmdlOmhpbmdlLGNhdGVnb3JpY2FsSGluZ2U6Y2F0ZWdvcmljYWxIaW5nZSxsb2djb3NoOmxvZ2Nvc2gsY2F0ZWdvcmljYWxDcm9zc2VudHJvcHk6Y2F0ZWdvcmljYWxDcm9zc2VudHJvcHksc3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHk6c3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHksYmluYXJ5Q3Jvc3NlbnRyb3B5OmJpbmFyeUNyb3NzZW50cm9weSxrdWxsYmFja0xlaWJsZXJEaXZlcmdlbmNlOmt1bGxiYWNrTGVpYmxlckRpdmVyZ2VuY2UscG9pc3Nvbjpwb2lzc29uLGNvc2luZVByb3hpbWl0eTpjb3NpbmVQcm94aW1pdHl9O2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXtpZihlIGluIHQpcmV0dXJuIHRbZV07dmFyIG49XCJVbmtub3duIGxvc3MgXCIrZTt0aHJvdyBlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJzb2Z0bWF4Y3Jvc3NlbnRyb3B5XCIpJiYobj1cIlVua25vd24gbG9zcyBcIitlKycuIFVzZSBcImNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5XCIgYXMgdGhlIHN0cmluZyBuYW1lIGZvciB0Zi5sb3NzZXMuc29mdG1heENyb3NzRW50cm9weScpLG5ldyBWYWx1ZUVycm9yKG4pfXJldHVybiBlfWZ1bmN0aW9uIGJpbmFyeUFjY3VyYWN5KGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj1tdWwoLjUsb25lc0xpa2UodCkpLHI9Y2FzdCQxKGdyZWF0ZXIodCxuKSxlLmR0eXBlKTtyZXR1cm4gbWVhbihlcXVhbChlLHIpLC0xKX0pfWZ1bmN0aW9uIGNhdGVnb3JpY2FsQWNjdXJhY3koZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBjYXN0JDEoZXF1YWwoYXJnTWF4KGUsLTEpLGFyZ01heCh0LC0xKSksXCJmbG9hdDMyXCIpfSl9ZnVuY3Rpb24gdHJ1ZVBvc2l0aXZlcyhlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGxvZ2ljYWxBbmQoZS5lcXVhbCgxKSx0LmVxdWFsKDEpKS5zdW0oKS5jYXN0KFwiZmxvYXQzMlwiKX0pfWZ1bmN0aW9uIGZhbHNlTmVnYXRpdmVzKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gbG9naWNhbEFuZChlLmVxdWFsKDEpLHQuZXF1YWwoMCkpLnN1bSgpLmNhc3QoXCJmbG9hdDMyXCIpfSl9ZnVuY3Rpb24gZmFsc2VQb3NpdGl2ZXMoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBsb2dpY2FsQW5kKGUuZXF1YWwoMCksdC5lcXVhbCgxKSkuc3VtKCkuY2FzdChcImZsb2F0MzJcIil9KX1mdW5jdGlvbiBwcmVjaXNpb24oZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuPXRydWVQb3NpdGl2ZXMoZSx0KSxyPWZhbHNlUG9zaXRpdmVzKGUsdCksaT1uLmFkZChyKTtyZXR1cm4gd2hlcmUoZ3JlYXRlcihpLDApLG4uZGl2KGkpLDApLmNhc3QoXCJmbG9hdDMyXCIpfSl9ZnVuY3Rpb24gcmVjYWxsKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj10cnVlUG9zaXRpdmVzKGUsdCkscj1mYWxzZU5lZ2F0aXZlcyhlLHQpLGk9bi5hZGQocik7cmV0dXJuIHdoZXJlKGdyZWF0ZXIoaSwwKSxuLmRpdihpKSwwKS5jYXN0KFwiZmxvYXQzMlwiKX0pfWZ1bmN0aW9uIGJpbmFyeUNyb3NzZW50cm9weSQxKGUsdCl7cmV0dXJuIGJpbmFyeUNyb3NzZW50cm9weShlLHQpfWZ1bmN0aW9uIHNwYXJzZUNhdGVnb3JpY2FsQWNjdXJhY3koZSx0KXtyZXR1cm4gZS5yYW5rPT09dC5yYW5rJiYoZT1lLnNxdWVlemUoW2UucmFuay0xXSkpLCh0PXQuYXJnTWF4KC0xKSkuZHR5cGUhPT1lLmR0eXBlJiYodD10LmFzVHlwZShlLmR0eXBlKSksZXF1YWwoZSx0KS5hc1R5cGUoXCJmbG9hdDMyXCIpfXZhciBtc2UkMT1tZWFuU3F1YXJlZEVycm9yLE1TRSQxPW1lYW5TcXVhcmVkRXJyb3IsbWFlJDE9bWVhbkFic29sdXRlRXJyb3IsTUFFJDE9bWVhbkFic29sdXRlRXJyb3IsbWFwZSQxPW1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcixNQVBFJDE9bWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yLGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5JDE9Y2F0ZWdvcmljYWxDcm9zc2VudHJvcHksY29zaW5lJDE9Y29zaW5lUHJveGltaXR5LHNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5JDE9c3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHk7ZnVuY3Rpb24gZ2V0JDEoZSl7dmFyIHQ9e2JpbmFyeUFjY3VyYWN5OmJpbmFyeUFjY3VyYWN5LGNhdGVnb3JpY2FsQWNjdXJhY3k6Y2F0ZWdvcmljYWxBY2N1cmFjeSxwcmVjaXNpb246cHJlY2lzaW9uLGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5OmNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5JDEsc3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHk6c3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHkkMSxtc2U6bXNlJDEsTVNFOk1TRSQxLG1hZTptYWUkMSxNQUU6TUFFJDEsbWFwZTptYXBlJDEsTUFQRTpNQVBFJDEsY29zaW5lOmNvc2luZSQxfTtpZihcInN0cmluZ1wiPT10eXBlb2YgZSYmZSBpbiB0KXJldHVybiB0W2VdO2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlJiZudWxsIT1lKXJldHVybiBlO3Rocm93IG5ldyBWYWx1ZUVycm9yKFwiVW5rbm93biBtZXRyaWMgXCIrZSl9ZnVuY3Rpb24gZ2V0T3B0aW1pemVyKGUpe3ZhciB0PXtBZGFncmFkOmZ1bmN0aW9uKCl7cmV0dXJuIHRyYWluLmFkYWdyYWQoLjAxKX0sQWRhZGVsdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdHJhaW4uYWRhZGVsdGEoMSwuOTUsZXBzaWxvbigpKX0sQWRhbTpmdW5jdGlvbigpe3JldHVybiB0cmFpbi5hZGFtKC4wMDEsLjksLjk5OSxlcHNpbG9uKCkpfSxBZGFtYXg6ZnVuY3Rpb24oKXtyZXR1cm4gdHJhaW4uYWRhbWF4KC4wMDIsLjksLjk5OSxlcHNpbG9uKCksMCl9LFJNU1Byb3A6ZnVuY3Rpb24oKXtyZXR1cm4gdHJhaW4ucm1zcHJvcCguMDAxLC45LDAsZXBzaWxvbigpKX0sU0dEOmZ1bmN0aW9uKCl7cmV0dXJuIHRyYWluLnNnZCguMDEpfX07aWYodC5hZGFncmFkPXQuQWRhZ3JhZCx0LmFkYWRlbHRhPXQuQWRhZGVsdGEsdC5hZGFtPXQuQWRhbSx0LmFkYW1heD10LkFkYW1heCx0LnJtc3Byb3A9dC5STVNQcm9wLHQuc2dkPXQuU0dELGUgaW4gdClyZXR1cm4gdFtlXSgpO3Rocm93IG5ldyBWYWx1ZUVycm9yKFwiVW5rbm93biBPcHRpbWl6ZXIgXCIrZSl9ZnVuY3Rpb24gcHJpbnRTdW1tYXJ5KGUsdCxuLHIpe3ZvaWQgMD09PXImJihyPWNvbnNvbGUubG9nKTt2YXIgaSxhPWlzTW9kZWxTZXF1ZW50aWFsTGlrZShlKSxvPVtcIkxheWVyICh0eXBlKVwiLFwiT3V0cHV0IHNoYXBlXCIsXCJQYXJhbSAjXCJdO2lmKGE/KHQ9dHx8NjUsbj1ufHxbLjQ1LC44NSwxXSk6KHQ9dHx8OTgsbj1ufHxbLjMzLC41NSwuNjcsMV0pLG5bbi5sZW5ndGgtMV08PTEmJihuPW4ubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBNYXRoLmZsb29yKHQqZSl9KSksIWEpZm9yKHZhciBzIGluIG8ucHVzaChcIlJlY2VpdmVzIGlucHV0c1wiKSxpPVtdLGUubm9kZXNCeURlcHRoKWkucHVzaC5hcHBseShpLGUubm9kZXNCeURlcHRoW3NdKTtyKFwiX1wiLnJlcGVhdCh0KSkscHJpbnRSb3cobyxuLHIpLHIoXCI9XCIucmVwZWF0KHQpKTtmb3IodmFyIGw9ZS5sYXllcnMsdT0wO3U8bC5sZW5ndGg7Kyt1KWE/cHJpbnRMYXllclN1bW1hcnkobFt1XSxuLHIpOnByaW50TGF5ZXJTdW1tYXJ5V2l0aENvbm5lY3Rpb25zKGxbdV0sbixpLHIpLHIoKHU9PT1sLmxlbmd0aC0xP1wiPVwiOlwiX1wiKS5yZXBlYXQodCkpO2UuY2hlY2tUcmFpbmFibGVXZWlnaHRzQ29uc2lzdGVuY3koKTt2YXIgYz1jb3VudFRyYWluYWJsZVBhcmFtcyhlKSxwPWNvdW50UGFyYW1zSW5XZWlnaHRzKGUubm9uVHJhaW5hYmxlV2VpZ2h0cyk7cihcIlRvdGFsIHBhcmFtczogXCIrKGMrcCkpLHIoXCJUcmFpbmFibGUgcGFyYW1zOiBcIitjKSxyKFwiTm9uLXRyYWluYWJsZSBwYXJhbXM6IFwiK3ApLHIoXCJfXCIucmVwZWF0KHQpKX1mdW5jdGlvbiBjb3VudFRyYWluYWJsZVBhcmFtcyhlKXtyZXR1cm4gbnVsbCE9ZS5jb2xsZWN0ZWRUcmFpbmFibGVXZWlnaHRzP2NvdW50UGFyYW1zSW5XZWlnaHRzKGUuY29sbGVjdGVkVHJhaW5hYmxlV2VpZ2h0cyk6Y291bnRQYXJhbXNJbldlaWdodHMoZS50cmFpbmFibGVXZWlnaHRzKX1mdW5jdGlvbiBpc01vZGVsU2VxdWVudGlhbExpa2UoZSl7dmFyIHQ9ITAsbj1bXSxyPVtdO2Zvcih2YXIgaSBpbiBlLm5vZGVzQnlEZXB0aCluLnB1c2goZS5ub2Rlc0J5RGVwdGhbaV0pO2Zvcih2YXIgYT0wLG89bjthPG8ubGVuZ3RoO2ErKyl7dmFyIHM9b1thXTtpZihzLmxlbmd0aD4xfHwxPT09cy5sZW5ndGgmJnNbMF0uaW5ib3VuZExheWVycy5sZW5ndGg+MSl7dD0hMTticmVha31yLnB1c2guYXBwbHkocixzKX1pZih0KWZvcih2YXIgbD0wLHU9ZS5sYXllcnM7bDx1Lmxlbmd0aDtsKyspe2Zvcih2YXIgYz0hMSxwPTAsaD11W2xdLmluYm91bmROb2RlcztwPGgubGVuZ3RoO3ArKyl7dmFyIGQ9aFtwXTtpZigtMSE9PXIuaW5kZXhPZihkKSl7aWYoYyl7dD0hMTticmVha31jPSEwfX1pZighdClicmVha31yZXR1cm4gdH1mdW5jdGlvbiBwcmludFJvdyhlLHQsbil7dm9pZCAwPT09biYmKG49Y29uc29sZS5sb2cpO2Zvcih2YXIgcj1cIlwiLGk9MDtpPGUubGVuZ3RoOysraSlpPjAmJihyPXIuc2xpY2UoMCxyLmxlbmd0aC0xKStcIiBcIikscj0ocis9ZVtpXSkuc2xpY2UoMCx0W2ldKSxyKz1cIiBcIi5yZXBlYXQodFtpXS1yLmxlbmd0aCk7bihyKX1mdW5jdGlvbiBwcmludExheWVyU3VtbWFyeShlLHQsbil7dmFyIHI7dHJ5e3I9SlNPTi5zdHJpbmdpZnkoZS5vdXRwdXRTaGFwZSl9Y2F0Y2goZSl7cj1cIm11bHRpcGxlXCJ9cHJpbnRSb3coW2UubmFtZStcIiAoXCIrZS5nZXRDbGFzc05hbWUoKStcIilcIixyLGUuY291bnRQYXJhbXMoKS50b1N0cmluZygpXSx0LG4pfWZ1bmN0aW9uIHByaW50TGF5ZXJTdW1tYXJ5V2l0aENvbm5lY3Rpb25zKGUsdCxuLHIpe3ZhciBpO3RyeXtpPUpTT04uc3RyaW5naWZ5KGUub3V0cHV0U2hhcGUpfWNhdGNoKGUpe2k9XCJtdWx0aXBsZVwifWZvcih2YXIgYT1bXSxvPTAscz1lLmluYm91bmROb2RlcztvPHMubGVuZ3RoO28rKyl7dmFyIGw9c1tvXTtpZighKG51bGwhPW4mJm4ubGVuZ3RoPjAmJi0xPT09bi5pbmRleE9mKGwpKSlmb3IodmFyIHU9MDt1PGwuaW5ib3VuZExheWVycy5sZW5ndGg7Kyt1KXt2YXIgYz1sLmluYm91bmRMYXllcnNbdV0ubmFtZSxwPWwubm9kZUluZGljZXNbdV0saD1sLnRlbnNvckluZGljZXNbdV07YS5wdXNoKGMrXCJbXCIrcCtcIl1bXCIraCtcIl1cIil9fXZhciBkPWUubmFtZSxmPWUuZ2V0Q2xhc3NOYW1lKCksZz0wPT09YS5sZW5ndGg/XCJcIjphWzBdO3ByaW50Um93KFtkK1wiIChcIitmK1wiKVwiLGksZS5jb3VudFBhcmFtcygpLnRvU3RyaW5nKCksZ10sdCxyKTtmb3IodT0xO3U8YS5sZW5ndGg7Kyt1KXByaW50Um93KFtcIlwiLFwiXCIsXCJcIixhW3VdXSx0LHIpfXZhciB2ZXJzaW9uPVwiMS4xLjJcIjtmdW5jdGlvbiBkZXNlcmlhbGl6ZShlLHQsbil7cmV0dXJuIHZvaWQgMD09PXQmJih0PXt9KSx2b2lkIDA9PT1uJiYobj0hMSksZGVzZXJpYWxpemVLZXJhc09iamVjdChlLHNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5nZXRNYXAoKS5jbGFzc05hbWVNYXAsdCxcImxheWVyXCIsbil9ZnVuY3Rpb24gaXNBcnJheUl0ZW1JbnB1dE9yT3V0cHV0TmFtZShlLHQsbil7cmV0dXJuKFwiaW5ib3VuZE5vZGVzXCI9PT1lfHxcIm91dHB1dExheWVyc1wiPT09ZXx8XCJpbnB1dExheWVyc1wiPT09ZSkmJjA9PT10JiZcInN0cmluZ1wiPT10eXBlb2Ygbn1mdW5jdGlvbiBjb252ZXJ0UHl0aG9uaWNUb1RzKGUsdCl7aWYobnVsbD09PWUpcmV0dXJuIG51bGw7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpcmV0dXJuIHRvQ2FtZWxDYXNlKGUpO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBlfHxcImJvb2xlYW5cIj09dHlwZW9mIGUpcmV0dXJuIGU7aWYoZSBpbnN0YW5jZW9mIEFycmF5KXtmb3IodmFyIG49W10scj1lLmxlbmd0aCxpPTA7aTxyOysraSl7dmFyIGE9ZVtpXTtpc0FycmF5SXRlbUlucHV0T3JPdXRwdXROYW1lKHQsaSxhKT9uLnB1c2goYSk6bi5wdXNoKGNvbnZlcnRQeXRob25pY1RvVHMoYSx0KSl9cmV0dXJuIG59Zm9yKHZhciBvPXt9LHM9MCxsPU9iamVjdC5rZXlzKGUpO3M8bC5sZW5ndGg7cysrKXt2YXIgdT1sW3NdLGM9ZVt1XTtpZihcIm5hbWVcIj09PXUmJlwic3RyaW5nXCI9PXR5cGVvZiBjKW9bdV09YztlbHNle3ZhciBwPXRvQ2FtZWxDYXNlKHUpO29bcF09Y29udmVydFB5dGhvbmljVG9UcyhjLHApfX1yZXR1cm4gb31mdW5jdGlvbiBjb252ZXJ0VHNUb1B5dGhvbmljKGUsdCl7aWYobnVsbD09PWV8fHZvaWQgMD09PWUpcmV0dXJuIG51bGw7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpcmV0dXJuIHRvU25ha2VDYXNlKGUpO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBlfHxcImJvb2xlYW5cIj09dHlwZW9mIGUpcmV0dXJuIGU7aWYoZSBpbnN0YW5jZW9mIEFycmF5KXtmb3IodmFyIG49W10scj1lLmxlbmd0aCxpPTA7aTxyOysraSl7dmFyIGE9ZVtpXTtpc0FycmF5SXRlbUlucHV0T3JPdXRwdXROYW1lKHQsaSxhKT9uLnB1c2goYSk6bi5wdXNoKGNvbnZlcnRUc1RvUHl0aG9uaWMoYSx0KSl9cmV0dXJuIG59Zm9yKHZhciBvPXt9LHM9MCxsPU9iamVjdC5rZXlzKGUpO3M8bC5sZW5ndGg7cysrKXt2YXIgdT1sW3NdLGM9ZVt1XSxwPXRvU25ha2VDYXNlKHUpO29bcF09XCJuYW1lXCIhPT11JiZcImNsYXNzTmFtZVwiIT09dXx8XCJzdHJpbmdcIiE9dHlwZW9mIGM/Y29udmVydFRzVG9QeXRob25pYyhjLHUpOmN9cmV0dXJuIG99ZnVuY3Rpb24gYXNzZXJ0RmVlZENvbXBhdGliaWxpdHkoZSx0KXtpZihudWxsPT1lLmR0eXBlfHxlLmR0eXBlPT09dC5kdHlwZSlyZXR1cm4gdDt0cnl7cmV0dXJuIGNhc3QodCxlLmR0eXBlKX1jYXRjaChuKXt0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBkdHlwZSBvZiB0aGUgZmVlZCAoXCIrdC5kdHlwZStcIikgY2FuIG5vdCBiZSBjYXN0IHRvIHRoZSBkdHlwZSBvZiB0aGUga2V5ICdcIitlLm5hbWUrXCInIChcIitlLmR0eXBlK1wiKS5cIil9fXZhciBGZWVkRGljdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7aWYodGhpcy5pZDJWYWx1ZT17fSx0aGlzLmlkMk1hc2s9e30sdGhpcy5uYW1lMklkPXt9LHQgaW5zdGFuY2VvZiBlKWZvcih2YXIgbiBpbiB0LmlkMlZhbHVlKXRoaXMuaWQyVmFsdWVbbl09dC5pZDJWYWx1ZVtuXSxuIGluIHQuaWQyTWFzayYmKHRoaXMuaWQyTWFza1tuXT10LmlkMk1hc2tbbl0pO2Vsc2V7aWYobnVsbD09dClyZXR1cm47Zm9yKHZhciByPTAsaT10O3I8aS5sZW5ndGg7cisrKXt2YXIgYT1pW3JdO3RoaXMuYWRkKGEua2V5LGEudmFsdWUpfX19cmV0dXJuIGUucHJvdG90eXBlLmFkZD1mdW5jdGlvbihlLHQsbil7aWYobnVsbCE9dGhpcy5pZDJWYWx1ZVtlLmlkXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkR1cGxpY2F0ZSBrZXk6IG5hbWU9XCIrZS5uYW1lK1wiLCBpZD1cIitlLmlkKTtyZXR1cm4gdGhpcy5pZDJWYWx1ZVtlLmlkXT1hc3NlcnRGZWVkQ29tcGF0aWJpbGl0eShlLHQpLHRoaXMubmFtZTJJZFtlLm5hbWVdPWUuaWQsbnVsbCE9biYmKHRoaXMuaWQyTWFza1tlLmlkXT1uKSx0aGlzfSxlLnByb3RvdHlwZS5hZGRGZWVkPWZ1bmN0aW9uKGUpe3RoaXMuYWRkKGUua2V5LGUudmFsdWUpfSxlLnByb3RvdHlwZS5oYXNLZXk9ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGwhPXRoaXMuaWQyVmFsdWVbZS5pZF19LGUucHJvdG90eXBlLm5hbWVzPWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubmFtZTJJZCl9LGUucHJvdG90eXBlLmdldFZhbHVlPWZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBTeW1ib2xpY1RlbnNvcil7aWYobnVsbD09dGhpcy5pZDJWYWx1ZVtlLmlkXSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIk5vbmV4aXN0ZW50IGtleTogXCIrZS5uYW1lKTtyZXR1cm4gdGhpcy5pZDJWYWx1ZVtlLmlkXX12YXIgdD10aGlzLm5hbWUySWRbZV07aWYobnVsbD09dCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkZlZWQgZGljdCBoYXMgbm8gU3ltYm9saWNUZW5zb3IgbmFtZTogXCIrZSk7cmV0dXJuIHRoaXMuaWQyVmFsdWVbdF19LGUucHJvdG90eXBlLmdldE1hc2s9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIFN5bWJvbGljVGVuc29yKXtpZihudWxsPT10aGlzLmlkMlZhbHVlW2UuaWRdKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTm9uZXhpc3RlbnQga2V5OiBcIitlLm5hbWUpO3JldHVybiB0aGlzLmlkMk1hc2tbZS5pZF19dmFyIHQ9dGhpcy5uYW1lMklkW2VdO2lmKG51bGw9PXQpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJGZWVkIGRpY3QgaGFzIG5vIFN5bWJvbGljVGVuc29yIG5hbWU6IFwiK2UpO3JldHVybiB0aGlzLmlkMk1hc2tbdF19LGUucHJvdG90eXBlLmRpc3Bvc2VNYXNrcz1mdW5jdGlvbigpe251bGwhPXRoaXMuaWQyTWFzayYmZGlzcG9zZSh0aGlzLmlkMk1hc2spfSxlfSgpLGNhY2hlZFNvcnRlZD17fSxjYWNoZWRSZWNpcGllbnRDb3VudHM9e307ZnVuY3Rpb24gZXhlY3V0ZShlLHQsbixyKXtmb3IodmFyIGk9bnVsbCE9biYmbi50cmFpbmluZyxhPUFycmF5LmlzQXJyYXkoZSksbz1hP2U6W2VdLHM9by5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmFtZX0pLGw9W10sdT10Lm5hbWVzKCksYz0wLHA9cztjPHAubGVuZ3RoO2MrKyl7dmFyIGg9cFtjXTstMSE9PXUuaW5kZXhPZihoKT9sLnB1c2godC5nZXRWYWx1ZShoKSk6bC5wdXNoKG51bGwpfW51bGwhPXImJihyLm1heE51bVRlbnNvcnM9LTEvMCxyLm1pbk51bVRlbnNvcnM9MS8wKTt2YXIgZCxmLGc9cy5qb2luKFwiLFwiKStcInxcIit0Lm5hbWVzKCkuam9pbihcIixcIik7aWYobnVsbD09Y2FjaGVkU29ydGVkW2ddKXt2YXIgbT1nZXRUb3BvbG9naWNhbFNvcnRBbmRSZWNpcGllbnRDb3VudHMobyx0KTtkPW0uc29ydGVkLGY9bS5yZWNpcGllbnRDb3VudHMsY2FjaGVkU29ydGVkW2ddPWQsY2FjaGVkUmVjaXBpZW50Q291bnRzW2ddPWZ9ZD1jYWNoZWRTb3J0ZWRbZ10sZj17fSxpfHxPYmplY3QuYXNzaWduKGYsY2FjaGVkUmVjaXBpZW50Q291bnRzW2ddKTtmb3IodmFyIHk9bmV3IEZlZWREaWN0KHQpLHY9MDt2PGQubGVuZ3RoOysrdil7aWYobnVsbCE9cil7dmFyIGI9bWVtb3J5KCkubnVtVGVuc29ycztiPnIubWF4TnVtVGVuc29ycyYmKHIubWF4TnVtVGVuc29ycz1iKSxiPHIubWluTnVtVGVuc29ycyYmKHIubWluTnVtVGVuc29ycz1iKX12YXIgdz1kW3ZdLHo9dy5zb3VyY2VMYXllcjtpZighKHogaW5zdGFuY2VvZiBJbnB1dExheWVyKSl7Zm9yKHZhciBTPVtdLEk9W10sQT1bXSxfPSExLEM9MCxOPXcuaW5wdXRzO0M8Ti5sZW5ndGg7QysrKXt2YXIgRT1OW0NdLGs9eS5nZXRWYWx1ZShFKSxMPXkuZ2V0TWFzayhFKTtTLnB1c2goayksSS5wdXNoKEwpLG51bGwhPUwmJihfPSEwKSxpfHwoZltFLm5hbWVdLS0sMCE9PWZbRS5uYW1lXXx8dC5oYXNLZXkoRSl8fC0xIT09cy5pbmRleE9mKEUubmFtZSl8fGsuaXNEaXNwb3NlZHx8ITA9PT1FLnNvdXJjZUxheWVyLnN0YXRlZnVsfHxBLnB1c2goaykpfV8mJigobj1ufHx7fSkubWFzaz1JWzBdKTt2YXIgeD10b0xpc3Qoei5hcHBseShTLG4pKSxUPW51bGw7ei5zdXBwb3J0c01hc2tpbmcmJihUPXouY29tcHV0ZU1hc2soUyxJKSk7Zm9yKHZhciBEPWdldE5vZGVPdXRwdXRzKHcpLE89QXJyYXkuaXNBcnJheShEKT9EOltEXSxSPTA7UjxPLmxlbmd0aDsrK1Ipe3kuaGFzS2V5KE9bUl0pfHx5LmFkZChPW1JdLHhbUl0sQXJyYXkuaXNBcnJheShUKT9UWzBdOlQpO3ZhciBNPXMuaW5kZXhPZihPW1JdLm5hbWUpOy0xIT09TSYmKGxbTV09eFtSXSl9aXx8ZGlzcG9zZShBKX19cmV0dXJuIHkuZGlzcG9zZU1hc2tzKCksYT9sOmxbMF19ZnVuY3Rpb24gZ2V0VG9wb2xvZ2ljYWxTb3J0QW5kUmVjaXBpZW50Q291bnRzKGUsdCl7dXRpbC5hc3NlcnQobnVsbCE9ZSYmZS5sZW5ndGg+MCxmdW5jdGlvbigpe3JldHVyblwiRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGZldGNoLCBnb3Qgbm9uZVwifSk7dmFyIG49W10scj17fTtpZigxPT09ZS5sZW5ndGgpe3ZhciBpPWdldFRvcG9sb2dpY2FsU29ydEFuZFJlY2lwaWVudENvdW50c0Zvck9uZUZldGNoKGVbMF0sdCk7bj1pLnNvcnRlZCxyPWkucmVjaXBpZW50TWFwfWVsc2UgZm9yKHZhciBhPW5ldyBTZXQsbz0wLHM9ZTtvPHMubGVuZ3RoO28rKyl7Zm9yKHZhciBsPWdldFRvcG9sb2dpY2FsU29ydEFuZFJlY2lwaWVudENvdW50c0Zvck9uZUZldGNoKHNbb10sdCksdT1sLnNvcnRlZCxjPWwucmVjaXBpZW50TWFwLHA9MCxoPXU7cDxoLmxlbmd0aDtwKyspe3ZhciBkPWhbcF07YS5oYXMoZC5uYW1lKXx8KG4ucHVzaChkKSxhLmFkZChkLm5hbWUpKX12YXIgZj1mdW5jdGlvbihlKXtudWxsPT1yW2VdJiYocltlXT1uZXcgU2V0KSxjW2VdLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIHJbZV0uYWRkKHQpfSl9O2Zvcih2YXIgZyBpbiBjKWYoZyl9cmV0dXJue3NvcnRlZDpuLHJlY2lwaWVudENvdW50czpyZWNpcGllbnRNYXAyQ291bnRzKHIpfX1mdW5jdGlvbiByZWNpcGllbnRNYXAyQ291bnRzKGUpe3ZhciB0PXt9O2Zvcih2YXIgbiBpbiBlKXRbbl09ZVtuXS5zaXplO3JldHVybiB0fWZ1bmN0aW9uIGdldFRvcG9sb2dpY2FsU29ydEFuZFJlY2lwaWVudENvdW50c0Zvck9uZUZldGNoKGUsdCl7Zm9yKHZhciBuPW5ldyBTZXQscj1bXSxpPXt9LGE9MCxvPXQubmFtZXMoKTthPG8ubGVuZ3RoO2ErKyl7dmFyIHM9b1thXTtuLmFkZChzKX12YXIgbD1bXSx1PVtdO2ZvcihsLnB1c2goZSk7bC5sZW5ndGg+MDspe3ZhciBjPWxbbC5sZW5ndGgtMV07aWYobi5oYXMoYy5uYW1lKSlsLnBvcCgpO2Vsc2V7dmFyIHA9dVt1Lmxlbmd0aC0xXT09PWwubGVuZ3RoLTE7aWYoMD09PWMuaW5wdXRzLmxlbmd0aHx8cClsLnBvcCgpLHIucHVzaChjKSxuLmFkZChjLm5hbWUpLHAmJnUucG9wKCk7ZWxzZXt1LnB1c2gobC5sZW5ndGgtMSk7Zm9yKHZhciBoPTAsZD1jLmlucHV0cztoPGQubGVuZ3RoO2grKyl7dmFyIGY9ZFtoXTtudWxsPT1pW2YubmFtZV0mJihpW2YubmFtZV09bmV3IFNldCksaVtmLm5hbWVdLmFkZChjLm5hbWUpLG4uaGFzKGYubmFtZSl8fGwucHVzaChmKX19fX1yZXR1cm57c29ydGVkOnIscmVjaXBpZW50TWFwOml9fWZ1bmN0aW9uIGdldE5vZGVPdXRwdXRzKGUpe3ZhciB0O2lmKDE9PT1lLnNvdXJjZUxheWVyLmluYm91bmROb2Rlcy5sZW5ndGgpdD1lLnNvdXJjZUxheWVyLm91dHB1dDtlbHNle2Zvcih2YXIgbj1udWxsLHI9MDtyPGUuc291cmNlTGF5ZXIuaW5ib3VuZE5vZGVzLmxlbmd0aDsrK3IpZm9yKHZhciBpPTAsYT1lLnNvdXJjZUxheWVyLmluYm91bmROb2Rlc1tyXS5vdXRwdXRUZW5zb3JzO2k8YS5sZW5ndGg7aSsrKXtpZihhW2ldLmlkPT09ZS5pZCl7bj1yO2JyZWFrfX10PWUuc291cmNlTGF5ZXIuZ2V0T3V0cHV0QXQobil9cmV0dXJuIHR9dmFyIENvbnRhaW5lcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KG4pe3ZhciByPWUuY2FsbCh0aGlzLHt9KXx8dGhpcztpZihyLmNvbnRhaW5lck5vZGVzPW5ldyBTZXQsci5uYW1lPW4ubmFtZSxudWxsPT1yLm5hbWUpe3ZhciBpPXIuZ2V0Q2xhc3NOYW1lKCkudG9Mb3dlckNhc2UoKTtyLm5hbWU9Z2V0VWlkKGkpfWlmKHIuc3VwcG9ydHNNYXNraW5nPSExLHIudHJhaW5hYmxlXz0hMCxyLnVwZGF0YWJsZT0hMCxBcnJheS5pc0FycmF5KG4uaW5wdXRzKT9yLmlucHV0cz1uLmlucHV0cy5zbGljZSgpOnIuaW5wdXRzPVtuLmlucHV0c10sQXJyYXkuaXNBcnJheShuLm91dHB1dHMpP3Iub3V0cHV0cz1uLm91dHB1dHMuc2xpY2UoKTpyLm91dHB1dHM9W24ub3V0cHV0c10sdW5pcXVlKHIuaW5wdXRzKS5sZW5ndGghPT1yLmlucHV0cy5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgbGlzdCBvZiBpbnB1dHMgcGFzc2VkIHRvIHRoZSBtb2RlbCBpcyByZWR1bmRhbnQuIEFsbCBpbnB1dHMgc2hvdWxkIG9ubHkgYXBwZWFyIG9uY2UuIEZvdW5kOiBcIityLmlucHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmFtZX0pKTt1bmlxdWUoci5vdXRwdXRzKS5sZW5ndGghPT1yLm91dHB1dHMubGVuZ3RoJiZjb25zb2xlLndhcm4oXCJUaGUgbGlzdCBvZiBvdXRwdXRzIHBhc3NlZCB0byB0aGUgbW9kZWwgaXMgcmVkdW5kYW50LiBBbGwgb3V0cHV0cyBzaG91bGQgb25seSBhcHBlYXIgb25jZS4gRm91bmQ6IFwiK3Iub3V0cHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmFtZX0pKSxyLmlucHV0TGF5ZXJzPVtdLHIuaW5wdXRMYXllcnNOb2RlSW5kaWNlcz1bXSxyLmlucHV0TGF5ZXJzVGVuc29ySW5kaWNlcz1bXSxyLm91dHB1dExheWVycz1bXSxyLm91dHB1dExheWVyc05vZGVJbmRpY2VzPVtdLHIub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlcz1bXSxyLmxheWVycz1bXTtmb3IodmFyIGE9MCxvPXIub3V0cHV0czthPG8ubGVuZ3RoO2ErKyl7dmFyIHM9KEM9b1thXSkuc291cmNlTGF5ZXIsbD1DLm5vZGVJbmRleCx1PUMudGVuc29ySW5kZXg7ci5vdXRwdXRMYXllcnMucHVzaChzKSxyLm91dHB1dExheWVyc05vZGVJbmRpY2VzLnB1c2gobCksci5vdXRwdXRMYXllcnNUZW5zb3JJbmRpY2VzLnB1c2godSl9Zm9yKHZhciBjPTAscD1yLmlucHV0cztjPHAubGVuZ3RoO2MrKyl7cz0oQz1wW2NdKS5zb3VyY2VMYXllcixsPUMubm9kZUluZGV4LHU9Qy50ZW5zb3JJbmRleDthc3NlcnQoMD09PWwsXCJpbnB1dCBsYXllciBoYXMgPjEgbm9kZXNcIiksYXNzZXJ0KDA9PT11LFwiaW5wdXQgbGF5ZXIgaGFzID4xIHRlbnNvcnNcIiksci5pbnB1dExheWVycy5wdXNoKHMpLHIuaW5wdXRMYXllcnNOb2RlSW5kaWNlcy5wdXNoKGwpLHIuaW5wdXRMYXllcnNUZW5zb3JJbmRpY2VzLnB1c2godSl9ci5pbnB1dE5hbWVzPVtdLHIub3V0cHV0TmFtZXM9W10sci5mZWVkSW5wdXRTaGFwZXM9W10sci5mZWVkSW5wdXROYW1lcz1bXSxyLmZlZWRPdXRwdXROYW1lcz1bXTtmb3IodmFyIGg9MDtoPHIuaW5wdXRMYXllcnMubGVuZ3RoO2grKyl7aWYoISgocz1yLmlucHV0TGF5ZXJzW2hdKWluc3RhbmNlb2YgSW5wdXRMYXllcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklucHV0IGxheWVycyB0byBhIExheWVyc01vZGVsIG11c3QgYmUgSW5wdXRMYXllciBvYmplY3RzLiBSZWNlaXZlZCBpbnB1dHM6IFwiK24uaW5wdXRzK1wiLiBJbnB1dCBcIitoK1wiICgwLWJhc2VkKSBvcmlnaW5hdGVzIGZyb20gbGF5ZXIgdHlwZSBcIitzLmdldENsYXNzTmFtZSgpK1wiLlwiKTtyLmlucHV0TmFtZXMucHVzaChzLm5hbWUpLHIuZmVlZElucHV0U2hhcGVzLnB1c2gocy5iYXRjaElucHV0U2hhcGUpLHIuZmVlZElucHV0TmFtZXMucHVzaChzLm5hbWUpfWZvcih2YXIgZD0wLGY9ci5vdXRwdXRMYXllcnM7ZDxmLmxlbmd0aDtkKyspe3M9ZltkXTtyLm91dHB1dE5hbWVzLnB1c2gocy5uYW1lKX1yLmludGVybmFsSW5wdXRTaGFwZXM9ci5pbnB1dHMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNoYXBlfSksci5pbnRlcm5hbE91dHB1dFNoYXBlcz1yLm91dHB1dHMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNoYXBlfSk7Zm9yKHZhciBnPXt9LG09e30seT17fSx2PXt9LGI9e30sdz1bXSx6PWZ1bmN0aW9uKGUsbixpLGEsbyxzKXtudWxsIT1hJiZudWxsIT1vJiZudWxsIT1zfHwoYT1lLnNvdXJjZUxheWVyLG89ZS5ub2RlSW5kZXgscz1lLnRlbnNvckluZGV4KTt2YXIgbD1hLmluYm91bmROb2Rlc1tvXTtpZigtMSE9PWkuaW5kZXhPZihsKSl0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiVGhlIHRlbnNvciBcIitlLm5hbWUrJyBhdCBsYXllciBcIicrYS5uYW1lKydcIiBpcyBwYXJ0IG9mIGEgY3ljbGUuJyk7aWYoLTE9PT1uLmluZGV4T2YobCkpe3IuY29udGFpbmVyTm9kZXMuYWRkKHQubm9kZUtleShhLG8pKSxhLmlkIGluIGJ8fChiW2EuaWRdPU9iamVjdC5rZXlzKGIpLmxlbmd0aCksLTE9PT1pLmluZGV4T2YobCkmJmkucHVzaChsKTtmb3IodmFyIHU9bC5pbmJvdW5kTGF5ZXJzLmxlbmd0aCxjPTA7Yzx1O2MrKyl7dmFyIHA9bC5pbnB1dFRlbnNvcnNbY10saD1sLmluYm91bmRMYXllcnNbY10sZD1sLm5vZGVJbmRpY2VzW2NdLGY9bC50ZW5zb3JJbmRpY2VzW2NdO3oocCxuLGksaCxkLGYpfWZvcihuLnB1c2gobCk7aS5pbmRleE9mKGwpPj0wOylpLnNwbGljZShpLmluZGV4T2YobCksMSk7dy5wdXNoKGwpfX0sUz1bXSxJPVtdLEE9MCxfPXIub3V0cHV0cztBPF8ubGVuZ3RoO0ErKyl7dmFyIEM9X1tBXTt6KEMsUyxJKX1mb3IodmFyIE49MCxFPXcuc2xpY2UoKS5yZXZlcnNlKCk7TjxFLmxlbmd0aDtOKyspe21bKEs9RVtOXSkuaWRdPUssSy5pZCBpbiBnfHwoZ1tLLmlkXT0wKTt2YXIgaz1nW0suaWRdLEw9bnVsbD09eVtLLm91dGJvdW5kTGF5ZXIuaWRdPzA6eVtLLm91dGJvdW5kTGF5ZXIuaWRdO2s9TWF0aC5tYXgoayxMKSx5W0sub3V0Ym91bmRMYXllci5pZF09ayx2W0sub3V0Ym91bmRMYXllci5pZF09Sy5vdXRib3VuZExheWVyLGdbSy5pZF09aztmb3IoaD0wO2g8Sy5pbmJvdW5kTGF5ZXJzLmxlbmd0aDtoKyspe3ZhciB4PUsuaW5ib3VuZExheWVyc1toXSxUPShsPUsubm9kZUluZGljZXNbaF0seC5pbmJvdW5kTm9kZXNbbF0pLEQ9bnVsbD09Z1tULmlkXT8wOmdbVC5pZF07Z1tULmlkXT1NYXRoLm1heChrKzEsRCksbVtULmlkXT1UfX12YXIgTz17fTtmb3IodmFyIFIgaW4gZyl7KGs9Z1tSXSlpbiBPfHwoT1trXT1bXSksT1trXS5wdXNoKG1bUl0pfXZhciBNPXt9O2Zvcih2YXIgUCBpbiB5KXsoaz15W1BdKWluIE18fChNW2tdPVtdKSxNW2tdLnB1c2godltQXSl9dmFyIEY9T2JqZWN0LmtleXMoTSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBwYXJzZUludChlLDEwKX0pLnNvcnQocmV2ZXJzZU51bWJlckNvbXBhcmUpO3IubGF5ZXJzPVtdO2Zvcih2YXIgVj0wLEI9RjtWPEIubGVuZ3RoO1YrKyl7dmFyIFU9TVtrPUJbVl1dO1Uuc29ydChmdW5jdGlvbihlLHQpe3ZhciBuPWJbZS5pZF0scj1iW3QuaWRdO3JldHVybiBuPHI/LTE6bj5yPzE6MH0pO2Zvcih2YXIgaj0wLFc9VTtqPFcubGVuZ3RoO2orKyl7cz1XW2pdO3IubGF5ZXJzLnB1c2gocyl9fXIubGF5ZXJzQnlEZXB0aD1NLEY9T2JqZWN0LmtleXMoTykubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBwYXJzZUludChlLDEwKX0pLnNvcnQocmV2ZXJzZU51bWJlckNvbXBhcmUpO2Zvcih2YXIgJD1yLmlucHV0cy5zbGljZSgpLHE9W10sRz0wLEg9RjtHPEgubGVuZ3RoO0crKylmb3IodmFyIEo9MCxaPU9baz1IW0ddXTtKPFoubGVuZ3RoO0orKyl7dmFyIEs7aWYobnVsbCE9KHM9KEs9WltKXSkub3V0Ym91bmRMYXllcikpe2Zvcih2YXIgWT0wLFg9Sy5pbnB1dFRlbnNvcnM7WTxYLmxlbmd0aDtZKyspe0M9WFtZXTtpZigtMT09PSQuaW5kZXhPZihDKSl0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiR3JhcGggZGlzY29ubmVjdGVkOiBjYW5ub3Qgb2J0YWluIHZhbHVlIGZvciB0ZW5zb3IgXCIrQysnIGF0IGxheWVyIFwiJytzLm5hbWUrJ1wiLiBUaGUgZm9sbG93aW5nIHByZXZpb3VzIGxheWVycyB3ZXJlIGFjY2Vzc2VkIHdpdGhvdXQgaXNzdWU6ICcrcSl9Zm9yKHZhciBRPTAsZWU9Sy5vdXRwdXRUZW5zb3JzO1E8ZWUubGVuZ3RoO1ErKyl7Qz1lZVtRXTskLnB1c2goQyl9cS5wdXNoKHMubmFtZSl9fXIubm9kZXNCeURlcHRoPU87Zm9yKHZhciB0ZT1yLmxheWVycy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmFtZX0pLG5lPWZ1bmN0aW9uKGUpe3ZhciB0PXRlLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gdD09PWV9KS5sZW5ndGg7aWYoMSE9PXQpdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignVGhlIG5hbWUgXCInK2UrJ1wiIGlzIHVzZWQgJyt0K1wiIHRpbWVzIGluIHRoZSBtb2RlbC4gQWxsIGxheWVyIG5hbWVzIHNob3VsZCBiZSB1bmlxdWUuIExheWVyIG5hbWVzOiBcIitKU09OLnN0cmluZ2lmeSh0ZSkpfSxyZT0wLGllPXRlO3JlPGllLmxlbmd0aDtyZSsrKXtuZShpZVtyZV0pfXJldHVybiByLm91dGJvdW5kTm9kZXM9W10sci5pbmJvdW5kTm9kZXM9W10sbmV3IE5vZGUoe291dGJvdW5kTGF5ZXI6cixpbmJvdW5kTGF5ZXJzOltdLG5vZGVJbmRpY2VzOltdLHRlbnNvckluZGljZXM6W10saW5wdXRUZW5zb3JzOnIuaW5wdXRzLG91dHB1dFRlbnNvcnM6ci5vdXRwdXRzLGlucHV0TWFza3M6ci5pbnB1dHMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBudWxsfSksb3V0cHV0TWFza3M6ci5vdXRwdXRzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gbnVsbH0pLGlucHV0U2hhcGVzOnIuaW5wdXRzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5zaGFwZX0pLG91dHB1dFNoYXBlczpyLm91dHB1dHMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNoYXBlfSl9KSxyLmJ1aWx0PSEwLHIuX3JlZkNvdW50PTEscn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXNzZXJ0Tm90RGlzcG9zZWQ9ZnVuY3Rpb24oKXtpZigwPT09dGhpcy5fcmVmQ291bnQpdGhyb3cgbmV3IEVycm9yKFwiQ29udGFpbmVyICdcIit0aGlzLm5hbWUrXCInIGlzIGFscmVhZHkgZGlzcG9zZWQuXCIpfSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5hc3NlcnROb3REaXNwb3NlZCgpO3ZhciBlPXtyZWZDb3VudEFmdGVyRGlzcG9zZTpudWxsLG51bURpc3Bvc2VkVmFyaWFibGVzOjB9O2lmKDA9PS0tdGhpcy5fcmVmQ291bnQpZm9yKHZhciB0PTAsbj10aGlzLmxheWVyczt0PG4ubGVuZ3RoO3QrKyl7dmFyIHI9blt0XTtlLm51bURpc3Bvc2VkVmFyaWFibGVzKz1yLmRpc3Bvc2UoKS5udW1EaXNwb3NlZFZhcmlhYmxlc31yZXR1cm4gZS5yZWZDb3VudEFmdGVyRGlzcG9zZT10aGlzLl9yZWZDb3VudCxlfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ0cmFpbmFibGVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhaW5hYmxlX30sc2V0OmZ1bmN0aW9uKGUpe3RoaXMubGF5ZXJzLmZvckVhY2goZnVuY3Rpb24odCl7dC5fdHJhaW5hYmxlV2VpZ2h0cy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRyYWluYWJsZT1lfSl9KSx0aGlzLnRyYWluYWJsZV89ZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ0cmFpbmFibGVXZWlnaHRzXCIse2dldDpmdW5jdGlvbigpe2lmKHRoaXMuX3RyYWluYWJsZVdlaWdodHMubGVuZ3RoPjApdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDb250YWluZXIgaW5zdGFuY2UgdW5leHBlY3RlZGx5IGNvbnRhaW5zIF90cmFpbmFibGVXZWlnaHRzLlRoZSB0cmFpbmFibGUgd2VpZ2h0cyBvZiBhIENvbnRhaW5lciBhcmUgYSB1bmlvbiBvZiB0aGUgdHJhaW5hYmxlIHdlaWdodHMgb2YgaXRzIGNvbnNpdHVlbnQgTGF5ZXJzLiBJdHMgb3duIF90cmFpbmFibGVXZWlnaHRzIG11c3QgcmVtYWluIGFuIGVtcHR5IEFycmF5LlwiKTtpZighdGhpcy50cmFpbmFibGUpcmV0dXJuW107Zm9yKHZhciBlPVtdLHQ9MCxuPXRoaXMubGF5ZXJzO3Q8bi5sZW5ndGg7dCsrKXt2YXIgcj1uW3RdO2U9ZS5jb25jYXQoci50cmFpbmFibGVXZWlnaHRzKX1yZXR1cm4gZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJub25UcmFpbmFibGVXZWlnaHRzXCIse2dldDpmdW5jdGlvbigpe2Zvcih2YXIgZT1bXSx0PTAsbj10aGlzLmxheWVyczt0PG4ubGVuZ3RoO3QrKyl7dmFyIHI9blt0XTtlLnB1c2guYXBwbHkoZSxyLm5vblRyYWluYWJsZVdlaWdodHMpfWlmKCF0aGlzLnRyYWluYWJsZSl7Zm9yKHZhciBpPVtdLGE9MCxvPXRoaXMubGF5ZXJzO2E8by5sZW5ndGg7YSsrKXtyPW9bYV07aS5wdXNoLmFwcGx5KGksci50cmFpbmFibGVXZWlnaHRzKX1yZXR1cm4gaS5jb25jYXQoZSl9cmV0dXJuIGV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwid2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFpbmFibGVXZWlnaHRzLmNvbmNhdCh0aGlzLm5vblRyYWluYWJsZVdlaWdodHMpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmxvYWRXZWlnaHRzPWZ1bmN0aW9uKGUsdCl7dm9pZCAwPT09dCYmKHQ9ITApO2Zvcih2YXIgbj17fSxyPTAsaT0wLGE9dGhpcy5sYXllcnM7aTxhLmxlbmd0aDtpKyspZm9yKHZhciBvPTAscz1hW2ldLndlaWdodHM7bzxzLmxlbmd0aDtvKyspe3ZhciBsPXNbb107aWYobnVsbCE9bltsLm9yaWdpbmFsTmFtZV0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJEdXBsaWNhdGUgd2VpZ2h0IG5hbWU6IFwiK2wub3JpZ2luYWxOYW1lKTtuW2wub3JpZ2luYWxOYW1lXT1sLHIrK312YXIgdT1bXTtmb3IodmFyIGMgaW4gZSl7aWYobnVsbCE9bltjXSl1LnB1c2goW25bY10sZVtjXV0pO2Vsc2UgaWYodCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlByb3ZpZGVkIHdlaWdodCBkYXRhIGhhcyBubyB0YXJnZXQgdmFyaWFibGU6IFwiK2MpO2RlbGV0ZSBuW2NdfWlmKHQpe3ZhciBwPVtdO2Zvcih2YXIgaCBpbiBuKXAucHVzaChoKTtpZihwLmxlbmd0aD4wKXRocm93IG5ldyBWYWx1ZUVycm9yKHAubGVuZ3RoK1wiIG9mIFwiK3IrXCIgd2VpZ2h0cyBhcmUgbm90IHNldDogXCIrcCl9YmF0Y2hTZXRWYWx1ZSh1KX0sdC5wcm90b3R5cGUudXBkYXRlZENvbmZpZz1mdW5jdGlvbigpe3ZhciBlPXRoaXMuZ2V0Q29uZmlnKCksdD17fTtyZXR1cm4gdC5jbGFzc05hbWU9dGhpcy5nZXRDbGFzc05hbWUoKSx0LmNvbmZpZz1lLHQua2VyYXNWZXJzaW9uPVwidGZqcy1sYXllcnMgXCIrdmVyc2lvbix0LmJhY2tlbmQ9XCJUZW5zb3JGbG93LmpzXCIsdH0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKGUsdCl7dm9pZCAwPT09dCYmKHQ9ITApO3ZhciBuPWNvbnZlcnRUc1RvUHl0aG9uaWModGhpcy51cGRhdGVkQ29uZmlnKCkpO3JldHVybiB0P0pTT04uc3RyaW5naWZ5KG4pOm59LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7ZT10b0xpc3QoZSk7Zm9yKHZhciByPW5ldyBGZWVkRGljdCxpPTA7aTxuLmlucHV0cy5sZW5ndGg7KytpKXIuYWRkKG4uaW5wdXRzW2ldLGVbaV0pO3JldHVybiBleGVjdXRlKG4ub3V0cHV0cyxyLHQpfSl9LHQucHJvdG90eXBlLmNvbXB1dGVNYXNrPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciByO3JldHVybiBlPXRvTGlzdChlKSxyPW51bGw9PXQ/cHlMaXN0UmVwZWF0KG51bGwsZS5sZW5ndGgpOnRvTGlzdCh0KSxuLnJ1bkludGVybmFsR3JhcGgoZSxyKVsxXX0pfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7dmFyIHQ9bm9ybWFsaXplU2hhcGVMaXN0KGUpO2lmKHQubGVuZ3RoIT09dGhpcy5pbnB1dExheWVycy5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnZhbGlkIGlucHV0U2hhcGUgYXJndW1lbnQgXCIrZStcIjogbW9kZWwgaGFzIFwiK3RoaXMuaW5wdXRMYXllcnMubGVuZ3RoK1wiIHRlbnNvciBpbnB1dHMuXCIpO2Zvcih2YXIgbj17fSxyPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBpPXRoaXMuaW5wdXRMYXllcnNbcl0sYT10W3JdO25bST1pLm5hbWUrXCJfMF8wXCJdPWF9dmFyIG89T2JqZWN0LmtleXModGhpcy5ub2Rlc0J5RGVwdGgpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gcGFyc2VJbnQoZSwxMCl9KS5zb3J0KHJldmVyc2VOdW1iZXJDb21wYXJlKTtpZihvLmxlbmd0aD4xKWZvcih2YXIgcz0wLGw9bztzPGwubGVuZ3RoO3MrKylmb3IodmFyIHU9bFtzXSxjPTAscD10aGlzLm5vZGVzQnlEZXB0aFt1XTtjPHAubGVuZ3RoO2MrKyl7dmFyIGg9cFtjXTtpPWgub3V0Ym91bmRMYXllcjtpZigtMT09PXRoaXMuaW5wdXRMYXllcnMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlkfSkuaW5kZXhPZihpLmlkKSl7Zm9yKHZhciBkPVtdLGY9MDtmPGguaW5ib3VuZExheWVycy5sZW5ndGg7ZisrKXt2YXIgZz1oLmluYm91bmRMYXllcnNbZl0sbT1oLm5vZGVJbmRpY2VzW2ZdLHk9aC50ZW5zb3JJbmRpY2VzW2ZdLHY9bltJPWcubmFtZStcIl9cIittK1wiX1wiK3ldO2QucHVzaCh2KX12YXIgYj1ub3JtYWxpemVTaGFwZUxpc3QoaS5jb21wdXRlT3V0cHV0U2hhcGUoc2luZ2xldG9uT3JBcnJheShkKSkpLHc9aS5pbmJvdW5kTm9kZXMuaW5kZXhPZihoKTtmb3IoZj0wO2Y8Yi5sZW5ndGg7ZisrKXtuW0k9aS5uYW1lK1wiX1wiK3crXCJfXCIrZl09YltmXX19fXZhciB6PVtdLFM9W107Zm9yKHI9MDtyPHRoaXMub3V0cHV0TGF5ZXJzLmxlbmd0aDtyKyspe2k9dGhpcy5vdXRwdXRMYXllcnNbcl0sdz10aGlzLm91dHB1dExheWVyc05vZGVJbmRpY2VzW3JdLHk9dGhpcy5vdXRwdXRMYXllcnNUZW5zb3JJbmRpY2VzW3JdO3ZhciBJPWkubmFtZStcIl9cIit3K1wiX1wiK3k7Uy5wdXNoKEkpfWZvcihyPTA7cjxTLmxlbmd0aDtyKyspe3ZhciBBPVNbcl07YXNzZXJ0KEEgaW4gbiksei5wdXNoKG5bQV0pfXJldHVybiBzaW5nbGV0b25PckFycmF5KHopfSx0LnByb3RvdHlwZS5ydW5JbnRlcm5hbEdyYXBoPWZ1bmN0aW9uKGUsdCl7bnVsbD09dCYmKHQ9cHlMaXN0UmVwZWF0KG51bGwsZS5sZW5ndGgpKTtmb3IodmFyIG49e30scj0wO3I8dGhpcy5pbnB1dHMubGVuZ3RoOysrcil7dmFyIGk9dGhpcy5pbnB1dHNbcl0sYT1lW3JdLG89dFtyXTtuW2kuaWRdPVthLG9dfWZvcih2YXIgcz0wLGw9T2JqZWN0LmtleXModGhpcy5ub2Rlc0J5RGVwdGgpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gcGFyc2VJbnQoZSwxMCl9KS5zb3J0KHJldmVyc2VOdW1iZXJDb21wYXJlKTtzPGwubGVuZ3RoO3MrKylmb3IodmFyIHU9bFtzXSxjPTAscD10aGlzLm5vZGVzQnlEZXB0aFt1XTtjPHAubGVuZ3RoO2MrKyl7Zm9yKHZhciBoPXBbY10sZD1oLm91dGJvdW5kTGF5ZXIsZj1oLmlucHV0VGVuc29ycyxnPWgub3V0cHV0VGVuc29ycyxtPW5ldyBBcnJheSx5PTAsdj1mO3k8di5sZW5ndGg7eSsrKXsoaT12W3ldKS5pZCBpbiBuJiZtLnB1c2gobltpLmlkXSl9aWYobS5sZW5ndGg9PT1mLmxlbmd0aCl7dmFyIGI9e30sdz12b2lkIDAsej12b2lkIDAsUz12b2lkIDAsST12b2lkIDA7aWYobnVsbCE9aC5jYWxsQXJncyYmKGI9aC5jYWxsQXJncyksMT09PW0ubGVuZ3RoKXt2YXIgQT1tWzBdLF89QVswXSxDPUFbMV07bnVsbD09Yi5tYXNrJiYoYi5tYXNrPUMpLFM9dG9MaXN0KGQuY2FsbChfLGIpKSxJPXRvTGlzdChkLmNvbXB1dGVNYXNrKF8sQykpLHc9W19dLHo9W0NdfWVsc2Ugdz1tLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZVswXX0pLHo9bS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGVbMV19KSxudWxsPT1iLm1hc2smJihiLm1hc2s9eiksUz10b0xpc3QoZC5jYWxsKHcsYikpLEk9dG9MaXN0KGQuY29tcHV0ZU1hc2sodyx6KSk7aWYoZC5hY3Rpdml0eVJlZ3VsYXJpemVyKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiTGF5ZXJzTW9kZWwgaW52b2NhdGlvbiB3aXRoIGNvbmNyZXRlIFRlbnNvciB2YWx1ZShzKSBpbiB0aGUgcHJlc2VuY2Ugb2YgYWN0aXZpdHkgcmVndWxhcml6ZXIocykgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO2ZvcihyPTA7cjxnLmxlbmd0aDsrK3Ipe2k9Z1tyXSxhPVNbcl0sbz1JW3JdO25baS5pZF09W2Esb119fX1mb3IodmFyIE49W10sRT1bXSxrPVtdLEw9MCx4PXRoaXMub3V0cHV0cztMPHgubGVuZ3RoO0wrKyl7YXNzZXJ0KChpPXhbTF0pLmlkIGluIG4sXCJDb3VsZCBub3QgY29tcHV0ZSBvdXRwdXQgXCIraS5uYW1lK1wiIDogXCIraS5pZCk7dmFyIFQ9bltpLmlkXSxEPVRbMF07bz1UWzFdO2sucHVzaChELnNoYXBlKSxOLnB1c2goRCksRS5wdXNoKG8pfXJldHVybltOLEUsa119LHQucHJvdG90eXBlLmJ1aWxkTm9kZUNvbnZlcnNpb25NYXA9ZnVuY3Rpb24oZSl7Zm9yKHZhciBuLHI9e30saT0wLGE9dGhpcy5sYXllcnM7aTxhLmxlbmd0aDtpKyspe3ZhciBvPWFbaV07bj1vIGluc3RhbmNlb2YgdD8xOjA7Zm9yKHZhciBzPTA7czxvLmluYm91bmROb2Rlcy5sZW5ndGg7cysrKXt2YXIgbD10Lm5vZGVLZXkobyxzKTt0aGlzLmNvbnRhaW5lck5vZGVzLmhhcyhsKSYmKHJbbF09bixuKz0xKX19cmV0dXJuIHJ9LHQucHJvdG90eXBlLmdldExheWVyPWZ1bmN0aW9uKGUsdCl7aWYobnVsbCE9dCl7aWYodGhpcy5sYXllcnMubGVuZ3RoPD10KXRocm93IG5ldyBWYWx1ZUVycm9yKFwiV2FzIGFza2VkIHRvIHJldHJpZXZlIGxheWVyIGF0IGluZGV4IFwiK3QrXCIsIGJ1dCBtb2RlbCBvbmx5IGhhcyBcIit0aGlzLmxheWVycy5sZW5ndGgrXCIgbGF5ZXIocykuXCIpO3JldHVybiB0aGlzLmxheWVyc1t0XX1pZihudWxsPT1lKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiUHJvdmlkZSBlaXRoZXIgYSBsYXllciBuYW1lIG9yIGxheWVyIGluZGV4XCIpO2Zvcih2YXIgbj0wLHI9dGhpcy5sYXllcnM7bjxyLmxlbmd0aDtuKyspe3ZhciBpPXJbbl07aWYoaS5uYW1lPT09ZSlyZXR1cm4gaX10aHJvdyBuZXcgVmFsdWVFcnJvcihcIk5vIHN1Y2ggbGF5ZXI6IFwiK2UpfSx0LnByb3RvdHlwZS5jYWxjdWxhdGVMb3NzZXM9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7Zm9yKHZhciBuPVtdLHI9MCxpPWUubGF5ZXJzO3I8aS5sZW5ndGg7cisrKWZvcih2YXIgYT1pW3JdLG89MDtvPGEuaW5ib3VuZE5vZGVzLmxlbmd0aDsrK28pe3ZhciBzPXQubm9kZUtleShhLG8pO2UuY29udGFpbmVyTm9kZXMuaGFzKHMpJiZuLnB1c2guYXBwbHkobixhLmNhbGN1bGF0ZUxvc3NlcygpKX1yZXR1cm4gbn0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtmb3IodmFyIGU9e25hbWU6dGhpcy5uYW1lfSxuPXRoaXMuYnVpbGROb2RlQ29udmVyc2lvbk1hcCh0aGlzLmxheWVycykscj1bXSxpPTAsYT10aGlzLmxheWVycztpPGEubGVuZ3RoO2krKyl7Zm9yKHZhciBvPSh3PWFbaV0pLmdldENsYXNzTmFtZSgpLHM9dy5nZXRDb25maWcoKSxsPVtdLHU9MDt1PHcuaW5ib3VuZE5vZGVzLmxlbmd0aDt1Kyspe3ZhciBjPXcuaW5ib3VuZE5vZGVzW3VdLHA9dC5ub2RlS2V5KHcsdSksaD17fTtpZih0aGlzLmNvbnRhaW5lck5vZGVzLmhhcyhwKSl7aWYoYy5jYWxsQXJncyl0cnl7SlNPTi5zdHJpbmdpZnkoYy5jYWxsQXJncyksaD1jLmNhbGxBcmdzfWNhdGNoKGUpe2NvbnNvbGUud2FybihcIkxheWVyIFwiK3cubmFtZStcIiB3YXMgcGFzc2VkIG5vbi1zZXJpYWxpemFibGUga2V5d29yZCBhcmd1bWVudHM6IFwiK2MuY2FsbEFyZ3MrXCIuIFRoZXkgd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIHNlcmlhbGl6ZWQgbW9kZWwgKGFuZCB0aHVzIHdpbGwgYmUgbWlzc2luZyBhdCBkZXNlcmlhbGl6YXRpb24gdGltZSkuXCIpLGg9e319aWYoYy5pbmJvdW5kTGF5ZXJzLmxlbmd0aD4wKXtmb3IodmFyIGQ9W10sZj0wO2Y8Yy5pbmJvdW5kTGF5ZXJzLmxlbmd0aDtmKyspe3ZhciBnPWMuaW5ib3VuZExheWVyc1tmXSxtPWMubm9kZUluZGljZXNbZl0seT1jLnRlbnNvckluZGljZXNbZl07bnVsbD09KFM9blt0Lm5vZGVLZXkoZyxtKV0pJiYoUz0wKSxkLnB1c2goW2cubmFtZSxTLHksaF0pfWwucHVzaChkKX19fXZhciB2PXt9O3YubmFtZT13Lm5hbWUsdi5jbGFzc05hbWU9byx2LmNvbmZpZz1zLHYuaW5ib3VuZE5vZGVzPWwsci5wdXNoKHYpfWUubGF5ZXJzPXI7dmFyIGI9W107Zm9yKGY9MDtmPHRoaXMuaW5wdXRMYXllcnMubGVuZ3RoO2YrKyl7dmFyIHc9dGhpcy5pbnB1dExheWVyc1tmXTttPXRoaXMuaW5wdXRMYXllcnNOb2RlSW5kaWNlc1tmXSxwPXQubm9kZUtleSh3LG0pO2lmKHRoaXMuY29udGFpbmVyTm9kZXMuaGFzKHApKXtudWxsIT09KFM9bltwXSkmJnZvaWQgMCE9PVN8fChTPTApO3k9dGhpcy5pbnB1dExheWVyc1RlbnNvckluZGljZXNbZl07Yi5wdXNoKFt3Lm5hbWUsUyx5XSl9fWUuaW5wdXRMYXllcnM9Yjt2YXIgej1bXTtmb3IoZj0wO2Y8dGhpcy5vdXRwdXRMYXllcnMubGVuZ3RoO2YrKyl7dz10aGlzLm91dHB1dExheWVyc1tmXSxtPXRoaXMub3V0cHV0TGF5ZXJzTm9kZUluZGljZXNbZl0scD10Lm5vZGVLZXkodyxtKTtpZih0aGlzLmNvbnRhaW5lck5vZGVzLmhhcyhwKSl7dmFyIFM7bnVsbCE9PShTPW5bcF0pJiZ2b2lkIDAhPT1TfHwoUz0wKTt5PXRoaXMub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlc1tmXTt6LnB1c2goW3cubmFtZSxTLHldKX19cmV0dXJuIGUub3V0cHV0TGF5ZXJzPXosZX0sdC5mcm9tQ29uZmlnPWZ1bmN0aW9uKGUsdCxuLHIpe3ZvaWQgMD09PW4mJihuPXt9KSx2b2lkIDA9PT1yJiYocj0hMSk7dmFyIGk9e30sYT17fTtmdW5jdGlvbiBvKGUsdCl7ZS5uYW1lIGluIGE/YVtlLm5hbWVdLnB1c2godCk6YVtlLm5hbWVdPVt0XX1mdW5jdGlvbiBzKGUsdCl7Zm9yKHZhciBuLHI9W10sYT0wLHM9dDthPHMubGVuZ3RoO2ErKyl7dmFyIGw9c1thXSx1PWxbMF0sYz1sWzFdLHA9bFsyXTtpZihuPW51bGw9PWxbM10/e306bFszXSwhKHUgaW4gaSkpcmV0dXJuIHZvaWQgbyhlLHQpO3ZhciBoPWlbdV07aWYoaC5pbmJvdW5kTm9kZXMubGVuZ3RoPD1jKXJldHVybiB2b2lkIG8oZSx0KTt2YXIgZD1oLmluYm91bmROb2Rlc1tjXTtyLnB1c2goZC5vdXRwdXRUZW5zb3JzW3BdKX1yLmxlbmd0aD4wJiZlLmFwcGx5KHNpbmdsZXRvbk9yQXJyYXkociksbil9ZnVuY3Rpb24gbChlKXt2YXIgbj1lLm5hbWUsYT1kZXNlcmlhbGl6ZShlLG51bGwhPXQuY3VzdG9tT2JqZWN0cz90LmN1c3RvbU9iamVjdHM6e30pO2Euc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZChyKSxpW25dPWEsZS5pbmJvdW5kTm9kZXMuZm9yRWFjaChmdW5jdGlvbihlKXtpZighKGUgaW5zdGFuY2VvZiBBcnJheSkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDb3JydXB0ZWQgY29uZmlndXJhdGlvbiwgZXhwZWN0ZWQgYXJyYXkgZm9yIG5vZGVEYXRhOiBcIitlKTtvKGEsZSl9KX1mb3IodmFyIHU9dC5uYW1lLGM9dC5sYXllcnMscD0wLGg9YztwPGgubGVuZ3RoO3ArKyl7bChnPWhbcF0pfWZvcig7IWlzT2JqZWN0RW1wdHkoYSk7KWZvcih2YXIgZD0wLGY9YztkPGYubGVuZ3RoO2QrKyl7dmFyIGc9ZltkXTtpZigoaz1pW2cubmFtZV0pLm5hbWUgaW4gYSl7dmFyIG09YVtrLm5hbWVdO2RlbGV0ZSBhW2submFtZV07Zm9yKHZhciB5PTAsdj1tO3k8di5sZW5ndGg7eSsrKXtzKGssdlt5XSl9fX1mb3IodmFyIGI9W10sdz1bXSx6PTAsUz10LmlucHV0TGF5ZXJzO3o8Uy5sZW5ndGg7eisrKXt2YXIgST0oZz1TW3pdKVswXSxBPWdbMV0sXz1nWzJdO2Fzc2VydChJIGluIGkpO3ZhciBDPShrPWlbSV0pLmluYm91bmROb2Rlc1tBXS5vdXRwdXRUZW5zb3JzO2IucHVzaChDW19dKX1mb3IodmFyIE49MCxFPXQub3V0cHV0TGF5ZXJzO048RS5sZW5ndGg7TisrKXtJPShnPUVbTl0pWzBdLEE9Z1sxXSxfPWdbMl07YXNzZXJ0KEkgaW4gaSk7dmFyIGs7Qz0oaz1pW0ldKS5pbmJvdW5kTm9kZXNbQV0ub3V0cHV0VGVuc29yczt3LnB1c2goQ1tfXSl9cmV0dXJuIG5ldyBlKHtpbnB1dHM6YixvdXRwdXRzOncsbmFtZTp1fSl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInN0YXRlZnVsXCIse2dldDpmdW5jdGlvbigpe2lmKHRoaXMuX3N0YXRlZnVsKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ29udGFpbmVyIGluc3RhbmNlIHVuZXhwZWN0ZWRseSBoYXMgX3N0YXRlZnVsID0gdHJ1ZS4gVGhlIHN0YXRlZnVsbmVzcyBvZiBhIENvbnRhaW5lciBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBMYXllcnMgaXQgY29udGFpbnMuIEl0cyBfc3RhdGVmdWwgcHJvcGVydHkgbXVzdCByZW1haW4gdGhlIGRlZmF1bHQgZmFsc2UuXCIpO2Zvcih2YXIgZT0wLHQ9dGhpcy5sYXllcnM7ZTx0Lmxlbmd0aDtlKyspe2lmKHRbZV0uc3RhdGVmdWwpcmV0dXJuITB9cmV0dXJuITF9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUucmVzZXRTdGF0ZXM9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RpZHkoZnVuY3Rpb24oKXtlLmxheWVycy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2Uuc3RhdGVmdWwmJmUucmVzZXRTdGF0ZXMoKX0pfSl9LHR9KExheWVyKSxERUZBVUxUX1ZBTElEQVRJT05fQkFUQ0hfU0laRT0zMjtmdW5jdGlvbiBzdGFuZGFyZGl6ZURhdGFJdGVyYXRvck91dHB1dChlLHQpe3ZhciBuLHIsaT10O249aS54cyxyPWkueXMsdXRpbC5hc3NlcnQobnVsbCE9biYmbnVsbCE9cixmdW5jdGlvbigpe3JldHVyblwiQSBEYXRhc2V0IGl0ZXJhdG9yIGZvciBmaXREYXRhc2V0KCkgaXMgZXhwZWN0ZWQgdG8gZ2VuZXJhdGUgb2JqZWN0cyBvZiB0aGUgZm9ybSBge3hzOiB4VmFsLCB5czogeVZhbH1gLCB3aGVyZSB0aGUgdHdvIHZhbHVlcyBtYXkgYmUgYHRmLlRlbnNvcmAsIGFuIGFycmF5IG9mIFRlbnNvcnMsIG9yIGEgbWFwIG9mIHN0cmluZyB0byBUZW5zb3IuICBUaGUgcHJvdmlkZWQgRGF0YXNldCBpbnN0ZWFkIGdlbmVyYXRlcyBcIit0fSk7dmFyIGE9ZmxhdHRlblRlbnNvck9yQXJyYXlPck1hcChcImlucHV0XCIsZS5pbnB1dE5hbWVzLG4pLG89ZmxhdHRlblRlbnNvck9yQXJyYXlPck1hcChcIm91dHB1dFwiLGUub3V0cHV0TmFtZXMscikscz1hWzBdLnNoYXBlWzBdO3V0aWwuYXNzZXJ0KGEubGVuZ3RoPT09ZS5pbnB1dHMubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJMYXllcnNNb2RlbCBoYXMgXCIrZS5pbnB1dHMubGVuZ3RoK1wiIGlucHV0cywgYnV0IHRoZSBkYXRhc2V0IHByb3ZpZGVzIFwiK2EubGVuZ3RoK1wiIGlucHV0cy4gIChFeHBlY3RlZCBpbnB1dCBrZXlzOiBcIitKU09OLnN0cmluZ2lmeShlLmlucHV0TmFtZXMpK1wiKVwifSksdXRpbC5hc3NlcnQoby5sZW5ndGg9PT1lLm91dHB1dHMubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJMYXllcnNNb2RlbCBoYXMgXCIrZS5vdXRwdXRzLmxlbmd0aCtcIiBvdXRwdXRzLCBidXQgdGhlIGRhdGFzZXQgcHJvdmlkZXMgXCIrby5sZW5ndGgrXCIgb3V0cHV0cy4gIChFeHBlY3RlZCBvdXRwdXQga2V5czogXCIrSlNPTi5zdHJpbmdpZnkoZS5vdXRwdXROYW1lcykrXCIpXCJ9KTt2YXIgbD1mdW5jdGlvbih0KXt1dGlsLmFzc2VydChhW3RdLnNoYXBlWzBdPT09cyxmdW5jdGlvbigpe3JldHVyblwiQmF0Y2ggc2l6ZSBtaXNtYXRjaDogaW5wdXQgXCIrZS5pbnB1dE5hbWVzW3RdK1wiIGhhcyBcIithW3RdLnNoYXBlWzBdK1wiOyBleHBlY3RlZCAgXCIrcytcIiBiYXNlZCBvbiBpbnB1dCBcIitlLmlucHV0TmFtZXNbMF0rXCIuXCJ9KX07Zm9yKHZhciB1IGluIGEpbCh1KTt2YXIgYz1mdW5jdGlvbih0KXt1dGlsLmFzc2VydChvW3RdLnNoYXBlWzBdPT09cyxmdW5jdGlvbigpe3JldHVyblwiQmF0Y2ggc2l6ZSBtaXNtYXRjaDogb3V0cHV0IFwiK2Uub3V0cHV0TmFtZXNbdF0rXCIgaGFzIFwiK29bdF0uc2hhcGVbMF0rXCI7IGV4cGVjdGVkICBcIitzK1wiIGJhc2VkIG9uIGlucHV0IFwiK2UuaW5wdXROYW1lc1swXStcIi5cIn0pfTtmb3IodmFyIHAgaW4gbyljKHApO3JldHVybiBhLmNvbmNhdChvKX1mdW5jdGlvbiBmbGF0dGVuVGVuc29yT3JBcnJheU9yTWFwKGUsdCxuKXtpZihuIGluc3RhbmNlb2YgVGVuc29yKXJldHVybltuXTtpZihBcnJheS5pc0FycmF5KG4pKXJldHVybiB1dGlsLmFzc2VydChuLmxlbmd0aD09PXQubGVuZ3RoLGZ1bmN0aW9uKCl7cmV0dXJuXCJSZWNlaXZlZCBhbiBhcnJheSBvZiBcIituLmxlbmd0aCtcIiBUZW5zb3JzLCBidXQgZXhwZWN0ZWQgXCIrdC5sZW5ndGgrXCIgdG8gbWF0Y2ggdGhlIFwiK2UrXCIga2V5cyBcIit0K1wiLlwifSksbjtmb3IodmFyIHI9W10saT0wLGE9dDtpPGEubGVuZ3RoO2krKyl7dmFyIG89YVtpXTtpZihudWxsPT1uW29dKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGZlYXR1cmUgZGF0YSBnZW5lcmF0ZWQgYnkgdGhlIGRhdGFzZXQgbGFja3MgdGhlIHJlcXVpcmVkIFwiK2UrXCIga2V5ICdcIitvK1wiJy5cIik7ci5wdXNoKG5bb10pfXJldHVybiByfWZ1bmN0aW9uIHN0YW5kYXJkaXplVGVuc29yVmFsaWRhdGlvbkRhdGEoZSl7aWYoMz09PWUubGVuZ3RoKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiVmFsaWRhdGlvbiB3aXRoIHNhbXBsZSB3ZWlnaHRzIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO3JldHVybnt4czplWzBdLHlzOmVbMV19fWZ1bmN0aW9uIGZpdERhdGFzZXQoZSx0LG4pe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHIsaSxhLG8scyxsLHUsYyxwLGgsZCxmLGcsbSx5LHYsYix3LHosUyxJLEEsXyxDLE4sRSxrO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKEwpe3N3aXRjaChMLmxhYmVsKXtjYXNlIDA6aWYocj1udWxsIT1uLmJhdGNoZXNQZXJFcG9jaCx1dGlsLmFzc2VydChudWxsIT1lLm9wdGltaXplcixmdW5jdGlvbigpe3JldHVyblwiWW91IG11c3QgY29tcGlsZSBhIG1vZGVsIGJlZm9yZSB0cmFpbmluZy90ZXN0aW5nLiBVc2UgTGF5ZXJzTW9kZWwuY29tcGlsZShtb2RlbENvbXBpbGVDb25maWcpLlwifSksdXRpbC5hc3NlcnQobnVsbCE9bixmdW5jdGlvbigpe3JldHVyblwiRm9yIGZpdERhdGFzZXQoKSwgdGhlIDJuZCBhcmd1bWVudCAoY29uZmlnKSBpcyByZXF1aXJlZCwgYnV0IGl0IGlzIG5vdCBwcm92aWRlZCBpbiB0aGlzIGNhbGwuXCJ9KSx1dGlsLmFzc2VydChudWxsIT1uLmVwb2NocyYmbi5lcG9jaHM+MCYmTnVtYmVyLmlzSW50ZWdlcihuLmVwb2NocyksZnVuY3Rpb24oKXtyZXR1cm5cIkZvciBmaXREYXRhc2V0KCksIGNvbmZpZy5lcG9jaHMgaXMgZXhwZWN0ZWQgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBidXQgZ290IFwiK24uZXBvY2hzfSksdXRpbC5hc3NlcnQoIXJ8fG4uYmF0Y2hlc1BlckVwb2NoPjAmJk51bWJlci5pc0ludGVnZXIobi5iYXRjaGVzUGVyRXBvY2gpLGZ1bmN0aW9uKCl7cmV0dXJuXCJGb3IgZml0RGF0YXNldCgpLCBjb25maWcuYmF0Y2hlc1BlckVwb2NoIGlzIGV4cGVjdGVkIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciBpZiBzcGVjaWZpZWQsIGJ1dCBnb3QgXCIrbi5iYXRjaGVzUGVyRXBvY2h9KSx1dGlsLmFzc2VydChudWxsPT1uLnZhbGlkYXRpb25TcGxpdCxmdW5jdGlvbigpe3JldHVyblwiYHZhbGlkYXRpb25TcGxpdGAgaXMgbm90IHN1cHBvcnRlZCBieSBgZml0RGF0YXNldCgpYC4gVXNlIHZhbGlkYXRpb25EYXRhIGluc3RlYWQuXCJ9KSxlLmlzVHJhaW5pbmcpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN0YXJ0IHRyYWluaW5nIGJlY2F1c2UgYW5vdGhlciBmaXQoKSBjYWxsIGlzIG9uZ29pbmcuXCIpO2UuaXNUcmFpbmluZz0hMCxMLmxhYmVsPTE7Y2FzZSAxOnJldHVybiBMLnRyeXMucHVzaChbMSwsMjIsMjNdKSxpPW51bGwhPW4udmFsaWRhdGlvbkRhdGEsYT12b2lkIDAsbz12b2lkIDAsaSYmKGlzRGF0YXNldE9iamVjdChuLnZhbGlkYXRpb25EYXRhKT91dGlsLmFzc2VydChudWxsPT1uLnZhbGlkYXRpb25CYXRjaGVzfHxuLnZhbGlkYXRpb25CYXRjaGVzPjAmJk51bWJlci5pc0ludGVnZXIobi52YWxpZGF0aW9uQmF0Y2hlcyksZnVuY3Rpb24oKXtyZXR1cm5cIkZvciBmaXREYXRhc2V0KCkgd2l0aCBkYXRhc2V0LWJhc2VkIHZhbGlkYXRpb24sIGNvbmZpZy52YWxpZGF0aW9uQmF0Y2hlcyBpcyBleHBlY3RlZCBub3QgdG8gYmUgcHJvdmlkZWQsIG9yIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCBcIituLnZhbGlkYXRpb25CYXRjaGVzfSk6KHM9c3RhbmRhcmRpemVUZW5zb3JWYWxpZGF0aW9uRGF0YShuLnZhbGlkYXRpb25EYXRhKSxhPXMueHMsbz1zLnlzKSksbD1lLm1ha2VUcmFpbkZ1bmN0aW9uKCksdT1lLmdldERlZHVwZWRNZXRyaWNzTmFtZXMoKSxjPXZvaWQgMCxjPWk/dS5zbGljZSgpLmNvbmNhdCh1Lm1hcChmdW5jdGlvbihlKXtyZXR1cm5cInZhbF9cIitlfSkpOnUuc2xpY2UoKSxwPXN0YW5kYXJkaXplQ2FsbGJhY2tzKG4uY2FsbGJhY2tzLG4ueWllbGRFdmVyeSksaD1udWxsPT1uLnZlcmJvc2U/MTpuLnZlcmJvc2UsZD1jb25maWd1cmVDYWxsYmFja3MocCxoLG4uZXBvY2hzLG51bGwsbnVsbCxnZXRTdGVwc1BlckVwb2NoKHQsbiksbnVsbCxpLGMpLGY9ZC5jYWxsYmFja0xpc3QsZz1kLmhpc3RvcnksZi5zZXRNb2RlbChlKSxlLmhpc3Rvcnk9ZyxbNCxmLm9uVHJhaW5CZWdpbigpXTtjYXNlIDI6cmV0dXJuIEwuc2VudCgpLGUuc3RvcFRyYWluaW5nXz0hMSxtPW51bGw9PW4uaW5pdGlhbEVwb2NoPzA6bi5pbml0aWFsRXBvY2gsWzQsdC5pdGVyYXRvcigpXTtjYXNlIDM6eT1MLnNlbnQoKSxMLmxhYmVsPTQ7Y2FzZSA0OnJldHVybiBtPG4uZXBvY2hzPyh2PXt9LFs0LGYub25FcG9jaEJlZ2luKG0pXSk6WzMsMTldO2Nhc2UgNTpyZXR1cm4gTC5zZW50KCksYj0wLHc9MCxyP1szLDddOls0LHQuaXRlcmF0b3IoKV07Y2FzZSA2Onk9TC5zZW50KCksTC5sYWJlbD03O2Nhc2UgNzpyZXR1cm4hcnx8YjxuLmJhdGNoZXNQZXJFcG9jaD9bNCx5Lm5leHQoKV06WzMsMTddO2Nhc2UgODpyZXR1cm4gej1MLnNlbnQoKSxyJiZ6LmRvbmU/KGNvbnNvbGUud2FybihcIllvdSBwcm92aWRlZCBgYmF0Y2hlc1BlckVwb2NoYCBhcyBcIituLmJhdGNoZXNQZXJFcG9jaCtcIiwgYnV0IHlvdXIgZGF0YXNldCBpdGVyYXRvciByYW4gb3V0IG9mIGRhdGEgYWZ0ZXIgXCIrYitcIiBiYXRjaGVzOyBpbnRlcnJ1cHRpbmcgdHJhaW5pbmcuIE1ha2Ugc3VyZSB0aGF0IHlvdXIgZGF0YXNldCBjYW4gZ2VuZXJhdGUgYXQgbGVhc3QgYGJhdGNoZXNQZXJFcG9jaCAqIGVwb2Noc2AgYmF0Y2hlcyAoaW4gdGhpcyBjYXNlLCBcIituLmJhdGNoZXNQZXJFcG9jaCpuLmVwb2NocytcIiBiYXRjaGVzKS4gWW91IG1heSBuZWVkIHRvIHVzZSB0aGUgcmVwZWF0KCkgZnVuY3Rpb24gd2hlbiBidWlsZGluZyB5b3VyIGRhdGFzZXQuXCIpLFszLDE3XSk6bnVsbD09ei52YWx1ZT9bMywxMV06KFM9c3RhbmRhcmRpemVEYXRhSXRlcmF0b3JPdXRwdXQoZSx6LnZhbHVlKSwoST17fSkuYmF0Y2g9dyxJLnNpemU9U1swXS5zaGFwZVswXSxbNCxmLm9uQmF0Y2hCZWdpbih3LEkpXSk7Y2FzZSA5OmZvcihMLnNlbnQoKSxBPWwoUyksZGlzcG9zZShTKSxrPTA7azx1Lmxlbmd0aDsrK2spXz11W2tdLEM9QVtrXSxJW19dPUMsa2VlcChDKTtyZXR1cm5bNCxmLm9uQmF0Y2hFbmQodyxJKV07Y2FzZSAxMDpMLnNlbnQoKSxkaXNwb3NlVGVuc29yc0luTG9ncyhJKSx3KyssYisrLEwubGFiZWw9MTE7Y2FzZSAxMTpyZXR1cm4ocj9iPj1uLmJhdGNoZXNQZXJFcG9jaDp6LmRvbmUpP2k/KE49dm9pZCAwLGlzRGF0YXNldE9iamVjdChuLnZhbGlkYXRpb25EYXRhKT8oRT10b0xpc3QsWzQsZS5ldmFsdWF0ZURhdGFzZXQobi52YWxpZGF0aW9uRGF0YSx7YmF0Y2hlczpuLnZhbGlkYXRpb25CYXRjaGVzfSldKTpbMywxM10pOlszLDE1XTpbMywxNl07Y2FzZSAxMjpyZXR1cm4gTj1FLmFwcGx5KHZvaWQgMCxbTC5zZW50KCldKSxbMywxNF07Y2FzZSAxMzpOPXRvTGlzdChlLmV2YWx1YXRlKGEsbyx7YmF0Y2hTaXplOm51bGw9PW4udmFsaWRhdGlvbkJhdGNoU2l6ZT9ERUZBVUxUX1ZBTElEQVRJT05fQkFUQ0hfU0laRTpuLnZhbGlkYXRpb25CYXRjaFNpemUsdmVyYm9zZTowfSkpLEwubGFiZWw9MTQ7Y2FzZSAxNDpmb3Ioaz0wO2s8ZS5tZXRyaWNzTmFtZXMubGVuZ3RoOysrayl2W1widmFsX1wiK2UubWV0cmljc05hbWVzW2tdXT1OW2tdO0wubGFiZWw9MTU7Y2FzZSAxNTpyZXR1cm5bMywxN107Y2FzZSAxNjpyZXR1cm4gZS5zdG9wVHJhaW5pbmdfP1szLDE3XTpbMyw3XTtjYXNlIDE3OnJldHVybls0LGYub25FcG9jaEVuZChtLHYpXTtjYXNlIDE4OnJldHVybiBMLnNlbnQoKSxtKyssZS5zdG9wVHJhaW5pbmdfP1szLDE5XTpbMyw0XTtjYXNlIDE5OnJldHVybls0LGYub25UcmFpbkVuZCgpXTtjYXNlIDIwOnJldHVybiBMLnNlbnQoKSxbNCxlLmhpc3Rvcnkuc3luY0RhdGEoKV07Y2FzZSAyMTpyZXR1cm4gTC5zZW50KCksWzIsZS5oaXN0b3J5XTtjYXNlIDIyOnJldHVybiBlLmlzVHJhaW5pbmc9ITEsWzddO2Nhc2UgMjM6cmV0dXJuWzJdfX0pfSl9ZnVuY3Rpb24gZ2V0U3RlcHNQZXJFcG9jaChlLHQpe3ZhciBuPW51bGw7cmV0dXJuIG51bGwhPXQuYmF0Y2hlc1BlckVwb2NoP249dC5iYXRjaGVzUGVyRXBvY2g6TnVtYmVyLmlzRmluaXRlKGUuc2l6ZSkmJihuPWUuc2l6ZSksbn1mdW5jdGlvbiBpc0RhdGFzZXRPYmplY3QoZSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZS5pdGVyYXRvcn1mdW5jdGlvbiBpc0xhenlJdGVyYXRvck9iamVjdChlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlLm5leHR9ZnVuY3Rpb24gZXZhbHVhdGVEYXRhc2V0KGUsdCxuKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciByLGksYSxvLHMsbCx1LGMscCxoO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGQpe3N3aXRjaChkLmxhYmVsKXtjYXNlIDA6aWYocj1udWxsIT0obj1ufHx7fSkuYmF0Y2hlcyxpPWUudGVzdEZ1bmN0aW9uLGE9W10sbi52ZXJib3NlPjApdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJWZXJib3NlIG1vZGUgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7cmV0dXJuIHV0aWwuYXNzZXJ0KCFyfHxuLmJhdGNoZXM+MCYmTnVtYmVyLmlzSW50ZWdlcihuLmJhdGNoZXMpLGZ1bmN0aW9uKCl7cmV0dXJuXCJUZXN0IGxvb3AgZXhwZWN0cyBgYmF0Y2hlc2AgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBidXQgcmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkobi5iYXRjaGVzKX0pLGlzTGF6eUl0ZXJhdG9yT2JqZWN0KHQpPyhzPXQsWzMsM10pOlszLDFdO2Nhc2UgMTpyZXR1cm5bNCx0Lml0ZXJhdG9yKCldO2Nhc2UgMjpzPWQuc2VudCgpLGQubGFiZWw9MztjYXNlIDM6bz1zLGw9MCx1PTAsYz1mdW5jdGlvbigpe3ZhciB0O3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHMpe3N3aXRjaChzLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsby5uZXh0KCldO2Nhc2UgMTpyZXR1cm4gdD1zLnNlbnQoKSxhPXRpZHkoZnVuY3Rpb24oKXtpZih0LnZhbHVlKXt2YXIgbj1zdGFuZGFyZGl6ZURhdGFJdGVyYXRvck91dHB1dChlLHQudmFsdWUpLHI9dGlkeShmdW5jdGlvbigpe3JldHVybiBpKG4pfSk7aWYoZGlzcG9zZShuKSwwPT09dSlmb3IodmFyIG89MDtvPHIubGVuZ3RoOysrbylhLnB1c2goc2NhbGFyKDApKTt2YXIgcz1uWzBdLnNoYXBlWzBdLGM9ZnVuY3Rpb24oZSl7dmFyIHQ9cltlXSxuPWFbZV07YVtlXT10aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGFkZChhW2VdLG11bChzLHQpKX0pLHU+MCYmZGlzcG9zZShuKX07Zm9yKG89MDtvPHIubGVuZ3RoOysrbyljKG8pO2Rpc3Bvc2UociksbCs9cywrK3V9cmV0dXJuIGF9KSx0LmRvbmU/KHImJmNvbnNvbGUud2FybihcIllvdXIgZGF0YXNldCBpdGVyYXRvciByYW4gb3V0IG9mIGRhdGEgZHVyaW5nIGV2YWx1YXRlRGF0YXNldCgpLiBJbnRlcnJ1cHRpbmcgZXZhbHV0aW9uLiBNYWtlIHN1cmUgdGhhdCB5b3VyIGRhdGFzZXQgY2FuIGdlbmVyYXRlIGF0IGxlYXN0IGBiYXRjaGVzYCBiYXRjaGVzIChpbiB0aGlzIGNhc2UsIFwiK24uYmF0Y2hlcytcIiBiYXRjaGVzKS4gWW91IG1heSBuZWVkIHRvIHVzZSB0aGUgcmVwZWF0KCkgZnVuY3Rpb24gd2hlbiBidWlsZGluZyB5b3VyIGRhdGFzZXQuXCIpLFsyLFwiYnJlYWtcIl0pOlsyXX19KX0sZC5sYWJlbD00O2Nhc2UgNDpyZXR1cm4hcnx8dTxuLmJhdGNoZXM/WzUsYygpXTpbMyw2XTtjYXNlIDU6cmV0dXJuXCJicmVha1wiPT09ZC5zZW50KCk/WzMsNl06WzMsNF07Y2FzZSA2OmZvcihwPTA7cDxhLmxlbmd0aDsrK3ApaD1hW3BdLGFbcF09ZGl2KGFbcF0sbCksZGlzcG9zZShoKTtyZXR1cm5bMixzaW5nbGV0b25PckFycmF5KGEpXX19KX0pfWZ1bmN0aW9uIGNoZWNrQmF0Y2hTaXplKGUpe3V0aWwuYXNzZXJ0KGU+MCYmTnVtYmVyLmlzSW50ZWdlcihlKSxmdW5jdGlvbigpe3JldHVyblwiYmF0Y2hTaXplIGlzIHJlcXVpcmVkIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCBcIitlfSl9ZnVuY3Rpb24gc2xpY2VBcnJheXMoZSx0LG4pe3JldHVybiBudWxsPT1lP1tudWxsXTpBcnJheS5pc0FycmF5KGUpP2UubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBzbGljZUFsb25nRmlyc3RBeGlzKGUsdCxuLXQpfSk6c2xpY2VBbG9uZ0ZpcnN0QXhpcyhlLHQsbi10KX1mdW5jdGlvbiBzbGljZUFycmF5c0J5SW5kaWNlcyhlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PWU/bnVsbDpBcnJheS5pc0FycmF5KGUpP2UubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBzbGljZUFycmF5c0J5SW5kaWNlcyhlLHQpfSk6Z2F0aGVyJDEoZSxcImludDMyXCI9PT10LmR0eXBlP3Q6dC50b0ludCgpKX0pfWZ1bmN0aW9uIG1ha2VCYXRjaGVzKGUsdCl7Zm9yKHZhciBuPVtdLHI9MCxpPW51bGw7cjxlOykoaT1yK3QpPj1lJiYoaT1lKSxuLnB1c2goW3IsaV0pLHI9aTtyZXR1cm4gbn1mdW5jdGlvbiBmaXRMb29wKGUsdCxuLHIsaSxhLG8scyxsLHUsYyxwLGgsZCxmKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBnLG0seSx2LGIsdyx6LFM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oSSl7c3dpdGNoKEkubGFiZWwpe2Nhc2UgMDppZihudWxsPT1pJiYoaT0zMiksbnVsbD09YSYmKGE9MSksbnVsbD09YyYmKGM9ITApLG51bGw9PWgmJihoPTApLGc9ITEsbnVsbCE9bCYmbnVsbCE9dSYmKGc9ITApLG51bGwhPWYmJihnPSEwLG51bGw9PWQpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ2FuIG9ubHkgdXNlIGB2YWxpZGF0aW9uU3RlcHNgIHdoZW4gZG9pbmcgc3RlcC13aXNlIHRyYWluaW5nLCBpLmUuLCBgc3RlcHNQZXJFcG9jaGAgbXVzdCBiZSBzZXQuXCIpO3JldHVybiBudWxsIT0obT1lLmNoZWNrTnVtU2FtcGxlcyhuLGksZCxcInN0ZXBzX3Blcl9lcG9jaFwiKSkmJih5PXJhbmdlKDAsbSkpLG51bGw9PW8mJihvPTEpLHY9Y29uZmlndXJlQ2FsbGJhY2tzKHMsbyxhLGgsbSxkLGksZyxwKSxiPXYuY2FsbGJhY2tMaXN0LHc9di5oaXN0b3J5LGIuc2V0TW9kZWwoZSksZS5oaXN0b3J5PXcsWzQsYi5vblRyYWluQmVnaW4oKV07Y2FzZSAxOkkuc2VudCgpLGUuc3RvcFRyYWluaW5nXz0hMSx6PWZ1bmN0aW9uKGEpe3ZhciBvLHMscCxoLGY7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24odil7c3dpdGNoKHYubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxiLm9uRXBvY2hCZWdpbihhKV07Y2FzZSAxOmlmKHYuc2VudCgpLG89e30sbnVsbD09ZClyZXR1cm5bMywyXTt0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcInN0ZXBzUGVyRXBvY2ggbW9kZSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtjYXNlIDI6aWYoXCJiYXRjaFwiPT09Yyl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcImJhdGNoIHNodWZmbGluZyBpcyBub3QgaW1wbGVtbmV0ZWQgeWV0XCIpO2MmJnV0aWwuc2h1ZmZsZSh5KSxzPXRlbnNvcjFkKHkpLHA9bWFrZUJhdGNoZXMobSxpKSxoPWZ1bmN0aW9uKGEpe3ZhciBjO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKGgpe3N3aXRjaChoLmxhYmVsKXtjYXNlIDA6cmV0dXJuIGM9e30sWzQsYi5vbkJhdGNoQmVnaW4oYSxjKV07Y2FzZSAxOnJldHVybiBoLnNlbnQoKSx0aWR5KGZ1bmN0aW9uKCl7dmFyIGg9cFthXVswXSxkPXBbYV1bMV0sZj1zbGljZUFsb25nRmlyc3RBeGlzKHMsaCxkLWgpO2MuYmF0Y2g9YSxjLnNpemU9ZC1oO2Zvcih2YXIgbT1zbGljZUFycmF5c0J5SW5kaWNlcyhuLGYpLHk9dChtKSx2PTA7djxyLmxlbmd0aDsrK3Ype3ZhciBiPXJbdl0sdz15W3ZdO2NbYl09dyxrZWVwKHcpfWlmKGE9PT1wLmxlbmd0aC0xJiZnKXt2YXIgej1lLnRlc3RMb29wKGwsdSxpKTtmb3Iodj0wO3Y8ci5sZW5ndGg7Kyt2KXtiPXJbdl0sdz16W3ZdO2tlZXAodyksb1tcInZhbF9cIitiXT13fX19KSxbNCxiLm9uQmF0Y2hFbmQoYSxjKV07Y2FzZSAyOnJldHVybiBoLnNlbnQoKSxkaXNwb3NlVGVuc29yc0luTG9ncyhjKSxlLnN0b3BUcmFpbmluZ18/WzIsXCJicmVha1wiXTpbMl19fSl9LGY9MCx2LmxhYmVsPTM7Y2FzZSAzOnJldHVybiBmPHAubGVuZ3RoP1s1LGgoZildOlszLDZdO2Nhc2UgNDppZihcImJyZWFrXCI9PT12LnNlbnQoKSlyZXR1cm5bMyw2XTt2LmxhYmVsPTU7Y2FzZSA1OnJldHVybisrZixbMywzXTtjYXNlIDY6cy5kaXNwb3NlKCksdi5sYWJlbD03O2Nhc2UgNzpyZXR1cm5bNCxiLm9uRXBvY2hFbmQoYSxvKV07Y2FzZSA4OnJldHVybiB2LnNlbnQoKSxlLnN0b3BUcmFpbmluZ18/WzIsXCJicmVha1wiXTpbMl19fSl9LFM9aCxJLmxhYmVsPTI7Y2FzZSAyOnJldHVybiBTPGE/WzUseihTKV06WzMsNV07Y2FzZSAzOmlmKFwiYnJlYWtcIj09PUkuc2VudCgpKXJldHVyblszLDVdO0kubGFiZWw9NDtjYXNlIDQ6cmV0dXJuKytTLFszLDJdO2Nhc2UgNTpyZXR1cm5bNCxiLm9uVHJhaW5FbmQoKV07Y2FzZSA2OnJldHVybiBJLnNlbnQoKSxbNCxlLmhpc3Rvcnkuc3luY0RhdGEoKV07Y2FzZSA3OnJldHVybiBJLnNlbnQoKSxbMixlLmhpc3RvcnldfX0pfSl9ZnVuY3Rpb24gZml0VGVuc29ycyhlLHQsbixyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9e30pLF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXt2YXIgaSxhLG8scyxsLHUsYyxwLGgsZCxmLGcsbSx5LHYsYix3LHosUztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihJKXtzd2l0Y2goSS5sYWJlbCl7Y2FzZSAwOmlmKGUuaXNUcmFpbmluZyl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3RhcnQgdHJhaW5pbmcgYmVjYXVzZSBhbm90aGVyIGZpdCgpIGNhbGwgaXMgb25nb2luZy5cIik7ZS5pc1RyYWluaW5nPSEwLEkubGFiZWw9MTtjYXNlIDE6aWYoSS50cnlzLnB1c2goWzEsLDMsNF0pLGNoZWNrQmF0Y2hTaXplKGM9bnVsbD09ci5iYXRjaFNpemU/MzI6ci5iYXRjaFNpemUpLHA9ZS5zdGFuZGFyZGl6ZVVzZXJEYXRhKHQsbiwhMSxjKSxpPXBbMF0sYT1wWzFdLGg9ITEsZD12b2lkIDAsbnVsbCE9ci52YWxpZGF0aW9uRGF0YSYmci52YWxpZGF0aW9uRGF0YS5sZW5ndGg+MCl7aWYoaD0hMCwyIT09ci52YWxpZGF0aW9uRGF0YS5sZW5ndGgpdGhyb3cgMz09PXIudmFsaWRhdGlvbkRhdGEubGVuZ3RoP25ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwidmFsaWRhdGlvbkRhdGEgaW5jbHVkaW5nIHNhbXBsZSB3ZWlnaHRzIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTpuZXcgVmFsdWVFcnJvcihcIldoZW4gcGFzc2luZyB2YWxpZGF0aW9uIGRhdGEsIGl0IG11c3QgY29udGFpbiAyICh2YWxYLCB2YWxZKSBvciAzICh2YWxYLCB2YWxZLCB2YWxTYW1wbGVXZWlnaHQpIGl0ZW1zOyBcIityLnZhbGlkYXRpb25EYXRhK1wiIGlzIGludmFsaWQuXCIpO289ci52YWxpZGF0aW9uRGF0YVswXSxzPXIudmFsaWRhdGlvbkRhdGFbMV0sZj1lLnN0YW5kYXJkaXplVXNlckRhdGEobyxzLCEwLGMpLGw9ZlswXSx1PWZbMV0sZD1sLmNvbmNhdCh1KX1lbHNlIG51bGwhPXIudmFsaWRhdGlvblNwbGl0JiZyLnZhbGlkYXRpb25TcGxpdD4wJiZyLnZhbGlkYXRpb25TcGxpdDwxPyhoPSEwLGc9TWF0aC5mbG9vcihpWzBdLnNoYXBlWzBdKigxLXIudmFsaWRhdGlvblNwbGl0KSksbT1pWzBdLnNoYXBlWzBdLGw9c2xpY2VBcnJheXMoaSxnLG0pLGk9c2xpY2VBcnJheXMoaSwwLGcpLHU9c2xpY2VBcnJheXMoYSxnLG0pLGE9c2xpY2VBcnJheXMoYSwwLGcpLGQ9bC5jb25jYXQodSkpOm51bGwhPXIudmFsaWRhdGlvblN0ZXBzJiYoaD0hMCk7cmV0dXJuIHk9aS5jb25jYXQoYSksZS5jaGVja1RyYWluYWJsZVdlaWdodHNDb25zaXN0ZW5jeSgpLHY9ZS5tYWtlVHJhaW5GdW5jdGlvbigpLGI9ZS5nZXREZWR1cGVkTWV0cmljc05hbWVzKCksdz12b2lkIDAsej12b2lkIDAsaD8oZS5tYWtlVGVzdEZ1bmN0aW9uKCksdz1lLnRlc3RGdW5jdGlvbix6PWIuc2xpY2UoKS5jb25jYXQoYi5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuXCJ2YWxfXCIrZX0pKSk6KHc9bnVsbCxkPVtdLHo9Yi5zbGljZSgpKSxTPXN0YW5kYXJkaXplQ2FsbGJhY2tzKHIuY2FsbGJhY2tzLHIueWllbGRFdmVyeSksWzQsZml0TG9vcChlLHYseSxiLGMsci5lcG9jaHMsci52ZXJib3NlLFMsdyxkLHIuc2h1ZmZsZSx6LHIuaW5pdGlhbEVwb2NoLG51bGwsbnVsbCldO2Nhc2UgMjpyZXR1cm5bMixJLnNlbnQoKV07Y2FzZSAzOnJldHVybiBlLmlzVHJhaW5pbmc9ITEsZGlzcG9zZU5ld1RlbnNvcnMoaSx0KSxkaXNwb3NlTmV3VGVuc29ycyhhLG4pLGRpc3Bvc2VOZXdUZW5zb3JzKGwsbyksZGlzcG9zZU5ld1RlbnNvcnModSxzKSxbN107Y2FzZSA0OnJldHVyblsyXX19KX0pfWZ1bmN0aW9uIGVuc3VyZVRlbnNvcnNSYW5rMk9ySGlnaGVyKGUpe3ZhciB0PVtdO2UgaW5zdGFuY2VvZiBUZW5zb3ImJihlPVtlXSk7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDsrK24pe3ZhciByPWVbbl07aWYoMT09PXIucmFuayl0LnB1c2goZXhwYW5kRGltcyQxKHIsMSkpO2Vsc2V7aWYoMD09PXIucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCB0ZW5zb3IgdG8gYmUgYXQgbGVhc3QgMUQsIGJ1dCByZWNlaXZlZCBhIDBEIHRlbnNvciAoc2NhbGFyKS5cIik7dC5wdXNoKHIpfX1yZXR1cm4gdH1mdW5jdGlvbiBkaXNwb3NlTmV3VGVuc29ycyhlLHQpe2lmKG51bGwhPWUpe3ZhciBuPVtdO2lmKHQgaW5zdGFuY2VvZiBUZW5zb3Ipbi5wdXNoKHQuaWQpO2Vsc2UgaWYoQXJyYXkuaXNBcnJheSh0KSl0LmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIG4ucHVzaChlLmlkKX0pO2Vsc2UgaWYobnVsbCE9dClmb3IodmFyIHIgaW4gdCl7dmFyIGk9dFtyXTtuLnB1c2goaS5pZCl9dmFyIGE9W107aWYoZSBpbnN0YW5jZW9mIFRlbnNvciktMT09PW4uaW5kZXhPZihlLmlkKSYmYS5wdXNoKGUpO2Vsc2UgaWYoQXJyYXkuaXNBcnJheShlKSllLmZvckVhY2goZnVuY3Rpb24oZSl7LTE9PT1uLmluZGV4T2YoZS5pZCkmJmEucHVzaChlKX0pO2Vsc2UgaWYobnVsbCE9ZSlmb3IodmFyIG8gaW4gZSl7dmFyIHM9ZVtvXTstMT09PW4uaW5kZXhPZihzLmlkKSYmYS5wdXNoKHMpfWEuZm9yRWFjaChmdW5jdGlvbihlKXtlLmlzRGlzcG9zZWR8fGUuZGlzcG9zZSgpfSl9fWZ1bmN0aW9uIGlzRGF0YVRlbnNvcihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIFRlbnNvcn1mdW5jdGlvbiBpc0RhdGFBcnJheShlKXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKX1mdW5jdGlvbiBpc0RhdGFEaWN0KGUpe3JldHVybiFpc0RhdGFUZW5zb3IoZSkmJiFpc0RhdGFBcnJheShlKX1mdW5jdGlvbiBzdGFuZGFyZGl6ZUlucHV0RGF0YShlLHQsbixyLGkpe2lmKHZvaWQgMD09PXImJihyPSEwKSx2b2lkIDA9PT1pJiYoaT1cIlwiKSxudWxsPT10fHwwPT09dC5sZW5ndGgpe2lmKG51bGwhPWUpe3ZhciBhPSExO2lmKGlzRGF0YUFycmF5KGUpJiZlLmxlbmd0aD4wKWE9ITA7ZWxzZSBpZihpc0RhdGFEaWN0KGUpKXtmb3IodmFyIG8gaW4gZSlpZihlLmhhc093blByb3BlcnR5KG8pKXthPSEwO2JyZWFrfX1lbHNlIGE9ITA7aWYoYSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkVycm9yIHdoZW4gY2hlY2tpbmcgbW9kZWwgXCIraStcIiBleHBlY3RlZCBubyBkYXRhLCBidXQgZ290IFwiK2UpfXJldHVybltdfWlmKG51bGw9PWUpcmV0dXJuIHQubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBudWxsfSk7dmFyIHM7aWYoaXNEYXRhRGljdChlKSl7ZT1lLHM9W107Zm9yKHZhciBsPTAsdT10O2w8dS5sZW5ndGg7bCsrKXt2YXIgYz11W2xdO2lmKG51bGw9PWVbY10pdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ05vIGRhdGEgcHJvdmlkZWQgZm9yIFwiJytjKydcIi4gTmVlZCBkYXRhIGZvciBlYWNoIGtleSBpbjogJyt0KTtzLnB1c2goZVtjXSl9fWVsc2UgaWYoaXNEYXRhQXJyYXkoZSkpe2lmKChlPWUpLmxlbmd0aCE9PXQubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRXJyb3Igd2hlbiBjaGVja2luZyBtb2RlbCBcIitpK1wiOiB0aGUgQXJyYXkgb2YgVGVuc29ycyB0aGF0IHlvdSBhcmUgcGFzc2luZyB0byB5b3VyIG1vZGVsIGlzIG5vdCB0aGUgc2l6ZSB0aGUgbW9kZWwgZXhwZWN0ZWQuIEV4cGVjdGVkIHRvIHNlZSBcIit0Lmxlbmd0aCtcIiBUZW5zb3IocyksIGJ1dCBpbnN0ZWFkIGdvdCB0aGUgZm9sbG93aW5nIGxpc3Qgb2YgVGVuc29yKHMpOiBcIitlKTtzPWV9ZWxzZXtpZihlPWUsdC5sZW5ndGg+MSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBtb2RlbCBcIitpK1wiIGV4cGVjdHMgXCIrdC5sZW5ndGgrXCIgVGVuc29yKHMpLCBidXQgb25seSByZWNlaXZlZCBvbmUgVGVuc29yLiBGb3VuZDogVGVuc29yIHdpdGggc2hhcGUgXCIrZS5zaGFwZSk7cz1bZV19aWYocz1lbnN1cmVUZW5zb3JzUmFuazJPckhpZ2hlcihzKSxudWxsIT1uKWZvcih2YXIgcD0wO3A8dC5sZW5ndGg7KytwKWlmKG51bGwhPW5bcF0pe3ZhciBoPXNbcF07aWYoaC5zaGFwZS5sZW5ndGghPT1uW3BdLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkVycm9yIHdoZW4gY2hlY2tpbmcgXCIraStcIjogZXhwZWN0ZWQgXCIrdFtwXStcIiB0byBoYXZlIFwiK25bcF0ubGVuZ3RoK1wiIGRpbWVuc2lvbihzKS4gYnV0IGdvdCBhcnJheSB3aXRoIHNoYXBlIFwiK2guc2hhcGUpO2Zvcih2YXIgZD0wO2Q8bltwXS5sZW5ndGg7KytkKWlmKDAhPT1kfHxyKXt2YXIgZj1oLnNoYXBlW2RdLGc9bltwXVtkXTtpZihudWxsIT1nJiZnPj0wJiZmIT09Zyl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkVycm9yIHdoZW4gY2hlY2tpbmcgXCIraStcIjogZXhwZWN0ZWQgXCIrdFtwXStcIiB0byBoYXZlIHNoYXBlIFtcIituW3BdK1wiXSwgYnV0IGdvdCBhcnJheSB3aXRoIHNoYXBlIFtcIitoLnNoYXBlK1wiXS5cIil9fXJldHVybiBzfWZ1bmN0aW9uIGNoZWNrQXJyYXlMZW5ndGhzKGUsdCxuKXt2YXIgcj11bmlxdWUoZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hhcGVbMF19KSk7ci5zb3J0KCk7dmFyIGk9dW5pcXVlKHQubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNoYXBlWzBdfSkpO2lmKGkuc29ydCgpLHIubGVuZ3RoPjEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBbGwgaW5wdXQgVGVuc29ycyAoeCkgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHNhbXBsZXMuIEdvdCBhcnJheSBzaGFwZXM6IFwiK0pTT04uc3RyaW5naWZ5KGUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNoYXBlfSkpKTtpZihpLmxlbmd0aD4xKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQWxsIHRhcmdldCBUZW5zb3JzICh5KSBzaG91bGQgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygc2FtcGxlcy4gR290IGFycmF5IHNoYXBlczogXCIrSlNPTi5zdHJpbmdpZnkodC5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2hhcGV9KSkpO2lmKHIubGVuZ3RoPjAmJmkubGVuZ3RoPjAmJiF1dGlsLmFycmF5c0VxdWFsKHIsaSkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnB1dCBUZW5zb3JzIHNob3VsZCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBzYW1wbGVzIGFzIHRhcmdldCBUZW5zb3JzLiBGb3VuZCBcIityWzBdK1wiIGlucHV0IHNhbXBsZShzKSBhbmQgXCIraVswXStcIiB0YXJnZXQgc2FtcGxlKHMpLlwiKX1mdW5jdGlvbiBjaGVja0xvc3NBbmRUYXJnZXRDb21wYXRpYmlsaXR5KGUsdCxuKXtmb3IodmFyIHI9W21lYW5TcXVhcmVkRXJyb3IsYmluYXJ5Q3Jvc3NlbnRyb3B5LGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5XSxpPTA7aTxlLmxlbmd0aDsrK2kpe3ZhciBhPWVbaV0sbz10W2ldLHM9bltpXTtpZihudWxsIT1vKXtpZihvPT09Y2F0ZWdvcmljYWxDcm9zc2VudHJvcHkmJjE9PT1hLnNoYXBlW2Euc2hhcGUubGVuZ3RoLTFdKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiWW91IGFyZSBwYXNzaW5nIGEgdGFyZ2V0IGFycmF5IG9mIHNoYXBlIFwiK2Euc2hhcGUrXCIgd2hpbGUgdXNpbmcgYSBsb3NzICdjYXRlZ29yaWNhbF9jcm9zc2VudHJvcHknLiAnY2F0ZWdvcmljYWxfY3Jvc3NlbnRyb3B5J2V4cGVjdHMgdGFyZ2V0cyB0byBiZSBiaW5hcnkgbWF0cmljZXMgKDFzIGFuZCAwcykgb2Ygc2hhcGUgW3NhbXBsZXMsIGNsYXNzZXNdLlwiKTtpZigtMSE9PXIuaW5kZXhPZihvKSlmb3IodmFyIGw9YS5zaGFwZS5zbGljZSgxKSx1PXMuc2xpY2UoMSksYz0wO2M8bC5sZW5ndGg7KytjKXt2YXIgcD1sW2NdLGg9dVtjXTtpZihudWxsIT1oJiZwIT09aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkEgdGFyZ2V0IFRlbnNvciB3aXRoIHNoYXBlIFwiK2Euc2hhcGUrXCIgd2FzIHBhc3NlZCBmb3IgYW4gb3V0cHV0IG9mIHNoYXBlIFwiK3MrXCIsIHdoaWxlIHVzaW5nIGEgbG9zcyBmdW5jdGlvbiB0aGF0IGV4cGVjdHMgdGFyZ2V0cyB0byBoYXZlIHRoZSBzYW1lIHNoYXBlIGFzIHRoZSBvdXRwdXQuXCIpfX19fWZ1bmN0aW9uIGNoZWNrSW5wdXREYXRhKGUsdCxuLHIsaSl7dmFyIGE7aWYodm9pZCAwPT09ciYmKHI9ITApLHZvaWQgMD09PWkmJihpPVwiXCIpLEFycmF5LmlzQXJyYXkoZSkpe2lmKGUubGVuZ3RoIT09dC5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJFcnJvciB3aGVuIGNoZWNraW5nIG1vZGVsIFwiK2krXCI6IHRoZSBBcnJheSBvZiBUZW5zb3JzIHRoYXQgeW91IGFyZSBwYXNzaW5nIHRvIHlvdXIgbW9kZWwgaXMgbm90IHRoZSBzaXplIHRoZSB0aGUgbW9kZWwgZXhwZWN0ZWQuIEV4cGVjdGVkIHRvIHNlZSBcIit0Lmxlbmd0aCtcIiBUZW5zb3IocyksIGJ1dCBpbnN0ZWFkIGdvdCBcIitlLmxlbmd0aCtcIiBUZW5zb3JzKHMpLlwiKTthPWV9ZWxzZXtpZih0Lmxlbmd0aD4xKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIG1vZGVsIGV4cGVjdHMgXCIrdC5sZW5ndGgrXCIgXCIraStcIiBUZW5zb3JzLCBidXQgb25seSByZWNlaXZlZCBvbmUgVGVuc29yLiBGb3VuZDogYXJyYXkgd2l0aCBzaGFwZSBcIitKU09OLnN0cmluZ2lmeShlLnNoYXBlKStcIi5cIik7YT1bZV19aWYobnVsbCE9bilmb3IodmFyIG89MDtvPHQubGVuZ3RoOysrbylpZihudWxsIT1uW29dKXt2YXIgcz1hW29dO2lmKHMuc2hhcGUubGVuZ3RoIT09bltvXS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJFcnJvciB3aGVuIGNoZWNraW5nIFwiK2krXCI6IGV4cGVjdGVkIFwiK3Rbb10rXCIgdG8gaGF2ZSBcIituW29dLmxlbmd0aCtcIiBkaW1lbnNpb24ocyksIGJ1dCBnb3QgYXJyYXkgd2l0aCBzaGFwZSBcIitKU09OLnN0cmluZ2lmeShzLnNoYXBlKSk7Zm9yKHZhciBsPTA7bDxuW29dLmxlbmd0aDsrK2wpaWYoMCE9PWx8fHIpe3ZhciB1PXMuc2hhcGVbbF0sYz1uW29dW2xdO2lmKG51bGwhPWMmJmMhPT11KXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRXJyb3Igd2hlbiBjaGVja2luZyBcIitpK1wiOiBleHBlY3RlZCBcIit0W29dK1wiIHRvIGhhdmUgc2hhcGUgXCIrSlNPTi5zdHJpbmdpZnkobltvXSkrXCIgYnV0IGdvdCBhcnJheSB3aXRoIHNoYXBlIFwiK0pTT04uc3RyaW5naWZ5KHMuc2hhcGUpK1wiLlwiKX19fWZ1bmN0aW9uIGNvbGxlY3RNZXRyaWNzKGUsdCl7aWYobnVsbD09ZXx8QXJyYXkuaXNBcnJheShlKSYmMD09PWUubGVuZ3RoKXJldHVybiB0Lm1hcChmdW5jdGlvbihlKXtyZXR1cm5bXX0pO2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlfSk7aWYobnVsbCE9ZSl7Zm9yKHZhciBuPVtdLHI9MCxpPXQ7cjxpLmxlbmd0aDtyKyspe3ZhciBhPWlbcl0sbz1lLmhhc093blByb3BlcnR5KGEpP2VbYV06W107QXJyYXkuaXNBcnJheShvKXx8KG89W29dKSxuLnB1c2gobyl9cmV0dXJuIG59dGhyb3cgbmV3IFR5cGVFcnJvcihcIlR5cGUgb2YgbWV0cmljcyBhcmd1bWVudCBub3QgdW5kZXJzdG9vZC4gRXhwZWN0ZWQgYW4gQXJyYXkgb3IgT2JqZWN0LCBmb3VuZDogXCIrZSl9dmFyIExBWUVSU19NT0RFTF9GT1JNQVRfTkFNRT1cImxheWVycy1tb2RlbFwiLExheWVyc01vZGVsPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIG4uaXNUcmFpbmluZz0hMSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5zdW1tYXJ5PWZ1bmN0aW9uKGUsdCxuKXtpZih2b2lkIDA9PT1uJiYobj1jb25zb2xlLmxvZyksIXRoaXMuYnVpbHQpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGlzIG1vZGVsIGhhcyBuZXZlciBiZWVuIGNhbGxlZCwgdGh1cyBpdHMgd2VpZ2h0cyBoYXZlIG5vdCBiZWVuIGNyZWF0ZWQgeWV0LiBTbyBubyBzdW1tYXJ5IGNhbiBiZSBkaXNwbGF5ZWQuIEJ1aWxkIHRoZSBtb2RlbCBmaXJzdCAoZS5nLiwgYnkgY2FsbGluZyBpdCBvbiBzb21lIHRlc3QgZGF0YSkuXCIpO3ByaW50U3VtbWFyeSh0aGlzLGUsdCxuKX0sdC5wcm90b3R5cGUuY29tcGlsZT1mdW5jdGlvbihlKXt2YXIgdD10aGlzO2lmKG51bGw9PWUubG9zcyYmKGUubG9zcz1bXSksdGhpcy5sb3NzPWUubG9zcyxcInN0cmluZ1wiPT10eXBlb2YgZS5vcHRpbWl6ZXIpdGhpcy5vcHRpbWl6ZXJfPWdldE9wdGltaXplcihlLm9wdGltaXplciksdGhpcy5pc09wdGltaXplck93bmVkPSEwO2Vsc2V7aWYoIShlLm9wdGltaXplciBpbnN0YW5jZW9mIE9wdGltaXplcikpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJVc2VyLWRlZmluZWQgb3B0aW1pemVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgdGYuT3B0aW1pemVyLlwiKTt0aGlzLm9wdGltaXplcl89ZS5vcHRpbWl6ZXIsdGhpcy5pc09wdGltaXplck93bmVkPSExfXZhciBuPVtdO2lmKEFycmF5LmlzQXJyYXkoZS5sb3NzKXx8XCJzdHJpbmdcIj09dHlwZW9mIGUubG9zc3x8XCJmdW5jdGlvblwiPT10eXBlb2YgZS5sb3NzKWlmKEFycmF5LmlzQXJyYXkoZS5sb3NzKSl7aWYoZS5sb3NzLmxlbmd0aCE9PXRoaXMub3V0cHV0cy5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJXaGVuIHBhc3NpbmcgYW4gQXJyYXkgYXMgbG9zcywgaXQgc2hvdWxkIGhhdmUgb25lIGVudHJ5IHBlciBtb2RlbCBvdXRwdXQuIFRoZSBtb2RlbCBoYXMgXCIrdGhpcy5vdXRwdXRzLmxlbmd0aCtcIiBvdXRwdXQocyksIGJ1dCB5b3UgcGFzc2VkIGxvc3M9XCIrZS5sb3NzK1wiLlwiKTt2YXIgcj1lLmxvc3M7bj1yLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZ2V0KGUpfSl9ZWxzZXt2YXIgaT1nZXQoZS5sb3NzKTt0aGlzLm91dHB1dHMuZm9yRWFjaChmdW5jdGlvbihlKXtuLnB1c2goaSl9KX1lbHNle2Zvcih2YXIgYSBpbiBlLmxvc3M9ZS5sb3NzLGUubG9zcylpZigtMT09PXRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihhKSl0aHJvdyBuZXcgVmFsdWVFcnJvcignVW5rbm93biBlbnRyeSBpbiBsb3NzIGRpY3Rpb25hcnk6IFwiJythKydcIi4gT25seSBleHBlY3RlZCB0aGUgZm9sbG93aW5nIGtleXM6ICcrdGhpcy5vdXRwdXROYW1lcyk7Zm9yKHZhciBvPTAscz10aGlzLm91dHB1dE5hbWVzO288cy5sZW5ndGg7bysrKXt2YXIgbD1zW29dO251bGw9PWUubG9zc1tsXSYmY29uc29sZS53YXJuKCdPdXRwdXQgXCInK2wrJ1wiIGlzIG1pc3NpbmcgZnJvbSBsb3NzIGRpY3Rpb25hcnkuIFdlIGFzc3VtZSB0aGlzIHdhcyBkb25lIG9uIHB1cnBvc2UsIGFuZCB3ZSB3aWxsIG5vdCBiZSBleHBlY3RpbmcgZGF0YSB0byBiZSBwYXNzZWQgdG8gJytsK1wiIGR1cmluZyB0cmFpbmluZ1wiKSxuLnB1c2goZ2V0KGUubG9zc1tsXSkpfX10aGlzLmxvc3NGdW5jdGlvbnM9bix0aGlzLmZlZWRPdXRwdXROYW1lcz1bXSx0aGlzLmZlZWRPdXRwdXRTaGFwZXM9W10sdGhpcy5mZWVkTG9zc0Zucz1bXTtmb3IodmFyIHU9MDt1PHRoaXMub3V0cHV0cy5sZW5ndGg7Kyt1KXt2YXIgYz10aGlzLmludGVybmFsT3V0cHV0U2hhcGVzW3VdLHA9dGhpcy5vdXRwdXROYW1lc1t1XTt0aGlzLmZlZWRPdXRwdXROYW1lcy5wdXNoKHApLHRoaXMuZmVlZE91dHB1dFNoYXBlcy5wdXNoKGMpLHRoaXMuZmVlZExvc3NGbnMucHVzaCh0aGlzLmxvc3NGdW5jdGlvbnNbdV0pfXZhciBoPVtdO3RoaXMubWV0cmljcz1lLm1ldHJpY3MsdGhpcy5tZXRyaWNzTmFtZXM9W1wibG9zc1wiXSx0aGlzLm1ldHJpY3NUZW5zb3JzPVtdLG5hbWVTY29wZShcImxvc3NcIixmdW5jdGlvbigpe2Zvcih2YXIgZT0wO2U8dC5vdXRwdXRzLmxlbmd0aDsrK2UpaWYoLTE9PT1oLmluZGV4T2YoZSkpe3ZhciBuPXQubG9zc0Z1bmN0aW9uc1tlXTt0Lm91dHB1dHMubGVuZ3RoPjEmJih0Lm1ldHJpY3NUZW5zb3JzLnB1c2goW24sZV0pLHQubWV0cmljc05hbWVzLnB1c2godC5vdXRwdXROYW1lc1tlXStcIl9sb3NzXCIpKX19KTt2YXIgZD1jb2xsZWN0TWV0cmljcyhlLm1ldHJpY3MsdGhpcy5vdXRwdXROYW1lcyk7bmFtZVNjb3BlKFwibWV0cmljXCIsZnVuY3Rpb24oKXtmb3IodmFyIGU9ZnVuY3Rpb24oZSl7aWYoLTEhPT1oLmluZGV4T2YoZSkpcmV0dXJuXCJjb250aW51ZVwiOyFmdW5jdGlvbihuKXtmb3IodmFyIHIsaSxhLG89ZnVuY3Rpb24obil7aWYoLTEhPT1bXCJhY2N1cmFjeVwiLFwiYWNjXCIsXCJjcm9zc2VudHJvcHlcIixcImNlXCJdLmluZGV4T2Yobikpe3ZhciBvPXQuaW50ZXJuYWxPdXRwdXRTaGFwZXNbZV07MT09PW9bby5sZW5ndGgtMV18fHQubG9zc0Z1bmN0aW9uc1tlXT09PWJpbmFyeUNyb3NzZW50cm9weT8tMSE9PVtcImFjY3VyYWN5XCIsXCJhY2NcIl0uaW5kZXhPZihuKT9pPWJpbmFyeUFjY3VyYWN5Oi0xIT09W1wiY3Jvc3NlbnRyb3B5XCIsXCJjZVwiXS5pbmRleE9mKG4pJiYoaT1iaW5hcnlDcm9zc2VudHJvcHkkMSk6dC5sb3NzRnVuY3Rpb25zW2VdPT09c3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHk/LTEhPT1bXCJhY2N1cmFjeVwiLFwiYWNjXCJdLmluZGV4T2Yobik/aT1zcGFyc2VDYXRlZ29yaWNhbEFjY3VyYWN5Oi0xIT09W1wiY3Jvc3NlbnRyb3B5XCIsXCJjZVwiXS5pbmRleE9mKG4pJiYoaT1zcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weSQxKTotMSE9PVtcImFjY3VyYWN5XCIsXCJhY2NcIl0uaW5kZXhPZihuKT9pPWNhdGVnb3JpY2FsQWNjdXJhY3k6LTEhPT1bXCJjcm9zc2VudHJvcHlcIixcImNlXCJdLmluZGV4T2YobikmJihpPWNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5JDEpO3ZhciBzPXZvaWQgMDstMSE9PVtcImFjY3VyYWN5XCIsXCJhY2NcIl0uaW5kZXhPZihuKT9zPVwiYWNjXCI6LTEhPT1bXCJjcm9zc2VudHJvcHlcIixcImNlXCJdLmluZGV4T2YobikmJihzPVwiY2VcIiksYT1pLHI9XCJcIitzfWVsc2V7dmFyIGw9Z2V0JDEobik7YT1sLHI9XCJcIitufXZhciB1O25hbWVTY29wZShyLGZ1bmN0aW9uKCl7dT1hfSksZnVuY3Rpb24oZSxuLHIpe3Qub3V0cHV0TmFtZXMubGVuZ3RoPjEmJihuPXQub3V0cHV0TmFtZXNbZV0rXCJfXCIrbiksdC5tZXRyaWNzTmFtZXMucHVzaChuKSx0Lm1ldHJpY3NUZW5zb3JzLnB1c2goW3IsZV0pfShlLHIsdSl9LHM9MCxsPW47czxsLmxlbmd0aDtzKyspbyhsW3NdKX0oZFtlXSl9LG49MDtuPHQub3V0cHV0cy5sZW5ndGg7KytuKWUobil9KSx0aGlzLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHM9dGhpcy50cmFpbmFibGVXZWlnaHRzfSx0LnByb3RvdHlwZS5jaGVja1RyYWluYWJsZVdlaWdodHNDb25zaXN0ZW5jeT1mdW5jdGlvbigpe251bGwhPXRoaXMuY29sbGVjdGVkVHJhaW5hYmxlV2VpZ2h0cyYmdGhpcy50cmFpbmFibGVXZWlnaHRzLmxlbmd0aCE9PXRoaXMuY29sbGVjdGVkVHJhaW5hYmxlV2VpZ2h0cy5sZW5ndGgmJmNvbnNvbGUud2FybihcIkRpc2NyZXBhbmN5IGJldHdlZW4gdHJhaW5hYmxld2VpZ2h0cyBhbmQgY29sbGVjdGVkIHRyYWluYWJsZSB3ZWlnaHRzLiBEaWQgeW91IHNldCBgbW9kZWwudHJhaW5hYmxlYCB3aXRob3V0IGNhbGxpbmcgYG1vZGVsLmNvbXBpbGUoKWAgYWZ0ZXJ3YXJkcz9cIil9LHQucHJvdG90eXBlLmV2YWx1YXRlPWZ1bmN0aW9uKGUsdCxuKXt2b2lkIDA9PT1uJiYobj17fSk7dmFyIHI9bnVsbD09bi5iYXRjaFNpemU/MzI6bi5iYXRjaFNpemU7Y2hlY2tCYXRjaFNpemUocik7dmFyIGk9dGhpcy5zdGFuZGFyZGl6ZVVzZXJEYXRhKGUsdCwhMCxyKTt0cnl7dmFyIGE9aVswXS5jb25jYXQoaVsxXSk7dGhpcy5tYWtlVGVzdEZ1bmN0aW9uKCk7dmFyIG89dGhpcy50ZXN0RnVuY3Rpb247cmV0dXJuIHNpbmdsZXRvbk9yQXJyYXkodGhpcy50ZXN0TG9vcChvLGEscixuLnZlcmJvc2Usbi5zdGVwcykpfWZpbmFsbHl7ZGlzcG9zZU5ld1RlbnNvcnMoaVswXSxlKSxkaXNwb3NlTmV3VGVuc29ycyhpWzFdLHQpfX0sdC5wcm90b3R5cGUuZXZhbHVhdGVEYXRhc2V0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5tYWtlVGVzdEZ1bmN0aW9uKCksWzIsZXZhbHVhdGVEYXRhc2V0KHRoaXMsZSx0KV19KX0pfSx0LnByb3RvdHlwZS5jaGVja051bVNhbXBsZXM9ZnVuY3Rpb24oZSx0LG4scil7dmFyIGk7aWYodm9pZCAwPT09ciYmKHI9XCJzdGVwc1wiKSxudWxsIT1uKXtpZihpPW51bGwsbnVsbCE9dCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklmIFwiK3IrXCIgaXMgc2V0LCBiYXRjaFNpemUgbXVzdCBiZSBudWxsIG9yIHVuZGVmaW5lZC5Hb3QgYmF0Y2hTaXplID0gXCIrdCl9ZWxzZXtpZihudWxsPT1lKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRWl0aGVyIHRoZSBpbnB1dCBkYXRhIHNob3VsZCBoYXZlIGEgZGVmaW5lZCBzaGFwZSwgb3IgXCIrcitcIiBzaG91ZCBiZSBzcGVjaWZpZWQuXCIpO2k9QXJyYXkuaXNBcnJheShlKT9lWzBdLnNoYXBlWzBdOmUuc2hhcGVbMF19cmV0dXJuIGl9LHQucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oZSx0KXtpZihBcnJheS5pc0FycmF5KHQpJiYwPT09dC5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJgb3V0cHV0c2AgaXMgYW4gZW1wdHkgQXJyYXksIHdoaWNoIGlzIG5vdCBhbGxvd2VkLlwiKTt2YXIgbj1BcnJheS5pc0FycmF5KHQpLHI9bj90Olt0XSxpPXRoaXMucmV0cmlldmVTeW1ib2xpY1RlbnNvcnMociksYT1uZXcgRmVlZERpY3Q7aWYoZSBpbnN0YW5jZW9mIFRlbnNvciYmKGU9W2VdKSxBcnJheS5pc0FycmF5KGUpKXtpZihlLmxlbmd0aCE9PXRoaXMuaW5wdXRzLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBudW1iZXIgb2YgaW5wdXRzIHByb3ZpZGVkIChcIitlLmxlbmd0aCtcIikgZG9lcyBub3QgbWF0Y2ggdGhlIG51bWJlciBvZiBpbnB1dHMgb2YgdGhpcyBtb2RlbCAoXCIrdGhpcy5pbnB1dHMubGVuZ3RoK1wiKS5cIik7Zm9yKHZhciBvPTA7bzx0aGlzLmlucHV0cy5sZW5ndGg7KytvKWEuYWRkKHRoaXMuaW5wdXRzW29dLGVbb10pfWVsc2UgZm9yKHZhciBzPTAsbD10aGlzLmlucHV0cztzPGwubGVuZ3RoO3MrKyl7dmFyIHU9bFtzXSxjPWVbdS5uYW1lXTtpZihudWxsPT1jKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTm8gdmFsdWUgaXMgcHJvdmlkZWQgZm9yIHRoZSBtb2RlbCdzIGlucHV0IFwiK3UubmFtZSk7YS5hZGQodSxjKX12YXIgcD1leGVjdXRlKGksYSk7cmV0dXJuIG4/cDpwWzBdfSx0LnByb3RvdHlwZS5yZXRyaWV2ZVN5bWJvbGljVGVuc29ycz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9cHlMaXN0UmVwZWF0KG51bGwsZS5sZW5ndGgpLG49ZS5sZW5ndGgscj0wLGk9dGhpcy5sYXllcnM7cjxpLmxlbmd0aDtyKyspe2Zvcih2YXIgYT1pW3JdLG89QXJyYXkuaXNBcnJheShhLm91dHB1dCk/YS5vdXRwdXQ6W2Eub3V0cHV0XSxzPW8ubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLm5hbWV9KSxsPTA7bDxlLmxlbmd0aDsrK2wpe3ZhciB1PXMuaW5kZXhPZihlW2xdKTtpZigtMSE9PXUmJih0W2xdPW9bdV0sbi0tKSwwPT09bilicmVha31pZigwPT09bilicmVha31pZihuPjApe3ZhciBjPVtdO3Rocm93IHQuZm9yRWFjaChmdW5jdGlvbih0LG4pe251bGw9PXQmJmMucHVzaChlW25dKX0pLG5ldyBWYWx1ZUVycm9yKFwiQ2Fubm90IGZpbmQgU3ltYm9saWNUZW5zb3JzIGZvciBvdXRwdXQgbmFtZShzKTogXCIrSlNPTi5zdHJpbmdpZnkoYykpfXJldHVybiB0fSx0LnByb3RvdHlwZS5wcmVkaWN0TG9vcD1mdW5jdGlvbihlLHQsbil7dmFyIHI9dGhpcztyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MzIpLHZvaWQgMD09PW4mJihuPSExKSx0aWR5KGZ1bmN0aW9uKCl7dmFyIGk9ci5jaGVja051bVNhbXBsZXMoZSk7aWYobil0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlZlcmJvc2UgcHJlZGljdExvb3AoKSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtmb3IodmFyIGE9bWFrZUJhdGNoZXMoaSx0KSxvPXIub3V0cHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuW119KSxzPWZ1bmN0aW9uKHQpe3RpZHkoZnVuY3Rpb24oKXt2YXIgbj1hW3RdWzBdLGk9YVt0XVsxXSxvPXNsaWNlQXJyYXlzKGUsbixpKSxzPVtdO2lmKEFycmF5LmlzQXJyYXkobykpZm9yKHZhciBsPTA7bDxvLmxlbmd0aDsrK2wpcy5wdXNoKHtrZXk6ci5pbnB1dHNbbF0sdmFsdWU6b1tsXX0pO2Vsc2Ugcy5wdXNoKHtrZXk6ci5pbnB1dHNbMF0sdmFsdWU6b30pO3ZhciB1PW5ldyBGZWVkRGljdChzKTtyZXR1cm4gZXhlY3V0ZShyLm91dHB1dHMsdSl9KS5mb3JFYWNoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIG9bdF0ucHVzaChlKX0pfSxsPTA7bDxhLmxlbmd0aDsrK2wpcyhsKTtyZXR1cm4gc2luZ2xldG9uT3JBcnJheShvLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gY29uY2F0KGUsMCl9KSl9KX0sdC5wcm90b3R5cGUucHJlZGljdD1mdW5jdGlvbihlLHQpe3ZvaWQgMD09PXQmJih0PXt9KTt2YXIgbj1lbnN1cmVUZW5zb3JzUmFuazJPckhpZ2hlcihlKTtjaGVja0lucHV0RGF0YShuLHRoaXMuaW5wdXROYW1lcyx0aGlzLmZlZWRJbnB1dFNoYXBlcywhMSk7dHJ5e3ZhciByPW51bGw9PXQuYmF0Y2hTaXplPzMyOnQuYmF0Y2hTaXplO3JldHVybiBjaGVja0JhdGNoU2l6ZShyKSx0aGlzLnByZWRpY3RMb29wKG4scil9ZmluYWxseXtkaXNwb3NlTmV3VGVuc29ycyhuLGUpfX0sdC5wcm90b3R5cGUucHJlZGljdE9uQmF0Y2g9ZnVuY3Rpb24oZSl7cmV0dXJuIGNoZWNrSW5wdXREYXRhKGUsdGhpcy5pbnB1dE5hbWVzLHRoaXMuZmVlZElucHV0U2hhcGVzLCEwKSx0aGlzLnByZWRpY3RMb29wKGUsZS5zaGFwZVswXSl9LHQucHJvdG90eXBlLnN0YW5kYXJkaXplVXNlckRhdGE9ZnVuY3Rpb24oZSx0LG4scil7aWYodm9pZCAwPT09biYmKG49ITApLG51bGw9PXRoaXMub3B0aW1pemVyXyl0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiWW91IG11c3QgY29tcGlsZSBhIG1vZGVsIGJlZm9yZSB0cmFpbmluZy90ZXN0aW5nLiBVc2UgTGF5ZXJzTW9kZWwuY29tcGlsZShtb2RlbENvbXBpbGVBcmdzKS5cIik7Zm9yKHZhciBpPVtdLGE9MDthPHRoaXMuZmVlZE91dHB1dFNoYXBlcy5sZW5ndGg7KythKXt2YXIgbz10aGlzLmZlZWRPdXRwdXRTaGFwZXNbYV07dGhpcy5mZWVkTG9zc0Zuc1thXT09PXNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5P2kucHVzaChvLnNsaWNlKDAsby5sZW5ndGgtMSkuY29uY2F0KFsxXSkpOmkucHVzaChvKX1pZihjaGVja0FycmF5TGVuZ3RocyhlPXN0YW5kYXJkaXplSW5wdXREYXRhKGUsdGhpcy5mZWVkSW5wdXROYW1lcyx0aGlzLmZlZWRJbnB1dFNoYXBlcywhMSxcImlucHV0XCIpLHQ9c3RhbmRhcmRpemVJbnB1dERhdGEodCx0aGlzLmZlZWRPdXRwdXROYW1lcyxpLCExLFwidGFyZ2V0XCIpLG51bGwpLGNoZWNrTG9zc0FuZFRhcmdldENvbXBhdGliaWxpdHkodCx0aGlzLmZlZWRMb3NzRm5zLHRoaXMuZmVlZE91dHB1dFNoYXBlcyksdGhpcy5zdGF0ZWZ1bCYmbnVsbCE9ciYmcj4wJiZlWzBdLnNoYXBlWzBdJXIhPTApdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbiBhIHN0YXRlZnVsIG5ldHdvcmssIHlvdSBzaG91bGQgb25seSBwYXNzIGlucHV0cyB3aXRoIGEgbnVtYmVyIG9mIHNhbXBsZXMgdGhhdCBpcyBkaXZpc2libGUgYnkgdGhlIGJhdGNoIHNpemUgXCIrcitcIi4gRm91bmQ6IFwiK2VbMF0uc2hhcGVbMF0rXCIgc2FtcGxlKHMpLlwiKTtyZXR1cm5bZSx0LG51bGxdfSx0LnByb3RvdHlwZS50ZXN0TG9vcD1mdW5jdGlvbihlLHQsbixyLGkpe3ZhciBhPXRoaXM7cmV0dXJuIHZvaWQgMD09PXImJihyPTApLHRpZHkoZnVuY3Rpb24oKXt2YXIgbz1hLmNoZWNrTnVtU2FtcGxlcyh0LG4saSxcInN0ZXBzXCIpLHM9W107aWYocj4wKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiVmVyYm9zZSBtb2RlIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO2lmKG51bGwhPWkpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJzdGVwcyBtb2RlIGluIHRlc3RMb29wKCkgaXMgbm90IGltcGxlbWVudGVkIHlldFwiKTtmb3IodmFyIGw9bWFrZUJhdGNoZXMobyxuKSx1PXRlbnNvcjFkKHJhbmdlKDAsbykpLGM9MDtjPGwubGVuZ3RoOysrYyl7dmFyIHA9bFtjXVswXSxoPWxbY11bMV0sZD1zbGljZUFsb25nRmlyc3RBeGlzKHUscCxoLXApLGY9c2xpY2VBcnJheXNCeUluZGljZXModCxkKSxnPWUoZik7aWYoMD09PWMpZm9yKHZhciBtPTA7bTxnLmxlbmd0aDsrK20pcy5wdXNoKHNjYWxhcigwKSk7Zm9yKG09MDttPGcubGVuZ3RoOysrbSl7dmFyIHk9Z1ttXTtzW21dPWFkZChzW21dLG11bChoLXAseSkpfX1mb3IobT0wO208cy5sZW5ndGg7KyttKXNbbV09ZGl2KHNbbV0sbyk7cmV0dXJuIHN9KX0sdC5wcm90b3R5cGUuZ2V0RGVkdXBlZE1ldHJpY3NOYW1lcz1mdW5jdGlvbigpe2Zvcih2YXIgZT10aGlzLm1ldHJpY3NOYW1lcyx0PVtdLG49MDtuPGUubGVuZ3RoOysrbil7dmFyIHI9ZVtuXSxpPXI7aWYoY291bnQoZSxyKT4xKWkrPVwiX1wiK2NvdW50KGUuc2xpY2UoMCxuKSxyKTt0LnB1c2goaSl9cmV0dXJuIHR9LHQucHJvdG90eXBlLm1ha2VUcmFpbkZ1bmN0aW9uPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcztyZXR1cm4gZnVuY3Rpb24odCl7dmFyIG49dC5zbGljZSgwLGUuaW5wdXRzLmxlbmd0aCkscj10LnNsaWNlKGUuaW5wdXRzLmxlbmd0aCxlLmlucHV0cy5sZW5ndGgrZS5vdXRwdXRzLmxlbmd0aCksaT1bXSxhPWUuY29sbGVjdGVkVHJhaW5hYmxlV2VpZ2h0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVhZCgpfSk7cmV0dXJuW2Uub3B0aW1pemVyXy5taW5pbWl6ZShmdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxhPTA7YTxlLmlucHV0cy5sZW5ndGg7KythKXQucHVzaCh7a2V5OmUuaW5wdXRzW2FdLHZhbHVlOm5bYV19KTt2YXIgbyxzPW5ldyBGZWVkRGljdCh0KSxsPWV4ZWN1dGUoZS5vdXRwdXRzLHMse3RyYWluaW5nOiEwfSk7Zm9yKGE9MDthPGUubG9zc0Z1bmN0aW9ucy5sZW5ndGg7KythKXt2YXIgdT0oMCxlLmxvc3NGdW5jdGlvbnNbYV0pKHJbYV0sbFthXSk7bWVhbih1KSxvPTA9PT1hP3U6YWRkKG8sdSl9Zm9yKGE9MDthPGUubWV0cmljc1RlbnNvcnMubGVuZ3RoOysrYSl7dmFyIGM9ZS5tZXRyaWNzVGVuc29yc1thXVswXSxwPWUubWV0cmljc1RlbnNvcnNbYV1bMV0saD1tZWFuKGMocltwXSxsW3BdKSk7a2VlcChoKSxpLnB1c2goaCl9cmV0dXJuIG89bWVhbihvKSxlLmNhbGN1bGF0ZUxvc3NlcygpLmZvckVhY2goZnVuY3Rpb24oZSl7bz1hZGQobyxlKX0pLG99LCEwLGEpXS5jb25jYXQoaSl9fSx0LnByb3RvdHlwZS5tYWtlVGVzdEZ1bmN0aW9uPWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLnRlc3RGdW5jdGlvbj1mdW5jdGlvbih0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe2Zvcih2YXIgbixyPVtdLGk9dC5zbGljZSgwLGUuaW5wdXRzLmxlbmd0aCksYT10LnNsaWNlKGUuaW5wdXRzLmxlbmd0aCxlLmlucHV0cy5sZW5ndGgrZS5vdXRwdXRzLmxlbmd0aCksbz1bXSxzPTA7czxlLmlucHV0cy5sZW5ndGg7KytzKW8ucHVzaCh7a2V5OmUuaW5wdXRzW3NdLHZhbHVlOmlbc119KTt2YXIgbD1uZXcgRmVlZERpY3QobyksdT1leGVjdXRlKGUub3V0cHV0cyxsKTtmb3Iocz0wO3M8ZS5sb3NzRnVuY3Rpb25zLmxlbmd0aDsrK3Mpe3ZhciBjPWUubG9zc0Z1bmN0aW9uc1tzXSxwPW1lYW4oYyhhW3NdLHVbc10pKTtuPTA9PT1zP3A6YWRkKG4scCksci5wdXNoKG4pfWZvcihzPTA7czxlLm1ldHJpY3NUZW5zb3JzLmxlbmd0aDsrK3Mpe3ZhciBoPWUubWV0cmljc1RlbnNvcnNbc11bMF0sZD1lLm1ldHJpY3NUZW5zb3JzW3NdWzFdLGY9bWVhbihoKGFbZF0sdVtkXSkpO3IucHVzaChmKX1yZXR1cm4gcn0pfX0sdC5wcm90b3R5cGUuZml0PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49e30pLF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihyKXtyZXR1cm5bMixmaXRUZW5zb3JzKHRoaXMsZSx0LG4pXX0pfSl9LHQucHJvdG90eXBlLmZpdERhdGFzZXQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3JldHVyblsyLGZpdERhdGFzZXQodGhpcyxlLHQpXX0pfSl9LHQucHJvdG90eXBlLnRyYWluT25CYXRjaD1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIG4scixpLGEsbyxzLGwsdSxjO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHApe3N3aXRjaChwLmxhYmVsKXtjYXNlIDA6bj10aGlzLnN0YW5kYXJkaXplVXNlckRhdGEoZSx0KSxyPW5bMF0saT1uWzFdLGE9dGhpcy5tYWtlVHJhaW5GdW5jdGlvbigpLG89YShyLmNvbmNhdChpKSkscz1bXSxsPTAsdT1vLHAubGFiZWw9MTtjYXNlIDE6cmV0dXJuIGw8dS5sZW5ndGg/WzQsdVtsXS5kYXRhKCldOlszLDRdO2Nhc2UgMjpjPXAuc2VudCgpLHMucHVzaChjWzBdKSxwLmxhYmVsPTM7Y2FzZSAzOnJldHVybiBsKyssWzMsMV07Y2FzZSA0OnJldHVybiBkaXNwb3NlKG8pLFsyLHNpbmdsZXRvbk9yQXJyYXkocyldfX0pfSl9LHQucHJvdG90eXBlLmdldE5hbWVkV2VpZ2h0cz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9e30sbj1udWxsIT1lJiZlLnRyYWluYWJsZU9ubHkscj1uP3RoaXMudHJhaW5hYmxlV2VpZ2h0czp0aGlzLndlaWdodHMsaT10aGlzLmdldFdlaWdodHMobiksYT0wO2E8ci5sZW5ndGg7KythKW4mJiFyW2FdLnRyYWluYWJsZXx8KHRbclthXS5vcmlnaW5hbE5hbWVdPWlbYV0pO3JldHVybiB0fSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJzdG9wVHJhaW5pbmdcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RvcFRyYWluaW5nX30sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuc3RvcFRyYWluaW5nXz1lfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIm9wdGltaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcHRpbWl6ZXJffSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5vcHRpbWl6ZXJfIT09ZSYmKHRoaXMub3B0aW1pemVyXz1lLHRoaXMuaXNPcHRpbWl6ZXJPd25lZD0hMSl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3ZhciB0PWUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtpZigwPT09dC5yZWZDb3VudEFmdGVyRGlzcG9zZSYmbnVsbCE9dGhpcy5vcHRpbWl6ZXImJnRoaXMuaXNPcHRpbWl6ZXJPd25lZCl7dmFyIG49bWVtb3J5KCkubnVtVGVuc29yczt0aGlzLm9wdGltaXplcl8uZGlzcG9zZSgpLHQubnVtRGlzcG9zZWRWYXJpYWJsZXMrPW4tbWVtb3J5KCkubnVtVGVuc29yc31yZXR1cm4gdH0sdC5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIG4scixpLGEsbztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihzKXtzd2l0Y2gocy5sYWJlbCl7Y2FzZSAwOmlmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXtpZigwPT09KG49aW8uZ2V0U2F2ZUhhbmRsZXJzKGUpKS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDYW5ub3QgZmluZCBhbnkgc2F2ZSBoYW5kbGVycyBmb3IgVVJMICdcIitlK1wiJ1wiKTtpZihuLmxlbmd0aD4xKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRm91bmQgbW9yZSB0aGFuIG9uZSAoXCIrbi5sZW5ndGgrXCIpIHNhdmUgaGFuZGxlcnMgZm9yIFVSTCAnXCIrZStcIidcIik7ZT1uWzBdfWlmKG51bGw9PWUuc2F2ZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkxheWVyc01vZGVsLnNhdmUoKSBjYW5ub3QgcHJvY2VlZCBiZWNhdXNlIHRoZSBJT0hhbmRsZXIgcHJvdmlkZWQgZG9lcyBub3QgaGF2ZSB0aGUgYHNhdmVgIGF0dHJpYnV0ZSBkZWZpbmVkLlwiKTtyZXR1cm5bNCxpby5lbmNvZGVXZWlnaHRzKHRoaXMuZ2V0TmFtZWRXZWlnaHRzKHQpKV07Y2FzZSAxOnJldHVybiByPXMuc2VudCgpLGk9ITEsYT1udWxsLG89dGhpcy50b0pTT04oYSxpKSxbMixlLnNhdmUoe21vZGVsVG9wb2xvZ3k6byx3ZWlnaHREYXRhOnIuZGF0YSx3ZWlnaHRTcGVjczpyLnNwZWNzLGZvcm1hdDpMQVlFUlNfTU9ERUxfRk9STUFUX05BTUUsZ2VuZXJhdGVkQnk6XCJUZW5zb3JGbG93LmpzIHRmanMtbGF5ZXJzIHZcIit2ZXJzaW9uLGNvbnZlcnRlZEJ5Om51bGx9KV19fSl9KX0sdC5jbGFzc05hbWU9XCJNb2RlbFwiLHR9KENvbnRhaW5lcik7ZnVuY3Rpb24gbW9kZWxGcm9tSlNPTihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIG4scixpLGEsbyxzLGwsdTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihjKXtzd2l0Y2goYy5sYWJlbCl7Y2FzZSAwOnJldHVyblwibW9kZWxUb3BvbG9neVwiaW4gZXx8KGU9e21vZGVsVG9wb2xvZ3k6ZX0pLG51bGwhPShuPShlPWUpLm1vZGVsVG9wb2xvZ3kpLm1vZGVsX2NvbmZpZyYmKG49bi5tb2RlbF9jb25maWcpLHI9Y29udmVydFB5dGhvbmljVG9UcyhuKSxpPWRlc2VyaWFsaXplKHIsdCksbnVsbD09ZS53ZWlnaHRzTWFuaWZlc3Q/WzMsMl06WzQsaW8ubG9hZFdlaWdodHMoZS53ZWlnaHRzTWFuaWZlc3QsZS5wYXRoUHJlZml4LGkud2VpZ2h0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUub3JpZ2luYWxOYW1lfSkpXTtjYXNlIDE6Zm9yKGE9Yy5zZW50KCksbz17fSxzPTAsbD1pLndlaWdodHM7czxsLmxlbmd0aDtzKyspdT1sW3NdLG9bdS5vcmlnaW5hbE5hbWVdPWFbdS5vcmlnaW5hbE5hbWVdO2kubG9hZFdlaWdodHMobyksZGlzcG9zZShhKSxjLmxhYmVsPTI7Y2FzZSAyOnJldHVyblsyLGldfX0pfSl9ZnVuY3Rpb24gbG9hZExheWVyc01vZGVsSW50ZXJuYWwoZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBuO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe2lmKG51bGw9PXQmJih0PXt9KSxcInN0cmluZ1wiPT10eXBlb2YgZSl7aWYoMD09PShuPWlvLmdldExvYWRIYW5kbGVycyhlKSkubGVuZ3RoKW4ucHVzaChpby5icm93c2VySFRUUFJlcXVlc3QoZSx0KSk7ZWxzZSBpZihuLmxlbmd0aD4xKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRm91bmQgbW9yZSB0aGFuIG9uZSAoXCIrbi5sZW5ndGgrXCIpIGxvYWQgaGFuZGxlcnMgZm9yIFVSTCAnXCIrZStcIidcIik7ZT1uWzBdfXJldHVyblsyLGxvYWRMYXllcnNNb2RlbEZyb21JT0hhbmRsZXIoZSx2b2lkIDAsdCldfSl9KX1mdW5jdGlvbiBsb2FkTGF5ZXJzTW9kZWxGcm9tSU9IYW5kbGVyKGUsdCxuKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciByLGksYSxvLHMsbDtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbih1KXtzd2l0Y2godS5sYWJlbCl7Y2FzZSAwOmlmKG51bGw9PW4mJihuPXt9KSxudWxsPT1lLmxvYWQpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDYW5ub3QgcHJvY2VlZCB3aXRoIG1vZGVsIGxvYWRpbmcgYmVjYXVzZSB0aGUgSU9IYW5kbGVyIHByb3ZpZGVkIGRvZXMgbm90IGhhdmUgdGhlIGBsb2FkYCBtZXRob2QgaW1wbGVtZW50ZWQuXCIpO3JldHVybls0LGUubG9hZCgpXTtjYXNlIDE6aWYocj11LnNlbnQoKSxudWxsIT0oaT1yLm1vZGVsVG9wb2xvZ3kpLm1vZGVsX2NvbmZpZyYmKGk9aS5tb2RlbF9jb25maWcpLGE9bnVsbD09bi5zdHJpY3R8fG4uc3RyaWN0LG89bnVsbCE9ci53ZWlnaHREYXRhJiZudWxsIT1yLndlaWdodFNwZWNzJiZhLHM9ZGVzZXJpYWxpemUoY29udmVydFB5dGhvbmljVG9UcyhpKSx0LG8pLG51bGwhPXIud2VpZ2h0RGF0YSl7aWYobnVsbD09ci53ZWlnaHRTcGVjcyl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkxheWVyc01vZGVsIGFydGlmYWN0cyBjb250YWlucyB3ZWlnaHQgZGF0YSwgYnV0IG5vdCB3ZWlnaHQgc3BlY3MuIFRoZXJlZm9yZSBsb2FkaW5nIG9mIHdlaWdodHMgY2Fubm90IHByb2NlZWQuXCIpO2w9aW8uZGVjb2RlV2VpZ2h0cyhyLndlaWdodERhdGEsci53ZWlnaHRTcGVjcykscy5sb2FkV2VpZ2h0cyhsLGEpLGRpc3Bvc2UobCl9cmV0dXJuWzIsc119fSl9KX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTGF5ZXJzTW9kZWwpO3ZhciBTZXF1ZW50aWFsPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMse2lucHV0czpbXSxvdXRwdXRzOltdfSl8fHRoaXM7aWYodD10fHx7fSxuLnRyYWluYWJsZT0hMCxuLl91cGRhdGFibGU9ITAsbi5idWlsdD0hMSxuLm5hbWU9bnVsbCE9dC5uYW1lP3QubmFtZTpnZXRVaWQoXCJzZXF1ZW50aWFsX1wiKSxudWxsIT10LmxheWVycylmb3IodmFyIHI9MCxpPXQubGF5ZXJzO3I8aS5sZW5ndGg7cisrKXt2YXIgYT1pW3JdO24uYWRkKGEpfXJldHVybiBufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jaGVja1NoYXBlPWZ1bmN0aW9uKGUpe2lmKGUuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFRlbnNvcnNbMF0uc2hhcGUuc29tZShmdW5jdGlvbihlKXtyZXR1cm4gZTwwfSkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJOZWdhdGl2ZSBkaW1lbnNpb24gc2l6ZSBjYXVzZWQgYnkgYWRkaW5nIGxheWVyIFwiK2UubmFtZStcIiB3aXRoIGlucHV0IHNoYXBlIFtcIitlLmluYm91bmROb2Rlc1swXS5pbnB1dFRlbnNvcnNbMF0uc2hhcGUrXCJdXCIpfSx0LnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oZSl7dmFyIG4scj1lIGluc3RhbmNlb2YgdHx8ZSBpbnN0YW5jZW9mIExheWVyc01vZGVsO2lmKHIpe2lmKDEhPT0obj1lKS5vdXRwdXRzLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkFsbCBsYXllcnMgaW4gYSBTZXF1ZW50aWFsIG1vZGVsIHNob3VsZCBoYXZlIGEgc2luZ2xlIG91dHB1dCB0ZW5zb3IuIEZvciBtdWx0aS1vdXRwdXQgbGF5ZXJzLCB1c2UgdGhlIGZ1bmN0aW9uYWwgQVBJLlwiKTtpZigxIT09bi5pbnB1dHMubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQWxsIGxheWVycyBpbiBhIFNlcXVlbnRpYWwgbW9kZWwgc2hvdWxkIGhhdmUgYSBzaW5nbGUgaW5wdXQgdGVuc29yLiBGb3IgbXVsdGktaW5wdXQgbGF5ZXJzLCB1c2UgdGhlIGZ1bmN0aW9uYWwgQVBJLlwiKX1pZigwPT09dGhpcy5vdXRwdXRzLmxlbmd0aCl7aWYoMD09PWUuaW5ib3VuZE5vZGVzLmxlbmd0aCl7aWYobnVsbD09ZS5iYXRjaElucHV0U2hhcGUpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgZmlyc3QgbGF5ZXIgaW4gYSBTZXF1ZW50aWFsIG1vZGVsIG11c3QgZ2V0IGFuIGBpbnB1dFNoYXBlYCBvciBgYmF0Y2hJbnB1dFNoYXBlYCBhcmd1bWVudC5cIik7dmFyIGk9SW5wdXQoe2JhdGNoU2hhcGU6ZS5iYXRjaElucHV0U2hhcGUsZHR5cGU6ZS5kdHlwZSxuYW1lOmUubmFtZStcIl9pbnB1dFwifSk7ZS5hcHBseShpKX1pZihyKXRoaXMub3V0cHV0cz1uLm91dHB1dHMsdGhpcy5pbnB1dHM9bi5pbnB1dHM7ZWxzZXtpZigxIT09ZS5pbmJvdW5kTm9kZXMubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQSBsYXllciBhZGRlZCB0byBhIFNlcXVlbnRpYWwgbW9kZWwgbXVzdCBub3QgYWxyZWFkeSBiZSBjb25uZWN0ZWQgc29tZXdoZXJlIGVsc2UuIExheWVyc01vZGVsIHJlY2VpdmVkIGxheWVyIFwiK2UubmFtZStcIiB3aGljaCBoYXMgXCIrZS5pbmJvdW5kTm9kZXMubGVuZ3RoK1wiIHByZS1leGlzdGluZyBpbmJvdW5kIGNvbm5lY3Rpb25zLlwiKTtpZigxIT09ZS5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0VGVuc29ycy5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBbGwgbGF5ZXJzIGluIGEgU2VxdWVudGlhbCBtb2RlbCBzaG91bGQgaGF2ZSBhIHNpbmdsZSBvdXRwdXQgdGVuc29yLiBGb3IgbXVsdGktb3V0cHV0IGxheWVycywgdXNlIHRoZSBmdW5jdGlvbmFsIEFQSS5cIik7dGhpcy5jaGVja1NoYXBlKGUpLHRoaXMub3V0cHV0cz1bZS5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0VGVuc29yc1swXV0sdGhpcy5pbnB1dHM9Z2V0U291cmNlSW5wdXRzKHRoaXMub3V0cHV0c1swXSl9dGhpcy5pbmJvdW5kTm9kZXM9W10sbmV3IE5vZGUoe291dGJvdW5kTGF5ZXI6dGhpcyxpbmJvdW5kTGF5ZXJzOltdLG5vZGVJbmRpY2VzOltdLHRlbnNvckluZGljZXM6W10saW5wdXRUZW5zb3JzOnRoaXMuaW5wdXRzLG91dHB1dFRlbnNvcnM6dGhpcy5vdXRwdXRzLGlucHV0TWFza3M6cHlMaXN0UmVwZWF0KG51bGwsdGhpcy5pbnB1dHMubGVuZ3RoKSxvdXRwdXRNYXNrczpbbnVsbF0saW5wdXRTaGFwZXM6dGhpcy5pbnB1dHMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNoYXBlfSksb3V0cHV0U2hhcGVzOnRoaXMub3V0cHV0c1swXS5zaGFwZX0pfWVsc2V7dmFyIGE9ZS5hcHBseSh0aGlzLm91dHB1dHNbMF0pO2lmKEFycmF5LmlzQXJyYXkoYSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFsbCBsYXllcnMgaW4gYSBTZXF1ZW50aWFsIG1vZGVsIHNob3VsZCBoYXZlIGEgc2luZ2xlIG91dHB1dCB0ZW5zb3IuIEZvciBtdWx0aS1vdXRwdXQgbGF5ZXJzLCB1c2UgdGhlIGZ1bmN0aW9uYWwgQVBJLlwiKTt0aGlzLmNoZWNrU2hhcGUoZSksdGhpcy5vdXRwdXRzPVthXSx0aGlzLmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzPXRoaXMub3V0cHV0cyx0aGlzLmluYm91bmROb2Rlc1swXS5vdXRwdXRTaGFwZXM9W3RoaXMub3V0cHV0c1swXS5zaGFwZV19dGhpcy5sYXllcnMucHVzaChlKSx0aGlzLmJ1aWx0PSExfSx0LnByb3RvdHlwZS5wb3A9ZnVuY3Rpb24oKXtpZigwPT09dGhpcy5sYXllcnMubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGVyZSBhcmUgbm8gbGF5ZXJzIGluIHRoZSBtb2RlbC5cIik7aWYodGhpcy5sYXllcnMucG9wKCksMD09PXRoaXMubGF5ZXJzLmxlbmd0aCl0aGlzLm91dHB1dHM9W10sdGhpcy5pbmJvdW5kTm9kZXM9W10sdGhpcy5vdXRib3VuZE5vZGVzPVtdO2Vsc2V7dmFyIGU9dGhpcy5sYXllcnMubGVuZ3RoLTE7dGhpcy5sYXllcnNbZV0ub3V0Ym91bmROb2Rlcz1bXSx0aGlzLm91dHB1dHM9W3RoaXMubGF5ZXJzW2VdLm91dHB1dF0sdGhpcy5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0VGVuc29ycz10aGlzLm91dHB1dHMsdGhpcy5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0U2hhcGVzPVt0aGlzLm91dHB1dHNbMF0uc2hhcGVdfX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3JldHVybiBudWxsPT10aGlzLm1vZGVsJiZ0aGlzLmJ1aWxkKCksdGhpcy5tb2RlbC5jYWxsKGUsdCl9LHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe2lmKGdldEV4YWN0bHlPbmVTaGFwZShlKSwwPT09dGhpcy5pbnB1dHMubGVuZ3RofHwwPT09dGhpcy5vdXRwdXRzLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU2VxdWVudGlhbCBtb2RlbCBjYW5ub3QgYmUgYnVpbHQ6IG1vZGVsIGlzIGVtcHR5LiBBZGQgc29tZSBsYXllcnMgZmlyc3QuXCIpO3RoaXMubW9kZWw9bmV3IExheWVyc01vZGVsKHtpbnB1dHM6dGhpcy5pbnB1dHMsb3V0cHV0czp0aGlzLm91dHB1dHNbMF0sbmFtZTp0aGlzLm5hbWUrXCJfbW9kZWxcIn0pLHRoaXMubW9kZWwudHJhaW5hYmxlPXRoaXMudHJhaW5hYmxlLHRoaXMubW9kZWwudXBkYXRhYmxlPXRoaXMudXBkYXRhYmxlLHRoaXMuc3VwcG9ydHNNYXNraW5nPXRoaXMubW9kZWwuc3VwcG9ydHNNYXNraW5nLHRoaXMuaW5wdXRMYXllcnM9dGhpcy5tb2RlbC5pbnB1dExheWVycyx0aGlzLmlucHV0TGF5ZXJzTm9kZUluZGljZXM9dGhpcy5tb2RlbC5pbnB1dExheWVyc05vZGVJbmRpY2VzLHRoaXMuaW5wdXRMYXllcnNUZW5zb3JJbmRpY2VzPXRoaXMubW9kZWwuaW5wdXRMYXllcnNUZW5zb3JJbmRpY2VzLHRoaXMub3V0cHV0TGF5ZXJzPXRoaXMubW9kZWwub3V0cHV0TGF5ZXJzLHRoaXMub3V0cHV0TGF5ZXJzTm9kZUluZGljZXM9dGhpcy5tb2RlbC5vdXRwdXRMYXllcnNOb2RlSW5kaWNlcyx0aGlzLm91dHB1dExheWVyc1RlbnNvckluZGljZXM9dGhpcy5tb2RlbC5vdXRwdXRMYXllcnNUZW5zb3JJbmRpY2VzLHRoaXMubm9kZXNCeURlcHRoPXRoaXMubW9kZWwubm9kZXNCeURlcHRoLHRoaXMuY29udGFpbmVyTm9kZXM9dGhpcy5tb2RlbC5jb250YWluZXJOb2Rlcyx0aGlzLm91dHB1dE5hbWVzPXRoaXMubW9kZWwub3V0cHV0TmFtZXMsdGhpcy5pbnB1dE5hbWVzPXRoaXMubW9kZWwuaW5wdXROYW1lcyx0aGlzLmJ1aWx0PSEwfSx0LnByb3RvdHlwZS5jb3VudFBhcmFtcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ1aWx0fHx0aGlzLmJ1aWxkKCksZS5wcm90b3R5cGUuY291bnRQYXJhbXMuY2FsbCh0aGlzKX0sdC5wcm90b3R5cGUuc3VtbWFyeT1mdW5jdGlvbih0LG4scil7dm9pZCAwPT09ciYmKHI9Y29uc29sZS5sb2cpLHRoaXMuYnVpbHR8fHRoaXMuYnVpbGQoKSxlLnByb3RvdHlwZS5zdW1tYXJ5LmNhbGwodGhpcyx0LG4scil9LHQucHJvdG90eXBlLnNldFdlaWdodHM9ZnVuY3Rpb24oZSl7bnVsbD09dGhpcy5tb2RlbCYmdGhpcy5idWlsZCgpLHRoaXMubW9kZWwuc2V0V2VpZ2h0cyhlKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidXBkYXRhYmxlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl91cGRhdGFibGV9LHNldDpmdW5jdGlvbihlKXt0aGlzLmJ1aWx0JiYodGhpcy5tb2RlbC51cGRhdGFibGU9ZSksdGhpcy5fdXBkYXRhYmxlPWV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuZXZhbHVhdGU9ZnVuY3Rpb24oZSx0LG4pe2lmKHZvaWQgMD09PW4mJihuPXt9KSwhdGhpcy5idWlsdCl0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiVGhlIG1vZGVsIG5lZWRzIHRvIGJlIGNvbXBpbGVkIGJlZm9yZSBiZWluZyB1c2VkLlwiKTtyZXR1cm4gdGhpcy5tb2RlbC5ldmFsdWF0ZShlLHQsbil9LHQucHJvdG90eXBlLmV2YWx1YXRlRGF0YXNldD1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7aWYoIXRoaXMuYnVpbHQpdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcIlRoZSBtb2RlbCBuZWVkcyB0byBiZSBjb21waWxlZCBiZWZvcmUgYmVpbmcgdXNlZC5cIik7cmV0dXJuWzIsdGhpcy5tb2RlbC5ldmFsdWF0ZURhdGFzZXQoZSx0KV19KX0pfSx0LnByb3RvdHlwZS5wcmVkaWN0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PXt9KSxudWxsPT10aGlzLm1vZGVsJiZ0aGlzLmJ1aWxkKCksdGhpcy5tb2RlbC5wcmVkaWN0KGUsdCl9LHQucHJvdG90eXBlLnByZWRpY3RPbkJhdGNoPWZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT10aGlzLm1vZGVsJiZ0aGlzLmJ1aWxkKCksdGhpcy5tb2RlbC5wcmVkaWN0T25CYXRjaChlKX0sdC5wcm90b3R5cGUuY29tcGlsZT1mdW5jdGlvbihlKXt0aGlzLmJ1aWxkKCksdGhpcy5tb2RlbC5jb21waWxlKGUpLHRoaXMub3B0aW1pemVyXz10aGlzLm1vZGVsLm9wdGltaXplcix0aGlzLmlzT3B0aW1pemVyT3duZWQ9dGhpcy5tb2RlbC5pc09wdGltaXplck93bmVkLHRoaXMubG9zcz10aGlzLm1vZGVsLmxvc3MsdGhpcy5tZXRyaWNzPXRoaXMubW9kZWwubWV0cmljcyx0aGlzLm1ldHJpY3NUZW5zb3JzPXRoaXMubW9kZWwubWV0cmljc1RlbnNvcnMsdGhpcy5tZXRyaWNzTmFtZXM9dGhpcy5tb2RlbC5tZXRyaWNzTmFtZXN9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIm9wdGltaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tb2RlbC5vcHRpbWl6ZXJ9LHNldDpmdW5jdGlvbihlKXt0aGlzLm1vZGVsLm9wdGltaXplcj1lfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmZpdD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPXt9KSxfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7aWYoIXRoaXMuYnVpbHQpdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcIlRoZSBtb2RlbCBuZWVkcyB0byBiZSBjb21waWxlZCBiZWZvcmUgYmVpbmcgdXNlZC5cIik7cmV0dXJuWzIsdGhpcy5tb2RlbC5maXQoZSx0LG4pXX0pfSl9LHQucHJvdG90eXBlLmZpdERhdGFzZXQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe2lmKCF0aGlzLmJ1aWx0KXRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJUaGUgbW9kZWwgbmVlZHMgdG8gYmUgY29tcGlsZWQgYmVmb3JlIGJlaW5nIHVzZWQuXCIpO3JldHVyblsyLHRoaXMubW9kZWwuZml0RGF0YXNldChlLHQpXX0pfSl9LHQucHJvdG90eXBlLnRyYWluT25CYXRjaD1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24obil7cmV0dXJuWzIsdGhpcy5tb2RlbC50cmFpbk9uQmF0Y2goZSx0KV19KX0pfSx0LmZyb21Db25maWc9ZnVuY3Rpb24oZSxuLHIsaSl7dmFyIGE7dm9pZCAwPT09ciYmKHI9e30pLHZvaWQgMD09PWkmJihpPSExKTt2YXIgbz17fTtpZihuIGluc3RhbmNlb2YgQXJyYXkpe2lmKG51bGw9PW5bMF0uY2xhc3NOYW1lfHxcIk1lcmdlXCI9PT1uWzBdLmNsYXNzTmFtZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkxlZ2FjeSBzZXJpYWxpemF0aW9uIGZvcm1hdCBub3Qgc3VwcG9ydGVkIHlldC5cIik7YT1ufWVsc2UgdXRpbC5hc3NlcnQobnVsbCE9bi5sYXllcnMsZnVuY3Rpb24oKXtyZXR1cm5cIldoZW4gdGhlIGNvbmZpZyBkYXRhIGZvciBhIFNlcXVlbnRpYWwgbW9kZWwgaXMgbm90IGFuIEFycmF5LCBpdCBtdXN0IGJlIGFuIE9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSAnbGF5ZXJzJyBmaWVsZC5cIn0pLGE9bi5sYXllcnMsZGVsZXRlIG4ubGF5ZXJzLG89bjt2YXIgcz1uZXcgZShvKTtpZighKHMgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlNlcXVlbnRpYWwuZnJvbUNvbmZpZyBjYWxsZWQgb24gbm9uLVNlcXVlbnRpYWwgaW5wdXQ6IFwiK3MpO2Zvcih2YXIgbD0wLHU9YTtsPHUubGVuZ3RoO2wrKyl7dmFyIGM9ZGVzZXJpYWxpemUodVtsXSx2b2lkIDAsaSk7aSYmYy5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkKCEwKSxzLmFkZChjKX1yZXR1cm4gc30sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwic3RvcFRyYWluaW5nXCIse2dldDpmdW5jdGlvbigpe2lmKG51bGw9PXRoaXMubW9kZWwpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBzdG9wVHJhaW5pbmcgcHJvcGVydHkgb2YgYSBzZXF1ZW50aWFsIG1vZGVsIGJlZm9yZSBpdCBpcyBjb21waWxlZC5cIik7cmV0dXJuIHRoaXMubW9kZWwuc3RvcFRyYWluaW5nfSxzZXQ6ZnVuY3Rpb24oZSl7aWYobnVsbD09dGhpcy5tb2RlbCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNhbm5vdCBzZXQgdGhlIHN0b3BUcmFpbmluZyBwcm9wZXJ0eSBvZiBhIHNlcXVlbnRpYWwgbW9kZWwgYmVmb3JlIGl0IGlzIGNvbXBpbGVkLlwiKTt0aGlzLm1vZGVsLnN0b3BUcmFpbmluZz1lfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe2Zvcih2YXIgZT1bXSx0PTAsbj10aGlzLmxheWVyczt0PG4ubGVuZ3RoO3QrKyl7dmFyIHI9blt0XSxpPXt9O2kuY2xhc3NOYW1lPXIuZ2V0Q2xhc3NOYW1lKCksaS5jb25maWc9ci5nZXRDb25maWcoKSxlLnB1c2goaSl9cmV0dXJuIGV9LHQuY2xhc3NOYW1lPVwiU2VxdWVudGlhbFwiLHR9KExheWVyc01vZGVsKTtmdW5jdGlvbiBtb2RlbChlKXtyZXR1cm4gbmV3IExheWVyc01vZGVsKGUpfWZ1bmN0aW9uIHNlcXVlbnRpYWwoZSl7cmV0dXJuIG5ldyBTZXF1ZW50aWFsKGUpfWZ1bmN0aW9uIGxvYWRMYXllcnNNb2RlbChlLHQpe3JldHVybiBudWxsPT10JiYodD17fSksbG9hZExheWVyc01vZGVsSW50ZXJuYWwoZSx0KX1mdW5jdGlvbiBpbnB1dChlKXtyZXR1cm4gSW5wdXQoZSl9ZnVuY3Rpb24gcmVnaXN0ZXJDYWxsYmFja0NvbnN0cnVjdG9yKGUsdCl7Q2FsbGJhY2tDb25zdHJ1Y3RvclJlZ2lzdHJ5LnJlZ2lzdGVyQ2FsbGJhY2tDb25zdHJ1Y3RvcihlLHQpfXNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTZXF1ZW50aWFsKTt2YXIgQWN0aXZhdGlvbj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue319LHR9KHNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlKSxFbHU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PTEpLGVsdSQxKGUsdCl9LHQuY2xhc3NOYW1lPVwiZWx1XCIsdH0oQWN0aXZhdGlvbik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEVsdSk7dmFyIFNlbHU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUpe3JldHVybiBzZWx1KGUpfSx0LmNsYXNzTmFtZT1cInNlbHVcIix0fShBY3RpdmF0aW9uKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoU2VsdSk7dmFyIFJlbHU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUpe3JldHVybiByZWx1KGUpfSx0LmNsYXNzTmFtZT1cInJlbHVcIix0fShBY3RpdmF0aW9uKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoUmVsdSk7dmFyIFJlbHU2PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBtaW5pbXVtKDYscmVsdShlKSl9KX0sdC5jbGFzc05hbWU9XCJyZWx1NlwiLHR9KEFjdGl2YXRpb24pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhSZWx1Nik7dmFyIExpbmVhcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LHQuY2xhc3NOYW1lPVwibGluZWFyXCIsdH0oQWN0aXZhdGlvbik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKExpbmVhcik7dmFyIFNpZ21vaWQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUpe3JldHVybiBzaWdtb2lkKGUpfSx0LmNsYXNzTmFtZT1cInNpZ21vaWRcIix0fShBY3RpdmF0aW9uKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoU2lnbW9pZCk7dmFyIEhhcmRTaWdtb2lkPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5hcHBseT1mdW5jdGlvbihlKXtyZXR1cm4gaGFyZFNpZ21vaWQoZSl9LHQuY2xhc3NOYW1lPVwiaGFyZFNpZ21vaWRcIix0fShBY3RpdmF0aW9uKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoSGFyZFNpZ21vaWQpO3ZhciBTb2Z0cGx1cz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24oZSl7cmV0dXJuIHNvZnRwbHVzKGUpfSx0LmNsYXNzTmFtZT1cInNvZnRwbHVzXCIsdH0oQWN0aXZhdGlvbik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFNvZnRwbHVzKTt2YXIgU29mdHNpZ249ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUpe3JldHVybiBzb2Z0c2lnbihlKX0sdC5jbGFzc05hbWU9XCJzb2Z0c2lnblwiLHR9KEFjdGl2YXRpb24pO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTb2Z0c2lnbik7dmFyIFRhbmg9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUpe3JldHVybiB0YW5oKGUpfSx0LmNsYXNzTmFtZT1cInRhbmhcIix0fShBY3RpdmF0aW9uKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoVGFuaCk7dmFyIFNvZnRtYXg9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PS0xKSxzb2Z0bWF4KGUsdCl9LHQuY2xhc3NOYW1lPVwic29mdG1heFwiLHR9KEFjdGl2YXRpb24pO2Z1bmN0aW9uIHNlcmlhbGl6ZUFjdGl2YXRpb24oZSl7cmV0dXJuIGUuZ2V0Q2xhc3NOYW1lKCl9ZnVuY3Rpb24gZGVzZXJpYWxpemVBY3RpdmF0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PXt9KSxkZXNlcmlhbGl6ZUtlcmFzT2JqZWN0KGUsc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLmdldE1hcCgpLmNsYXNzTmFtZU1hcCx0LFwiYWN0aXZhdGlvblwiKX1mdW5jdGlvbiBnZXRBY3RpdmF0aW9uKGUpe3ZhciB0O3JldHVybiBudWxsPT1lP2Rlc2VyaWFsaXplQWN0aXZhdGlvbih0PXtjbGFzc05hbWU6XCJsaW5lYXJcIixjb25maWc6e319KTpcInN0cmluZ1wiPT10eXBlb2YgZT8oKHQ9e30pLmNsYXNzTmFtZT1lLHQuY29uZmlnPXt9LGRlc2VyaWFsaXplQWN0aXZhdGlvbih0KSk6ZSBpbnN0YW5jZW9mIEFjdGl2YXRpb24/ZTpkZXNlcmlhbGl6ZUFjdGl2YXRpb24oZSl9c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFNvZnRtYXgpO3ZhciBSZWd1bGFyaXplcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdH0oc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGUpLEwxTDI9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4ubDE9bnVsbD09dHx8bnVsbD09dC5sMT8uMDE6dC5sMSxuLmwyPW51bGw9PXR8fG51bGw9PXQubDI/LjAxOnQubDIsbi5oYXNMMT0wIT09bi5sMSxuLmhhc0wyPTAhPT1uLmwyLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbj16ZXJvcyhbMV0pO3JldHVybiB0Lmhhc0wxJiYobj1hZGQobixzdW0obXVsKHQubDEsYWJzKGUpKSkpKSx0Lmhhc0wyJiYobj1hZGQobixzdW0obXVsKHQubDIsc3F1YXJlKGUpKSkpKSxuLmFzU2NhbGFyKCl9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2wxOnRoaXMubDEsbDI6dGhpcy5sMn19LHQuZnJvbUNvbmZpZz1mdW5jdGlvbihlLHQpe3JldHVybiBuZXcgZSh7bDE6dC5sMSxsMjp0LmwyfSl9LHQuY2xhc3NOYW1lPVwiTDFMMlwiLHR9KFJlZ3VsYXJpemVyKTtmdW5jdGlvbiBsMShlKXtyZXR1cm4gbmV3IEwxTDIoe2wxOm51bGwhPWU/ZS5sMTpudWxsLGwyOjB9KX1mdW5jdGlvbiBsMihlKXtyZXR1cm4gbmV3IEwxTDIoe2wyOm51bGwhPWU/ZS5sMjpudWxsLGwxOjB9KX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTDFMMik7dmFyIFJFR1VMQVJJWkVSX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUD17bDFsMjpcIkwxTDJcIn07ZnVuY3Rpb24gc2VyaWFsaXplUmVndWxhcml6ZXIoZSl7cmV0dXJuIHNlcmlhbGl6ZUtlcmFzT2JqZWN0KGUpfWZ1bmN0aW9uIGRlc2VyaWFsaXplUmVndWxhcml6ZXIoZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9e30pLGRlc2VyaWFsaXplS2VyYXNPYmplY3QoZSxzZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAuZ2V0TWFwKCkuY2xhc3NOYW1lTWFwLHQsXCJyZWd1bGFyaXplclwiKX1mdW5jdGlvbiBnZXRSZWd1bGFyaXplcihlKXtyZXR1cm4gbnVsbD09ZT9udWxsOlwic3RyaW5nXCI9PXR5cGVvZiBlP2Rlc2VyaWFsaXplUmVndWxhcml6ZXIoe2NsYXNzTmFtZTplIGluIFJFR1VMQVJJWkVSX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUD9SRUdVTEFSSVpFUl9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVBbZV06ZSxjb25maWc6e319KTplIGluc3RhbmNlb2YgUmVndWxhcml6ZXI/ZTpkZXNlcmlhbGl6ZVJlZ3VsYXJpemVyKGUpfXZhciBSZUxVPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsbnVsbD09dD97fTp0KXx8dGhpcztyZXR1cm4gbi5zdXBwb3J0c01hc2tpbmc9ITAsbnVsbCE9dCYmKG4ubWF4VmFsdWU9dC5tYXhWYWx1ZSksbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe2U9Z2V0RXhhY3RseU9uZVRlbnNvcihlKTt2YXIgbj1yZWx1KGUpO3JldHVybiBudWxsIT10aGlzLm1heFZhbHVlJiYobj1jbGlwQnlWYWx1ZShuLDAsdGhpcy5tYXhWYWx1ZSkpLG59LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtyZXR1cm4gZX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e21heFZhbHVlOnRoaXMubWF4VmFsdWV9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIlJlTFVcIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFJlTFUpO3ZhciBMZWFreVJlTFU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyxudWxsPT10P3t9OnQpfHx0aGlzO3JldHVybiBuLkRFRkFVTFRfQUxQSEE9LjMsbnVsbD09dCYmKHQ9e30pLG4uYWxwaGE9bnVsbD09dC5hbHBoYT9uLkRFRkFVTFRfQUxQSEE6dC5hbHBoYSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49Z2V0RXhhY3RseU9uZVRlbnNvcihlKTtyZXR1cm4gbGVha3lSZWx1KG4sdGhpcy5hbHBoYSl9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtyZXR1cm4gZX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2FscGhhOnRoaXMuYWxwaGF9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIkxlYWt5UmVMVVwiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTGVha3lSZUxVKTt2YXIgUFJlTFU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyxudWxsPT10P3t9OnQpfHx0aGlzO2lmKG4uREVGQVVMVF9BTFBIQV9JTklUSUFMSVpFUj1cInplcm9zXCIsbnVsbD09dCYmKHQ9e30pLG4uc3VwcG9ydHNNYXNraW5nPSEwLG4uYWxwaGFJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcih0LmFscGhhSW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9BTFBIQV9JTklUSUFMSVpFUiksbi5hbHBoYVJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQuYWxwaGFSZWd1bGFyaXplciksbi5hbHBoYUNvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludCh0LmFscGhhQ29uc3RyYWludCksbnVsbD09dC5zaGFyZWRBeGVzKW4uc2hhcmVkQXhlcz1udWxsO2Vsc2UgaWYoQXJyYXkuaXNBcnJheSh0LnNoYXJlZEF4ZXMpKW4uc2hhcmVkQXhlcz10LnNoYXJlZEF4ZXM7ZWxzZXtpZihcIm51bWJlclwiIT10eXBlb2YgdC5zaGFyZWRBeGVzKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRXhwZWN0ZWQgc2hhcmVkQXhlcyB0byBiZSBhIG51bWJlciBvciBhbiBhcnJheSBvZiBudW1iZXJzLCBidXQgZ290IFwiK3Quc2hhcmVkQXhlcyk7bi5zaGFyZWRBeGVzPVt0LnNoYXJlZEF4ZXNdfXJldHVybiBufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXt2YXIgdD0oZT1nZXRFeGFjdGx5T25lU2hhcGUoZSkpLnNsaWNlKDEpO2lmKG51bGwhPXRoaXMuc2hhcmVkQXhlcylmb3IodmFyIG49MCxyPXRoaXMuc2hhcmVkQXhlcztuPHIubGVuZ3RoO24rKyl7dFsoYT1yW25dKS0xXT0xfXRoaXMuYWxwaGE9dGhpcy5hZGRXZWlnaHQoXCJhbHBoYVwiLHQsXCJmbG9hdDMyXCIsdGhpcy5hbHBoYUluaXRpYWxpemVyLHRoaXMuYWxwaGFSZWd1bGFyaXplciwhMCx0aGlzLmFscGhhQ29uc3RyYWludCk7dmFyIGk9e307aWYobnVsbCE9dGhpcy5zaGFyZWRBeGVzKWZvcih2YXIgYT0xO2E8ZS5sZW5ndGg7KythKWlbYV09ZVthXTt0aGlzLmlucHV0U3BlYz1bbmV3IElucHV0U3BlYyh7bmRpbTplLmxlbmd0aCxheGVzOml9KV0sdGhpcy5idWlsdD0hMH0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3JldHVybiBlPWdldEV4YWN0bHlPbmVUZW5zb3IoZSkscHJlbHUoZSx0aGlzLmFscGhhLnJlYWQoKSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXthbHBoYUluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYWxwaGFJbml0aWFsaXplciksYWxwaGFSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFscGhhUmVndWxhcml6ZXIpLGFscGhhQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMuYWxwaGFDb25zdHJhaW50KSxzaGFyZWRBeGVzOnRoaXMuc2hhcmVkQXhlc30sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiUFJlTFVcIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFBSZUxVKTt2YXIgRUxVPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsbnVsbD09dD97fTp0KXx8dGhpcztpZihuLkRFRkFVTFRfQUxQSEE9MSxudWxsPT10JiYodD17fSksbnVsbCE9dC5hbHBoYSYmdC5hbHBoYSE9PW4uREVGQVVMVF9BTFBIQSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIk5vbi1kZWZhdWx0IGFscGhhIHZhbHVlIChcIit0LmFscGhhK1wiKSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBFTFUgbGF5ZXIgeWV0LlwiKTtyZXR1cm4gbi5hbHBoYT1udWxsPT10LmFscGhhP24uREVGQVVMVF9BTFBIQTp0LmFscGhhLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1nZXRFeGFjdGx5T25lVGVuc29yKGUpO3JldHVybiBlbHUobil9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtyZXR1cm4gZX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2FscGhhOnRoaXMuYWxwaGF9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIkVMVVwiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoRUxVKTt2YXIgVGhyZXNob2xkZWRSZUxVPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsbnVsbD09dD97fTp0KXx8dGhpcztyZXR1cm4gbi5ERUZBVUxUX1RIRVRBPTEsbnVsbD09dCYmKHQ9e30pLG4udGhldGE9bnVsbD09dC50aGV0YT9uLkRFRkFVTFRfVEhFVEE6dC50aGV0YSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49Z2V0RXhhY3RseU9uZVRlbnNvcihlKTtyZXR1cm4gbi5tdWwoY2FzdCQxKG4uZ3JlYXRlcih0aGlzLnRoZXRhKSxcImZsb2F0MzJcIikpfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXt0aGV0YTp0aGlzLnRoZXRhfSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJUaHJlc2hvbGRlZFJlTFVcIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFRocmVzaG9sZGVkUmVMVSk7dmFyIFNvZnRtYXgkMT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLG51bGw9PXQ/e306dCl8fHRoaXM7cmV0dXJuIG4uREVGQVVMVF9BWElTPTEsbnVsbD09dCYmKHQ9e30pLG4uc29mdG1heD0obmV3IFNvZnRtYXgpLmFwcGx5LG4uYXhpcz1udWxsPT10LmF4aXM/bi5ERUZBVUxUX0FYSVM6dC5heGlzLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1nZXRFeGFjdGx5T25lVGVuc29yKGUpO3JldHVybiB0aGlzLnNvZnRtYXgobix0aGlzLmF4aXMpfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtheGlzOnRoaXMuYXhpc30sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiU29mdG1heFwiLHR9KExheWVyKTtmdW5jdGlvbiBub3JtYWxpemVBcnJheShlLHQsbil7aWYoXCJudW1iZXJcIj09dHlwZW9mIGUpcmV0dXJuIHB5TGlzdFJlcGVhdChlLHQpO2lmKGUubGVuZ3RoIT09dCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBcIituK1wiIGFyZ3VtZW50IG11c3QgYmUgYW4gaW50ZWdlciBvciB0dXBsZSBvZiBcIit0K1wiIGludGVnZXJzLiBSZWNlaXZlZDogXCIrZS5sZW5ndGgrXCIgZWxlbWVudHMuXCIpO2Zvcih2YXIgcj0wO3I8dDsrK3Ipe3ZhciBpPWVbcl07aWYoIWlzSW50ZWdlcihpKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBcIituK1wiIGFyZ3VtZW50IG11c3QgYmUgYW4gaW50ZWdlciBvciB0dXBsZSBvZiBcIit0K1wiIGludGVnZXJzLiBSZWNlaXZlZDogXCIrSlNPTi5zdHJpbmdpZnkoZSkrXCIgaW5jbHVkaW5nIGEgbm9uLWludGVnZXIgbnVtYmVyIFwiK2kpfXJldHVybiBlfWZ1bmN0aW9uIGNvbnZPdXRwdXRMZW5ndGgoZSx0LG4scixpKXtyZXR1cm4gdm9pZCAwPT09aSYmKGk9MSksbnVsbD09ZT9lOihhPVwic2FtZVwiPT09bj9lOmUtKHQrKHQtMSkqKGktMSkpKzEsTWF0aC5mbG9vcigoYStyLTEpL3IpKTt2YXIgYX1mdW5jdGlvbiBkZWNvbnZMZW5ndGgoZSx0LG4scil7aWYobnVsbD09ZSlyZXR1cm4gbnVsbDtpZihcInZhbGlkXCI9PT1yKWU9ZSp0K21heCQxKFtuLXQsMF0pO2Vsc2V7aWYoXCJzYW1lXCIhPT1yKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVW5zdXBwb3J0IHBhZGRpbmcgbW9kZTogXCIrcitcIi5cIik7ZSo9dH1yZXR1cm4gZX1mdW5jdGlvbiBwcmVwcm9jZXNzQ29udjJESW5wdXQoZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBjaGVja0RhdGFGb3JtYXQodCksXCJjaGFubmVsc0ZpcnN0XCI9PT10P3RyYW5zcG9zZShlLFswLDIsMywxXSk6ZX0pfWZ1bmN0aW9uIHByZXByb2Nlc3NDb252M0RJbnB1dChlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGNoZWNrRGF0YUZvcm1hdCh0KSxcImNoYW5uZWxzRmlyc3RcIj09PXQ/dHJhbnNwb3NlKGUsWzAsMiwzLDQsMV0pOmV9KX1mdW5jdGlvbiBjb252MWRXaXRoQmlhcyhlLHQsbixyLGksYSxvKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9MSksdm9pZCAwPT09aSYmKGk9XCJ2YWxpZFwiKSx2b2lkIDA9PT1vJiYobz0xKSx0aWR5KGZ1bmN0aW9uKCl7aWYobnVsbD09YSYmKGE9aW1hZ2VEYXRhRm9ybWF0KCkpLGNoZWNrRGF0YUZvcm1hdChhKSwzIT09ZS5zaGFwZS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgaW5wdXQgb2YgYSBjb252MWRXaXRoQmlhcyBvcGVyYXRpb24gc2hvdWxkIGJlIDMsIGJ1dCBpcyBcIitlLnNoYXBlLmxlbmd0aCtcIiBpbnN0ZWFkLlwiKTtpZigzIT09dC5zaGFwZS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUga2VybmVsIGZvciBhIGNvbnYxZFdpdGhCaWFzIG9wZXJhdGlvbiBzaG91bGQgYmUgMywgYnV0IGlzIFwiK3Quc2hhcGUubGVuZ3RoK1wiIGluc3RlYWRcIik7aWYobnVsbCE9biYmMSE9PW4uc2hhcGUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGJpYXMgZm9yIGEgY29udjFkV2l0aEJpYXMgb3BlcmF0aW9uIHNob3VsZCBiZSAxLCBidXQgaXMgXCIrdC5zaGFwZS5sZW5ndGgrXCIgaW5zdGVhZFwiKTtpZihcImNoYW5uZWxzRmlyc3RcIj09PWEmJihlPXRyYW5zcG9zZShlLFswLDIsMV0pKSxcImNhdXNhbFwiPT09aSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlRoZSBzdXBwb3J0IGZvciBDQVVTQUwgcGFkZGluZyBtb2RlIGluIGNvbnYxZFdpdGhCaWFzIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO3ZhciBzPWNvbnYxZChlLHQscixcInNhbWVcIj09PWk/XCJzYW1lXCI6XCJ2YWxpZFwiLFwiTldDXCIsbyk7cmV0dXJuIG51bGwhPW4mJihzPWJpYXNBZGQocyxuKSksc30pfWZ1bmN0aW9uIGNvbnYyZFdpdGhCaWFzKGUsdCxuLHIsaSxhLG8pe3JldHVybiB2b2lkIDA9PT1yJiYocj1bMSwxXSksdm9pZCAwPT09aSYmKGk9XCJ2YWxpZFwiKSx0aWR5KGZ1bmN0aW9uKCl7aWYobnVsbD09YSYmKGE9aW1hZ2VEYXRhRm9ybWF0KCkpLGNoZWNrRGF0YUZvcm1hdChhKSwzIT09ZS5yYW5rJiY0IT09ZS5yYW5rKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiY29udjJkV2l0aEJpYXMgZXhwZWN0cyBpbnB1dCB0byBiZSBvZiByYW5rIDMgb3IgNCwgYnV0IHJlY2VpdmVkIFwiK2UucmFuaytcIi5cIik7aWYoMyE9PXQucmFuayYmNCE9PXQucmFuayl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImNvbnYyZFdpdGhCaWFzIGV4cGVjdHMga2VybmVsIHRvIGJlIG9mIHJhbmsgMyBvciA0LCBidXQgcmVjZWl2ZWQgXCIrZS5yYW5rK1wiLlwiKTt2YXIgcz1wcmVwcm9jZXNzQ29udjJESW5wdXQoZSxhKTtpZihcImNhdXNhbFwiPT09aSl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIlRoZSBzdXBwb3J0IGZvciBDQVVTQUwgcGFkZGluZyBtb2RlIGluIGNvbnYxZFdpdGhCaWFzIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO3JldHVybiBzPWNvbnYyZChzLHQscixcInNhbWVcIj09PWk/XCJzYW1lXCI6XCJ2YWxpZFwiLFwiTkhXQ1wiLG8pLG51bGwhPW4mJihzPWJpYXNBZGQocyxuKSksXCJjaGFubmVsc0ZpcnN0XCI9PT1hJiYocz10cmFuc3Bvc2UocyxbMCwzLDEsMl0pKSxzfSl9ZnVuY3Rpb24gY29udjNkV2l0aEJpYXMoZSx0LG4scixpLGEsbyl7cmV0dXJuIHZvaWQgMD09PXImJihyPVsxLDEsMV0pLHZvaWQgMD09PWkmJihpPVwidmFsaWRcIiksdGlkeShmdW5jdGlvbigpe2lmKG51bGw9PWEmJihhPWltYWdlRGF0YUZvcm1hdCgpKSxjaGVja0RhdGFGb3JtYXQoYSksNCE9PWUucmFuayYmNSE9PWUucmFuayl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImNvbnYzZFdpdGhCaWFzIGV4cGVjdHMgaW5wdXQgdG8gYmUgb2YgcmFuayA0IG9yIDUsIGJ1dCByZWNlaXZlZCBcIitlLnJhbmsrXCIuXCIpO2lmKDQhPT10LnJhbmsmJjUhPT10LnJhbmspdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJjb252M2RXaXRoQmlhcyBleHBlY3RzIGtlcm5lbCB0byBiZSBvZiByYW5rIDQgb3IgNSwgYnV0IHJlY2VpdmVkIFwiK2UucmFuaytcIi5cIik7dmFyIHM9cHJlcHJvY2Vzc0NvbnYzRElucHV0KGUsYSk7aWYoXCJjYXVzYWxcIj09PWkpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJUaGUgc3VwcG9ydCBmb3IgQ0FVU0FMIHBhZGRpbmcgbW9kZSBpbiBjb252M2RXaXRoQmlhcyBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtyZXR1cm4gcz1jb252M2Qocyx0LHIsXCJzYW1lXCI9PT1pP1wic2FtZVwiOlwidmFsaWRcIixcIk5ESFdDXCIsbyksbnVsbCE9biYmKHM9Ymlhc0FkZChzLG4pKSxcImNoYW5uZWxzRmlyc3RcIj09PWEmJihzPXRyYW5zcG9zZShzLFswLDQsMSwyLDNdKSksc30pfXNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTb2Z0bWF4JDEpO3ZhciBCYXNlQ29udj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KG4scil7dmFyIGk9ZS5jYWxsKHRoaXMscil8fHRoaXM7aWYoaS5iaWFzPW51bGwsaS5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUj1cImdsb3JvdE5vcm1hbFwiLGkuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSPVwiemVyb3NcIix0LnZlcmlmeUFyZ3MociksaS5yYW5rPW4sYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKGkucmFuayxcInJhbmtcIiksMSE9PWkucmFuayYmMiE9PWkucmFuayYmMyE9PWkucmFuayl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIkNvbnZvbHV0aW9uIGxheWVyIGZvciByYW5rIG90aGVyIHRoYW4gMSwgMiwgb3IgMyAoXCIraS5yYW5rK1wiKSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtpZihpLmtlcm5lbFNpemU9bm9ybWFsaXplQXJyYXkoci5rZXJuZWxTaXplLG4sXCJrZXJuZWxTaXplXCIpLGkuc3RyaWRlcz1ub3JtYWxpemVBcnJheShudWxsPT1yLnN0cmlkZXM/MTpyLnN0cmlkZXMsbixcInN0cmlkZXNcIiksaS5wYWRkaW5nPW51bGw9PXIucGFkZGluZz9cInZhbGlkXCI6ci5wYWRkaW5nLGNoZWNrUGFkZGluZ01vZGUoaS5wYWRkaW5nKSxpLmRhdGFGb3JtYXQ9bnVsbD09ci5kYXRhRm9ybWF0P1wiY2hhbm5lbHNMYXN0XCI6ci5kYXRhRm9ybWF0LGNoZWNrRGF0YUZvcm1hdChpLmRhdGFGb3JtYXQpLGkuYWN0aXZhdGlvbj1nZXRBY3RpdmF0aW9uKHIuYWN0aXZhdGlvbiksaS51c2VCaWFzPW51bGw9PXIudXNlQmlhc3x8ci51c2VCaWFzLGkuYmlhc0luaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHIuYmlhc0luaXRpYWxpemVyfHxpLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUiksaS5iaWFzQ29uc3RyYWludD1nZXRDb25zdHJhaW50KHIuYmlhc0NvbnN0cmFpbnQpLGkuYmlhc1JlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHIuYmlhc1JlZ3VsYXJpemVyKSxpLmFjdGl2aXR5UmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIoci5hY3Rpdml0eVJlZ3VsYXJpemVyKSxpLmRpbGF0aW9uUmF0ZT1ub3JtYWxpemVBcnJheShudWxsPT1yLmRpbGF0aW9uUmF0ZT8xOnIuZGlsYXRpb25SYXRlLG4sXCJkaWxhdGlvblJhdGVcIiksMT09PWkucmFuayYmQXJyYXkuaXNBcnJheShpLmRpbGF0aW9uUmF0ZSkmJjEhPT1pLmRpbGF0aW9uUmF0ZS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJkaWxhdGlvblJhdGUgbXVzdCBiZSBhIG51bWJlciBvciBhbiBhcnJheSBvZiBhIHNpbmdsZSBudW1iZXIgZm9yIDFEIGNvbnZvbHV0aW9uLCBidXQgcmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkoaS5kaWxhdGlvblJhdGUpKTtpZigyPT09aS5yYW5rKXtpZihcIm51bWJlclwiPT10eXBlb2YgaS5kaWxhdGlvblJhdGUpaS5kaWxhdGlvblJhdGU9W2kuZGlsYXRpb25SYXRlLGkuZGlsYXRpb25SYXRlXTtlbHNlIGlmKDIhPT1pLmRpbGF0aW9uUmF0ZS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJkaWxhdGlvblJhdGUgbXVzdCBiZSBhIG51bWJlciBvciBhcnJheSBvZiB0d28gbnVtYmVycyBmb3IgMkQgY29udm9sdXRpb24sIGJ1dCByZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeShpLmRpbGF0aW9uUmF0ZSkpfWVsc2UgaWYoMz09PWkucmFuaylpZihcIm51bWJlclwiPT10eXBlb2YgaS5kaWxhdGlvblJhdGUpaS5kaWxhdGlvblJhdGU9W2kuZGlsYXRpb25SYXRlLGkuZGlsYXRpb25SYXRlLGkuZGlsYXRpb25SYXRlXTtlbHNlIGlmKDMhPT1pLmRpbGF0aW9uUmF0ZS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJkaWxhdGlvblJhdGUgbXVzdCBiZSBhIG51bWJlciBvciBhcnJheSBvZiB0aHJlZSBudW1iZXJzIGZvciAzRCBjb252b2x1dGlvbiwgYnV0IHJlY2VpdmVkIFwiK0pTT04uc3RyaW5naWZ5KGkuZGlsYXRpb25SYXRlKSk7cmV0dXJuIGl9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQudmVyaWZ5QXJncz1mdW5jdGlvbihlKXtpZihhc3NlcnQoXCJrZXJuZWxTaXplXCJpbiBlLFwicmVxdWlyZWQga2V5ICdrZXJuZWxTaXplJyBub3QgaW4gY29uZmlnXCIpLFwibnVtYmVyXCIhPXR5cGVvZiBlLmtlcm5lbFNpemUmJiFjaGVja0FycmF5VHlwZUFuZExlbmd0aChlLmtlcm5lbFNpemUsXCJudW1iZXJcIiwxLDMpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQmFzZUNvbnYgZXhwZWN0cyBjb25maWcua2VybmVsU2l6ZSB0byBiZSBudW1iZXIgb3IgbnVtYmVyW10gd2l0aCBsZW5ndGggMSwgMiwgb3IgMywgYnV0IHJlY2VpdmVkIFwiK0pTT04uc3RyaW5naWZ5KGUua2VybmVsU2l6ZSkrXCIuXCIpfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17a2VybmVsU2l6ZTp0aGlzLmtlcm5lbFNpemUsc3RyaWRlczp0aGlzLnN0cmlkZXMscGFkZGluZzp0aGlzLnBhZGRpbmcsZGF0YUZvcm1hdDp0aGlzLmRhdGFGb3JtYXQsZGlsYXRpb25SYXRlOnRoaXMuZGlsYXRpb25SYXRlLGFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLHVzZUJpYXM6dGhpcy51c2VCaWFzLGJpYXNJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksYmlhc1JlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksYmlhc0NvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KX0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHR9KExheWVyKSxDb252PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobixyKXt2YXIgaT1lLmNhbGwodGhpcyxuLHIpfHx0aGlzO3JldHVybiBpLmtlcm5lbD1udWxsLHQudmVyaWZ5QXJncyhyKSxpLmZpbHRlcnM9ci5maWx0ZXJzLGFzc2VydFBvc2l0aXZlSW50ZWdlcihpLmZpbHRlcnMsXCJmaWx0ZXJzXCIpLGkua2VybmVsSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIoci5rZXJuZWxJbml0aWFsaXplcnx8aS5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUiksaS5rZXJuZWxDb25zdHJhaW50PWdldENvbnN0cmFpbnQoci5rZXJuZWxDb25zdHJhaW50KSxpLmtlcm5lbFJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHIua2VybmVsUmVndWxhcml6ZXIpLGl9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe3ZhciB0O2U9Z2V0RXhhY3RseU9uZVNoYXBlKGUpO3ZhciBuPVwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0PzE6ZS5sZW5ndGgtMTtpZihudWxsPT1lW25dKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGNoYW5uZWwgZGltZW5zaW9uIG9mIHRoZSBpbnB1dCBzaG91bGQgYmUgZGVmaW5lZC4gRm91bmQgXCIrZVtuXSk7dmFyIHI9ZVtuXSxpPXRoaXMua2VybmVsU2l6ZS5jb25jYXQoW3IsdGhpcy5maWx0ZXJzXSk7dGhpcy5rZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJrZXJuZWxcIixpLG51bGwsdGhpcy5rZXJuZWxJbml0aWFsaXplcix0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCEwLHRoaXMua2VybmVsQ29uc3RyYWludCksdGhpcy51c2VCaWFzJiYodGhpcy5iaWFzPXRoaXMuYWRkV2VpZ2h0KFwiYmlhc1wiLFt0aGlzLmZpbHRlcnNdLG51bGwsdGhpcy5iaWFzSW5pdGlhbGl6ZXIsdGhpcy5iaWFzUmVndWxhcml6ZXIsITAsdGhpcy5iaWFzQ29uc3RyYWludCkpLHRoaXMuaW5wdXRTcGVjPVt7bmRpbTp0aGlzLnJhbmsrMixheGVzOih0PXt9LHRbbl09cix0KX1dLHRoaXMuYnVpbHQ9ITB9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ7ZT1nZXRFeGFjdGx5T25lVGVuc29yKGUpO3ZhciByPW51bGw9PW4uYmlhcz9udWxsOm4uYmlhcy5yZWFkKCk7aWYoMT09PW4ucmFuayl0PWNvbnYxZFdpdGhCaWFzKGUsbi5rZXJuZWwucmVhZCgpLHIsbi5zdHJpZGVzWzBdLG4ucGFkZGluZyxuLmRhdGFGb3JtYXQsbi5kaWxhdGlvblJhdGVbMF0pO2Vsc2UgaWYoMj09PW4ucmFuayl0PWNvbnYyZFdpdGhCaWFzKGUsbi5rZXJuZWwucmVhZCgpLHIsbi5zdHJpZGVzLG4ucGFkZGluZyxuLmRhdGFGb3JtYXQsbi5kaWxhdGlvblJhdGUpO2Vsc2V7aWYoMyE9PW4ucmFuayl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcImNvbnZvbHV0aW9ucyBncmVhdGVyIHRoYW4gM0QgYXJlIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO3Q9Y29udjNkV2l0aEJpYXMoZSxuLmtlcm5lbC5yZWFkKCkscixuLnN0cmlkZXMsbi5wYWRkaW5nLG4uZGF0YUZvcm1hdCxuLmRpbGF0aW9uUmF0ZSl9cmV0dXJuIG51bGwhPW4uYWN0aXZhdGlvbiYmKHQ9bi5hY3RpdmF0aW9uLmFwcGx5KHQpKSx0fSl9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtlPWdldEV4YWN0bHlPbmVTaGFwZShlKTtmb3IodmFyIHQ9W10sbj1cImNoYW5uZWxzTGFzdFwiPT09dGhpcy5kYXRhRm9ybWF0P2Uuc2xpY2UoMSxlLmxlbmd0aC0xKTplLnNsaWNlKDIpLHI9MDtyPG4ubGVuZ3RoOysrcil7dmFyIGk9Y29udk91dHB1dExlbmd0aChuW3JdLHRoaXMua2VybmVsU2l6ZVtyXSx0aGlzLnBhZGRpbmcsdGhpcy5zdHJpZGVzW3JdLFwibnVtYmVyXCI9PXR5cGVvZiB0aGlzLmRpbGF0aW9uUmF0ZT90aGlzLmRpbGF0aW9uUmF0ZTp0aGlzLmRpbGF0aW9uUmF0ZVtyXSk7dC5wdXNoKGkpfXZhciBhPVtlWzBdXTtyZXR1cm5cImNoYW5uZWxzTGFzdFwiPT09dGhpcy5kYXRhRm9ybWF0PyhhPWEuY29uY2F0KHQpKS5wdXNoKHRoaXMuZmlsdGVycyk6KGEucHVzaCh0aGlzLmZpbHRlcnMpLGE9YS5jb25jYXQodCkpLGF9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtmaWx0ZXJzOnRoaXMuZmlsdGVycyxrZXJuZWxJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxrZXJuZWxSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmtlcm5lbFJlZ3VsYXJpemVyKSxrZXJuZWxDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5rZXJuZWxDb25zdHJhaW50KX0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQudmVyaWZ5QXJncz1mdW5jdGlvbihlKXtpZighKFwiZmlsdGVyc1wiaW4gZSl8fFwibnVtYmVyXCIhPXR5cGVvZiBlLmZpbHRlcnN8fGUuZmlsdGVyczwxKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ29udm9sdXRpb24gbGF5ZXIgZXhwZWN0ZWQgY29uZmlnLmZpbHRlcnMgdG8gYmUgYSAnbnVtYmVyJyA+IDAgYnV0IGdvdCBcIitKU09OLnN0cmluZ2lmeShlLmZpbHRlcnMpKX0sdH0oQmFzZUNvbnYpLENvbnYyRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KG4pe3ZhciByPWUuY2FsbCh0aGlzLDIsbil8fHRoaXM7cmV0dXJuIHQudmVyaWZ5QXJncyhuKSxyfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gZGVsZXRlIHQucmFuayx0fSx0LnZlcmlmeUFyZ3M9ZnVuY3Rpb24oZSl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGUua2VybmVsU2l6ZSYmIWNoZWNrQXJyYXlUeXBlQW5kTGVuZ3RoKGUua2VybmVsU2l6ZSxcIm51bWJlclwiLDEsMikpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDb252MkQgZXhwZWN0cyBjb25maWcua2VybmVsU2l6ZSB0byBiZSBudW1iZXIgb3IgbnVtYmVyW10gd2l0aCBsZW5ndGggMSBvciAyLCBidXQgcmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkoZS5rZXJuZWxTaXplKStcIi5cIil9LHQuY2xhc3NOYW1lPVwiQ29udjJEXCIsdH0oQ29udik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKENvbnYyRCk7dmFyIENvbnYzRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KG4pe3ZhciByPWUuY2FsbCh0aGlzLDMsbil8fHRoaXM7cmV0dXJuIHQudmVyaWZ5QXJncyhuKSxyfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gZGVsZXRlIHQucmFuayx0fSx0LnZlcmlmeUFyZ3M9ZnVuY3Rpb24oZSl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGUua2VybmVsU2l6ZSYmKCFBcnJheS5pc0FycmF5KGUua2VybmVsU2l6ZSl8fDEhPT1lLmtlcm5lbFNpemUubGVuZ3RoJiYzIT09ZS5rZXJuZWxTaXplLmxlbmd0aCkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDb252M0QgZXhwZWN0cyBjb25maWcua2VybmVsU2l6ZSB0byBiZSBudW1iZXIgb3IgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBidXQgcmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkoZS5rZXJuZWxTaXplKStcIi5cIil9LHQuY2xhc3NOYW1lPVwiQ29udjNEXCIsdH0oQ29udik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKENvbnYzRCk7dmFyIENvbnYyRFRyYW5zcG9zZT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO2lmKG4uaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOjR9KV0sXCJzYW1lXCIhPT1uLnBhZGRpbmcmJlwidmFsaWRcIiE9PW4ucGFkZGluZyl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkNvbnYyRFRyYW5zcG9zZSBjdXJyZW50bHkgc3VwcG9ydHMgb25seSBwYWRkaW5nIG1vZGVzICdzYW1lJyBhbmQgJ3ZhbGlkJywgYnV0IHJlY2VpdmVkIHBhZGRpbmcgbW9kZSBcIituLnBhZGRpbmcpO3JldHVybiBufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXt2YXIgdDtpZig0IT09KGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpKS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnB1dCBzaG91bGQgaGF2ZSByYW5rIDQ7IFJlY2VpdmVkIGlucHV0IHNoYXBlOiBcIitKU09OLnN0cmluZ2lmeShlKSk7dmFyIG49XCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/MTplLmxlbmd0aC0xO2lmKG51bGw9PWVbbl0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgY2hhbm5lbCBkaW1lbnNpb24gb2YgdGhlIGlucHV0cyBzaG91bGQgYmUgZGVmaW5lZC4gRm91bmQgYE5vbmVgLlwiKTt2YXIgcj1lW25dLGk9dGhpcy5rZXJuZWxTaXplLmNvbmNhdChbdGhpcy5maWx0ZXJzLHJdKTt0aGlzLmtlcm5lbD10aGlzLmFkZFdlaWdodChcImtlcm5lbFwiLGksXCJmbG9hdDMyXCIsdGhpcy5rZXJuZWxJbml0aWFsaXplcix0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCEwLHRoaXMua2VybmVsQ29uc3RyYWludCksdGhpcy51c2VCaWFzJiYodGhpcy5iaWFzPXRoaXMuYWRkV2VpZ2h0KFwiYmlhc1wiLFt0aGlzLmZpbHRlcnNdLFwiZmxvYXQzMlwiLHRoaXMuYmlhc0luaXRpYWxpemVyLHRoaXMuYmlhc1JlZ3VsYXJpemVyLCEwLHRoaXMuYmlhc0NvbnN0cmFpbnQpKSx0aGlzLmlucHV0U3BlYz1bbmV3IElucHV0U3BlYyh7bmRpbTo0LGF4ZXM6KHQ9e30sdFtuXT1yLHQpfSldLHRoaXMuYnVpbHQ9ITB9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHQ9Z2V0RXhhY3RseU9uZVRlbnNvcihlKTtpZig0IT09dC5zaGFwZS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDb252MkRUcmFuc3Bvc2UuY2FsbCgpIGV4cGVjdHMgaW5wdXQgdGVuc29yIHRvIGJlIHJhbmstNCwgYnV0IHJlY2VpdmVkIGEgdGVuc29yIG9mIHJhbmstXCIrdC5zaGFwZS5sZW5ndGgpO3ZhciByLGksYT10LnNoYXBlLG89YVswXTtcImNoYW5uZWxzRmlyc3RcIj09PW4uZGF0YUZvcm1hdD8ocj0yLGk9Myk6KHI9MSxpPTIpO3ZhciBzPWFbcl0sbD1hW2ldLHU9bi5rZXJuZWxTaXplWzBdLGM9bi5rZXJuZWxTaXplWzFdLHA9bi5zdHJpZGVzWzBdLGg9bi5zdHJpZGVzWzFdLGQ9W28sZGVjb252TGVuZ3RoKHMscCx1LG4ucGFkZGluZyksZGVjb252TGVuZ3RoKGwsaCxjLG4ucGFkZGluZyksbi5maWx0ZXJzXTtcImNoYW5uZWxzTGFzdFwiIT09bi5kYXRhRm9ybWF0JiYodD10cmFuc3Bvc2UodCxbMCwyLDMsMV0pKTt2YXIgZj1jb252MmRUcmFuc3Bvc2UodCxuLmtlcm5lbC5yZWFkKCksZCxuLnN0cmlkZXMsbi5wYWRkaW5nKTtyZXR1cm5cImNoYW5uZWxzTGFzdFwiIT09bi5kYXRhRm9ybWF0JiYoZj10cmFuc3Bvc2UoZixbMCwzLDEsMl0pKSxudWxsIT1uLmJpYXMmJihmPWJpYXNBZGQoZixuLmJpYXMucmVhZCgpLG4uZGF0YUZvcm1hdCkpLG51bGwhPW4uYWN0aXZhdGlvbiYmKGY9bi5hY3RpdmF0aW9uLmFwcGx5KGYpKSxmfSl9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXt2YXIgdCxuLHIsaT0oZT1nZXRFeGFjdGx5T25lU2hhcGUoZSkpLnNsaWNlKCk7XCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/KHQ9MSxuPTIscj0zKToodD0zLG49MSxyPTIpO3ZhciBhPXRoaXMua2VybmVsU2l6ZVswXSxvPXRoaXMua2VybmVsU2l6ZVsxXSxzPXRoaXMuc3RyaWRlc1swXSxsPXRoaXMuc3RyaWRlc1sxXTtyZXR1cm4gaVt0XT10aGlzLmZpbHRlcnMsaVtuXT1kZWNvbnZMZW5ndGgoaVtuXSxzLGEsdGhpcy5wYWRkaW5nKSxpW3JdPWRlY29udkxlbmd0aChpW3JdLGwsbyx0aGlzLnBhZGRpbmcpLGl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBkZWxldGUgdC5kaWxhdGlvblJhdGUsdH0sdC5jbGFzc05hbWU9XCJDb252MkRUcmFuc3Bvc2VcIix0fShDb252MkQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhDb252MkRUcmFuc3Bvc2UpO3ZhciBTZXBhcmFibGVDb252PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCxuKXt2YXIgcj1lLmNhbGwodGhpcyx0LG4pfHx0aGlzO2lmKHIuREVGQVVMVF9ERVBUSFdJU0VfSU5JVElBTElaRVI9XCJnbG9yb3RVbmlmb3JtXCIsci5ERUZBVUxUX1BPSU5UV0lTRV9JTklUSUFMSVpFUj1cImdsb3JvdFVuaWZvcm1cIixyLmRlcHRod2lzZUtlcm5lbD1udWxsLHIucG9pbnR3aXNlS2VybmVsPW51bGwsbnVsbD09bi5maWx0ZXJzKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGhlIGBmaWx0ZXJzYCBjb25maWd1cmF0aW9uIGZpZWxkIGlzIHJlcXVpcmVkIGJ5IFNlcGFyYWJsZUNvbnYsIGJ1dCBpcyB1bnNwZWNpZmllZC5cIik7aWYobnVsbCE9bi5rZXJuZWxJbml0aWFsaXplcnx8bnVsbCE9bi5rZXJuZWxSZWd1bGFyaXplcnx8bnVsbCE9bi5rZXJuZWxDb25zdHJhaW50KXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRmllbGRzIGtlcm5lbEluaXRpYWxpemVyLCBrZXJuZWxSZWd1bGFyaXplciBhbmQga2VybmVsQ29uc3RyYWludCBhcmUgaW52YWxpZCBmb3IgU2VwYXJhYmxlQ29udjJELiBVc2UgZGVwdGh3aXNlSW5pdGlhbGl6ZXIsIGRlcHRod2lzZVJlZ3VsYXJpemVyLCBkZXB0aHdpc2VDb25zdHJhaW50LCBwb2ludHdpc2VJbml0aWFsaXplciwgcG9pbnR3aXNlUmVndWxhcml6ZXIgYW5kIHBvaW50d2lzZUNvbnN0cmFpbnQgaW5zdGVhZC5cIik7aWYobnVsbCE9bi5wYWRkaW5nJiZcInNhbWVcIiE9PW4ucGFkZGluZyYmXCJ2YWxpZFwiIT09bi5wYWRkaW5nKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiU2VwYXJhYmxlQ29udlwiK3IucmFuaytcIkQgc3VwcG9ydHMgb25seSBwYWRkaW5nIG1vZGVzOiAnc2FtZScgYW5kICd2YWxpZCcsIGJ1dCByZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeShuLnBhZGRpbmcpKTtyZXR1cm4gci5kZXB0aE11bHRpcGxpZXI9bnVsbD09bi5kZXB0aE11bHRpcGxpZXI/MTpuLmRlcHRoTXVsdGlwbGllcixyLmRlcHRod2lzZUluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKG4uZGVwdGh3aXNlSW5pdGlhbGl6ZXJ8fHIuREVGQVVMVF9ERVBUSFdJU0VfSU5JVElBTElaRVIpLHIuZGVwdGh3aXNlUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIobi5kZXB0aHdpc2VSZWd1bGFyaXplciksci5kZXB0aHdpc2VDb25zdHJhaW50PWdldENvbnN0cmFpbnQobi5kZXB0aHdpc2VDb25zdHJhaW50KSxyLnBvaW50d2lzZUluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKG4uZGVwdGh3aXNlSW5pdGlhbGl6ZXJ8fHIuREVGQVVMVF9QT0lOVFdJU0VfSU5JVElBTElaRVIpLHIucG9pbnR3aXNlUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIobi5wb2ludHdpc2VSZWd1bGFyaXplciksci5wb2ludHdpc2VDb25zdHJhaW50PWdldENvbnN0cmFpbnQobi5wb2ludHdpc2VDb25zdHJhaW50KSxyfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXt2YXIgdDtpZigoZT1nZXRFeGFjdGx5T25lU2hhcGUoZSkpLmxlbmd0aDx0aGlzLnJhbmsrMil0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0cyB0byBTZXBhcmFibGVDb252XCIrdGhpcy5yYW5rK1wiRCBzaG91bGQgaGF2ZSByYW5rIFwiKyh0aGlzLnJhbmsrMikrXCIsIGJ1dCByZWNlaXZlZCBpbnB1dCBzaGFwZTogXCIrSlNPTi5zdHJpbmdpZnkoZSkpO3ZhciBuPVwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0PzE6ZS5sZW5ndGgtMTtpZihudWxsPT1lW25dfHxlW25dPDApdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgY2hhbm5lbCBkaW1lbnNpb24gb2YgdGhlIGlucHV0cyBzaG91bGQgYmUgZGVmaW5lZCwgYnV0IGZvdW5kIFwiK0pTT04uc3RyaW5naWZ5KGVbbl0pKTtmb3IodmFyIHI9ZVtuXSxpPXRoaXMua2VybmVsU2l6ZS5jb25jYXQoW3IsdGhpcy5kZXB0aE11bHRpcGxpZXJdKSxhPVtdLG89MDtvPHRoaXMucmFuazsrK28pYS5wdXNoKDEpO2EucHVzaChyKnRoaXMuZGVwdGhNdWx0aXBsaWVyLHRoaXMuZmlsdGVycyk7dGhpcy5kZXB0aHdpc2VLZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJkZXB0aHdpc2Vfa2VybmVsXCIsaSxcImZsb2F0MzJcIix0aGlzLmRlcHRod2lzZUluaXRpYWxpemVyLHRoaXMuZGVwdGh3aXNlUmVndWxhcml6ZXIsITAsdGhpcy5kZXB0aHdpc2VDb25zdHJhaW50KSx0aGlzLnBvaW50d2lzZUtlcm5lbD10aGlzLmFkZFdlaWdodChcInBvaW50d2lzZV9rZXJuZWxcIixhLFwiZmxvYXQzMlwiLHRoaXMucG9pbnR3aXNlSW5pdGlhbGl6ZXIsdGhpcy5wb2ludHdpc2VSZWd1bGFyaXplciwhMCx0aGlzLnBvaW50d2lzZUNvbnN0cmFpbnQpLHRoaXMudXNlQmlhcz90aGlzLmJpYXM9dGhpcy5hZGRXZWlnaHQoXCJiaWFzXCIsW3RoaXMuZmlsdGVyc10sXCJmbG9hdDMyXCIsdGhpcy5iaWFzSW5pdGlhbGl6ZXIsdGhpcy5iaWFzUmVndWxhcml6ZXIsITAsdGhpcy5iaWFzQ29uc3RyYWludCk6dGhpcy5iaWFzPW51bGwsdGhpcy5pbnB1dFNwZWM9W25ldyBJbnB1dFNwZWMoe25kaW06dGhpcy5yYW5rKzIsYXhlczoodD17fSx0W25dPXIsdCl9KV0sdGhpcy5idWlsdD0hMH0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgdDtpZihlPWdldEV4YWN0bHlPbmVUZW5zb3IoZSksMT09PW4ucmFuayl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcIjFEIHNlcGFyYWJsZSBjb252b2x1dGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtyZXR1cm4gMj09PW4ucmFuayYmKFwiY2hhbm5lbHNGaXJzdFwiPT09bi5kYXRhRm9ybWF0JiYoZT10cmFuc3Bvc2UoZSxbMCwyLDMsMV0pKSx0PXNlcGFyYWJsZUNvbnYyZChlLG4uZGVwdGh3aXNlS2VybmVsLnJlYWQoKSxuLnBvaW50d2lzZUtlcm5lbC5yZWFkKCksbi5zdHJpZGVzLG4ucGFkZGluZyxuLmRpbGF0aW9uUmF0ZSxcIk5IV0NcIikpLG4udXNlQmlhcyYmKHQ9Ymlhc0FkZCh0LG4uYmlhcy5yZWFkKCksbi5kYXRhRm9ybWF0KSksbnVsbCE9bi5hY3RpdmF0aW9uJiYodD1uLmFjdGl2YXRpb24uYXBwbHkodCkpLFwiY2hhbm5lbHNGaXJzdFwiPT09bi5kYXRhRm9ybWF0JiYodD10cmFuc3Bvc2UodCxbMCwzLDEsMl0pKSx0fSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBkZWxldGUgdC5yYW5rLGRlbGV0ZSB0Lmtlcm5lbEluaXRpYWxpemVyLGRlbGV0ZSB0Lmtlcm5lbFJlZ3VsYXJpemVyLGRlbGV0ZSB0Lmtlcm5lbENvbnN0cmFpbnQsdC5kZXB0aHdpc2VJbml0aWFsaXplcj1zZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmRlcHRod2lzZUluaXRpYWxpemVyKSx0LnBvaW50d2lzZUluaXRpYWxpemVyPXNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMucG9pbnR3aXNlSW5pdGlhbGl6ZXIpLHQuZGVwdGh3aXNlUmVndWxhcml6ZXI9c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5kZXB0aHdpc2VSZWd1bGFyaXplciksdC5wb2ludHdpc2VSZWd1bGFyaXplcj1zZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLnBvaW50d2lzZVJlZ3VsYXJpemVyKSx0LmRlcHRod2lzZUNvbnN0cmFpbnQ9c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmRlcHRod2lzZUNvbnN0cmFpbnQpLHQucG9pbnR3aXNlQ29uc3RyYWludD1zZXJpYWxpemVDb25zdHJhaW50KHRoaXMucG9pbnR3aXNlQ29uc3RyYWludCksdH0sdC5jbGFzc05hbWU9XCJTZXBhcmFibGVDb252XCIsdH0oQ29udiksU2VwYXJhYmxlQ29udjJEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLDIsdCl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQuY2xhc3NOYW1lPVwiU2VwYXJhYmxlQ29udjJEXCIsdH0oU2VwYXJhYmxlQ29udik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFNlcGFyYWJsZUNvbnYyRCk7dmFyIENvbnYxRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KG4pe3ZhciByPWUuY2FsbCh0aGlzLDEsbil8fHRoaXM7cmV0dXJuIHQudmVyaWZ5QXJncyhuKSxyLmlucHV0U3BlYz1be25kaW06M31dLHJ9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBkZWxldGUgdC5yYW5rLGRlbGV0ZSB0LmRhdGFGb3JtYXQsdH0sdC52ZXJpZnlBcmdzPWZ1bmN0aW9uKGUpe2lmKFwibnVtYmVyXCIhPXR5cGVvZiBlLmtlcm5lbFNpemUmJiFjaGVja0FycmF5VHlwZUFuZExlbmd0aChlLmtlcm5lbFNpemUsXCJudW1iZXJcIiwxLDEpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ29udjFEIGV4cGVjdHMgY29uZmlnLmtlcm5lbFNpemUgdG8gYmUgbnVtYmVyIG9yIG51bWJlcltdIHdpdGggbGVuZ3RoIDEsIGJ1dCByZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeShlLmtlcm5lbFNpemUpK1wiLlwiKX0sdC5jbGFzc05hbWU9XCJDb252MURcIix0fShDb252KTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQ29udjFEKTt2YXIgQ3JvcHBpbmcyRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0LmNyb3BwaW5nP24uY3JvcHBpbmc9W1t0LmNyb3BwaW5nLHQuY3JvcHBpbmddLFt0LmNyb3BwaW5nLHQuY3JvcHBpbmddXTpcIm51bWJlclwiPT10eXBlb2YgdC5jcm9wcGluZ1swXT9uLmNyb3BwaW5nPVtbdC5jcm9wcGluZ1swXSx0LmNyb3BwaW5nWzBdXSxbdC5jcm9wcGluZ1sxXSx0LmNyb3BwaW5nWzFdXV06bi5jcm9wcGluZz10LmNyb3BwaW5nLG4uZGF0YUZvcm1hdD12b2lkIDA9PT10LmRhdGFGb3JtYXQ/XCJjaGFubmVsc0xhc3RcIjp0LmRhdGFGb3JtYXQsbi5pbnB1dFNwZWM9W3tuZGltOjR9XSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuXCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/W2VbMF0sZVsxXSxlWzJdLXRoaXMuY3JvcHBpbmdbMF1bMF0tdGhpcy5jcm9wcGluZ1swXVsxXSxlWzNdLXRoaXMuY3JvcHBpbmdbMV1bMF0tdGhpcy5jcm9wcGluZ1sxXVsxXV06W2VbMF0sZVsxXS10aGlzLmNyb3BwaW5nWzBdWzBdLXRoaXMuY3JvcHBpbmdbMF1bMV0sZVsyXS10aGlzLmNyb3BwaW5nWzFdWzBdLXRoaXMuY3JvcHBpbmdbMV1bMV0sZVszXV19LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGU9Z2V0RXhhY3RseU9uZVRlbnNvcihlKSxcImNoYW5uZWxzTGFzdFwiPT09bi5kYXRhRm9ybWF0P3NsaWNlQWxvbmdBeGlzKHNsaWNlQWxvbmdBeGlzKGUsbi5jcm9wcGluZ1swXVswXSxlLnNoYXBlWzFdLW4uY3JvcHBpbmdbMF1bMF0tbi5jcm9wcGluZ1swXVsxXSwyKSxuLmNyb3BwaW5nWzFdWzBdLGUuc2hhcGVbMl0tbi5jcm9wcGluZ1sxXVsxXS1uLmNyb3BwaW5nWzFdWzBdLDMpOnNsaWNlQWxvbmdBeGlzKHNsaWNlQWxvbmdBeGlzKGUsbi5jcm9wcGluZ1swXVswXSxlLnNoYXBlWzJdLW4uY3JvcHBpbmdbMF1bMF0tbi5jcm9wcGluZ1swXVsxXSwzKSxuLmNyb3BwaW5nWzFdWzBdLGUuc2hhcGVbM10tbi5jcm9wcGluZ1sxXVsxXS1uLmNyb3BwaW5nWzFdWzBdLDQpfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtjcm9wcGluZzp0aGlzLmNyb3BwaW5nLGRhdGFGb3JtYXQ6dGhpcy5kYXRhRm9ybWF0fSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJDcm9wcGluZzJEXCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhDcm9wcGluZzJEKTt2YXIgVXBTYW1wbGluZzJEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIG4uREVGQVVMVF9TSVpFPVsyLDJdLG4uaW5wdXRTcGVjPVt7bmRpbTo0fV0sbi5zaXplPW51bGw9PXQuc2l6ZT9uLkRFRkFVTFRfU0laRTp0LnNpemUsbi5kYXRhRm9ybWF0PW51bGw9PXQuZGF0YUZvcm1hdD9cImNoYW5uZWxzTGFzdFwiOnQuZGF0YUZvcm1hdCxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7aWYoXCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQpe3ZhciB0PW51bGw9PWVbMl0/bnVsbDp0aGlzLnNpemVbMF0qZVsyXSxuPW51bGw9PWVbM10/bnVsbDp0aGlzLnNpemVbMV0qZVszXTtyZXR1cm5bZVswXSxlWzFdLHQsbl19dD1udWxsPT1lWzFdP251bGw6dGhpcy5zaXplWzBdKmVbMV0sbj1udWxsPT1lWzJdP251bGw6dGhpcy5zaXplWzFdKmVbMl07cmV0dXJuW2VbMF0sdCxuLGVbM11dfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciB0PWdldEV4YWN0bHlPbmVUZW5zb3IoZSkscj10LnNoYXBlO2lmKFwiY2hhbm5lbHNGaXJzdFwiPT09bi5kYXRhRm9ybWF0KXt0PXRyYW5zcG9zZSh0LFswLDIsMywxXSk7dmFyIGk9bi5zaXplWzBdKnJbMl0sYT1uLnNpemVbMV0qclszXSxvPXQucmVzaXplTmVhcmVzdE5laWdoYm9yKFtpLGFdKTtyZXR1cm4gdHJhbnNwb3NlKG8sWzAsMywxLDJdKX1pPW4uc2l6ZVswXSpyWzFdLGE9bi5zaXplWzFdKnJbMl07cmV0dXJuIHQucmVzaXplTmVhcmVzdE5laWdoYm9yKFtpLGFdKX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17c2l6ZTp0aGlzLnNpemUsZGF0YUZvcm1hdDp0aGlzLmRhdGFGb3JtYXR9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIlVwU2FtcGxpbmcyRFwiLHR9KExheWVyKTtmdW5jdGlvbiBkZXB0aHdpc2VDb252MmQkMShlLHQsbixyLGksYSl7cmV0dXJuIHZvaWQgMD09PW4mJihuPVsxLDFdKSx2b2lkIDA9PT1yJiYocj1cInZhbGlkXCIpLHRpZHkoZnVuY3Rpb24oKXtudWxsPT1pJiYoaT1pbWFnZURhdGFGb3JtYXQoKSksY2hlY2tEYXRhRm9ybWF0KGkpO3ZhciBvPXByZXByb2Nlc3NDb252MkRJbnB1dChlLGkpO2lmKDQhPT1lLnJhbmspdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJJbnB1dCBmb3IgZGVwdGh3aXNlQ29udjJkIGlzIHJlcXVpcmVkIHRvIGJlIDQtRCwgYnV0IGlzIGluc3RlYWQgXCIrZS5yYW5rK1wiLURcIik7aWYoNCE9PXQucmFuayl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImRlcHRod2lzZUtlcm5lbCBpcyByZXF1aXJlZCB0byBiZSA0LUQsIGJ1dCBpcyBpbnN0ZWFkIFwiK3QucmFuaytcIi1EXCIpO3JldHVybiBvPWRlcHRod2lzZUNvbnYyZChvLHQsbixcInNhbWVcIj09PXI/XCJzYW1lXCI6XCJ2YWxpZFwiLFwiTkhXQ1wiLGEpLFwiY2hhbm5lbHNGaXJzdFwiPT09aSYmKG89dHJhbnNwb3NlKG8sWzAsMywxLDJdKSksb30pfXNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhVcFNhbXBsaW5nMkQpO3ZhciBEZXB0aHdpc2VDb252MkQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcywyLHQpfHx0aGlzO3JldHVybiBuLmRlcHRod2lzZUtlcm5lbD1udWxsLG4uZGVwdGhNdWx0aXBsaWVyPW51bGw9PXQuZGVwdGhNdWx0aXBsaWVyPzE6dC5kZXB0aE11bHRpcGxpZXIsbi5kZXB0aHdpc2VJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcih0LmRlcHRod2lzZUluaXRpYWxpemVyfHxuLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKSxuLmRlcHRod2lzZUNvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludCh0LmRlcHRod2lzZUNvbnN0cmFpbnQpLG4uZGVwdGh3aXNlUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5kZXB0aHdpc2VSZWd1bGFyaXplciksbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7aWYoKGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpKS5sZW5ndGg8NCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0cyB0byBEZXB0aHdpc2VDb252MkQgc2hvdWxkIGhhdmUgcmFuayA0LiBSZWNlaXZlZCBpbnB1dCBzaGFwZTogXCIrSlNPTi5zdHJpbmdpZnkoZSkrXCIuXCIpO3ZhciB0PVwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0PzE6MztpZihudWxsPT1lW3RdfHxlW3RdPDApdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJUaGUgY2hhbm5lbCBkaW1lbnNpb24gb2YgdGhlIGlucHV0cyB0byBEZXB0aHdpc2VDb252MkQgc2hvdWxkIGJlIGRlZmluZWQsIGJ1dCBpcyBub3QgKFwiK2VbdF0rXCIpLlwiKTt2YXIgbj1lW3RdLHI9W3RoaXMua2VybmVsU2l6ZVswXSx0aGlzLmtlcm5lbFNpemVbMV0sbix0aGlzLmRlcHRoTXVsdGlwbGllcl07dGhpcy5kZXB0aHdpc2VLZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJkZXB0aHdpc2Vfa2VybmVsXCIscixudWxsLHRoaXMuZGVwdGh3aXNlSW5pdGlhbGl6ZXIsdGhpcy5kZXB0aHdpc2VSZWd1bGFyaXplciwhMCx0aGlzLmRlcHRod2lzZUNvbnN0cmFpbnQpLHRoaXMudXNlQmlhcz90aGlzLmJpYXM9dGhpcy5hZGRXZWlnaHQoXCJiaWFzXCIsW24qdGhpcy5kZXB0aE11bHRpcGxpZXJdLG51bGwsdGhpcy5iaWFzSW5pdGlhbGl6ZXIsdGhpcy5iaWFzUmVndWxhcml6ZXIsITAsdGhpcy5iaWFzQ29uc3RyYWludCk6dGhpcy5iaWFzPW51bGwsdGhpcy5idWlsdD0hMH0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgdD1kZXB0aHdpc2VDb252MmQkMShlPWdldEV4YWN0bHlPbmVUZW5zb3IoZSksbi5kZXB0aHdpc2VLZXJuZWwucmVhZCgpLG4uc3RyaWRlcyxuLnBhZGRpbmcsbi5kYXRhRm9ybWF0LG51bGwpO3JldHVybiBuLnVzZUJpYXMmJih0PWJpYXNBZGQodCxuLmJpYXMucmVhZCgpLG4uZGF0YUZvcm1hdCkpLG51bGwhPW4uYWN0aXZhdGlvbiYmKHQ9bi5hY3RpdmF0aW9uLmFwcGx5KHQpKSx0fSl9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtlPWdldEV4YWN0bHlPbmVTaGFwZShlKTt2YXIgdD1cImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdD9lWzJdOmVbMV0sbj1cImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdD9lWzNdOmVbMl0scj1cImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdD9lWzFdKnRoaXMuZGVwdGhNdWx0aXBsaWVyOmVbM10qdGhpcy5kZXB0aE11bHRpcGxpZXIsaT1jb252T3V0cHV0TGVuZ3RoKHQsdGhpcy5rZXJuZWxTaXplWzBdLHRoaXMucGFkZGluZyx0aGlzLnN0cmlkZXNbMF0pLGE9Y29udk91dHB1dExlbmd0aChuLHRoaXMua2VybmVsU2l6ZVsxXSx0aGlzLnBhZGRpbmcsdGhpcy5zdHJpZGVzWzFdKTtyZXR1cm5cImNoYW5uZWxzRmlyc3RcIj09PXRoaXMuZGF0YUZvcm1hdD9bZVswXSxyLGksYV06W2VbMF0saSxhLHJdfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gdC5kZXB0aE11bHRpcGxpZXI9dGhpcy5kZXB0aE11bHRpcGxpZXIsdC5kZXB0aHdpc2VJbml0aWFsaXplcj1zZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmRlcHRod2lzZUluaXRpYWxpemVyKSx0LmRlcHRod2lzZVJlZ3VsYXJpemVyPXNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuZGVwdGh3aXNlUmVndWxhcml6ZXIpLHQuZGVwdGh3aXNlQ29uc3RyYWludD1zZXJpYWxpemVDb25zdHJhaW50KHRoaXMuZGVwdGh3aXNlUmVndWxhcml6ZXIpLHR9LHQuY2xhc3NOYW1lPVwiRGVwdGh3aXNlQ29udjJEXCIsdH0oQmFzZUNvbnYpO2Z1bmN0aW9uIG1hcEFjdGl2YXRpb25Ub0Z1c2VkS2VybmVsKGUpe3JldHVyblwicmVsdVwiPT09ZT9cInJlbHVcIjpcImxpbmVhclwiPT09ZT9cImxpbmVhclwiOm51bGx9c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKERlcHRod2lzZUNvbnYyRCk7dmFyIERyb3BvdXQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztpZihuLnJhdGU9TWF0aC5tYXgoTWF0aC5taW4odC5yYXRlLDEpLDApLG4ubm9pc2VTaGFwZT10Lm5vaXNlU2hhcGUsbi5zZWVkPXQuc2VlZCxudWxsIT1uLnNlZWQpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJOb24tZGVmYXVsdCBzZWVkIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBEcm9wb3V0IGxheWVyIHlldDogXCIrbi5zZWVkKTtyZXR1cm4gbi5zdXBwb3J0c01hc2tpbmc9ITAsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuZ2V0Tm9pc2VTaGFwZT1mdW5jdGlvbihlKXtpZihudWxsPT10aGlzLm5vaXNlU2hhcGUpcmV0dXJuIHRoaXMubm9pc2VTaGFwZTtmb3IodmFyIHQ9ZS5zaGFwZSxuPVtdLHI9MDtyPHRoaXMubm9pc2VTaGFwZS5sZW5ndGg7KytyKW4ucHVzaChudWxsPT10aGlzLm5vaXNlU2hhcGVbcl0/dFtyXTp0aGlzLm5vaXNlU2hhcGVbcl0pO3JldHVybiBufSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe24uaW52b2tlQ2FsbEhvb2soZSx0KTt2YXIgcj1nZXRFeGFjdGx5T25lVGVuc29yKGUpO2lmKG51bGwhPW4ubm9pc2VTaGFwZSYmIXV0aWwuYXJyYXlzRXF1YWwoci5zaGFwZSxuLm5vaXNlU2hhcGUpKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiTm9uLWRlZmF1bHQgbm9pc2Ugc2hhcGUgaXMgbm90IGltcGxlbWVudGVkIGluIERyb3BvdXQgbGF5ZXIgeWV0OiBcIitKU09OLnN0cmluZ2lmeShuLm5vaXNlU2hhcGUpKTtpZigwPG4ucmF0ZSYmbi5yYXRlPDEpe3ZhciBpPW51bGwhPXQudHJhaW5pbmcmJnQudHJhaW5pbmcsYT1uLmdldE5vaXNlU2hhcGUocik7cmV0dXJuIGluVHJhaW5QaGFzZShmdW5jdGlvbigpe3JldHVybiBkcm9wb3V0KHIsbi5yYXRlLGEsbi5zZWVkKX0sZnVuY3Rpb24oKXtyZXR1cm4gcn0saSl9cmV0dXJuIGV9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e3JhdGU6dGhpcy5yYXRlLG5vaXNlU2hhcGU6dGhpcy5ub2lzZVNoYXBlLHNlZWQ6dGhpcy5zZWVkfSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3JldHVybiBlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyl9LHQuY2xhc3NOYW1lPVwiRHJvcG91dFwiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoRHJvcG91dCk7dmFyIERlbnNlPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7aWYobi5hY3RpdmF0aW9uPW51bGwsbi51c2VCaWFzPSEwLG4ua2VybmVsPW51bGwsbi5iaWFzPW51bGwsbi5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUj1cImdsb3JvdE5vcm1hbFwiLG4uREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSPVwiemVyb3NcIixudWxsPT10LmJhdGNoSW5wdXRTaGFwZSYmbnVsbD09dC5pbnB1dFNoYXBlJiZudWxsIT10LmlucHV0RGltKXt2YXIgcj1udWxsO251bGwhPXQuYmF0Y2hTaXplJiYocj10LmJhdGNoU2l6ZSksbi5iYXRjaElucHV0U2hhcGU9W3IsdC5pbnB1dERpbV19cmV0dXJuIG4udW5pdHM9dC51bml0cyxhc3NlcnRQb3NpdGl2ZUludGVnZXIobi51bml0cyxcInVuaXRzXCIpLG4uYWN0aXZhdGlvbj1nZXRBY3RpdmF0aW9uKHQuYWN0aXZhdGlvbiksbnVsbCE9dC51c2VCaWFzJiYobi51c2VCaWFzPXQudXNlQmlhcyksbi5rZXJuZWxJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcih0Lmtlcm5lbEluaXRpYWxpemVyfHxuLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKSxuLmJpYXNJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcih0LmJpYXNJbml0aWFsaXplcnx8bi5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVIpLG4ua2VybmVsQ29uc3RyYWludD1nZXRDb25zdHJhaW50KHQua2VybmVsQ29uc3RyYWludCksbi5iaWFzQ29uc3RyYWludD1nZXRDb25zdHJhaW50KHQuYmlhc0NvbnN0cmFpbnQpLG4ua2VybmVsUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5rZXJuZWxSZWd1bGFyaXplciksbi5iaWFzUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5iaWFzUmVndWxhcml6ZXIpLG4uYWN0aXZpdHlSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0LmFjdGl2aXR5UmVndWxhcml6ZXIpLG4uc3VwcG9ydHNNYXNraW5nPSEwLG4uaW5wdXRTcGVjPVt7bWluTkRpbToyfV0sbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7dmFyIHQsbj0oZT1nZXRFeGFjdGx5T25lU2hhcGUoZSkpW2UubGVuZ3RoLTFdO251bGw9PXRoaXMua2VybmVsJiYodGhpcy5rZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJrZXJuZWxcIixbbix0aGlzLnVuaXRzXSxudWxsLHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsdGhpcy5rZXJuZWxSZWd1bGFyaXplciwhMCx0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHRoaXMudXNlQmlhcyYmKHRoaXMuYmlhcz10aGlzLmFkZFdlaWdodChcImJpYXNcIixbdGhpcy51bml0c10sbnVsbCx0aGlzLmJpYXNJbml0aWFsaXplcix0aGlzLmJpYXNSZWd1bGFyaXplciwhMCx0aGlzLmJpYXNDb25zdHJhaW50KSkpLHRoaXMuaW5wdXRTcGVjPVt7bWluTkRpbToyLGF4ZXM6KHQ9e30sdFstMV09bix0KX1dLHRoaXMuYnVpbHQ9ITB9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXt2YXIgdD0oZT1nZXRFeGFjdGx5T25lU2hhcGUoZSkpLnNsaWNlKCk7cmV0dXJuIHRbdC5sZW5ndGgtMV09dGhpcy51bml0cyx0fSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe24uaW52b2tlQ2FsbEhvb2soZSx0KTt2YXIgcixpPWdldEV4YWN0bHlPbmVUZW5zb3IoZSksYT1tYXBBY3RpdmF0aW9uVG9GdXNlZEtlcm5lbChuLmFjdGl2YXRpb24uZ2V0Q2xhc3NOYW1lKCkpO3JldHVybiBudWxsIT1hP3I9ZG90KGksbi5rZXJuZWwucmVhZCgpLGEsbi5iaWFzP24uYmlhcy5yZWFkKCk6bnVsbCk6KHI9ZG90KGksbi5rZXJuZWwucmVhZCgpKSxudWxsIT1uLmJpYXMmJihyPWJpYXNBZGQocixuLmJpYXMucmVhZCgpKSksbnVsbCE9bi5hY3RpdmF0aW9uJiYocj1uLmFjdGl2YXRpb24uYXBwbHkocikpKSxyfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXt1bml0czp0aGlzLnVuaXRzLGFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLHVzZUJpYXM6dGhpcy51c2VCaWFzLGtlcm5lbEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLGJpYXNJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksa2VybmVsUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplciksYmlhc1JlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksa2VybmVsQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMua2VybmVsQ29uc3RyYWludCksYmlhc0NvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KX0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiRGVuc2VcIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKERlbnNlKTt2YXIgRmxhdHRlbj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHR8fHt9KXx8dGhpcztyZXR1cm4gbi5pbnB1dFNwZWM9W3ttaW5ORGltOjN9XSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTAsbj0oZT1nZXRFeGFjdGx5T25lU2hhcGUoZSkpLnNsaWNlKDEpO3Q8bi5sZW5ndGg7dCsrKXtpZihudWxsPT1uW3RdKXRocm93IG5ldyBWYWx1ZUVycm9yKCdUaGUgc2hhcGUgb2YgdGhlIGlucHV0IHRvIFwiRmxhdHRlblwiIGlzIG5vdCBmdWxseSBkZWZpbmVkIChnb3QgJytlLnNsaWNlKDEpKycpLiBNYWtlIHN1cmUgdG8gcGFzcyBhIGNvbXBsZXRlIFwiaW5wdXRfc2hhcGVcIiBvciBcImJhdGNoX2lucHV0X3NoYXBlXCIgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGxheWVyIGluIHlvdXIgbW9kZWwuJyl9cmV0dXJuW2VbMF0sYXJyYXlQcm9kKGUsMSldfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBuLmludm9rZUNhbGxIb29rKGUsdCksYmF0Y2hGbGF0dGVuKGdldEV4YWN0bHlPbmVUZW5zb3IoZSkpfSl9LHQuY2xhc3NOYW1lPVwiRmxhdHRlblwiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoRmxhdHRlbik7dmFyIEFjdGl2YXRpb24kMT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLnN1cHBvcnRzTWFza2luZz0hMCxuLmFjdGl2YXRpb249Z2V0QWN0aXZhdGlvbih0LmFjdGl2YXRpb24pLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7bi5pbnZva2VDYWxsSG9vayhlLHQpO3ZhciByPWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7cmV0dXJuIG4uYWN0aXZhdGlvbi5hcHBseShyKX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17YWN0aXZhdGlvbjpzZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMuYWN0aXZhdGlvbil9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIkFjdGl2YXRpb25cIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEFjdGl2YXRpb24kMSk7dmFyIFJlcGVhdFZlY3Rvcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLm49dC5uLG4uaW5wdXRTcGVjPVt7bmRpbToyfV0sbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3JldHVybltlWzBdLHRoaXMubixlWzFdXX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gcmVwZWF0KGU9Z2V0RXhhY3RseU9uZVRlbnNvcihlKSxuLm4pfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtuOnRoaXMubn0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiUmVwZWF0VmVjdG9yXCIsdH0oTGF5ZXIpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhSZXBlYXRWZWN0b3IpO3ZhciBSZXNoYXBlPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7bi50YXJnZXRTaGFwZT10LnRhcmdldFNoYXBlO2Zvcih2YXIgcj0wO3I8bi50YXJnZXRTaGFwZS5sZW5ndGg7KytyKW4uaXNVbmtub3duKG4udGFyZ2V0U2hhcGVbcl0pJiYobi50YXJnZXRTaGFwZVtyXT1udWxsKTtyZXR1cm4gbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuaXNVbmtub3duPWZ1bmN0aW9uKGUpe3JldHVybiBlPDB8fG51bGw9PWV9LHQucHJvdG90eXBlLmZpeFVua25vd25EaW1lbnNpb249ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49XCJUb3RhbCBzaXplIG9mIG5ldyBhcnJheSBtdXN0IGJlIHVuY2hhbmdlZC5cIixyPXQuc2xpY2UoKSxpPTEsYT1udWxsLG89MDtvPHIubGVuZ3RoOysrbyl7dmFyIHM9cltvXTtpZih0aGlzLmlzVW5rbm93bihzKSl7aWYobnVsbCE9PWEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJDYW4gb25seSBzcGVjaWZpeSBvbmUgdW5rbm93biBkaW1lbnNpb24uXCIpO2E9b31lbHNlIGkqPXN9dmFyIGw9YXJyYXlQcm9kKGUpO2lmKG51bGwhPT1hKXtpZigwPT09aXx8bCVpIT0wKXRocm93IG5ldyBWYWx1ZUVycm9yKG4pO3JbYV09bC9pfWVsc2UgaWYobCE9PWkpdGhyb3cgbmV3IFZhbHVlRXJyb3Iobik7cmV0dXJuIHJ9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtmb3IodmFyIHQ9ITEsbj0wO248ZS5sZW5ndGg7KytuKWlmKHRoaXMuaXNVbmtub3duKGVbbl0pKXt0PSEwO2JyZWFrfXJldHVybiB0P2Uuc2xpY2UoMCwxKS5jb25jYXQodGhpcy50YXJnZXRTaGFwZSk6ZS5zbGljZSgwLDEpLmNvbmNhdCh0aGlzLmZpeFVua25vd25EaW1lbnNpb24oZS5zbGljZSgxKSx0aGlzLnRhcmdldFNoYXBlKSl9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7bi5pbnZva2VDYWxsSG9vayhlLHQpO3ZhciByPWdldEV4YWN0bHlPbmVUZW5zb3IoZSksaT1yLnNoYXBlLGE9aS5zbGljZSgwLDEpLmNvbmNhdChuLmZpeFVua25vd25EaW1lbnNpb24oaS5zbGljZSgxKSxuLnRhcmdldFNoYXBlKSk7cmV0dXJuIHIucmVzaGFwZShhKX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17dGFyZ2V0U2hhcGU6dGhpcy50YXJnZXRTaGFwZX0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiUmVzaGFwZVwiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoUmVzaGFwZSk7dmFyIFBlcm11dGU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztpZihudWxsPT10LmRpbXMpdGhyb3cgbmV3IEVycm9yKFwiUmVxdWlyZWQgY29uZmlndXJhdGlvbiBmaWVsZCBgZGltc2AgaXMgbWlzc2luZyBkdXJpbmcgUGVybXV0ZSBjb25zdHJ1Y3RvciBjYWxsLlwiKTtpZighQXJyYXkuaXNBcnJheSh0LmRpbXMpKXRocm93IG5ldyBFcnJvcihcIlBlcm11dGUgY29uc3RydWN0b3IgcmVxdWlyZXMgYGRpbXNgIHRvIGJlIGFuIEFycmF5LCBidXQgcmVjZWl2ZWQgXCIrdC5kaW1zK1wiIGluc3RlYWQuXCIpO3ZhciByPXJhbmdlKDEsdC5kaW1zLmxlbmd0aCsxKTtpZighdXRpbC5hcnJheXNFcXVhbCh0LmRpbXMuc2xpY2UoKS5zb3J0KCkscikpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwZXJtdXRhdGlvbiBgZGltc2A6IFwiK0pTT04uc3RyaW5naWZ5KHQuZGltcykrXCIgYGRpbXNgIG11c3QgY29udGFpbiBjb25zZWN1dGl2ZSBpbnRlZ2VycyBzdGFydGluZyBmcm9tIDEuXCIpO3JldHVybiBuLmRpbXM9dC5kaW1zLG4uZGltc0luY2x1ZGluZ0JhdGNoPVswXS5jb25jYXQobi5kaW1zKSxuLmlucHV0U3BlYz1bbmV3IElucHV0U3BlYyh7bmRpbTpuLmRpbXMubGVuZ3RoKzF9KV0sbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3ZhciB0PShlPWdldEV4YWN0bHlPbmVTaGFwZShlKSkuc2xpY2UoKTtyZXR1cm4gdGhpcy5kaW1zLmZvckVhY2goZnVuY3Rpb24obixyKXt0W3IrMV09ZVtuXX0pLHR9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHJhbnNwb3NlKGdldEV4YWN0bHlPbmVUZW5zb3IoZSksdGhpcy5kaW1zSW5jbHVkaW5nQmF0Y2gpfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17ZGltczp0aGlzLmRpbXN9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIlBlcm11dGVcIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFBlcm11dGUpO3ZhciBNYXNraW5nPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsbnVsbD09dD97fTp0KXx8dGhpcztyZXR1cm4gbi5zdXBwb3J0c01hc2tpbmc9ITAsbi5tYXNrVmFsdWU9bnVsbCE9dD9udWxsPT10Lm1hc2tWYWx1ZT8wOnQubWFza1ZhbHVlOjAsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3JldHVybiBlfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKSxuPXttYXNrVmFsdWU6dGhpcy5tYXNrVmFsdWV9O3JldHVybiBPYmplY3QuYXNzaWduKG4sdCksbn0sdC5wcm90b3R5cGUuY29tcHV0ZU1hc2s9ZnVuY3Rpb24oZSx0KXt2YXIgbj1nZXRFeGFjdGx5T25lVGVuc29yKGUpO3JldHVybiBhbnkobm90RXF1YWwobix0aGlzLm1hc2tWYWx1ZSksLTEpfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe24uaW52b2tlQ2FsbEhvb2soZSx0KTt2YXIgcj1nZXRFeGFjdGx5T25lVGVuc29yKGUpLGk9YW55KG5vdEVxdWFsKHIsbi5tYXNrVmFsdWUpLC0xLCEwKTtyZXR1cm4gci5tdWwoaS5hc1R5cGUoci5kdHlwZSkpfSl9LHQuY2xhc3NOYW1lPVwiTWFza2luZ1wiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTWFza2luZyk7dmFyIEVtYmVkZGluZz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO2lmKG4uZW1iZWRkaW5ncz1udWxsLG4uREVGQVVMVF9FTUJFRERJTkdTX0lOSVRJQUxJWkVSPVwicmFuZG9tVW5pZm9ybVwiLG51bGw9PXQuYmF0Y2hJbnB1dFNoYXBlJiZudWxsPT10LmlucHV0U2hhcGUpe3ZhciByPW51bGw7bnVsbCE9dC5iYXRjaFNpemUmJihyPXQuYmF0Y2hTaXplKSxudWxsPT10LmlucHV0TGVuZ3RoP24uYmF0Y2hJbnB1dFNoYXBlPVtyLG51bGxdOm4uYmF0Y2hJbnB1dFNoYXBlPVtyXS5jb25jYXQodG9MaXN0KHQuaW5wdXRMZW5ndGgpKX1yZXR1cm4gbi5pbnB1dERpbT10LmlucHV0RGltLGFzc2VydFBvc2l0aXZlSW50ZWdlcihuLmlucHV0RGltLFwiaW5wdXREaW1cIiksbi5vdXRwdXREaW09dC5vdXRwdXREaW0sYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKG4ub3V0cHV0RGltLFwib3V0cHV0RGltXCIpLG4uZW1iZWRkaW5nc0luaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQuZW1iZWRkaW5nc0luaXRpYWxpemVyfHxuLkRFRkFVTFRfRU1CRURESU5HU19JTklUSUFMSVpFUiksbi5lbWJlZGRpbmdzUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5lbWJlZGRpbmdzUmVndWxhcml6ZXIpLG4uYWN0aXZpdHlSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0LmFjdGl2aXR5UmVndWxhcml6ZXIpLG4uZW1iZWRkaW5nc0NvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludCh0LmVtYmVkZGluZ3NDb25zdHJhaW50KSxuLm1hc2taZXJvPXQubWFza1plcm8sbi5zdXBwb3J0c01hc2tpbmc9dC5tYXNrWmVybyxuLmlucHV0TGVuZ3RoPXQuaW5wdXRMZW5ndGgsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7dGhpcy5lbWJlZGRpbmdzPXRoaXMuYWRkV2VpZ2h0KFwiZW1iZWRkaW5nc1wiLFt0aGlzLmlucHV0RGltLHRoaXMub3V0cHV0RGltXSx0aGlzLmR0eXBlLHRoaXMuZW1iZWRkaW5nc0luaXRpYWxpemVyLHRoaXMuZW1iZWRkaW5nc1JlZ3VsYXJpemVyLCEwLHRoaXMuZW1iZWRkaW5nc0NvbnN0cmFpbnQpLHRoaXMuYnVpbHQ9ITB9LHQucHJvdG90eXBlLndhcm5PbkluY29tcGF0aWJsZUlucHV0U2hhcGU9ZnVuY3Rpb24oZSl7fSx0LnByb3RvdHlwZS5jb21wdXRlTWFzaz1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gbi5tYXNrWmVybz8oZT1nZXRFeGFjdGx5T25lVGVuc29yKGUpLG5vdEVxdWFsKGUsemVyb3NMaWtlKGUpKSk6bnVsbH0pfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7aWYoZT1nZXRFeGFjdGx5T25lU2hhcGUoZSksbnVsbD09dGhpcy5pbnB1dExlbmd0aClyZXR1cm4gZS5jb25jYXQoW3RoaXMub3V0cHV0RGltXSk7dmFyIHQ9dG9MaXN0KHRoaXMuaW5wdXRMZW5ndGgpO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgtMSl0aHJvdyBuZXcgVmFsdWVFcnJvcignXCJpbnB1dExlbmd0aFwiIGlzICcrdGhpcy5pbnB1dExlbmd0aCtcIiwgYnV0IHJlY2VpdmVkIGlucHV0IHNoYXBlIGhhcyBzaGFwZSBcIitlKTtmb3IodmFyIG49MCxyPTA7cjx0Lmxlbmd0aDsrK3Ipe3ZhciBpPXRbcl0sYT1lW3IrMV07aWYobnVsbCE9aSYmbnVsbCE9YSYmaSE9PWEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ1wiaW5wdXRMZW5ndGhcIiBpcyAnK3RoaXMuaW5wdXRMZW5ndGgrXCIsIGJ1dCByZWNlaXZlZCBpbnB1dCBzaGFwZSBoYXMgc2hhcGUgXCIrZSk7bnVsbD09aSYmKHRbbl09YSksbisrfXJldHVybltlWzBdXS5jb25jYXQodCxbdGhpcy5vdXRwdXREaW1dKX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtuLmludm9rZUNhbGxIb29rKGUsdCk7dmFyIHI9Z2V0RXhhY3RseU9uZVRlbnNvcihlKTtyZXR1cm5cImludDMyXCIhPT1yLmR0eXBlJiYocj1jYXN0JDEocixcImludDMyXCIpKSxnYXRoZXIkMShuLmVtYmVkZGluZ3MucmVhZCgpLHIuYXMxRCgpKS5yZXNoYXBlKGdldEV4YWN0bHlPbmVTaGFwZShuLmNvbXB1dGVPdXRwdXRTaGFwZShyLnNoYXBlKSkpfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtpbnB1dERpbTp0aGlzLmlucHV0RGltLG91dHB1dERpbTp0aGlzLm91dHB1dERpbSxlbWJlZGRpbmdzSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5lbWJlZGRpbmdzSW5pdGlhbGl6ZXIpLGVtYmVkZGluZ3NSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmVtYmVkZGluZ3NSZWd1bGFyaXplciksYWN0aXZpdHlSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLGVtYmVkZGluZ3NDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5lbWJlZGRpbmdzQ29uc3RyYWludCksbWFza1plcm86dGhpcy5tYXNrWmVybyxpbnB1dExlbmd0aDp0aGlzLmlucHV0TGVuZ3RofSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJFbWJlZGRpbmdcIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEVtYmVkZGluZyk7dmFyIE1lcmdlPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdHx8e30pfHx0aGlzO3JldHVybiBuLnN1cHBvcnRzTWFza2luZz0hMCxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5tZXJnZUZ1bmN0aW9uPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yfSx0LnByb3RvdHlwZS5jb21wdXRlRWxlbWVudHdpc2VPcE91dHB1dFNoYXBlPWZ1bmN0aW9uKGUsdCl7aWYobnVsbD09ZXx8bnVsbD09dClyZXR1cm4gbnVsbDtpZihlLmxlbmd0aDx0Lmxlbmd0aClyZXR1cm4gdGhpcy5jb21wdXRlRWxlbWVudHdpc2VPcE91dHB1dFNoYXBlKHQsZSk7aWYoMD09PXQubGVuZ3RoKXJldHVybiBlO2Zvcih2YXIgbj1lLnNsaWNlKDAsZS5sZW5ndGgtdC5sZW5ndGgpLHI9MDtyPHQubGVuZ3RoOysrcil7dmFyIGk9ZVtlLmxlbmd0aC10Lmxlbmd0aCtyXSxhPXRbcl07aWYobnVsbD09aXx8bnVsbD09YXx8aTwwfHxhPDApbi5wdXNoKG51bGwpO2Vsc2UgaWYoMT09PWkpbi5wdXNoKGEpO2Vsc2UgaWYoMT09PWEpbi5wdXNoKGkpO2Vsc2V7aWYoaSE9PWEpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJPcGVyYW5kcyBjb3VsZCBub3QgYmUgYnJvYWRjYXN0IHRvZ2V0aGVyIHdpdGggc2hhcGVzIFwiK0pTT04uc3RyaW5naWZ5KGUpK1wiIFwiK0pTT04uc3RyaW5naWZ5KHQpKTtuLnB1c2goaSl9fXJldHVybiBufSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpJiYhQXJyYXkuaXNBcnJheShlWzBdKSYmKGU9W2dldEV4YWN0bHlPbmVTaGFwZShlKV0pLChlPWUpLmxlbmd0aDwyKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQSBtZXJnZSBsYXllciBzaG91bGQgYmUgY2FsbGVkIG9uIGFuIEFycmF5IG9mIGF0IGxlYXN0IDIgaW5wdXRzLiBHb3QgXCIrZS5sZW5ndGgrXCIgaW5wdXQocykuXCIpO2Zvcih2YXIgdD1bXSxuPTAscj1lO248ci5sZW5ndGg7bisrKXtudWxsIT0obz1yW25dKSYmbnVsbCE9PW9bMF0mJnQucHVzaChvWzBdKX1pZigodD11bmlxdWUodCkpLmxlbmd0aD4xKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQ2FuIG5vdCBtZXJnZSB0ZW5zb3JzIHdpdGggZGlmZmVyZW50IGJhdGNoIHNpemVzLiBHb3QgdGVuc29ycyB3aXRoIHNoYXBlczogXCIrSlNPTi5zdHJpbmdpZnkoZSkrXCIuXCIpO2Zvcih2YXIgaT1udWxsPT1lWzBdP251bGw6ZVswXS5zbGljZSgxKSxhPTE7YTxlLmxlbmd0aDsrK2Epe3ZhciBvPW51bGw9PWVbYV0/bnVsbDplW2FdLnNsaWNlKDEpO2k9dGhpcy5jb21wdXRlRWxlbWVudHdpc2VPcE91dHB1dFNoYXBlKGksbyl9dmFyIHM9ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubGVuZ3RofSk7LTE9PT1lLmluZGV4T2YobnVsbCkmJjE9PT11bmlxdWUocykubGVuZ3RoP3RoaXMucmVzaGFwZVJlcXVpcmVkPSExOnRoaXMucmVzaGFwZVJlcXVpcmVkPSEwfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe2lmKGU9ZSxuLnJlc2hhcGVSZXF1aXJlZCl7dmFyIHQ9W10scj1lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5yYW5rfSk7aWYoLTE9PT1yLmluZGV4T2YobnVsbCkpe2Zvcih2YXIgaT1tYXgkMShyKSxhPTAsbz1lO2E8by5sZW5ndGg7YSsrKXtmb3IodmFyIHM9KGg9b1thXSkucmFuayxsPTA7bDxpLXM7KytsKWg9ZXhwYW5kRGltcyQxKGgsMSk7dC5wdXNoKGgpfXJldHVybiBuLm1lcmdlRnVuY3Rpb24odCl9Zm9yKHZhciB1PSExLGM9MCxwPWU7YzxwLmxlbmd0aDtjKyspe3ZhciBoO2lmKG51bGw9PShzPShoPXBbY10pLnJhbmspKXt2YXIgZD1oLnNoYXBlLGY9ZFswXSxnPWQuc2xpY2UoMSkuY29uY2F0KFtmXSksbT1oLnJlc2hhcGUoW2ZdLmNvbmNhdChhcnJheVByb2QoZC5zbGljZSgxKSkpKTttPShtPXRyYW5zcG9zZShtLFsxLDBdKSkucmVzaGFwZShnKSx0LnB1c2gobSksdT0hMH1lbHNlIGlmKHM+MSl7dmFyIHk9cmFuZ2UoMSxzKS5jb25jYXQoWzBdKTt0LnB1c2godHJhbnNwb3NlKGgseSkpLHU9ITB9ZWxzZSB0LnB1c2goaCl9dmFyIHY9bi5tZXJnZUZ1bmN0aW9uKHQpLGI9di5yYW5rO2lmKHUpaWYobnVsbD09Yil7dmFyIHc9di5zaGFwZTtnPVtmPXdbdy5sZW5ndGgtMV1dLmNvbmNhdCh3LnNsaWNlKDAsdy5sZW5ndGgtMSkpO3Y9dHJhbnNwb3NlKHYucmVzaGFwZShbLTEsZl0pLFsxLDBdKS5yZXNoYXBlKGcpfWVsc2UgaWYoYj4xKXt5PVtiLTFdLmNvbmNhdChyYW5nZSgwLGItMSkpO3Y9dHJhbnNwb3NlKHYseSl9cmV0dXJuIHZ9cmV0dXJuIG4ubWVyZ2VGdW5jdGlvbihlKX0pfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7dmFyIHQ7dD1udWxsPT0oZT1lKVswXT9udWxsOmVbMF0uc2xpY2UoMSk7Zm9yKHZhciBuPTE7bjxlLmxlbmd0aDsrK24pe3ZhciByPW51bGw9PWVbbl0/bnVsbDplW25dLnNsaWNlKDEpO3Q9dGhpcy5jb21wdXRlRWxlbWVudHdpc2VPcE91dHB1dFNoYXBlKHQscil9Zm9yKHZhciBpPVtdLGE9MCxvPWU7YTxvLmxlbmd0aDthKyspe251bGwhPShyPW9bYV0pJiZudWxsIT09clswXSYmaS5wdXNoKHJbMF0pfXJldHVybiB0PTE9PT0oaT11bmlxdWUoaSkpLmxlbmd0aD9pLmNvbmNhdCh0KTpbbnVsbF0uY29uY2F0KHQpfSx0LnByb3RvdHlwZS5jb21wdXRlTWFzaz1mdW5jdGlvbihlLHQpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7aWYobnVsbD09dClyZXR1cm4gbnVsbDtpZighQXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImBtYXNrYCBzaG91bGQgYmUgYW4gQXJyYXlcIik7aWYoIUFycmF5LmlzQXJyYXkoZSkpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJgaW5wdXRzYCBzaG91bGQgYmUgYW4gQXJyYXlcIik7aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBBcnJheSAnaW5wdXRzJyBhbmQgJ21hc2snIGFyZSBleHBlY3RlZCB0byBoYXZlIHRoZSBzYW1lIGxlbmd0aCwgYnV0IGhhdmUgZGlmZmVyZW50IGxlbmd0aHMgKFwiK2UubGVuZ3RoK1wiIHZzIFwiK3QubGVuZ3RoK1wiKVwiKTtpZih0LmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lfSkpcmV0dXJuIG51bGw7Zm9yKHZhciBuPSh0PXQubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lP2U6ZXhwYW5kRGltcyhlLDApfSkpWzBdLHI9MTtyPHQubGVuZ3RoLTE7KytyKW49bG9naWNhbEFuZChuLHRbcl0pO3JldHVybiBufSl9LHR9KExheWVyKSxBZGQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMsdCl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLm1lcmdlRnVuY3Rpb249ZnVuY3Rpb24oZSl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtmb3IodmFyIHQ9ZVswXS5jbG9uZSgpLG49MTtuPGUubGVuZ3RoOysrbil0PWFkZCh0LGVbbl0pO3JldHVybiB0fSl9LHQuY2xhc3NOYW1lPVwiQWRkXCIsdH0oTWVyZ2UpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhBZGQpO3ZhciBNdWx0aXBseT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcyx0KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUubWVyZ2VGdW5jdGlvbj1mdW5jdGlvbihlKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe2Zvcih2YXIgdD1lWzBdLmNsb25lKCksbj0xO248ZS5sZW5ndGg7KytuKXQ9bXVsKHQsZVtuXSk7cmV0dXJuIHR9KX0sdC5jbGFzc05hbWU9XCJNdWx0aXBseVwiLHR9KE1lcmdlKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTXVsdGlwbHkpO3ZhciBBdmVyYWdlPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLHQpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5tZXJnZUZ1bmN0aW9uPWZ1bmN0aW9uKGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7Zm9yKHZhciB0PWVbMF0uY2xvbmUoKSxuPTE7bjxlLmxlbmd0aDsrK24pdD1hZGQodCxlW25dKTtyZXR1cm4gbXVsKDEvZS5sZW5ndGgsdCl9KX0sdC5jbGFzc05hbWU9XCJBdmVyYWdlXCIsdH0oTWVyZ2UpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhBdmVyYWdlKTt2YXIgTWF4aW11bT1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcyx0KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUubWVyZ2VGdW5jdGlvbj1mdW5jdGlvbihlKXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe2Zvcih2YXIgdD1lWzBdLG49MTtuPGUubGVuZ3RoOysrbil0PW1heGltdW0odCxlW25dKTtyZXR1cm4gdH0pfSx0LmNsYXNzTmFtZT1cIk1heGltdW1cIix0fShNZXJnZSk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE1heGltdW0pO3ZhciBNaW5pbXVtPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGUuY2FsbCh0aGlzLHQpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5tZXJnZUZ1bmN0aW9uPWZ1bmN0aW9uKGUpe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7Zm9yKHZhciB0PWVbMF0sbj0xO248ZS5sZW5ndGg7KytuKXQ9bWluaW11bSh0LGVbbl0pO3JldHVybiB0fSl9LHQuY2xhc3NOYW1lPVwiTWluaW11bVwiLHR9KE1lcmdlKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTWluaW11bSk7dmFyIENvbmNhdGVuYXRlPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIG4uREVGQVVMVF9BWElTPS0xLG51bGw9PXQmJih0PXt9KSxuLmF4aXM9bnVsbD09dC5heGlzP24uREVGQVVMVF9BWElTOnQuYXhpcyxuLnN1cHBvcnRzTWFza2luZz0hMCxuLnJlc2hhcGVSZXF1aXJlZD0hMSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXtpZighQXJyYXkuaXNBcnJheShlKXx8IUFycmF5LmlzQXJyYXkoZVswXSl8fDE9PT1lLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkEgYENvbmNhdGVuYXRlYCBsYXllciBzaG91bGQgYmUgY2FsbGVkIG9uIGEgbGlzdCBvZiBhdCBsZWFzdCAyIGlucHV0c1wiKTtmb3IodmFyIHQ9ITAsbj0wLHI9ZT1lO248ci5sZW5ndGg7bisrKXtpZihudWxsIT0oYz1yW25dKSl7dD0hMTticmVha319aWYoIXQpe2Zvcih2YXIgaT1bXSxhPTA7YTxlLmxlbmd0aDsrK2Epe3ZhciBvPWVbYV0uc2xpY2UoKTtvLnNwbGljZSh0aGlzLmF4aXMsMSk7Zm9yKHZhciBzPSExLGw9MCx1PWk7bDx1Lmxlbmd0aDtsKyspe3ZhciBjPXVbbF07aWYodXRpbC5hcnJheXNFcXVhbChjLG8pKXtzPSEwO2JyZWFrfX1zfHxpLnB1c2gobyl9aWYoaS5sZW5ndGg+MSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkEgYENvbmNhdGVuYXRlYCBsYXllciByZXF1aXJlcyBpbnB1dHMgd2l0aCBtYXRjaGluZyBzaGFwZXMgZXhjZXB0IGZvciB0aGUgY29uY2F0IGF4aXMuIEdvdCBpbnB1dCBzaGFwZXM6IFwiK0pTT04uc3RyaW5naWZ5KGUpKX19LHQucHJvdG90eXBlLm1lcmdlRnVuY3Rpb249ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBjb25jYXRlbmF0ZShlLHQuYXhpcyl9KX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe2lmKCFBcnJheS5pc0FycmF5KGUpfHwhQXJyYXkuaXNBcnJheShlWzBdKSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIkEgYENvbmNhdGVuYXRlYCBsYXllciBzaG91bGQgYmUgY2FsbGVkIG9uIGEgbGlzdCBvZiBpbnB1dHMuXCIpO2Zvcih2YXIgdD1lLG49dFswXS5zbGljZSgpLHI9dGhpcy5heGlzPDA/bi5sZW5ndGgrdGhpcy5heGlzOnRoaXMuYXhpcyxpPTAsYT10LnNsaWNlKDEpO2k8YS5sZW5ndGg7aSsrKXt2YXIgbz1hW2ldO2lmKG51bGw9PW5bcl18fG51bGw9PW9bcl0pe25bcl09bnVsbDticmVha31uW3JdKz1vW3JdfXJldHVybiBufSx0LnByb3RvdHlwZS5jb21wdXRlTWFzaz1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7aWYobnVsbD09dClyZXR1cm4gbnVsbDtpZighQXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcImBtYXNrYCBzaG91bGQgYmUgYW4gYXJyYXkgZm9yIENvbmNhdGVuYXRlXCIpO2lmKCFBcnJheS5pc0FycmF5KGUpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiYGlucHV0c2Agc2hvdWxkIGJlIGFuIGFycmF5IGZvciBDb25jYXRlbmF0ZVwiKTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiTWlzbWF0Y2ggaW4gdGhlIGxlbmd0aCBvZiBtYXNrIChcIit0Lmxlbmd0aCtcIikgYW5kIHRoZSBsZWdudGggb2YgaW5wdXRzIChcIitlLmxlbmd0aCtcIilcIik7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgcj0hMDtpZih0LmZvckVhY2goZnVuY3Rpb24oZSl7bnVsbD09ZXx8KHI9ITEpfSkscilyZXR1cm4gbnVsbDtmb3IodmFyIGk9W10sYT0wO2E8ZS5sZW5ndGg7KythKW51bGw9PXRbYV0/aS5wdXNoKG9uZXNMaWtlKGVbYV0pLmFzVHlwZShcImJvb2xcIikpOnRbYV0ucmFuazxlW2FdLnJhbms/aS5wdXNoKGV4cGFuZERpbXModFthXSwtMSkpOmkucHVzaCh0W2FdKTt2YXIgbz1jb25jYXQoaSxuLmF4aXMpO3JldHVybiBhbGwobywtMSwhMSl9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2F4aXM6dGhpcy5heGlzfSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJDb25jYXRlbmF0ZVwiLHR9KE1lcmdlKTtmdW5jdGlvbiBpbnRlcnByZXRBeGlzKGUsdCl7Zm9yKDtlPDA7KWUrPXQ7cmV0dXJuIGV9ZnVuY3Rpb24gYmF0Y2hEb3QoZSx0LG4pe2lmKGUuc2hhcGUubGVuZ3RoPjN8fHQuc2hhcGUubGVuZ3RoPjMpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJiYXRjaERvdCBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIHRlbnNvcnMgb2YgNEQgb3IgaGlnaGVyIHJhbmsgeWV0XCIpO2lmKHV0aWwuYXNzZXJ0KGUuc2hhcGUubGVuZ3RoPj0yLGZ1bmN0aW9uKCl7cmV0dXJuXCJiYXRjaERvdCByZXF1aXJlcyB0aGUgcmFuayBvZiB4IHRvIGJlID49IDIsIGJ1dCBnb3QgXCIrZS5zaGFwZS5sZW5ndGh9KSx1dGlsLmFzc2VydChlLnNoYXBlLmxlbmd0aD49MixmdW5jdGlvbigpe3JldHVyblwiYmF0Y2hEb3QgcmVxdWlyZXMgdGhlIHJhbmsgb2YgeSB0byBiZSA+PSAyLCBidXQgZ290IFwiK3Quc2hhcGUubGVuZ3RofSksXCJudW1iZXJcIj09dHlwZW9mIG4mJihuPVtuLG5dKSxcImNvbXBsZXg2NFwiPT09ZS5kdHlwZXx8XCJjb21wbGV4NjRcIj09PXQuZHR5cGUpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJiYXRjaERvdCBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIGNvbXBsZXg2NC10eXBlIFRlbnNvcnMgeWV0LlwiKTt2YXIgcj1lLnNoYXBlLmxlbmd0aCxpPXQuc2hhcGUubGVuZ3RoO251bGw9PW4mJihuPVtyLTEsaS0yXSk7dmFyIGE9bjtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciBuLG87aWYocj5pKXtuPXItaTtmb3IodmFyIHM9W10sbD0wO2w8bjsrK2wpcy5wdXNoKDEpO3Q9dC5yZXNoYXBlKHQuc2hhcGUuY29uY2F0KHMpKX1lbHNlIGlmKGk+cil7bj1pLXI7Zm9yKHM9W10sbD0wO2w8bjsrK2wpcy5wdXNoKDEpO2U9ZS5yZXNoYXBlKGUuc2hhcGUuY29uY2F0KHMpKX1lbHNlIG49MDtpZigyPT09ZS5zaGFwZS5sZW5ndGgmJjI9PT10LnNoYXBlLmxlbmd0aClvPWFbMF09PT1hWzFdP2UubXVsU3RyaWN0KHQpLnN1bShhWzBdKTplLnRyYW5zcG9zZShbMSwwXSkubXVsU3RyaWN0KHQpLnN1bShhWzFdKTtlbHNle3ZhciB1PWFbMF0hPT1lLnNoYXBlLmxlbmd0aC0xLGM9YVsxXT09PXQuc2hhcGUubGVuZ3RoLTE7bz1lLm1hdE11bCh0LHUsYyl9aWYobj4wKXt2YXIgcD12b2lkIDAsaD1bXTtmb3IobD1wPXI+aT9yK2ktMzpyLTE7bDxwK247KytsKWgucHVzaChsKTtvPW8uc3F1ZWV6ZShoKX1yZXR1cm4gMT09PW8uc2hhcGUubGVuZ3RoJiYobz1vLmV4cGFuZERpbXMoMSkpLG99KX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQ29uY2F0ZW5hdGUpO3ZhciBEb3Q9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5heGVzPXQuYXhlcyxuLm5vcm1hbGl6ZT1udWxsIT10Lm5vcm1hbGl6ZSYmdC5ub3JtYWxpemUsbi5zdXBwb3J0c01hc2tpbmc9ITAsbi5yZXNoYXBlUmVxdWlyZWQ9ITEsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7dXRpbC5hc3NlcnQoQXJyYXkuaXNBcnJheShlKSYmMj09PWUubGVuZ3RoJiZBcnJheS5pc0FycmF5KGVbMF0pJiZBcnJheS5pc0FycmF5KGVbMV0pLGZ1bmN0aW9uKCl7cmV0dXJuXCJBIGBEb3RgIGxheWVyIHNob3VsZCBiZSBjYWxsZWQgb24gYSBsaXN0IG9mIGV4YWN0bHkgMiBpbnB1dHMuXCJ9KTt2YXIgdD1lWzBdLG49ZVsxXTtpZih0Lmxlbmd0aD4zfHxuLmxlbmd0aD4zKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiRG90IGxheWVyIGRvZXMgbm90IHN1cHBvcnQgdGVuc29ycyBvZiA0RCBvciBoaWdoZXIgcmFuayB5ZXQuXCIpO3ZhciByPXRoaXMuaW50ZXJwcmV0QXhlcyh0LG4pO2lmKHRbclswXV0hPT1uW3JbMV1dKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiRGltZW5zaW9uIGluY29tcGF0aWJpbGl0eTogXCIrdFtyWzBdXStcIiAhPT0gXCIrbltyWzFdXSl9LHQucHJvdG90eXBlLm1lcmdlRnVuY3Rpb249ZnVuY3Rpb24oZSl7aWYoMiE9PWUubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiQSBgRG90YCBsYXllciBtdXN0IGJlIGNhbGxlZCBvbiBleGFjdGx5IDIgaW5wdXRzLCBidXQgcmVjZWl2ZWQgXCIrZS5sZW5ndGgrXCIgaW5wdXQocykuXCIpO3ZhciB0LG49ZVswXSxyPWVbMV07cmV0dXJuIHQ9QXJyYXkuaXNBcnJheSh0aGlzLmF4ZXMpP3RoaXMuYXhlcy5tYXAoZnVuY3Rpb24odCxuKXtyZXR1cm4gaW50ZXJwcmV0QXhpcyh0LGVbbl0uc2hhcGUubGVuZ3RoKX0pOltpbnRlcnByZXRBeGlzKHRoaXMuYXhlcyxuLnNoYXBlLmxlbmd0aCksaW50ZXJwcmV0QXhpcyh0aGlzLmF4ZXMsci5zaGFwZS5sZW5ndGgpXSx0aGlzLm5vcm1hbGl6ZSYmKG49bDJOb3JtYWxpemUobix0WzBdKSxyPWwyTm9ybWFsaXplKHIsdFsxXSkpLGJhdGNoRG90KG4scix0KX0sdC5wcm90b3R5cGUuaW50ZXJwcmV0QXhlcz1mdW5jdGlvbihlLHQpe3JldHVybiBBcnJheS5pc0FycmF5KHRoaXMuYXhlcyk/dGhpcy5heGVzOltpbnRlcnByZXRBeGlzKHRoaXMuYXhlcyxlLmxlbmd0aCksaW50ZXJwcmV0QXhpcyh0aGlzLmF4ZXMsdC5sZW5ndGgpXX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3V0aWwuYXNzZXJ0KEFycmF5LmlzQXJyYXkoZSkmJjI9PT1lLmxlbmd0aCYmQXJyYXkuaXNBcnJheShlWzBdKSYmQXJyYXkuaXNBcnJheShlWzFdKSxmdW5jdGlvbigpe3JldHVyblwiQSBgRG90YCBsYXllciBzaG91bGQgYmUgY2FsbGVkIG9uIGEgbGlzdCBvZiBleGFjdGx5IDIgaW5wdXRzLlwifSk7dmFyIHQ9ZVswXS5zbGljZSgpLG49ZVsxXS5zbGljZSgpO2lmKHQubGVuZ3RoPjN8fG4ubGVuZ3RoPjMpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJEb3QgbGF5ZXIgZG9lcyBub3Qgc3VwcG9ydCB0ZW5zb3JzIG9mIDREIG9yIGhpZ2hlciByYW5rIHlldC5cIik7dmFyIHI9dGhpcy5pbnRlcnByZXRBeGVzKHQsbik7dC5zcGxpY2UoclswXSwxKSxuLnNwbGljZShyWzFdLDEpLG4uc3BsaWNlKDAsMSk7dmFyIGk9dC5jb25jYXQobik7cmV0dXJuIDE9PT1pLmxlbmd0aCYmaS5wdXNoKDEpLGl9LHQucHJvdG90eXBlLmNvbXB1dGVNYXNrPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG51bGx9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtheGVzOnRoaXMuYXhlcyxub3JtYWxpemU6dGhpcy5ub3JtYWxpemV9LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIkRvdFwiLHR9KE1lcmdlKTtmdW5jdGlvbiBiYXRjaE5vcm1hbGl6YXRpb24oZSx0LG4scixpLGEpe3ZhciBvO2lmKHZvaWQgMD09PWEmJihhPS4wMDEpLDI9PT1lLnJhbmspbz1iYXRjaE5vcm0yZChlLHQsbixyLGksYSk7ZWxzZSBpZigzPT09ZS5yYW5rKW89YmF0Y2hOb3JtM2QoZSx0LG4scixpLGEpO2Vsc2V7aWYoNCE9PWUucmFuayl0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcImJhdGNoTm9ybWFsaXphdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIGFycmF5IG9mIHJhbmsgXCIrZS5yYW5rK1wiIHlldFwiKTtvPWJhdGNoTm9ybTRkKGUsdCxuLHIsaSxhKX1yZXR1cm4gb31mdW5jdGlvbiByZWd1bGFyTm9ybWFsaXplQmF0Y2hJblRyYWluaW5nKGUsdCxuLHIsaSl7cmV0dXJuIHZvaWQgMD09PWkmJihpPS4wMDEpLHRpZHkoZnVuY3Rpb24oKXt2YXIgYT1tb21lbnRzKGUsciksbz1hLm1lYW4scz1hLnZhcmlhbmNlO3JldHVybltiYXRjaE5vcm1hbGl6YXRpb24oZSxvLHMsbix0LGkpLG8sc119KX1mdW5jdGlvbiBicm9hZGNhc3ROb3JtYWxpemVCYXRjaEluVHJhaW5pbmcoZSx0LG4scixpKXtyZXR1cm4gdm9pZCAwPT09aSYmKGk9LjAwMSksdGlkeShmdW5jdGlvbigpe2Zvcih2YXIgYT1tb21lbnRzKGUsciksbz1hLm1lYW4scz1hLnZhcmlhbmNlLGw9W10sdT0wLGM9cmFuZ2UoMCxlLnJhbmspO3U8Yy5sZW5ndGg7dSsrKXt2YXIgcD1jW3VdOy0xIT09ci5pbmRleE9mKHApP2wucHVzaCgxKTpsLnB1c2goZS5zaGFwZVtwXSl9dmFyIGg9by5yZXNoYXBlKGwpLGQ9cy5yZXNoYXBlKGwpLGY9bnVsbD09dD9udWxsOnQucmVzaGFwZShsKSxnPW51bGw9PW4/bnVsbDpuLnJlc2hhcGUobCk7cmV0dXJuW2JhdGNoTm9ybWFsaXphdGlvbihlLGgsZCxnLGYsaSksbyxzXX0pfWZ1bmN0aW9uIG5vcm1hbGl6ZUJhdGNoSW5UcmFpbmluZyhlLHQsbixyLGkpe3JldHVybiB2b2lkIDA9PT1pJiYoaT0uMDAxKSx1dGlsLmFycmF5c0VxdWFsKHIuc2xpY2UoKS5zb3J0KCkscmFuZ2UoMCxlLnJhbmstMSkpP3JlZ3VsYXJOb3JtYWxpemVCYXRjaEluVHJhaW5pbmcoZSx0LG4scixpKTpicm9hZGNhc3ROb3JtYWxpemVCYXRjaEluVHJhaW5pbmcoZSx0LG4scixpKX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoRG90KTt2YXIgQmF0Y2hOb3JtYWxpemF0aW9uPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49dGhpcztyZXR1cm4gbnVsbD09dCYmKHQ9e30pLChuPWUuY2FsbCh0aGlzLHQpfHx0aGlzKS5zdXBwb3J0c01hc2tpbmc9ITAsbi5heGlzPW51bGw9PXQuYXhpcz8tMTp0LmF4aXMsbi5tb21lbnR1bT1udWxsPT10Lm1vbWVudHVtPy45OTp0Lm1vbWVudHVtLG4uZXBzaWxvbj1udWxsPT10LmVwc2lsb24/LjAwMTp0LmVwc2lsb24sbi5jZW50ZXI9bnVsbD09dC5jZW50ZXJ8fHQuY2VudGVyLG4uc2NhbGU9bnVsbD09dC5zY2FsZXx8dC5zY2FsZSxuLmJldGFJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcih0LmJldGFJbml0aWFsaXplcnx8XCJ6ZXJvc1wiKSxuLmdhbW1hSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5nYW1tYUluaXRpYWxpemVyfHxcIm9uZXNcIiksbi5tb3ZpbmdNZWFuSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5tb3ZpbmdNZWFuSW5pdGlhbGl6ZXJ8fFwiemVyb3NcIiksbi5tb3ZpbmdWYXJpYW5jZUluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQubW92aW5nVmFyaWFuY2VJbml0aWFsaXplcnx8XCJvbmVzXCIpLG4uYmV0YUNvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludCh0LmJldGFDb25zdHJhaW50KSxuLmdhbW1hQ29uc3RyYWludD1nZXRDb25zdHJhaW50KHQuZ2FtbWFDb25zdHJhaW50KSxuLmJldGFSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0LmJldGFSZWd1bGFyaXplciksbi5nYW1tYVJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQuZ2FtbWFSZWd1bGFyaXplciksbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7dmFyIHQ7ZT1nZXRFeGFjdGx5T25lU2hhcGUoZSk7dmFyIG49dGhpcy5heGlzPj0wP3RoaXMuYXhpczp0aGlzLmF4aXMrZS5sZW5ndGgscj1lW25dO2lmKG51bGw9PXIpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBeGlzIFwiK24rXCIgb2YgaW5wdXQgdGVuc29yIHNob3VsZCBoYXZlIGEgZGVmaW5lZCBkaW1lbnNpb24gYnV0IHRoZSBsYXllciByZWNlaXZlZCBhbiBpbnB1dCB3aXRoIHNoYXBlIFwiK0pTT04uc3RyaW5naWZ5KGUpK1wiLlwiKTt0aGlzLmlucHV0U3BlYz1bbmV3IElucHV0U3BlYyh7bmRpbTplLmxlbmd0aCxheGVzOih0PXt9LHRbbl09cix0KX0pXTt2YXIgaT1bcl07dGhpcy5zY2FsZSYmKHRoaXMuZ2FtbWE9dGhpcy5hZGRXZWlnaHQoXCJnYW1tYVwiLGksbnVsbCx0aGlzLmdhbW1hSW5pdGlhbGl6ZXIsdGhpcy5nYW1tYVJlZ3VsYXJpemVyLCEwLHRoaXMuZ2FtbWFDb25zdHJhaW50KSksdGhpcy5jZW50ZXImJih0aGlzLmJldGE9dGhpcy5hZGRXZWlnaHQoXCJiZXRhXCIsaSxudWxsLHRoaXMuYmV0YUluaXRpYWxpemVyLHRoaXMuYmV0YVJlZ3VsYXJpemVyLCEwLHRoaXMuYmV0YUNvbnN0cmFpbnQpKSx0aGlzLm1vdmluZ01lYW49dGhpcy5hZGRXZWlnaHQoXCJtb3ZpbmdfbWVhblwiLGksbnVsbCx0aGlzLm1vdmluZ01lYW5Jbml0aWFsaXplcixudWxsLCExKSx0aGlzLm1vdmluZ1ZhcmlhbmNlPXRoaXMuYWRkV2VpZ2h0KFwibW92aW5nX3ZhcmlhbmNlXCIsaSxudWxsLHRoaXMubW92aW5nVmFyaWFuY2VJbml0aWFsaXplcixudWxsLCExKSx0aGlzLmJ1aWx0PSEwfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciByPW51bGwhPXQudHJhaW5pbmcmJnQudHJhaW5pbmcsaT1nZXRFeGFjdGx5T25lVGVuc29yKGUpLGE9aS5zaGFwZSxvPWEubGVuZ3RoLHM9cmFuZ2UoMCxvKSxsPW4uYXhpcz49MD9uLmF4aXM6bi5heGlzK287cy5zcGxpY2UobCwxKTt2YXIgdT1weUxpc3RSZXBlYXQoMSxvKTt1W2xdPWFbbF07dmFyIGM9cy5zbGljZSgpO2Muc29ydCgpO3ZhciBwPSF1dGlsLmFycmF5c0VxdWFsKGMscmFuZ2UoMCxvKS5zbGljZSgwLG8tMSkpO2lmKCFyKXJldHVybiBmdW5jdGlvbigpe2lmKHApe3ZhciBlPW4ubW92aW5nTWVhbi5yZWFkKCkucmVzaGFwZSh1KSx0PW4ubW92aW5nVmFyaWFuY2UucmVhZCgpLnJlc2hhcGUodSkscj1uLmNlbnRlcj9uLmJldGEucmVhZCgpLnJlc2hhcGUodSk6bnVsbCxhPW4uc2NhbGU/bi5nYW1tYS5yZWFkKCkucmVzaGFwZSh1KTpudWxsO3JldHVybiBiYXRjaE5vcm1hbGl6YXRpb24oaSxlLHQscixhLG4uZXBzaWxvbil9cmV0dXJuIGJhdGNoTm9ybWFsaXphdGlvbihpLG4ubW92aW5nTWVhbi5yZWFkKCksbi5tb3ZpbmdWYXJpYW5jZS5yZWFkKCksbnVsbD09bi5iZXRhP251bGw6bi5iZXRhLnJlYWQoKSxudWxsPT1uLmdhbW1hP251bGw6bi5nYW1tYS5yZWFkKCksbi5lcHNpbG9uKX0oKTt2YXIgaD1ub3JtYWxpemVCYXRjaEluVHJhaW5pbmcoaSxuLmdhbW1hLnJlYWQoKSxuLmJldGEucmVhZCgpLHMsbi5lcHNpbG9uKSxkPWhbMF0sZj1oWzFdLGc9aFsyXSxtPWZ1bmN0aW9uKGUsdCxuKXt0aWR5KGZ1bmN0aW9uKCl7dmFyIHI9MS1uLGk9ZS5yZWFkKCksYT1pLnN1Yih0KS5tdWwocik7ZS53cml0ZShpLnN1YihhKSl9KX07cmV0dXJuIG0obi5tb3ZpbmdNZWFuLGYsbi5tb21lbnR1bSksbShuLm1vdmluZ1ZhcmlhbmNlLGcsbi5tb21lbnR1bSksZH0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17YXhpczp0aGlzLmF4aXMsbW9tZW50dW06dGhpcy5tb21lbnR1bSxlcHNpbG9uOnRoaXMuZXBzaWxvbixjZW50ZXI6dGhpcy5jZW50ZXIsc2NhbGU6dGhpcy5zY2FsZSxiZXRhSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iZXRhSW5pdGlhbGl6ZXIpLGdhbW1hSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5nYW1tYUluaXRpYWxpemVyKSxtb3ZpbmdNZWFuSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5tb3ZpbmdNZWFuSW5pdGlhbGl6ZXIpLG1vdmluZ1ZhcmlhbmNlSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5tb3ZpbmdWYXJpYW5jZUluaXRpYWxpemVyKSxiZXRhUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5iZXRhUmVndWxhcml6ZXIpLGdhbW1hUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5nYW1tYVJlZ3VsYXJpemVyKSxiZXRhQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMuYmV0YUNvbnN0cmFpbnQpLGdhbW1hQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMuZ2FtbWFDb25zdHJhaW50KX0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiQmF0Y2hOb3JtYWxpemF0aW9uXCIsdH0oTGF5ZXIpO2Z1bmN0aW9uIHNwYXRpYWwyZFBhZGRpbmcoZSx0LG4pe3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7aWYoNCE9PWUucmFuayl0aHJvdyBuZXcgVmFsdWVFcnJvcihcInRlbXBvcmFsUGFkZGluZyBleHBlY3RzIGlucHV0IHRlbnNvciB0byBiZSA0LUQsIGJ1dCByZWNlaXZlZCBhIFwiK2UucmFuaytcIi1EIHRlbnNvci5cIik7aWYobnVsbD09dCYmKHQ9W1sxLDFdLFsxLDFdXSksMiE9PXQubGVuZ3RofHwyIT09dFswXS5sZW5ndGh8fDIhPT10WzFdLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcInNwYXRpYWwyZFBhZGRpbmcgZXhwZWN0cyBgcGFkZGluZ2AgdG8gYmUgYW4gQXJyYXkgb2YgdHdvIEFycmF5cywgZWFjaCBvZiB3aGljaCBpcyBhbiBBcnJheSBvZiB0d28gaW50ZWdlcnMuXCIpO2lmKG51bGw9PW4mJihuPWltYWdlRGF0YUZvcm1hdCgpKSxcImNoYW5uZWxzTGFzdFwiIT09biYmXCJjaGFubmVsc0ZpcnN0XCIhPT1uKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVW5rbm93biBkYXRhIGZvcm1hdDogXCIrbitcIi4gU3VwcG9ydGVkIGRhdGEgZm9ybWF0cyBhcmUgJ2NoYW5uZWxzTGFzdCcgYW5kICdjaGFubmVsc0ZpcnN0LlwiKTt2YXIgcjtyZXR1cm4gcj1cImNoYW5uZWxzRmlyc3RcIj09PW4/W1swLDBdLFswLDBdLHRbMF0sdFsxXV06W1swLDBdLHRbMF0sdFsxXSxbMCwwXV0scGFkKGUscil9KX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQmF0Y2hOb3JtYWxpemF0aW9uKTt2YXIgWmVyb1BhZGRpbmcyRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPXRoaXM7aWYobnVsbD09dCYmKHQ9e30pLChuPWUuY2FsbCh0aGlzLHQpfHx0aGlzKS5kYXRhRm9ybWF0PW51bGw9PXQuZGF0YUZvcm1hdD9pbWFnZURhdGFGb3JtYXQoKTp0LmRhdGFGb3JtYXQsbnVsbD09dC5wYWRkaW5nKW4ucGFkZGluZz1bWzEsMV0sWzEsMV1dO2Vsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIHQucGFkZGluZyluLnBhZGRpbmc9W1t0LnBhZGRpbmcsdC5wYWRkaW5nXSxbdC5wYWRkaW5nLHQucGFkZGluZ11dO2Vsc2V7aWYodC5wYWRkaW5nPXQucGFkZGluZywyIT09dC5wYWRkaW5nLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlplcm9QYWRkaW5nMkQgZXhwZWN0cyBwYWRkaW5nIHRvIGJlIGEgbGVuZ3RoLTIgYXJyYXksIGJ1dCByZWNlaXZlZCBhIGxlbmd0aC1cIit0LnBhZGRpbmcubGVuZ3RoK1wiIGFycmF5LlwiKTt2YXIgcj12b2lkIDAsaT12b2lkIDA7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQucGFkZGluZ1swXSlyPVt0LnBhZGRpbmdbMF0sdC5wYWRkaW5nWzBdXSxpPVt0LnBhZGRpbmdbMV0sdC5wYWRkaW5nWzFdXTtlbHNle2lmKHQucGFkZGluZz10LnBhZGRpbmcsMiE9PXQucGFkZGluZ1swXS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJaZXJvUGFkZGluZzJEIGV4cGVjdHMgaGVpZ2h0IHBhZGRpbmcgdG8gYmUgYSBsZW5ndGgtMiBhcnJheSwgYnV0IHJlY2VpdmVkIGEgbGVuZ3RoLVwiK3QucGFkZGluZ1swXS5sZW5ndGgrXCIgYXJyYXkuXCIpO2lmKHI9dC5wYWRkaW5nWzBdLDIhPT10LnBhZGRpbmdbMV0ubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiWmVyb1BhZGRpbmcyRCBleHBlY3RzIHdpZHRoIHBhZGRpbmcgdG8gYmUgYSBsZW5ndGgtMiBhcnJheSwgYnV0IHJlY2VpdmVkIGEgbGVuZ3RoLVwiK3QucGFkZGluZ1sxXS5sZW5ndGgrXCIgYXJyYXkuXCIpO2k9dC5wYWRkaW5nWzFdfW4ucGFkZGluZz1bcixpXX1yZXR1cm4gbi5pbnB1dFNwZWM9W25ldyBJbnB1dFNwZWMoe25kaW06NH0pXSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7dmFyIHQsbjtyZXR1cm4gZT1nZXRFeGFjdGx5T25lU2hhcGUoZSksXCJjaGFubmVsc0ZpcnN0XCI9PT10aGlzLmRhdGFGb3JtYXQ/KHQ9bnVsbCE9ZVsyXSYmZVsyXT49MD9lWzJdK3RoaXMucGFkZGluZ1swXVswXSt0aGlzLnBhZGRpbmdbMF1bMV06bnVsbCxuPW51bGwhPWVbM10mJmVbM10+PTA/ZVszXSt0aGlzLnBhZGRpbmdbMV1bMF0rdGhpcy5wYWRkaW5nWzFdWzFdOm51bGwsW2VbMF0sZVsxXSx0LG5dKToodD1udWxsIT1lWzFdJiZlWzFdPj0wP2VbMV0rdGhpcy5wYWRkaW5nWzBdWzBdK3RoaXMucGFkZGluZ1swXVsxXTpudWxsLG49bnVsbCE9ZVsyXSYmZVsyXT49MD9lWzJdK3RoaXMucGFkZGluZ1sxXVswXSt0aGlzLnBhZGRpbmdbMV1bMV06bnVsbCxbZVswXSx0LG4sZVszXV0pfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBzcGF0aWFsMmRQYWRkaW5nKGdldEV4YWN0bHlPbmVUZW5zb3IoZSksbi5wYWRkaW5nLG4uZGF0YUZvcm1hdCl9KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e3BhZGRpbmc6dGhpcy5wYWRkaW5nLGRhdGFGb3JtYXQ6dGhpcy5kYXRhRm9ybWF0fSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJaZXJvUGFkZGluZzJEXCIsdH0oTGF5ZXIpO2Z1bmN0aW9uIHBvb2wyZChlLHQsbixyLGksYSl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgbztjaGVja0RhdGFGb3JtYXQoaSksY2hlY2tQb29sTW9kZShhKSxjaGVja1BhZGRpbmdNb2RlKHIpLG51bGw9PW4mJihuPVsxLDFdKSxudWxsPT1yJiYocj1cInZhbGlkXCIpLG51bGw9PWkmJihpPWltYWdlRGF0YUZvcm1hdCgpKSxudWxsPT1hJiYoYT1cIm1heFwiKSxlPXByZXByb2Nlc3NDb252MkRJbnB1dChlLGkpO3ZhciBzPVwic2FtZVwiPT09cj9cInNhbWVcIjpcInZhbGlkXCI7cmV0dXJuIG89XCJtYXhcIj09PWE/bWF4UG9vbChlLHQsbixzKTphdmdQb29sKGUsdCxuLHMpLFwiY2hhbm5lbHNGaXJzdFwiPT09aSYmKG89dHJhbnNwb3NlKG8sWzAsMywxLDJdKSksb30pfXNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhaZXJvUGFkZGluZzJEKTt2YXIgUG9vbGluZzFEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49dGhpcztpZihudWxsPT10LnBvb2xTaXplJiYodC5wb29sU2l6ZT0yKSxuPWUuY2FsbCh0aGlzLHQpfHx0aGlzLFwibnVtYmVyXCI9PXR5cGVvZiB0LnBvb2xTaXplKW4ucG9vbFNpemU9W3QucG9vbFNpemVdO2Vsc2V7aWYoIUFycmF5LmlzQXJyYXkodC5wb29sU2l6ZSl8fDEhPT10LnBvb2xTaXplLmxlbmd0aHx8XCJudW1iZXJcIiE9dHlwZW9mIHQucG9vbFNpemVbMF0pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJwb29sU2l6ZSBmb3IgMUQgY29udm9sdXRpb25hbCBsYXllciBtdXN0IGJlIGEgbnVtYmVyIG9yIGFuIEFycmF5IG9mIGEgc2luZ2xlIG51bWJlciwgYnV0IHJlY2VpdmVkIFwiK0pTT04uc3RyaW5naWZ5KHQucG9vbFNpemUpKTtuLnBvb2xTaXplPXQucG9vbFNpemV9aWYoYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKG4ucG9vbFNpemUsXCJwb29sU2l6ZVwiKSxudWxsPT10LnN0cmlkZXMpbi5zdHJpZGVzPW4ucG9vbFNpemU7ZWxzZSBpZihcIm51bWJlclwiPT10eXBlb2YgdC5zdHJpZGVzKW4uc3RyaWRlcz1bdC5zdHJpZGVzXTtlbHNle2lmKCFBcnJheS5pc0FycmF5KHQuc3RyaWRlcyl8fDEhPT10LnN0cmlkZXMubGVuZ3RofHxcIm51bWJlclwiIT10eXBlb2YgdC5zdHJpZGVzWzBdKXRocm93IG5ldyBWYWx1ZUVycm9yKFwic3RyaWRlcyBmb3IgMUQgY29udm9sdXRpb25hbCBsYXllciBtdXN0IGJlIGEgbnVtYmVyIG9yIGFuIEFycmF5IG9mIGEgc2luZ2xlIG51bWJlciwgYnV0IHJlY2VpdmVkIFwiK0pTT04uc3RyaW5naWZ5KHQuc3RyaWRlcykpO24uc3RyaWRlcz10LnN0cmlkZXN9cmV0dXJuIGFzc2VydFBvc2l0aXZlSW50ZWdlcihuLnN0cmlkZXMsXCJzdHJpZGVzXCIpLG4ucGFkZGluZz1udWxsPT10LnBhZGRpbmc/XCJ2YWxpZFwiOnQucGFkZGluZyxjaGVja1BhZGRpbmdNb2RlKG4ucGFkZGluZyksbi5pbnB1dFNwZWM9W25ldyBJbnB1dFNwZWMoe25kaW06M30pXSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7dmFyIHQ9Y29udk91dHB1dExlbmd0aCgoZT1nZXRFeGFjdGx5T25lU2hhcGUoZSkpWzFdLHRoaXMucG9vbFNpemVbMF0sdGhpcy5wYWRkaW5nLHRoaXMuc3RyaWRlc1swXSk7cmV0dXJuW2VbMF0sdCxlWzJdXX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtuLmludm9rZUNhbGxIb29rKGUsdCksZT1leHBhbmREaW1zJDEoZ2V0RXhhY3RseU9uZVRlbnNvcihlKSwyKTt2YXIgcj1uLnBvb2xpbmdGdW5jdGlvbihnZXRFeGFjdGx5T25lVGVuc29yKGUpLFtuLnBvb2xTaXplWzBdLDFdLFtuLnN0cmlkZXNbMF0sMV0sbi5wYWRkaW5nLFwiY2hhbm5lbHNMYXN0XCIpO3JldHVybiBzcXVlZXplKHIsWzJdKX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17cG9vbFNpemU6dGhpcy5wb29sU2l6ZSxwYWRkaW5nOnRoaXMucGFkZGluZyxzdHJpZGVzOnRoaXMuc3RyaWRlc30sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHR9KExheWVyKSxNYXhQb29saW5nMUQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMsdCl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLnBvb2xpbmdGdW5jdGlvbj1mdW5jdGlvbihlLHQsbixyLGkpe3JldHVybiBjaGVja0RhdGFGb3JtYXQoaSksY2hlY2tQYWRkaW5nTW9kZShyKSxwb29sMmQoZSx0LG4scixpLFwibWF4XCIpfSx0LmNsYXNzTmFtZT1cIk1heFBvb2xpbmcxRFwiLHR9KFBvb2xpbmcxRCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE1heFBvb2xpbmcxRCk7dmFyIEF2ZXJhZ2VQb29saW5nMUQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMsdCl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLnBvb2xpbmdGdW5jdGlvbj1mdW5jdGlvbihlLHQsbixyLGkpe3JldHVybiBjaGVja0RhdGFGb3JtYXQoaSksY2hlY2tQYWRkaW5nTW9kZShyKSxwb29sMmQoZSx0LG4scixpLFwiYXZnXCIpfSx0LmNsYXNzTmFtZT1cIkF2ZXJhZ2VQb29saW5nMURcIix0fShQb29saW5nMUQpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhBdmVyYWdlUG9vbGluZzFEKTt2YXIgUG9vbGluZzJEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49dGhpcztpZihudWxsPT10LnBvb2xTaXplJiYodC5wb29sU2l6ZT1bMiwyXSksKG49ZS5jYWxsKHRoaXMsdCl8fHRoaXMpLnBvb2xTaXplPUFycmF5LmlzQXJyYXkodC5wb29sU2l6ZSk/dC5wb29sU2l6ZTpbdC5wb29sU2l6ZSx0LnBvb2xTaXplXSxudWxsPT10LnN0cmlkZXMpbi5zdHJpZGVzPW4ucG9vbFNpemU7ZWxzZSBpZihBcnJheS5pc0FycmF5KHQuc3RyaWRlcykpe2lmKDIhPT10LnN0cmlkZXMubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiSWYgdGhlIHN0cmlkZXMgcHJvcGVydHkgb2YgYSAyRCBwb29saW5nIGxheWVyIGlzIGFuIEFycmF5LCBpdCBpcyBleHBlY3RlZCB0byBoYXZlIGEgbGVuZ3RoIG9mIDIsIGJ1dCByZWNlaXZlZCBsZW5ndGggXCIrdC5zdHJpZGVzLmxlbmd0aCtcIi5cIik7bi5zdHJpZGVzPXQuc3RyaWRlc31lbHNlIG4uc3RyaWRlcz1bdC5zdHJpZGVzLHQuc3RyaWRlc107cmV0dXJuIGFzc2VydFBvc2l0aXZlSW50ZWdlcihuLnBvb2xTaXplLFwicG9vbFNpemVcIiksYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKG4uc3RyaWRlcyxcInN0cmlkZXNcIiksbi5wYWRkaW5nPW51bGw9PXQucGFkZGluZz9cInZhbGlkXCI6dC5wYWRkaW5nLG4uZGF0YUZvcm1hdD1udWxsPT10LmRhdGFGb3JtYXQ/XCJjaGFubmVsc0xhc3RcIjp0LmRhdGFGb3JtYXQsY2hlY2tEYXRhRm9ybWF0KG4uZGF0YUZvcm1hdCksY2hlY2tQYWRkaW5nTW9kZShuLnBhZGRpbmcpLG4uaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOjR9KV0sbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe2U9Z2V0RXhhY3RseU9uZVNoYXBlKGUpO3ZhciB0PVwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0P2VbMl06ZVsxXSxuPVwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0P2VbM106ZVsyXTtyZXR1cm4gdD1jb252T3V0cHV0TGVuZ3RoKHQsdGhpcy5wb29sU2l6ZVswXSx0aGlzLnBhZGRpbmcsdGhpcy5zdHJpZGVzWzBdKSxuPWNvbnZPdXRwdXRMZW5ndGgobix0aGlzLnBvb2xTaXplWzFdLHRoaXMucGFkZGluZyx0aGlzLnN0cmlkZXNbMV0pLFwiY2hhbm5lbHNGaXJzdFwiPT09dGhpcy5kYXRhRm9ybWF0P1tlWzBdLGVbMV0sdCxuXTpbZVswXSx0LG4sZVszXV19LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIG4uaW52b2tlQ2FsbEhvb2soZSx0KSxuLnBvb2xpbmdGdW5jdGlvbihnZXRFeGFjdGx5T25lVGVuc29yKGUpLG4ucG9vbFNpemUsbi5zdHJpZGVzLG4ucGFkZGluZyxuLmRhdGFGb3JtYXQpfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtwb29sU2l6ZTp0aGlzLnBvb2xTaXplLHBhZGRpbmc6dGhpcy5wYWRkaW5nLHN0cmlkZXM6dGhpcy5zdHJpZGVzLGRhdGFGb3JtYXQ6dGhpcy5kYXRhRm9ybWF0fSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdH0oTGF5ZXIpLE1heFBvb2xpbmcyRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcyx0KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUucG9vbGluZ0Z1bmN0aW9uPWZ1bmN0aW9uKGUsdCxuLHIsaSl7cmV0dXJuIGNoZWNrRGF0YUZvcm1hdChpKSxjaGVja1BhZGRpbmdNb2RlKHIpLHBvb2wyZChlLHQsbixyLGksXCJtYXhcIil9LHQuY2xhc3NOYW1lPVwiTWF4UG9vbGluZzJEXCIsdH0oUG9vbGluZzJEKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTWF4UG9vbGluZzJEKTt2YXIgQXZlcmFnZVBvb2xpbmcyRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcyx0KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUucG9vbGluZ0Z1bmN0aW9uPWZ1bmN0aW9uKGUsdCxuLHIsaSl7cmV0dXJuIGNoZWNrRGF0YUZvcm1hdChpKSxjaGVja1BhZGRpbmdNb2RlKHIpLHBvb2wyZChlLHQsbixyLGksXCJhdmdcIil9LHQuY2xhc3NOYW1lPVwiQXZlcmFnZVBvb2xpbmcyRFwiLHR9KFBvb2xpbmcyRCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEF2ZXJhZ2VQb29saW5nMkQpO3ZhciBHbG9iYWxQb29saW5nMUQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5pbnB1dFNwZWM9W25ldyBJbnB1dFNwZWMoe25kaW06M30pXSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuW2VbMF0sZVsyXV19LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcn0sdH0oTGF5ZXIpLEdsb2JhbEF2ZXJhZ2VQb29saW5nMUQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gZS5jYWxsKHRoaXMsdHx8e30pfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgdD1nZXRFeGFjdGx5T25lVGVuc29yKGUpO3JldHVybiBtZWFuKHQsMSl9KX0sdC5jbGFzc05hbWU9XCJHbG9iYWxBdmVyYWdlUG9vbGluZzFEXCIsdH0oR2xvYmFsUG9vbGluZzFEKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR2xvYmFsQXZlcmFnZVBvb2xpbmcxRCk7dmFyIEdsb2JhbE1heFBvb2xpbmcxRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3JldHVybiBlLmNhbGwodGhpcyx0fHx7fSl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciB0PWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7cmV0dXJuIG1heCh0LDEpfSl9LHQuY2xhc3NOYW1lPVwiR2xvYmFsTWF4UG9vbGluZzFEXCIsdH0oR2xvYmFsUG9vbGluZzFEKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR2xvYmFsTWF4UG9vbGluZzFEKTt2YXIgR2xvYmFsUG9vbGluZzJEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIG4uZGF0YUZvcm1hdD1udWxsPT10LmRhdGFGb3JtYXQ/XCJjaGFubmVsc0xhc3RcIjp0LmRhdGFGb3JtYXQsY2hlY2tEYXRhRm9ybWF0KG4uZGF0YUZvcm1hdCksbi5pbnB1dFNwZWM9W25ldyBJbnB1dFNwZWMoe25kaW06NH0pXSxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGU9ZSxcImNoYW5uZWxzTGFzdFwiPT09dGhpcy5kYXRhRm9ybWF0P1tlWzBdLGVbM11dOltlWzBdLGVbMV1dfSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3J9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXtkYXRhRm9ybWF0OnRoaXMuZGF0YUZvcm1hdH0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHR9KExheWVyKSxHbG9iYWxBdmVyYWdlUG9vbGluZzJEPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbCE9PWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciB0PWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7cmV0dXJuXCJjaGFubmVsc0xhc3RcIj09PW4uZGF0YUZvcm1hdD9tZWFuKHQsWzEsMl0pOm1lYW4odCxbMiwzXSl9KX0sdC5jbGFzc05hbWU9XCJHbG9iYWxBdmVyYWdlUG9vbGluZzJEXCIsdH0oR2xvYmFsUG9vbGluZzJEKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR2xvYmFsQXZlcmFnZVBvb2xpbmcyRCk7dmFyIEdsb2JhbE1heFBvb2xpbmcyRD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIG51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgdD1nZXRFeGFjdGx5T25lVGVuc29yKGUpO3JldHVyblwiY2hhbm5lbHNMYXN0XCI9PT1uLmRhdGFGb3JtYXQ/bWF4KHQsWzEsMl0pOm1heCh0LFsyLDNdKX0pfSx0LmNsYXNzTmFtZT1cIkdsb2JhbE1heFBvb2xpbmcyRFwiLHR9KEdsb2JhbFBvb2xpbmcyRCk7ZnVuY3Rpb24gc3RhbmRhcmRpemVBcmdzKGUsdCxuLHIpe2lmKEFycmF5LmlzQXJyYXkoZSkpe2lmKG51bGwhPXR8fG51bGwhPW4pdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJXaGVuIGlucHV0cyBpcyBhbiBhcnJheSwgbmVpdGhlciBpbml0aWFsU3RhdGUgb3IgY29uc3RhbnRzIHNob3VsZCBiZSBwcm92aWRlZFwiKTtudWxsIT1yJiYobj1lLnNsaWNlKGUubGVuZ3RoLXIsZS5sZW5ndGgpLGU9ZS5zbGljZSgwLGUubGVuZ3RoLXIpKSxlLmxlbmd0aD4xJiYodD1lLnNsaWNlKDEsZS5sZW5ndGgpKSxlPWVbMF19ZnVuY3Rpb24gaShlKXtyZXR1cm4gbnVsbD09ZXx8QXJyYXkuaXNBcnJheShlKT9lOltlXX1yZXR1cm57aW5wdXRzOmUsaW5pdGlhbFN0YXRlOnQ9aSh0KSxjb25zdGFudHM6bj1pKG4pfX1mdW5jdGlvbiBybm4oZSx0LG4scixpLGEsbyxzKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9ITEpLHZvaWQgMD09PW8mJihvPSExKSx2b2lkIDA9PT1zJiYocz0hMSksdGlkeShmdW5jdGlvbigpe3ZhciBsPXQuc2hhcGUubGVuZ3RoO2lmKGw8Myl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklucHV0IHNob3VsZCBiZSBhdCBsZWFzdCAzRCwgYnV0IGlzIFwiK2wrXCJELlwiKTt2YXIgdT1bMSwwXS5jb25jYXQocmFuZ2UoMixsKSk7aWYodD10cmFuc3Bvc2UodCx1KSxudWxsIT1hKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwiVGhlIHJubigpIGZ1bmN0b2luIG9mIHRoZSBkZWVwbGVhcm4uanMgYmFja2VuZCBkb2VzIG5vdCBzdXBwb3J0IGNvbnN0YW50cyB5ZXQuXCIpO28mJmNvbnNvbGUud2FybihcIkJhY2tlbmQgcm5uKCk6IHRoZSB1bnJvbGwgPSB0cnVlIG9wdGlvbiBpcyBub3QgYXBwbGljYWJsZSB0byB0aGUgaW1wZXJhdGl2ZSBkZWVwbGVhcm4uanMgYmFja2VuZC5cIiksbnVsbCE9aSYmKChpPWkuYXNUeXBlKFwiYm9vbFwiKS5hc1R5cGUoXCJmbG9hdDMyXCIpKS5yYW5rPT09bC0xJiYoaT1leHBhbmREaW1zKGksLTEpKSxpPXRyYW5zcG9zZShpLHUpKSxyJiYodD1yZXZlcnNlKHQsMCksbnVsbCE9aSYmKGk9cmV2ZXJzZShpLDApKSk7dmFyIGMscCxoPVtdLGQ9bixmPXQuc2hhcGVbMF0sZz11bnN0YWNrKHQpO251bGwhPWkmJihwPXVuc3RhY2soaSkpO2Zvcih2YXIgbSx5PWZ1bmN0aW9uKHQpe3ZhciBuPWdbdF0scj10aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGUobixkKX0pO2lmKG51bGw9PWkpYz1yWzBdLGQ9clsxXTtlbHNle3ZhciBhPXRpZHkoZnVuY3Rpb24oKXt2YXIgZT1wW3RdLG49b25lc0xpa2UoZSkuc3ViKGUpO3JldHVybntvdXRwdXQ6clswXS5tdWwoZSkuYWRkU3RyaWN0KGRbMF0ubXVsKG4pKSxuZXdTdGF0ZXM6ZC5tYXAoZnVuY3Rpb24odCxpKXtyZXR1cm4gclsxXVtpXS5tdWwoZSkuYWRkU3RyaWN0KHQubXVsKG4pKX0pfX0pO2M9YS5vdXRwdXQsZD1hLm5ld1N0YXRlc31zJiZoLnB1c2goYyl9LHY9MDt2PGY7Kyt2KXkodik7aWYocyl7bT1zdGFjayhoLDEpfXJldHVybltjLG0sZF19KX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR2xvYmFsTWF4UG9vbGluZzJEKTt2YXIgUk5OPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG4scj1lLmNhbGwodGhpcyx0KXx8dGhpcztpZihudWxsPT10LmNlbGwpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJjZWxsIHByb3BlcnR5IGlzIG1pc3NpbmcgZm9yIHRoZSBjb25zdHJ1Y3RvciBvZiBSTk4uXCIpO2lmKG51bGw9PShuPUFycmF5LmlzQXJyYXkodC5jZWxsKT9uZXcgU3RhY2tlZFJOTkNlbGxzKHtjZWxsczp0LmNlbGx9KTp0LmNlbGwpLnN0YXRlU2l6ZSl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBSTk4gY2VsbCBzaG91bGQgaGF2ZSBhbiBhdHRyaWJ1dGUgYHN0YXRlU2l6ZWAgKHR1cGxlIG9mIGludGVnZXJzLCBvbmUgaW50ZWdlciBwZXIgUk5OIHN0YXRlKS5cIik7cmV0dXJuIHIuY2VsbD1uLHIucmV0dXJuU2VxdWVuY2VzPW51bGwhPXQucmV0dXJuU2VxdWVuY2VzJiZ0LnJldHVyblNlcXVlbmNlcyxyLnJldHVyblN0YXRlPW51bGwhPXQucmV0dXJuU3RhdGUmJnQucmV0dXJuU3RhdGUsci5nb0JhY2t3YXJkcz1udWxsIT10LmdvQmFja3dhcmRzJiZ0LmdvQmFja3dhcmRzLHIuX3N0YXRlZnVsPW51bGwhPXQuc3RhdGVmdWwmJnQuc3RhdGVmdWwsci51bnJvbGw9bnVsbCE9dC51bnJvbGwmJnQudW5yb2xsLHIuc3VwcG9ydHNNYXNraW5nPSEwLHIuaW5wdXRTcGVjPVtuZXcgSW5wdXRTcGVjKHtuZGltOjN9KV0sci5zdGF0ZVNwZWM9bnVsbCxyLnN0YXRlc189bnVsbCxyLm51bUNvbnN0YW50cz1udWxsLHIua2VwdFN0YXRlcz1bXSxyfXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5nZXRTdGF0ZXM9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09dGhpcy5zdGF0ZXNfP3JhbmdlKDAsQXJyYXkuaXNBcnJheSh0aGlzLmNlbGwuc3RhdGVTaXplKT90aGlzLmNlbGwuc3RhdGVTaXplLmxlbmd0aDoxKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG51bGx9KTp0aGlzLnN0YXRlc199LHQucHJvdG90eXBlLnNldFN0YXRlcz1mdW5jdGlvbihlKXt0aGlzLnN0YXRlc189ZX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe2lzQXJyYXlPZlNoYXBlcyhlKSYmKGU9ZVswXSksZT1lO3ZhciB0PXRoaXMuY2VsbC5zdGF0ZVNpemU7QXJyYXkuaXNBcnJheSh0KXx8KHQ9W3RdKTt2YXIgbixyPXRbMF07aWYobj10aGlzLnJldHVyblNlcXVlbmNlcz9bZVswXSxlWzFdLHJdOltlWzBdLHJdLHRoaXMucmV0dXJuU3RhdGUpe2Zvcih2YXIgaT1bXSxhPTAsbz10O2E8by5sZW5ndGg7YSsrKXt2YXIgcz1vW2FdO2kucHVzaChbZVswXSxzXSl9cmV0dXJuW25dLmNvbmNhdChpKX1yZXR1cm4gbn0sdC5wcm90b3R5cGUuY29tcHV0ZU1hc2s9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7QXJyYXkuaXNBcnJheSh0KSYmKHQ9dFswXSk7dmFyIGU9bi5yZXR1cm5TZXF1ZW5jZXM/dDpudWxsO2lmKG4ucmV0dXJuU3RhdGUpe3ZhciByPW4uc3RhdGVzLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gbnVsbH0pO3JldHVybltlXS5jb25jYXQocil9cmV0dXJuIGV9KX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwic3RhdGVzXCIse2dldDpmdW5jdGlvbigpe2lmKG51bGw9PXRoaXMuc3RhdGVzXyl7Zm9yKHZhciBlPUFycmF5LmlzQXJyYXkodGhpcy5jZWxsLnN0YXRlU2l6ZSk/dGhpcy5jZWxsLnN0YXRlU2l6ZS5sZW5ndGg6MSx0PVtdLG49MDtuPGU7KytuKXQucHVzaChudWxsKTtyZXR1cm4gdH1yZXR1cm4gdGhpcy5zdGF0ZXNffSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5zdGF0ZXNfPWV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7aWYobnVsbCE9dGhpcy5udW1Db25zdGFudHMpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJDb25zdGFudHMgc3VwcG9ydCBpcyBub3QgaW1wbGVtZW50ZWQgaW4gUk5OIHlldC5cIik7aXNBcnJheU9mU2hhcGVzKGUpJiYoZT1lWzBdKSxlPWU7dmFyIHQ9dGhpcy5zdGF0ZWZ1bD9lWzBdOm51bGwsbj1lW2UubGVuZ3RoLTFdO3RoaXMuaW5wdXRTcGVjWzBdPW5ldyBJbnB1dFNwZWMoe3NoYXBlOlt0LG51bGwsbl19KTt2YXIgcixpPVtlWzBdXS5jb25jYXQoZS5zbGljZSgyKSk7aWYodGhpcy5jZWxsLmJ1aWxkKGkpLHI9QXJyYXkuaXNBcnJheSh0aGlzLmNlbGwuc3RhdGVTaXplKT90aGlzLmNlbGwuc3RhdGVTaXplOlt0aGlzLmNlbGwuc3RhdGVTaXplXSxudWxsIT10aGlzLnN0YXRlU3BlYyl7aWYoIXV0aWwuYXJyYXlzRXF1YWwodGhpcy5zdGF0ZVNwZWMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNoYXBlW2Uuc2hhcGUubGVuZ3RoLTFdfSkscikpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJBbiBpbml0aWFsU3RhdGUgd2FzIHBhc3NlZCB0aGF0IGlzIG5vdCBjb21wYXRpYmxlIHdpdGggY2VsbC5zdGF0ZVNpemUuIFJlY2VpdmVkIHN0YXRlU3BlYz1cIit0aGlzLnN0YXRlU3BlYytcIjsgSG93ZXZlciBjZWxsLnN0YXRlU2l6ZSBpcyBcIit0aGlzLmNlbGwuc3RhdGVTaXplKX1lbHNlIHRoaXMuc3RhdGVTcGVjPXIubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgSW5wdXRTcGVjKHtzaGFwZTpbbnVsbCxlXX0pfSk7dGhpcy5zdGF0ZWZ1bCYmdGhpcy5yZXNldFN0YXRlcygpfSx0LnByb3RvdHlwZS5yZXNldFN0YXRlcz1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7dm9pZCAwPT09dCYmKHQ9ITEpLHRpZHkoZnVuY3Rpb24oKXtpZighbi5zdGF0ZWZ1bCl0aHJvdyBuZXcgQXR0cmlidXRlRXJyb3IoXCJDYW5ub3QgY2FsbCByZXNldFN0YXRlcygpIG9uIGFuIFJOTiBMYXllciB0aGF0IGlzIG5vdCBzdGF0ZWZ1bC5cIik7dmFyIHI9bi5pbnB1dFNwZWNbMF0uc2hhcGVbMF07aWYobnVsbD09cil0aHJvdyBuZXcgVmFsdWVFcnJvcihcIklmIGFuIFJOTiBpcyBzdGF0ZWZ1bCwgaXQgbmVlZHMgdG8ga25vdyBpdHMgYmF0Y2ggc2l6ZS4gU3BlY2lmeSB0aGUgYmF0Y2ggc2l6ZSBvZiB5b3VyIGlucHV0IHRlbnNvcnM6IFxcbi0gSWYgdXNpbmcgYSBTZXF1ZW50aWFsIG1vZGVsLCBzcGVjaWZ5IHRoZSBiYXRjaCBzaXplIGJ5IHBhc3NpbmcgYSBgYmF0Y2hJbnB1dFNoYXBlYCBvcHRpb24gdG8geW91ciBmaXJzdCBsYXllci5cXG4tIElmIHVzaW5nIHRoZSBmdW5jdGlvbmFsIEFQSSwgc3BlY2lmeSB0aGUgYmF0Y2ggc2l6ZSBieSBwYXNzaW5nIGEgYGJhdGNoU2hhcGVgIG9wdGlvbiB0byB5b3VyIElucHV0IGxheWVyLlwiKTtpZihudWxsPT1uLnN0YXRlc18pQXJyYXkuaXNBcnJheShuLmNlbGwuc3RhdGVTaXplKT9uLnN0YXRlc189bi5jZWxsLnN0YXRlU2l6ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHplcm9zKFtyLGVdKX0pOm4uc3RhdGVzXz1bemVyb3MoW3Isbi5jZWxsLnN0YXRlU2l6ZV0pXTtlbHNlIGlmKG51bGw9PWUpZGlzcG9zZShuLnN0YXRlc18pLG51bGwhPW4ua2VwdFN0YXRlcyYmKGRpc3Bvc2Uobi5rZXB0U3RhdGVzKSxuLmtlcHRTdGF0ZXM9W10pLEFycmF5LmlzQXJyYXkobi5jZWxsLnN0YXRlU2l6ZSk/bi5zdGF0ZXNfPW4uY2VsbC5zdGF0ZVNpemUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiB6ZXJvcyhbcixlXSl9KTpuLnN0YXRlc19bMF09emVyb3MoW3Isbi5jZWxsLnN0YXRlU2l6ZV0pO2Vsc2V7aWYoQXJyYXkuaXNBcnJheShlKXx8KGU9W2VdKSxlLmxlbmd0aCE9PW4uc3RhdGVzXy5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJMYXllciBcIituLm5hbWUrXCIgZXhwZWN0cyBcIituLnN0YXRlc18ubGVuZ3RoK1wiIHN0YXRlKHMpLCBidXQgaXQgcmVjZWl2ZWQgXCIrZS5sZW5ndGgrXCIgc3RhdGUgdmFsdWUocykuIElucHV0IHJlY2VpdmVkOiBcIitlKTshMD09PXQ/bi5rZXB0U3RhdGVzLnB1c2gobi5zdGF0ZXNfLnNsaWNlKCkpOmRpc3Bvc2Uobi5zdGF0ZXNfKTtmb3IodmFyIGk9MDtpPG4uc3RhdGVzXy5sZW5ndGg7KytpKXt2YXIgYT1lW2ldLG89QXJyYXkuaXNBcnJheShuLmNlbGwuc3RhdGVTaXplKT9uLmNlbGwuc3RhdGVTaXplW2ldOm4uY2VsbC5zdGF0ZVNpemUscz1bcixvXTtpZighdXRpbC5hcnJheXNFcXVhbChhLnNoYXBlLHMpKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiU3RhdGUgXCIraStcIiBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciBcIituLm5hbWUrXCI6IGV4cGVjdGVkIHNoYXBlPVwiK3MrXCIsIHJlY2VpdmVkIHNoYXBlPVwiK2Euc2hhcGUpO24uc3RhdGVzX1tpXT1hfX1uLnN0YXRlc189bi5zdGF0ZXNfLm1hcChmdW5jdGlvbihlKXtyZXR1cm4ga2VlcChlLmNsb25lKCkpfSl9KX0sdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24odCxuKXt2YXIgcj1udWxsPT1uP251bGw6bi5pbml0aWFsU3RhdGUsaT1udWxsPT1uP251bGw6bi5jb25zdGFudHM7bnVsbD09biYmKG49e30pO3ZhciBhPXN0YW5kYXJkaXplQXJncyh0LHIsaSx0aGlzLm51bUNvbnN0YW50cyk7dD1hLmlucHV0cyxyPWEuaW5pdGlhbFN0YXRlLGk9YS5jb25zdGFudHM7dmFyIG89W10scz1bXTtpZihudWxsIT1yKXtuLmluaXRpYWxTdGF0ZT1yLG89by5jb25jYXQociksdGhpcy5zdGF0ZVNwZWM9W107Zm9yKHZhciBsPTAsdT1yO2w8dS5sZW5ndGg7bCsrKXt2YXIgYz11W2xdO3RoaXMuc3RhdGVTcGVjLnB1c2gobmV3IElucHV0U3BlYyh7c2hhcGU6Yy5zaGFwZX0pKX1zPXMuY29uY2F0KHRoaXMuc3RhdGVTcGVjKX1pZihudWxsIT1pJiYobi5jb25zdGFudHM9aSxvPW8uY29uY2F0KGkpLHRoaXMubnVtQ29uc3RhbnRzPWkubGVuZ3RoKSxvWzBdaW5zdGFuY2VvZiBTeW1ib2xpY1RlbnNvcil7dmFyIHA9W3RdLmNvbmNhdChvKSxoPXRoaXMuaW5wdXRTcGVjLmNvbmNhdChzKSxkPXRoaXMuaW5wdXRTcGVjO3RoaXMuaW5wdXRTcGVjPWg7dmFyIGY9ZS5wcm90b3R5cGUuYXBwbHkuY2FsbCh0aGlzLHAsbik7cmV0dXJuIHRoaXMuaW5wdXRTcGVjPWQsZn1yZXR1cm4gZS5wcm90b3R5cGUuYXBwbHkuY2FsbCh0aGlzLHQsbil9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHI9bnVsbD09dD9udWxsOnQubWFzayxpPW51bGw9PXQ/bnVsbDp0LnRyYWluaW5nLGE9bnVsbD09dD9udWxsOnQuaW5pdGlhbFN0YXRlO2U9Z2V0RXhhY3RseU9uZVRlbnNvcihlKSxudWxsPT1hJiYoYT1uLnN0YXRlZnVsP24uc3RhdGVzXzpuLmdldEluaXRpYWxTdGF0ZShlKSk7dmFyIG89QXJyYXkuaXNBcnJheShuLmNlbGwuc3RhdGVTaXplKT9uLmNlbGwuc3RhdGVTaXplLmxlbmd0aDoxO2lmKGEubGVuZ3RoIT09byl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlJOTiBMYXllciBoYXMgXCIrbytcIiBzdGF0ZShzKSBidXQgd2FzIHBhc3NlZCBcIithLmxlbmd0aCtcIiBpbml0aWFsIHN0YXRlKHMpLlwiKTtuLnVucm9sbCYmY29uc29sZS53YXJuKFwiSWdub3JpbmcgdW5yb2xsID0gdHJ1ZSBmb3IgUk5OIGxheWVyLCBkdWUgdG8gaW1wZXJhdGl2ZSBiYWNrZW5kLlwiKTt2YXIgcz17dHJhaW5pbmc6aX0sbD1ybm4oZnVuY3Rpb24oZSx0KXt2YXIgcj1uLmNlbGwuY2FsbChbZV0uY29uY2F0KHQpLHMpO3JldHVybltyWzBdLHIuc2xpY2UoMSldfSxlLGEsbi5nb0JhY2t3YXJkcyxyLG51bGwsbi51bnJvbGwsbi5yZXR1cm5TZXF1ZW5jZXMpLHU9bFswXSxjPWxbMV0scD1sWzJdO24uc3RhdGVmdWwmJm4ucmVzZXRTdGF0ZXMocCxpKTt2YXIgaD1uLnJldHVyblNlcXVlbmNlcz9jOnU7cmV0dXJuIG4ucmV0dXJuU3RhdGU/W2hdLmNvbmNhdChwKTpofSl9LHQucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZT1mdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIG49emVyb3MoZS5zaGFwZSk7cmV0dXJuIG49ZXhwYW5kRGltcyQxKG49c3VtKG4sWzEsMl0pKSxBcnJheS5pc0FycmF5KHQuY2VsbC5zdGF0ZVNpemUpP3QuY2VsbC5zdGF0ZVNpemUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlPjE/dGlsZSQxKG4sWzEsZV0pOm59KTp0LmNlbGwuc3RhdGVTaXplPjE/W3RpbGUkMShuLFsxLHQuY2VsbC5zdGF0ZVNpemVdKV06W25dfSl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhaW5hYmxlP3RoaXMuY2VsbC50cmFpbmFibGVXZWlnaHRzOltdfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIm5vblRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJhaW5hYmxlP3RoaXMuY2VsbC5ub25UcmFpbmFibGVXZWlnaHRzOnRoaXMuY2VsbC53ZWlnaHRzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLnNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQ9ZnVuY3Rpb24odCl7ZS5wcm90b3R5cGUuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZC5jYWxsKHRoaXMsdCksbnVsbCE9dGhpcy5jZWxsJiZ0aGlzLmNlbGwuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZCh0KX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e3JldHVyblNlcXVlbmNlczp0aGlzLnJldHVyblNlcXVlbmNlcyxyZXR1cm5TdGF0ZTp0aGlzLnJldHVyblN0YXRlLGdvQmFja3dhcmRzOnRoaXMuZ29CYWNrd2FyZHMsc3RhdGVmdWw6dGhpcy5zdGF0ZWZ1bCx1bnJvbGw6dGhpcy51bnJvbGx9O251bGwhPXRoaXMubnVtQ29uc3RhbnRzJiYodC5udW1Db25zdGFudHM9dGhpcy5udW1Db25zdGFudHMpO3ZhciBuPXRoaXMuY2VsbC5nZXRDb25maWcoKTt0LmNlbGw9e2NsYXNzTmFtZTp0aGlzLmNlbGwuZ2V0Q2xhc3NOYW1lKCksY29uZmlnOm59O3ZhciByPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsciksdH0sdC5jbGFzc05hbWU9XCJSTk5cIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFJOTik7dmFyIFJOTkNlbGw9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHR9KExheWVyKSxTaW1wbGVSTk5DZWxsPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIG4uREVGQVVMVF9BQ1RJVkFUSU9OPVwidGFuaFwiLG4uREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVI9XCJnbG9yb3ROb3JtYWxcIixuLkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSPVwib3J0aG9nb25hbFwiLG4uREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSPVwiemVyb3NcIixuLnVuaXRzPXQudW5pdHMsYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKG4udW5pdHMsXCJ1bml0c1wiKSxuLmFjdGl2YXRpb249Z2V0QWN0aXZhdGlvbihudWxsPT10LmFjdGl2YXRpb24/bi5ERUZBVUxUX0FDVElWQVRJT046dC5hY3RpdmF0aW9uKSxuLnVzZUJpYXM9bnVsbD09dC51c2VCaWFzfHx0LnVzZUJpYXMsbi5rZXJuZWxJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcih0Lmtlcm5lbEluaXRpYWxpemVyfHxuLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKSxuLnJlY3VycmVudEluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQucmVjdXJyZW50SW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9SRUNVUlJFTlRfSU5JVElBTElaRVIpLG4uYmlhc0luaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQuYmlhc0luaXRpYWxpemVyfHxuLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUiksbi5rZXJuZWxSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0Lmtlcm5lbFJlZ3VsYXJpemVyKSxuLnJlY3VycmVudFJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQucmVjdXJyZW50UmVndWxhcml6ZXIpLG4uYmlhc1JlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQuYmlhc1JlZ3VsYXJpemVyKSxuLmtlcm5lbENvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludCh0Lmtlcm5lbENvbnN0cmFpbnQpLG4ucmVjdXJyZW50Q29uc3RyYWludD1nZXRDb25zdHJhaW50KHQucmVjdXJyZW50Q29uc3RyYWludCksbi5iaWFzQ29uc3RyYWludD1nZXRDb25zdHJhaW50KHQuYmlhc0NvbnN0cmFpbnQpLG4uZHJvcG91dD1taW4kMShbMSxtYXgkMShbMCxudWxsPT10LmRyb3BvdXQ/MDp0LmRyb3BvdXRdKV0pLG4ucmVjdXJyZW50RHJvcG91dD1taW4kMShbMSxtYXgkMShbMCxudWxsPT10LnJlY3VycmVudERyb3BvdXQ/MDp0LnJlY3VycmVudERyb3BvdXRdKV0pLG4uc3RhdGVTaXplPW4udW5pdHMsbi5kcm9wb3V0TWFzaz1udWxsLG4ucmVjdXJyZW50RHJvcG91dE1hc2s9bnVsbCxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXtlPWdldEV4YWN0bHlPbmVTaGFwZShlKSx0aGlzLmtlcm5lbD10aGlzLmFkZFdlaWdodChcImtlcm5lbFwiLFtlW2UubGVuZ3RoLTFdLHRoaXMudW5pdHNdLG51bGwsdGhpcy5rZXJuZWxJbml0aWFsaXplcix0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCEwLHRoaXMua2VybmVsQ29uc3RyYWludCksdGhpcy5yZWN1cnJlbnRLZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJyZWN1cnJlbnRfa2VybmVsXCIsW3RoaXMudW5pdHMsdGhpcy51bml0c10sbnVsbCx0aGlzLnJlY3VycmVudEluaXRpYWxpemVyLHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIsITAsdGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KSx0aGlzLnVzZUJpYXM/dGhpcy5iaWFzPXRoaXMuYWRkV2VpZ2h0KFwiYmlhc1wiLFt0aGlzLnVuaXRzXSxudWxsLHRoaXMuYmlhc0luaXRpYWxpemVyLHRoaXMuYmlhc1JlZ3VsYXJpemVyLCEwLHRoaXMuYmlhc0NvbnN0cmFpbnQpOnRoaXMuYmlhcz1udWxsLHRoaXMuYnVpbHQ9ITB9LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7aWYoMiE9PShlPWUpLmxlbmd0aCl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlNpbXBsZVJOTkNlbGwgZXhwZWN0cyAyIGlucHV0IFRlbnNvcnMsIGdvdCBcIitlLmxlbmd0aCtcIi5cIik7dmFyIHI9ZVsxXTtlPWVbMF07dmFyIGksYT1udWxsIT10LnRyYWluaW5nJiZ0LnRyYWluaW5nOzA8bi5kcm9wb3V0JiZuLmRyb3BvdXQ8MSYmbnVsbD09bi5kcm9wb3V0TWFzayYmKG4uZHJvcG91dE1hc2s9Z2VuZXJhdGVEcm9wb3V0TWFzayhmdW5jdGlvbigpe3JldHVybiBvbmVzTGlrZShlKX0sbi5kcm9wb3V0LGEpKSwwPG4ucmVjdXJyZW50RHJvcG91dCYmbi5yZWN1cnJlbnREcm9wb3V0PDEmJm51bGw9PW4ucmVjdXJyZW50RHJvcG91dE1hc2smJihuLnJlY3VycmVudERyb3BvdXRNYXNrPWdlbmVyYXRlRHJvcG91dE1hc2soZnVuY3Rpb24oKXtyZXR1cm4gb25lc0xpa2Uocil9LG4ucmVjdXJyZW50RHJvcG91dCxhKSk7dmFyIG89bi5kcm9wb3V0TWFzayxzPW4ucmVjdXJyZW50RHJvcG91dE1hc2s7aT1kb3QobnVsbCE9bz9tdWwoZSxvKTplLG4ua2VybmVsLnJlYWQoKSksbnVsbCE9bi5iaWFzJiYoaT1iaWFzQWRkKGksbi5iaWFzLnJlYWQoKSkpLG51bGwhPXMmJihyPW11bChyLHMpKTt2YXIgbD1hZGQoaSxkb3QocixuLnJlY3VycmVudEtlcm5lbC5yZWFkKCkpKTtyZXR1cm4gbnVsbCE9bi5hY3RpdmF0aW9uJiYobD1uLmFjdGl2YXRpb24uYXBwbHkobCkpLFtsLGxdfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXt1bml0czp0aGlzLnVuaXRzLGFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLHVzZUJpYXM6dGhpcy51c2VCaWFzLGtlcm5lbEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLHJlY3VycmVudEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIpLGJpYXNJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksa2VybmVsUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplcikscmVjdXJyZW50UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciksYmlhc1JlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksa2VybmVsQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMua2VybmVsQ29uc3RyYWludCkscmVjdXJyZW50Q29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksYmlhc0NvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KSxkcm9wb3V0OnRoaXMuZHJvcG91dCxyZWN1cnJlbnREcm9wb3V0OnRoaXMucmVjdXJyZW50RHJvcG91dH0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9LHQuY2xhc3NOYW1lPVwiU2ltcGxlUk5OQ2VsbFwiLHR9KFJOTkNlbGwpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTaW1wbGVSTk5DZWxsKTt2YXIgU2ltcGxlUk5OPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIHQuY2VsbD1uZXcgU2ltcGxlUk5OQ2VsbCh0KSxlLmNhbGwodGhpcyx0KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbih0LG4pe3ZhciByPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtudWxsIT1yLmNlbGwuZHJvcG91dE1hc2smJihkaXNwb3NlKHIuY2VsbC5kcm9wb3V0TWFzayksci5jZWxsLmRyb3BvdXRNYXNrPW51bGwpLG51bGwhPXIuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzayYmKGRpc3Bvc2Uoci5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrKSxyLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2s9bnVsbCk7dmFyIGk9bnVsbD09bj9udWxsOm4ubWFzayxhPW51bGw9PW4/bnVsbDpuLnRyYWluaW5nLG89bnVsbD09bj9udWxsOm4uaW5pdGlhbFN0YXRlO3JldHVybiBlLnByb3RvdHlwZS5jYWxsLmNhbGwocix0LHttYXNrOmksdHJhaW5pbmc6YSxpbml0aWFsU3RhdGU6b30pfSl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInVuaXRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwudW5pdHN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiYWN0aXZhdGlvblwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmFjdGl2YXRpb259LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidXNlQmlhc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnVzZUJpYXN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwia2VybmVsSW5pdGlhbGl6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5rZXJuZWxJbml0aWFsaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyZWN1cnJlbnRJbml0aWFsaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudEluaXRpYWxpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImJpYXNJbml0aWFsaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmJpYXNJbml0aWFsaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJrZXJuZWxSZWd1bGFyaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmtlcm5lbFJlZ3VsYXJpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJlY3VycmVudFJlZ3VsYXJpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50UmVndWxhcml6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiYmlhc1JlZ3VsYXJpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYmlhc1JlZ3VsYXJpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImtlcm5lbENvbnN0cmFpbnRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5rZXJuZWxDb25zdHJhaW50fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJlY3VycmVudENvbnN0cmFpbnRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRDb25zdHJhaW50fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImJpYXNDb25zdHJhaW50XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYmlhc0NvbnN0cmFpbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiZHJvcG91dFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmRyb3BvdXR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVjdXJyZW50RHJvcG91dFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudERyb3BvdXR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e3VuaXRzOnRoaXMudW5pdHMsYWN0aXZhdGlvbjpzZXJpYWxpemVBY3RpdmF0aW9uKHRoaXMuYWN0aXZhdGlvbiksdXNlQmlhczp0aGlzLnVzZUJpYXMsa2VybmVsSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5rZXJuZWxJbml0aWFsaXplcikscmVjdXJyZW50SW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5yZWN1cnJlbnRJbml0aWFsaXplciksYmlhc0luaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYmlhc0luaXRpYWxpemVyKSxrZXJuZWxSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmtlcm5lbFJlZ3VsYXJpemVyKSxyZWN1cnJlbnRSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyKSxiaWFzUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5iaWFzUmVndWxhcml6ZXIpLGFjdGl2aXR5UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxrZXJuZWxDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5rZXJuZWxDb25zdHJhaW50KSxyZWN1cnJlbnRDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KSxiaWFzQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMuYmlhc0NvbnN0cmFpbnQpLGRyb3BvdXQ6dGhpcy5kcm9wb3V0LHJlY3VycmVudERyb3BvdXQ6dGhpcy5yZWN1cnJlbnREcm9wb3V0fSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBkZWxldGUgbi5jZWxsLE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmNsYXNzTmFtZT1cIlNpbXBsZVJOTlwiLHR9KFJOTik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFNpbXBsZVJOTik7dmFyIEdSVUNlbGw9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5ERUZBVUxUX0FDVElWQVRJT049XCJ0YW5oXCIsbi5ERUZBVUxUX1JFQ1VSUkVOVF9BQ1RJVkFUSU9OPVwiaGFyZFNpZ21vaWRcIixuLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSPVwiZ2xvcm90Tm9ybWFsXCIsbi5ERUZBVUxUX1JFQ1VSUkVOVF9JTklUSUFMSVpFUj1cIm9ydGhvZ29uYWxcIixuLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUj1cInplcm9zXCIsbi51bml0cz10LnVuaXRzLGFzc2VydFBvc2l0aXZlSW50ZWdlcihuLnVuaXRzLFwidW5pdHNcIiksbi5hY3RpdmF0aW9uPWdldEFjdGl2YXRpb24odm9pZCAwPT09dC5hY3RpdmF0aW9uP24uREVGQVVMVF9BQ1RJVkFUSU9OOnQuYWN0aXZhdGlvbiksbi5yZWN1cnJlbnRBY3RpdmF0aW9uPWdldEFjdGl2YXRpb24odm9pZCAwPT09dC5yZWN1cnJlbnRBY3RpdmF0aW9uP24uREVGQVVMVF9SRUNVUlJFTlRfQUNUSVZBVElPTjp0LnJlY3VycmVudEFjdGl2YXRpb24pLG4udXNlQmlhcz1udWxsPT10LnVzZUJpYXN8fHQudXNlQmlhcyxuLmtlcm5lbEluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQua2VybmVsSW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIpLG4ucmVjdXJyZW50SW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5yZWN1cnJlbnRJbml0aWFsaXplcnx8bi5ERUZBVUxUX1JFQ1VSUkVOVF9JTklUSUFMSVpFUiksbi5iaWFzSW5pdGlhbGl6ZXI9Z2V0SW5pdGlhbGl6ZXIodC5iaWFzSW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKSxuLmtlcm5lbFJlZ3VsYXJpemVyPWdldFJlZ3VsYXJpemVyKHQua2VybmVsUmVndWxhcml6ZXIpLG4ucmVjdXJyZW50UmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5yZWN1cnJlbnRSZWd1bGFyaXplciksbi5iaWFzUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5iaWFzUmVndWxhcml6ZXIpLG4ua2VybmVsQ29uc3RyYWludD1nZXRDb25zdHJhaW50KHQua2VybmVsQ29uc3RyYWludCksbi5yZWN1cnJlbnRDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5yZWN1cnJlbnRDb25zdHJhaW50KSxuLmJpYXNDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5iaWFzQ29uc3RyYWludCksbi5kcm9wb3V0PW1pbiQxKFsxLG1heCQxKFswLG51bGw9PXQuZHJvcG91dD8wOnQuZHJvcG91dF0pXSksbi5yZWN1cnJlbnREcm9wb3V0PW1pbiQxKFsxLG1heCQxKFswLG51bGw9PXQucmVjdXJyZW50RHJvcG91dD8wOnQucmVjdXJyZW50RHJvcG91dF0pXSksbi5pbXBsZW1lbnRhdGlvbj10LmltcGxlbWVudGF0aW9uLG4uc3RhdGVTaXplPW4udW5pdHMsbi5kcm9wb3V0TWFzaz1udWxsLG4ucmVjdXJyZW50RHJvcG91dE1hc2s9bnVsbCxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXt2YXIgdD0oZT1nZXRFeGFjdGx5T25lU2hhcGUoZSkpW2UubGVuZ3RoLTFdO3RoaXMua2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwia2VybmVsXCIsW3QsMyp0aGlzLnVuaXRzXSxudWxsLHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsdGhpcy5rZXJuZWxSZWd1bGFyaXplciwhMCx0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHRoaXMucmVjdXJyZW50S2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwicmVjdXJyZW50X2tlcm5lbFwiLFt0aGlzLnVuaXRzLDMqdGhpcy51bml0c10sbnVsbCx0aGlzLnJlY3VycmVudEluaXRpYWxpemVyLHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIsITAsdGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KSx0aGlzLnVzZUJpYXM/dGhpcy5iaWFzPXRoaXMuYWRkV2VpZ2h0KFwiYmlhc1wiLFszKnRoaXMudW5pdHNdLG51bGwsdGhpcy5iaWFzSW5pdGlhbGl6ZXIsdGhpcy5iaWFzUmVndWxhcml6ZXIsITAsdGhpcy5iaWFzQ29uc3RyYWludCk6dGhpcy5iaWFzPW51bGwsdGhpcy5idWlsdD0hMH0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtpZigyIT09KGU9ZSkubGVuZ3RoKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiR1JVQ2VsbCBleHBlY3RzIDIgaW5wdXQgVGVuc29ycyAoaW5wdXRzLCBoLCBjKSwgZ290IFwiK2UubGVuZ3RoK1wiLlwiKTt2YXIgcj1udWxsIT10LnRyYWluaW5nJiZ0LnRyYWluaW5nLGk9ZVsxXTtlPWVbMF0sMDxuLmRyb3BvdXQmJm4uZHJvcG91dDwxJiZudWxsPT1uLmRyb3BvdXRNYXNrJiYobi5kcm9wb3V0TWFzaz1nZW5lcmF0ZURyb3BvdXRNYXNrKGZ1bmN0aW9uKCl7cmV0dXJuIG9uZXNMaWtlKGUpfSxuLmRyb3BvdXQsciwzKSksMDxuLnJlY3VycmVudERyb3BvdXQmJm4ucmVjdXJyZW50RHJvcG91dDwxJiZudWxsPT1uLnJlY3VycmVudERyb3BvdXRNYXNrJiYobi5yZWN1cnJlbnREcm9wb3V0TWFzaz1nZW5lcmF0ZURyb3BvdXRNYXNrKGZ1bmN0aW9uKCl7cmV0dXJuIG9uZXNMaWtlKGkpfSxuLnJlY3VycmVudERyb3BvdXQsciwzKSk7dmFyIGEsbyxzLGw9bi5kcm9wb3V0TWFzayx1PW4ucmVjdXJyZW50RHJvcG91dE1hc2s7MDxuLmRyb3BvdXQmJm4uZHJvcG91dDwxJiYoZT1tdWwoZSxsWzBdKSk7dmFyIGM9ZG90KGUsbi5rZXJuZWwucmVhZCgpKTtuLnVzZUJpYXMmJihjPWJpYXNBZGQoYyxuLmJpYXMucmVhZCgpKSksMDxuLnJlY3VycmVudERyb3BvdXQmJm4ucmVjdXJyZW50RHJvcG91dDwxJiYoaT1tdWwoaSx1WzBdKSk7dmFyIHA9bi5yZWN1cnJlbnRLZXJuZWwucmVhZCgpLGg9c3BsaXQocCxbMipuLnVuaXRzLG4udW5pdHNdLHAucmFuay0xKSxkPWhbMF0sZj1oWzFdLGc9ZG90KGksZCksbT1zcGxpdChjLDMsYy5yYW5rLTEpLHk9bVswXSx2PW1bMV0sYj1tWzJdLHc9c3BsaXQoZywyLGcucmFuay0xKSx6PXdbMF0sUz13WzFdO2E9bi5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KGFkZCh5LHopKSxvPW4ucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseShhZGQodixTKSk7dmFyIEk9ZG90KG11bChvLGkpLGYpO3M9bi5hY3RpdmF0aW9uLmFwcGx5KGFkZChiLEkpKTt2YXIgQT1hZGQobXVsKGEsaSksbXVsKGFkZCgxLG5lZyhhKSkscykpO3JldHVybltBLEFdfSl9LHQucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3ZhciB0PXt1bml0czp0aGlzLnVuaXRzLGFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLHJlY3VycmVudEFjdGl2YXRpb246c2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLnJlY3VycmVudEFjdGl2YXRpb24pLHVzZUJpYXM6dGhpcy51c2VCaWFzLGtlcm5lbEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLHJlY3VycmVudEluaXRpYWxpemVyOnNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIpLGJpYXNJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksa2VybmVsUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplcikscmVjdXJyZW50UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciksYmlhc1JlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksa2VybmVsQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMua2VybmVsQ29uc3RyYWludCkscmVjdXJyZW50Q29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksYmlhc0NvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KSxkcm9wb3V0OnRoaXMuZHJvcG91dCxyZWN1cnJlbnREcm9wb3V0OnRoaXMucmVjdXJyZW50RHJvcG91dCxpbXBsZW1lbnRhdGlvbjp0aGlzLmltcGxlbWVudGF0aW9ufSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJHUlVDZWxsXCIsdH0oUk5OQ2VsbCk7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEdSVUNlbGwpO3ZhciBHUlU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gMD09PXQuaW1wbGVtZW50YXRpb24mJmNvbnNvbGUud2FybihcImBpbXBsZW1lbnRhdGlvbj0wYCBoYXMgYmVlbiBkZXByZWNhdGVkLCBhbmQgbm93IGRlZmF1bHRzIHRvIGBpbXBsZW1lbnRhdGlvbj0xYC4gUGxlYXNlIHVwZGF0ZSB5b3VyIGxheWVyIGNhbGwuXCIpLHQuY2VsbD1uZXcgR1JVQ2VsbCh0KSxlLmNhbGwodGhpcyx0KXx8dGhpc31yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbih0LG4pe3ZhciByPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtudWxsIT1yLmNlbGwuZHJvcG91dE1hc2smJihkaXNwb3NlKHIuY2VsbC5kcm9wb3V0TWFzayksci5jZWxsLmRyb3BvdXRNYXNrPW51bGwpLG51bGwhPXIuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzayYmKGRpc3Bvc2Uoci5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrKSxyLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2s9bnVsbCk7dmFyIGk9bnVsbD09bj9udWxsOm4ubWFzayxhPW51bGw9PW4/bnVsbDpuLnRyYWluaW5nLG89bnVsbD09bj9udWxsOm4uaW5pdGlhbFN0YXRlO3JldHVybiBlLnByb3RvdHlwZS5jYWxsLmNhbGwocix0LHttYXNrOmksdHJhaW5pbmc6YSxpbml0aWFsU3RhdGU6b30pfSl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInVuaXRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwudW5pdHN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiYWN0aXZhdGlvblwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmFjdGl2YXRpb259LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVjdXJyZW50QWN0aXZhdGlvblwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudEFjdGl2YXRpb259LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidXNlQmlhc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnVzZUJpYXN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwia2VybmVsSW5pdGlhbGl6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5rZXJuZWxJbml0aWFsaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyZWN1cnJlbnRJbml0aWFsaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudEluaXRpYWxpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImJpYXNJbml0aWFsaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmJpYXNJbml0aWFsaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJrZXJuZWxSZWd1bGFyaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmtlcm5lbFJlZ3VsYXJpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJlY3VycmVudFJlZ3VsYXJpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50UmVndWxhcml6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiYmlhc1JlZ3VsYXJpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYmlhc1JlZ3VsYXJpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImtlcm5lbENvbnN0cmFpbnRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5rZXJuZWxDb25zdHJhaW50fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJlY3VycmVudENvbnN0cmFpbnRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRDb25zdHJhaW50fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImJpYXNDb25zdHJhaW50XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYmlhc0NvbnN0cmFpbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiZHJvcG91dFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmRyb3BvdXR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVjdXJyZW50RHJvcG91dFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudERyb3BvdXR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiaW1wbGVtZW50YXRpb25cIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5pbXBsZW1lbnRhdGlvbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17dW5pdHM6dGhpcy51bml0cyxhY3RpdmF0aW9uOnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKSxyZWN1cnJlbnRBY3RpdmF0aW9uOnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uKSx1c2VCaWFzOnRoaXMudXNlQmlhcyxrZXJuZWxJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxyZWN1cnJlbnRJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLnJlY3VycmVudEluaXRpYWxpemVyKSxiaWFzSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLGtlcm5lbFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMua2VybmVsUmVndWxhcml6ZXIpLHJlY3VycmVudFJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIpLGJpYXNSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmJpYXNSZWd1bGFyaXplciksYWN0aXZpdHlSZWd1bGFyaXplcjpzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLGtlcm5lbENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHJlY3VycmVudENvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLGJpYXNDb25zdHJhaW50OnNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5iaWFzQ29uc3RyYWludCksZHJvcG91dDp0aGlzLmRyb3BvdXQscmVjdXJyZW50RHJvcG91dDp0aGlzLnJlY3VycmVudERyb3BvdXQsaW1wbGVtZW50YXRpb246dGhpcy5pbXBsZW1lbnRhdGlvbn0sbj1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKTtyZXR1cm4gZGVsZXRlIG4uY2VsbCxPYmplY3QuYXNzaWduKHQsbiksdH0sdC5mcm9tQ29uZmlnPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIDA9PT10LmltcGxtZW50YXRpb24mJih0LmltcGxlbWVudGF0aW9uPTEpLG5ldyBlKHQpfSx0LmNsYXNzTmFtZT1cIkdSVVwiLHR9KFJOTik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEdSVSk7dmFyIExTVE1DZWxsPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIG4uREVGQVVMVF9BQ1RJVkFUSU9OPVwidGFuaFwiLG4uREVGQVVMVF9SRUNVUlJFTlRfQUNUSVZBVElPTj1cImhhcmRTaWdtb2lkXCIsbi5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUj1cImdsb3JvdE5vcm1hbFwiLG4uREVGQVVMVF9SRUNVUlJFTlRfSU5JVElBTElaRVI9XCJvcnRob2dvbmFsXCIsbi5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVI9XCJ6ZXJvc1wiLG4udW5pdHM9dC51bml0cyxhc3NlcnRQb3NpdGl2ZUludGVnZXIobi51bml0cyxcInVuaXRzXCIpLG4uYWN0aXZhdGlvbj1nZXRBY3RpdmF0aW9uKHZvaWQgMD09PXQuYWN0aXZhdGlvbj9uLkRFRkFVTFRfQUNUSVZBVElPTjp0LmFjdGl2YXRpb24pLG4ucmVjdXJyZW50QWN0aXZhdGlvbj1nZXRBY3RpdmF0aW9uKHZvaWQgMD09PXQucmVjdXJyZW50QWN0aXZhdGlvbj9uLkRFRkFVTFRfUkVDVVJSRU5UX0FDVElWQVRJT046dC5yZWN1cnJlbnRBY3RpdmF0aW9uKSxuLnVzZUJpYXM9bnVsbD09dC51c2VCaWFzfHx0LnVzZUJpYXMsbi5rZXJuZWxJbml0aWFsaXplcj1nZXRJbml0aWFsaXplcih0Lmtlcm5lbEluaXRpYWxpemVyfHxuLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKSxuLnJlY3VycmVudEluaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQucmVjdXJyZW50SW5pdGlhbGl6ZXJ8fG4uREVGQVVMVF9SRUNVUlJFTlRfSU5JVElBTElaRVIpLG4uYmlhc0luaXRpYWxpemVyPWdldEluaXRpYWxpemVyKHQuYmlhc0luaXRpYWxpemVyfHxuLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUiksbi51bml0Rm9yZ2V0Qmlhcz10LnVuaXRGb3JnZXRCaWFzLG4ua2VybmVsUmVndWxhcml6ZXI9Z2V0UmVndWxhcml6ZXIodC5rZXJuZWxSZWd1bGFyaXplciksbi5yZWN1cnJlbnRSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0LnJlY3VycmVudFJlZ3VsYXJpemVyKSxuLmJpYXNSZWd1bGFyaXplcj1nZXRSZWd1bGFyaXplcih0LmJpYXNSZWd1bGFyaXplciksbi5rZXJuZWxDb25zdHJhaW50PWdldENvbnN0cmFpbnQodC5rZXJuZWxDb25zdHJhaW50KSxuLnJlY3VycmVudENvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludCh0LnJlY3VycmVudENvbnN0cmFpbnQpLG4uYmlhc0NvbnN0cmFpbnQ9Z2V0Q29uc3RyYWludCh0LmJpYXNDb25zdHJhaW50KSxuLmRyb3BvdXQ9bWluJDEoWzEsbWF4JDEoWzAsbnVsbD09dC5kcm9wb3V0PzA6dC5kcm9wb3V0XSldKSxuLnJlY3VycmVudERyb3BvdXQ9bWluJDEoWzEsbWF4JDEoWzAsbnVsbD09dC5yZWN1cnJlbnREcm9wb3V0PzA6dC5yZWN1cnJlbnREcm9wb3V0XSldKSxuLmltcGxlbWVudGF0aW9uPXQuaW1wbGVtZW50YXRpb24sbi5zdGF0ZVNpemU9W24udW5pdHMsbi51bml0c10sbi5kcm9wb3V0TWFzaz1udWxsLG4ucmVjdXJyZW50RHJvcG91dE1hc2s9bnVsbCxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbihlKXt2YXIgdCxuLHI9KGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpKVtlLmxlbmd0aC0xXTtpZih0aGlzLmtlcm5lbD10aGlzLmFkZFdlaWdodChcImtlcm5lbFwiLFtyLDQqdGhpcy51bml0c10sbnVsbCx0aGlzLmtlcm5lbEluaXRpYWxpemVyLHRoaXMua2VybmVsUmVndWxhcml6ZXIsITAsdGhpcy5rZXJuZWxDb25zdHJhaW50KSx0aGlzLnJlY3VycmVudEtlcm5lbD10aGlzLmFkZFdlaWdodChcInJlY3VycmVudF9rZXJuZWxcIixbdGhpcy51bml0cyw0KnRoaXMudW5pdHNdLG51bGwsdGhpcy5yZWN1cnJlbnRJbml0aWFsaXplcix0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyLCEwLHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksdGhpcy51c2VCaWFzKXtpZih0aGlzLnVuaXRGb3JnZXRCaWFzKXt2YXIgaT10aGlzLmJpYXNJbml0aWFsaXplcixhPXRoaXMudW5pdHM7bj1uZXcoKHQ9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmFwcGx5PWZ1bmN0aW9uKGUsdCl7dmFyIG49aS5hcHBseShbYV0pLHI9KG5ldyBPbmVzKS5hcHBseShbYV0pLG89aS5hcHBseShbMiphXSk7cmV0dXJuIGNvbmNhdEFsb25nRmlyc3RBeGlzKGNvbmNhdEFsb25nRmlyc3RBeGlzKG4sciksbyl9LHR9KEluaXRpYWxpemVyKSkuY2xhc3NOYW1lPVwiQ3VzdG9tSW5pdFwiLHQpfWVsc2Ugbj10aGlzLmJpYXNJbml0aWFsaXplcjt0aGlzLmJpYXM9dGhpcy5hZGRXZWlnaHQoXCJiaWFzXCIsWzQqdGhpcy51bml0c10sbnVsbCxuLHRoaXMuYmlhc1JlZ3VsYXJpemVyLCEwLHRoaXMuYmlhc0NvbnN0cmFpbnQpfWVsc2UgdGhpcy5iaWFzPW51bGw7dGhpcy5idWlsdD0hMH0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgcj1udWxsIT10LnRyYWluaW5nJiZ0LnRyYWluaW5nO2lmKDMhPT0oZT1lKS5sZW5ndGgpdGhyb3cgbmV3IFZhbHVlRXJyb3IoXCJMU1RNQ2VsbCBleHBlY3RzIDMgaW5wdXQgVGVuc29ycyAoaW5wdXRzLCBoLCBjKSwgZ290IFwiK2UubGVuZ3RoK1wiLlwiKTt2YXIgaT1lWzFdLGE9ZVsyXTtlPWVbMF0sMDxuLmRyb3BvdXQmJm4uZHJvcG91dDwxJiZudWxsPT1uLmRyb3BvdXRNYXNrJiYobi5kcm9wb3V0TWFzaz1nZW5lcmF0ZURyb3BvdXRNYXNrKGZ1bmN0aW9uKCl7cmV0dXJuIG9uZXNMaWtlKGUpfSxuLmRyb3BvdXQsciw0KSksMDxuLnJlY3VycmVudERyb3BvdXQmJm4ucmVjdXJyZW50RHJvcG91dDwxJiZudWxsPT1uLnJlY3VycmVudERyb3BvdXRNYXNrJiYobi5yZWN1cnJlbnREcm9wb3V0TWFzaz1nZW5lcmF0ZURyb3BvdXRNYXNrKGZ1bmN0aW9uKCl7cmV0dXJuIG9uZXNMaWtlKGkpfSxuLnJlY3VycmVudERyb3BvdXQsciw0KSk7dmFyIG8scyxsLHUsYz1uLmRyb3BvdXRNYXNrLHA9bi5yZWN1cnJlbnREcm9wb3V0TWFzazswPG4uZHJvcG91dCYmbi5kcm9wb3V0PDEmJihlPW11bChlLGNbMF0pKTt2YXIgaD1kb3QoZSxuLmtlcm5lbC5yZWFkKCkpOzA8bi5yZWN1cnJlbnREcm9wb3V0JiZuLnJlY3VycmVudERyb3BvdXQ8MSYmKGk9bXVsKGkscFswXSkpLGg9YWRkKGgsZG90KGksbi5yZWN1cnJlbnRLZXJuZWwucmVhZCgpKSksbi51c2VCaWFzJiYoaD1iaWFzQWRkKGgsbi5iaWFzLnJlYWQoKSkpO3ZhciBkPXNwbGl0KGgsNCxoLnJhbmstMSksZj1kWzBdLGc9ZFsxXSxtPWRbMl0seT1kWzNdO289bi5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KGYpLHM9bi5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KGcpLGw9YWRkKG11bChzLGEpLG11bChvLG4uYWN0aXZhdGlvbi5hcHBseShtKSkpLHU9bi5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KHkpO3ZhciB2PW11bCh1LG4uYWN0aXZhdGlvbi5hcHBseShsKSk7cmV0dXJuW3YsdixsXX0pfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17dW5pdHM6dGhpcy51bml0cyxhY3RpdmF0aW9uOnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKSxyZWN1cnJlbnRBY3RpdmF0aW9uOnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uKSx1c2VCaWFzOnRoaXMudXNlQmlhcyxrZXJuZWxJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxyZWN1cnJlbnRJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLnJlY3VycmVudEluaXRpYWxpemVyKSxiaWFzSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLHVuaXRGb3JnZXRCaWFzOnRoaXMudW5pdEZvcmdldEJpYXMsa2VybmVsUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplcikscmVjdXJyZW50UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciksYmlhc1JlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksa2VybmVsQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMua2VybmVsQ29uc3RyYWludCkscmVjdXJyZW50Q29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksYmlhc0NvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KSxkcm9wb3V0OnRoaXMuZHJvcG91dCxyZWN1cnJlbnREcm9wb3V0OnRoaXMucmVjdXJyZW50RHJvcG91dCxpbXBsZW1lbnRhdGlvbjp0aGlzLmltcGxlbWVudGF0aW9ufSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5jbGFzc05hbWU9XCJMU1RNQ2VsbFwiLHR9KFJOTkNlbGwpO3NlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhMU1RNQ2VsbCk7dmFyIExTVE09ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gMD09PXQuaW1wbGVtZW50YXRpb24mJmNvbnNvbGUud2FybihcImBpbXBsZW1lbnRhdGlvbj0wYCBoYXMgYmVlbiBkZXByZWNhdGVkLCBhbmQgbm93IGRlZmF1bHRzIHRvIGBpbXBsZW1lbnRhdGlvbj0xYC4gUGxlYXNlIHVwZGF0ZSB5b3VyIGxheWVyIGNhbGwuXCIpLHQuY2VsbD1uZXcgTFNUTUNlbGwodCksZS5jYWxsKHRoaXMsdCl8fHRoaXN9cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24odCxuKXt2YXIgcj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7bnVsbCE9ci5jZWxsLmRyb3BvdXRNYXNrJiYoZGlzcG9zZShyLmNlbGwuZHJvcG91dE1hc2spLHIuY2VsbC5kcm9wb3V0TWFzaz1udWxsKSxudWxsIT1yLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2smJihkaXNwb3NlKHIuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzayksci5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrPW51bGwpO3ZhciBpPW51bGw9PW4/bnVsbDpuLm1hc2ssYT1udWxsPT1uP251bGw6bi50cmFpbmluZyxvPW51bGw9PW4/bnVsbDpuLmluaXRpYWxTdGF0ZTtyZXR1cm4gZS5wcm90b3R5cGUuY2FsbC5jYWxsKHIsdCx7bWFzazppLHRyYWluaW5nOmEsaW5pdGlhbFN0YXRlOm99KX0pfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ1bml0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnVuaXRzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImFjdGl2YXRpb25cIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5hY3RpdmF0aW9ufSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJlY3VycmVudEFjdGl2YXRpb25cIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRBY3RpdmF0aW9ufSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInVzZUJpYXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC51c2VCaWFzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImtlcm5lbEluaXRpYWxpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwua2VybmVsSW5pdGlhbGl6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVjdXJyZW50SW5pdGlhbGl6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRJbml0aWFsaXplcn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJiaWFzSW5pdGlhbGl6ZXJcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5iaWFzSW5pdGlhbGl6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidW5pdEZvcmdldEJpYXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC51bml0Rm9yZ2V0Qmlhc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJrZXJuZWxSZWd1bGFyaXplclwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmtlcm5lbFJlZ3VsYXJpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJlY3VycmVudFJlZ3VsYXJpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwucmVjdXJyZW50UmVndWxhcml6ZXJ9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiYmlhc1JlZ3VsYXJpemVyXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYmlhc1JlZ3VsYXJpemVyfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImtlcm5lbENvbnN0cmFpbnRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5rZXJuZWxDb25zdHJhaW50fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInJlY3VycmVudENvbnN0cmFpbnRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5yZWN1cnJlbnRDb25zdHJhaW50fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImJpYXNDb25zdHJhaW50XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNlbGwuYmlhc0NvbnN0cmFpbnR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiZHJvcG91dFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLmRyb3BvdXR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmVjdXJyZW50RHJvcG91dFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jZWxsLnJlY3VycmVudERyb3BvdXR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiaW1wbGVtZW50YXRpb25cIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2VsbC5pbXBsZW1lbnRhdGlvbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17dW5pdHM6dGhpcy51bml0cyxhY3RpdmF0aW9uOnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKSxyZWN1cnJlbnRBY3RpdmF0aW9uOnNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uKSx1c2VCaWFzOnRoaXMudXNlQmlhcyxrZXJuZWxJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxyZWN1cnJlbnRJbml0aWFsaXplcjpzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLnJlY3VycmVudEluaXRpYWxpemVyKSxiaWFzSW5pdGlhbGl6ZXI6c2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLHVuaXRGb3JnZXRCaWFzOnRoaXMudW5pdEZvcmdldEJpYXMsa2VybmVsUmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplcikscmVjdXJyZW50UmVndWxhcml6ZXI6c2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciksYmlhc1JlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOnNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksa2VybmVsQ29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMua2VybmVsQ29uc3RyYWludCkscmVjdXJyZW50Q29uc3RyYWludDpzZXJpYWxpemVDb25zdHJhaW50KHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksYmlhc0NvbnN0cmFpbnQ6c2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KSxkcm9wb3V0OnRoaXMuZHJvcG91dCxyZWN1cnJlbnREcm9wb3V0OnRoaXMucmVjdXJyZW50RHJvcG91dCxpbXBsZW1lbnRhdGlvbjp0aGlzLmltcGxlbWVudGF0aW9ufSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBkZWxldGUgbi5jZWxsLE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LmZyb21Db25maWc9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD09PXQuaW1wbG1lbnRhdGlvbiYmKHQuaW1wbGVtZW50YXRpb249MSksbmV3IGUodCl9LHQuY2xhc3NOYW1lPVwiTFNUTVwiLHR9KFJOTik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKExTVE0pO3ZhciBTdGFja2VkUk5OQ2VsbHM9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcztyZXR1cm4gbi5jZWxscz10LmNlbGxzLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInN0YXRlU2l6ZVwiLHtnZXQ6ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wLG49dGhpcy5jZWxscy5zbGljZSgpLnJldmVyc2UoKTt0PG4ubGVuZ3RoO3QrKyl7dmFyIHI9blt0XTtBcnJheS5pc0FycmF5KHIuc3RhdGVTaXplKT9lLnB1c2guYXBwbHkoZSxyLnN0YXRlU2l6ZSk6ZS5wdXNoKHIuc3RhdGVTaXplKX1yZXR1cm4gZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe2Zvcih2YXIgcj0oZT1lKS5zbGljZSgxKSxpPVtdLGE9MCxvPW4uY2VsbHMuc2xpY2UoKS5yZXZlcnNlKCk7YTxvLmxlbmd0aDthKyspe3ZhciBzPW9bYV07QXJyYXkuaXNBcnJheShzLnN0YXRlU2l6ZSk/aS5wdXNoKHIuc3BsaWNlKDAscy5zdGF0ZVNpemUubGVuZ3RoKSk6aS5wdXNoKHIuc3BsaWNlKDAsMSkpfWkucmV2ZXJzZSgpO2Zvcih2YXIgbCx1PVtdLGM9MDtjPG4uY2VsbHMubGVuZ3RoOysrYyl7cz1uLmNlbGxzW2NdO3I9aVtjXSxsPTA9PT1jP1tlWzBdXS5jb25jYXQocik6W2xbMF1dLmNvbmNhdChyKSxsPXMuY2FsbChsLHQpLHUucHVzaChsLnNsaWNlKDEpKX1yPVtdO2Zvcih2YXIgcD0wLGg9dS5zbGljZSgpLnJldmVyc2UoKTtwPGgubGVuZ3RoO3ArKyl7dmFyIGQ9aFtwXTtyLnB1c2guYXBwbHkocixkKX1yZXR1cm5bbFswXV0uY29uY2F0KHIpfSl9LHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe3ZhciB0O2lzQXJyYXlPZlNoYXBlcyhlKSYmKGU9ZVswXSksZT1lO2Zvcih2YXIgbj0wLHI9dGhpcy5jZWxscztuPHIubGVuZ3RoO24rKyl7dmFyIGk9cltuXTtpLmJ1aWxkKGUpLHQ9QXJyYXkuaXNBcnJheShpLnN0YXRlU2l6ZSk/aS5zdGF0ZVNpemVbMF06aS5zdGF0ZVNpemUsZT1bZVswXSx0XX10aGlzLmJ1aWx0PSEwfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sbj0wLHI9dGhpcy5jZWxscztuPHIubGVuZ3RoO24rKyl7dmFyIGk9cltuXTt0LnB1c2goe2NsYXNzTmFtZTp0aGlzLmdldENsYXNzTmFtZSgpLGNvbmZpZzppLmdldENvbmZpZygpfSl9dmFyIGE9e2NlbGxzOnR9LG89ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24oYSxvKSxhfSx0LmZyb21Db25maWc9ZnVuY3Rpb24oZSx0LG4pe3ZvaWQgMD09PW4mJihuPXt9KTtmb3IodmFyIHI9W10saT0wLGE9dC5jZWxscztpPGEubGVuZ3RoO2krKyl7dmFyIG89YVtpXTtyLnB1c2goZGVzZXJpYWxpemUobyxuKSl9cmV0dXJuIG5ldyBlKHtjZWxsczpyfSl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7aWYoIXRoaXMudHJhaW5hYmxlKXJldHVybltdO2Zvcih2YXIgZT1bXSx0PTAsbj10aGlzLmNlbGxzO3Q8bi5sZW5ndGg7dCsrKXt2YXIgcj1uW3RdO2UucHVzaC5hcHBseShlLHIudHJhaW5hYmxlV2VpZ2h0cyl9cmV0dXJuIGV9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwibm9uVHJhaW5hYmxlV2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wLG49dGhpcy5jZWxsczt0PG4ubGVuZ3RoO3QrKyl7dmFyIHI9blt0XTtlLnB1c2guYXBwbHkoZSxyLm5vblRyYWluYWJsZVdlaWdodHMpfWlmKCF0aGlzLnRyYWluYWJsZSl7Zm9yKHZhciBpPVtdLGE9MCxvPXRoaXMuY2VsbHM7YTxvLmxlbmd0aDthKyspe3I9b1thXTtpLnB1c2guYXBwbHkoaSxyLnRyYWluYWJsZVdlaWdodHMpfXJldHVybiBpLmNvbmNhdChlKX1yZXR1cm4gZX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5nZXRXZWlnaHRzPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MCxuPXRoaXMuY2VsbHM7dDxuLmxlbmd0aDt0Kyspe3ZhciByPW5bdF07ZS5wdXNoLmFwcGx5KGUsci53ZWlnaHRzKX1yZXR1cm4gYmF0Y2hHZXRWYWx1ZShlKX0sdC5wcm90b3R5cGUuc2V0V2VpZ2h0cz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9W10sbj0wLHI9dGhpcy5jZWxscztuPHIubGVuZ3RoO24rKylmb3IodmFyIGk9cltuXSxhPWkud2VpZ2h0cy5sZW5ndGgsbz1lLnNwbGljZShhKSxzPTA7czxpLndlaWdodHMubGVuZ3RoOysrcyl0LnB1c2goW2kud2VpZ2h0c1tzXSxvW3NdXSk7YmF0Y2hTZXRWYWx1ZSh0KX0sdC5jbGFzc05hbWU9XCJTdGFja2VkUk5OQ2VsbHNcIix0fShSTk5DZWxsKTtmdW5jdGlvbiBnZW5lcmF0ZURyb3BvdXRNYXNrKGUsdCxuLHIpe2Z1bmN0aW9uIGkoKXtyZXR1cm4gZHJvcG91dChlKCksdCl9aWYodm9pZCAwPT09biYmKG49bnVsbCksdm9pZCAwPT09ciYmKHI9MSkscj4xKXtmb3IodmFyIGE9W10sbz0wO288cjtvKyspYS5wdXNoKGluVHJhaW5QaGFzZShpLGUsbikpO3JldHVybiBhLm1hcChmdW5jdGlvbihlKXtyZXR1cm4ga2VlcChlLmNsb25lKCkpfSl9cmV0dXJuIGtlZXAoaW5UcmFpblBoYXNlKGksZSxuKS5jbG9uZSgpKX1zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoU3RhY2tlZFJOTkNlbGxzKTt2YXIgV3JhcHBlcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLmxheWVyPXQubGF5ZXIsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuYnVpbGQ9ZnVuY3Rpb24oZSl7dGhpcy5idWlsdD0hMH0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidHJhaW5hYmxlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLmxheWVyJiZ0aGlzLmxheWVyLnRyYWluYWJsZX0sc2V0OmZ1bmN0aW9uKGUpe251bGwhPXRoaXMubGF5ZXImJih0aGlzLmxheWVyLnRyYWluYWJsZT1lKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJ0cmFpbmFibGVXZWlnaHRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxheWVyLnRyYWluYWJsZVdlaWdodHN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwibm9uVHJhaW5hYmxlV2VpZ2h0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYXllci5ub25UcmFpbmFibGVXZWlnaHRzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInVwZGF0ZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGF5ZXIuX3VwZGF0ZXN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwibG9zc2VzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxheWVyLmxvc3Nlc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5nZXRXZWlnaHRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGF5ZXIuZ2V0V2VpZ2h0cygpfSx0LnByb3RvdHlwZS5zZXRXZWlnaHRzPWZ1bmN0aW9uKGUpe3RoaXMubGF5ZXIuc2V0V2VpZ2h0cyhlKX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9e2xheWVyOntjbGFzc05hbWU6dGhpcy5sYXllci5nZXRDbGFzc05hbWUoKSxjb25maWc6dGhpcy5sYXllci5nZXRDb25maWcoKX19LG49ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fSx0LnByb3RvdHlwZS5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkPWZ1bmN0aW9uKHQpe2UucHJvdG90eXBlLnNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQuY2FsbCh0aGlzLHQpLG51bGwhPXRoaXMubGF5ZXImJnRoaXMubGF5ZXIuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZCh0KX0sdC5mcm9tQ29uZmlnPWZ1bmN0aW9uKGUsdCxuKXt2b2lkIDA9PT1uJiYobj17fSk7dmFyIHI9ZGVzZXJpYWxpemUodC5sYXllcixuKTtkZWxldGUgdC5sYXllcjt2YXIgaT17bGF5ZXI6cn07cmV0dXJuIE9iamVjdC5hc3NpZ24oaSx0KSxuZXcgZShpKX0sdH0oTGF5ZXIpLFRpbWVEaXN0cmlidXRlZD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLnN1cHBvcnRzTWFza2luZz0hMCxufXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5idWlsZD1mdW5jdGlvbih0KXtpZigodD1nZXRFeGFjdGx5T25lU2hhcGUodCkpLmxlbmd0aDwzKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiVGltZURpc3RyaWJ1dGVkIGxheWVyIGV4cGVjdHMgYW4gaW5wdXQgc2hhcGUgPj0gM0QsIGJ1dCByZWNlaXZlZCBpbnB1dCBzaGFwZSBcIitKU09OLnN0cmluZ2lmeSh0KSk7dGhpcy5pbnB1dFNwZWM9W3tzaGFwZTp0fV07dmFyIG49W3RbMF1dLmNvbmNhdCh0LnNsaWNlKDIpKTt0aGlzLmxheWVyLmJ1aWx0fHwodGhpcy5sYXllci5idWlsZChuKSx0aGlzLmxheWVyLmJ1aWx0PSEwKSxlLnByb3RvdHlwZS5idWlsZC5jYWxsKHRoaXMsdCl9LHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXt2YXIgdD1bKGU9Z2V0RXhhY3RseU9uZVNoYXBlKGUpKVswXV0uY29uY2F0KGUuc2xpY2UoMikpLG49dGhpcy5sYXllci5jb21wdXRlT3V0cHV0U2hhcGUodCkscj1lWzFdO3JldHVybltuWzBdLHJdLmNvbmNhdChuLnNsaWNlKDEpKX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gcm5uKGZ1bmN0aW9uKGUscil7cmV0dXJuW2dldEV4YWN0bHlPbmVUZW5zb3Iobi5sYXllci5jYWxsKGUsdCkpLFtdXX0sZT1nZXRFeGFjdGx5T25lVGVuc29yKGUpLFtdLCExLG51bGwsbnVsbCwhMSwhMClbMV19KX0sdC5jbGFzc05hbWU9XCJUaW1lRGlzdHJpYnV0ZWRcIix0fShXcmFwcGVyKTtmdW5jdGlvbiBjaGVja0JpZGlyZWN0aW9uYWxNZXJnZU1vZGUoZSl7Y2hlY2tTdHJpbmdUeXBlVW5pb25WYWx1ZShWQUxJRF9CSURJUkVDVElPTkFMX01FUkdFX01PREVTLFwiQmlkaXJlY3Rpb25hbE1lcmdlTW9kZVwiLGUpfXNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhUaW1lRGlzdHJpYnV0ZWQpO3ZhciBERUZBVUxUX0JJRElSRUNUSU9OQUxfTUVSR0VfTU9ERT1cImNvbmNhdFwiLEJpZGlyZWN0aW9uYWw9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyx0KXx8dGhpcyxyPXQubGF5ZXIuZ2V0Q29uZmlnKCksaT17fTtpLmNsYXNzTmFtZT10LmxheWVyLmdldENsYXNzTmFtZSgpLGkuY29uZmlnPXIsbi5mb3J3YXJkTGF5ZXI9ZGVzZXJpYWxpemUoaSksci5nb0JhY2t3YXJkcz0hMCE9PXIuZ29CYWNrd2FyZHM7dmFyIGE9e307aWYoYS5jbGFzc05hbWU9dC5sYXllci5nZXRDbGFzc05hbWUoKSxhLmNvbmZpZz1yLG4uYmFja3dhcmRMYXllcj1kZXNlcmlhbGl6ZShhKSxuLmZvcndhcmRMYXllci5uYW1lPVwiZm9yd2FyZF9cIituLmZvcndhcmRMYXllci5uYW1lLG4uYmFja3dhcmRMYXllci5uYW1lPVwiYmFja3dhcmRfXCIrbi5iYWNrd2FyZExheWVyLm5hbWUsbi5tZXJnZU1vZGU9dm9pZCAwPT09dC5tZXJnZU1vZGU/REVGQVVMVF9CSURJUkVDVElPTkFMX01FUkdFX01PREU6dC5tZXJnZU1vZGUsY2hlY2tCaWRpcmVjdGlvbmFsTWVyZ2VNb2RlKG4ubWVyZ2VNb2RlKSx0LndlaWdodHMpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJ3ZWlnaHRzIHN1cHBvcnQgaXMgbm90IGltcGxlbWVudGVkIGZvciBCaWRpcmVjdGlvbmFsIGxheWVyIHlldC5cIik7cmV0dXJuIG4uX3N0YXRlZnVsPXQubGF5ZXIuc3RhdGVmdWwsbi5yZXR1cm5TZXF1ZW5jZXM9dC5sYXllci5yZXR1cm5TZXF1ZW5jZXMsbi5yZXR1cm5TdGF0ZT10LmxheWVyLnJldHVyblN0YXRlLG4uc3VwcG9ydHNNYXNraW5nPSEwLG4uX3RyYWluYWJsZT0hMCxuLmlucHV0U3BlYz10LmxheWVyLmlucHV0U3BlYyxuLm51bUNvbnN0YW50cz1udWxsLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInRyYWluYWJsZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdHJhaW5hYmxlfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fdHJhaW5hYmxlPWUsbnVsbCE9dGhpcy5mb3J3YXJkTGF5ZXImJih0aGlzLmZvcndhcmRMYXllci50cmFpbmFibGU9ZSksbnVsbCE9dGhpcy5iYWNrd2FyZExheWVyJiYodGhpcy5iYWNrd2FyZExheWVyLnRyYWluYWJsZT1lKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5nZXRXZWlnaHRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZm9yd2FyZExheWVyLmdldFdlaWdodHMoKS5jb25jYXQodGhpcy5iYWNrd2FyZExheWVyLmdldFdlaWdodHMoKSl9LHQucHJvdG90eXBlLnNldFdlaWdodHM9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5sZW5ndGgsbj1NYXRoLmZsb29yKHQvMik7dGhpcy5mb3J3YXJkTGF5ZXIuc2V0V2VpZ2h0cyhlLnNsaWNlKDAsbikpLHRoaXMuYmFja3dhcmRMYXllci5zZXRXZWlnaHRzKGUuc2xpY2UobikpfSx0LnByb3RvdHlwZS5jb21wdXRlT3V0cHV0U2hhcGU9ZnVuY3Rpb24oZSl7dmFyIHQsbixyLGk9dGhpcy5mb3J3YXJkTGF5ZXIuY29tcHV0ZU91dHB1dFNoYXBlKGUpO3JldHVybiBBcnJheS5pc0FycmF5KGkpJiZBcnJheS5pc0FycmF5KGlbMF0pfHwoaT1baV0pLGk9aSx0aGlzLnJldHVyblN0YXRlPyhyPWkuc2xpY2UoMSksdD1pWzBdKTp0PWlbMF0sdD10LFwiY29uY2F0XCI9PT10aGlzLm1lcmdlTW9kZT8odFt0Lmxlbmd0aC0xXSo9MixuPVt0XSk6bj1udWxsPT10aGlzLm1lcmdlTW9kZT9bdCx0LnNsaWNlKCldOlt0XSx0aGlzLnJldHVyblN0YXRlP251bGw9PXRoaXMubWVyZ2VNb2RlP24uY29uY2F0KHIpLmNvbmNhdChyLnNsaWNlKCkpOlt0XS5jb25jYXQocikuY29uY2F0KHIuc2xpY2UoKSk6c2luZ2xldG9uT3JBcnJheShuKX0sdC5wcm90b3R5cGUuYXBwbHk9ZnVuY3Rpb24odCxuKXt2YXIgcj1udWxsPT1uP251bGw6bi5pbml0aWFsU3RhdGUsaT1udWxsPT1uP251bGw6bi5jb25zdGFudHM7bnVsbD09biYmKG49e30pO3ZhciBhPXN0YW5kYXJkaXplQXJncyh0LHIsaSx0aGlzLm51bUNvbnN0YW50cyk7aWYodD1hLmlucHV0cyxyPWEuaW5pdGlhbFN0YXRlLGk9YS5jb25zdGFudHMsQXJyYXkuaXNBcnJheSh0KSYmKHI9dC5zbGljZSgxKSx0PXRbMF0pLChudWxsPT1yfHwwPT09ci5sZW5ndGgpJiZudWxsPT1pKXJldHVybiBlLnByb3RvdHlwZS5hcHBseS5jYWxsKHRoaXMsdCxuKTt2YXIgbz1bXSxzPVtdO2lmKG51bGwhPXIpe3ZhciBsPXIubGVuZ3RoO2lmKGwlMj4wKXRocm93IG5ldyBWYWx1ZUVycm9yKFwiV2hlbiBwYXNzaW5nIGBpbml0aWFsU3RhdGVgIHRvIGEgQmlkcmVjdGlvbmFsIFJOTiwgdGhlIHN0YXRlIHNob3VsZCBiZSBhbiBBcnJheSBjb250YWluaW5nIHRoZSBzdGF0ZXMgb2YgdGhlIHVuZGVybHlpbmcgUk5Ocy5cIik7bi5pbml0aWFsU3RhdGU9cixvLnB1c2guYXBwbHkobyxyKTt2YXIgdT1yLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gbmV3IElucHV0U3BlYyh7c2hhcGU6ZS5zaGFwZX0pfSk7dGhpcy5mb3J3YXJkTGF5ZXIuc3RhdGVTcGVjPXUuc2xpY2UoMCxsLzIpLHRoaXMuYmFja3dhcmRMYXllci5zdGF0ZVNwZWM9dS5zbGljZShsLzIpLHMucHVzaC5hcHBseShzLHUpfWlmKG51bGwhPWkpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJTdXBwb3J0IGZvciBjb25zdGFudHMgaW4gQmlkaXJlY3Rpb25hbCBsYXllcnMgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7Zm9yKHZhciBjPW9bMF1pbnN0YW5jZW9mIFN5bWJvbGljVGVuc29yLHA9MCxoPW87cDxoLmxlbmd0aDtwKyspe2lmKGhbcF1pbnN0YW5jZW9mIFN5bWJvbGljVGVuc29yIT09Yyl0aHJvdyBuZXcgVmFsdWVFcnJvcihcIlRoZSBpbml0aWFsIHN0YXRlIG9mIGEgQmlkaXJlY3Rpb25hbCBsYXllciBjYW5ub3QgYmUgc3BlY2lmaWVkIGFzIGEgbWl4IG9mIHN5bWJvbGljIGFuZCBub24tc3ltYm9saWMgdGVuc29yc1wiKX1pZihjKXt2YXIgZD1bdF0uY29uY2F0KG8pLGY9dGhpcy5pbnB1dFNwZWMuY29uY2F0KHMpLGc9dGhpcy5pbnB1dFNwZWM7dGhpcy5pbnB1dFNwZWM9Zjt2YXIgbT1lLnByb3RvdHlwZS5hcHBseS5jYWxsKHRoaXMsZCxuKTtyZXR1cm4gdGhpcy5pbnB1dFNwZWM9ZyxtfXJldHVybiBlLnByb3RvdHlwZS5hcHBseS5jYWxsKHRoaXMsdCxuKX0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtpZihudWxsIT10Lm1hc2spdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJUaGUgc3VwcG9ydCBmb3IgbWFza2luZyBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIEJpZGlyZWN0aW9uYWwgbGF5ZXJzIHlldC5cIik7dmFyIHIsaSxhLG8scz10LmluaXRpYWxTdGF0ZTtpZihudWxsPT1zKXI9bi5mb3J3YXJkTGF5ZXIuY2FsbChlLHQpLGk9bi5iYWNrd2FyZExheWVyLmNhbGwoZSx0KTtlbHNle3ZhciBsPXMuc2xpY2UoMCxzLmxlbmd0aC8yKSx1PXMuc2xpY2Uocy5sZW5ndGgvMik7cj1uLmZvcndhcmRMYXllci5jYWxsKGUsT2JqZWN0LmFzc2lnbih0LHtpbml0aWFsU3RhdGU6bH0pKSxpPW4uYmFja3dhcmRMYXllci5jYWxsKGUsT2JqZWN0LmFzc2lnbih0LHtpbml0aWFsU3RhdGU6dX0pKX1yZXR1cm4gbi5yZXR1cm5TdGF0ZSYmKEFycmF5LmlzQXJyYXkocikmJihhPXIuc2xpY2UoMSkuY29uY2F0KGkuc2xpY2UoMSkpKSxyPXJbMF0saT1pWzBdKSxuLnJldHVyblNlcXVlbmNlcyYmKGk9cmV2ZXJzZShpLDEpKSxcImNvbmNhdFwiPT09bi5tZXJnZU1vZGU/bz1jb25jYXRlbmF0ZShbcixpXSk6XCJzdW1cIj09PW4ubWVyZ2VNb2RlP289YWRkKHIsaSk6XCJhdmVcIj09PW4ubWVyZ2VNb2RlP289bXVsKC41LGFkZChyLGkpKTpcIm11bFwiPT09bi5tZXJnZU1vZGU/bz1tdWwocixpKTpudWxsPT1uLm1lcmdlTW9kZSYmKG89W3IsaV0pLG4ucmV0dXJuU3RhdGU/bnVsbD09bi5tZXJnZU1vZGU/by5jb25jYXQoYSk6W29dLmNvbmNhdChhKTpvfSl9LHQucHJvdG90eXBlLnJlc2V0U3RhdGVzPWZ1bmN0aW9uKGUpe3RoaXMuZm9yd2FyZExheWVyLnJlc2V0U3RhdGVzKCksdGhpcy5iYWNrd2FyZExheWVyLnJlc2V0U3RhdGVzKCl9LHQucHJvdG90eXBlLmJ1aWxkPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7bmFtZVNjb3BlKHRoaXMuZm9yd2FyZExheWVyLm5hbWUsZnVuY3Rpb24oKXt0LmZvcndhcmRMYXllci5idWlsZChlKX0pLG5hbWVTY29wZSh0aGlzLmJhY2t3YXJkTGF5ZXIubmFtZSxmdW5jdGlvbigpe3QuYmFja3dhcmRMYXllci5idWlsZChlKX0pLHRoaXMuYnVpbHQ9ITB9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInRyYWluYWJsZVdlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZm9yd2FyZExheWVyLnRyYWluYWJsZVdlaWdodHMuY29uY2F0KHRoaXMuYmFja3dhcmRMYXllci50cmFpbmFibGVXZWlnaHRzKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJub25UcmFpbmFibGVXZWlnaHRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZvcndhcmRMYXllci5ub25UcmFpbmFibGVXZWlnaHRzLmNvbmNhdCh0aGlzLmJhY2t3YXJkTGF5ZXIubm9uVHJhaW5hYmxlV2VpZ2h0cyl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZD1mdW5jdGlvbih0KXtlLnByb3RvdHlwZS5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkLmNhbGwodGhpcyx0KSxudWxsIT10aGlzLmZvcndhcmRMYXllciYmdGhpcy5mb3J3YXJkTGF5ZXIuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZCh0KSxudWxsIT10aGlzLmJhY2t3YXJkTGF5ZXImJnRoaXMuYmFja3dhcmRMYXllci5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkKHQpfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17bWVyZ2VNb2RlOnRoaXMubWVyZ2VNb2RlfSxuPWUucHJvdG90eXBlLmdldENvbmZpZy5jYWxsKHRoaXMpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH0sdC5mcm9tQ29uZmlnPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZGVzZXJpYWxpemUodC5sYXllcik7aWYoZGVsZXRlIHQubGF5ZXIsbnVsbCE9dC5udW1Db25zdGFudHMpdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXCJEZXNlcmlhbGl6YXRpb24gb2YgYSBCaWRpcmVjdGlvbmFsIGxheWVyIHdpdGggbnVtQ29uc3RhbnRzIHByZXNlbnQgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO3ZhciByPXQ7cmV0dXJuIHIubGF5ZXI9bixuZXcgZShyKX0sdC5jbGFzc05hbWU9XCJCaWRpcmVjdGlvbmFsXCIsdH0oV3JhcHBlcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEJpZGlyZWN0aW9uYWwpO3ZhciBHYXVzc2lhbk5vaXNlPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCl7dmFyIG49ZS5jYWxsKHRoaXMsdCl8fHRoaXM7cmV0dXJuIG4uc3VwcG9ydHNNYXNraW5nPSEwLG4uc3RkZGV2PXQuc3RkZGV2LG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtyZXR1cm4gZX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyksbj17c3RkZGV2OnRoaXMuc3RkZGV2fTtyZXR1cm4gT2JqZWN0LmFzc2lnbihuLHQpLG59LHQucHJvdG90eXBlLmNhbGw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3JldHVybiB0aWR5KGZ1bmN0aW9uKCl7bi5pbnZva2VDYWxsSG9vayhlLHQpO3ZhciByPWdldEV4YWN0bHlPbmVUZW5zb3IoZSk7cmV0dXJuIGluVHJhaW5QaGFzZShmdW5jdGlvbigpe3JldHVybiByYW5kb21Ob3JtYWwkMShyLnNoYXBlLDAsbi5zdGRkZXYpLmFkZChyKX0sZnVuY3Rpb24oKXtyZXR1cm4gcn0sdC50cmFpbmluZ3x8ITEpfSl9LHQuY2xhc3NOYW1lPVwiR2F1c3NpYW5Ob2lzZVwiLHR9KExheWVyKTtzZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR2F1c3NpYW5Ob2lzZSk7dmFyIEdhdXNzaWFuRHJvcG91dD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLnN1cHBvcnRzTWFza2luZz0hMCxuLnJhdGU9dC5yYXRlLG59cmV0dXJuIF9fZXh0ZW5kcyh0LGUpLHQucHJvdG90eXBlLmNvbXB1dGVPdXRwdXRTaGFwZT1mdW5jdGlvbihlKXtyZXR1cm4gZX0sdC5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7dmFyIHQ9ZS5wcm90b3R5cGUuZ2V0Q29uZmlnLmNhbGwodGhpcyksbj17cmF0ZTp0aGlzLnJhdGV9O3JldHVybiBPYmplY3QuYXNzaWduKG4sdCksbn0sdC5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtuLmludm9rZUNhbGxIb29rKGUsdCk7dmFyIHI9Z2V0RXhhY3RseU9uZVRlbnNvcihlKTtpZihuLnJhdGU+MCYmbi5yYXRlPDEpe3JldHVybiBpblRyYWluUGhhc2UoZnVuY3Rpb24oKXt2YXIgZT1NYXRoLnNxcnQobi5yYXRlLygxLW4ucmF0ZSkpO3JldHVybiBkb3QocixyYW5kb21Ob3JtYWwkMShyLnNoYXBlLDEsZSkpfSxmdW5jdGlvbigpe3JldHVybiByfSx0LnRyYWluaW5nfHwhMSl9cmV0dXJuIHJ9KX0sdC5jbGFzc05hbWU9XCJHYXVzc2lhbkRyb3BvdXRcIix0fShMYXllcik7c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEdhdXNzaWFuRHJvcG91dCk7dmFyIEFscGhhRHJvcG91dD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQpe3ZhciBuPWUuY2FsbCh0aGlzLHQpfHx0aGlzO3JldHVybiBuLnN1cHBvcnRzTWFza2luZz0hMCxuLnJhdGU9dC5yYXRlLG4ubm9pc2VTaGFwZT10Lm5vaXNlU2hhcGUsbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUuX2dldE5vaXNlU2hhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubm9pc2VTaGFwZXx8Z2V0RXhhY3RseU9uZVRlbnNvcihlKS5zaGFwZX0sdC5wcm90b3R5cGUuY29tcHV0ZU91dHB1dFNoYXBlPWZ1bmN0aW9uKGUpe3JldHVybiBlfSx0LnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD1lLnByb3RvdHlwZS5nZXRDb25maWcuY2FsbCh0aGlzKSxuPXtyYXRlOnRoaXMucmF0ZX07cmV0dXJuIE9iamVjdC5hc3NpZ24obix0KSxufSx0LnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGlkeShmdW5jdGlvbigpe2lmKG4ucmF0ZTwxJiZuLnJhdGU+MCl7dmFyIHI9bi5fZ2V0Tm9pc2VTaGFwZShlKTtyZXR1cm4gaW5UcmFpblBoYXNlKGZ1bmN0aW9uKCl7dmFyIHQ9Z2V0RXhhY3RseU9uZVRlbnNvcihlKSxpPS0xLjc1ODA5OTM0MDg0NzM3NjYsYT1ncmVhdGVyRXF1YWwocmFuZG9tVW5pZm9ybShyKSxuLnJhdGUpO2E9Y2FzdCQxKGEsXCJmbG9hdDMyXCIpO3ZhciBvPU1hdGgucG93KCgxLW4ucmF0ZSkqKDErbi5yYXRlKk1hdGgucG93KGksMikpLC0uNSkscz0tbyppKm4ucmF0ZTtyZXR1cm4gZG90KHQsYSkuYWRkKGEuYWRkKC0xKS5tdWwoaSkpLm11bChvKS5hZGQocyl9LGZ1bmN0aW9uKCl7cmV0dXJuIGdldEV4YWN0bHlPbmVUZW5zb3IoZSl9LHQudHJhaW5pbmd8fCExKX1yZXR1cm4gZX0pfSx0LmNsYXNzTmFtZT1cIkFscGhhRHJvcG91dFwiLHR9KExheWVyKTtmdW5jdGlvbiBpbnB1dExheWVyKGUpe3JldHVybiBuZXcgSW5wdXRMYXllcihlKX1mdW5jdGlvbiBlbHUkMihlKXtyZXR1cm4gbmV3IEVMVShlKX1mdW5jdGlvbiByZUxVKGUpe3JldHVybiBuZXcgUmVMVShlKX1mdW5jdGlvbiBsZWFreVJlTFUoZSl7cmV0dXJuIG5ldyBMZWFreVJlTFUoZSl9ZnVuY3Rpb24gcHJlbHUkMShlKXtyZXR1cm4gbmV3IFBSZUxVKGUpfWZ1bmN0aW9uIHNvZnRtYXgkMShlKXtyZXR1cm4gbmV3IFNvZnRtYXgkMShlKX1mdW5jdGlvbiB0aHJlc2hvbGRlZFJlTFUoZSl7cmV0dXJuIG5ldyBUaHJlc2hvbGRlZFJlTFUoZSl9ZnVuY3Rpb24gY29udjFkJDIoZSl7cmV0dXJuIG5ldyBDb252MUQoZSl9ZnVuY3Rpb24gY29udjJkJDIoZSl7cmV0dXJuIG5ldyBDb252MkQoZSl9ZnVuY3Rpb24gY29udjJkVHJhbnNwb3NlJDEoZSl7cmV0dXJuIG5ldyBDb252MkRUcmFuc3Bvc2UoZSl9ZnVuY3Rpb24gY29udjNkJDIoZSl7cmV0dXJuIG5ldyBDb252M0QoZSl9ZnVuY3Rpb24gc2VwYXJhYmxlQ29udjJkJDEoZSl7cmV0dXJuIG5ldyBTZXBhcmFibGVDb252MkQoZSl9ZnVuY3Rpb24gY3JvcHBpbmcyRChlKXtyZXR1cm4gbmV3IENyb3BwaW5nMkQoZSl9ZnVuY3Rpb24gdXBTYW1wbGluZzJkKGUpe3JldHVybiBuZXcgVXBTYW1wbGluZzJEKGUpfWZ1bmN0aW9uIGRlcHRod2lzZUNvbnYyZCQyKGUpe3JldHVybiBuZXcgRGVwdGh3aXNlQ29udjJEKGUpfWZ1bmN0aW9uIGFjdGl2YXRpb24oZSl7cmV0dXJuIG5ldyBBY3RpdmF0aW9uJDEoZSl9ZnVuY3Rpb24gZGVuc2UoZSl7cmV0dXJuIG5ldyBEZW5zZShlKX1mdW5jdGlvbiBkcm9wb3V0JDEoZSl7cmV0dXJuIG5ldyBEcm9wb3V0KGUpfWZ1bmN0aW9uIGZsYXR0ZW4kMShlKXtyZXR1cm4gbmV3IEZsYXR0ZW4oZSl9ZnVuY3Rpb24gcmVwZWF0VmVjdG9yKGUpe3JldHVybiBuZXcgUmVwZWF0VmVjdG9yKGUpfWZ1bmN0aW9uIHJlc2hhcGUoZSl7cmV0dXJuIG5ldyBSZXNoYXBlKGUpfWZ1bmN0aW9uIHBlcm11dGUoZSl7cmV0dXJuIG5ldyBQZXJtdXRlKGUpfWZ1bmN0aW9uIGVtYmVkZGluZyhlKXtyZXR1cm4gbmV3IEVtYmVkZGluZyhlKX1mdW5jdGlvbiBhZGQkMihlKXtyZXR1cm4gbmV3IEFkZChlKX1mdW5jdGlvbiBhdmVyYWdlJDEoZSl7cmV0dXJuIG5ldyBBdmVyYWdlKGUpfWZ1bmN0aW9uIGNvbmNhdGVuYXRlJDIoZSl7cmV0dXJuIG5ldyBDb25jYXRlbmF0ZShlKX1mdW5jdGlvbiBtYXhpbXVtJDIoZSl7cmV0dXJuIG5ldyBNYXhpbXVtKGUpfWZ1bmN0aW9uIG1pbmltdW0kMihlKXtyZXR1cm4gbmV3IE1pbmltdW0oZSl9ZnVuY3Rpb24gbXVsdGlwbHkkMShlKXtyZXR1cm4gbmV3IE11bHRpcGx5KGUpfWZ1bmN0aW9uIGRvdCQxKGUpe3JldHVybiBuZXcgRG90KGUpfWZ1bmN0aW9uIGJhdGNoTm9ybWFsaXphdGlvbiQxKGUpe3JldHVybiBuZXcgQmF0Y2hOb3JtYWxpemF0aW9uKGUpfWZ1bmN0aW9uIHplcm9QYWRkaW5nMmQoZSl7cmV0dXJuIG5ldyBaZXJvUGFkZGluZzJEKGUpfWZ1bmN0aW9uIGF2ZXJhZ2VQb29saW5nMWQoZSl7cmV0dXJuIG5ldyBBdmVyYWdlUG9vbGluZzFEKGUpfWZ1bmN0aW9uIGF2Z1Bvb2wxZChlKXtyZXR1cm4gYXZlcmFnZVBvb2xpbmcxZChlKX1mdW5jdGlvbiBhdmdQb29saW5nMWQoZSl7cmV0dXJuIGF2ZXJhZ2VQb29saW5nMWQoZSl9ZnVuY3Rpb24gYXZlcmFnZVBvb2xpbmcyZChlKXtyZXR1cm4gbmV3IEF2ZXJhZ2VQb29saW5nMkQoZSl9ZnVuY3Rpb24gYXZnUG9vbDJkKGUpe3JldHVybiBhdmVyYWdlUG9vbGluZzJkKGUpfWZ1bmN0aW9uIGF2Z1Bvb2xpbmcyZChlKXtyZXR1cm4gYXZlcmFnZVBvb2xpbmcyZChlKX1mdW5jdGlvbiBnbG9iYWxBdmVyYWdlUG9vbGluZzFkKGUpe3JldHVybiBuZXcgR2xvYmFsQXZlcmFnZVBvb2xpbmcxRChlKX1mdW5jdGlvbiBnbG9iYWxBdmVyYWdlUG9vbGluZzJkKGUpe3JldHVybiBuZXcgR2xvYmFsQXZlcmFnZVBvb2xpbmcyRChlKX1mdW5jdGlvbiBnbG9iYWxNYXhQb29saW5nMWQoZSl7cmV0dXJuIG5ldyBHbG9iYWxNYXhQb29saW5nMUQoZSl9ZnVuY3Rpb24gZ2xvYmFsTWF4UG9vbGluZzJkKGUpe3JldHVybiBuZXcgR2xvYmFsTWF4UG9vbGluZzJEKGUpfWZ1bmN0aW9uIG1heFBvb2xpbmcxZChlKXtyZXR1cm4gbmV3IE1heFBvb2xpbmcxRChlKX1mdW5jdGlvbiBtYXhQb29saW5nMmQoZSl7cmV0dXJuIG5ldyBNYXhQb29saW5nMkQoZSl9ZnVuY3Rpb24gZ3J1KGUpe3JldHVybiBuZXcgR1JVKGUpfWZ1bmN0aW9uIGdydUNlbGwoZSl7cmV0dXJuIG5ldyBHUlVDZWxsKGUpfWZ1bmN0aW9uIGxzdG0oZSl7cmV0dXJuIG5ldyBMU1RNKGUpfWZ1bmN0aW9uIGxzdG1DZWxsKGUpe3JldHVybiBuZXcgTFNUTUNlbGwoZSl9ZnVuY3Rpb24gc2ltcGxlUk5OKGUpe3JldHVybiBuZXcgU2ltcGxlUk5OKGUpfWZ1bmN0aW9uIHNpbXBsZVJOTkNlbGwoZSl7cmV0dXJuIG5ldyBTaW1wbGVSTk5DZWxsKGUpfWZ1bmN0aW9uIHJubiQxKGUpe3JldHVybiBuZXcgUk5OKGUpfWZ1bmN0aW9uIHN0YWNrZWRSTk5DZWxscyhlKXtyZXR1cm4gbmV3IFN0YWNrZWRSTk5DZWxscyhlKX1mdW5jdGlvbiBiaWRpcmVjdGlvbmFsKGUpe3JldHVybiBuZXcgQmlkaXJlY3Rpb25hbChlKX1mdW5jdGlvbiB0aW1lRGlzdHJpYnV0ZWQoZSl7cmV0dXJuIG5ldyBUaW1lRGlzdHJpYnV0ZWQoZSl9c2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEFscGhhRHJvcG91dCk7dmFyIGdsb2JhbE1heFBvb2wxZD1nbG9iYWxNYXhQb29saW5nMWQsZ2xvYmFsTWF4UG9vbDJkPWdsb2JhbE1heFBvb2xpbmcyZCxtYXhQb29sMWQ9bWF4UG9vbGluZzFkLG1heFBvb2wyZD1tYXhQb29saW5nMmQ7ZnVuY3Rpb24gZ2F1c3NpYW5Ob2lzZShlKXtyZXR1cm4gbmV3IEdhdXNzaWFuTm9pc2UoZSl9ZnVuY3Rpb24gZ2F1c3NpYW5Ecm9wb3V0KGUpe3JldHVybiBuZXcgR2F1c3NpYW5Ecm9wb3V0KGUpfWZ1bmN0aW9uIGFscGhhRHJvcG91dChlKXtyZXR1cm4gbmV3IEFscGhhRHJvcG91dChlKX1mdW5jdGlvbiBtYXNraW5nKGUpe3JldHVybiBuZXcgTWFza2luZyhlKX12YXIgZXhwb3J0c19sYXllcnM9T2JqZWN0LmZyZWV6ZSh7aW5wdXRMYXllcjppbnB1dExheWVyLGVsdTplbHUkMixyZUxVOnJlTFUsbGVha3lSZUxVOmxlYWt5UmVMVSxwcmVsdTpwcmVsdSQxLHNvZnRtYXg6c29mdG1heCQxLHRocmVzaG9sZGVkUmVMVTp0aHJlc2hvbGRlZFJlTFUsY29udjFkOmNvbnYxZCQyLGNvbnYyZDpjb252MmQkMixjb252MmRUcmFuc3Bvc2U6Y29udjJkVHJhbnNwb3NlJDEsY29udjNkOmNvbnYzZCQyLHNlcGFyYWJsZUNvbnYyZDpzZXBhcmFibGVDb252MmQkMSxjcm9wcGluZzJEOmNyb3BwaW5nMkQsdXBTYW1wbGluZzJkOnVwU2FtcGxpbmcyZCxkZXB0aHdpc2VDb252MmQ6ZGVwdGh3aXNlQ29udjJkJDIsYWN0aXZhdGlvbjphY3RpdmF0aW9uLGRlbnNlOmRlbnNlLGRyb3BvdXQ6ZHJvcG91dCQxLGZsYXR0ZW46ZmxhdHRlbiQxLHJlcGVhdFZlY3RvcjpyZXBlYXRWZWN0b3IscmVzaGFwZTpyZXNoYXBlLHBlcm11dGU6cGVybXV0ZSxlbWJlZGRpbmc6ZW1iZWRkaW5nLGFkZDphZGQkMixhdmVyYWdlOmF2ZXJhZ2UkMSxjb25jYXRlbmF0ZTpjb25jYXRlbmF0ZSQyLG1heGltdW06bWF4aW11bSQyLG1pbmltdW06bWluaW11bSQyLG11bHRpcGx5Om11bHRpcGx5JDEsZG90OmRvdCQxLGJhdGNoTm9ybWFsaXphdGlvbjpiYXRjaE5vcm1hbGl6YXRpb24kMSx6ZXJvUGFkZGluZzJkOnplcm9QYWRkaW5nMmQsYXZlcmFnZVBvb2xpbmcxZDphdmVyYWdlUG9vbGluZzFkLGF2Z1Bvb2wxZDphdmdQb29sMWQsYXZnUG9vbGluZzFkOmF2Z1Bvb2xpbmcxZCxhdmVyYWdlUG9vbGluZzJkOmF2ZXJhZ2VQb29saW5nMmQsYXZnUG9vbDJkOmF2Z1Bvb2wyZCxhdmdQb29saW5nMmQ6YXZnUG9vbGluZzJkLGdsb2JhbEF2ZXJhZ2VQb29saW5nMWQ6Z2xvYmFsQXZlcmFnZVBvb2xpbmcxZCxnbG9iYWxBdmVyYWdlUG9vbGluZzJkOmdsb2JhbEF2ZXJhZ2VQb29saW5nMmQsZ2xvYmFsTWF4UG9vbGluZzFkOmdsb2JhbE1heFBvb2xpbmcxZCxnbG9iYWxNYXhQb29saW5nMmQ6Z2xvYmFsTWF4UG9vbGluZzJkLG1heFBvb2xpbmcxZDptYXhQb29saW5nMWQsbWF4UG9vbGluZzJkOm1heFBvb2xpbmcyZCxncnU6Z3J1LGdydUNlbGw6Z3J1Q2VsbCxsc3RtOmxzdG0sbHN0bUNlbGw6bHN0bUNlbGwsc2ltcGxlUk5OOnNpbXBsZVJOTixzaW1wbGVSTk5DZWxsOnNpbXBsZVJOTkNlbGwscm5uOnJubiQxLHN0YWNrZWRSTk5DZWxsczpzdGFja2VkUk5OQ2VsbHMsYmlkaXJlY3Rpb25hbDpiaWRpcmVjdGlvbmFsLHRpbWVEaXN0cmlidXRlZDp0aW1lRGlzdHJpYnV0ZWQsZ2xvYmFsTWF4UG9vbDFkOmdsb2JhbE1heFBvb2wxZCxnbG9iYWxNYXhQb29sMmQ6Z2xvYmFsTWF4UG9vbDJkLG1heFBvb2wxZDptYXhQb29sMWQsbWF4UG9vbDJkOm1heFBvb2wyZCxMYXllcjpMYXllcixSTk46Uk5OLFJOTkNlbGw6Uk5OQ2VsbCxpbnB1dDppbnB1dCxnYXVzc2lhbk5vaXNlOmdhdXNzaWFuTm9pc2UsZ2F1c3NpYW5Ecm9wb3V0OmdhdXNzaWFuRHJvcG91dCxhbHBoYURyb3BvdXQ6YWxwaGFEcm9wb3V0LG1hc2tpbmc6bWFza2luZ30pO2Z1bmN0aW9uIGJpbmFyeUFjY3VyYWN5JDEoZSx0KXtyZXR1cm4gYmluYXJ5QWNjdXJhY3koZSx0KX1mdW5jdGlvbiBiaW5hcnlDcm9zc2VudHJvcHkkMihlLHQpe3JldHVybiBiaW5hcnlDcm9zc2VudHJvcHkkMShlLHQpfWZ1bmN0aW9uIHNwYXJzZUNhdGVnb3JpY2FsQWNjdXJhY3kkMShlLHQpe3JldHVybiBzcGFyc2VDYXRlZ29yaWNhbEFjY3VyYWN5KGUsdCl9ZnVuY3Rpb24gY2F0ZWdvcmljYWxBY2N1cmFjeSQxKGUsdCl7cmV0dXJuIGNhdGVnb3JpY2FsQWNjdXJhY3koZSx0KX1mdW5jdGlvbiBjYXRlZ29yaWNhbENyb3NzZW50cm9weSQyKGUsdCl7cmV0dXJuIGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5JDEoZSx0KX1mdW5jdGlvbiBwcmVjaXNpb24kMShlLHQpe3JldHVybiBwcmVjaXNpb24oZSx0KX1mdW5jdGlvbiByZWNhbGwkMShlLHQpe3JldHVybiByZWNhbGwoZSx0KX1mdW5jdGlvbiBjb3NpbmVQcm94aW1pdHkkMShlLHQpe3JldHVybiBjb3NpbmVQcm94aW1pdHkoZSx0KX1mdW5jdGlvbiBtZWFuQWJzb2x1dGVFcnJvciQxKGUsdCl7cmV0dXJuIG1lYW5BYnNvbHV0ZUVycm9yKGUsdCl9ZnVuY3Rpb24gbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yJDEoZSx0KXtyZXR1cm4gbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yKGUsdCl9ZnVuY3Rpb24gTUFQRSQyKGUsdCl7cmV0dXJuIG1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcihlLHQpfWZ1bmN0aW9uIG1hcGUkMihlLHQpe3JldHVybiBtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3IoZSx0KX1mdW5jdGlvbiBtZWFuU3F1YXJlZEVycm9yJDEoZSx0KXtyZXR1cm4gbWVhblNxdWFyZWRFcnJvcihlLHQpfWZ1bmN0aW9uIE1TRSQyKGUsdCl7cmV0dXJuIG1lYW5TcXVhcmVkRXJyb3IoZSx0KX1mdW5jdGlvbiBtc2UkMihlLHQpe3JldHVybiBtZWFuU3F1YXJlZEVycm9yKGUsdCl9dmFyIGV4cG9ydHNfbWV0cmljcz1PYmplY3QuZnJlZXplKHtiaW5hcnlBY2N1cmFjeTpiaW5hcnlBY2N1cmFjeSQxLGJpbmFyeUNyb3NzZW50cm9weTpiaW5hcnlDcm9zc2VudHJvcHkkMixzcGFyc2VDYXRlZ29yaWNhbEFjY3VyYWN5OnNwYXJzZUNhdGVnb3JpY2FsQWNjdXJhY3kkMSxjYXRlZ29yaWNhbEFjY3VyYWN5OmNhdGVnb3JpY2FsQWNjdXJhY3kkMSxjYXRlZ29yaWNhbENyb3NzZW50cm9weTpjYXRlZ29yaWNhbENyb3NzZW50cm9weSQyLHByZWNpc2lvbjpwcmVjaXNpb24kMSxyZWNhbGw6cmVjYWxsJDEsY29zaW5lUHJveGltaXR5OmNvc2luZVByb3hpbWl0eSQxLG1lYW5BYnNvbHV0ZUVycm9yOm1lYW5BYnNvbHV0ZUVycm9yJDEsbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yOm1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvciQxLE1BUEU6TUFQRSQyLG1hcGU6bWFwZSQyLG1lYW5TcXVhcmVkRXJyb3I6bWVhblNxdWFyZWRFcnJvciQxLE1TRTpNU0UkMixtc2U6bXNlJDJ9KSxleHBvcnRzX21vZGVscz1PYmplY3QuZnJlZXplKHttb2RlbEZyb21KU09OOm1vZGVsRnJvbUpTT059KTtmdW5jdGlvbiBsMWwyKGUpe3JldHVybiBuZXcgTDFMMihlKX1mdW5jdGlvbiBsMSQxKGUpe3JldHVybiBsMShlKX1mdW5jdGlvbiBsMiQxKGUpe3JldHVybiBsMihlKX12YXIgZXhwb3J0c19yZWd1bGFyaXplcnM9T2JqZWN0LmZyZWV6ZSh7bDFsMjpsMWwyLGwxOmwxJDEsbDI6bDIkMX0pLENhbGxiYWNrPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXt2YXIgdD1udWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7cmV0dXJuIHQubW9kZWw9bnVsbCx0fXJldHVybiBfX2V4dGVuZHModCxlKSx0LnByb3RvdHlwZS5zZXRNb2RlbD1mdW5jdGlvbihlKXtpZighKGUgaW5zdGFuY2VvZiBMYXllcnNNb2RlbCkpdGhyb3cgbmV3IEVycm9yKFwibW9kZWwgbXVzdCBiZSBhIExheWVyc01vZGVsLCBub3Qgc29tZSBvdGhlciBDb250YWluZXJcIik7dGhpcy5tb2RlbD1lfSx0fShCYXNlQ2FsbGJhY2spO2Z1bmN0aW9uIGxlc3MoZSx0KXtyZXR1cm4gZTx0fWZ1bmN0aW9uIGdyZWF0ZXIkMShlLHQpe3JldHVybiBlPnR9dmFyIEVhcmx5U3RvcHBpbmc9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXt2YXIgbj1lLmNhbGwodGhpcyl8fHRoaXM7aWYobnVsbD09dCYmKHQ9e30pLHQucmVzdG9yZUJlc3RXZWlnaHRzKXRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFwicmVzdG9yZUJlc3RXZWlnaHRzID0gVHJ1ZSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gRWFybHlTdG9wcGluZyB5ZXQuXCIpO3JldHVybiBuLm1vbml0b3I9dC5tb25pdG9yfHxcInZhbF9sb3NzXCIsbi5taW5EZWx0YT1NYXRoLmFicyh0Lm1pbkRlbHRhfHwwKSxuLnBhdGllbmNlPXQucGF0aWVuY2V8fDAsbi52ZXJib3NlPXQudmVyYm9zZXx8MCxuLm1vZGU9dC5tb2RlfHxcImF1dG9cIixuLmJhc2VsaW5lPXQuYmFzZWxpbmUsLTE9PT1bXCJhdXRvXCIsXCJtaW5cIixcIm1heFwiXS5pbmRleE9mKG4ubW9kZSkmJihjb25zb2xlLndhcm4oXCJFYXJseVN0b3BwaW5nIG1vZGUgJ1wiK24ubW9kZStcIicgaXMgaW52YWxpZC4gRmFsbGluZyBiYWNrIHRvIG1vZGUgJ2F1dG8nLlwiKSxuLm1vZGU9XCJhdXRvXCIpLFwibWluXCI9PT1uLm1vZGU/bi5tb25pdG9yRnVuYz1sZXNzOlwibWF4XCI9PT1uLm1vZGU/bi5tb25pdG9yRnVuYz1ncmVhdGVyJDE6LTEhPT1uLm1vbml0b3IuaW5kZXhPZihcImFjY1wiKT9uLm1vbml0b3JGdW5jPWdyZWF0ZXIkMTpuLm1vbml0b3JGdW5jPWxlc3Msbi5tb25pdG9yRnVuYz09PWxlc3MmJihuLm1pbkRlbHRhKj0tMSksbn1yZXR1cm4gX19leHRlbmRzKHQsZSksdC5wcm90b3R5cGUub25UcmFpbkJlZ2luPWZ1bmN0aW9uKGUpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMud2FpdD0wLHRoaXMuc3RvcHBlZEVwb2NoPTAsbnVsbCE9dGhpcy5iYXNlbGluZT90aGlzLmJlc3Q9dGhpcy5iYXNlbGluZTp0aGlzLmJlc3Q9dGhpcy5tb25pdG9yRnVuYz09PWxlc3M/MS8wOi0xLzAsWzJdfSl9KX0sdC5wcm90b3R5cGUub25FcG9jaEVuZD1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxyZXNvbHZlU2NhbGFyc0luTG9ncyh0KV07Y2FzZSAxOnJldHVybiByLnNlbnQoKSxudWxsPT0obj10aGlzLmdldE1vbml0b3JWYWx1ZSh0KSk/WzJdOih0aGlzLm1vbml0b3JGdW5jKG4tdGhpcy5taW5EZWx0YSx0aGlzLmJlc3QpPyh0aGlzLmJlc3Q9bix0aGlzLndhaXQ9MCk6KHRoaXMud2FpdCsrLHRoaXMud2FpdD49dGhpcy5wYXRpZW5jZSYmKHRoaXMuc3RvcHBlZEVwb2NoPWUsdGhpcy5tb2RlbC5zdG9wVHJhaW5pbmc9ITApKSxbMl0pfX0pfSl9LHQucHJvdG90eXBlLm9uVHJhaW5FbmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIF9fYXdhaXRlcih0aGlzLHZvaWQgMCx2b2lkIDAsZnVuY3Rpb24oKXtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5zdG9wcGVkRXBvY2g+MCYmdGhpcy52ZXJib3NlJiZjb25zb2xlLmxvZyhcIkVwb2NoIFwiK3RoaXMuc3RvcHBlZEVwb2NoK1wiOiBlYXJseSBzdG9wcGluZy5cIiksWzJdfSl9KX0sdC5wcm90b3R5cGUuZ2V0TW9uaXRvclZhbHVlPWZ1bmN0aW9uKGUpe251bGw9PWUmJihlPXt9KTt2YXIgdD1lW3RoaXMubW9uaXRvcl07cmV0dXJuIG51bGw9PXQmJmNvbnNvbGUud2FybihcIk1ldHJpYyBmb3IgRWFybHlTdG9wcGluZyBcIit0aGlzLm1vbml0b3IrXCIgaXMgbm90IGF2YWlsYWJsZS4gQXZhaWxhYmxlIG1ldHJpY3MgYXJlOiBcIitPYmplY3Qua2V5cyhlKSksdH0sdH0oQ2FsbGJhY2spO2Z1bmN0aW9uIGVhcmx5U3RvcHBpbmcoZSl7cmV0dXJuIG5ldyBFYXJseVN0b3BwaW5nKGUpfXZhciBjYWxsYmFja3M9e2Vhcmx5U3RvcHBpbmc6ZWFybHlTdG9wcGluZ307ZXhwb3J0e2V4cG9ydHNfY29uc3RyYWludHMgYXMgY29uc3RyYWludHMsZXhwb3J0c19pbml0aWFsaXplcnMgYXMgaW5pdGlhbGl6ZXJzLGV4cG9ydHNfbGF5ZXJzIGFzIGxheWVycyxleHBvcnRzX21ldHJpY3MgYXMgbWV0cmljcyxleHBvcnRzX21vZGVscyBhcyBtb2RlbHMsZXhwb3J0c19yZWd1bGFyaXplcnMgYXMgcmVndWxhcml6ZXJzLENhbGxiYWNrTGlzdCxDdXN0b21DYWxsYmFjayxIaXN0b3J5LENhbGxiYWNrLGNhbGxiYWNrcyxFYXJseVN0b3BwaW5nLElucHV0U3BlYyxTeW1ib2xpY1RlbnNvcixMYXllcnNNb2RlbCxpbnB1dCxsb2FkTGF5ZXJzTW9kZWwsbW9kZWwscmVnaXN0ZXJDYWxsYmFja0NvbnN0cnVjdG9yLHNlcXVlbnRpYWwsUk5OLFNlcXVlbnRpYWwsTGF5ZXJWYXJpYWJsZSx2ZXJzaW9uIGFzIHZlcnNpb25fbGF5ZXJzfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRmLWxheWVycy5lc20uanMubWFwXG4iLCIvLyBAdGVuc29yZmxvdy90ZmpzIENvcHlyaWdodCAyMDE5IEdvb2dsZVxuaW1wb3J0e3ZlcnNpb25fY29yZX1mcm9tXCJAdGVuc29yZmxvdy90ZmpzLWNvcmVcIjtleHBvcnQqZnJvbVwiQHRlbnNvcmZsb3cvdGZqcy1jb3JlXCI7aW1wb3J0e3ZlcnNpb25fbGF5ZXJzfWZyb21cIkB0ZW5zb3JmbG93L3RmanMtbGF5ZXJzXCI7ZXhwb3J0KmZyb21cIkB0ZW5zb3JmbG93L3RmanMtbGF5ZXJzXCI7aW1wb3J0e3ZlcnNpb25fY29udmVydGVyfWZyb21cIkB0ZW5zb3JmbG93L3RmanMtY29udmVydGVyXCI7ZXhwb3J0KmZyb21cIkB0ZW5zb3JmbG93L3RmanMtY29udmVydGVyXCI7aW1wb3J0KmFzIHRmanNEYXRhIGZyb21cIkB0ZW5zb3JmbG93L3RmanMtZGF0YVwiO2ltcG9ydHt2ZXJzaW9uX2RhdGF9ZnJvbVwiQHRlbnNvcmZsb3cvdGZqcy1kYXRhXCI7ZXhwb3J0e3RmanNEYXRhIGFzIGRhdGF9O3ZhciB2ZXJzaW9uPVwiMS4xLjJcIix2ZXJzaW9uJDE9e1widGZqcy1jb3JlXCI6dmVyc2lvbl9jb3JlLFwidGZqcy1kYXRhXCI6dmVyc2lvbl9kYXRhLFwidGZqcy1sYXllcnNcIjp2ZXJzaW9uX2xheWVycyxcInRmanMtY29udmVydGVyXCI6dmVyc2lvbl9jb252ZXJ0ZXIsdGZqczp2ZXJzaW9ufTtleHBvcnR7dmVyc2lvbiQxIGFzIHZlcnNpb259O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGYuZXNtLmpzLm1hcFxuIiwidmFyIGFzbjEgPSBleHBvcnRzO1xuXG5hc24xLmJpZ251bSA9IHJlcXVpcmUoJ2JuLmpzJyk7XG5cbmFzbjEuZGVmaW5lID0gcmVxdWlyZSgnLi9hc24xL2FwaScpLmRlZmluZTtcbmFzbjEuYmFzZSA9IHJlcXVpcmUoJy4vYXNuMS9iYXNlJyk7XG5hc24xLmNvbnN0YW50cyA9IHJlcXVpcmUoJy4vYXNuMS9jb25zdGFudHMnKTtcbmFzbjEuZGVjb2RlcnMgPSByZXF1aXJlKCcuL2FzbjEvZGVjb2RlcnMnKTtcbmFzbjEuZW5jb2RlcnMgPSByZXF1aXJlKCcuL2FzbjEvZW5jb2RlcnMnKTtcbiIsInZhciBhc24xID0gcmVxdWlyZSgnLi4vYXNuMScpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxudmFyIGFwaSA9IGV4cG9ydHM7XG5cbmFwaS5kZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUobmFtZSwgYm9keSkge1xuICByZXR1cm4gbmV3IEVudGl0eShuYW1lLCBib2R5KTtcbn07XG5cbmZ1bmN0aW9uIEVudGl0eShuYW1lLCBib2R5KSB7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgdGhpcy5kZWNvZGVycyA9IHt9O1xuICB0aGlzLmVuY29kZXJzID0ge307XG59O1xuXG5FbnRpdHkucHJvdG90eXBlLl9jcmVhdGVOYW1lZCA9IGZ1bmN0aW9uIGNyZWF0ZU5hbWVkKGJhc2UpIHtcbiAgdmFyIG5hbWVkO1xuICB0cnkge1xuICAgIG5hbWVkID0gcmVxdWlyZSgndm0nKS5ydW5JblRoaXNDb250ZXh0KFxuICAgICAgJyhmdW5jdGlvbiAnICsgdGhpcy5uYW1lICsgJyhlbnRpdHkpIHtcXG4nICtcbiAgICAgICcgIHRoaXMuX2luaXROYW1lZChlbnRpdHkpO1xcbicgK1xuICAgICAgJ30pJ1xuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBuYW1lZCA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcbiAgICAgIHRoaXMuX2luaXROYW1lZChlbnRpdHkpO1xuICAgIH07XG4gIH1cbiAgaW5oZXJpdHMobmFtZWQsIGJhc2UpO1xuICBuYW1lZC5wcm90b3R5cGUuX2luaXROYW1lZCA9IGZ1bmN0aW9uIGluaXRuYW1lZChlbnRpdHkpIHtcbiAgICBiYXNlLmNhbGwodGhpcywgZW50aXR5KTtcbiAgfTtcblxuICByZXR1cm4gbmV3IG5hbWVkKHRoaXMpO1xufTtcblxuRW50aXR5LnByb3RvdHlwZS5fZ2V0RGVjb2RlciA9IGZ1bmN0aW9uIF9nZXREZWNvZGVyKGVuYykge1xuICBlbmMgPSBlbmMgfHwgJ2Rlcic7XG4gIC8vIExhemlseSBjcmVhdGUgZGVjb2RlclxuICBpZiAoIXRoaXMuZGVjb2RlcnMuaGFzT3duUHJvcGVydHkoZW5jKSlcbiAgICB0aGlzLmRlY29kZXJzW2VuY10gPSB0aGlzLl9jcmVhdGVOYW1lZChhc24xLmRlY29kZXJzW2VuY10pO1xuICByZXR1cm4gdGhpcy5kZWNvZGVyc1tlbmNdO1xufTtcblxuRW50aXR5LnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoZGF0YSwgZW5jLCBvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLl9nZXREZWNvZGVyKGVuYykuZGVjb2RlKGRhdGEsIG9wdGlvbnMpO1xufTtcblxuRW50aXR5LnByb3RvdHlwZS5fZ2V0RW5jb2RlciA9IGZ1bmN0aW9uIF9nZXRFbmNvZGVyKGVuYykge1xuICBlbmMgPSBlbmMgfHwgJ2Rlcic7XG4gIC8vIExhemlseSBjcmVhdGUgZW5jb2RlclxuICBpZiAoIXRoaXMuZW5jb2RlcnMuaGFzT3duUHJvcGVydHkoZW5jKSlcbiAgICB0aGlzLmVuY29kZXJzW2VuY10gPSB0aGlzLl9jcmVhdGVOYW1lZChhc24xLmVuY29kZXJzW2VuY10pO1xuICByZXR1cm4gdGhpcy5lbmNvZGVyc1tlbmNdO1xufTtcblxuRW50aXR5LnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZGF0YSwgZW5jLCAvKiBpbnRlcm5hbCAqLyByZXBvcnRlcikge1xuICByZXR1cm4gdGhpcy5fZ2V0RW5jb2RlcihlbmMpLmVuY29kZShkYXRhLCByZXBvcnRlcik7XG59O1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBSZXBvcnRlciA9IHJlcXVpcmUoJy4uL2Jhc2UnKS5SZXBvcnRlcjtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbmZ1bmN0aW9uIERlY29kZXJCdWZmZXIoYmFzZSwgb3B0aW9ucykge1xuICBSZXBvcnRlci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiYXNlKSkge1xuICAgIHRoaXMuZXJyb3IoJ0lucHV0IG5vdCBCdWZmZXInKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmJhc2UgPSBiYXNlO1xuICB0aGlzLm9mZnNldCA9IDA7XG4gIHRoaXMubGVuZ3RoID0gYmFzZS5sZW5ndGg7XG59XG5pbmhlcml0cyhEZWNvZGVyQnVmZmVyLCBSZXBvcnRlcik7XG5leHBvcnRzLkRlY29kZXJCdWZmZXIgPSBEZWNvZGVyQnVmZmVyO1xuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gc2F2ZSgpIHtcbiAgcmV0dXJuIHsgb2Zmc2V0OiB0aGlzLm9mZnNldCwgcmVwb3J0ZXI6IFJlcG9ydGVyLnByb3RvdHlwZS5zYXZlLmNhbGwodGhpcykgfTtcbn07XG5cbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbiByZXN0b3JlKHNhdmUpIHtcbiAgLy8gUmV0dXJuIHNraXBwZWQgZGF0YVxuICB2YXIgcmVzID0gbmV3IERlY29kZXJCdWZmZXIodGhpcy5iYXNlKTtcbiAgcmVzLm9mZnNldCA9IHNhdmUub2Zmc2V0O1xuICByZXMubGVuZ3RoID0gdGhpcy5vZmZzZXQ7XG5cbiAgdGhpcy5vZmZzZXQgPSBzYXZlLm9mZnNldDtcbiAgUmVwb3J0ZXIucHJvdG90eXBlLnJlc3RvcmUuY2FsbCh0aGlzLCBzYXZlLnJlcG9ydGVyKTtcblxuICByZXR1cm4gcmVzO1xufTtcblxuRGVjb2RlckJ1ZmZlci5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gIHJldHVybiB0aGlzLm9mZnNldCA9PT0gdGhpcy5sZW5ndGg7XG59O1xuXG5EZWNvZGVyQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDgoZmFpbCkge1xuICBpZiAodGhpcy5vZmZzZXQgKyAxIDw9IHRoaXMubGVuZ3RoKVxuICAgIHJldHVybiB0aGlzLmJhc2UucmVhZFVJbnQ4KHRoaXMub2Zmc2V0KyssIHRydWUpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuZXJyb3IoZmFpbCB8fCAnRGVjb2RlckJ1ZmZlciBvdmVycnVuJyk7XG59XG5cbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiBza2lwKGJ5dGVzLCBmYWlsKSB7XG4gIGlmICghKHRoaXMub2Zmc2V0ICsgYnl0ZXMgPD0gdGhpcy5sZW5ndGgpKVxuICAgIHJldHVybiB0aGlzLmVycm9yKGZhaWwgfHwgJ0RlY29kZXJCdWZmZXIgb3ZlcnJ1bicpO1xuXG4gIHZhciByZXMgPSBuZXcgRGVjb2RlckJ1ZmZlcih0aGlzLmJhc2UpO1xuXG4gIC8vIFNoYXJlIHJlcG9ydGVyIHN0YXRlXG4gIHJlcy5fcmVwb3J0ZXJTdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG5cbiAgcmVzLm9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICByZXMubGVuZ3RoID0gdGhpcy5vZmZzZXQgKyBieXRlcztcbiAgdGhpcy5vZmZzZXQgKz0gYnl0ZXM7XG4gIHJldHVybiByZXM7XG59XG5cbkRlY29kZXJCdWZmZXIucHJvdG90eXBlLnJhdyA9IGZ1bmN0aW9uIHJhdyhzYXZlKSB7XG4gIHJldHVybiB0aGlzLmJhc2Uuc2xpY2Uoc2F2ZSA/IHNhdmUub2Zmc2V0IDogdGhpcy5vZmZzZXQsIHRoaXMubGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gRW5jb2RlckJ1ZmZlcih2YWx1ZSwgcmVwb3J0ZXIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIEVuY29kZXJCdWZmZXIpKVxuICAgICAgICBpdGVtID0gbmV3IEVuY29kZXJCdWZmZXIoaXRlbSwgcmVwb3J0ZXIpO1xuICAgICAgdGhpcy5sZW5ndGggKz0gaXRlbS5sZW5ndGg7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9LCB0aGlzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKCEoMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSAweGZmKSlcbiAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignbm9uLWJ5dGUgRW5jb2RlckJ1ZmZlciB2YWx1ZScpO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlKTtcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXBvcnRlci5lcnJvcignVW5zdXBwb3J0ZWQgdHlwZTogJyArIHR5cGVvZiB2YWx1ZSk7XG4gIH1cbn1cbmV4cG9ydHMuRW5jb2RlckJ1ZmZlciA9IEVuY29kZXJCdWZmZXI7XG5cbkVuY29kZXJCdWZmZXIucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKG91dCwgb2Zmc2V0KSB7XG4gIGlmICghb3V0KVxuICAgIG91dCA9IG5ldyBCdWZmZXIodGhpcy5sZW5ndGgpO1xuICBpZiAoIW9mZnNldClcbiAgICBvZmZzZXQgPSAwO1xuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gb3V0O1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpKSB7XG4gICAgdGhpcy52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIGl0ZW0uam9pbihvdXQsIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gaXRlbS5sZW5ndGg7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgIG91dFtvZmZzZXRdID0gdGhpcy52YWx1ZTtcbiAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICBvdXQud3JpdGUodGhpcy52YWx1ZSwgb2Zmc2V0KTtcbiAgICBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodGhpcy52YWx1ZSkpXG4gICAgICB0aGlzLnZhbHVlLmNvcHkob3V0LCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuIiwidmFyIGJhc2UgPSBleHBvcnRzO1xuXG5iYXNlLlJlcG9ydGVyID0gcmVxdWlyZSgnLi9yZXBvcnRlcicpLlJlcG9ydGVyO1xuYmFzZS5EZWNvZGVyQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXInKS5EZWNvZGVyQnVmZmVyO1xuYmFzZS5FbmNvZGVyQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXInKS5FbmNvZGVyQnVmZmVyO1xuYmFzZS5Ob2RlID0gcmVxdWlyZSgnLi9ub2RlJyk7XG4iLCJ2YXIgUmVwb3J0ZXIgPSByZXF1aXJlKCcuLi9iYXNlJykuUmVwb3J0ZXI7XG52YXIgRW5jb2RlckJ1ZmZlciA9IHJlcXVpcmUoJy4uL2Jhc2UnKS5FbmNvZGVyQnVmZmVyO1xudmFyIERlY29kZXJCdWZmZXIgPSByZXF1aXJlKCcuLi9iYXNlJykuRGVjb2RlckJ1ZmZlcjtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG5cbi8vIFN1cHBvcnRlZCB0YWdzXG52YXIgdGFncyA9IFtcbiAgJ3NlcScsICdzZXFvZicsICdzZXQnLCAnc2V0b2YnLCAnb2JqaWQnLCAnYm9vbCcsXG4gICdnZW50aW1lJywgJ3V0Y3RpbWUnLCAnbnVsbF8nLCAnZW51bScsICdpbnQnLCAnb2JqRGVzYycsXG4gICdiaXRzdHInLCAnYm1wc3RyJywgJ2NoYXJzdHInLCAnZ2Vuc3RyJywgJ2dyYXBoc3RyJywgJ2lhNXN0cicsICdpc282NDZzdHInLFxuICAnbnVtc3RyJywgJ29jdHN0cicsICdwcmludHN0cicsICd0NjFzdHInLCAndW5pc3RyJywgJ3V0ZjhzdHInLCAndmlkZW9zdHInXG5dO1xuXG4vLyBQdWJsaWMgbWV0aG9kcyBsaXN0XG52YXIgbWV0aG9kcyA9IFtcbiAgJ2tleScsICdvYmonLCAndXNlJywgJ29wdGlvbmFsJywgJ2V4cGxpY2l0JywgJ2ltcGxpY2l0JywgJ2RlZicsICdjaG9pY2UnLFxuICAnYW55JywgJ2NvbnRhaW5zJ1xuXS5jb25jYXQodGFncyk7XG5cbi8vIE92ZXJyaWRlZCBtZXRob2RzIGxpc3RcbnZhciBvdmVycmlkZWQgPSBbXG4gICdfcGVla1RhZycsICdfZGVjb2RlVGFnJywgJ191c2UnLFxuICAnX2RlY29kZVN0cicsICdfZGVjb2RlT2JqaWQnLCAnX2RlY29kZVRpbWUnLFxuICAnX2RlY29kZU51bGwnLCAnX2RlY29kZUludCcsICdfZGVjb2RlQm9vbCcsICdfZGVjb2RlTGlzdCcsXG5cbiAgJ19lbmNvZGVDb21wb3NpdGUnLCAnX2VuY29kZVN0cicsICdfZW5jb2RlT2JqaWQnLCAnX2VuY29kZVRpbWUnLFxuICAnX2VuY29kZU51bGwnLCAnX2VuY29kZUludCcsICdfZW5jb2RlQm9vbCdcbl07XG5cbmZ1bmN0aW9uIE5vZGUoZW5jLCBwYXJlbnQpIHtcbiAgdmFyIHN0YXRlID0ge307XG4gIHRoaXMuX2Jhc2VTdGF0ZSA9IHN0YXRlO1xuXG4gIHN0YXRlLmVuYyA9IGVuYztcblxuICBzdGF0ZS5wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcbiAgc3RhdGUuY2hpbGRyZW4gPSBudWxsO1xuXG4gIC8vIFN0YXRlXG4gIHN0YXRlLnRhZyA9IG51bGw7XG4gIHN0YXRlLmFyZ3MgPSBudWxsO1xuICBzdGF0ZS5yZXZlcnNlQXJncyA9IG51bGw7XG4gIHN0YXRlLmNob2ljZSA9IG51bGw7XG4gIHN0YXRlLm9wdGlvbmFsID0gZmFsc2U7XG4gIHN0YXRlLmFueSA9IGZhbHNlO1xuICBzdGF0ZS5vYmogPSBmYWxzZTtcbiAgc3RhdGUudXNlID0gbnVsbDtcbiAgc3RhdGUudXNlRGVjb2RlciA9IG51bGw7XG4gIHN0YXRlLmtleSA9IG51bGw7XG4gIHN0YXRlWydkZWZhdWx0J10gPSBudWxsO1xuICBzdGF0ZS5leHBsaWNpdCA9IG51bGw7XG4gIHN0YXRlLmltcGxpY2l0ID0gbnVsbDtcbiAgc3RhdGUuY29udGFpbnMgPSBudWxsO1xuXG4gIC8vIFNob3VsZCBjcmVhdGUgbmV3IGluc3RhbmNlIG9uIGVhY2ggbWV0aG9kXG4gIGlmICghc3RhdGUucGFyZW50KSB7XG4gICAgc3RhdGUuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLl93cmFwKCk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gTm9kZTtcblxudmFyIHN0YXRlUHJvcHMgPSBbXG4gICdlbmMnLCAncGFyZW50JywgJ2NoaWxkcmVuJywgJ3RhZycsICdhcmdzJywgJ3JldmVyc2VBcmdzJywgJ2Nob2ljZScsXG4gICdvcHRpb25hbCcsICdhbnknLCAnb2JqJywgJ3VzZScsICdhbHRlcmVkVXNlJywgJ2tleScsICdkZWZhdWx0JywgJ2V4cGxpY2l0JyxcbiAgJ2ltcGxpY2l0JywgJ2NvbnRhaW5zJ1xuXTtcblxuTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICB2YXIgY3N0YXRlID0ge307XG4gIHN0YXRlUHJvcHMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgY3N0YXRlW3Byb3BdID0gc3RhdGVbcHJvcF07XG4gIH0pO1xuICB2YXIgcmVzID0gbmV3IHRoaXMuY29uc3RydWN0b3IoY3N0YXRlLnBhcmVudCk7XG4gIHJlcy5fYmFzZVN0YXRlID0gY3N0YXRlO1xuICByZXR1cm4gcmVzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX3dyYXAgPSBmdW5jdGlvbiB3cmFwKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICB0aGlzW21ldGhvZF0gPSBmdW5jdGlvbiBfd3JhcHBlZE1ldGhvZCgpIHtcbiAgICAgIHZhciBjbG9uZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgc3RhdGUuY2hpbGRyZW4ucHVzaChjbG9uZSk7XG4gICAgICByZXR1cm4gY2xvbmVbbWV0aG9kXS5hcHBseShjbG9uZSwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9LCB0aGlzKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdChib2R5KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUucGFyZW50ID09PSBudWxsKTtcbiAgYm9keS5jYWxsKHRoaXMpO1xuXG4gIC8vIEZpbHRlciBjaGlsZHJlblxuICBzdGF0ZS5jaGlsZHJlbiA9IHN0YXRlLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbihjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZC5fYmFzZVN0YXRlLnBhcmVudCA9PT0gdGhpcztcbiAgfSwgdGhpcyk7XG4gIGFzc2VydC5lcXVhbChzdGF0ZS5jaGlsZHJlbi5sZW5ndGgsIDEsICdSb290IG5vZGUgY2FuIGhhdmUgb25seSBvbmUgY2hpbGQnKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl91c2VBcmdzID0gZnVuY3Rpb24gdXNlQXJncyhhcmdzKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICAvLyBGaWx0ZXIgY2hpbGRyZW4gYW5kIGFyZ3NcbiAgdmFyIGNoaWxkcmVuID0gYXJncy5maWx0ZXIoZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3I7XG4gIH0sIHRoaXMpO1xuICBhcmdzID0gYXJncy5maWx0ZXIoZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuICEoYXJnIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH0sIHRoaXMpO1xuXG4gIGlmIChjaGlsZHJlbi5sZW5ndGggIT09IDApIHtcbiAgICBhc3NlcnQoc3RhdGUuY2hpbGRyZW4gPT09IG51bGwpO1xuICAgIHN0YXRlLmNoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICAvLyBSZXBsYWNlIHBhcmVudCB0byBtYWludGFpbiBiYWNrd2FyZCBsaW5rXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgY2hpbGQuX2Jhc2VTdGF0ZS5wYXJlbnQgPSB0aGlzO1xuICAgIH0sIHRoaXMpO1xuICB9XG4gIGlmIChhcmdzLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzc2VydChzdGF0ZS5hcmdzID09PSBudWxsKTtcbiAgICBzdGF0ZS5hcmdzID0gYXJncztcbiAgICBzdGF0ZS5yZXZlcnNlQXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uKGFyZykge1xuICAgICAgaWYgKHR5cGVvZiBhcmcgIT09ICdvYmplY3QnIHx8IGFyZy5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KVxuICAgICAgICByZXR1cm4gYXJnO1xuXG4gICAgICB2YXIgcmVzID0ge307XG4gICAgICBPYmplY3Qua2V5cyhhcmcpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT0gKGtleSB8IDApKVxuICAgICAgICAgIGtleSB8PSAwO1xuICAgICAgICB2YXIgdmFsdWUgPSBhcmdba2V5XTtcbiAgICAgICAgcmVzW3ZhbHVlXSA9IGtleTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9KTtcbiAgfVxufTtcblxuLy9cbi8vIE92ZXJyaWRlZCBtZXRob2RzXG4vL1xuXG5vdmVycmlkZWQuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgTm9kZS5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIF9vdmVycmlkZWQoKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnIG5vdCBpbXBsZW1lbnRlZCBmb3IgZW5jb2Rpbmc6ICcgKyBzdGF0ZS5lbmMpO1xuICB9O1xufSk7XG5cbi8vXG4vLyBQdWJsaWMgbWV0aG9kc1xuLy9cblxudGFncy5mb3JFYWNoKGZ1bmN0aW9uKHRhZykge1xuICBOb2RlLnByb3RvdHlwZVt0YWddID0gZnVuY3Rpb24gX3RhZ01ldGhvZCgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgYXNzZXJ0KHN0YXRlLnRhZyA9PT0gbnVsbCk7XG4gICAgc3RhdGUudGFnID0gdGFnO1xuXG4gICAgdGhpcy5fdXNlQXJncyhhcmdzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufSk7XG5cbk5vZGUucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShpdGVtKSB7XG4gIGFzc2VydChpdGVtKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS51c2UgPT09IG51bGwpO1xuICBzdGF0ZS51c2UgPSBpdGVtO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUub3B0aW9uYWwgPSBmdW5jdGlvbiBvcHRpb25hbCgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIHN0YXRlLm9wdGlvbmFsID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmRlZiA9IGZ1bmN0aW9uIGRlZih2YWwpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZVsnZGVmYXVsdCddID09PSBudWxsKTtcbiAgc3RhdGVbJ2RlZmF1bHQnXSA9IHZhbDtcbiAgc3RhdGUub3B0aW9uYWwgPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZXhwbGljaXQgPSBmdW5jdGlvbiBleHBsaWNpdChudW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS5leHBsaWNpdCA9PT0gbnVsbCAmJiBzdGF0ZS5pbXBsaWNpdCA9PT0gbnVsbCk7XG4gIHN0YXRlLmV4cGxpY2l0ID0gbnVtO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuaW1wbGljaXQgPSBmdW5jdGlvbiBpbXBsaWNpdChudW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGFzc2VydChzdGF0ZS5leHBsaWNpdCA9PT0gbnVsbCAmJiBzdGF0ZS5pbXBsaWNpdCA9PT0gbnVsbCk7XG4gIHN0YXRlLmltcGxpY2l0ID0gbnVtO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUub2JqID0gZnVuY3Rpb24gb2JqKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICBzdGF0ZS5vYmogPSB0cnVlO1xuXG4gIGlmIChhcmdzLmxlbmd0aCAhPT0gMClcbiAgICB0aGlzLl91c2VBcmdzKGFyZ3MpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUua2V5ID0gZnVuY3Rpb24ga2V5KG5ld0tleSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgYXNzZXJ0KHN0YXRlLmtleSA9PT0gbnVsbCk7XG4gIHN0YXRlLmtleSA9IG5ld0tleTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmFueSA9IGZ1bmN0aW9uIGFueSgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIHN0YXRlLmFueSA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5jaG9pY2UgPSBmdW5jdGlvbiBjaG9pY2Uob2JqKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUuY2hvaWNlID09PSBudWxsKTtcbiAgc3RhdGUuY2hvaWNlID0gb2JqO1xuICB0aGlzLl91c2VBcmdzKE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfSkpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyhpdGVtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICBhc3NlcnQoc3RhdGUudXNlID09PSBudWxsKTtcbiAgc3RhdGUuY29udGFpbnMgPSBpdGVtO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIERlY29kaW5nXG4vL1xuXG5Ob2RlLnByb3RvdHlwZS5fZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICAvLyBEZWNvZGUgcm9vdCBub2RlXG4gIGlmIChzdGF0ZS5wYXJlbnQgPT09IG51bGwpXG4gICAgcmV0dXJuIGlucHV0LndyYXBSZXN1bHQoc3RhdGUuY2hpbGRyZW5bMF0uX2RlY29kZShpbnB1dCwgb3B0aW9ucykpO1xuXG4gIHZhciByZXN1bHQgPSBzdGF0ZVsnZGVmYXVsdCddO1xuICB2YXIgcHJlc2VudCA9IHRydWU7XG5cbiAgdmFyIHByZXZLZXkgPSBudWxsO1xuICBpZiAoc3RhdGUua2V5ICE9PSBudWxsKVxuICAgIHByZXZLZXkgPSBpbnB1dC5lbnRlcktleShzdGF0ZS5rZXkpO1xuXG4gIC8vIENoZWNrIGlmIHRhZyBpcyB0aGVyZVxuICBpZiAoc3RhdGUub3B0aW9uYWwpIHtcbiAgICB2YXIgdGFnID0gbnVsbDtcbiAgICBpZiAoc3RhdGUuZXhwbGljaXQgIT09IG51bGwpXG4gICAgICB0YWcgPSBzdGF0ZS5leHBsaWNpdDtcbiAgICBlbHNlIGlmIChzdGF0ZS5pbXBsaWNpdCAhPT0gbnVsbClcbiAgICAgIHRhZyA9IHN0YXRlLmltcGxpY2l0O1xuICAgIGVsc2UgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbClcbiAgICAgIHRhZyA9IHN0YXRlLnRhZztcblxuICAgIGlmICh0YWcgPT09IG51bGwgJiYgIXN0YXRlLmFueSkge1xuICAgICAgLy8gVHJpYWwgYW5kIEVycm9yXG4gICAgICB2YXIgc2F2ZSA9IGlucHV0LnNhdmUoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzdGF0ZS5jaG9pY2UgPT09IG51bGwpXG4gICAgICAgICAgdGhpcy5fZGVjb2RlR2VuZXJpYyhzdGF0ZS50YWcsIGlucHV0LCBvcHRpb25zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMuX2RlY29kZUNob2ljZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgICAgIHByZXNlbnQgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBwcmVzZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpbnB1dC5yZXN0b3JlKHNhdmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVzZW50ID0gdGhpcy5fcGVla1RhZyhpbnB1dCwgdGFnLCBzdGF0ZS5hbnkpO1xuXG4gICAgICBpZiAoaW5wdXQuaXNFcnJvcihwcmVzZW50KSlcbiAgICAgICAgcmV0dXJuIHByZXNlbnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gUHVzaCBvYmplY3Qgb24gc3RhY2tcbiAgdmFyIHByZXZPYmo7XG4gIGlmIChzdGF0ZS5vYmogJiYgcHJlc2VudClcbiAgICBwcmV2T2JqID0gaW5wdXQuZW50ZXJPYmplY3QoKTtcblxuICBpZiAocHJlc2VudCkge1xuICAgIC8vIFVud3JhcCBleHBsaWNpdCB2YWx1ZXNcbiAgICBpZiAoc3RhdGUuZXhwbGljaXQgIT09IG51bGwpIHtcbiAgICAgIHZhciBleHBsaWNpdCA9IHRoaXMuX2RlY29kZVRhZyhpbnB1dCwgc3RhdGUuZXhwbGljaXQpO1xuICAgICAgaWYgKGlucHV0LmlzRXJyb3IoZXhwbGljaXQpKVxuICAgICAgICByZXR1cm4gZXhwbGljaXQ7XG4gICAgICBpbnB1dCA9IGV4cGxpY2l0O1xuICAgIH1cblxuICAgIHZhciBzdGFydCA9IGlucHV0Lm9mZnNldDtcblxuICAgIC8vIFVud3JhcCBpbXBsaWNpdCBhbmQgbm9ybWFsIHZhbHVlc1xuICAgIGlmIChzdGF0ZS51c2UgPT09IG51bGwgJiYgc3RhdGUuY2hvaWNlID09PSBudWxsKSB7XG4gICAgICBpZiAoc3RhdGUuYW55KVxuICAgICAgICB2YXIgc2F2ZSA9IGlucHV0LnNhdmUoKTtcbiAgICAgIHZhciBib2R5ID0gdGhpcy5fZGVjb2RlVGFnKFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgc3RhdGUuaW1wbGljaXQgIT09IG51bGwgPyBzdGF0ZS5pbXBsaWNpdCA6IHN0YXRlLnRhZyxcbiAgICAgICAgc3RhdGUuYW55XG4gICAgICApO1xuICAgICAgaWYgKGlucHV0LmlzRXJyb3IoYm9keSkpXG4gICAgICAgIHJldHVybiBib2R5O1xuXG4gICAgICBpZiAoc3RhdGUuYW55KVxuICAgICAgICByZXN1bHQgPSBpbnB1dC5yYXcoc2F2ZSk7XG4gICAgICBlbHNlXG4gICAgICAgIGlucHV0ID0gYm9keTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnRyYWNrICYmIHN0YXRlLnRhZyAhPT0gbnVsbClcbiAgICAgIG9wdGlvbnMudHJhY2soaW5wdXQucGF0aCgpLCBzdGFydCwgaW5wdXQubGVuZ3RoLCAndGFnZ2VkJyk7XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnRyYWNrICYmIHN0YXRlLnRhZyAhPT0gbnVsbClcbiAgICAgIG9wdGlvbnMudHJhY2soaW5wdXQucGF0aCgpLCBpbnB1dC5vZmZzZXQsIGlucHV0Lmxlbmd0aCwgJ2NvbnRlbnQnKTtcblxuICAgIC8vIFNlbGVjdCBwcm9wZXIgbWV0aG9kIGZvciB0YWdcbiAgICBpZiAoc3RhdGUuYW55KVxuICAgICAgcmVzdWx0ID0gcmVzdWx0O1xuICAgIGVsc2UgaWYgKHN0YXRlLmNob2ljZSA9PT0gbnVsbClcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2RlY29kZUdlbmVyaWMoc3RhdGUudGFnLCBpbnB1dCwgb3B0aW9ucyk7XG4gICAgZWxzZVxuICAgICAgcmVzdWx0ID0gdGhpcy5fZGVjb2RlQ2hvaWNlKGlucHV0LCBvcHRpb25zKTtcblxuICAgIGlmIChpbnB1dC5pc0Vycm9yKHJlc3VsdCkpXG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgLy8gRGVjb2RlIGNoaWxkcmVuXG4gICAgaWYgKCFzdGF0ZS5hbnkgJiYgc3RhdGUuY2hvaWNlID09PSBudWxsICYmIHN0YXRlLmNoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICBzdGF0ZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIGRlY29kZUNoaWxkcmVuKGNoaWxkKSB7XG4gICAgICAgIC8vIE5PVEU6IFdlIGFyZSBpZ25vcmluZyBlcnJvcnMgaGVyZSwgdG8gbGV0IHBhcnNlciBjb250aW51ZSB3aXRoIG90aGVyXG4gICAgICAgIC8vIHBhcnRzIG9mIGVuY29kZWQgZGF0YVxuICAgICAgICBjaGlsZC5fZGVjb2RlKGlucHV0LCBvcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERlY29kZSBjb250YWluZWQvZW5jb2RlZCBieSBzY2hlbWEsIG9ubHkgaW4gYml0IG9yIG9jdGV0IHN0cmluZ3NcbiAgICBpZiAoc3RhdGUuY29udGFpbnMgJiYgKHN0YXRlLnRhZyA9PT0gJ29jdHN0cicgfHwgc3RhdGUudGFnID09PSAnYml0c3RyJykpIHtcbiAgICAgIHZhciBkYXRhID0gbmV3IERlY29kZXJCdWZmZXIocmVzdWx0KTtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2dldFVzZShzdGF0ZS5jb250YWlucywgaW5wdXQuX3JlcG9ydGVyU3RhdGUub2JqKVxuICAgICAgICAgIC5fZGVjb2RlKGRhdGEsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFBvcCBvYmplY3RcbiAgaWYgKHN0YXRlLm9iaiAmJiBwcmVzZW50KVxuICAgIHJlc3VsdCA9IGlucHV0LmxlYXZlT2JqZWN0KHByZXZPYmopO1xuXG4gIC8vIFNldCBrZXlcbiAgaWYgKHN0YXRlLmtleSAhPT0gbnVsbCAmJiAocmVzdWx0ICE9PSBudWxsIHx8IHByZXNlbnQgPT09IHRydWUpKVxuICAgIGlucHV0LmxlYXZlS2V5KHByZXZLZXksIHN0YXRlLmtleSwgcmVzdWx0KTtcbiAgZWxzZSBpZiAocHJldktleSAhPT0gbnVsbClcbiAgICBpbnB1dC5leGl0S2V5KHByZXZLZXkpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZGVjb2RlR2VuZXJpYyA9IGZ1bmN0aW9uIGRlY29kZUdlbmVyaWModGFnLCBpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9iYXNlU3RhdGU7XG5cbiAgaWYgKHRhZyA9PT0gJ3NlcScgfHwgdGFnID09PSAnc2V0JylcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKHRhZyA9PT0gJ3NlcW9mJyB8fCB0YWcgPT09ICdzZXRvZicpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZUxpc3QoaW5wdXQsIHRhZywgc3RhdGUuYXJnc1swXSwgb3B0aW9ucyk7XG4gIGVsc2UgaWYgKC9zdHIkLy50ZXN0KHRhZykpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZVN0cihpbnB1dCwgdGFnLCBvcHRpb25zKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqaWQnICYmIHN0YXRlLmFyZ3MpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZU9iamlkKGlucHV0LCBzdGF0ZS5hcmdzWzBdLCBzdGF0ZS5hcmdzWzFdLCBvcHRpb25zKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqaWQnKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVPYmppZChpbnB1dCwgbnVsbCwgbnVsbCwgb3B0aW9ucyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2dlbnRpbWUnIHx8IHRhZyA9PT0gJ3V0Y3RpbWUnKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVUaW1lKGlucHV0LCB0YWcsIG9wdGlvbnMpO1xuICBlbHNlIGlmICh0YWcgPT09ICdudWxsXycpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZU51bGwoaW5wdXQsIG9wdGlvbnMpO1xuICBlbHNlIGlmICh0YWcgPT09ICdib29sJylcbiAgICByZXR1cm4gdGhpcy5fZGVjb2RlQm9vbChpbnB1dCwgb3B0aW9ucyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iakRlc2MnKVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGVTdHIoaW5wdXQsIHRhZywgb3B0aW9ucyk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2ludCcgfHwgdGFnID09PSAnZW51bScpXG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZUludChpbnB1dCwgc3RhdGUuYXJncyAmJiBzdGF0ZS5hcmdzWzBdLCBvcHRpb25zKTtcblxuICBpZiAoc3RhdGUudXNlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVzZShzdGF0ZS51c2UsIGlucHV0Ll9yZXBvcnRlclN0YXRlLm9iailcbiAgICAgICAgLl9kZWNvZGUoaW5wdXQsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpbnB1dC5lcnJvcigndW5rbm93biB0YWc6ICcgKyB0YWcpO1xuICB9XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fZ2V0VXNlID0gZnVuY3Rpb24gX2dldFVzZShlbnRpdHksIG9iaikge1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgLy8gQ3JlYXRlIGFsdGVyZWQgdXNlIGRlY29kZXIgaWYgaW1wbGljaXQgaXMgc2V0XG4gIHN0YXRlLnVzZURlY29kZXIgPSB0aGlzLl91c2UoZW50aXR5LCBvYmopO1xuICBhc3NlcnQoc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLnBhcmVudCA9PT0gbnVsbCk7XG4gIHN0YXRlLnVzZURlY29kZXIgPSBzdGF0ZS51c2VEZWNvZGVyLl9iYXNlU3RhdGUuY2hpbGRyZW5bMF07XG4gIGlmIChzdGF0ZS5pbXBsaWNpdCAhPT0gc3RhdGUudXNlRGVjb2Rlci5fYmFzZVN0YXRlLmltcGxpY2l0KSB7XG4gICAgc3RhdGUudXNlRGVjb2RlciA9IHN0YXRlLnVzZURlY29kZXIuY2xvbmUoKTtcbiAgICBzdGF0ZS51c2VEZWNvZGVyLl9iYXNlU3RhdGUuaW1wbGljaXQgPSBzdGF0ZS5pbXBsaWNpdDtcbiAgfVxuICByZXR1cm4gc3RhdGUudXNlRGVjb2Rlcjtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9kZWNvZGVDaG9pY2UgPSBmdW5jdGlvbiBkZWNvZGVDaG9pY2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgdmFyIG1hdGNoID0gZmFsc2U7XG5cbiAgT2JqZWN0LmtleXMoc3RhdGUuY2hvaWNlKS5zb21lKGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBzYXZlID0gaW5wdXQuc2F2ZSgpO1xuICAgIHZhciBub2RlID0gc3RhdGUuY2hvaWNlW2tleV07XG4gICAgdHJ5IHtcbiAgICAgIHZhciB2YWx1ZSA9IG5vZGUuX2RlY29kZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgICBpZiAoaW5wdXQuaXNFcnJvcih2YWx1ZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgcmVzdWx0ID0geyB0eXBlOiBrZXksIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgbWF0Y2ggPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlucHV0LnJlc3RvcmUoc2F2ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LCB0aGlzKTtcblxuICBpZiAoIW1hdGNoKVxuICAgIHJldHVybiBpbnB1dC5lcnJvcignQ2hvaWNlIG5vdCBtYXRjaGVkJyk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vXG4vLyBFbmNvZGluZ1xuLy9cblxuTm9kZS5wcm90b3R5cGUuX2NyZWF0ZUVuY29kZXJCdWZmZXIgPSBmdW5jdGlvbiBjcmVhdGVFbmNvZGVyQnVmZmVyKGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBFbmNvZGVyQnVmZmVyKGRhdGEsIHRoaXMucmVwb3J0ZXIpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShkYXRhLCByZXBvcnRlciwgcGFyZW50KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgaWYgKHN0YXRlWydkZWZhdWx0J10gIT09IG51bGwgJiYgc3RhdGVbJ2RlZmF1bHQnXSA9PT0gZGF0YSlcbiAgICByZXR1cm47XG5cbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2VuY29kZVZhbHVlKGRhdGEsIHJlcG9ydGVyLCBwYXJlbnQpO1xuICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuO1xuXG4gIGlmICh0aGlzLl9za2lwRGVmYXVsdChyZXN1bHQsIHJlcG9ydGVyLCBwYXJlbnQpKVxuICAgIHJldHVybjtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2VuY29kZVZhbHVlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIHJlcG9ydGVyLCBwYXJlbnQpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIC8vIERlY29kZSByb290IG5vZGVcbiAgaWYgKHN0YXRlLnBhcmVudCA9PT0gbnVsbClcbiAgICByZXR1cm4gc3RhdGUuY2hpbGRyZW5bMF0uX2VuY29kZShkYXRhLCByZXBvcnRlciB8fCBuZXcgUmVwb3J0ZXIoKSk7XG5cbiAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgLy8gU2V0IHJlcG9ydGVyIHRvIHNoYXJlIGl0IHdpdGggYSBjaGlsZCBjbGFzc1xuICB0aGlzLnJlcG9ydGVyID0gcmVwb3J0ZXI7XG5cbiAgLy8gQ2hlY2sgaWYgZGF0YSBpcyB0aGVyZVxuICBpZiAoc3RhdGUub3B0aW9uYWwgJiYgZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHN0YXRlWydkZWZhdWx0J10gIT09IG51bGwpXG4gICAgICBkYXRhID0gc3RhdGVbJ2RlZmF1bHQnXVxuICAgIGVsc2VcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVuY29kZSBjaGlsZHJlbiBmaXJzdFxuICB2YXIgY29udGVudCA9IG51bGw7XG4gIHZhciBwcmltaXRpdmUgPSBmYWxzZTtcbiAgaWYgKHN0YXRlLmFueSkge1xuICAgIC8vIEFueXRoaW5nIHRoYXQgd2FzIGdpdmVuIGlzIHRyYW5zbGF0ZWQgdG8gYnVmZmVyXG4gICAgcmVzdWx0ID0gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihkYXRhKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5jaG9pY2UpIHtcbiAgICByZXN1bHQgPSB0aGlzLl9lbmNvZGVDaG9pY2UoZGF0YSwgcmVwb3J0ZXIpO1xuICB9IGVsc2UgaWYgKHN0YXRlLmNvbnRhaW5zKSB7XG4gICAgY29udGVudCA9IHRoaXMuX2dldFVzZShzdGF0ZS5jb250YWlucywgcGFyZW50KS5fZW5jb2RlKGRhdGEsIHJlcG9ydGVyKTtcbiAgICBwcmltaXRpdmUgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHN0YXRlLmNoaWxkcmVuKSB7XG4gICAgY29udGVudCA9IHN0YXRlLmNoaWxkcmVuLm1hcChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLl9iYXNlU3RhdGUudGFnID09PSAnbnVsbF8nKVxuICAgICAgICByZXR1cm4gY2hpbGQuX2VuY29kZShudWxsLCByZXBvcnRlciwgZGF0YSk7XG5cbiAgICAgIGlmIChjaGlsZC5fYmFzZVN0YXRlLmtleSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdDaGlsZCBzaG91bGQgaGF2ZSBhIGtleScpO1xuICAgICAgdmFyIHByZXZLZXkgPSByZXBvcnRlci5lbnRlcktleShjaGlsZC5fYmFzZVN0YXRlLmtleSk7XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignQ2hpbGQgZXhwZWN0ZWQsIGJ1dCBpbnB1dCBpcyBub3Qgb2JqZWN0Jyk7XG5cbiAgICAgIHZhciByZXMgPSBjaGlsZC5fZW5jb2RlKGRhdGFbY2hpbGQuX2Jhc2VTdGF0ZS5rZXldLCByZXBvcnRlciwgZGF0YSk7XG4gICAgICByZXBvcnRlci5sZWF2ZUtleShwcmV2S2V5KTtcblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCB0aGlzKS5maWx0ZXIoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9KTtcbiAgICBjb250ZW50ID0gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihjb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc3RhdGUudGFnID09PSAnc2Vxb2YnIHx8IHN0YXRlLnRhZyA9PT0gJ3NldG9mJykge1xuICAgICAgLy8gVE9ETyhpbmR1dG55KTogdGhpcyBzaG91bGQgYmUgdGhyb3duIG9uIERTTCBsZXZlbFxuICAgICAgaWYgKCEoc3RhdGUuYXJncyAmJiBzdGF0ZS5hcmdzLmxlbmd0aCA9PT0gMSkpXG4gICAgICAgIHJldHVybiByZXBvcnRlci5lcnJvcignVG9vIG1hbnkgYXJncyBmb3IgOiAnICsgc3RhdGUudGFnKTtcblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICByZXR1cm4gcmVwb3J0ZXIuZXJyb3IoJ3NlcW9mL3NldG9mLCBidXQgZGF0YSBpcyBub3QgQXJyYXknKTtcblxuICAgICAgdmFyIGNoaWxkID0gdGhpcy5jbG9uZSgpO1xuICAgICAgY2hpbGQuX2Jhc2VTdGF0ZS5pbXBsaWNpdCA9IG51bGw7XG4gICAgICBjb250ZW50ID0gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihkYXRhLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VXNlKHN0YXRlLmFyZ3NbMF0sIGRhdGEpLl9lbmNvZGUoaXRlbSwgcmVwb3J0ZXIpO1xuICAgICAgfSwgY2hpbGQpKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLnVzZSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0VXNlKHN0YXRlLnVzZSwgcGFyZW50KS5fZW5jb2RlKGRhdGEsIHJlcG9ydGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IHRoaXMuX2VuY29kZVByaW1pdGl2ZShzdGF0ZS50YWcsIGRhdGEpO1xuICAgICAgcHJpbWl0aXZlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBFbmNvZGUgZGF0YSBpdHNlbGZcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCFzdGF0ZS5hbnkgJiYgc3RhdGUuY2hvaWNlID09PSBudWxsKSB7XG4gICAgdmFyIHRhZyA9IHN0YXRlLmltcGxpY2l0ICE9PSBudWxsID8gc3RhdGUuaW1wbGljaXQgOiBzdGF0ZS50YWc7XG4gICAgdmFyIGNscyA9IHN0YXRlLmltcGxpY2l0ID09PSBudWxsID8gJ3VuaXZlcnNhbCcgOiAnY29udGV4dCc7XG5cbiAgICBpZiAodGFnID09PSBudWxsKSB7XG4gICAgICBpZiAoc3RhdGUudXNlID09PSBudWxsKVxuICAgICAgICByZXBvcnRlci5lcnJvcignVGFnIGNvdWxkIGJlIG9taXR0ZWQgb25seSBmb3IgLnVzZSgpJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS51c2UgPT09IG51bGwpXG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2VuY29kZUNvbXBvc2l0ZSh0YWcsIHByaW1pdGl2ZSwgY2xzLCBjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBXcmFwIGluIGV4cGxpY2l0XG4gIGlmIChzdGF0ZS5leHBsaWNpdCAhPT0gbnVsbClcbiAgICByZXN1bHQgPSB0aGlzLl9lbmNvZGVDb21wb3NpdGUoc3RhdGUuZXhwbGljaXQsIGZhbHNlLCAnY29udGV4dCcsIHJlc3VsdCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9lbmNvZGVDaG9pY2UgPSBmdW5jdGlvbiBlbmNvZGVDaG9pY2UoZGF0YSwgcmVwb3J0ZXIpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIHZhciBub2RlID0gc3RhdGUuY2hvaWNlW2RhdGEudHlwZV07XG4gIGlmICghbm9kZSkge1xuICAgIGFzc2VydChcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGRhdGEudHlwZSArICcgbm90IGZvdW5kIGluICcgK1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc3RhdGUuY2hvaWNlKSkpO1xuICB9XG4gIHJldHVybiBub2RlLl9lbmNvZGUoZGF0YS52YWx1ZSwgcmVwb3J0ZXIpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2VuY29kZVByaW1pdGl2ZSA9IGZ1bmN0aW9uIGVuY29kZVByaW1pdGl2ZSh0YWcsIGRhdGEpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fYmFzZVN0YXRlO1xuXG4gIGlmICgvc3RyJC8udGVzdCh0YWcpKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVTdHIoZGF0YSwgdGFnKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqaWQnICYmIHN0YXRlLmFyZ3MpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZU9iamlkKGRhdGEsIHN0YXRlLnJldmVyc2VBcmdzWzBdLCBzdGF0ZS5hcmdzWzFdKTtcbiAgZWxzZSBpZiAodGFnID09PSAnb2JqaWQnKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVPYmppZChkYXRhLCBudWxsLCBudWxsKTtcbiAgZWxzZSBpZiAodGFnID09PSAnZ2VudGltZScgfHwgdGFnID09PSAndXRjdGltZScpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZVRpbWUoZGF0YSwgdGFnKTtcbiAgZWxzZSBpZiAodGFnID09PSAnbnVsbF8nKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVOdWxsKCk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ2ludCcgfHwgdGFnID09PSAnZW51bScpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZUludChkYXRhLCBzdGF0ZS5hcmdzICYmIHN0YXRlLnJldmVyc2VBcmdzWzBdKTtcbiAgZWxzZSBpZiAodGFnID09PSAnYm9vbCcpXG4gICAgcmV0dXJuIHRoaXMuX2VuY29kZUJvb2woZGF0YSk7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ29iakRlc2MnKVxuICAgIHJldHVybiB0aGlzLl9lbmNvZGVTdHIoZGF0YSwgdGFnKTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdGFnOiAnICsgdGFnKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLl9pc051bXN0ciA9IGZ1bmN0aW9uIGlzTnVtc3RyKHN0cikge1xuICByZXR1cm4gL15bMC05IF0qJC8udGVzdChzdHIpO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX2lzUHJpbnRzdHIgPSBmdW5jdGlvbiBpc1ByaW50c3RyKHN0cikge1xuICByZXR1cm4gL15bQS1aYS16MC05ICdcXChcXClcXCssXFwtXFwuXFwvOj1cXD9dKiQvLnRlc3Qoc3RyKTtcbn07XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5mdW5jdGlvbiBSZXBvcnRlcihvcHRpb25zKSB7XG4gIHRoaXMuX3JlcG9ydGVyU3RhdGUgPSB7XG4gICAgb2JqOiBudWxsLFxuICAgIHBhdGg6IFtdLFxuICAgIG9wdGlvbnM6IG9wdGlvbnMgfHwge30sXG4gICAgZXJyb3JzOiBbXVxuICB9O1xufVxuZXhwb3J0cy5SZXBvcnRlciA9IFJlcG9ydGVyO1xuXG5SZXBvcnRlci5wcm90b3R5cGUuaXNFcnJvciA9IGZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBSZXBvcnRlckVycm9yO1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiBzYXZlKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHJldHVybiB7IG9iajogc3RhdGUub2JqLCBwYXRoTGVuOiBzdGF0ZS5wYXRoLmxlbmd0aCB9O1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbiByZXN0b3JlKGRhdGEpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICBzdGF0ZS5vYmogPSBkYXRhLm9iajtcbiAgc3RhdGUucGF0aCA9IHN0YXRlLnBhdGguc2xpY2UoMCwgZGF0YS5wYXRoTGVuKTtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5lbnRlcktleSA9IGZ1bmN0aW9uIGVudGVyS2V5KGtleSkge1xuICByZXR1cm4gdGhpcy5fcmVwb3J0ZXJTdGF0ZS5wYXRoLnB1c2goa2V5KTtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5leGl0S2V5ID0gZnVuY3Rpb24gZXhpdEtleShpbmRleCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHN0YXRlLnBhdGggPSBzdGF0ZS5wYXRoLnNsaWNlKDAsIGluZGV4IC0gMSk7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUubGVhdmVLZXkgPSBmdW5jdGlvbiBsZWF2ZUtleShpbmRleCwga2V5LCB2YWx1ZSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHRoaXMuZXhpdEtleShpbmRleCk7XG4gIGlmIChzdGF0ZS5vYmogIT09IG51bGwpXG4gICAgc3RhdGUub2JqW2tleV0gPSB2YWx1ZTtcbn07XG5cblJlcG9ydGVyLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gcGF0aCgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlcG9ydGVyU3RhdGUucGF0aC5qb2luKCcvJyk7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUuZW50ZXJPYmplY3QgPSBmdW5jdGlvbiBlbnRlck9iamVjdCgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICB2YXIgcHJldiA9IHN0YXRlLm9iajtcbiAgc3RhdGUub2JqID0ge307XG4gIHJldHVybiBwcmV2O1xufTtcblxuUmVwb3J0ZXIucHJvdG90eXBlLmxlYXZlT2JqZWN0ID0gZnVuY3Rpb24gbGVhdmVPYmplY3QocHJldikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZXBvcnRlclN0YXRlO1xuXG4gIHZhciBub3cgPSBzdGF0ZS5vYmo7XG4gIHN0YXRlLm9iaiA9IHByZXY7XG4gIHJldHVybiBub3c7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgdmFyIGVycjtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVwb3J0ZXJTdGF0ZTtcblxuICB2YXIgaW5oZXJpdGVkID0gbXNnIGluc3RhbmNlb2YgUmVwb3J0ZXJFcnJvcjtcbiAgaWYgKGluaGVyaXRlZCkge1xuICAgIGVyciA9IG1zZztcbiAgfSBlbHNlIHtcbiAgICBlcnIgPSBuZXcgUmVwb3J0ZXJFcnJvcihzdGF0ZS5wYXRoLm1hcChmdW5jdGlvbihlbGVtKSB7XG4gICAgICByZXR1cm4gJ1snICsgSlNPTi5zdHJpbmdpZnkoZWxlbSkgKyAnXSc7XG4gICAgfSkuam9pbignJyksIG1zZy5tZXNzYWdlIHx8IG1zZywgbXNnLnN0YWNrKTtcbiAgfVxuXG4gIGlmICghc3RhdGUub3B0aW9ucy5wYXJ0aWFsKVxuICAgIHRocm93IGVycjtcblxuICBpZiAoIWluaGVyaXRlZClcbiAgICBzdGF0ZS5lcnJvcnMucHVzaChlcnIpO1xuXG4gIHJldHVybiBlcnI7XG59O1xuXG5SZXBvcnRlci5wcm90b3R5cGUud3JhcFJlc3VsdCA9IGZ1bmN0aW9uIHdyYXBSZXN1bHQocmVzdWx0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlcG9ydGVyU3RhdGU7XG4gIGlmICghc3RhdGUub3B0aW9ucy5wYXJ0aWFsKVxuICAgIHJldHVybiByZXN1bHQ7XG5cbiAgcmV0dXJuIHtcbiAgICByZXN1bHQ6IHRoaXMuaXNFcnJvcihyZXN1bHQpID8gbnVsbCA6IHJlc3VsdCxcbiAgICBlcnJvcnM6IHN0YXRlLmVycm9yc1xuICB9O1xufTtcblxuZnVuY3Rpb24gUmVwb3J0ZXJFcnJvcihwYXRoLCBtc2cpIHtcbiAgdGhpcy5wYXRoID0gcGF0aDtcbiAgdGhpcy5yZXRocm93KG1zZyk7XG59O1xuaW5oZXJpdHMoUmVwb3J0ZXJFcnJvciwgRXJyb3IpO1xuXG5SZXBvcnRlckVycm9yLnByb3RvdHlwZS5yZXRocm93ID0gZnVuY3Rpb24gcmV0aHJvdyhtc2cpIHtcbiAgdGhpcy5tZXNzYWdlID0gbXNnICsgJyBhdDogJyArICh0aGlzLnBhdGggfHwgJyhzaGFsbG93KScpO1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVwb3J0ZXJFcnJvcik7XG5cbiAgaWYgKCF0aGlzLnN0YWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIElFIG9ubHkgYWRkcyBzdGFjayB3aGVuIHRocm93blxuICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMubWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5zdGFjayA9IGUuc3RhY2s7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcbiIsInZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcblxuZXhwb3J0cy50YWdDbGFzcyA9IHtcbiAgMDogJ3VuaXZlcnNhbCcsXG4gIDE6ICdhcHBsaWNhdGlvbicsXG4gIDI6ICdjb250ZXh0JyxcbiAgMzogJ3ByaXZhdGUnXG59O1xuZXhwb3J0cy50YWdDbGFzc0J5TmFtZSA9IGNvbnN0YW50cy5fcmV2ZXJzZShleHBvcnRzLnRhZ0NsYXNzKTtcblxuZXhwb3J0cy50YWcgPSB7XG4gIDB4MDA6ICdlbmQnLFxuICAweDAxOiAnYm9vbCcsXG4gIDB4MDI6ICdpbnQnLFxuICAweDAzOiAnYml0c3RyJyxcbiAgMHgwNDogJ29jdHN0cicsXG4gIDB4MDU6ICdudWxsXycsXG4gIDB4MDY6ICdvYmppZCcsXG4gIDB4MDc6ICdvYmpEZXNjJyxcbiAgMHgwODogJ2V4dGVybmFsJyxcbiAgMHgwOTogJ3JlYWwnLFxuICAweDBhOiAnZW51bScsXG4gIDB4MGI6ICdlbWJlZCcsXG4gIDB4MGM6ICd1dGY4c3RyJyxcbiAgMHgwZDogJ3JlbGF0aXZlT2lkJyxcbiAgMHgxMDogJ3NlcScsXG4gIDB4MTE6ICdzZXQnLFxuICAweDEyOiAnbnVtc3RyJyxcbiAgMHgxMzogJ3ByaW50c3RyJyxcbiAgMHgxNDogJ3Q2MXN0cicsXG4gIDB4MTU6ICd2aWRlb3N0cicsXG4gIDB4MTY6ICdpYTVzdHInLFxuICAweDE3OiAndXRjdGltZScsXG4gIDB4MTg6ICdnZW50aW1lJyxcbiAgMHgxOTogJ2dyYXBoc3RyJyxcbiAgMHgxYTogJ2lzbzY0NnN0cicsXG4gIDB4MWI6ICdnZW5zdHInLFxuICAweDFjOiAndW5pc3RyJyxcbiAgMHgxZDogJ2NoYXJzdHInLFxuICAweDFlOiAnYm1wc3RyJ1xufTtcbmV4cG9ydHMudGFnQnlOYW1lID0gY29uc3RhbnRzLl9yZXZlcnNlKGV4cG9ydHMudGFnKTtcbiIsInZhciBjb25zdGFudHMgPSBleHBvcnRzO1xuXG4vLyBIZWxwZXJcbmNvbnN0YW50cy5fcmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UobWFwKSB7XG4gIHZhciByZXMgPSB7fTtcblxuICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgLy8gQ29udmVydCBrZXkgdG8gaW50ZWdlciBpZiBpdCBpcyBzdHJpbmdpZmllZFxuICAgIGlmICgoa2V5IHwgMCkgPT0ga2V5KVxuICAgICAga2V5ID0ga2V5IHwgMDtcblxuICAgIHZhciB2YWx1ZSA9IG1hcFtrZXldO1xuICAgIHJlc1t2YWx1ZV0gPSBrZXk7XG4gIH0pO1xuXG4gIHJldHVybiByZXM7XG59O1xuXG5jb25zdGFudHMuZGVyID0gcmVxdWlyZSgnLi9kZXInKTtcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBhc24xID0gcmVxdWlyZSgnLi4vLi4vYXNuMScpO1xudmFyIGJhc2UgPSBhc24xLmJhc2U7XG52YXIgYmlnbnVtID0gYXNuMS5iaWdudW07XG5cbi8vIEltcG9ydCBERVIgY29uc3RhbnRzXG52YXIgZGVyID0gYXNuMS5jb25zdGFudHMuZGVyO1xuXG5mdW5jdGlvbiBERVJEZWNvZGVyKGVudGl0eSkge1xuICB0aGlzLmVuYyA9ICdkZXInO1xuICB0aGlzLm5hbWUgPSBlbnRpdHkubmFtZTtcbiAgdGhpcy5lbnRpdHkgPSBlbnRpdHk7XG5cbiAgLy8gQ29uc3RydWN0IGJhc2UgdHJlZVxuICB0aGlzLnRyZWUgPSBuZXcgREVSTm9kZSgpO1xuICB0aGlzLnRyZWUuX2luaXQoZW50aXR5LmJvZHkpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gREVSRGVjb2RlcjtcblxuREVSRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGRhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIGJhc2UuRGVjb2RlckJ1ZmZlcikpXG4gICAgZGF0YSA9IG5ldyBiYXNlLkRlY29kZXJCdWZmZXIoZGF0YSwgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMudHJlZS5fZGVjb2RlKGRhdGEsIG9wdGlvbnMpO1xufTtcblxuLy8gVHJlZSBtZXRob2RzXG5cbmZ1bmN0aW9uIERFUk5vZGUocGFyZW50KSB7XG4gIGJhc2UuTm9kZS5jYWxsKHRoaXMsICdkZXInLCBwYXJlbnQpO1xufVxuaW5oZXJpdHMoREVSTm9kZSwgYmFzZS5Ob2RlKTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3BlZWtUYWcgPSBmdW5jdGlvbiBwZWVrVGFnKGJ1ZmZlciwgdGFnLCBhbnkpIHtcbiAgaWYgKGJ1ZmZlci5pc0VtcHR5KCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBzdGF0ZSA9IGJ1ZmZlci5zYXZlKCk7XG4gIHZhciBkZWNvZGVkVGFnID0gZGVyRGVjb2RlVGFnKGJ1ZmZlciwgJ0ZhaWxlZCB0byBwZWVrIHRhZzogXCInICsgdGFnICsgJ1wiJyk7XG4gIGlmIChidWZmZXIuaXNFcnJvcihkZWNvZGVkVGFnKSlcbiAgICByZXR1cm4gZGVjb2RlZFRhZztcblxuICBidWZmZXIucmVzdG9yZShzdGF0ZSk7XG5cbiAgcmV0dXJuIGRlY29kZWRUYWcudGFnID09PSB0YWcgfHwgZGVjb2RlZFRhZy50YWdTdHIgPT09IHRhZyB8fFxuICAgIChkZWNvZGVkVGFnLnRhZ1N0ciArICdvZicpID09PSB0YWcgfHwgYW55O1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZVRhZyA9IGZ1bmN0aW9uIGRlY29kZVRhZyhidWZmZXIsIHRhZywgYW55KSB7XG4gIHZhciBkZWNvZGVkVGFnID0gZGVyRGVjb2RlVGFnKGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0ZhaWxlZCB0byBkZWNvZGUgdGFnIG9mIFwiJyArIHRhZyArICdcIicpO1xuICBpZiAoYnVmZmVyLmlzRXJyb3IoZGVjb2RlZFRhZykpXG4gICAgcmV0dXJuIGRlY29kZWRUYWc7XG5cbiAgdmFyIGxlbiA9IGRlckRlY29kZUxlbihidWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZFRhZy5wcmltaXRpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ0ZhaWxlZCB0byBnZXQgbGVuZ3RoIG9mIFwiJyArIHRhZyArICdcIicpO1xuXG4gIC8vIEZhaWx1cmVcbiAgaWYgKGJ1ZmZlci5pc0Vycm9yKGxlbikpXG4gICAgcmV0dXJuIGxlbjtcblxuICBpZiAoIWFueSAmJlxuICAgICAgZGVjb2RlZFRhZy50YWcgIT09IHRhZyAmJlxuICAgICAgZGVjb2RlZFRhZy50YWdTdHIgIT09IHRhZyAmJlxuICAgICAgZGVjb2RlZFRhZy50YWdTdHIgKyAnb2YnICE9PSB0YWcpIHtcbiAgICByZXR1cm4gYnVmZmVyLmVycm9yKCdGYWlsZWQgdG8gbWF0Y2ggdGFnOiBcIicgKyB0YWcgKyAnXCInKTtcbiAgfVxuXG4gIGlmIChkZWNvZGVkVGFnLnByaW1pdGl2ZSB8fCBsZW4gIT09IG51bGwpXG4gICAgcmV0dXJuIGJ1ZmZlci5za2lwKGxlbiwgJ0ZhaWxlZCB0byBtYXRjaCBib2R5IG9mOiBcIicgKyB0YWcgKyAnXCInKTtcblxuICAvLyBJbmRlZmluaXRlIGxlbmd0aC4uLiBmaW5kIEVORCB0YWdcbiAgdmFyIHN0YXRlID0gYnVmZmVyLnNhdmUoKTtcbiAgdmFyIHJlcyA9IHRoaXMuX3NraXBVbnRpbEVuZChcbiAgICAgIGJ1ZmZlcixcbiAgICAgICdGYWlsZWQgdG8gc2tpcCBpbmRlZmluaXRlIGxlbmd0aCBib2R5OiBcIicgKyB0aGlzLnRhZyArICdcIicpO1xuICBpZiAoYnVmZmVyLmlzRXJyb3IocmVzKSlcbiAgICByZXR1cm4gcmVzO1xuXG4gIGxlbiA9IGJ1ZmZlci5vZmZzZXQgLSBzdGF0ZS5vZmZzZXQ7XG4gIGJ1ZmZlci5yZXN0b3JlKHN0YXRlKTtcbiAgcmV0dXJuIGJ1ZmZlci5za2lwKGxlbiwgJ0ZhaWxlZCB0byBtYXRjaCBib2R5IG9mOiBcIicgKyB0YWcgKyAnXCInKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9za2lwVW50aWxFbmQgPSBmdW5jdGlvbiBza2lwVW50aWxFbmQoYnVmZmVyLCBmYWlsKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHRhZyA9IGRlckRlY29kZVRhZyhidWZmZXIsIGZhaWwpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcih0YWcpKVxuICAgICAgcmV0dXJuIHRhZztcbiAgICB2YXIgbGVuID0gZGVyRGVjb2RlTGVuKGJ1ZmZlciwgdGFnLnByaW1pdGl2ZSwgZmFpbCk7XG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKGxlbikpXG4gICAgICByZXR1cm4gbGVuO1xuXG4gICAgdmFyIHJlcztcbiAgICBpZiAodGFnLnByaW1pdGl2ZSB8fCBsZW4gIT09IG51bGwpXG4gICAgICByZXMgPSBidWZmZXIuc2tpcChsZW4pXG4gICAgZWxzZVxuICAgICAgcmVzID0gdGhpcy5fc2tpcFVudGlsRW5kKGJ1ZmZlciwgZmFpbCk7XG5cbiAgICAvLyBGYWlsdXJlXG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKHJlcykpXG4gICAgICByZXR1cm4gcmVzO1xuXG4gICAgaWYgKHRhZy50YWdTdHIgPT09ICdlbmQnKVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVMaXN0ID0gZnVuY3Rpb24gZGVjb2RlTGlzdChidWZmZXIsIHRhZywgZGVjb2RlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKCFidWZmZXIuaXNFbXB0eSgpKSB7XG4gICAgdmFyIHBvc3NpYmxlRW5kID0gdGhpcy5fcGVla1RhZyhidWZmZXIsICdlbmQnKTtcbiAgICBpZiAoYnVmZmVyLmlzRXJyb3IocG9zc2libGVFbmQpKVxuICAgICAgcmV0dXJuIHBvc3NpYmxlRW5kO1xuXG4gICAgdmFyIHJlcyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlciwgJ2RlcicsIG9wdGlvbnMpO1xuICAgIGlmIChidWZmZXIuaXNFcnJvcihyZXMpICYmIHBvc3NpYmxlRW5kKVxuICAgICAgYnJlYWs7XG4gICAgcmVzdWx0LnB1c2gocmVzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZVN0ciA9IGZ1bmN0aW9uIGRlY29kZVN0cihidWZmZXIsIHRhZykge1xuICBpZiAodGFnID09PSAnYml0c3RyJykge1xuICAgIHZhciB1bnVzZWQgPSBidWZmZXIucmVhZFVJbnQ4KCk7XG4gICAgaWYgKGJ1ZmZlci5pc0Vycm9yKHVudXNlZCkpXG4gICAgICByZXR1cm4gdW51c2VkO1xuICAgIHJldHVybiB7IHVudXNlZDogdW51c2VkLCBkYXRhOiBidWZmZXIucmF3KCkgfTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdibXBzdHInKSB7XG4gICAgdmFyIHJhdyA9IGJ1ZmZlci5yYXcoKTtcbiAgICBpZiAocmF3Lmxlbmd0aCAlIDIgPT09IDEpXG4gICAgICByZXR1cm4gYnVmZmVyLmVycm9yKCdEZWNvZGluZyBvZiBzdHJpbmcgdHlwZTogYm1wc3RyIGxlbmd0aCBtaXNtYXRjaCcpO1xuXG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Lmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocmF3LnJlYWRVSW50MTZCRShpICogMikpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ251bXN0cicpIHtcbiAgICB2YXIgbnVtc3RyID0gYnVmZmVyLnJhdygpLnRvU3RyaW5nKCdhc2NpaScpO1xuICAgIGlmICghdGhpcy5faXNOdW1zdHIobnVtc3RyKSkge1xuICAgICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRGVjb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnbnVtc3RyIHVuc3VwcG9ydGVkIGNoYXJhY3RlcnMnKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bXN0cjtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdvY3RzdHInKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5yYXcoKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdvYmpEZXNjJykge1xuICAgIHJldHVybiBidWZmZXIucmF3KCk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAncHJpbnRzdHInKSB7XG4gICAgdmFyIHByaW50c3RyID0gYnVmZmVyLnJhdygpLnRvU3RyaW5nKCdhc2NpaScpO1xuICAgIGlmICghdGhpcy5faXNQcmludHN0cihwcmludHN0cikpIHtcbiAgICAgIHJldHVybiBidWZmZXIuZXJyb3IoJ0RlY29kaW5nIG9mIHN0cmluZyB0eXBlOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ByaW50c3RyIHVuc3VwcG9ydGVkIGNoYXJhY3RlcnMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHByaW50c3RyO1xuICB9IGVsc2UgaWYgKC9zdHIkLy50ZXN0KHRhZykpIHtcbiAgICByZXR1cm4gYnVmZmVyLnJhdygpLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5lcnJvcignRGVjb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6ICcgKyB0YWcgKyAnIHVuc3VwcG9ydGVkJyk7XG4gIH1cbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVPYmppZCA9IGZ1bmN0aW9uIGRlY29kZU9iamlkKGJ1ZmZlciwgdmFsdWVzLCByZWxhdGl2ZSkge1xuICB2YXIgcmVzdWx0O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcbiAgdmFyIGlkZW50ID0gMDtcbiAgd2hpbGUgKCFidWZmZXIuaXNFbXB0eSgpKSB7XG4gICAgdmFyIHN1YmlkZW50ID0gYnVmZmVyLnJlYWRVSW50OCgpO1xuICAgIGlkZW50IDw8PSA3O1xuICAgIGlkZW50IHw9IHN1YmlkZW50ICYgMHg3ZjtcbiAgICBpZiAoKHN1YmlkZW50ICYgMHg4MCkgPT09IDApIHtcbiAgICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnQpO1xuICAgICAgaWRlbnQgPSAwO1xuICAgIH1cbiAgfVxuICBpZiAoc3ViaWRlbnQgJiAweDgwKVxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnQpO1xuXG4gIHZhciBmaXJzdCA9IChpZGVudGlmaWVyc1swXSAvIDQwKSB8IDA7XG4gIHZhciBzZWNvbmQgPSBpZGVudGlmaWVyc1swXSAlIDQwO1xuXG4gIGlmIChyZWxhdGl2ZSlcbiAgICByZXN1bHQgPSBpZGVudGlmaWVycztcbiAgZWxzZVxuICAgIHJlc3VsdCA9IFtmaXJzdCwgc2Vjb25kXS5jb25jYXQoaWRlbnRpZmllcnMuc2xpY2UoMSkpO1xuXG4gIGlmICh2YWx1ZXMpIHtcbiAgICB2YXIgdG1wID0gdmFsdWVzW3Jlc3VsdC5qb2luKCcgJyldO1xuICAgIGlmICh0bXAgPT09IHVuZGVmaW5lZClcbiAgICAgIHRtcCA9IHZhbHVlc1tyZXN1bHQuam9pbignLicpXTtcbiAgICBpZiAodG1wICE9PSB1bmRlZmluZWQpXG4gICAgICByZXN1bHQgPSB0bXA7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZVRpbWUgPSBmdW5jdGlvbiBkZWNvZGVUaW1lKGJ1ZmZlciwgdGFnKSB7XG4gIHZhciBzdHIgPSBidWZmZXIucmF3KCkudG9TdHJpbmcoKTtcbiAgaWYgKHRhZyA9PT0gJ2dlbnRpbWUnKSB7XG4gICAgdmFyIHllYXIgPSBzdHIuc2xpY2UoMCwgNCkgfCAwO1xuICAgIHZhciBtb24gPSBzdHIuc2xpY2UoNCwgNikgfCAwO1xuICAgIHZhciBkYXkgPSBzdHIuc2xpY2UoNiwgOCkgfCAwO1xuICAgIHZhciBob3VyID0gc3RyLnNsaWNlKDgsIDEwKSB8IDA7XG4gICAgdmFyIG1pbiA9IHN0ci5zbGljZSgxMCwgMTIpIHwgMDtcbiAgICB2YXIgc2VjID0gc3RyLnNsaWNlKDEyLCAxNCkgfCAwO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3V0Y3RpbWUnKSB7XG4gICAgdmFyIHllYXIgPSBzdHIuc2xpY2UoMCwgMikgfCAwO1xuICAgIHZhciBtb24gPSBzdHIuc2xpY2UoMiwgNCkgfCAwO1xuICAgIHZhciBkYXkgPSBzdHIuc2xpY2UoNCwgNikgfCAwO1xuICAgIHZhciBob3VyID0gc3RyLnNsaWNlKDYsIDgpIHwgMDtcbiAgICB2YXIgbWluID0gc3RyLnNsaWNlKDgsIDEwKSB8IDA7XG4gICAgdmFyIHNlYyA9IHN0ci5zbGljZSgxMCwgMTIpIHwgMDtcbiAgICBpZiAoeWVhciA8IDcwKVxuICAgICAgeWVhciA9IDIwMDAgKyB5ZWFyO1xuICAgIGVsc2VcbiAgICAgIHllYXIgPSAxOTAwICsgeWVhcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYnVmZmVyLmVycm9yKCdEZWNvZGluZyAnICsgdGFnICsgJyB0aW1lIGlzIG5vdCBzdXBwb3J0ZWQgeWV0Jyk7XG4gIH1cblxuICByZXR1cm4gRGF0ZS5VVEMoeWVhciwgbW9uIC0gMSwgZGF5LCBob3VyLCBtaW4sIHNlYywgMCk7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fZGVjb2RlTnVsbCA9IGZ1bmN0aW9uIGRlY29kZU51bGwoYnVmZmVyKSB7XG4gIHJldHVybiBudWxsO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2RlY29kZUJvb2wgPSBmdW5jdGlvbiBkZWNvZGVCb29sKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gYnVmZmVyLnJlYWRVSW50OCgpO1xuICBpZiAoYnVmZmVyLmlzRXJyb3IocmVzKSlcbiAgICByZXR1cm4gcmVzO1xuICBlbHNlXG4gICAgcmV0dXJuIHJlcyAhPT0gMDtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9kZWNvZGVJbnQgPSBmdW5jdGlvbiBkZWNvZGVJbnQoYnVmZmVyLCB2YWx1ZXMpIHtcbiAgLy8gQmlnaW50LCByZXR1cm4gYXMgaXQgaXMgKGFzc3VtZSBiaWcgZW5kaWFuKVxuICB2YXIgcmF3ID0gYnVmZmVyLnJhdygpO1xuICB2YXIgcmVzID0gbmV3IGJpZ251bShyYXcpO1xuXG4gIGlmICh2YWx1ZXMpXG4gICAgcmVzID0gdmFsdWVzW3Jlcy50b1N0cmluZygxMCldIHx8IHJlcztcblxuICByZXR1cm4gcmVzO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX3VzZSA9IGZ1bmN0aW9uIHVzZShlbnRpdHksIG9iaikge1xuICBpZiAodHlwZW9mIGVudGl0eSA9PT0gJ2Z1bmN0aW9uJylcbiAgICBlbnRpdHkgPSBlbnRpdHkob2JqKTtcbiAgcmV0dXJuIGVudGl0eS5fZ2V0RGVjb2RlcignZGVyJykudHJlZTtcbn07XG5cbi8vIFV0aWxpdHkgbWV0aG9kc1xuXG5mdW5jdGlvbiBkZXJEZWNvZGVUYWcoYnVmLCBmYWlsKSB7XG4gIHZhciB0YWcgPSBidWYucmVhZFVJbnQ4KGZhaWwpO1xuICBpZiAoYnVmLmlzRXJyb3IodGFnKSlcbiAgICByZXR1cm4gdGFnO1xuXG4gIHZhciBjbHMgPSBkZXIudGFnQ2xhc3NbdGFnID4+IDZdO1xuICB2YXIgcHJpbWl0aXZlID0gKHRhZyAmIDB4MjApID09PSAwO1xuXG4gIC8vIE11bHRpLW9jdGV0IHRhZyAtIGxvYWRcbiAgaWYgKCh0YWcgJiAweDFmKSA9PT0gMHgxZikge1xuICAgIHZhciBvY3QgPSB0YWc7XG4gICAgdGFnID0gMDtcbiAgICB3aGlsZSAoKG9jdCAmIDB4ODApID09PSAweDgwKSB7XG4gICAgICBvY3QgPSBidWYucmVhZFVJbnQ4KGZhaWwpO1xuICAgICAgaWYgKGJ1Zi5pc0Vycm9yKG9jdCkpXG4gICAgICAgIHJldHVybiBvY3Q7XG5cbiAgICAgIHRhZyA8PD0gNztcbiAgICAgIHRhZyB8PSBvY3QgJiAweDdmO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YWcgJj0gMHgxZjtcbiAgfVxuICB2YXIgdGFnU3RyID0gZGVyLnRhZ1t0YWddO1xuXG4gIHJldHVybiB7XG4gICAgY2xzOiBjbHMsXG4gICAgcHJpbWl0aXZlOiBwcmltaXRpdmUsXG4gICAgdGFnOiB0YWcsXG4gICAgdGFnU3RyOiB0YWdTdHJcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVyRGVjb2RlTGVuKGJ1ZiwgcHJpbWl0aXZlLCBmYWlsKSB7XG4gIHZhciBsZW4gPSBidWYucmVhZFVJbnQ4KGZhaWwpO1xuICBpZiAoYnVmLmlzRXJyb3IobGVuKSlcbiAgICByZXR1cm4gbGVuO1xuXG4gIC8vIEluZGVmaW5pdGUgZm9ybVxuICBpZiAoIXByaW1pdGl2ZSAmJiBsZW4gPT09IDB4ODApXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgLy8gRGVmaW5pdGUgZm9ybVxuICBpZiAoKGxlbiAmIDB4ODApID09PSAwKSB7XG4gICAgLy8gU2hvcnQgZm9ybVxuICAgIHJldHVybiBsZW47XG4gIH1cblxuICAvLyBMb25nIGZvcm1cbiAgdmFyIG51bSA9IGxlbiAmIDB4N2Y7XG4gIGlmIChudW0gPiA0KVxuICAgIHJldHVybiBidWYuZXJyb3IoJ2xlbmd0aCBvY3RlY3QgaXMgdG9vIGxvbmcnKTtcblxuICBsZW4gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgbGVuIDw8PSA4O1xuICAgIHZhciBqID0gYnVmLnJlYWRVSW50OChmYWlsKTtcbiAgICBpZiAoYnVmLmlzRXJyb3IoaikpXG4gICAgICByZXR1cm4gajtcbiAgICBsZW4gfD0gajtcbiAgfVxuXG4gIHJldHVybiBsZW47XG59XG4iLCJ2YXIgZGVjb2RlcnMgPSBleHBvcnRzO1xuXG5kZWNvZGVycy5kZXIgPSByZXF1aXJlKCcuL2RlcicpO1xuZGVjb2RlcnMucGVtID0gcmVxdWlyZSgnLi9wZW0nKTtcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgREVSRGVjb2RlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG5cbmZ1bmN0aW9uIFBFTURlY29kZXIoZW50aXR5KSB7XG4gIERFUkRlY29kZXIuY2FsbCh0aGlzLCBlbnRpdHkpO1xuICB0aGlzLmVuYyA9ICdwZW0nO1xufTtcbmluaGVyaXRzKFBFTURlY29kZXIsIERFUkRlY29kZXIpO1xubW9kdWxlLmV4cG9ydHMgPSBQRU1EZWNvZGVyO1xuXG5QRU1EZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoZGF0YSwgb3B0aW9ucykge1xuICB2YXIgbGluZXMgPSBkYXRhLnRvU3RyaW5nKCkuc3BsaXQoL1tcXHJcXG5dKy9nKTtcblxuICB2YXIgbGFiZWwgPSBvcHRpb25zLmxhYmVsLnRvVXBwZXJDYXNlKCk7XG5cbiAgdmFyIHJlID0gL14tLS0tLShCRUdJTnxFTkQpIChbXi1dKyktLS0tLSQvO1xuICB2YXIgc3RhcnQgPSAtMTtcbiAgdmFyIGVuZCA9IC0xO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1hdGNoID0gbGluZXNbaV0ubWF0Y2gocmUpO1xuICAgIGlmIChtYXRjaCA9PT0gbnVsbClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgaWYgKG1hdGNoWzJdICE9PSBsYWJlbClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgaWYgKG1hdGNoWzFdICE9PSAnQkVHSU4nKVxuICAgICAgICBicmVhaztcbiAgICAgIHN0YXJ0ID0gaTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG1hdGNoWzFdICE9PSAnRU5EJylcbiAgICAgICAgYnJlYWs7XG4gICAgICBlbmQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChzdGFydCA9PT0gLTEgfHwgZW5kID09PSAtMSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BFTSBzZWN0aW9uIG5vdCBmb3VuZCBmb3I6ICcgKyBsYWJlbCk7XG5cbiAgdmFyIGJhc2U2NCA9IGxpbmVzLnNsaWNlKHN0YXJ0ICsgMSwgZW5kKS5qb2luKCcnKTtcbiAgLy8gUmVtb3ZlIGV4Y2Vzc2l2ZSBzeW1ib2xzXG4gIGJhc2U2NC5yZXBsYWNlKC9bXmEtejAtOVxcK1xcLz1dKy9naSwgJycpO1xuXG4gIHZhciBpbnB1dCA9IG5ldyBCdWZmZXIoYmFzZTY0LCAnYmFzZTY0Jyk7XG4gIHJldHVybiBERVJEZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUuY2FsbCh0aGlzLCBpbnB1dCwgb3B0aW9ucyk7XG59O1xuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBhc24xID0gcmVxdWlyZSgnLi4vLi4vYXNuMScpO1xudmFyIGJhc2UgPSBhc24xLmJhc2U7XG5cbi8vIEltcG9ydCBERVIgY29uc3RhbnRzXG52YXIgZGVyID0gYXNuMS5jb25zdGFudHMuZGVyO1xuXG5mdW5jdGlvbiBERVJFbmNvZGVyKGVudGl0eSkge1xuICB0aGlzLmVuYyA9ICdkZXInO1xuICB0aGlzLm5hbWUgPSBlbnRpdHkubmFtZTtcbiAgdGhpcy5lbnRpdHkgPSBlbnRpdHk7XG5cbiAgLy8gQ29uc3RydWN0IGJhc2UgdHJlZVxuICB0aGlzLnRyZWUgPSBuZXcgREVSTm9kZSgpO1xuICB0aGlzLnRyZWUuX2luaXQoZW50aXR5LmJvZHkpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gREVSRW5jb2RlcjtcblxuREVSRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGRhdGEsIHJlcG9ydGVyKSB7XG4gIHJldHVybiB0aGlzLnRyZWUuX2VuY29kZShkYXRhLCByZXBvcnRlcikuam9pbigpO1xufTtcblxuLy8gVHJlZSBtZXRob2RzXG5cbmZ1bmN0aW9uIERFUk5vZGUocGFyZW50KSB7XG4gIGJhc2UuTm9kZS5jYWxsKHRoaXMsICdkZXInLCBwYXJlbnQpO1xufVxuaW5oZXJpdHMoREVSTm9kZSwgYmFzZS5Ob2RlKTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2VuY29kZUNvbXBvc2l0ZSA9IGZ1bmN0aW9uIGVuY29kZUNvbXBvc2l0ZSh0YWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1pdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50KSB7XG4gIHZhciBlbmNvZGVkVGFnID0gZW5jb2RlVGFnKHRhZywgcHJpbWl0aXZlLCBjbHMsIHRoaXMucmVwb3J0ZXIpO1xuXG4gIC8vIFNob3J0IGZvcm1cbiAgaWYgKGNvbnRlbnQubGVuZ3RoIDwgMHg4MCkge1xuICAgIHZhciBoZWFkZXIgPSBuZXcgQnVmZmVyKDIpO1xuICAgIGhlYWRlclswXSA9IGVuY29kZWRUYWc7XG4gICAgaGVhZGVyWzFdID0gY29udGVudC5sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoWyBoZWFkZXIsIGNvbnRlbnQgXSk7XG4gIH1cblxuICAvLyBMb25nIGZvcm1cbiAgLy8gQ291bnQgb2N0ZXRzIHJlcXVpcmVkIHRvIHN0b3JlIGxlbmd0aFxuICB2YXIgbGVuT2N0ZXRzID0gMTtcbiAgZm9yICh2YXIgaSA9IGNvbnRlbnQubGVuZ3RoOyBpID49IDB4MTAwOyBpID4+PSA4KVxuICAgIGxlbk9jdGV0cysrO1xuXG4gIHZhciBoZWFkZXIgPSBuZXcgQnVmZmVyKDEgKyAxICsgbGVuT2N0ZXRzKTtcbiAgaGVhZGVyWzBdID0gZW5jb2RlZFRhZztcbiAgaGVhZGVyWzFdID0gMHg4MCB8IGxlbk9jdGV0cztcblxuICBmb3IgKHZhciBpID0gMSArIGxlbk9jdGV0cywgaiA9IGNvbnRlbnQubGVuZ3RoOyBqID4gMDsgaS0tLCBqID4+PSA4KVxuICAgIGhlYWRlcltpXSA9IGogJiAweGZmO1xuXG4gIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKFsgaGVhZGVyLCBjb250ZW50IF0pO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2VuY29kZVN0ciA9IGZ1bmN0aW9uIGVuY29kZVN0cihzdHIsIHRhZykge1xuICBpZiAodGFnID09PSAnYml0c3RyJykge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKFsgc3RyLnVudXNlZCB8IDAsIHN0ci5kYXRhIF0pO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2JtcHN0cicpIHtcbiAgICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzdHIubGVuZ3RoICogMik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKHN0ci5jaGFyQ29kZUF0KGkpLCBpICogMik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKGJ1Zik7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnbnVtc3RyJykge1xuICAgIGlmICghdGhpcy5faXNOdW1zdHIoc3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ0VuY29kaW5nIG9mIHN0cmluZyB0eXBlOiBudW1zdHIgc3VwcG9ydHMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25seSBkaWdpdHMgYW5kIHNwYWNlJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKHN0cik7XG4gIH0gZWxzZSBpZiAodGFnID09PSAncHJpbnRzdHInKSB7XG4gICAgaWYgKCF0aGlzLl9pc1ByaW50c3RyKHN0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdFbmNvZGluZyBvZiBzdHJpbmcgdHlwZTogcHJpbnRzdHIgc3VwcG9ydHMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25seSBsYXRpbiB1cHBlciBhbmQgbG93ZXIgY2FzZSBsZXR0ZXJzLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkaWdpdHMsIHNwYWNlLCBhcG9zdHJvcGhlLCBsZWZ0IGFuZCByaWd0aCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwYXJlbnRoZXNpcywgcGx1cyBzaWduLCBjb21tYSwgaHlwaGVuLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkb3QsIHNsYXNoLCBjb2xvbiwgZXF1YWwgc2lnbiwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncXVlc3Rpb24gbWFyaycpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihzdHIpO1xuICB9IGVsc2UgaWYgKC9zdHIkLy50ZXN0KHRhZykpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihzdHIpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ29iakRlc2MnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoc3RyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5yZXBvcnRlci5lcnJvcignRW5jb2Rpbmcgb2Ygc3RyaW5nIHR5cGU6ICcgKyB0YWcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgdW5zdXBwb3J0ZWQnKTtcbiAgfVxufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2VuY29kZU9iamlkID0gZnVuY3Rpb24gZW5jb2RlT2JqaWQoaWQsIHZhbHVlcywgcmVsYXRpdmUpIHtcbiAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIXZhbHVlcylcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdzdHJpbmcgb2JqaWQgZ2l2ZW4sIGJ1dCBubyB2YWx1ZXMgbWFwIGZvdW5kJyk7XG4gICAgaWYgKCF2YWx1ZXMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ29iamlkIG5vdCBmb3VuZCBpbiB2YWx1ZXMgbWFwJyk7XG4gICAgaWQgPSB2YWx1ZXNbaWRdLnNwbGl0KC9bXFxzXFwuXSsvZyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZC5sZW5ndGg7IGkrKylcbiAgICAgIGlkW2ldIHw9IDA7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpZCkpIHtcbiAgICBpZCA9IGlkLnNsaWNlKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZC5sZW5ndGg7IGkrKylcbiAgICAgIGlkW2ldIHw9IDA7XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoaWQpKSB7XG4gICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ29iamlkKCkgc2hvdWxkIGJlIGVpdGhlciBhcnJheSBvciBzdHJpbmcsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdnb3Q6ICcgKyBKU09OLnN0cmluZ2lmeShpZCkpO1xuICB9XG5cbiAgaWYgKCFyZWxhdGl2ZSkge1xuICAgIGlmIChpZFsxXSA+PSA0MClcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdTZWNvbmQgb2JqaWQgaWRlbnRpZmllciBPT0InKTtcbiAgICBpZC5zcGxpY2UoMCwgMiwgaWRbMF0gKiA0MCArIGlkWzFdKTtcbiAgfVxuXG4gIC8vIENvdW50IG51bWJlciBvZiBvY3RldHNcbiAgdmFyIHNpemUgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGlkLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlkZW50ID0gaWRbaV07XG4gICAgZm9yIChzaXplKys7IGlkZW50ID49IDB4ODA7IGlkZW50ID4+PSA3KVxuICAgICAgc2l6ZSsrO1xuICB9XG5cbiAgdmFyIG9iamlkID0gbmV3IEJ1ZmZlcihzaXplKTtcbiAgdmFyIG9mZnNldCA9IG9iamlkLmxlbmd0aCAtIDE7XG4gIGZvciAodmFyIGkgPSBpZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBpZGVudCA9IGlkW2ldO1xuICAgIG9iamlkW29mZnNldC0tXSA9IGlkZW50ICYgMHg3ZjtcbiAgICB3aGlsZSAoKGlkZW50ID4+PSA3KSA+IDApXG4gICAgICBvYmppZFtvZmZzZXQtLV0gPSAweDgwIHwgKGlkZW50ICYgMHg3Zik7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihvYmppZCk7XG59O1xuXG5mdW5jdGlvbiB0d28obnVtKSB7XG4gIGlmIChudW0gPCAxMClcbiAgICByZXR1cm4gJzAnICsgbnVtO1xuICBlbHNlXG4gICAgcmV0dXJuIG51bTtcbn1cblxuREVSTm9kZS5wcm90b3R5cGUuX2VuY29kZVRpbWUgPSBmdW5jdGlvbiBlbmNvZGVUaW1lKHRpbWUsIHRhZykge1xuICB2YXIgc3RyO1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHRpbWUpO1xuXG4gIGlmICh0YWcgPT09ICdnZW50aW1lJykge1xuICAgIHN0ciA9IFtcbiAgICAgIHR3byhkYXRlLmdldEZ1bGxZZWFyKCkpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDRGF0ZSgpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ0hvdXJzKCkpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDTWludXRlcygpKSxcbiAgICAgIHR3byhkYXRlLmdldFVUQ1NlY29uZHMoKSksXG4gICAgICAnWidcbiAgICBdLmpvaW4oJycpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3V0Y3RpbWUnKSB7XG4gICAgc3RyID0gW1xuICAgICAgdHdvKGRhdGUuZ2V0RnVsbFllYXIoKSAlIDEwMCksXG4gICAgICB0d28oZGF0ZS5nZXRVVENNb250aCgpICsgMSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENEYXRlKCkpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDSG91cnMoKSksXG4gICAgICB0d28oZGF0ZS5nZXRVVENNaW51dGVzKCkpLFxuICAgICAgdHdvKGRhdGUuZ2V0VVRDU2Vjb25kcygpKSxcbiAgICAgICdaJ1xuICAgIF0uam9pbignJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZXBvcnRlci5lcnJvcignRW5jb2RpbmcgJyArIHRhZyArICcgdGltZSBpcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2VuY29kZVN0cihzdHIsICdvY3RzdHInKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVOdWxsID0gZnVuY3Rpb24gZW5jb2RlTnVsbCgpIHtcbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIoJycpO1xufTtcblxuREVSTm9kZS5wcm90b3R5cGUuX2VuY29kZUludCA9IGZ1bmN0aW9uIGVuY29kZUludChudW0sIHZhbHVlcykge1xuICBpZiAodHlwZW9mIG51bSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIXZhbHVlcylcbiAgICAgIHJldHVybiB0aGlzLnJlcG9ydGVyLmVycm9yKCdTdHJpbmcgaW50IG9yIGVudW0gZ2l2ZW4sIGJ1dCBubyB2YWx1ZXMgbWFwJyk7XG4gICAgaWYgKCF2YWx1ZXMuaGFzT3duUHJvcGVydHkobnVtKSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVwb3J0ZXIuZXJyb3IoJ1ZhbHVlcyBtYXAgZG9lc25cXCd0IGNvbnRhaW46ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobnVtKSk7XG4gICAgfVxuICAgIG51bSA9IHZhbHVlc1tudW1dO1xuICB9XG5cbiAgLy8gQmlnbnVtLCBhc3N1bWUgYmlnIGVuZGlhblxuICBpZiAodHlwZW9mIG51bSAhPT0gJ251bWJlcicgJiYgIUJ1ZmZlci5pc0J1ZmZlcihudW0pKSB7XG4gICAgdmFyIG51bUFycmF5ID0gbnVtLnRvQXJyYXkoKTtcbiAgICBpZiAoIW51bS5zaWduICYmIG51bUFycmF5WzBdICYgMHg4MCkge1xuICAgICAgbnVtQXJyYXkudW5zaGlmdCgwKTtcbiAgICB9XG4gICAgbnVtID0gbmV3IEJ1ZmZlcihudW1BcnJheSk7XG4gIH1cblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG51bSkpIHtcbiAgICB2YXIgc2l6ZSA9IG51bS5sZW5ndGg7XG4gICAgaWYgKG51bS5sZW5ndGggPT09IDApXG4gICAgICBzaXplKys7XG5cbiAgICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcihzaXplKTtcbiAgICBudW0uY29weShvdXQpO1xuICAgIGlmIChudW0ubGVuZ3RoID09PSAwKVxuICAgICAgb3V0WzBdID0gMFxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVFbmNvZGVyQnVmZmVyKG91dCk7XG4gIH1cblxuICBpZiAobnVtIDwgMHg4MClcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihudW0pO1xuXG4gIGlmIChudW0gPCAweDEwMClcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcihbMCwgbnVtXSk7XG5cbiAgdmFyIHNpemUgPSAxO1xuICBmb3IgKHZhciBpID0gbnVtOyBpID49IDB4MTAwOyBpID4+PSA4KVxuICAgIHNpemUrKztcblxuICB2YXIgb3V0ID0gbmV3IEFycmF5KHNpemUpO1xuICBmb3IgKHZhciBpID0gb3V0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgb3V0W2ldID0gbnVtICYgMHhmZjtcbiAgICBudW0gPj49IDg7XG4gIH1cbiAgaWYob3V0WzBdICYgMHg4MCkge1xuICAgIG91dC51bnNoaWZ0KDApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZUVuY29kZXJCdWZmZXIobmV3IEJ1ZmZlcihvdXQpKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl9lbmNvZGVCb29sID0gZnVuY3Rpb24gZW5jb2RlQm9vbCh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fY3JlYXRlRW5jb2RlckJ1ZmZlcih2YWx1ZSA/IDB4ZmYgOiAwKTtcbn07XG5cbkRFUk5vZGUucHJvdG90eXBlLl91c2UgPSBmdW5jdGlvbiB1c2UoZW50aXR5LCBvYmopIHtcbiAgaWYgKHR5cGVvZiBlbnRpdHkgPT09ICdmdW5jdGlvbicpXG4gICAgZW50aXR5ID0gZW50aXR5KG9iaik7XG4gIHJldHVybiBlbnRpdHkuX2dldEVuY29kZXIoJ2RlcicpLnRyZWU7XG59O1xuXG5ERVJOb2RlLnByb3RvdHlwZS5fc2tpcERlZmF1bHQgPSBmdW5jdGlvbiBza2lwRGVmYXVsdChkYXRhQnVmZmVyLCByZXBvcnRlciwgcGFyZW50KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX2Jhc2VTdGF0ZTtcbiAgdmFyIGk7XG4gIGlmIChzdGF0ZVsnZGVmYXVsdCddID09PSBudWxsKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgZGF0YSA9IGRhdGFCdWZmZXIuam9pbigpO1xuICBpZiAoc3RhdGUuZGVmYXVsdEJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuICAgIHN0YXRlLmRlZmF1bHRCdWZmZXIgPSB0aGlzLl9lbmNvZGVWYWx1ZShzdGF0ZVsnZGVmYXVsdCddLCByZXBvcnRlciwgcGFyZW50KS5qb2luKCk7XG5cbiAgaWYgKGRhdGEubGVuZ3RoICE9PSBzdGF0ZS5kZWZhdWx0QnVmZmVyLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgZm9yIChpPTA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKVxuICAgIGlmIChkYXRhW2ldICE9PSBzdGF0ZS5kZWZhdWx0QnVmZmVyW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gVXRpbGl0eSBtZXRob2RzXG5cbmZ1bmN0aW9uIGVuY29kZVRhZyh0YWcsIHByaW1pdGl2ZSwgY2xzLCByZXBvcnRlcikge1xuICB2YXIgcmVzO1xuXG4gIGlmICh0YWcgPT09ICdzZXFvZicpXG4gICAgdGFnID0gJ3NlcSc7XG4gIGVsc2UgaWYgKHRhZyA9PT0gJ3NldG9mJylcbiAgICB0YWcgPSAnc2V0JztcblxuICBpZiAoZGVyLnRhZ0J5TmFtZS5oYXNPd25Qcm9wZXJ0eSh0YWcpKVxuICAgIHJlcyA9IGRlci50YWdCeU5hbWVbdGFnXTtcbiAgZWxzZSBpZiAodHlwZW9mIHRhZyA9PT0gJ251bWJlcicgJiYgKHRhZyB8IDApID09PSB0YWcpXG4gICAgcmVzID0gdGFnO1xuICBlbHNlXG4gICAgcmV0dXJuIHJlcG9ydGVyLmVycm9yKCdVbmtub3duIHRhZzogJyArIHRhZyk7XG5cbiAgaWYgKHJlcyA+PSAweDFmKVxuICAgIHJldHVybiByZXBvcnRlci5lcnJvcignTXVsdGktb2N0ZXQgdGFnIGVuY29kaW5nIHVuc3VwcG9ydGVkJyk7XG5cbiAgaWYgKCFwcmltaXRpdmUpXG4gICAgcmVzIHw9IDB4MjA7XG5cbiAgcmVzIHw9IChkZXIudGFnQ2xhc3NCeU5hbWVbY2xzIHx8ICd1bml2ZXJzYWwnXSA8PCA2KTtcblxuICByZXR1cm4gcmVzO1xufVxuIiwidmFyIGVuY29kZXJzID0gZXhwb3J0cztcblxuZW5jb2RlcnMuZGVyID0gcmVxdWlyZSgnLi9kZXInKTtcbmVuY29kZXJzLnBlbSA9IHJlcXVpcmUoJy4vcGVtJyk7XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG52YXIgREVSRW5jb2RlciA9IHJlcXVpcmUoJy4vZGVyJyk7XG5cbmZ1bmN0aW9uIFBFTUVuY29kZXIoZW50aXR5KSB7XG4gIERFUkVuY29kZXIuY2FsbCh0aGlzLCBlbnRpdHkpO1xuICB0aGlzLmVuYyA9ICdwZW0nO1xufTtcbmluaGVyaXRzKFBFTUVuY29kZXIsIERFUkVuY29kZXIpO1xubW9kdWxlLmV4cG9ydHMgPSBQRU1FbmNvZGVyO1xuXG5QRU1FbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZGF0YSwgb3B0aW9ucykge1xuICB2YXIgYnVmID0gREVSRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlLmNhbGwodGhpcywgZGF0YSk7XG5cbiAgdmFyIHAgPSBidWYudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB2YXIgb3V0ID0gWyAnLS0tLS1CRUdJTiAnICsgb3B0aW9ucy5sYWJlbCArICctLS0tLScgXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSArPSA2NClcbiAgICBvdXQucHVzaChwLnNsaWNlKGksIGkgKyA2NCkpO1xuICBvdXQucHVzaCgnLS0tLS1FTkQgJyArIG9wdGlvbnMubGFiZWwgKyAnLS0tLS0nKTtcbiAgcmV0dXJuIG91dC5qb2luKCdcXG4nKTtcbn07XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBVdGlsc1xuICBmdW5jdGlvbiBhc3NlcnQgKHZhbCwgbXNnKSB7XG4gICAgaWYgKCF2YWwpIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgfVxuXG4gIC8vIENvdWxkIHVzZSBgaW5oZXJpdHNgIG1vZHVsZSwgYnV0IGRvbid0IHdhbnQgdG8gbW92ZSBmcm9tIHNpbmdsZSBmaWxlXG4gIC8vIGFyY2hpdGVjdHVyZSB5ZXQuXG4gIGZ1bmN0aW9uIGluaGVyaXRzIChjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCk7XG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuICB9XG5cbiAgLy8gQk5cblxuICBmdW5jdGlvbiBCTiAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAoQk4uaXNCTihudW1iZXIpKSB7XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIHRoaXMud29yZHMgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIC8vIFJlZHVjdGlvbiBjb250ZXh0XG4gICAgdGhpcy5yZWQgPSBudWxsO1xuXG4gICAgaWYgKG51bWJlciAhPT0gbnVsbCkge1xuICAgICAgaWYgKGJhc2UgPT09ICdsZScgfHwgYmFzZSA9PT0gJ2JlJykge1xuICAgICAgICBlbmRpYW4gPSBiYXNlO1xuICAgICAgICBiYXNlID0gMTA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2luaXQobnVtYmVyIHx8IDAsIGJhc2UgfHwgMTAsIGVuZGlhbiB8fCAnYmUnKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCTjtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLkJOID0gQk47XG4gIH1cblxuICBCTi5CTiA9IEJOO1xuICBCTi53b3JkU2l6ZSA9IDI2O1xuXG4gIHZhciBCdWZmZXI7XG4gIHRyeSB7XG4gICAgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cblxuICBCTi5pc0JOID0gZnVuY3Rpb24gaXNCTiAobnVtKSB7XG4gICAgaWYgKG51bSBpbnN0YW5jZW9mIEJOKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtICE9PSBudWxsICYmIHR5cGVvZiBudW0gPT09ICdvYmplY3QnICYmXG4gICAgICBudW0uY29uc3RydWN0b3Iud29yZFNpemUgPT09IEJOLndvcmRTaXplICYmIEFycmF5LmlzQXJyYXkobnVtLndvcmRzKTtcbiAgfTtcblxuICBCTi5tYXggPSBmdW5jdGlvbiBtYXggKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA+IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5taW4gPSBmdW5jdGlvbiBtaW4gKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA8IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXROdW1iZXIobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXRBcnJheShudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBiYXNlID0gMTY7XG4gICAgfVxuICAgIGFzc2VydChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KTtcblxuICAgIG51bWJlciA9IG51bWJlci50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgJycpO1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgaWYgKG51bWJlclswXSA9PT0gJy0nKSB7XG4gICAgICBzdGFydCsrO1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAxNikge1xuICAgICAgdGhpcy5fcGFyc2VIZXgobnVtYmVyLCBzdGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BhcnNlQmFzZShudW1iZXIsIGJhc2UsIHN0YXJ0KTtcbiAgICB9XG5cbiAgICBpZiAobnVtYmVyWzBdID09PSAnLScpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIHRoaXMuc3RyaXAoKTtcblxuICAgIGlmIChlbmRpYW4gIT09ICdsZScpIHJldHVybjtcblxuICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXROdW1iZXIgPSBmdW5jdGlvbiBfaW5pdE51bWJlciAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICBudW1iZXIgPSAtbnVtYmVyO1xuICAgIH1cbiAgICBpZiAobnVtYmVyIDwgMHg0MDAwMDAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gWyBudW1iZXIgJiAweDNmZmZmZmYgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKG51bWJlciA8IDB4MTAwMDAwMDAwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmZcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChudW1iZXIgPCAweDIwMDAwMDAwMDAwMDAwKTsgLy8gMiBeIDUzICh1bnNhZmUpXG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmLFxuICAgICAgICAxXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAzO1xuICAgIH1cblxuICAgIGlmIChlbmRpYW4gIT09ICdsZScpIHJldHVybjtcblxuICAgIC8vIFJldmVyc2UgdGhlIGJ5dGVzXG4gICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdEFycmF5ID0gZnVuY3Rpb24gX2luaXRBcnJheSAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICAvLyBQZXJoYXBzIGEgVWludDhBcnJheVxuICAgIGFzc2VydCh0eXBlb2YgbnVtYmVyLmxlbmd0aCA9PT0gJ251bWJlcicpO1xuICAgIGlmIChudW1iZXIubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbIDAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKG51bWJlci5sZW5ndGggLyAzKTtcbiAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIH1cblxuICAgIHZhciBqLCB3O1xuICAgIHZhciBvZmYgPSAwO1xuICAgIGlmIChlbmRpYW4gPT09ICdiZScpIHtcbiAgICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSAxLCBqID0gMDsgaSA+PSAwOyBpIC09IDMpIHtcbiAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSAtIDFdIDw8IDgpIHwgKG51bWJlcltpIC0gMl0gPDwgMTYpO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjQ7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbnVtYmVyLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgKyAxXSA8PCA4KSB8IChudW1iZXJbaSArIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlSGV4IChzdHIsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgciA9IDA7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGVuZCk7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuICAgICAgciA8PD0gNDtcblxuICAgICAgLy8gJ2EnIC0gJ2YnXG4gICAgICBpZiAoYyA+PSA0OSAmJiBjIDw9IDU0KSB7XG4gICAgICAgIHIgfD0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgICAvLyAnQScgLSAnRidcbiAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNyAmJiBjIDw9IDIyKSB7XG4gICAgICAgIHIgfD0gYyAtIDE3ICsgMHhhO1xuXG4gICAgICAvLyAnMCcgLSAnOSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgfD0gYyAmIDB4ZjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3BhcnNlSGV4ID0gZnVuY3Rpb24gX3BhcnNlSGV4IChudW1iZXIsIHN0YXJ0KSB7XG4gICAgLy8gQ3JlYXRlIHBvc3NpYmx5IGJpZ2dlciBhcnJheSB0byBlbnN1cmUgdGhhdCBpdCBmaXRzIHRoZSBudW1iZXJcbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbCgobnVtYmVyLmxlbmd0aCAtIHN0YXJ0KSAvIDYpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGosIHc7XG4gICAgLy8gU2NhbiAyNC1iaXQgY2h1bmtzIGFuZCBhZGQgdGhlbSB0byB0aGUgbnVtYmVyXG4gICAgdmFyIG9mZiA9IDA7XG4gICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDYsIGogPSAwOyBpID49IHN0YXJ0OyBpIC09IDYpIHtcbiAgICAgIHcgPSBwYXJzZUhleChudW1iZXIsIGksIGkgKyA2KTtcbiAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgIC8vIE5PVEU6IGAweDNmZmZmZmAgaXMgaW50ZW50aW9uYWwgaGVyZSwgMjZiaXRzIG1heCBzaGlmdCArIDI0Yml0IGhleCBsaW1iXG4gICAgICB0aGlzLndvcmRzW2ogKyAxXSB8PSB3ID4+PiAoMjYgLSBvZmYpICYgMHgzZmZmZmY7XG4gICAgICBvZmYgKz0gMjQ7XG4gICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSArIDYgIT09IHN0YXJ0KSB7XG4gICAgICB3ID0gcGFyc2VIZXgobnVtYmVyLCBzdGFydCwgaSArIDYpO1xuICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgdGhpcy53b3Jkc1tqICsgMV0gfD0gdyA+Pj4gKDI2IC0gb2ZmKSAmIDB4M2ZmZmZmO1xuICAgIH1cbiAgICB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VCYXNlIChzdHIsIHN0YXJ0LCBlbmQsIG11bCkge1xuICAgIHZhciByID0gMDtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuXG4gICAgICByICo9IG11bDtcblxuICAgICAgLy8gJ2EnXG4gICAgICBpZiAoYyA+PSA0OSkge1xuICAgICAgICByICs9IGMgLSA0OSArIDB4YTtcblxuICAgICAgLy8gJ0EnXG4gICAgICB9IGVsc2UgaWYgKGMgPj0gMTcpIHtcbiAgICAgICAgciArPSBjIC0gMTcgKyAweGE7XG5cbiAgICAgIC8vICcwJyAtICc5J1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciArPSBjO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fcGFyc2VCYXNlID0gZnVuY3Rpb24gX3BhcnNlQmFzZSAobnVtYmVyLCBiYXNlLCBzdGFydCkge1xuICAgIC8vIEluaXRpYWxpemUgYXMgemVyb1xuICAgIHRoaXMud29yZHMgPSBbIDAgXTtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG5cbiAgICAvLyBGaW5kIGxlbmd0aCBvZiBsaW1iIGluIGJhc2VcbiAgICBmb3IgKHZhciBsaW1iTGVuID0gMCwgbGltYlBvdyA9IDE7IGxpbWJQb3cgPD0gMHgzZmZmZmZmOyBsaW1iUG93ICo9IGJhc2UpIHtcbiAgICAgIGxpbWJMZW4rKztcbiAgICB9XG4gICAgbGltYkxlbi0tO1xuICAgIGxpbWJQb3cgPSAobGltYlBvdyAvIGJhc2UpIHwgMDtcblxuICAgIHZhciB0b3RhbCA9IG51bWJlci5sZW5ndGggLSBzdGFydDtcbiAgICB2YXIgbW9kID0gdG90YWwgJSBsaW1iTGVuO1xuICAgIHZhciBlbmQgPSBNYXRoLm1pbih0b3RhbCwgdG90YWwgLSBtb2QpICsgc3RhcnQ7XG5cbiAgICB2YXIgd29yZCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGxpbWJMZW4pIHtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBpICsgbGltYkxlbiwgYmFzZSk7XG5cbiAgICAgIHRoaXMuaW11bG4obGltYlBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vZCAhPT0gMCkge1xuICAgICAgdmFyIHBvdyA9IDE7XG4gICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgbnVtYmVyLmxlbmd0aCwgYmFzZSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtb2Q7IGkrKykge1xuICAgICAgICBwb3cgKj0gYmFzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbXVsbihwb3cpO1xuICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKGRlc3QpIHtcbiAgICBkZXN0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc3Qud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgIH1cbiAgICBkZXN0Lmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIGRlc3QubmVnYXRpdmUgPSB0aGlzLm5lZ2F0aXZlO1xuICAgIGRlc3QucmVkID0gdGhpcy5yZWQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciByID0gbmV3IEJOKG51bGwpO1xuICAgIHRoaXMuY29weShyKTtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2V4cGFuZCA9IGZ1bmN0aW9uIF9leHBhbmQgKHNpemUpIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBzaXplKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gUmVtb3ZlIGxlYWRpbmcgYDBgIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zdHJpcCA9IGZ1bmN0aW9uIHN0cmlwICgpIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPiAxICYmIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9ub3JtU2lnbiA9IGZ1bmN0aW9uIF9ub3JtU2lnbiAoKSB7XG4gICAgLy8gLTAgPSAwXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgIHJldHVybiAodGhpcy5yZWQgPyAnPEJOLVI6ICcgOiAnPEJOOiAnKSArIHRoaXMudG9TdHJpbmcoMTYpICsgJz4nO1xuICB9O1xuXG4gIC8qXG5cbiAgdmFyIHplcm9zID0gW107XG4gIHZhciBncm91cFNpemVzID0gW107XG4gIHZhciBncm91cEJhc2VzID0gW107XG5cbiAgdmFyIHMgPSAnJztcbiAgdmFyIGkgPSAtMTtcbiAgd2hpbGUgKCsraSA8IEJOLndvcmRTaXplKSB7XG4gICAgemVyb3NbaV0gPSBzO1xuICAgIHMgKz0gJzAnO1xuICB9XG4gIGdyb3VwU2l6ZXNbMF0gPSAwO1xuICBncm91cFNpemVzWzFdID0gMDtcbiAgZ3JvdXBCYXNlc1swXSA9IDA7XG4gIGdyb3VwQmFzZXNbMV0gPSAwO1xuICB2YXIgYmFzZSA9IDIgLSAxO1xuICB3aGlsZSAoKytiYXNlIDwgMzYgKyAxKSB7XG4gICAgdmFyIGdyb3VwU2l6ZSA9IDA7XG4gICAgdmFyIGdyb3VwQmFzZSA9IDE7XG4gICAgd2hpbGUgKGdyb3VwQmFzZSA8ICgxIDw8IEJOLndvcmRTaXplKSAvIGJhc2UpIHtcbiAgICAgIGdyb3VwQmFzZSAqPSBiYXNlO1xuICAgICAgZ3JvdXBTaXplICs9IDE7XG4gICAgfVxuICAgIGdyb3VwU2l6ZXNbYmFzZV0gPSBncm91cFNpemU7XG4gICAgZ3JvdXBCYXNlc1tiYXNlXSA9IGdyb3VwQmFzZTtcbiAgfVxuXG4gICovXG5cbiAgdmFyIHplcm9zID0gW1xuICAgICcnLFxuICAgICcwJyxcbiAgICAnMDAnLFxuICAgICcwMDAnLFxuICAgICcwMDAwJyxcbiAgICAnMDAwMDAnLFxuICAgICcwMDAwMDAnLFxuICAgICcwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICBdO1xuXG4gIHZhciBncm91cFNpemVzID0gW1xuICAgIDAsIDAsXG4gICAgMjUsIDE2LCAxMiwgMTEsIDEwLCA5LCA4LFxuICAgIDgsIDcsIDcsIDcsIDcsIDYsIDYsXG4gICAgNiwgNiwgNiwgNiwgNiwgNSwgNSxcbiAgICA1LCA1LCA1LCA1LCA1LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDVcbiAgXTtcblxuICB2YXIgZ3JvdXBCYXNlcyA9IFtcbiAgICAwLCAwLFxuICAgIDMzNTU0NDMyLCA0MzA0NjcyMSwgMTY3NzcyMTYsIDQ4ODI4MTI1LCA2MDQ2NjE3NiwgNDAzNTM2MDcsIDE2Nzc3MjE2LFxuICAgIDQzMDQ2NzIxLCAxMDAwMDAwMCwgMTk0ODcxNzEsIDM1ODMxODA4LCA2Mjc0ODUxNywgNzUyOTUzNiwgMTEzOTA2MjUsXG4gICAgMTY3NzcyMTYsIDI0MTM3NTY5LCAzNDAxMjIyNCwgNDcwNDU4ODEsIDY0MDAwMDAwLCA0MDg0MTAxLCA1MTUzNjMyLFxuICAgIDY0MzYzNDMsIDc5NjI2MjQsIDk3NjU2MjUsIDExODgxMzc2LCAxNDM0ODkwNywgMTcyMTAzNjgsIDIwNTExMTQ5LFxuICAgIDI0MzAwMDAwLCAyODYyOTE1MSwgMzM1NTQ0MzIsIDM5MTM1MzkzLCA0NTQzNTQyNCwgNTI1MjE4NzUsIDYwNDY2MTc2XG4gIF07XG5cbiAgQk4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKGJhc2UsIHBhZGRpbmcpIHtcbiAgICBiYXNlID0gYmFzZSB8fCAxMDtcbiAgICBwYWRkaW5nID0gcGFkZGluZyB8IDAgfHwgMTtcblxuICAgIHZhciBvdXQ7XG4gICAgaWYgKGJhc2UgPT09IDE2IHx8IGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBvdXQgPSAnJztcbiAgICAgIHZhciBvZmYgPSAwO1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV07XG4gICAgICAgIHZhciB3b3JkID0gKCgodyA8PCBvZmYpIHwgY2FycnkpICYgMHhmZmZmZmYpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgY2FycnkgPSAodyA+Pj4gKDI0IC0gb2ZmKSkgJiAweGZmZmZmZjtcbiAgICAgICAgaWYgKGNhcnJ5ICE9PSAwIHx8IGkgIT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIG91dCA9IHplcm9zWzYgLSB3b3JkLmxlbmd0aF0gKyB3b3JkICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHdvcmQgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgb2ZmICs9IDI7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgICAgb3V0ID0gY2FycnkudG9TdHJpbmcoMTYpICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpIHtcbiAgICAgIC8vIHZhciBncm91cFNpemUgPSBNYXRoLmZsb29yKEJOLndvcmRTaXplICogTWF0aC5MTjIgLyBNYXRoLmxvZyhiYXNlKSk7XG4gICAgICB2YXIgZ3JvdXBTaXplID0gZ3JvdXBTaXplc1tiYXNlXTtcbiAgICAgIC8vIHZhciBncm91cEJhc2UgPSBNYXRoLnBvdyhiYXNlLCBncm91cFNpemUpO1xuICAgICAgdmFyIGdyb3VwQmFzZSA9IGdyb3VwQmFzZXNbYmFzZV07XG4gICAgICBvdXQgPSAnJztcbiAgICAgIHZhciBjID0gdGhpcy5jbG9uZSgpO1xuICAgICAgYy5uZWdhdGl2ZSA9IDA7XG4gICAgICB3aGlsZSAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgdmFyIHIgPSBjLm1vZG4oZ3JvdXBCYXNlKS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgYyA9IGMuaWRpdm4oZ3JvdXBCYXNlKTtcblxuICAgICAgICBpZiAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgICBvdXQgPSB6ZXJvc1tncm91cFNpemUgLSByLmxlbmd0aF0gKyByICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHIgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGFzc2VydChmYWxzZSwgJ0Jhc2Ugc2hvdWxkIGJlIGJldHdlZW4gMiBhbmQgMzYnKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlciAoKSB7XG4gICAgdmFyIHJldCA9IHRoaXMud29yZHNbMF07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXQgKz0gdGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID09PSAzICYmIHRoaXMud29yZHNbMl0gPT09IDB4MDEpIHtcbiAgICAgIC8vIE5PVEU6IGF0IHRoaXMgc3RhZ2UgaXQgaXMga25vd24gdGhhdCB0aGUgdG9wIGJpdCBpcyBzZXRcbiAgICAgIHJldCArPSAweDEwMDAwMDAwMDAwMDAwICsgKHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiAyKSB7XG4gICAgICBhc3NlcnQoZmFsc2UsICdOdW1iZXIgY2FuIG9ubHkgc2FmZWx5IHN0b3JlIHVwIHRvIDUzIGJpdHMnKTtcbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLm5lZ2F0aXZlICE9PSAwKSA/IC1yZXQgOiByZXQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoMTYpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIHRvQnVmZmVyIChlbmRpYW4sIGxlbmd0aCkge1xuICAgIGFzc2VydCh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyk7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQnVmZmVyLCBlbmRpYW4sIGxlbmd0aCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5IChlbmRpYW4sIGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEFycmF5LCBlbmRpYW4sIGxlbmd0aCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQXJyYXlMaWtlID0gZnVuY3Rpb24gdG9BcnJheUxpa2UgKEFycmF5VHlwZSwgZW5kaWFuLCBsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHRoaXMuYnl0ZUxlbmd0aCgpO1xuICAgIHZhciByZXFMZW5ndGggPSBsZW5ndGggfHwgTWF0aC5tYXgoMSwgYnl0ZUxlbmd0aCk7XG4gICAgYXNzZXJ0KGJ5dGVMZW5ndGggPD0gcmVxTGVuZ3RoLCAnYnl0ZSBhcnJheSBsb25nZXIgdGhhbiBkZXNpcmVkIGxlbmd0aCcpO1xuICAgIGFzc2VydChyZXFMZW5ndGggPiAwLCAnUmVxdWVzdGVkIGFycmF5IGxlbmd0aCA8PSAwJyk7XG5cbiAgICB0aGlzLnN0cmlwKCk7XG4gICAgdmFyIGxpdHRsZUVuZGlhbiA9IGVuZGlhbiA9PT0gJ2xlJztcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5VHlwZShyZXFMZW5ndGgpO1xuXG4gICAgdmFyIGIsIGk7XG4gICAgdmFyIHEgPSB0aGlzLmNsb25lKCk7XG4gICAgaWYgKCFsaXR0bGVFbmRpYW4pIHtcbiAgICAgIC8vIEFzc3VtZSBiaWctZW5kaWFuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcmVxTGVuZ3RoIC0gYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7ICFxLmlzWmVybygpOyBpKyspIHtcbiAgICAgICAgYiA9IHEuYW5kbG4oMHhmZik7XG4gICAgICAgIHEuaXVzaHJuKDgpO1xuXG4gICAgICAgIHJlc1tyZXFMZW5ndGggLSBpIC0gMV0gPSBiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyAhcS5pc1plcm8oKTsgaSsrKSB7XG4gICAgICAgIGIgPSBxLmFuZGxuKDB4ZmYpO1xuICAgICAgICBxLml1c2hybig4KTtcblxuICAgICAgICByZXNbaV0gPSBiO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgaSA8IHJlcUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBpZiAoTWF0aC5jbHozMikge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgcmV0dXJuIDMyIC0gTWF0aC5jbHozMih3KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgdmFyIHQgPSB3O1xuICAgICAgdmFyIHIgPSAwO1xuICAgICAgaWYgKHQgPj0gMHgxMDAwKSB7XG4gICAgICAgIHIgKz0gMTM7XG4gICAgICAgIHQgPj4+PSAxMztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4NDApIHtcbiAgICAgICAgciArPSA3O1xuICAgICAgICB0ID4+Pj0gNztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4OCkge1xuICAgICAgICByICs9IDQ7XG4gICAgICAgIHQgPj4+PSA0O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHgwMikge1xuICAgICAgICByICs9IDI7XG4gICAgICAgIHQgPj4+PSAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHIgKyB0O1xuICAgIH07XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3plcm9CaXRzID0gZnVuY3Rpb24gX3plcm9CaXRzICh3KSB7XG4gICAgLy8gU2hvcnQtY3V0XG4gICAgaWYgKHcgPT09IDApIHJldHVybiAyNjtcblxuICAgIHZhciB0ID0gdztcbiAgICB2YXIgciA9IDA7XG4gICAgaWYgKCh0ICYgMHgxZmZmKSA9PT0gMCkge1xuICAgICAgciArPSAxMztcbiAgICAgIHQgPj4+PSAxMztcbiAgICB9XG4gICAgaWYgKCh0ICYgMHg3ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNztcbiAgICAgIHQgPj4+PSA3O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweGYpID09PSAwKSB7XG4gICAgICByICs9IDQ7XG4gICAgICB0ID4+Pj0gNDtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgzKSA9PT0gMCkge1xuICAgICAgciArPSAyO1xuICAgICAgdCA+Pj49IDI7XG4gICAgfVxuICAgIGlmICgodCAmIDB4MSkgPT09IDApIHtcbiAgICAgIHIrKztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG51bWJlciBvZiB1c2VkIGJpdHMgaW4gYSBCTlxuICBCTi5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24gYml0TGVuZ3RoICgpIHtcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgaGkgPSB0aGlzLl9jb3VudEJpdHModyk7XG4gICAgcmV0dXJuICh0aGlzLmxlbmd0aCAtIDEpICogMjYgKyBoaTtcbiAgfTtcblxuICBmdW5jdGlvbiB0b0JpdEFycmF5IChudW0pIHtcbiAgICB2YXIgdyA9IG5ldyBBcnJheShudW0uYml0TGVuZ3RoKCkpO1xuXG4gICAgZm9yICh2YXIgYml0ID0gMDsgYml0IDwgdy5sZW5ndGg7IGJpdCsrKSB7XG4gICAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gICAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgICB3W2JpdF0gPSAobnVtLndvcmRzW29mZl0gJiAoMSA8PCB3Yml0KSkgPj4+IHdiaXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHc7XG4gIH1cblxuICAvLyBOdW1iZXIgb2YgdHJhaWxpbmcgemVybyBiaXRzXG4gIEJOLnByb3RvdHlwZS56ZXJvQml0cyA9IGZ1bmN0aW9uIHplcm9CaXRzICgpIHtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIDA7XG5cbiAgICB2YXIgciA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYiA9IHRoaXMuX3plcm9CaXRzKHRoaXMud29yZHNbaV0pO1xuICAgICAgciArPSBiO1xuICAgICAgaWYgKGIgIT09IDI2KSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiBieXRlTGVuZ3RoICgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuYml0TGVuZ3RoKCkgLyA4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9Ud29zID0gZnVuY3Rpb24gdG9Ud29zICh3aWR0aCkge1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5hYnMoKS5pbm90bih3aWR0aCkuaWFkZG4oMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21Ud29zID0gZnVuY3Rpb24gZnJvbVR3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMudGVzdG4od2lkdGggLSAxKSkge1xuICAgICAgcmV0dXJuIHRoaXMubm90bih3aWR0aCkuaWFkZG4oMSkuaW5lZygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc05lZyA9IGZ1bmN0aW9uIGlzTmVnICgpIHtcbiAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMDtcbiAgfTtcblxuICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5lZygpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbmVnID0gZnVuY3Rpb24gaW5lZyAoKSB7XG4gICAgaWYgKCF0aGlzLmlzWmVybygpKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1b3IgPSBmdW5jdGlvbiBpdW9yIChudW0pIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gfCBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW9yID0gZnVuY3Rpb24gaW9yIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdW9yKG51bSk7XG4gIH07XG5cbiAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaW9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlvcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudW9yID0gZnVuY3Rpb24gdW9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVvcih0aGlzKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1YW5kID0gZnVuY3Rpb24gaXVhbmQgKG51bSkge1xuICAgIC8vIGIgPSBtaW4tbGVuZ3RoKG51bSwgdGhpcylcbiAgICB2YXIgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldICYgbnVtLndvcmRzW2ldO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYi5sZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYW5kID0gZnVuY3Rpb24gaWFuZCAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVhbmQobnVtKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZCAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhbmQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVhbmQgPSBmdW5jdGlvbiB1YW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1YW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1YW5kKHRoaXMpO1xuICB9O1xuXG4gIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXV4b3IgPSBmdW5jdGlvbiBpdXhvciAobnVtKSB7XG4gICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICAgIHZhciBhO1xuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV0gXiBiLndvcmRzW2ldO1xuICAgIH1cblxuICAgIGlmICh0aGlzICE9PSBhKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLml4b3IgPSBmdW5jdGlvbiBpeG9yIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXhvcihudW0pO1xuICB9O1xuXG4gIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml4b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXhvcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXhvciA9IGZ1bmN0aW9uIHV4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXV4b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXV4b3IodGhpcyk7XG4gIH07XG5cbiAgLy8gTm90IGBgdGhpc2BgIHdpdGggYGB3aWR0aGBgIGJpdHdpZHRoXG4gIEJOLnByb3RvdHlwZS5pbm90biA9IGZ1bmN0aW9uIGlub3RuICh3aWR0aCkge1xuICAgIGFzc2VydCh0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInICYmIHdpZHRoID49IDApO1xuXG4gICAgdmFyIGJ5dGVzTmVlZGVkID0gTWF0aC5jZWlsKHdpZHRoIC8gMjYpIHwgMDtcbiAgICB2YXIgYml0c0xlZnQgPSB3aWR0aCAlIDI2O1xuXG4gICAgLy8gRXh0ZW5kIHRoZSBidWZmZXIgd2l0aCBsZWFkaW5nIHplcm9lc1xuICAgIHRoaXMuX2V4cGFuZChieXRlc05lZWRlZCk7XG5cbiAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG4gICAgICBieXRlc05lZWRlZC0tO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBjb21wbGV0ZSB3b3Jkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXNOZWVkZWQ7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB0aGUgcmVzaWR1ZVxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmICgweDNmZmZmZmYgPj4gKDI2IC0gYml0c0xlZnQpKTtcbiAgICB9XG5cbiAgICAvLyBBbmQgcmVtb3ZlIGxlYWRpbmcgemVyb2VzXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubm90biA9IGZ1bmN0aW9uIG5vdG4gKHdpZHRoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbm90bih3aWR0aCk7XG4gIH07XG5cbiAgLy8gU2V0IGBiaXRgIG9mIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc2V0biA9IGZ1bmN0aW9uIHNldG4gKGJpdCwgdmFsKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcblxuICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgdGhpcy5fZXhwYW5kKG9mZiArIDEpO1xuXG4gICAgaWYgKHZhbCkge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdIHwgKDEgPDwgd2JpdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSAmIH4oMSA8PCB3Yml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIC8vIEFkZCBgbnVtYCB0byBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChudW0pIHtcbiAgICB2YXIgcjtcblxuICAgIC8vIG5lZ2F0aXZlICsgcG9zaXRpdmVcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG5cbiAgICAvLyBwb3NpdGl2ZSArIG5lZ2F0aXZlXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICAgIH1cbiAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGhdID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIC8vIENvcHkgdGhlIHJlc3Qgb2YgdGhlIHdvcmRzXG4gICAgfSBlbHNlIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChudW0pIHtcbiAgICB2YXIgcmVzO1xuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDAgJiYgdGhpcy5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IHRoaXMuc3ViKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgXj0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIGlmIChudW0ubmVnYXRpdmUgPT09IDAgJiYgdGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXMgPSBudW0uc3ViKHRoaXMpO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZChudW0pO1xuXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhZGQodGhpcyk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChudW0pIHtcbiAgICAvLyB0aGlzIC0gKC1udW0pID0gdGhpcyArIG51bVxuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICB2YXIgciA9IHRoaXMuaWFkZChudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuXG4gICAgLy8gLXRoaXMgLSBudW0gPSAtKHRoaXMgKyBudW0pXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaWFkZChudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmVcbiAgICB2YXIgY21wID0gdGhpcy5jbXAobnVtKTtcblxuICAgIC8vIE9wdGltaXphdGlvbiAtIHplcm9pZnlcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gYSA+IGJcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoY21wID4gMCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApIC0gKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIENvcHkgcmVzdCBvZiB0aGUgd29yZHNcbiAgICBpZiAoY2FycnkgPT09IDAgJiYgaSA8IGEubGVuZ3RoICYmIGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpKTtcblxuICAgIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1YihudW0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNtYWxsTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgICB2YXIgbGVuID0gKHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aCkgfCAwO1xuICAgIG91dC5sZW5ndGggPSBsZW47XG4gICAgbGVuID0gKGxlbiAtIDEpIHwgMDtcblxuICAgIC8vIFBlZWwgb25lIGl0ZXJhdGlvbiAoY29tcGlsZXIgY2FuJ3QgZG8gaXQsIGJlY2F1c2Ugb2YgY29kZSBjb21wbGV4aXR5KVxuICAgIHZhciBhID0gc2VsZi53b3Jkc1swXSB8IDA7XG4gICAgdmFyIGIgPSBudW0ud29yZHNbMF0gfCAwO1xuICAgIHZhciByID0gYSAqIGI7XG5cbiAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgIHZhciBjYXJyeSA9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgb3V0LndvcmRzWzBdID0gbG87XG5cbiAgICBmb3IgKHZhciBrID0gMTsgayA8IGxlbjsgaysrKSB7XG4gICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgICAgdmFyIG5jYXJyeSA9IGNhcnJ5ID4+PiAyNjtcbiAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgIHZhciBpID0gKGsgLSBqKSB8IDA7XG4gICAgICAgIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICAgIHIgPSBhICogYiArIHJ3b3JkO1xuICAgICAgICBuY2FycnkgKz0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICAgICAgcndvcmQgPSByICYgMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQgfCAwO1xuICAgICAgY2FycnkgPSBuY2FycnkgfCAwO1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5IHwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfVxuXG4gIC8vIFRPRE8oaW5kdXRueSk6IGl0IG1heSBiZSByZWFzb25hYmxlIHRvIG9taXQgaXQgZm9yIHVzZXJzIHdobyBkb24ndCBuZWVkXG4gIC8vIHRvIHdvcmsgd2l0aCAyNTYtYml0IG51bWJlcnMsIG90aGVyd2lzZSBpdCBnaXZlcyAyMCUgaW1wcm92ZW1lbnQgZm9yIDI1Ni1iaXRcbiAgLy8gbXVsdGlwbGljYXRpb24gKGxpa2UgZWxsaXB0aWMgc2VjcDI1NmsxKS5cbiAgdmFyIGNvbWIxME11bFRvID0gZnVuY3Rpb24gY29tYjEwTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgdmFyIGEgPSBzZWxmLndvcmRzO1xuICAgIHZhciBiID0gbnVtLndvcmRzO1xuICAgIHZhciBvID0gb3V0LndvcmRzO1xuICAgIHZhciBjID0gMDtcbiAgICB2YXIgbG87XG4gICAgdmFyIG1pZDtcbiAgICB2YXIgaGk7XG4gICAgdmFyIGEwID0gYVswXSB8IDA7XG4gICAgdmFyIGFsMCA9IGEwICYgMHgxZmZmO1xuICAgIHZhciBhaDAgPSBhMCA+Pj4gMTM7XG4gICAgdmFyIGExID0gYVsxXSB8IDA7XG4gICAgdmFyIGFsMSA9IGExICYgMHgxZmZmO1xuICAgIHZhciBhaDEgPSBhMSA+Pj4gMTM7XG4gICAgdmFyIGEyID0gYVsyXSB8IDA7XG4gICAgdmFyIGFsMiA9IGEyICYgMHgxZmZmO1xuICAgIHZhciBhaDIgPSBhMiA+Pj4gMTM7XG4gICAgdmFyIGEzID0gYVszXSB8IDA7XG4gICAgdmFyIGFsMyA9IGEzICYgMHgxZmZmO1xuICAgIHZhciBhaDMgPSBhMyA+Pj4gMTM7XG4gICAgdmFyIGE0ID0gYVs0XSB8IDA7XG4gICAgdmFyIGFsNCA9IGE0ICYgMHgxZmZmO1xuICAgIHZhciBhaDQgPSBhNCA+Pj4gMTM7XG4gICAgdmFyIGE1ID0gYVs1XSB8IDA7XG4gICAgdmFyIGFsNSA9IGE1ICYgMHgxZmZmO1xuICAgIHZhciBhaDUgPSBhNSA+Pj4gMTM7XG4gICAgdmFyIGE2ID0gYVs2XSB8IDA7XG4gICAgdmFyIGFsNiA9IGE2ICYgMHgxZmZmO1xuICAgIHZhciBhaDYgPSBhNiA+Pj4gMTM7XG4gICAgdmFyIGE3ID0gYVs3XSB8IDA7XG4gICAgdmFyIGFsNyA9IGE3ICYgMHgxZmZmO1xuICAgIHZhciBhaDcgPSBhNyA+Pj4gMTM7XG4gICAgdmFyIGE4ID0gYVs4XSB8IDA7XG4gICAgdmFyIGFsOCA9IGE4ICYgMHgxZmZmO1xuICAgIHZhciBhaDggPSBhOCA+Pj4gMTM7XG4gICAgdmFyIGE5ID0gYVs5XSB8IDA7XG4gICAgdmFyIGFsOSA9IGE5ICYgMHgxZmZmO1xuICAgIHZhciBhaDkgPSBhOSA+Pj4gMTM7XG4gICAgdmFyIGIwID0gYlswXSB8IDA7XG4gICAgdmFyIGJsMCA9IGIwICYgMHgxZmZmO1xuICAgIHZhciBiaDAgPSBiMCA+Pj4gMTM7XG4gICAgdmFyIGIxID0gYlsxXSB8IDA7XG4gICAgdmFyIGJsMSA9IGIxICYgMHgxZmZmO1xuICAgIHZhciBiaDEgPSBiMSA+Pj4gMTM7XG4gICAgdmFyIGIyID0gYlsyXSB8IDA7XG4gICAgdmFyIGJsMiA9IGIyICYgMHgxZmZmO1xuICAgIHZhciBiaDIgPSBiMiA+Pj4gMTM7XG4gICAgdmFyIGIzID0gYlszXSB8IDA7XG4gICAgdmFyIGJsMyA9IGIzICYgMHgxZmZmO1xuICAgIHZhciBiaDMgPSBiMyA+Pj4gMTM7XG4gICAgdmFyIGI0ID0gYls0XSB8IDA7XG4gICAgdmFyIGJsNCA9IGI0ICYgMHgxZmZmO1xuICAgIHZhciBiaDQgPSBiNCA+Pj4gMTM7XG4gICAgdmFyIGI1ID0gYls1XSB8IDA7XG4gICAgdmFyIGJsNSA9IGI1ICYgMHgxZmZmO1xuICAgIHZhciBiaDUgPSBiNSA+Pj4gMTM7XG4gICAgdmFyIGI2ID0gYls2XSB8IDA7XG4gICAgdmFyIGJsNiA9IGI2ICYgMHgxZmZmO1xuICAgIHZhciBiaDYgPSBiNiA+Pj4gMTM7XG4gICAgdmFyIGI3ID0gYls3XSB8IDA7XG4gICAgdmFyIGJsNyA9IGI3ICYgMHgxZmZmO1xuICAgIHZhciBiaDcgPSBiNyA+Pj4gMTM7XG4gICAgdmFyIGI4ID0gYls4XSB8IDA7XG4gICAgdmFyIGJsOCA9IGI4ICYgMHgxZmZmO1xuICAgIHZhciBiaDggPSBiOCA+Pj4gMTM7XG4gICAgdmFyIGI5ID0gYls5XSB8IDA7XG4gICAgdmFyIGJsOSA9IGI5ICYgMHgxZmZmO1xuICAgIHZhciBiaDkgPSBiOSA+Pj4gMTM7XG5cbiAgICBvdXQubmVnYXRpdmUgPSBzZWxmLm5lZ2F0aXZlIF4gbnVtLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSAxOTtcbiAgICAvKiBrID0gMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwwLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDApO1xuICAgIHZhciB3MCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzAgPj4+IDI2KSkgfCAwO1xuICAgIHcwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgxLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMSkpIHwgMDtcbiAgICB2YXIgdzEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxID4+PiAyNikpIHwgMDtcbiAgICB3MSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDIgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDIsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMiwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMiwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgyKSkgfCAwO1xuICAgIHZhciB3MiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzIgPj4+IDI2KSkgfCAwO1xuICAgIHcyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwzLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgzKSkgfCAwO1xuICAgIHZhciB3MyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzMgPj4+IDI2KSkgfCAwO1xuICAgIHczICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg0LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNCkpIHwgMDtcbiAgICB2YXIgdzQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc0ID4+PiAyNikpIHwgMDtcbiAgICB3NCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDUgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDUsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg1KSkgfCAwO1xuICAgIHZhciB3NSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzUgPj4+IDI2KSkgfCAwO1xuICAgIHc1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw2LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg2KSkgfCAwO1xuICAgIHZhciB3NiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzYgPj4+IDI2KSkgfCAwO1xuICAgIHc2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNykpIHwgMDtcbiAgICB2YXIgdzcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc3ID4+PiAyNikpIHwgMDtcbiAgICB3NyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDggKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDgsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOCwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg4KSkgfCAwO1xuICAgIHZhciB3OCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzggPj4+IDI2KSkgfCAwO1xuICAgIHc4ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg5KSkgfCAwO1xuICAgIHZhciB3OSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzkgPj4+IDI2KSkgfCAwO1xuICAgIHc5ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTAgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgxKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwxKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgxKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMCA+Pj4gMjYpKSB8IDA7XG4gICAgdzEwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTEgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMik7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgyKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwyKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgyKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzExID4+PiAyNikpIHwgMDtcbiAgICB3MTEgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwzKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDMpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDMpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDMpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMiA+Pj4gMjYpKSB8IDA7XG4gICAgdzEyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTMgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg0KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw0KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg0KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMyA+Pj4gMjYpKSB8IDA7XG4gICAgdzEzICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTQgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg1KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw1KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg1KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE0ID4+PiAyNikpIHwgMDtcbiAgICB3MTQgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw2KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDYpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDYpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDYpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNSA+Pj4gMjYpKSB8IDA7XG4gICAgdzE1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTYgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNyk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg3KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw3KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg3KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNiA+Pj4gMjYpKSB8IDA7XG4gICAgdzE2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTcgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg4KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw4KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg4KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE3ID4+PiAyNikpIHwgMDtcbiAgICB3MTcgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw5KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDkpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDkpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDkpO1xuICAgIHZhciB3MTggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxOCA+Pj4gMjYpKSB8IDA7XG4gICAgdzE4ICY9IDB4M2ZmZmZmZjtcbiAgICBvWzBdID0gdzA7XG4gICAgb1sxXSA9IHcxO1xuICAgIG9bMl0gPSB3MjtcbiAgICBvWzNdID0gdzM7XG4gICAgb1s0XSA9IHc0O1xuICAgIG9bNV0gPSB3NTtcbiAgICBvWzZdID0gdzY7XG4gICAgb1s3XSA9IHc3O1xuICAgIG9bOF0gPSB3ODtcbiAgICBvWzldID0gdzk7XG4gICAgb1sxMF0gPSB3MTA7XG4gICAgb1sxMV0gPSB3MTE7XG4gICAgb1sxMl0gPSB3MTI7XG4gICAgb1sxM10gPSB3MTM7XG4gICAgb1sxNF0gPSB3MTQ7XG4gICAgb1sxNV0gPSB3MTU7XG4gICAgb1sxNl0gPSB3MTY7XG4gICAgb1sxN10gPSB3MTc7XG4gICAgb1sxOF0gPSB3MTg7XG4gICAgaWYgKGMgIT09IDApIHtcbiAgICAgIG9bMTldID0gYztcbiAgICAgIG91dC5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcblxuICAvLyBQb2x5ZmlsbCBjb21iXG4gIGlmICghTWF0aC5pbXVsKSB7XG4gICAgY29tYjEwTXVsVG8gPSBzbWFsbE11bFRvO1xuICB9XG5cbiAgZnVuY3Rpb24gYmlnTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0gc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICB2YXIgaG5jYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXQubGVuZ3RoIC0gMTsgaysrKSB7XG4gICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgICAgdmFyIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgICBobmNhcnJ5ID0gMDtcbiAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgIHZhciBpID0gayAtIGo7XG4gICAgICAgIHZhciBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICAgIHZhciBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgdmFyIHIgPSBhICogYjtcblxuICAgICAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKChyIC8gMHg0MDAwMDAwKSB8IDApKSB8IDA7XG4gICAgICAgIGxvID0gKGxvICsgcndvcmQpIHwgMDtcbiAgICAgICAgcndvcmQgPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArIChsbyA+Pj4gMjYpKSB8IDA7XG5cbiAgICAgICAgaG5jYXJyeSArPSBuY2FycnkgPj4+IDI2O1xuICAgICAgICBuY2FycnkgJj0gMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQ7XG4gICAgICBjYXJyeSA9IG5jYXJyeTtcbiAgICAgIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2Fycnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5sZW5ndGgtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG4gIH1cblxuICBmdW5jdGlvbiBqdW1ib011bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIHZhciBmZnRtID0gbmV3IEZGVE0oKTtcbiAgICByZXR1cm4gZmZ0bS5tdWxwKHNlbGYsIG51bSwgb3V0KTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uIG11bFRvIChudW0sIG91dCkge1xuICAgIHZhciByZXM7XG4gICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aDtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEwICYmIG51bS5sZW5ndGggPT09IDEwKSB7XG4gICAgICByZXMgPSBjb21iMTBNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCA2Mykge1xuICAgICAgcmVzID0gc21hbGxNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCAxMDI0KSB7XG4gICAgICByZXMgPSBiaWdNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gQ29vbGV5LVR1a2V5IGFsZ29yaXRobSBmb3IgRkZUXG4gIC8vIHNsaWdodGx5IHJldmlzaXRlZCB0byByZWx5IG9uIGxvb3BpbmcgaW5zdGVhZCBvZiByZWN1cnNpb25cblxuICBmdW5jdGlvbiBGRlRNICh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG5cbiAgRkZUTS5wcm90b3R5cGUubWFrZVJCVCA9IGZ1bmN0aW9uIG1ha2VSQlQgKE4pIHtcbiAgICB2YXIgdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbCA9IEJOLnByb3RvdHlwZS5fY291bnRCaXRzKE4pIC0gMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdFtpXSA9IHRoaXMucmV2QmluKGksIGwsIE4pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYmluYXJ5LXJldmVyc2VkIHJlcHJlc2VudGF0aW9uIG9mIGB4YFxuICBGRlRNLnByb3RvdHlwZS5yZXZCaW4gPSBmdW5jdGlvbiByZXZCaW4gKHgsIGwsIE4pIHtcbiAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSBOIC0gMSkgcmV0dXJuIHg7XG5cbiAgICB2YXIgcmIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICByYiB8PSAoeCAmIDEpIDw8IChsIC0gaSAtIDEpO1xuICAgICAgeCA+Pj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmI7XG4gIH07XG5cbiAgLy8gUGVyZm9ybXMgXCJ0d2VlZGxpbmdcIiBwaGFzZSwgdGhlcmVmb3JlICdlbXVsYXRpbmcnXG4gIC8vIGJlaGF2aW91ciBvZiB0aGUgcmVjdXJzaXZlIGFsZ29yaXRobVxuICBGRlRNLnByb3RvdHlwZS5wZXJtdXRlID0gZnVuY3Rpb24gcGVybXV0ZSAocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBydHdzW2ldID0gcndzW3JidFtpXV07XG4gICAgICBpdHdzW2ldID0gaXdzW3JidFtpXV07XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybSAocndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4sIHJidCkge1xuICAgIHRoaXMucGVybXV0ZShyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKTtcblxuICAgIGZvciAodmFyIHMgPSAxOyBzIDwgTjsgcyA8PD0gMSkge1xuICAgICAgdmFyIGwgPSBzIDw8IDE7XG5cbiAgICAgIHZhciBydHdkZiA9IE1hdGguY29zKDIgKiBNYXRoLlBJIC8gbCk7XG4gICAgICB2YXIgaXR3ZGYgPSBNYXRoLnNpbigyICogTWF0aC5QSSAvIGwpO1xuXG4gICAgICBmb3IgKHZhciBwID0gMDsgcCA8IE47IHAgKz0gbCkge1xuICAgICAgICB2YXIgcnR3ZGZfID0gcnR3ZGY7XG4gICAgICAgIHZhciBpdHdkZl8gPSBpdHdkZjtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHM7IGorKykge1xuICAgICAgICAgIHZhciByZSA9IHJ0d3NbcCArIGpdO1xuICAgICAgICAgIHZhciBpZSA9IGl0d3NbcCArIGpdO1xuXG4gICAgICAgICAgdmFyIHJvID0gcnR3c1twICsgaiArIHNdO1xuICAgICAgICAgIHZhciBpbyA9IGl0d3NbcCArIGogKyBzXTtcblxuICAgICAgICAgIHZhciByeCA9IHJ0d2RmXyAqIHJvIC0gaXR3ZGZfICogaW87XG5cbiAgICAgICAgICBpbyA9IHJ0d2RmXyAqIGlvICsgaXR3ZGZfICogcm87XG4gICAgICAgICAgcm8gPSByeDtcblxuICAgICAgICAgIHJ0d3NbcCArIGpdID0gcmUgKyBybztcbiAgICAgICAgICBpdHdzW3AgKyBqXSA9IGllICsgaW87XG5cbiAgICAgICAgICBydHdzW3AgKyBqICsgc10gPSByZSAtIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGogKyBzXSA9IGllIC0gaW87XG5cbiAgICAgICAgICAvKiBqc2hpbnQgbWF4ZGVwdGggOiBmYWxzZSAqL1xuICAgICAgICAgIGlmIChqICE9PSBsKSB7XG4gICAgICAgICAgICByeCA9IHJ0d2RmICogcnR3ZGZfIC0gaXR3ZGYgKiBpdHdkZl87XG5cbiAgICAgICAgICAgIGl0d2RmXyA9IHJ0d2RmICogaXR3ZGZfICsgaXR3ZGYgKiBydHdkZl87XG4gICAgICAgICAgICBydHdkZl8gPSByeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuZ3Vlc3NMZW4xM2IgPSBmdW5jdGlvbiBndWVzc0xlbjEzYiAobiwgbSkge1xuICAgIHZhciBOID0gTWF0aC5tYXgobSwgbikgfCAxO1xuICAgIHZhciBvZGQgPSBOICYgMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yIChOID0gTiAvIDIgfCAwOyBOOyBOID0gTiA+Pj4gMSkge1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiAxIDw8IGkgKyAxICsgb2RkO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIGNvbmp1Z2F0ZSAocndzLCBpd3MsIE4pIHtcbiAgICBpZiAoTiA8PSAxKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB0ID0gcndzW2ldO1xuXG4gICAgICByd3NbaV0gPSByd3NbTiAtIGkgLSAxXTtcbiAgICAgIHJ3c1tOIC0gaSAtIDFdID0gdDtcblxuICAgICAgdCA9IGl3c1tpXTtcblxuICAgICAgaXdzW2ldID0gLWl3c1tOIC0gaSAtIDFdO1xuICAgICAgaXdzW04gLSBpIC0gMV0gPSAtdDtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubm9ybWFsaXplMTNiID0gZnVuY3Rpb24gbm9ybWFsaXplMTNiICh3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgICB2YXIgdyA9IE1hdGgucm91bmQod3NbMiAqIGkgKyAxXSAvIE4pICogMHgyMDAwICtcbiAgICAgICAgTWF0aC5yb3VuZCh3c1syICogaV0gLyBOKSArXG4gICAgICAgIGNhcnJ5O1xuXG4gICAgICB3c1tpXSA9IHcgJiAweDNmZmZmZmY7XG5cbiAgICAgIGlmICh3IDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcnJ5ID0gdyAvIDB4NDAwMDAwMCB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdzO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbnZlcnQxM2IgPSBmdW5jdGlvbiBjb252ZXJ0MTNiICh3cywgbGVuLCByd3MsIE4pIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNhcnJ5ID0gY2FycnkgKyAod3NbaV0gfCAwKTtcblxuICAgICAgcndzWzIgKiBpXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICAgIHJ3c1syICogaSArIDFdID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgIH1cblxuICAgIC8vIFBhZCB3aXRoIHplcm9lc1xuICAgIGZvciAoaSA9IDIgKiBsZW47IGkgPCBOOyArK2kpIHtcbiAgICAgIHJ3c1tpXSA9IDA7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGNhcnJ5ID09PSAwKTtcbiAgICBhc3NlcnQoKGNhcnJ5ICYgfjB4MWZmZikgPT09IDApO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnN0dWIgPSBmdW5jdGlvbiBzdHViIChOKSB7XG4gICAgdmFyIHBoID0gbmV3IEFycmF5KE4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBwaFtpXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBoO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLm11bHAgPSBmdW5jdGlvbiBtdWxwICh4LCB5LCBvdXQpIHtcbiAgICB2YXIgTiA9IDIgKiB0aGlzLmd1ZXNzTGVuMTNiKHgubGVuZ3RoLCB5Lmxlbmd0aCk7XG5cbiAgICB2YXIgcmJ0ID0gdGhpcy5tYWtlUkJUKE4pO1xuXG4gICAgdmFyIF8gPSB0aGlzLnN0dWIoTik7XG5cbiAgICB2YXIgcndzID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciByd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBpd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIG5yd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5yd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBuaXdzdCA9IG5ldyBBcnJheShOKTtcblxuICAgIHZhciBybXdzID0gb3V0LndvcmRzO1xuICAgIHJtd3MubGVuZ3RoID0gTjtcblxuICAgIHRoaXMuY29udmVydDEzYih4LndvcmRzLCB4Lmxlbmd0aCwgcndzLCBOKTtcbiAgICB0aGlzLmNvbnZlcnQxM2IoeS53b3JkcywgeS5sZW5ndGgsIG5yd3MsIE4pO1xuXG4gICAgdGhpcy50cmFuc2Zvcm0ocndzLCBfLCByd3N0LCBpd3N0LCBOLCByYnQpO1xuICAgIHRoaXMudHJhbnNmb3JtKG5yd3MsIF8sIG5yd3N0LCBuaXdzdCwgTiwgcmJ0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB2YXIgcnggPSByd3N0W2ldICogbnJ3c3RbaV0gLSBpd3N0W2ldICogbml3c3RbaV07XG4gICAgICBpd3N0W2ldID0gcndzdFtpXSAqIG5pd3N0W2ldICsgaXdzdFtpXSAqIG5yd3N0W2ldO1xuICAgICAgcndzdFtpXSA9IHJ4O1xuICAgIH1cblxuICAgIHRoaXMuY29uanVnYXRlKHJ3c3QsIGl3c3QsIE4pO1xuICAgIHRoaXMudHJhbnNmb3JtKHJ3c3QsIGl3c3QsIHJtd3MsIF8sIE4sIHJidCk7XG4gICAgdGhpcy5jb25qdWdhdGUocm13cywgXywgTik7XG4gICAgdGhpcy5ub3JtYWxpemUxM2Iocm13cywgTik7XG5cbiAgICBvdXQubmVnYXRpdmUgPSB4Lm5lZ2F0aXZlIF4geS5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0geC5sZW5ndGggKyB5Lmxlbmd0aDtcbiAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgYHRoaXNgIGJ5IGBudW1gXG4gIEJOLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXMubXVsVG8obnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIE11bHRpcGx5IGVtcGxveWluZyBGRlRcbiAgQk4ucHJvdG90eXBlLm11bGYgPSBmdW5jdGlvbiBtdWxmIChudW0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICAgIHJldHVybiBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBNdWx0aXBsaWNhdGlvblxuICBCTi5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkubXVsVG8obnVtLCB0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW11bG4gPSBmdW5jdGlvbiBpbXVsbiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcblxuICAgIC8vIENhcnJ5XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSAqIG51bTtcbiAgICAgIHZhciBsbyA9ICh3ICYgMHgzZmZmZmZmKSArIChjYXJyeSAmIDB4M2ZmZmZmZik7XG4gICAgICBjYXJyeSA+Pj0gMjY7XG4gICAgICBjYXJyeSArPSAodyAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgLy8gTk9URTogbG8gaXMgMjdiaXQgbWF4aW11bVxuICAgICAgY2FycnkgKz0gbG8gPj4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubXVsbiA9IGZ1bmN0aW9uIG11bG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW11bG4obnVtKTtcbiAgfTtcblxuICAvLyBgdGhpc2AgKiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKHRoaXMpO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKCkge1xuICAgIHJldHVybiB0aGlzLmltdWwodGhpcy5jbG9uZSgpKTtcbiAgfTtcblxuICAvLyBNYXRoLnBvdyhgdGhpc2AsIGBudW1gKVxuICBCTi5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChudW0pIHtcbiAgICB2YXIgdyA9IHRvQml0QXJyYXkobnVtKTtcbiAgICBpZiAody5sZW5ndGggPT09IDApIHJldHVybiBuZXcgQk4oMSk7XG5cbiAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzXG4gICAgdmFyIHJlcyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3Lmxlbmd0aDsgaSsrLCByZXMgPSByZXMuc3FyKCkpIHtcbiAgICAgIGlmICh3W2ldICE9PSAwKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoKytpIDwgdy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIHEgPSByZXMuc3FyKCk7IGkgPCB3Lmxlbmd0aDsgaSsrLCBxID0gcS5zcXIoKSkge1xuICAgICAgICBpZiAod1tpXSA9PT0gMCkgY29udGludWU7XG5cbiAgICAgICAgcmVzID0gcmVzLm11bChxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIFNoaWZ0LWxlZnQgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1c2hsbiA9IGZ1bmN0aW9uIGl1c2hsbiAoYml0cykge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcbiAgICB2YXIgY2FycnlNYXNrID0gKDB4M2ZmZmZmZiA+Pj4gKDI2IC0gcikpIDw8ICgyNiAtIHIpO1xuICAgIHZhciBpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuZXdDYXJyeSA9IHRoaXMud29yZHNbaV0gJiBjYXJyeU1hc2s7XG4gICAgICAgIHZhciBjID0gKCh0aGlzLndvcmRzW2ldIHwgMCkgLSBuZXdDYXJyeSkgPDwgcjtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGMgfCBjYXJyeTtcbiAgICAgICAgY2FycnkgPSBuZXdDYXJyeSA+Pj4gKDI2IC0gcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYXJyeSkge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHMgIT09IDApIHtcbiAgICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgc10gPSB0aGlzLndvcmRzW2ldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCArPSBzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzaGxuID0gZnVuY3Rpb24gaXNobG4gKGJpdHMpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaGxuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LXJpZ2h0IGluLXBsYWNlXG4gIC8vIE5PVEU6IGBoaW50YCBpcyBhIGxvd2VzdCBiaXQgYmVmb3JlIHRyYWlsaW5nIHplcm9lc1xuICAvLyBOT1RFOiBpZiBgZXh0ZW5kZWRgIGlzIHByZXNlbnQgLSBpdCB3aWxsIGJlIGZpbGxlZCB3aXRoIGRlc3Ryb3llZCBiaXRzXG4gIEJOLnByb3RvdHlwZS5pdXNocm4gPSBmdW5jdGlvbiBpdXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciBoO1xuICAgIGlmIChoaW50KSB7XG4gICAgICBoID0gKGhpbnQgLSAoaGludCAlIDI2KSkgLyAyNjtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSBNYXRoLm1pbigoYml0cyAtIHIpIC8gMjYsIHRoaXMubGVuZ3RoKTtcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICB2YXIgbWFza2VkV29yZHMgPSBleHRlbmRlZDtcblxuICAgIGggLT0gcztcbiAgICBoID0gTWF0aC5tYXgoMCwgaCk7XG5cbiAgICAvLyBFeHRlbmRlZCBtb2RlLCBjb3B5IG1hc2tlZCBwYXJ0XG4gICAgaWYgKG1hc2tlZFdvcmRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICBtYXNrZWRXb3Jkcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG4gICAgICBtYXNrZWRXb3Jkcy5sZW5ndGggPSBzO1xuICAgIH1cblxuICAgIGlmIChzID09PSAwKSB7XG4gICAgICAvLyBOby1vcCwgd2Ugc2hvdWxkIG5vdCBtb3ZlIGFueXRoaW5nIGF0IGFsbFxuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiBzKSB7XG4gICAgICB0aGlzLmxlbmd0aCAtPSBzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaSArIHNdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwICYmIChjYXJyeSAhPT0gMCB8fCBpID49IGgpOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB0aGlzLndvcmRzW2ldID0gKGNhcnJ5IDw8ICgyNiAtIHIpKSB8ICh3b3JkID4+PiByKTtcbiAgICAgIGNhcnJ5ID0gd29yZCAmIG1hc2s7XG4gICAgfVxuXG4gICAgLy8gUHVzaCBjYXJyaWVkIGJpdHMgYXMgYSBtYXNrXG4gICAgaWYgKG1hc2tlZFdvcmRzICYmIGNhcnJ5ICE9PSAwKSB7XG4gICAgICBtYXNrZWRXb3Jkcy53b3Jkc1ttYXNrZWRXb3Jkcy5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzaHJuID0gZnVuY3Rpb24gaXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1c2hybihiaXRzLCBoaW50LCBleHRlbmRlZCk7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdFxuICBCTi5wcm90b3R5cGUuc2hsbiA9IGZ1bmN0aW9uIHNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaGxuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hsbiA9IGZ1bmN0aW9uIHVzaGxuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHRcbiAgQk4ucHJvdG90eXBlLnNocm4gPSBmdW5jdGlvbiBzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hybihiaXRzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXNocm4gPSBmdW5jdGlvbiB1c2hybiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaHJuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFRlc3QgaWYgbiBiaXQgaXMgc2V0XG4gIEJOLnByb3RvdHlwZS50ZXN0biA9IGZ1bmN0aW9uIHRlc3RuIChiaXQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuICAgIHZhciByID0gYml0ICUgMjY7XG4gICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgICB2YXIgcSA9IDEgPDwgcjtcblxuICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIENoZWNrIGJpdCBhbmQgcmV0dXJuXG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW3NdO1xuXG4gICAgcmV0dXJuICEhKHcgJiBxKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXIgKGluLXBsYWNlKVxuICBCTi5wcm90b3R5cGUuaW1hc2tuID0gZnVuY3Rpb24gaW1hc2tuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnMnKTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgcysrO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWluKHMsIHRoaXMubGVuZ3RoKTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSAmPSBtYXNrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5tYXNrbiA9IGZ1bmN0aW9uIG1hc2tuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24oYml0cyk7XG4gIH07XG5cbiAgLy8gQWRkIHBsYWluIG51bWJlciBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlhZGRuID0gZnVuY3Rpb24gaWFkZG4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlzdWJuKC1udW0pO1xuXG4gICAgLy8gUG9zc2libGUgc2lnbiBjaGFuZ2VcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmICh0aGlzLndvcmRzWzBdIHwgMCkgPCBudW0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSA9IG51bSAtICh0aGlzLndvcmRzWzBdIHwgMCk7XG4gICAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlzdWJuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRob3V0IGNoZWNrc1xuICAgIHJldHVybiB0aGlzLl9pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faWFkZG4gPSBmdW5jdGlvbiBfaWFkZG4gKG51bSkge1xuICAgIHRoaXMud29yZHNbMF0gKz0gbnVtO1xuXG4gICAgLy8gQ2FycnlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPj0gMHg0MDAwMDAwOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gLT0gMHg0MDAwMDAwO1xuICAgICAgaWYgKGkgPT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSsrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpICsgMSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBwbGFpbiBudW1iZXIgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlzdWJuID0gZnVuY3Rpb24gaXN1Ym4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlhZGRuKC1udW0pO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkbihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLndvcmRzWzBdIC09IG51bTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdIDwgMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IC10aGlzLndvcmRzWzBdO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhcnJ5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPCAwOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSArPSAweDQwMDAwMDA7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdIC09IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWRkbiA9IGZ1bmN0aW9uIGFkZG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZG4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuc3VibiA9IGZ1bmN0aW9uIHN1Ym4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1Ym4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFicyA9IGZ1bmN0aW9uIGlhYnMgKCkge1xuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uIGFicyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pc2hsbnN1Ym11bCA9IGZ1bmN0aW9uIF9pc2hsbnN1Ym11bCAobnVtLCBtdWwsIHNoaWZ0KSB7XG4gICAgdmFyIGxlbiA9IG51bS5sZW5ndGggKyBzaGlmdDtcbiAgICB2YXIgaTtcblxuICAgIHRoaXMuX2V4cGFuZChsZW4pO1xuXG4gICAgdmFyIHc7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgICB2YXIgcmlnaHQgPSAobnVtLndvcmRzW2ldIHwgMCkgKiBtdWw7XG4gICAgICB3IC09IHJpZ2h0ICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSAodyA+PiAyNikgLSAoKHJpZ2h0IC8gMHg0MDAwMDAwKSB8IDApO1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGkgPCB0aGlzLmxlbmd0aCAtIHNoaWZ0OyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ID09PSAwKSByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXG4gICAgLy8gU3VidHJhY3Rpb24gb3ZlcmZsb3dcbiAgICBhc3NlcnQoY2FycnkgPT09IC0xKTtcbiAgICBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAtKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX3dvcmREaXYgPSBmdW5jdGlvbiBfd29yZERpdiAobnVtLCBtb2RlKSB7XG4gICAgdmFyIHNoaWZ0ID0gdGhpcy5sZW5ndGggLSBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW07XG5cbiAgICAvLyBOb3JtYWxpemVcbiAgICB2YXIgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB2YXIgYmhpQml0cyA9IHRoaXMuX2NvdW50Qml0cyhiaGkpO1xuICAgIHNoaWZ0ID0gMjYgLSBiaGlCaXRzO1xuICAgIGlmIChzaGlmdCAhPT0gMCkge1xuICAgICAgYiA9IGIudXNobG4oc2hpZnQpO1xuICAgICAgYS5pdXNobG4oc2hpZnQpO1xuICAgICAgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHF1b3RpZW50XG4gICAgdmFyIG0gPSBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICAgIHZhciBxO1xuXG4gICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICBxID0gbmV3IEJOKG51bGwpO1xuICAgICAgcS5sZW5ndGggPSBtICsgMTtcbiAgICAgIHEud29yZHMgPSBuZXcgQXJyYXkocS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHEud29yZHNbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkaWZmID0gYS5jbG9uZSgpLl9pc2hsbnN1Ym11bChiLCAxLCBtKTtcbiAgICBpZiAoZGlmZi5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgYSA9IGRpZmY7XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW21dID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gbSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICB2YXIgcWogPSAoYS53b3Jkc1tiLmxlbmd0aCArIGpdIHwgMCkgKiAweDQwMDAwMDAgK1xuICAgICAgICAoYS53b3Jkc1tiLmxlbmd0aCArIGogLSAxXSB8IDApO1xuXG4gICAgICAvLyBOT1RFOiAocWogLyBiaGkpIGlzICgweDNmZmZmZmYgKiAweDQwMDAwMDAgKyAweDNmZmZmZmYpIC8gMHgyMDAwMDAwIG1heFxuICAgICAgLy8gKDB4N2ZmZmZmZilcbiAgICAgIHFqID0gTWF0aC5taW4oKHFqIC8gYmhpKSB8IDAsIDB4M2ZmZmZmZik7XG5cbiAgICAgIGEuX2lzaGxuc3VibXVsKGIsIHFqLCBqKTtcbiAgICAgIHdoaWxlIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIHFqLS07XG4gICAgICAgIGEubmVnYXRpdmUgPSAwO1xuICAgICAgICBhLl9pc2hsbnN1Ym11bChiLCAxLCBqKTtcbiAgICAgICAgaWYgKCFhLmlzWmVybygpKSB7XG4gICAgICAgICAgYS5uZWdhdGl2ZSBePSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW2pdID0gcWo7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxKSB7XG4gICAgICBxLnN0cmlwKCk7XG4gICAgfVxuICAgIGEuc3RyaXAoKTtcblxuICAgIC8vIERlbm9ybWFsaXplXG4gICAgaWYgKG1vZGUgIT09ICdkaXYnICYmIHNoaWZ0ICE9PSAwKSB7XG4gICAgICBhLml1c2hybihzaGlmdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpdjogcSB8fCBudWxsLFxuICAgICAgbW9kOiBhXG4gICAgfTtcbiAgfTtcblxuICAvLyBOT1RFOiAxKSBgbW9kZWAgY2FuIGJlIHNldCB0byBgbW9kYCB0byByZXF1ZXN0IG1vZCBvbmx5LFxuICAvLyAgICAgICB0byBgZGl2YCB0byByZXF1ZXN0IGRpdiBvbmx5LCBvciBiZSBhYnNlbnQgdG9cbiAgLy8gICAgICAgcmVxdWVzdCBib3RoIGRpdiAmIG1vZFxuICAvLyAgICAgICAyKSBgcG9zaXRpdmVgIGlzIHRydWUgaWYgdW5zaWduZWQgbW9kIGlzIHJlcXVlc3RlZFxuICBCTi5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24gZGl2bW9kIChudW0sIG1vZGUsIHBvc2l0aXZlKSB7XG4gICAgYXNzZXJ0KCFudW0uaXNaZXJvKCkpO1xuXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IG5ldyBCTigwKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGl2LCBtb2QsIHJlcztcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pYWRkKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogbW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBtb2Q6IHJlcy5tb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCh0aGlzLm5lZ2F0aXZlICYgbnVtLm5lZ2F0aXZlKSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBtb2QuaXN1YihudW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogcmVzLmRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZSBhdCB0aGlzIHBvaW50XG5cbiAgICAvLyBTdHJpcCBib3RoIG51bWJlcnMgdG8gYXBwcm94aW1hdGUgc2hpZnQgdmFsdWVcbiAgICBpZiAobnVtLmxlbmd0aCA+IHRoaXMubGVuZ3RoIHx8IHRoaXMuY21wKG51bSkgPCAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IG5ldyBCTigwKSxcbiAgICAgICAgbW9kOiB0aGlzXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFZlcnkgc2hvcnQgcmVkdWN0aW9uXG4gICAgaWYgKG51bS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChtb2RlID09PSAnZGl2Jykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgICAgbW9kOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlID09PSAnbW9kJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogbnVsbCxcbiAgICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RuKG51bS53b3Jkc1swXSkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93b3JkRGl2KG51bSwgbW9kZSk7XG4gIH07XG5cbiAgLy8gRmluZCBgdGhpc2AgLyBgbnVtYFxuICBCTi5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gZGl2IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnZGl2JywgZmFsc2UpLmRpdjtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAlIGBudW1gXG4gIEJOLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiBtb2QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCBmYWxzZSkubW9kO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51bW9kID0gZnVuY3Rpb24gdW1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIHRydWUpLm1vZDtcbiAgfTtcblxuICAvLyBGaW5kIFJvdW5kKGB0aGlzYCAvIGBudW1gKVxuICBCTi5wcm90b3R5cGUuZGl2Um91bmQgPSBmdW5jdGlvbiBkaXZSb3VuZCAobnVtKSB7XG4gICAgdmFyIGRtID0gdGhpcy5kaXZtb2QobnVtKTtcblxuICAgIC8vIEZhc3QgY2FzZSAtIGV4YWN0IGRpdmlzaW9uXG4gICAgaWYgKGRtLm1vZC5pc1plcm8oKSkgcmV0dXJuIGRtLmRpdjtcblxuICAgIHZhciBtb2QgPSBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5tb2QuaXN1YihudW0pIDogZG0ubW9kO1xuXG4gICAgdmFyIGhhbGYgPSBudW0udXNocm4oMSk7XG4gICAgdmFyIHIyID0gbnVtLmFuZGxuKDEpO1xuICAgIHZhciBjbXAgPSBtb2QuY21wKGhhbGYpO1xuXG4gICAgLy8gUm91bmQgZG93blxuICAgIGlmIChjbXAgPCAwIHx8IHIyID09PSAxICYmIGNtcCA9PT0gMCkgcmV0dXJuIGRtLmRpdjtcblxuICAgIC8vIFJvdW5kIHVwXG4gICAgcmV0dXJuIGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLmRpdi5pc3VibigxKSA6IGRtLmRpdi5pYWRkbigxKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubW9kbiA9IGZ1bmN0aW9uIG1vZG4gKG51bSkge1xuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcbiAgICB2YXIgcCA9ICgxIDw8IDI2KSAlIG51bTtcblxuICAgIHZhciBhY2MgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBhY2MgPSAocCAqIGFjYyArICh0aGlzLndvcmRzW2ldIHwgMCkpICUgbnVtO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgZGl2aXNpb24gYnkgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5pZGl2biA9IGZ1bmN0aW9uIGlkaXZuIChudW0pIHtcbiAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeSAqIDB4NDAwMDAwMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAodyAvIG51bSkgfCAwO1xuICAgICAgY2FycnkgPSB3ICUgbnVtO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmRpdm4gPSBmdW5jdGlvbiBkaXZuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlkaXZuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVnY2QgPSBmdW5jdGlvbiBlZ2NkIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgeCA9IHRoaXM7XG4gICAgdmFyIHkgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoeC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgeCA9IHgudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHguY2xvbmUoKTtcbiAgICB9XG5cbiAgICAvLyBBICogeCArIEIgKiB5ID0geFxuICAgIHZhciBBID0gbmV3IEJOKDEpO1xuICAgIHZhciBCID0gbmV3IEJOKDApO1xuXG4gICAgLy8gQyAqIHggKyBEICogeSA9IHlcbiAgICB2YXIgQyA9IG5ldyBCTigwKTtcbiAgICB2YXIgRCA9IG5ldyBCTigxKTtcblxuICAgIHZhciBnID0gMDtcblxuICAgIHdoaWxlICh4LmlzRXZlbigpICYmIHkuaXNFdmVuKCkpIHtcbiAgICAgIHguaXVzaHJuKDEpO1xuICAgICAgeS5pdXNocm4oMSk7XG4gICAgICArK2c7XG4gICAgfVxuXG4gICAgdmFyIHlwID0geS5jbG9uZSgpO1xuICAgIHZhciB4cCA9IHguY2xvbmUoKTtcblxuICAgIHdoaWxlICgheC5pc1plcm8oKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKHgud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB4Lml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoQS5pc09kZCgpIHx8IEIuaXNPZGQoKSkge1xuICAgICAgICAgICAgQS5pYWRkKHlwKTtcbiAgICAgICAgICAgIEIuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQS5pdXNocm4oMSk7XG4gICAgICAgICAgQi5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKHkud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICB5Lml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoQy5pc09kZCgpIHx8IEQuaXNPZGQoKSkge1xuICAgICAgICAgICAgQy5pYWRkKHlwKTtcbiAgICAgICAgICAgIEQuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQy5pdXNocm4oMSk7XG4gICAgICAgICAgRC5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHguY21wKHkpID49IDApIHtcbiAgICAgICAgeC5pc3ViKHkpO1xuICAgICAgICBBLmlzdWIoQyk7XG4gICAgICAgIEIuaXN1YihEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkuaXN1Yih4KTtcbiAgICAgICAgQy5pc3ViKEEpO1xuICAgICAgICBELmlzdWIoQik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGE6IEMsXG4gICAgICBiOiBELFxuICAgICAgZ2NkOiB5Lml1c2hsbihnKVxuICAgIH07XG4gIH07XG5cbiAgLy8gVGhpcyBpcyByZWR1Y2VkIGluY2FybmF0aW9uIG9mIHRoZSBiaW5hcnkgRUVBXG4gIC8vIGFib3ZlLCBkZXNpZ25hdGVkIHRvIGludmVydCBtZW1iZXJzIG9mIHRoZVxuICAvLyBfcHJpbWVfIGZpZWxkcyBGKHApIGF0IGEgbWF4aW1hbCBzcGVlZFxuICBCTi5wcm90b3R5cGUuX2ludm1wID0gZnVuY3Rpb24gX2ludm1wIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIGIgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgYSA9IGEudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICB2YXIgeDEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIHgyID0gbmV3IEJOKDApO1xuXG4gICAgdmFyIGRlbHRhID0gYi5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKGEuY21wbigxKSA+IDAgJiYgYi5jbXBuKDEpID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKGEud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBhLml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDEuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDEuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDEuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7IChiLndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG4gICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgYi5pdXNocm4oaik7XG4gICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKHgyLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIHgyLmlhZGQoZGVsdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgyLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYS5jbXAoYikgPj0gMCkge1xuICAgICAgICBhLmlzdWIoYik7XG4gICAgICAgIHgxLmlzdWIoeDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYi5pc3ViKGEpO1xuICAgICAgICB4Mi5pc3ViKHgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmIChhLmNtcG4oMSkgPT09IDApIHtcbiAgICAgIHJlcyA9IHgxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB4MjtcbiAgICB9XG5cbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZChwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5nY2QgPSBmdW5jdGlvbiBnY2QgKG51bSkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gbnVtLmFicygpO1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiB0aGlzLmFicygpO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW0uY2xvbmUoKTtcbiAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICBiLm5lZ2F0aXZlID0gMDtcblxuICAgIC8vIFJlbW92ZSBjb21tb24gZmFjdG9yIG9mIHR3b1xuICAgIGZvciAodmFyIHNoaWZ0ID0gMDsgYS5pc0V2ZW4oKSAmJiBiLmlzRXZlbigpOyBzaGlmdCsrKSB7XG4gICAgICBhLml1c2hybigxKTtcbiAgICAgIGIuaXVzaHJuKDEpO1xuICAgIH1cblxuICAgIGRvIHtcbiAgICAgIHdoaWxlIChhLmlzRXZlbigpKSB7XG4gICAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGIuaXNFdmVuKCkpIHtcbiAgICAgICAgYi5pdXNocm4oMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByID0gYS5jbXAoYik7XG4gICAgICBpZiAociA8IDApIHtcbiAgICAgICAgLy8gU3dhcCBgYWAgYW5kIGBiYCB0byBtYWtlIGBhYCBhbHdheXMgYmlnZ2VyIHRoYW4gYGJgXG4gICAgICAgIHZhciB0ID0gYTtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGIgPSB0O1xuICAgICAgfSBlbHNlIGlmIChyID09PSAwIHx8IGIuY21wbigxKSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYS5pc3ViKGIpO1xuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgcmV0dXJuIGIuaXVzaGxuKHNoaWZ0KTtcbiAgfTtcblxuICAvLyBJbnZlcnQgbnVtYmVyIGluIHRoZSBmaWVsZCBGKG51bSlcbiAgQk4ucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5lZ2NkKG51bSkuYS51bW9kKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQgKCkge1xuICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAxO1xuICB9O1xuXG4gIC8vIEFuZCBmaXJzdCB3b3JkIGFuZCBudW1cbiAgQk4ucHJvdG90eXBlLmFuZGxuID0gZnVuY3Rpb24gYW5kbG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLndvcmRzWzBdICYgbnVtO1xuICB9O1xuXG4gIC8vIEluY3JlbWVudCBhdCB0aGUgYml0IHBvc2l0aW9uIGluLWxpbmVcbiAgQk4ucHJvdG90eXBlLmJpbmNuID0gZnVuY3Rpb24gYmluY24gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgICAgdGhpcy5fZXhwYW5kKHMgKyAxKTtcbiAgICAgIHRoaXMud29yZHNbc10gfD0gcTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBiaXQgYW5kIHByb3BhZ2F0ZSwgaWYgbmVlZGVkXG4gICAgdmFyIGNhcnJ5ID0gcTtcbiAgICBmb3IgKHZhciBpID0gczsgY2FycnkgIT09IDAgJiYgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB3ICs9IGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+PiAyNjtcbiAgICAgIHcgJj0gMHgzZmZmZmZmO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHc7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNtcG4gPSBmdW5jdGlvbiBjbXBuIChudW0pIHtcbiAgICB2YXIgbmVnYXRpdmUgPSBudW0gPCAwO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgIW5lZ2F0aXZlKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbmVnYXRpdmUpIHJldHVybiAxO1xuXG4gICAgdGhpcy5zdHJpcCgpO1xuXG4gICAgdmFyIHJlcztcbiAgICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgbnVtID0gLW51bTtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYsICdOdW1iZXIgaXMgdG9vIGJpZycpO1xuXG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbMF0gfCAwO1xuICAgICAgcmVzID0gdyA9PT0gbnVtID8gMCA6IHcgPCBudW0gPyAtMSA6IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb21wYXJlIHR3byBudW1iZXJzIGFuZCByZXR1cm46XG4gIC8vIDEgLSBpZiBgdGhpc2AgPiBgbnVtYFxuICAvLyAwIC0gaWYgYHRoaXNgID09IGBudW1gXG4gIC8vIC0xIC0gaWYgYHRoaXNgIDwgYG51bWBcbiAgQk4ucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uIGNtcCAobnVtKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gMTtcblxuICAgIHZhciByZXMgPSB0aGlzLnVjbXAobnVtKTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gVW5zaWduZWQgY29tcGFyaXNvblxuICBCTi5wcm90b3R5cGUudWNtcCA9IGZ1bmN0aW9uIHVjbXAgKG51bSkge1xuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGhhdmUgdGhlIHNhbWUgc2lnblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiAxO1xuICAgIGlmICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHJldHVybiAtMTtcblxuICAgIHZhciByZXMgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYSA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdmFyIGIgPSBudW0ud29yZHNbaV0gfCAwO1xuXG4gICAgICBpZiAoYSA9PT0gYikgY29udGludWU7XG4gICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmVzID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJlcyA9IDE7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RuID0gZnVuY3Rpb24gZ3RuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24gZ3QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAxO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndGVuID0gZnVuY3Rpb24gZ3RlbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID49IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZSA9IGZ1bmN0aW9uIGd0ZSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRuID0gZnVuY3Rpb24gbHRuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IC0xO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdCA9IGZ1bmN0aW9uIGx0IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ZW4gPSBmdW5jdGlvbiBsdGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPD0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlID0gZnVuY3Rpb24gbHRlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcW4gPSBmdW5jdGlvbiBlcW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDA7XG4gIH07XG5cbiAgLy9cbiAgLy8gQSByZWR1Y2UgY29udGV4dCwgY291bGQgYmUgdXNpbmcgbW9udGdvbWVyeSBvciBzb21ldGhpbmcgYmV0dGVyLCBkZXBlbmRpbmdcbiAgLy8gb24gdGhlIGBtYCBpdHNlbGYuXG4gIC8vXG4gIEJOLnJlZCA9IGZ1bmN0aW9uIHJlZCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBSZWQobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9SZWQgPSBmdW5jdGlvbiB0b1JlZCAoY3R4KSB7XG4gICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgcmV0dXJuIGN0eC5jb252ZXJ0VG8odGhpcykuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21SZWQgPSBmdW5jdGlvbiBmcm9tUmVkICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmNvbnZlcnRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZm9yY2VSZWQgPSBmdW5jdGlvbiBfZm9yY2VSZWQgKGN0eCkge1xuICAgIHRoaXMucmVkID0gY3R4O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mb3JjZVJlZCA9IGZ1bmN0aW9uIGZvcmNlUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIHJldHVybiB0aGlzLl9mb3JjZVJlZChjdHgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRBZGQgPSBmdW5jdGlvbiByZWRBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElBZGQgPSBmdW5jdGlvbiByZWRJQWRkIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFN1YiA9IGZ1bmN0aW9uIHJlZFN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVN1YiA9IGZ1bmN0aW9uIHJlZElTdWIgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU2hsID0gZnVuY3Rpb24gcmVkU2hsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTaGwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNobCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRNdWwgPSBmdW5jdGlvbiByZWRNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5tdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSU11bCA9IGZ1bmN0aW9uIHJlZElNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbXVsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFNxciA9IGZ1bmN0aW9uIHJlZFNxciAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zcXIodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElTcXIgPSBmdW5jdGlvbiByZWRJU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pc3FyKHRoaXMpO1xuICB9O1xuXG4gIC8vIFNxdWFyZSByb290IG92ZXIgcFxuICBCTi5wcm90b3R5cGUucmVkU3FydCA9IGZ1bmN0aW9uIHJlZFNxcnQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxcnQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcnQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEludm0gPSBmdW5jdGlvbiByZWRJbnZtICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJbnZtIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbnZtKHRoaXMpO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2AgJSBgcmVkIG1vZHVsb2BcbiAgQk4ucHJvdG90eXBlLnJlZE5lZyA9IGZ1bmN0aW9uIHJlZE5lZyAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5uZWcodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFBvdyA9IGZ1bmN0aW9uIHJlZFBvdyAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkICYmICFudW0ucmVkLCAncmVkUG93KG5vcm1hbE51bSknKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQucG93KHRoaXMsIG51bSk7XG4gIH07XG5cbiAgLy8gUHJpbWUgbnVtYmVycyB3aXRoIGVmZmljaWVudCByZWR1Y3Rpb25cbiAgdmFyIHByaW1lcyA9IHtcbiAgICBrMjU2OiBudWxsLFxuICAgIHAyMjQ6IG51bGwsXG4gICAgcDE5MjogbnVsbCxcbiAgICBwMjU1MTk6IG51bGxcbiAgfTtcblxuICAvLyBQc2V1ZG8tTWVyc2VubmUgcHJpbWVcbiAgZnVuY3Rpb24gTVByaW1lIChuYW1lLCBwKSB7XG4gICAgLy8gUCA9IDIgXiBOIC0gS1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wID0gbmV3IEJOKHAsIDE2KTtcbiAgICB0aGlzLm4gPSB0aGlzLnAuYml0TGVuZ3RoKCk7XG4gICAgdGhpcy5rID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLm4pLmlzdWIodGhpcy5wKTtcblxuICAgIHRoaXMudG1wID0gdGhpcy5fdG1wKCk7XG4gIH1cblxuICBNUHJpbWUucHJvdG90eXBlLl90bXAgPSBmdW5jdGlvbiBfdG1wICgpIHtcbiAgICB2YXIgdG1wID0gbmV3IEJOKG51bGwpO1xuICAgIHRtcC53b3JkcyA9IG5ldyBBcnJheShNYXRoLmNlaWwodGhpcy5uIC8gMTMpKTtcbiAgICByZXR1cm4gdG1wO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaXJlZHVjZSA9IGZ1bmN0aW9uIGlyZWR1Y2UgKG51bSkge1xuICAgIC8vIEFzc3VtZXMgdGhhdCBgbnVtYCBpcyBsZXNzIHRoYW4gYFBeMmBcbiAgICAvLyBudW0gPSBISSAqICgyIF4gTiAtIEspICsgSEkgKiBLICsgTE8gPSBISSAqIEsgKyBMTyAobW9kIFApXG4gICAgdmFyIHIgPSBudW07XG4gICAgdmFyIHJsZW47XG5cbiAgICBkbyB7XG4gICAgICB0aGlzLnNwbGl0KHIsIHRoaXMudG1wKTtcbiAgICAgIHIgPSB0aGlzLmltdWxLKHIpO1xuICAgICAgciA9IHIuaWFkZCh0aGlzLnRtcCk7XG4gICAgICBybGVuID0gci5iaXRMZW5ndGgoKTtcbiAgICB9IHdoaWxlIChybGVuID4gdGhpcy5uKTtcblxuICAgIHZhciBjbXAgPSBybGVuIDwgdGhpcy5uID8gLTEgOiByLnVjbXAodGhpcy5wKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICByLndvcmRzWzBdID0gMDtcbiAgICAgIHIubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgIHIuaXN1Yih0aGlzLnApO1xuICAgIH0gZWxzZSB7XG4gICAgICByLnN0cmlwKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0KSB7XG4gICAgaW5wdXQuaXVzaHJuKHRoaXMubiwgMCwgb3V0KTtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIHJldHVybiBudW0uaW11bCh0aGlzLmspO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEsyNTYgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdrMjU2JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicpO1xuICB9XG4gIGluaGVyaXRzKEsyNTYsIE1QcmltZSk7XG5cbiAgSzI1Ni5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dHB1dCkge1xuICAgIC8vIDI1NiA9IDkgKiAyNiArIDIyXG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZjtcblxuICAgIHZhciBvdXRMZW4gPSBNYXRoLm1pbihpbnB1dC5sZW5ndGgsIDkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspIHtcbiAgICAgIG91dHB1dC53b3Jkc1tpXSA9IGlucHV0LndvcmRzW2ldO1xuICAgIH1cbiAgICBvdXRwdXQubGVuZ3RoID0gb3V0TGVuO1xuXG4gICAgaWYgKGlucHV0Lmxlbmd0aCA8PSA5KSB7XG4gICAgICBpbnB1dC53b3Jkc1swXSA9IDA7XG4gICAgICBpbnB1dC5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNoaWZ0IGJ5IDkgbGltYnNcbiAgICB2YXIgcHJldiA9IGlucHV0LndvcmRzWzldO1xuICAgIG91dHB1dC53b3Jkc1tvdXRwdXQubGVuZ3RoKytdID0gcHJldiAmIG1hc2s7XG5cbiAgICBmb3IgKGkgPSAxMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dCA9IGlucHV0LndvcmRzW2ldIHwgMDtcbiAgICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSAoKG5leHQgJiBtYXNrKSA8PCA0KSB8IChwcmV2ID4+PiAyMik7XG4gICAgICBwcmV2ID0gbmV4dDtcbiAgICB9XG4gICAgcHJldiA+Pj49IDIyO1xuICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSBwcmV2O1xuICAgIGlmIChwcmV2ID09PSAwICYmIGlucHV0Lmxlbmd0aCA+IDEwKSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSA5O1xuICAgIH1cbiAgfTtcblxuICBLMjU2LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxMDAwMDAzZDEgPSBbIDB4NDAsIDB4M2QxIF1cbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aF0gPSAwO1xuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoICsgMV0gPSAwO1xuICAgIG51bS5sZW5ndGggKz0gMjtcblxuICAgIC8vIGJvdW5kZWQgYXQ6IDB4NDAgKiAweDNmZmZmZmYgKyAweDNkMCA9IDB4MTAwMDAwMzkwXG4gICAgdmFyIGxvID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSBudW0ud29yZHNbaV0gfCAwO1xuICAgICAgbG8gKz0gdyAqIDB4M2QxO1xuICAgICAgbnVtLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICBsbyA9IHcgKiAweDQwICsgKChsbyAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICB9XG5cbiAgICAvLyBGYXN0IGxlbmd0aCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFAyMjQgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMjI0JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScpO1xuICB9XG4gIGluaGVyaXRzKFAyMjQsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDE5MiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AxOTInLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDE5MiwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMjU1MTkgKCkge1xuICAgIC8vIDIgXiAyNTUgLSAxOVxuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICcyNTUxOScsXG4gICAgICAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcpO1xuICB9XG4gIGluaGVyaXRzKFAyNTUxOSwgTVByaW1lKTtcblxuICBQMjU1MTkucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEzXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhpID0gKG51bS53b3Jkc1tpXSB8IDApICogMHgxMyArIGNhcnJ5O1xuICAgICAgdmFyIGxvID0gaGkgJiAweDNmZmZmZmY7XG4gICAgICBoaSA+Pj49IDI2O1xuXG4gICAgICBudW0ud29yZHNbaV0gPSBsbztcbiAgICAgIGNhcnJ5ID0gaGk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgbnVtLndvcmRzW251bS5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICAvLyBFeHBvcnRlZCBtb3N0bHkgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHVzZSBwbGFpbiBuYW1lIGluc3RlYWRcbiAgQk4uX3ByaW1lID0gZnVuY3Rpb24gcHJpbWUgKG5hbWUpIHtcbiAgICAvLyBDYWNoZWQgdmVyc2lvbiBvZiBwcmltZVxuICAgIGlmIChwcmltZXNbbmFtZV0pIHJldHVybiBwcmltZXNbbmFtZV07XG5cbiAgICB2YXIgcHJpbWU7XG4gICAgaWYgKG5hbWUgPT09ICdrMjU2Jykge1xuICAgICAgcHJpbWUgPSBuZXcgSzI1NigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyMjQnKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjI0KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDE5MicpIHtcbiAgICAgIHByaW1lID0gbmV3IFAxOTIoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjU1MTknKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjU1MTkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByaW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgcHJpbWVzW25hbWVdID0gcHJpbWU7XG5cbiAgICByZXR1cm4gcHJpbWU7XG4gIH07XG5cbiAgLy9cbiAgLy8gQmFzZSByZWR1Y3Rpb24gZW5naW5lXG4gIC8vXG4gIGZ1bmN0aW9uIFJlZCAobSkge1xuICAgIGlmICh0eXBlb2YgbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBwcmltZSA9IEJOLl9wcmltZShtKTtcbiAgICAgIHRoaXMubSA9IHByaW1lLnA7XG4gICAgICB0aGlzLnByaW1lID0gcHJpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChtLmd0bigxKSwgJ21vZHVsdXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMScpO1xuICAgICAgdGhpcy5tID0gbTtcbiAgICAgIHRoaXMucHJpbWUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTEgPSBmdW5jdGlvbiBfdmVyaWZ5MSAoYSkge1xuICAgIGFzc2VydChhLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQsICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MiA9IGZ1bmN0aW9uIF92ZXJpZnkyIChhLCBiKSB7XG4gICAgYXNzZXJ0KChhLm5lZ2F0aXZlIHwgYi5uZWdhdGl2ZSkgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCAmJiBhLnJlZCA9PT0gYi5yZWQsXG4gICAgICAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW1vZCA9IGZ1bmN0aW9uIGltb2QgKGEpIHtcbiAgICBpZiAodGhpcy5wcmltZSkgcmV0dXJuIHRoaXMucHJpbWUuaXJlZHVjZShhKS5fZm9yY2VSZWQodGhpcyk7XG4gICAgcmV0dXJuIGEudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm0uc3ViKGEpLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5hZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlhZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLnN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlzdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uIHNobCAoYSwgbnVtKSB7XG4gICAgdGhpcy5fdmVyaWZ5MShhKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEudXNobG4obnVtKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLmltdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEubXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bChhLCBhLmNsb25lKCkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKGEsIGEpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uIHNxcnQgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciBtb2QzID0gdGhpcy5tLmFuZGxuKDMpO1xuICAgIGFzc2VydChtb2QzICUgMiA9PT0gMSk7XG5cbiAgICAvLyBGYXN0IGNhc2VcbiAgICBpZiAobW9kMyA9PT0gMykge1xuICAgICAgdmFyIHBvdyA9IHRoaXMubS5hZGQobmV3IEJOKDEpKS5pdXNocm4oMik7XG4gICAgICByZXR1cm4gdGhpcy5wb3coYSwgcG93KTtcbiAgICB9XG5cbiAgICAvLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG0gKFRvdGFsbHkgdW5vcHRpbWl6ZWQgYW5kIHNsb3cpXG4gICAgLy9cbiAgICAvLyBGaW5kIFEgYW5kIFMsIHRoYXQgUSAqIDIgXiBTID0gKFAgLSAxKVxuICAgIHZhciBxID0gdGhpcy5tLnN1Ym4oMSk7XG4gICAgdmFyIHMgPSAwO1xuICAgIHdoaWxlICghcS5pc1plcm8oKSAmJiBxLmFuZGxuKDEpID09PSAwKSB7XG4gICAgICBzKys7XG4gICAgICBxLml1c2hybigxKTtcbiAgICB9XG4gICAgYXNzZXJ0KCFxLmlzWmVybygpKTtcblxuICAgIHZhciBvbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgdmFyIG5PbmUgPSBvbmUucmVkTmVnKCk7XG5cbiAgICAvLyBGaW5kIHF1YWRyYXRpYyBub24tcmVzaWR1ZVxuICAgIC8vIE5PVEU6IE1heCBpcyBzdWNoIGJlY2F1c2Ugb2YgZ2VuZXJhbGl6ZWQgUmllbWFubiBoeXBvdGhlc2lzLlxuICAgIHZhciBscG93ID0gdGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpO1xuICAgIHZhciB6ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIHogPSBuZXcgQk4oMiAqIHogKiB6KS50b1JlZCh0aGlzKTtcblxuICAgIHdoaWxlICh0aGlzLnBvdyh6LCBscG93KS5jbXAobk9uZSkgIT09IDApIHtcbiAgICAgIHoucmVkSUFkZChuT25lKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMucG93KHosIHEpO1xuICAgIHZhciByID0gdGhpcy5wb3coYSwgcS5hZGRuKDEpLml1c2hybigxKSk7XG4gICAgdmFyIHQgPSB0aGlzLnBvdyhhLCBxKTtcbiAgICB2YXIgbSA9IHM7XG4gICAgd2hpbGUgKHQuY21wKG9uZSkgIT09IDApIHtcbiAgICAgIHZhciB0bXAgPSB0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IHRtcC5jbXAob25lKSAhPT0gMDsgaSsrKSB7XG4gICAgICAgIHRtcCA9IHRtcC5yZWRTcXIoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydChpIDwgbSk7XG4gICAgICB2YXIgYiA9IHRoaXMucG93KGMsIG5ldyBCTigxKS5pdXNobG4obSAtIGkgLSAxKSk7XG5cbiAgICAgIHIgPSByLnJlZE11bChiKTtcbiAgICAgIGMgPSBiLnJlZFNxcigpO1xuICAgICAgdCA9IHQucmVkTXVsKGMpO1xuICAgICAgbSA9IGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIHZhciBpbnYgPSBhLl9pbnZtcCh0aGlzLm0pO1xuICAgIGlmIChpbnYubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGludi5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludikucmVkTmVnKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KTtcbiAgICB9XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKGEsIG51bSkge1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgaWYgKG51bS5jbXBuKDEpID09PSAwKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIHdpbmRvd1NpemUgPSA0O1xuICAgIHZhciB3bmQgPSBuZXcgQXJyYXkoMSA8PCB3aW5kb3dTaXplKTtcbiAgICB3bmRbMF0gPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgd25kWzFdID0gYTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IHduZC5sZW5ndGg7IGkrKykge1xuICAgICAgd25kW2ldID0gdGhpcy5tdWwod25kW2kgLSAxXSwgYSk7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHduZFswXTtcbiAgICB2YXIgY3VycmVudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRMZW4gPSAwO1xuICAgIHZhciBzdGFydCA9IG51bS5iaXRMZW5ndGgoKSAlIDI2O1xuICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBudW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gbnVtLndvcmRzW2ldO1xuICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0IC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgdmFyIGJpdCA9ICh3b3JkID4+IGopICYgMTtcbiAgICAgICAgaWYgKHJlcyAhPT0gd25kWzBdKSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5zcXIocmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiaXQgPT09IDAgJiYgY3VycmVudCA9PT0gMCkge1xuICAgICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA8PD0gMTtcbiAgICAgICAgY3VycmVudCB8PSBiaXQ7XG4gICAgICAgIGN1cnJlbnRMZW4rKztcbiAgICAgICAgaWYgKGN1cnJlbnRMZW4gIT09IHdpbmRvd1NpemUgJiYgKGkgIT09IDAgfHwgaiAhPT0gMCkpIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHRoaXMubXVsKHJlcywgd25kW2N1cnJlbnRdKTtcbiAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgIGN1cnJlbnQgPSAwO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICB2YXIgciA9IG51bS51bW9kKHRoaXMubSk7XG5cbiAgICByZXR1cm4gciA9PT0gbnVtID8gci5jbG9uZSgpIDogcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByZXMgPSBudW0uY2xvbmUoKTtcbiAgICByZXMucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vXG4gIC8vIE1vbnRnb21lcnkgbWV0aG9kIGVuZ2luZVxuICAvL1xuXG4gIEJOLm1vbnQgPSBmdW5jdGlvbiBtb250IChudW0pIHtcbiAgICByZXR1cm4gbmV3IE1vbnQobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBNb250IChtKSB7XG4gICAgUmVkLmNhbGwodGhpcywgbSk7XG5cbiAgICB0aGlzLnNoaWZ0ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIGlmICh0aGlzLnNoaWZ0ICUgMjYgIT09IDApIHtcbiAgICAgIHRoaXMuc2hpZnQgKz0gMjYgLSAodGhpcy5zaGlmdCAlIDI2KTtcbiAgICB9XG5cbiAgICB0aGlzLnIgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMuc2hpZnQpO1xuICAgIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKTtcbiAgICB0aGlzLnJpbnYgPSB0aGlzLnIuX2ludm1wKHRoaXMubSk7XG5cbiAgICB0aGlzLm1pbnYgPSB0aGlzLnJpbnYubXVsKHRoaXMucikuaXN1Ym4oMSkuZGl2KHRoaXMubSk7XG4gICAgdGhpcy5taW52ID0gdGhpcy5taW52LnVtb2QodGhpcy5yKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLnIuc3ViKHRoaXMubWludik7XG4gIH1cbiAgaW5oZXJpdHMoTW9udCwgUmVkKTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmltb2QobnVtLnVzaGxuKHRoaXMuc2hpZnQpKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgciA9IHRoaXMuaW1vZChudW0ubXVsKHRoaXMucmludikpO1xuICAgIHIucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHtcbiAgICAgIGEud29yZHNbMF0gPSAwO1xuICAgICAgYS5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBhLmltdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG5cbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMCkuX2ZvcmNlUmVkKHRoaXMpO1xuXG4gICAgdmFyIHQgPSBhLm11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgLy8gKEFSKV4tMSAqIFJeMiA9IChBXi0xICogUl4tMSkgKiBSXjIgPSBBXi0xICogUlxuICAgIHZhciByZXMgPSB0aGlzLmltb2QoYS5faW52bXAodGhpcy5tKS5tdWwodGhpcy5yMikpO1xuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xufSkodHlwZW9mIG1vZHVsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbW9kdWxlLCB0aGlzKTtcbiIsInZhciByO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJhbmQobGVuKSB7XG4gIGlmICghcilcbiAgICByID0gbmV3IFJhbmQobnVsbCk7XG5cbiAgcmV0dXJuIHIuZ2VuZXJhdGUobGVuKTtcbn07XG5cbmZ1bmN0aW9uIFJhbmQocmFuZCkge1xuICB0aGlzLnJhbmQgPSByYW5kO1xufVxubW9kdWxlLmV4cG9ydHMuUmFuZCA9IFJhbmQ7XG5cblJhbmQucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUobGVuKSB7XG4gIHJldHVybiB0aGlzLl9yYW5kKGxlbik7XG59O1xuXG4vLyBFbXVsYXRlIGNyeXB0byBBUEkgdXNpbmcgcmFuZHlcblJhbmQucHJvdG90eXBlLl9yYW5kID0gZnVuY3Rpb24gX3JhbmQobikge1xuICBpZiAodGhpcy5yYW5kLmdldEJ5dGVzKVxuICAgIHJldHVybiB0aGlzLnJhbmQuZ2V0Qnl0ZXMobik7XG5cbiAgdmFyIHJlcyA9IG5ldyBVaW50OEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkrKylcbiAgICByZXNbaV0gPSB0aGlzLnJhbmQuZ2V0Qnl0ZSgpO1xuICByZXR1cm4gcmVzO1xufTtcblxuaWYgKHR5cGVvZiBzZWxmID09PSAnb2JqZWN0Jykge1xuICBpZiAoc2VsZi5jcnlwdG8gJiYgc2VsZi5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gTW9kZXJuIGJyb3dzZXJzXG4gICAgUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbiBfcmFuZChuKSB7XG4gICAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgICBzZWxmLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKTtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChzZWxmLm1zQ3J5cHRvICYmIHNlbGYubXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gSUVcbiAgICBSYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgIHNlbGYubXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH07XG5cbiAgLy8gU2FmYXJpJ3MgV2ViV29ya2VycyBkbyBub3QgaGF2ZSBgY3J5cHRvYFxuICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gT2xkIGp1bmtcbiAgICBSYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gICAgfTtcbiAgfVxufSBlbHNlIHtcbiAgLy8gTm9kZS5qcyBvciBXZWIgd29ya2VyIHdpdGggbm8gY3J5cHRvIHN1cHBvcnRcbiAgdHJ5IHtcbiAgICB2YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gICAgaWYgKHR5cGVvZiBjcnlwdG8ucmFuZG9tQnl0ZXMgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQnKTtcblxuICAgIFJhbmQucHJvdG90eXBlLl9yYW5kID0gZnVuY3Rpb24gX3JhbmQobikge1xuICAgICAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcyhuKTtcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cbiIsIi8vIGJhc2VkIG9uIHRoZSBhZXMgaW1wbGltZW50YXRpb24gaW4gdHJpcGxlIHNlY1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2tleWJhc2UvdHJpcGxlc2VjXG4vLyB3aGljaCBpcyBpbiB0dXJuIGJhc2VkIG9uIHRoZSBvbmUgZnJvbSBjcnlwdG8tanNcbi8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuZnVuY3Rpb24gYXNVSW50MzJBcnJheSAoYnVmKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcblxuICB2YXIgbGVuID0gKGJ1Zi5sZW5ndGggLyA0KSB8IDBcbiAgdmFyIG91dCA9IG5ldyBBcnJheShsZW4pXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IGJ1Zi5yZWFkVUludDMyQkUoaSAqIDQpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHNjcnViVmVjICh2KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IHYrKykge1xuICAgIHZbaV0gPSAwXG4gIH1cbn1cblxuZnVuY3Rpb24gY3J5cHRCbG9jayAoTSwga2V5U2NoZWR1bGUsIFNVQl9NSVgsIFNCT1gsIG5Sb3VuZHMpIHtcbiAgdmFyIFNVQl9NSVgwID0gU1VCX01JWFswXVxuICB2YXIgU1VCX01JWDEgPSBTVUJfTUlYWzFdXG4gIHZhciBTVUJfTUlYMiA9IFNVQl9NSVhbMl1cbiAgdmFyIFNVQl9NSVgzID0gU1VCX01JWFszXVxuXG4gIHZhciBzMCA9IE1bMF0gXiBrZXlTY2hlZHVsZVswXVxuICB2YXIgczEgPSBNWzFdIF4ga2V5U2NoZWR1bGVbMV1cbiAgdmFyIHMyID0gTVsyXSBeIGtleVNjaGVkdWxlWzJdXG4gIHZhciBzMyA9IE1bM10gXiBrZXlTY2hlZHVsZVszXVxuICB2YXIgdDAsIHQxLCB0MiwgdDNcbiAgdmFyIGtzUm93ID0gNFxuXG4gIGZvciAodmFyIHJvdW5kID0gMTsgcm91bmQgPCBuUm91bmRzOyByb3VuZCsrKSB7XG4gICAgdDAgPSBTVUJfTUlYMFtzMCA+Pj4gMjRdIF4gU1VCX01JWDFbKHMxID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVgyWyhzMiA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVgzW3MzICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHQxID0gU1VCX01JWDBbczEgPj4+IDI0XSBeIFNVQl9NSVgxWyhzMiA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYMlsoczMgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYM1tzMCAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgICB0MiA9IFNVQl9NSVgwW3MyID4+PiAyNF0gXiBTVUJfTUlYMVsoczMgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWDJbKHMwID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWDNbczEgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gICAgdDMgPSBTVUJfTUlYMFtzMyA+Pj4gMjRdIF4gU1VCX01JWDFbKHMwID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVgyWyhzMSA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVgzW3MyICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICAgIHMwID0gdDBcbiAgICBzMSA9IHQxXG4gICAgczIgPSB0MlxuICAgIHMzID0gdDNcbiAgfVxuXG4gIHQwID0gKChTQk9YW3MwID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMxID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczIgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MzICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgdDEgPSAoKFNCT1hbczEgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczIgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMyA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczAgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXVxuICB0MiA9ICgoU0JPWFtzMiA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMyA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMwID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMSAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdXG4gIHQzID0gKChTQk9YW3MzID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMwID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczEgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MyICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK11cbiAgdDAgPSB0MCA+Pj4gMFxuICB0MSA9IHQxID4+PiAwXG4gIHQyID0gdDIgPj4+IDBcbiAgdDMgPSB0MyA+Pj4gMFxuXG4gIHJldHVybiBbdDAsIHQxLCB0MiwgdDNdXG59XG5cbi8vIEFFUyBjb25zdGFudHNcbnZhciBSQ09OID0gWzB4MDAsIDB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdXG52YXIgRyA9IChmdW5jdGlvbiAoKSB7XG4gIC8vIENvbXB1dGUgZG91YmxlIHRhYmxlXG4gIHZhciBkID0gbmV3IEFycmF5KDI1NilcbiAgZm9yICh2YXIgaiA9IDA7IGogPCAyNTY7IGorKykge1xuICAgIGlmIChqIDwgMTI4KSB7XG4gICAgICBkW2pdID0gaiA8PCAxXG4gICAgfSBlbHNlIHtcbiAgICAgIGRbal0gPSAoaiA8PCAxKSBeIDB4MTFiXG4gICAgfVxuICB9XG5cbiAgdmFyIFNCT1ggPSBbXVxuICB2YXIgSU5WX1NCT1ggPSBbXVxuICB2YXIgU1VCX01JWCA9IFtbXSwgW10sIFtdLCBbXV1cbiAgdmFyIElOVl9TVUJfTUlYID0gW1tdLCBbXSwgW10sIFtdXVxuXG4gIC8vIFdhbGsgR0YoMl44KVxuICB2YXIgeCA9IDBcbiAgdmFyIHhpID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgLy8gQ29tcHV0ZSBzYm94XG4gICAgdmFyIHN4ID0geGkgXiAoeGkgPDwgMSkgXiAoeGkgPDwgMikgXiAoeGkgPDwgMykgXiAoeGkgPDwgNClcbiAgICBzeCA9IChzeCA+Pj4gOCkgXiAoc3ggJiAweGZmKSBeIDB4NjNcbiAgICBTQk9YW3hdID0gc3hcbiAgICBJTlZfU0JPWFtzeF0gPSB4XG5cbiAgICAvLyBDb21wdXRlIG11bHRpcGxpY2F0aW9uXG4gICAgdmFyIHgyID0gZFt4XVxuICAgIHZhciB4NCA9IGRbeDJdXG4gICAgdmFyIHg4ID0gZFt4NF1cblxuICAgIC8vIENvbXB1dGUgc3ViIGJ5dGVzLCBtaXggY29sdW1ucyB0YWJsZXNcbiAgICB2YXIgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMClcbiAgICBTVUJfTUlYWzBdW3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpXG4gICAgU1VCX01JWFsxXVt4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNilcbiAgICBTVUJfTUlYWzJdW3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpXG4gICAgU1VCX01JWFszXVt4XSA9IHRcblxuICAgIC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xuICAgIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMClcbiAgICBJTlZfU1VCX01JWFswXVtzeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOClcbiAgICBJTlZfU1VCX01JWFsxXVtzeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpXG4gICAgSU5WX1NVQl9NSVhbMl1bc3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpXG4gICAgSU5WX1NVQl9NSVhbM11bc3hdID0gdFxuXG4gICAgaWYgKHggPT09IDApIHtcbiAgICAgIHggPSB4aSA9IDFcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXVxuICAgICAgeGkgXj0gZFtkW3hpXV1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIFNCT1g6IFNCT1gsXG4gICAgSU5WX1NCT1g6IElOVl9TQk9YLFxuICAgIFNVQl9NSVg6IFNVQl9NSVgsXG4gICAgSU5WX1NVQl9NSVg6IElOVl9TVUJfTUlYXG4gIH1cbn0pKClcblxuZnVuY3Rpb24gQUVTIChrZXkpIHtcbiAgdGhpcy5fa2V5ID0gYXNVSW50MzJBcnJheShrZXkpXG4gIHRoaXMuX3Jlc2V0KClcbn1cblxuQUVTLmJsb2NrU2l6ZSA9IDQgKiA0XG5BRVMua2V5U2l6ZSA9IDI1NiAvIDhcbkFFUy5wcm90b3R5cGUuYmxvY2tTaXplID0gQUVTLmJsb2NrU2l6ZVxuQUVTLnByb3RvdHlwZS5rZXlTaXplID0gQUVTLmtleVNpemVcbkFFUy5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIga2V5V29yZHMgPSB0aGlzLl9rZXlcbiAgdmFyIGtleVNpemUgPSBrZXlXb3Jkcy5sZW5ndGhcbiAgdmFyIG5Sb3VuZHMgPSBrZXlTaXplICsgNlxuICB2YXIga3NSb3dzID0gKG5Sb3VuZHMgKyAxKSAqIDRcblxuICB2YXIga2V5U2NoZWR1bGUgPSBbXVxuICBmb3IgKHZhciBrID0gMDsgayA8IGtleVNpemU7IGsrKykge1xuICAgIGtleVNjaGVkdWxlW2tdID0ga2V5V29yZHNba11cbiAgfVxuXG4gIGZvciAoayA9IGtleVNpemU7IGsgPCBrc1Jvd3M7IGsrKykge1xuICAgIHZhciB0ID0ga2V5U2NoZWR1bGVbayAtIDFdXG5cbiAgICBpZiAoayAlIGtleVNpemUgPT09IDApIHtcbiAgICAgIHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNClcbiAgICAgIHQgPVxuICAgICAgICAoRy5TQk9YW3QgPj4+IDI0XSA8PCAyNCkgfFxuICAgICAgICAoRy5TQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfFxuICAgICAgICAoRy5TQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHxcbiAgICAgICAgKEcuU0JPWFt0ICYgMHhmZl0pXG5cbiAgICAgIHQgXj0gUkNPTlsoayAvIGtleVNpemUpIHwgMF0gPDwgMjRcbiAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGsgJSBrZXlTaXplID09PSA0KSB7XG4gICAgICB0ID1cbiAgICAgICAgKEcuU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHxcbiAgICAgICAgKEcuU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHxcbiAgICAgICAgKEcuU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8XG4gICAgICAgIChHLlNCT1hbdCAmIDB4ZmZdKVxuICAgIH1cblxuICAgIGtleVNjaGVkdWxlW2tdID0ga2V5U2NoZWR1bGVbayAtIGtleVNpemVdIF4gdFxuICB9XG5cbiAgdmFyIGludktleVNjaGVkdWxlID0gW11cbiAgZm9yICh2YXIgaWsgPSAwOyBpayA8IGtzUm93czsgaWsrKykge1xuICAgIHZhciBrc1IgPSBrc1Jvd3MgLSBpa1xuICAgIHZhciB0dCA9IGtleVNjaGVkdWxlW2tzUiAtIChpayAlIDQgPyAwIDogNCldXG5cbiAgICBpZiAoaWsgPCA0IHx8IGtzUiA8PSA0KSB7XG4gICAgICBpbnZLZXlTY2hlZHVsZVtpa10gPSB0dFxuICAgIH0gZWxzZSB7XG4gICAgICBpbnZLZXlTY2hlZHVsZVtpa10gPVxuICAgICAgICBHLklOVl9TVUJfTUlYWzBdW0cuU0JPWFt0dCA+Pj4gMjRdXSBeXG4gICAgICAgIEcuSU5WX1NVQl9NSVhbMV1bRy5TQk9YWyh0dCA+Pj4gMTYpICYgMHhmZl1dIF5cbiAgICAgICAgRy5JTlZfU1VCX01JWFsyXVtHLlNCT1hbKHR0ID4+PiA4KSAmIDB4ZmZdXSBeXG4gICAgICAgIEcuSU5WX1NVQl9NSVhbM11bRy5TQk9YW3R0ICYgMHhmZl1dXG4gICAgfVxuICB9XG5cbiAgdGhpcy5fblJvdW5kcyA9IG5Sb3VuZHNcbiAgdGhpcy5fa2V5U2NoZWR1bGUgPSBrZXlTY2hlZHVsZVxuICB0aGlzLl9pbnZLZXlTY2hlZHVsZSA9IGludktleVNjaGVkdWxlXG59XG5cbkFFUy5wcm90b3R5cGUuZW5jcnlwdEJsb2NrUmF3ID0gZnVuY3Rpb24gKE0pIHtcbiAgTSA9IGFzVUludDMyQXJyYXkoTSlcbiAgcmV0dXJuIGNyeXB0QmxvY2soTSwgdGhpcy5fa2V5U2NoZWR1bGUsIEcuU1VCX01JWCwgRy5TQk9YLCB0aGlzLl9uUm91bmRzKVxufVxuXG5BRVMucHJvdG90eXBlLmVuY3J5cHRCbG9jayA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBvdXQgPSB0aGlzLmVuY3J5cHRCbG9ja1JhdyhNKVxuICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDE2KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMF0sIDApXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsxXSwgNClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzJdLCA4KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbM10sIDEyKVxuICByZXR1cm4gYnVmXG59XG5cbkFFUy5wcm90b3R5cGUuZGVjcnlwdEJsb2NrID0gZnVuY3Rpb24gKE0pIHtcbiAgTSA9IGFzVUludDMyQXJyYXkoTSlcblxuICAvLyBzd2FwXG4gIHZhciBtMSA9IE1bMV1cbiAgTVsxXSA9IE1bM11cbiAgTVszXSA9IG0xXG5cbiAgdmFyIG91dCA9IGNyeXB0QmxvY2soTSwgdGhpcy5faW52S2V5U2NoZWR1bGUsIEcuSU5WX1NVQl9NSVgsIEcuSU5WX1NCT1gsIHRoaXMuX25Sb3VuZHMpXG4gIHZhciBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFswXSwgMClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzNdLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMl0sIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFsxXSwgMTIpXG4gIHJldHVybiBidWZcbn1cblxuQUVTLnByb3RvdHlwZS5zY3J1YiA9IGZ1bmN0aW9uICgpIHtcbiAgc2NydWJWZWModGhpcy5fa2V5U2NoZWR1bGUpXG4gIHNjcnViVmVjKHRoaXMuX2ludktleVNjaGVkdWxlKVxuICBzY3J1YlZlYyh0aGlzLl9rZXkpXG59XG5cbm1vZHVsZS5leHBvcnRzLkFFUyA9IEFFU1xuIiwidmFyIGFlcyA9IHJlcXVpcmUoJy4vYWVzJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBHSEFTSCA9IHJlcXVpcmUoJy4vZ2hhc2gnKVxudmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxudmFyIGluY3IzMiA9IHJlcXVpcmUoJy4vaW5jcjMyJylcblxuZnVuY3Rpb24geG9yVGVzdCAoYSwgYikge1xuICB2YXIgb3V0ID0gMFxuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSBvdXQrK1xuXG4gIHZhciBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBvdXQgKz0gKGFbaV0gXiBiW2ldKVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBjYWxjSXYgKHNlbGYsIGl2LCBjaykge1xuICBpZiAoaXYubGVuZ3RoID09PSAxMikge1xuICAgIHNlbGYuX2ZpbklEID0gQnVmZmVyLmNvbmNhdChbaXYsIEJ1ZmZlci5mcm9tKFswLCAwLCAwLCAxXSldKVxuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtpdiwgQnVmZmVyLmZyb20oWzAsIDAsIDAsIDJdKV0pXG4gIH1cbiAgdmFyIGdoYXNoID0gbmV3IEdIQVNIKGNrKVxuICB2YXIgbGVuID0gaXYubGVuZ3RoXG4gIHZhciB0b1BhZCA9IGxlbiAlIDE2XG4gIGdoYXNoLnVwZGF0ZShpdilcbiAgaWYgKHRvUGFkKSB7XG4gICAgdG9QYWQgPSAxNiAtIHRvUGFkXG4gICAgZ2hhc2gudXBkYXRlKEJ1ZmZlci5hbGxvYyh0b1BhZCwgMCkpXG4gIH1cbiAgZ2hhc2gudXBkYXRlKEJ1ZmZlci5hbGxvYyg4LCAwKSlcbiAgdmFyIGl2Qml0cyA9IGxlbiAqIDhcbiAgdmFyIHRhaWwgPSBCdWZmZXIuYWxsb2MoOClcbiAgdGFpbC53cml0ZVVJbnRCRShpdkJpdHMsIDAsIDgpXG4gIGdoYXNoLnVwZGF0ZSh0YWlsKVxuICBzZWxmLl9maW5JRCA9IGdoYXNoLnN0YXRlXG4gIHZhciBvdXQgPSBCdWZmZXIuZnJvbShzZWxmLl9maW5JRClcbiAgaW5jcjMyKG91dClcbiAgcmV0dXJuIG91dFxufVxuZnVuY3Rpb24gU3RyZWFtQ2lwaGVyIChtb2RlLCBrZXksIGl2LCBkZWNyeXB0KSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG5cbiAgdmFyIGggPSBCdWZmZXIuYWxsb2MoNCwgMClcblxuICB0aGlzLl9jaXBoZXIgPSBuZXcgYWVzLkFFUyhrZXkpXG4gIHZhciBjayA9IHRoaXMuX2NpcGhlci5lbmNyeXB0QmxvY2soaClcbiAgdGhpcy5fZ2hhc2ggPSBuZXcgR0hBU0goY2spXG4gIGl2ID0gY2FsY0l2KHRoaXMsIGl2LCBjaylcblxuICB0aGlzLl9wcmV2ID0gQnVmZmVyLmZyb20oaXYpXG4gIHRoaXMuX2NhY2hlID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG4gIHRoaXMuX3NlY0NhY2hlID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG4gIHRoaXMuX2RlY3J5cHQgPSBkZWNyeXB0XG4gIHRoaXMuX2FsZW4gPSAwXG4gIHRoaXMuX2xlbiA9IDBcbiAgdGhpcy5fbW9kZSA9IG1vZGVcblxuICB0aGlzLl9hdXRoVGFnID0gbnVsbFxuICB0aGlzLl9jYWxsZWQgPSBmYWxzZVxufVxuXG5pbmhlcml0cyhTdHJlYW1DaXBoZXIsIFRyYW5zZm9ybSlcblxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIGlmICghdGhpcy5fY2FsbGVkICYmIHRoaXMuX2FsZW4pIHtcbiAgICB2YXIgcnVtcCA9IDE2IC0gKHRoaXMuX2FsZW4gJSAxNilcbiAgICBpZiAocnVtcCA8IDE2KSB7XG4gICAgICBydW1wID0gQnVmZmVyLmFsbG9jKHJ1bXAsIDApXG4gICAgICB0aGlzLl9naGFzaC51cGRhdGUocnVtcClcbiAgICB9XG4gIH1cblxuICB0aGlzLl9jYWxsZWQgPSB0cnVlXG4gIHZhciBvdXQgPSB0aGlzLl9tb2RlLmVuY3J5cHQodGhpcywgY2h1bmspXG4gIGlmICh0aGlzLl9kZWNyeXB0KSB7XG4gICAgdGhpcy5fZ2hhc2gudXBkYXRlKGNodW5rKVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2doYXNoLnVwZGF0ZShvdXQpXG4gIH1cbiAgdGhpcy5fbGVuICs9IGNodW5rLmxlbmd0aFxuICByZXR1cm4gb3V0XG59XG5cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZGVjcnlwdCAmJiAhdGhpcy5fYXV0aFRhZykgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzdGF0ZSBvciB1bmFibGUgdG8gYXV0aGVudGljYXRlIGRhdGEnKVxuXG4gIHZhciB0YWcgPSB4b3IodGhpcy5fZ2hhc2guZmluYWwodGhpcy5fYWxlbiAqIDgsIHRoaXMuX2xlbiAqIDgpLCB0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHRoaXMuX2ZpbklEKSlcbiAgaWYgKHRoaXMuX2RlY3J5cHQgJiYgeG9yVGVzdCh0YWcsIHRoaXMuX2F1dGhUYWcpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHN0YXRlIG9yIHVuYWJsZSB0byBhdXRoZW50aWNhdGUgZGF0YScpXG5cbiAgdGhpcy5fYXV0aFRhZyA9IHRhZ1xuICB0aGlzLl9jaXBoZXIuc2NydWIoKVxufVxuXG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLmdldEF1dGhUYWcgPSBmdW5jdGlvbiBnZXRBdXRoVGFnICgpIHtcbiAgaWYgKHRoaXMuX2RlY3J5cHQgfHwgIUJ1ZmZlci5pc0J1ZmZlcih0aGlzLl9hdXRoVGFnKSkgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIGdldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG5cbiAgcmV0dXJuIHRoaXMuX2F1dGhUYWdcbn1cblxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5zZXRBdXRoVGFnID0gZnVuY3Rpb24gc2V0QXV0aFRhZyAodGFnKSB7XG4gIGlmICghdGhpcy5fZGVjcnlwdCkgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIHNldCBhdXRoIHRhZyBpbiB1bnN1cHBvcnRlZCBzdGF0ZScpXG5cbiAgdGhpcy5fYXV0aFRhZyA9IHRhZ1xufVxuXG5TdHJlYW1DaXBoZXIucHJvdG90eXBlLnNldEFBRCA9IGZ1bmN0aW9uIHNldEFBRCAoYnVmKSB7XG4gIGlmICh0aGlzLl9jYWxsZWQpIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBzZXQgQUFEIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcblxuICB0aGlzLl9naGFzaC51cGRhdGUoYnVmKVxuICB0aGlzLl9hbGVuICs9IGJ1Zi5sZW5ndGhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW1DaXBoZXJcbiIsInZhciBjaXBoZXJzID0gcmVxdWlyZSgnLi9lbmNyeXB0ZXInKVxudmFyIGRlY2lwaGVycyA9IHJlcXVpcmUoJy4vZGVjcnlwdGVyJylcbnZhciBtb2RlcyA9IHJlcXVpcmUoJy4vbW9kZXMvbGlzdC5qc29uJylcblxuZnVuY3Rpb24gZ2V0Q2lwaGVycyAoKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhtb2Rlcylcbn1cblxuZXhwb3J0cy5jcmVhdGVDaXBoZXIgPSBleHBvcnRzLkNpcGhlciA9IGNpcGhlcnMuY3JlYXRlQ2lwaGVyXG5leHBvcnRzLmNyZWF0ZUNpcGhlcml2ID0gZXhwb3J0cy5DaXBoZXJpdiA9IGNpcGhlcnMuY3JlYXRlQ2lwaGVyaXZcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXIgPSBleHBvcnRzLkRlY2lwaGVyID0gZGVjaXBoZXJzLmNyZWF0ZURlY2lwaGVyXG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyaXYgPSBleHBvcnRzLkRlY2lwaGVyaXYgPSBkZWNpcGhlcnMuY3JlYXRlRGVjaXBoZXJpdlxuZXhwb3J0cy5saXN0Q2lwaGVycyA9IGV4cG9ydHMuZ2V0Q2lwaGVycyA9IGdldENpcGhlcnNcbiIsInZhciBBdXRoQ2lwaGVyID0gcmVxdWlyZSgnLi9hdXRoQ2lwaGVyJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIE1PREVTID0gcmVxdWlyZSgnLi9tb2RlcycpXG52YXIgU3RyZWFtQ2lwaGVyID0gcmVxdWlyZSgnLi9zdHJlYW1DaXBoZXInKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgZWJ0ayA9IHJlcXVpcmUoJ2V2cF9ieXRlc3Rva2V5JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuZnVuY3Rpb24gRGVjaXBoZXIgKG1vZGUsIGtleSwgaXYpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcblxuICB0aGlzLl9jYWNoZSA9IG5ldyBTcGxpdHRlcigpXG4gIHRoaXMuX2xhc3QgPSB2b2lkIDBcbiAgdGhpcy5fY2lwaGVyID0gbmV3IGFlcy5BRVMoa2V5KVxuICB0aGlzLl9wcmV2ID0gQnVmZmVyLmZyb20oaXYpXG4gIHRoaXMuX21vZGUgPSBtb2RlXG4gIHRoaXMuX2F1dG9wYWRkaW5nID0gdHJ1ZVxufVxuXG5pbmhlcml0cyhEZWNpcGhlciwgVHJhbnNmb3JtKVxuXG5EZWNpcGhlci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2NhY2hlLmFkZChkYXRhKVxuICB2YXIgY2h1bmtcbiAgdmFyIHRoaW5nXG4gIHZhciBvdXQgPSBbXVxuICB3aGlsZSAoKGNodW5rID0gdGhpcy5fY2FjaGUuZ2V0KHRoaXMuX2F1dG9wYWRkaW5nKSkpIHtcbiAgICB0aGluZyA9IHRoaXMuX21vZGUuZGVjcnlwdCh0aGlzLCBjaHVuaylcbiAgICBvdXQucHVzaCh0aGluZylcbiAgfVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChvdXQpXG59XG5cbkRlY2lwaGVyLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjaHVuayA9IHRoaXMuX2NhY2hlLmZsdXNoKClcbiAgaWYgKHRoaXMuX2F1dG9wYWRkaW5nKSB7XG4gICAgcmV0dXJuIHVucGFkKHRoaXMuX21vZGUuZGVjcnlwdCh0aGlzLCBjaHVuaykpXG4gIH0gZWxzZSBpZiAoY2h1bmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgbm90IG11bHRpcGxlIG9mIGJsb2NrIGxlbmd0aCcpXG4gIH1cbn1cblxuRGVjaXBoZXIucHJvdG90eXBlLnNldEF1dG9QYWRkaW5nID0gZnVuY3Rpb24gKHNldFRvKSB7XG4gIHRoaXMuX2F1dG9wYWRkaW5nID0gISFzZXRUb1xuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBTcGxpdHRlciAoKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMClcbn1cblxuU3BsaXR0ZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBkYXRhXSlcbn1cblxuU3BsaXR0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChhdXRvUGFkZGluZykge1xuICB2YXIgb3V0XG4gIGlmIChhdXRvUGFkZGluZykge1xuICAgIGlmICh0aGlzLmNhY2hlLmxlbmd0aCA+IDE2KSB7XG4gICAgICBvdXQgPSB0aGlzLmNhY2hlLnNsaWNlKDAsIDE2KVxuICAgICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUuc2xpY2UoMTYpXG4gICAgICByZXR1cm4gb3V0XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLmNhY2hlLmxlbmd0aCA+PSAxNikge1xuICAgICAgb3V0ID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNhY2hlLnNsaWNlKDE2KVxuICAgICAgcmV0dXJuIG91dFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cblNwbGl0dGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoKSByZXR1cm4gdGhpcy5jYWNoZVxufVxuXG5mdW5jdGlvbiB1bnBhZCAobGFzdCkge1xuICB2YXIgcGFkZGVkID0gbGFzdFsxNV1cbiAgaWYgKHBhZGRlZCA8IDEgfHwgcGFkZGVkID4gMTYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBkZWNyeXB0IGRhdGEnKVxuICB9XG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IHBhZGRlZCkge1xuICAgIGlmIChsYXN0WyhpICsgKDE2IC0gcGFkZGVkKSldICE9PSBwYWRkZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGRlY3J5cHQgZGF0YScpXG4gICAgfVxuICB9XG4gIGlmIChwYWRkZWQgPT09IDE2KSByZXR1cm5cblxuICByZXR1cm4gbGFzdC5zbGljZSgwLCAxNiAtIHBhZGRlZClcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVjaXBoZXJpdiAoc3VpdGUsIHBhc3N3b3JkLCBpdikge1xuICB2YXIgY29uZmlnID0gTU9ERVNbc3VpdGUudG9Mb3dlckNhc2UoKV1cbiAgaWYgKCFjb25maWcpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG5cbiAgaWYgKHR5cGVvZiBpdiA9PT0gJ3N0cmluZycpIGl2ID0gQnVmZmVyLmZyb20oaXYpXG4gIGlmIChjb25maWcubW9kZSAhPT0gJ0dDTScgJiYgaXYubGVuZ3RoICE9PSBjb25maWcuaXYpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgaXYgbGVuZ3RoICcgKyBpdi5sZW5ndGgpXG5cbiAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3N0cmluZycpIHBhc3N3b3JkID0gQnVmZmVyLmZyb20ocGFzc3dvcmQpXG4gIGlmIChwYXNzd29yZC5sZW5ndGggIT09IGNvbmZpZy5rZXkgLyA4KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGtleSBsZW5ndGggJyArIHBhc3N3b3JkLmxlbmd0aClcblxuICBpZiAoY29uZmlnLnR5cGUgPT09ICdzdHJlYW0nKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1DaXBoZXIoY29uZmlnLm1vZHVsZSwgcGFzc3dvcmQsIGl2LCB0cnVlKVxuICB9IGVsc2UgaWYgKGNvbmZpZy50eXBlID09PSAnYXV0aCcpIHtcbiAgICByZXR1cm4gbmV3IEF1dGhDaXBoZXIoY29uZmlnLm1vZHVsZSwgcGFzc3dvcmQsIGl2LCB0cnVlKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBEZWNpcGhlcihjb25maWcubW9kdWxlLCBwYXNzd29yZCwgaXYpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlY2lwaGVyIChzdWl0ZSwgcGFzc3dvcmQpIHtcbiAgdmFyIGNvbmZpZyA9IE1PREVTW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuXG4gIHZhciBrZXlzID0gZWJ0ayhwYXNzd29yZCwgZmFsc2UsIGNvbmZpZy5rZXksIGNvbmZpZy5pdilcbiAgcmV0dXJuIGNyZWF0ZURlY2lwaGVyaXYoc3VpdGUsIGtleXMua2V5LCBrZXlzLml2KVxufVxuXG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyID0gY3JlYXRlRGVjaXBoZXJcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXJpdiA9IGNyZWF0ZURlY2lwaGVyaXZcbiIsInZhciBNT0RFUyA9IHJlcXVpcmUoJy4vbW9kZXMnKVxudmFyIEF1dGhDaXBoZXIgPSByZXF1aXJlKCcuL2F1dGhDaXBoZXInKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgU3RyZWFtQ2lwaGVyID0gcmVxdWlyZSgnLi9zdHJlYW1DaXBoZXInKVxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgZWJ0ayA9IHJlcXVpcmUoJ2V2cF9ieXRlc3Rva2V5JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuZnVuY3Rpb24gQ2lwaGVyIChtb2RlLCBrZXksIGl2KSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG5cbiAgdGhpcy5fY2FjaGUgPSBuZXcgU3BsaXR0ZXIoKVxuICB0aGlzLl9jaXBoZXIgPSBuZXcgYWVzLkFFUyhrZXkpXG4gIHRoaXMuX3ByZXYgPSBCdWZmZXIuZnJvbShpdilcbiAgdGhpcy5fbW9kZSA9IG1vZGVcbiAgdGhpcy5fYXV0b3BhZGRpbmcgPSB0cnVlXG59XG5cbmluaGVyaXRzKENpcGhlciwgVHJhbnNmb3JtKVxuXG5DaXBoZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLl9jYWNoZS5hZGQoZGF0YSlcbiAgdmFyIGNodW5rXG4gIHZhciB0aGluZ1xuICB2YXIgb3V0ID0gW11cblxuICB3aGlsZSAoKGNodW5rID0gdGhpcy5fY2FjaGUuZ2V0KCkpKSB7XG4gICAgdGhpbmcgPSB0aGlzLl9tb2RlLmVuY3J5cHQodGhpcywgY2h1bmspXG4gICAgb3V0LnB1c2godGhpbmcpXG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChvdXQpXG59XG5cbnZhciBQQURESU5HID0gQnVmZmVyLmFsbG9jKDE2LCAweDEwKVxuXG5DaXBoZXIucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNodW5rID0gdGhpcy5fY2FjaGUuZmx1c2goKVxuICBpZiAodGhpcy5fYXV0b3BhZGRpbmcpIHtcbiAgICBjaHVuayA9IHRoaXMuX21vZGUuZW5jcnlwdCh0aGlzLCBjaHVuaylcbiAgICB0aGlzLl9jaXBoZXIuc2NydWIoKVxuICAgIHJldHVybiBjaHVua1xuICB9XG5cbiAgaWYgKCFjaHVuay5lcXVhbHMoUEFERElORykpIHtcbiAgICB0aGlzLl9jaXBoZXIuc2NydWIoKVxuICAgIHRocm93IG5ldyBFcnJvcignZGF0YSBub3QgbXVsdGlwbGUgb2YgYmxvY2sgbGVuZ3RoJylcbiAgfVxufVxuXG5DaXBoZXIucHJvdG90eXBlLnNldEF1dG9QYWRkaW5nID0gZnVuY3Rpb24gKHNldFRvKSB7XG4gIHRoaXMuX2F1dG9wYWRkaW5nID0gISFzZXRUb1xuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBTcGxpdHRlciAoKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMClcbn1cblxuU3BsaXR0ZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuY2FjaGUgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBkYXRhXSlcbn1cblxuU3BsaXR0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2FjaGUubGVuZ3RoID4gMTUpIHtcbiAgICB2YXIgb3V0ID0gdGhpcy5jYWNoZS5zbGljZSgwLCAxNilcbiAgICB0aGlzLmNhY2hlID0gdGhpcy5jYWNoZS5zbGljZSgxNilcbiAgICByZXR1cm4gb3V0XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuU3BsaXR0ZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGVuID0gMTYgLSB0aGlzLmNhY2hlLmxlbmd0aFxuICB2YXIgcGFkQnVmZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW4pXG5cbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgcGFkQnVmZi53cml0ZVVJbnQ4KGxlbiwgaSlcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFt0aGlzLmNhY2hlLCBwYWRCdWZmXSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2lwaGVyaXYgKHN1aXRlLCBwYXNzd29yZCwgaXYpIHtcbiAgdmFyIGNvbmZpZyA9IE1PREVTW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuXG4gIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICdzdHJpbmcnKSBwYXNzd29yZCA9IEJ1ZmZlci5mcm9tKHBhc3N3b3JkKVxuICBpZiAocGFzc3dvcmQubGVuZ3RoICE9PSBjb25maWcua2V5IC8gOCkgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBrZXkgbGVuZ3RoICcgKyBwYXNzd29yZC5sZW5ndGgpXG5cbiAgaWYgKHR5cGVvZiBpdiA9PT0gJ3N0cmluZycpIGl2ID0gQnVmZmVyLmZyb20oaXYpXG4gIGlmIChjb25maWcubW9kZSAhPT0gJ0dDTScgJiYgaXYubGVuZ3RoICE9PSBjb25maWcuaXYpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgaXYgbGVuZ3RoICcgKyBpdi5sZW5ndGgpXG5cbiAgaWYgKGNvbmZpZy50eXBlID09PSAnc3RyZWFtJykge1xuICAgIHJldHVybiBuZXcgU3RyZWFtQ2lwaGVyKGNvbmZpZy5tb2R1bGUsIHBhc3N3b3JkLCBpdilcbiAgfSBlbHNlIGlmIChjb25maWcudHlwZSA9PT0gJ2F1dGgnKSB7XG4gICAgcmV0dXJuIG5ldyBBdXRoQ2lwaGVyKGNvbmZpZy5tb2R1bGUsIHBhc3N3b3JkLCBpdilcbiAgfVxuXG4gIHJldHVybiBuZXcgQ2lwaGVyKGNvbmZpZy5tb2R1bGUsIHBhc3N3b3JkLCBpdilcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2lwaGVyIChzdWl0ZSwgcGFzc3dvcmQpIHtcbiAgdmFyIGNvbmZpZyA9IE1PREVTW3N1aXRlLnRvTG93ZXJDYXNlKCldXG4gIGlmICghY29uZmlnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1aXRlIHR5cGUnKVxuXG4gIHZhciBrZXlzID0gZWJ0ayhwYXNzd29yZCwgZmFsc2UsIGNvbmZpZy5rZXksIGNvbmZpZy5pdilcbiAgcmV0dXJuIGNyZWF0ZUNpcGhlcml2KHN1aXRlLCBrZXlzLmtleSwga2V5cy5pdilcbn1cblxuZXhwb3J0cy5jcmVhdGVDaXBoZXJpdiA9IGNyZWF0ZUNpcGhlcml2XG5leHBvcnRzLmNyZWF0ZUNpcGhlciA9IGNyZWF0ZUNpcGhlclxuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgWkVST0VTID0gQnVmZmVyLmFsbG9jKDE2LCAwKVxuXG5mdW5jdGlvbiB0b0FycmF5IChidWYpIHtcbiAgcmV0dXJuIFtcbiAgICBidWYucmVhZFVJbnQzMkJFKDApLFxuICAgIGJ1Zi5yZWFkVUludDMyQkUoNCksXG4gICAgYnVmLnJlYWRVSW50MzJCRSg4KSxcbiAgICBidWYucmVhZFVJbnQzMkJFKDEyKVxuICBdXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheSAob3V0KSB7XG4gIHZhciBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTYpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFswXSA+Pj4gMCwgMClcbiAgYnVmLndyaXRlVUludDMyQkUob3V0WzFdID4+PiAwLCA0KVxuICBidWYud3JpdGVVSW50MzJCRShvdXRbMl0gPj4+IDAsIDgpXG4gIGJ1Zi53cml0ZVVJbnQzMkJFKG91dFszXSA+Pj4gMCwgMTIpXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gR0hBU0ggKGtleSkge1xuICB0aGlzLmggPSBrZXlcbiAgdGhpcy5zdGF0ZSA9IEJ1ZmZlci5hbGxvYygxNiwgMClcbiAgdGhpcy5jYWNoZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxufVxuXG4vLyBmcm9tIGh0dHA6Ly9iaXR3aXNlc2hpZnRsZWZ0LmdpdGh1Yi5pby9zamNsL2RvYy9zeW1ib2xzL3NyYy9jb3JlX2djbS5qcy5odG1sXG4vLyBieSBKdWhvIFbDpGjDpC1IZXJ0dHVhXG5HSEFTSC5wcm90b3R5cGUuZ2hhc2ggPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgYmxvY2subGVuZ3RoKSB7XG4gICAgdGhpcy5zdGF0ZVtpXSBePSBibG9ja1tpXVxuICB9XG4gIHRoaXMuX211bHRpcGx5KClcbn1cblxuR0hBU0gucHJvdG90eXBlLl9tdWx0aXBseSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIFZpID0gdG9BcnJheSh0aGlzLmgpXG4gIHZhciBaaSA9IFswLCAwLCAwLCAwXVxuICB2YXIgaiwgeGksIGxzYlZpXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IDEyOCkge1xuICAgIHhpID0gKHRoaXMuc3RhdGVbfn4oaSAvIDgpXSAmICgxIDw8ICg3IC0gKGkgJSA4KSkpKSAhPT0gMFxuICAgIGlmICh4aSkge1xuICAgICAgLy8gWl9pKzEgPSBaX2kgXiBWX2lcbiAgICAgIFppWzBdIF49IFZpWzBdXG4gICAgICBaaVsxXSBePSBWaVsxXVxuICAgICAgWmlbMl0gXj0gVmlbMl1cbiAgICAgIFppWzNdIF49IFZpWzNdXG4gICAgfVxuXG4gICAgLy8gU3RvcmUgdGhlIHZhbHVlIG9mIExTQihWX2kpXG4gICAgbHNiVmkgPSAoVmlbM10gJiAxKSAhPT0gMFxuXG4gICAgLy8gVl9pKzEgPSBWX2kgPj4gMVxuICAgIGZvciAoaiA9IDM7IGogPiAwOyBqLS0pIHtcbiAgICAgIFZpW2pdID0gKFZpW2pdID4+PiAxKSB8ICgoVmlbaiAtIDFdICYgMSkgPDwgMzEpXG4gICAgfVxuICAgIFZpWzBdID0gVmlbMF0gPj4+IDFcblxuICAgIC8vIElmIExTQihWX2kpIGlzIDEsIFZfaSsxID0gKFZfaSA+PiAxKSBeIFJcbiAgICBpZiAobHNiVmkpIHtcbiAgICAgIFZpWzBdID0gVmlbMF0gXiAoMHhlMSA8PCAyNClcbiAgICB9XG4gIH1cbiAgdGhpcy5zdGF0ZSA9IGZyb21BcnJheShaaSlcbn1cblxuR0hBU0gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgdGhpcy5jYWNoZSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIGJ1Zl0pXG4gIHZhciBjaHVua1xuICB3aGlsZSAodGhpcy5jYWNoZS5sZW5ndGggPj0gMTYpIHtcbiAgICBjaHVuayA9IHRoaXMuY2FjaGUuc2xpY2UoMCwgMTYpXG4gICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUuc2xpY2UoMTYpXG4gICAgdGhpcy5naGFzaChjaHVuaylcbiAgfVxufVxuXG5HSEFTSC5wcm90b3R5cGUuZmluYWwgPSBmdW5jdGlvbiAoYWJsLCBibCkge1xuICBpZiAodGhpcy5jYWNoZS5sZW5ndGgpIHtcbiAgICB0aGlzLmdoYXNoKEJ1ZmZlci5jb25jYXQoW3RoaXMuY2FjaGUsIFpFUk9FU10sIDE2KSlcbiAgfVxuXG4gIHRoaXMuZ2hhc2goZnJvbUFycmF5KFswLCBhYmwsIDAsIGJsXSkpXG4gIHJldHVybiB0aGlzLnN0YXRlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gR0hBU0hcbiIsImZ1bmN0aW9uIGluY3IzMiAoaXYpIHtcbiAgdmFyIGxlbiA9IGl2Lmxlbmd0aFxuICB2YXIgaXRlbVxuICB3aGlsZSAobGVuLS0pIHtcbiAgICBpdGVtID0gaXYucmVhZFVJbnQ4KGxlbilcbiAgICBpZiAoaXRlbSA9PT0gMjU1KSB7XG4gICAgICBpdi53cml0ZVVJbnQ4KDAsIGxlbilcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbSsrXG4gICAgICBpdi53cml0ZVVJbnQ4KGl0ZW0sIGxlbilcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluY3IzMlxuIiwidmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgYmxvY2spIHtcbiAgdmFyIGRhdGEgPSB4b3IoYmxvY2ssIHNlbGYuX3ByZXYpXG5cbiAgc2VsZi5fcHJldiA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soZGF0YSlcbiAgcmV0dXJuIHNlbGYuX3ByZXZcbn1cblxuZXhwb3J0cy5kZWNyeXB0ID0gZnVuY3Rpb24gKHNlbGYsIGJsb2NrKSB7XG4gIHZhciBwYWQgPSBzZWxmLl9wcmV2XG5cbiAgc2VsZi5fcHJldiA9IGJsb2NrXG4gIHZhciBvdXQgPSBzZWxmLl9jaXBoZXIuZGVjcnlwdEJsb2NrKGJsb2NrKVxuXG4gIHJldHVybiB4b3Iob3V0LCBwYWQpXG59XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciB4b3IgPSByZXF1aXJlKCdidWZmZXIteG9yJylcblxuZnVuY3Rpb24gZW5jcnlwdFN0YXJ0IChzZWxmLCBkYXRhLCBkZWNyeXB0KSB7XG4gIHZhciBsZW4gPSBkYXRhLmxlbmd0aFxuICB2YXIgb3V0ID0geG9yKGRhdGEsIHNlbGYuX2NhY2hlKVxuICBzZWxmLl9jYWNoZSA9IHNlbGYuX2NhY2hlLnNsaWNlKGxlbilcbiAgc2VsZi5fcHJldiA9IEJ1ZmZlci5jb25jYXQoW3NlbGYuX3ByZXYsIGRlY3J5cHQgPyBkYXRhIDogb3V0XSlcbiAgcmV0dXJuIG91dFxufVxuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgZGF0YSwgZGVjcnlwdCkge1xuICB2YXIgb3V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApXG4gIHZhciBsZW5cblxuICB3aGlsZSAoZGF0YS5sZW5ndGgpIHtcbiAgICBpZiAoc2VsZi5fY2FjaGUubGVuZ3RoID09PSAwKSB7XG4gICAgICBzZWxmLl9jYWNoZSA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgICAgIHNlbGYuX3ByZXYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMClcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fY2FjaGUubGVuZ3RoIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgICBsZW4gPSBzZWxmLl9jYWNoZS5sZW5ndGhcbiAgICAgIG91dCA9IEJ1ZmZlci5jb25jYXQoW291dCwgZW5jcnlwdFN0YXJ0KHNlbGYsIGRhdGEuc2xpY2UoMCwgbGVuKSwgZGVjcnlwdCldKVxuICAgICAgZGF0YSA9IGRhdGEuc2xpY2UobGVuKVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBCdWZmZXIuY29uY2F0KFtvdXQsIGVuY3J5cHRTdGFydChzZWxmLCBkYXRhLCBkZWNyeXB0KV0pXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5mdW5jdGlvbiBlbmNyeXB0Qnl0ZSAoc2VsZiwgYnl0ZVBhcmFtLCBkZWNyeXB0KSB7XG4gIHZhciBwYWRcbiAgdmFyIGkgPSAtMVxuICB2YXIgbGVuID0gOFxuICB2YXIgb3V0ID0gMFxuICB2YXIgYml0LCB2YWx1ZVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgcGFkID0gc2VsZi5fY2lwaGVyLmVuY3J5cHRCbG9jayhzZWxmLl9wcmV2KVxuICAgIGJpdCA9IChieXRlUGFyYW0gJiAoMSA8PCAoNyAtIGkpKSkgPyAweDgwIDogMFxuICAgIHZhbHVlID0gcGFkWzBdIF4gYml0XG4gICAgb3V0ICs9ICgodmFsdWUgJiAweDgwKSA+PiAoaSAlIDgpKVxuICAgIHNlbGYuX3ByZXYgPSBzaGlmdEluKHNlbGYuX3ByZXYsIGRlY3J5cHQgPyBiaXQgOiB2YWx1ZSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHNoaWZ0SW4gKGJ1ZmZlciwgdmFsdWUpIHtcbiAgdmFyIGxlbiA9IGJ1ZmZlci5sZW5ndGhcbiAgdmFyIGkgPSAtMVxuICB2YXIgb3V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJ1ZmZlci5sZW5ndGgpXG4gIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2J1ZmZlciwgQnVmZmVyLmZyb20oW3ZhbHVlXSldKVxuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBvdXRbaV0gPSBidWZmZXJbaV0gPDwgMSB8IGJ1ZmZlcltpICsgMV0gPj4gKDcpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaywgZGVjcnlwdCkge1xuICB2YXIgbGVuID0gY2h1bmsubGVuZ3RoXG4gIHZhciBvdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuKVxuICB2YXIgaSA9IC0xXG5cbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dFtpXSA9IGVuY3J5cHRCeXRlKHNlbGYsIGNodW5rW2ldLCBkZWNyeXB0KVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbmZ1bmN0aW9uIGVuY3J5cHRCeXRlIChzZWxmLCBieXRlUGFyYW0sIGRlY3J5cHQpIHtcbiAgdmFyIHBhZCA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soc2VsZi5fcHJldilcbiAgdmFyIG91dCA9IHBhZFswXSBeIGJ5dGVQYXJhbVxuXG4gIHNlbGYuX3ByZXYgPSBCdWZmZXIuY29uY2F0KFtcbiAgICBzZWxmLl9wcmV2LnNsaWNlKDEpLFxuICAgIEJ1ZmZlci5mcm9tKFtkZWNyeXB0ID8gYnl0ZVBhcmFtIDogb3V0XSlcbiAgXSlcblxuICByZXR1cm4gb3V0XG59XG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaywgZGVjcnlwdCkge1xuICB2YXIgbGVuID0gY2h1bmsubGVuZ3RoXG4gIHZhciBvdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuKVxuICB2YXIgaSA9IC0xXG5cbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIG91dFtpXSA9IGVuY3J5cHRCeXRlKHNlbGYsIGNodW5rW2ldLCBkZWNyeXB0KVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuIiwidmFyIHhvciA9IHJlcXVpcmUoJ2J1ZmZlci14b3InKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgaW5jcjMyID0gcmVxdWlyZSgnLi4vaW5jcjMyJylcblxuZnVuY3Rpb24gZ2V0QmxvY2sgKHNlbGYpIHtcbiAgdmFyIG91dCA9IHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2tSYXcoc2VsZi5fcHJldilcbiAgaW5jcjMyKHNlbGYuX3ByZXYpXG4gIHJldHVybiBvdXRcbn1cblxudmFyIGJsb2NrU2l6ZSA9IDE2XG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgY2h1bmspIHtcbiAgdmFyIGNodW5rTnVtID0gTWF0aC5jZWlsKGNodW5rLmxlbmd0aCAvIGJsb2NrU2l6ZSlcbiAgdmFyIHN0YXJ0ID0gc2VsZi5fY2FjaGUubGVuZ3RoXG4gIHNlbGYuX2NhY2hlID0gQnVmZmVyLmNvbmNhdChbXG4gICAgc2VsZi5fY2FjaGUsXG4gICAgQnVmZmVyLmFsbG9jVW5zYWZlKGNodW5rTnVtICogYmxvY2tTaXplKVxuICBdKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rTnVtOyBpKyspIHtcbiAgICB2YXIgb3V0ID0gZ2V0QmxvY2soc2VsZilcbiAgICB2YXIgb2Zmc2V0ID0gc3RhcnQgKyBpICogYmxvY2tTaXplXG4gICAgc2VsZi5fY2FjaGUud3JpdGVVSW50MzJCRShvdXRbMF0sIG9mZnNldCArIDApXG4gICAgc2VsZi5fY2FjaGUud3JpdGVVSW50MzJCRShvdXRbMV0sIG9mZnNldCArIDQpXG4gICAgc2VsZi5fY2FjaGUud3JpdGVVSW50MzJCRShvdXRbMl0sIG9mZnNldCArIDgpXG4gICAgc2VsZi5fY2FjaGUud3JpdGVVSW50MzJCRShvdXRbM10sIG9mZnNldCArIDEyKVxuICB9XG4gIHZhciBwYWQgPSBzZWxmLl9jYWNoZS5zbGljZSgwLCBjaHVuay5sZW5ndGgpXG4gIHNlbGYuX2NhY2hlID0gc2VsZi5fY2FjaGUuc2xpY2UoY2h1bmsubGVuZ3RoKVxuICByZXR1cm4geG9yKGNodW5rLCBwYWQpXG59XG4iLCJleHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbiAoc2VsZiwgYmxvY2spIHtcbiAgcmV0dXJuIHNlbGYuX2NpcGhlci5lbmNyeXB0QmxvY2soYmxvY2spXG59XG5cbmV4cG9ydHMuZGVjcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBibG9jaykge1xuICByZXR1cm4gc2VsZi5fY2lwaGVyLmRlY3J5cHRCbG9jayhibG9jaylcbn1cbiIsInZhciBtb2RlTW9kdWxlcyA9IHtcbiAgRUNCOiByZXF1aXJlKCcuL2VjYicpLFxuICBDQkM6IHJlcXVpcmUoJy4vY2JjJyksXG4gIENGQjogcmVxdWlyZSgnLi9jZmInKSxcbiAgQ0ZCODogcmVxdWlyZSgnLi9jZmI4JyksXG4gIENGQjE6IHJlcXVpcmUoJy4vY2ZiMScpLFxuICBPRkI6IHJlcXVpcmUoJy4vb2ZiJyksXG4gIENUUjogcmVxdWlyZSgnLi9jdHInKSxcbiAgR0NNOiByZXF1aXJlKCcuL2N0cicpXG59XG5cbnZhciBtb2RlcyA9IHJlcXVpcmUoJy4vbGlzdC5qc29uJylcblxuZm9yICh2YXIga2V5IGluIG1vZGVzKSB7XG4gIG1vZGVzW2tleV0ubW9kdWxlID0gbW9kZU1vZHVsZXNbbW9kZXNba2V5XS5tb2RlXVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1vZGVzXG4iLCJ2YXIgeG9yID0gcmVxdWlyZSgnYnVmZmVyLXhvcicpXG5cbmZ1bmN0aW9uIGdldEJsb2NrIChzZWxmKSB7XG4gIHNlbGYuX3ByZXYgPSBzZWxmLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHNlbGYuX3ByZXYpXG4gIHJldHVybiBzZWxmLl9wcmV2XG59XG5cbmV4cG9ydHMuZW5jcnlwdCA9IGZ1bmN0aW9uIChzZWxmLCBjaHVuaykge1xuICB3aGlsZSAoc2VsZi5fY2FjaGUubGVuZ3RoIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgc2VsZi5fY2FjaGUgPSBCdWZmZXIuY29uY2F0KFtzZWxmLl9jYWNoZSwgZ2V0QmxvY2soc2VsZildKVxuICB9XG5cbiAgdmFyIHBhZCA9IHNlbGYuX2NhY2hlLnNsaWNlKDAsIGNodW5rLmxlbmd0aClcbiAgc2VsZi5fY2FjaGUgPSBzZWxmLl9jYWNoZS5zbGljZShjaHVuay5sZW5ndGgpXG4gIHJldHVybiB4b3IoY2h1bmssIHBhZClcbn1cbiIsInZhciBhZXMgPSByZXF1aXJlKCcuL2FlcycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbmZ1bmN0aW9uIFN0cmVhbUNpcGhlciAobW9kZSwga2V5LCBpdiwgZGVjcnlwdCkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuXG4gIHRoaXMuX2NpcGhlciA9IG5ldyBhZXMuQUVTKGtleSlcbiAgdGhpcy5fcHJldiA9IEJ1ZmZlci5mcm9tKGl2KVxuICB0aGlzLl9jYWNoZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxuICB0aGlzLl9zZWNDYWNoZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxuICB0aGlzLl9kZWNyeXB0ID0gZGVjcnlwdFxuICB0aGlzLl9tb2RlID0gbW9kZVxufVxuXG5pbmhlcml0cyhTdHJlYW1DaXBoZXIsIFRyYW5zZm9ybSlcblxuU3RyZWFtQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiB0aGlzLl9tb2RlLmVuY3J5cHQodGhpcywgY2h1bmssIHRoaXMuX2RlY3J5cHQpXG59XG5cblN0cmVhbUNpcGhlci5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9jaXBoZXIuc2NydWIoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbUNpcGhlclxuIiwidmFyIERFUyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktZGVzJylcbnZhciBhZXMgPSByZXF1aXJlKCdicm93c2VyaWZ5LWFlcy9icm93c2VyJylcbnZhciBhZXNNb2RlcyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktYWVzL21vZGVzJylcbnZhciBkZXNNb2RlcyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktZGVzL21vZGVzJylcbnZhciBlYnRrID0gcmVxdWlyZSgnZXZwX2J5dGVzdG9rZXknKVxuXG5mdW5jdGlvbiBjcmVhdGVDaXBoZXIgKHN1aXRlLCBwYXNzd29yZCkge1xuICBzdWl0ZSA9IHN1aXRlLnRvTG93ZXJDYXNlKClcblxuICB2YXIga2V5TGVuLCBpdkxlblxuICBpZiAoYWVzTW9kZXNbc3VpdGVdKSB7XG4gICAga2V5TGVuID0gYWVzTW9kZXNbc3VpdGVdLmtleVxuICAgIGl2TGVuID0gYWVzTW9kZXNbc3VpdGVdLml2XG4gIH0gZWxzZSBpZiAoZGVzTW9kZXNbc3VpdGVdKSB7XG4gICAga2V5TGVuID0gZGVzTW9kZXNbc3VpdGVdLmtleSAqIDhcbiAgICBpdkxlbiA9IGRlc01vZGVzW3N1aXRlXS5pdlxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG4gIH1cblxuICB2YXIga2V5cyA9IGVidGsocGFzc3dvcmQsIGZhbHNlLCBrZXlMZW4sIGl2TGVuKVxuICByZXR1cm4gY3JlYXRlQ2lwaGVyaXYoc3VpdGUsIGtleXMua2V5LCBrZXlzLml2KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWNpcGhlciAoc3VpdGUsIHBhc3N3b3JkKSB7XG4gIHN1aXRlID0gc3VpdGUudG9Mb3dlckNhc2UoKVxuXG4gIHZhciBrZXlMZW4sIGl2TGVuXG4gIGlmIChhZXNNb2Rlc1tzdWl0ZV0pIHtcbiAgICBrZXlMZW4gPSBhZXNNb2Rlc1tzdWl0ZV0ua2V5XG4gICAgaXZMZW4gPSBhZXNNb2Rlc1tzdWl0ZV0uaXZcbiAgfSBlbHNlIGlmIChkZXNNb2Rlc1tzdWl0ZV0pIHtcbiAgICBrZXlMZW4gPSBkZXNNb2Rlc1tzdWl0ZV0ua2V5ICogOFxuICAgIGl2TGVuID0gZGVzTW9kZXNbc3VpdGVdLml2XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbiAgfVxuXG4gIHZhciBrZXlzID0gZWJ0ayhwYXNzd29yZCwgZmFsc2UsIGtleUxlbiwgaXZMZW4pXG4gIHJldHVybiBjcmVhdGVEZWNpcGhlcml2KHN1aXRlLCBrZXlzLmtleSwga2V5cy5pdilcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2lwaGVyaXYgKHN1aXRlLCBrZXksIGl2KSB7XG4gIHN1aXRlID0gc3VpdGUudG9Mb3dlckNhc2UoKVxuICBpZiAoYWVzTW9kZXNbc3VpdGVdKSByZXR1cm4gYWVzLmNyZWF0ZUNpcGhlcml2KHN1aXRlLCBrZXksIGl2KVxuICBpZiAoZGVzTW9kZXNbc3VpdGVdKSByZXR1cm4gbmV3IERFUyh7IGtleToga2V5LCBpdjogaXYsIG1vZGU6IHN1aXRlIH0pXG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWl0ZSB0eXBlJylcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVjaXBoZXJpdiAoc3VpdGUsIGtleSwgaXYpIHtcbiAgc3VpdGUgPSBzdWl0ZS50b0xvd2VyQ2FzZSgpXG4gIGlmIChhZXNNb2Rlc1tzdWl0ZV0pIHJldHVybiBhZXMuY3JlYXRlRGVjaXBoZXJpdihzdWl0ZSwga2V5LCBpdilcbiAgaWYgKGRlc01vZGVzW3N1aXRlXSkgcmV0dXJuIG5ldyBERVMoeyBrZXk6IGtleSwgaXY6IGl2LCBtb2RlOiBzdWl0ZSwgZGVjcnlwdDogdHJ1ZSB9KVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc3VpdGUgdHlwZScpXG59XG5cbmZ1bmN0aW9uIGdldENpcGhlcnMgKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoZGVzTW9kZXMpLmNvbmNhdChhZXMuZ2V0Q2lwaGVycygpKVxufVxuXG5leHBvcnRzLmNyZWF0ZUNpcGhlciA9IGV4cG9ydHMuQ2lwaGVyID0gY3JlYXRlQ2lwaGVyXG5leHBvcnRzLmNyZWF0ZUNpcGhlcml2ID0gZXhwb3J0cy5DaXBoZXJpdiA9IGNyZWF0ZUNpcGhlcml2XG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyID0gZXhwb3J0cy5EZWNpcGhlciA9IGNyZWF0ZURlY2lwaGVyXG5leHBvcnRzLmNyZWF0ZURlY2lwaGVyaXYgPSBleHBvcnRzLkRlY2lwaGVyaXYgPSBjcmVhdGVEZWNpcGhlcml2XG5leHBvcnRzLmxpc3RDaXBoZXJzID0gZXhwb3J0cy5nZXRDaXBoZXJzID0gZ2V0Q2lwaGVyc1xuIiwidmFyIENpcGhlckJhc2UgPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG52YXIgZGVzID0gcmVxdWlyZSgnZGVzLmpzJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgbW9kZXMgPSB7XG4gICdkZXMtZWRlMy1jYmMnOiBkZXMuQ0JDLmluc3RhbnRpYXRlKGRlcy5FREUpLFxuICAnZGVzLWVkZTMnOiBkZXMuRURFLFxuICAnZGVzLWVkZS1jYmMnOiBkZXMuQ0JDLmluc3RhbnRpYXRlKGRlcy5FREUpLFxuICAnZGVzLWVkZSc6IGRlcy5FREUsXG4gICdkZXMtY2JjJzogZGVzLkNCQy5pbnN0YW50aWF0ZShkZXMuREVTKSxcbiAgJ2Rlcy1lY2InOiBkZXMuREVTXG59XG5tb2Rlcy5kZXMgPSBtb2Rlc1snZGVzLWNiYyddXG5tb2Rlcy5kZXMzID0gbW9kZXNbJ2Rlcy1lZGUzLWNiYyddXG5tb2R1bGUuZXhwb3J0cyA9IERFU1xuaW5oZXJpdHMoREVTLCBDaXBoZXJCYXNlKVxuZnVuY3Rpb24gREVTIChvcHRzKSB7XG4gIENpcGhlckJhc2UuY2FsbCh0aGlzKVxuICB2YXIgbW9kZU5hbWUgPSBvcHRzLm1vZGUudG9Mb3dlckNhc2UoKVxuICB2YXIgbW9kZSA9IG1vZGVzW21vZGVOYW1lXVxuICB2YXIgdHlwZVxuICBpZiAob3B0cy5kZWNyeXB0KSB7XG4gICAgdHlwZSA9ICdkZWNyeXB0J1xuICB9IGVsc2Uge1xuICAgIHR5cGUgPSAnZW5jcnlwdCdcbiAgfVxuICB2YXIga2V5ID0gb3B0cy5rZXlcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoa2V5KSkge1xuICAgIGtleSA9IEJ1ZmZlci5mcm9tKGtleSlcbiAgfVxuICBpZiAobW9kZU5hbWUgPT09ICdkZXMtZWRlJyB8fCBtb2RlTmFtZSA9PT0gJ2Rlcy1lZGUtY2JjJykge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwga2V5LnNsaWNlKDAsIDgpXSlcbiAgfVxuICB2YXIgaXYgPSBvcHRzLml2XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGl2KSkge1xuICAgIGl2ID0gQnVmZmVyLmZyb20oaXYpXG4gIH1cbiAgdGhpcy5fZGVzID0gbW9kZS5jcmVhdGUoe1xuICAgIGtleToga2V5LFxuICAgIGl2OiBpdixcbiAgICB0eXBlOiB0eXBlXG4gIH0pXG59XG5ERVMucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5fZGVzLnVwZGF0ZShkYXRhKSlcbn1cbkRFUy5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5fZGVzLmZpbmFsKCkpXG59XG4iLCJleHBvcnRzWydkZXMtZWNiJ10gPSB7XG4gIGtleTogOCxcbiAgaXY6IDBcbn1cbmV4cG9ydHNbJ2Rlcy1jYmMnXSA9IGV4cG9ydHMuZGVzID0ge1xuICBrZXk6IDgsXG4gIGl2OiA4XG59XG5leHBvcnRzWydkZXMtZWRlMy1jYmMnXSA9IGV4cG9ydHMuZGVzMyA9IHtcbiAga2V5OiAyNCxcbiAgaXY6IDhcbn1cbmV4cG9ydHNbJ2Rlcy1lZGUzJ10gPSB7XG4gIGtleTogMjQsXG4gIGl2OiAwXG59XG5leHBvcnRzWydkZXMtZWRlLWNiYyddID0ge1xuICBrZXk6IDE2LFxuICBpdjogOFxufVxuZXhwb3J0c1snZGVzLWVkZSddID0ge1xuICBrZXk6IDE2LFxuICBpdjogMFxufVxuIiwidmFyIGJuID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGNydDtcbmZ1bmN0aW9uIGJsaW5kKHByaXYpIHtcbiAgdmFyIHIgPSBnZXRyKHByaXYpO1xuICB2YXIgYmxpbmRlciA9IHIudG9SZWQoYm4ubW9udChwcml2Lm1vZHVsdXMpKVxuICAucmVkUG93KG5ldyBibihwcml2LnB1YmxpY0V4cG9uZW50KSkuZnJvbVJlZCgpO1xuICByZXR1cm4ge1xuICAgIGJsaW5kZXI6IGJsaW5kZXIsXG4gICAgdW5ibGluZGVyOnIuaW52bShwcml2Lm1vZHVsdXMpXG4gIH07XG59XG5mdW5jdGlvbiBjcnQobXNnLCBwcml2KSB7XG4gIHZhciBibGluZHMgPSBibGluZChwcml2KTtcbiAgdmFyIGxlbiA9IHByaXYubW9kdWx1cy5ieXRlTGVuZ3RoKCk7XG4gIHZhciBtb2QgPSBibi5tb250KHByaXYubW9kdWx1cyk7XG4gIHZhciBibGluZGVkID0gbmV3IGJuKG1zZykubXVsKGJsaW5kcy5ibGluZGVyKS51bW9kKHByaXYubW9kdWx1cyk7XG4gIHZhciBjMSA9IGJsaW5kZWQudG9SZWQoYm4ubW9udChwcml2LnByaW1lMSkpO1xuICB2YXIgYzIgPSBibGluZGVkLnRvUmVkKGJuLm1vbnQocHJpdi5wcmltZTIpKTtcbiAgdmFyIHFpbnYgPSBwcml2LmNvZWZmaWNpZW50O1xuICB2YXIgcCA9IHByaXYucHJpbWUxO1xuICB2YXIgcSA9IHByaXYucHJpbWUyO1xuICB2YXIgbTEgPSBjMS5yZWRQb3cocHJpdi5leHBvbmVudDEpO1xuICB2YXIgbTIgPSBjMi5yZWRQb3cocHJpdi5leHBvbmVudDIpO1xuICBtMSA9IG0xLmZyb21SZWQoKTtcbiAgbTIgPSBtMi5mcm9tUmVkKCk7XG4gIHZhciBoID0gbTEuaXN1YihtMikuaW11bChxaW52KS51bW9kKHApO1xuICBoLmltdWwocSk7XG4gIG0yLmlhZGQoaCk7XG4gIHJldHVybiBuZXcgQnVmZmVyKG0yLmltdWwoYmxpbmRzLnVuYmxpbmRlcikudW1vZChwcml2Lm1vZHVsdXMpLnRvQXJyYXkoZmFsc2UsIGxlbikpO1xufVxuY3J0LmdldHIgPSBnZXRyO1xuZnVuY3Rpb24gZ2V0cihwcml2KSB7XG4gIHZhciBsZW4gPSBwcml2Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpO1xuICB2YXIgciA9IG5ldyBibihyYW5kb21CeXRlcyhsZW4pKTtcbiAgd2hpbGUgKHIuY21wKHByaXYubW9kdWx1cykgPj0gIDAgfHwgIXIudW1vZChwcml2LnByaW1lMSkgfHwgIXIudW1vZChwcml2LnByaW1lMikpIHtcbiAgICByID0gbmV3IGJuKHJhbmRvbUJ5dGVzKGxlbikpO1xuICB9XG4gIHJldHVybiByO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jyb3dzZXIvYWxnb3JpdGhtcy5qc29uJylcbiIsInZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vc2lnbicpXG52YXIgdmVyaWZ5ID0gcmVxdWlyZSgnLi92ZXJpZnknKVxuXG52YXIgYWxnb3JpdGhtcyA9IHJlcXVpcmUoJy4vYWxnb3JpdGhtcy5qc29uJylcbk9iamVjdC5rZXlzKGFsZ29yaXRobXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBhbGdvcml0aG1zW2tleV0uaWQgPSBuZXcgQnVmZmVyKGFsZ29yaXRobXNba2V5XS5pZCwgJ2hleCcpXG4gIGFsZ29yaXRobXNba2V5LnRvTG93ZXJDYXNlKCldID0gYWxnb3JpdGhtc1trZXldXG59KVxuXG5mdW5jdGlvbiBTaWduIChhbGdvcml0aG0pIHtcbiAgc3RyZWFtLldyaXRhYmxlLmNhbGwodGhpcylcblxuICB2YXIgZGF0YSA9IGFsZ29yaXRobXNbYWxnb3JpdGhtXVxuICBpZiAoIWRhdGEpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtZXNzYWdlIGRpZ2VzdCcpXG5cbiAgdGhpcy5faGFzaFR5cGUgPSBkYXRhLmhhc2hcbiAgdGhpcy5faGFzaCA9IGNyZWF0ZUhhc2goZGF0YS5oYXNoKVxuICB0aGlzLl90YWcgPSBkYXRhLmlkXG4gIHRoaXMuX3NpZ25UeXBlID0gZGF0YS5zaWduXG59XG5pbmhlcml0cyhTaWduLCBzdHJlYW0uV3JpdGFibGUpXG5cblNpZ24ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIF93cml0ZSAoZGF0YSwgXywgZG9uZSkge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxuICBkb25lKClcbn1cblxuU2lnbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChkYXRhLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgZW5jKVxuXG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG4gIHJldHVybiB0aGlzXG59XG5cblNpZ24ucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduTWV0aG9kIChrZXksIGVuYykge1xuICB0aGlzLmVuZCgpXG4gIHZhciBoYXNoID0gdGhpcy5faGFzaC5kaWdlc3QoKVxuICB2YXIgc2lnID0gc2lnbihoYXNoLCBrZXksIHRoaXMuX2hhc2hUeXBlLCB0aGlzLl9zaWduVHlwZSwgdGhpcy5fdGFnKVxuXG4gIHJldHVybiBlbmMgPyBzaWcudG9TdHJpbmcoZW5jKSA6IHNpZ1xufVxuXG5mdW5jdGlvbiBWZXJpZnkgKGFsZ29yaXRobSkge1xuICBzdHJlYW0uV3JpdGFibGUuY2FsbCh0aGlzKVxuXG4gIHZhciBkYXRhID0gYWxnb3JpdGhtc1thbGdvcml0aG1dXG4gIGlmICghZGF0YSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1lc3NhZ2UgZGlnZXN0JylcblxuICB0aGlzLl9oYXNoID0gY3JlYXRlSGFzaChkYXRhLmhhc2gpXG4gIHRoaXMuX3RhZyA9IGRhdGEuaWRcbiAgdGhpcy5fc2lnblR5cGUgPSBkYXRhLnNpZ25cbn1cbmluaGVyaXRzKFZlcmlmeSwgc3RyZWFtLldyaXRhYmxlKVxuXG5WZXJpZnkucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIF93cml0ZSAoZGF0YSwgXywgZG9uZSkge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxuICBkb25lKClcbn1cblxuVmVyaWZ5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKGRhdGEsIGVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBlbmMpXG5cbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcbiAgcmV0dXJuIHRoaXNcbn1cblxuVmVyaWZ5LnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnlNZXRob2QgKGtleSwgc2lnLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBzaWcgPT09ICdzdHJpbmcnKSBzaWcgPSBuZXcgQnVmZmVyKHNpZywgZW5jKVxuXG4gIHRoaXMuZW5kKClcbiAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoLmRpZ2VzdCgpXG4gIHJldHVybiB2ZXJpZnkoc2lnLCBoYXNoLCBrZXksIHRoaXMuX3NpZ25UeXBlLCB0aGlzLl90YWcpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNpZ24gKGFsZ29yaXRobSkge1xuICByZXR1cm4gbmV3IFNpZ24oYWxnb3JpdGhtKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVWZXJpZnkgKGFsZ29yaXRobSkge1xuICByZXR1cm4gbmV3IFZlcmlmeShhbGdvcml0aG0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBTaWduOiBjcmVhdGVTaWduLFxuICBWZXJpZnk6IGNyZWF0ZVZlcmlmeSxcbiAgY3JlYXRlU2lnbjogY3JlYXRlU2lnbixcbiAgY3JlYXRlVmVyaWZ5OiBjcmVhdGVWZXJpZnlcbn1cbiIsIi8vIG11Y2ggb2YgdGhpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9zZWxmLXNpZ25lZC9ibG9iL2doLXBhZ2VzL2xpYi9yc2EuanNcbnZhciBjcmVhdGVIbWFjID0gcmVxdWlyZSgnY3JlYXRlLWhtYWMnKVxudmFyIGNydCA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktcnNhJylcbnZhciBFQyA9IHJlcXVpcmUoJ2VsbGlwdGljJykuZWNcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJylcbnZhciBwYXJzZUtleXMgPSByZXF1aXJlKCdwYXJzZS1hc24xJylcbnZhciBjdXJ2ZXMgPSByZXF1aXJlKCcuL2N1cnZlcy5qc29uJylcblxuZnVuY3Rpb24gc2lnbiAoaGFzaCwga2V5LCBoYXNoVHlwZSwgc2lnblR5cGUsIHRhZykge1xuICB2YXIgcHJpdiA9IHBhcnNlS2V5cyhrZXkpXG4gIGlmIChwcml2LmN1cnZlKSB7XG4gICAgLy8gcnNhIGtleXMgY2FuIGJlIGludGVycHJldGVkIGFzIGVjZHNhIG9uZXMgaW4gb3BlbnNzbFxuICAgIGlmIChzaWduVHlwZSAhPT0gJ2VjZHNhJyAmJiBzaWduVHlwZSAhPT0gJ2VjZHNhL3JzYScpIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHJpdmF0ZSBrZXkgdHlwZScpXG4gICAgcmV0dXJuIGVjU2lnbihoYXNoLCBwcml2KVxuICB9IGVsc2UgaWYgKHByaXYudHlwZSA9PT0gJ2RzYScpIHtcbiAgICBpZiAoc2lnblR5cGUgIT09ICdkc2EnKSB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHByaXZhdGUga2V5IHR5cGUnKVxuICAgIHJldHVybiBkc2FTaWduKGhhc2gsIHByaXYsIGhhc2hUeXBlKVxuICB9IGVsc2Uge1xuICAgIGlmIChzaWduVHlwZSAhPT0gJ3JzYScgJiYgc2lnblR5cGUgIT09ICdlY2RzYS9yc2EnKSB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHByaXZhdGUga2V5IHR5cGUnKVxuICB9XG4gIGhhc2ggPSBCdWZmZXIuY29uY2F0KFt0YWcsIGhhc2hdKVxuICB2YXIgbGVuID0gcHJpdi5tb2R1bHVzLmJ5dGVMZW5ndGgoKVxuICB2YXIgcGFkID0gWyAwLCAxIF1cbiAgd2hpbGUgKGhhc2gubGVuZ3RoICsgcGFkLmxlbmd0aCArIDEgPCBsZW4pIHBhZC5wdXNoKDB4ZmYpXG4gIHBhZC5wdXNoKDB4MDApXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGhhc2gubGVuZ3RoKSBwYWQucHVzaChoYXNoW2ldKVxuXG4gIHZhciBvdXQgPSBjcnQocGFkLCBwcml2KVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIGVjU2lnbiAoaGFzaCwgcHJpdikge1xuICB2YXIgY3VydmVJZCA9IGN1cnZlc1twcml2LmN1cnZlLmpvaW4oJy4nKV1cbiAgaWYgKCFjdXJ2ZUlkKSB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY3VydmUgJyArIHByaXYuY3VydmUuam9pbignLicpKVxuXG4gIHZhciBjdXJ2ZSA9IG5ldyBFQyhjdXJ2ZUlkKVxuICB2YXIga2V5ID0gY3VydmUua2V5RnJvbVByaXZhdGUocHJpdi5wcml2YXRlS2V5KVxuICB2YXIgb3V0ID0ga2V5LnNpZ24oaGFzaClcblxuICByZXR1cm4gbmV3IEJ1ZmZlcihvdXQudG9ERVIoKSlcbn1cblxuZnVuY3Rpb24gZHNhU2lnbiAoaGFzaCwgcHJpdiwgYWxnbykge1xuICB2YXIgeCA9IHByaXYucGFyYW1zLnByaXZfa2V5XG4gIHZhciBwID0gcHJpdi5wYXJhbXMucFxuICB2YXIgcSA9IHByaXYucGFyYW1zLnFcbiAgdmFyIGcgPSBwcml2LnBhcmFtcy5nXG4gIHZhciByID0gbmV3IEJOKDApXG4gIHZhciBrXG4gIHZhciBIID0gYml0czJpbnQoaGFzaCwgcSkubW9kKHEpXG4gIHZhciBzID0gZmFsc2VcbiAgdmFyIGt2ID0gZ2V0S2V5KHgsIHEsIGhhc2gsIGFsZ28pXG4gIHdoaWxlIChzID09PSBmYWxzZSkge1xuICAgIGsgPSBtYWtlS2V5KHEsIGt2LCBhbGdvKVxuICAgIHIgPSBtYWtlUihnLCBrLCBwLCBxKVxuICAgIHMgPSBrLmludm0ocSkuaW11bChILmFkZCh4Lm11bChyKSkpLm1vZChxKVxuICAgIGlmIChzLmNtcG4oMCkgPT09IDApIHtcbiAgICAgIHMgPSBmYWxzZVxuICAgICAgciA9IG5ldyBCTigwKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG9ERVIociwgcylcbn1cblxuZnVuY3Rpb24gdG9ERVIgKHIsIHMpIHtcbiAgciA9IHIudG9BcnJheSgpXG4gIHMgPSBzLnRvQXJyYXkoKVxuXG4gIC8vIFBhZCB2YWx1ZXNcbiAgaWYgKHJbMF0gJiAweDgwKSByID0gWyAwIF0uY29uY2F0KHIpXG4gIGlmIChzWzBdICYgMHg4MCkgcyA9IFsgMCBdLmNvbmNhdChzKVxuXG4gIHZhciB0b3RhbCA9IHIubGVuZ3RoICsgcy5sZW5ndGggKyA0XG4gIHZhciByZXMgPSBbIDB4MzAsIHRvdGFsLCAweDAyLCByLmxlbmd0aCBdXG4gIHJlcyA9IHJlcy5jb25jYXQociwgWyAweDAyLCBzLmxlbmd0aCBdLCBzKVxuICByZXR1cm4gbmV3IEJ1ZmZlcihyZXMpXG59XG5cbmZ1bmN0aW9uIGdldEtleSAoeCwgcSwgaGFzaCwgYWxnbykge1xuICB4ID0gbmV3IEJ1ZmZlcih4LnRvQXJyYXkoKSlcbiAgaWYgKHgubGVuZ3RoIDwgcS5ieXRlTGVuZ3RoKCkpIHtcbiAgICB2YXIgemVyb3MgPSBuZXcgQnVmZmVyKHEuYnl0ZUxlbmd0aCgpIC0geC5sZW5ndGgpXG4gICAgemVyb3MuZmlsbCgwKVxuICAgIHggPSBCdWZmZXIuY29uY2F0KFsgemVyb3MsIHggXSlcbiAgfVxuICB2YXIgaGxlbiA9IGhhc2gubGVuZ3RoXG4gIHZhciBoYml0cyA9IGJpdHMyb2N0ZXRzKGhhc2gsIHEpXG4gIHZhciB2ID0gbmV3IEJ1ZmZlcihobGVuKVxuICB2LmZpbGwoMSlcbiAgdmFyIGsgPSBuZXcgQnVmZmVyKGhsZW4pXG4gIGsuZmlsbCgwKVxuICBrID0gY3JlYXRlSG1hYyhhbGdvLCBrKS51cGRhdGUodikudXBkYXRlKG5ldyBCdWZmZXIoWyAwIF0pKS51cGRhdGUoeCkudXBkYXRlKGhiaXRzKS5kaWdlc3QoKVxuICB2ID0gY3JlYXRlSG1hYyhhbGdvLCBrKS51cGRhdGUodikuZGlnZXN0KClcbiAgayA9IGNyZWF0ZUhtYWMoYWxnbywgaykudXBkYXRlKHYpLnVwZGF0ZShuZXcgQnVmZmVyKFsgMSBdKSkudXBkYXRlKHgpLnVwZGF0ZShoYml0cykuZGlnZXN0KClcbiAgdiA9IGNyZWF0ZUhtYWMoYWxnbywgaykudXBkYXRlKHYpLmRpZ2VzdCgpXG4gIHJldHVybiB7IGs6IGssIHY6IHYgfVxufVxuXG5mdW5jdGlvbiBiaXRzMmludCAob2JpdHMsIHEpIHtcbiAgdmFyIGJpdHMgPSBuZXcgQk4ob2JpdHMpXG4gIHZhciBzaGlmdCA9IChvYml0cy5sZW5ndGggPDwgMykgLSBxLmJpdExlbmd0aCgpXG4gIGlmIChzaGlmdCA+IDApIGJpdHMuaXNocm4oc2hpZnQpXG4gIHJldHVybiBiaXRzXG59XG5cbmZ1bmN0aW9uIGJpdHMyb2N0ZXRzIChiaXRzLCBxKSB7XG4gIGJpdHMgPSBiaXRzMmludChiaXRzLCBxKVxuICBiaXRzID0gYml0cy5tb2QocSlcbiAgdmFyIG91dCA9IG5ldyBCdWZmZXIoYml0cy50b0FycmF5KCkpXG4gIGlmIChvdXQubGVuZ3RoIDwgcS5ieXRlTGVuZ3RoKCkpIHtcbiAgICB2YXIgemVyb3MgPSBuZXcgQnVmZmVyKHEuYnl0ZUxlbmd0aCgpIC0gb3V0Lmxlbmd0aClcbiAgICB6ZXJvcy5maWxsKDApXG4gICAgb3V0ID0gQnVmZmVyLmNvbmNhdChbIHplcm9zLCBvdXQgXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIG1ha2VLZXkgKHEsIGt2LCBhbGdvKSB7XG4gIHZhciB0XG4gIHZhciBrXG5cbiAgZG8ge1xuICAgIHQgPSBuZXcgQnVmZmVyKDApXG5cbiAgICB3aGlsZSAodC5sZW5ndGggKiA4IDwgcS5iaXRMZW5ndGgoKSkge1xuICAgICAga3YudiA9IGNyZWF0ZUhtYWMoYWxnbywga3YuaykudXBkYXRlKGt2LnYpLmRpZ2VzdCgpXG4gICAgICB0ID0gQnVmZmVyLmNvbmNhdChbIHQsIGt2LnYgXSlcbiAgICB9XG5cbiAgICBrID0gYml0czJpbnQodCwgcSlcbiAgICBrdi5rID0gY3JlYXRlSG1hYyhhbGdvLCBrdi5rKS51cGRhdGUoa3YudikudXBkYXRlKG5ldyBCdWZmZXIoWyAwIF0pKS5kaWdlc3QoKVxuICAgIGt2LnYgPSBjcmVhdGVIbWFjKGFsZ28sIGt2LmspLnVwZGF0ZShrdi52KS5kaWdlc3QoKVxuICB9IHdoaWxlIChrLmNtcChxKSAhPT0gLTEpXG5cbiAgcmV0dXJuIGtcbn1cblxuZnVuY3Rpb24gbWFrZVIgKGcsIGssIHAsIHEpIHtcbiAgcmV0dXJuIGcudG9SZWQoQk4ubW9udChwKSkucmVkUG93KGspLmZyb21SZWQoKS5tb2QocSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaWduXG5tb2R1bGUuZXhwb3J0cy5nZXRLZXkgPSBnZXRLZXlcbm1vZHVsZS5leHBvcnRzLm1ha2VLZXkgPSBtYWtlS2V5XG4iLCIvLyBtdWNoIG9mIHRoaXMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvc2VsZi1zaWduZWQvYmxvYi9naC1wYWdlcy9saWIvcnNhLmpzXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG52YXIgRUMgPSByZXF1aXJlKCdlbGxpcHRpYycpLmVjXG52YXIgcGFyc2VLZXlzID0gcmVxdWlyZSgncGFyc2UtYXNuMScpXG52YXIgY3VydmVzID0gcmVxdWlyZSgnLi9jdXJ2ZXMuanNvbicpXG5cbmZ1bmN0aW9uIHZlcmlmeSAoc2lnLCBoYXNoLCBrZXksIHNpZ25UeXBlLCB0YWcpIHtcbiAgdmFyIHB1YiA9IHBhcnNlS2V5cyhrZXkpXG4gIGlmIChwdWIudHlwZSA9PT0gJ2VjJykge1xuICAgIC8vIHJzYSBrZXlzIGNhbiBiZSBpbnRlcnByZXRlZCBhcyBlY2RzYSBvbmVzIGluIG9wZW5zc2xcbiAgICBpZiAoc2lnblR5cGUgIT09ICdlY2RzYScgJiYgc2lnblR5cGUgIT09ICdlY2RzYS9yc2EnKSB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHB1YmxpYyBrZXkgdHlwZScpXG4gICAgcmV0dXJuIGVjVmVyaWZ5KHNpZywgaGFzaCwgcHViKVxuICB9IGVsc2UgaWYgKHB1Yi50eXBlID09PSAnZHNhJykge1xuICAgIGlmIChzaWduVHlwZSAhPT0gJ2RzYScpIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHVibGljIGtleSB0eXBlJylcbiAgICByZXR1cm4gZHNhVmVyaWZ5KHNpZywgaGFzaCwgcHViKVxuICB9IGVsc2Uge1xuICAgIGlmIChzaWduVHlwZSAhPT0gJ3JzYScgJiYgc2lnblR5cGUgIT09ICdlY2RzYS9yc2EnKSB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHB1YmxpYyBrZXkgdHlwZScpXG4gIH1cbiAgaGFzaCA9IEJ1ZmZlci5jb25jYXQoW3RhZywgaGFzaF0pXG4gIHZhciBsZW4gPSBwdWIubW9kdWx1cy5ieXRlTGVuZ3RoKClcbiAgdmFyIHBhZCA9IFsgMSBdXG4gIHZhciBwYWROdW0gPSAwXG4gIHdoaWxlIChoYXNoLmxlbmd0aCArIHBhZC5sZW5ndGggKyAyIDwgbGVuKSB7XG4gICAgcGFkLnB1c2goMHhmZilcbiAgICBwYWROdW0rK1xuICB9XG4gIHBhZC5wdXNoKDB4MDApXG4gIHZhciBpID0gLTFcbiAgd2hpbGUgKCsraSA8IGhhc2gubGVuZ3RoKSB7XG4gICAgcGFkLnB1c2goaGFzaFtpXSlcbiAgfVxuICBwYWQgPSBuZXcgQnVmZmVyKHBhZClcbiAgdmFyIHJlZCA9IEJOLm1vbnQocHViLm1vZHVsdXMpXG4gIHNpZyA9IG5ldyBCTihzaWcpLnRvUmVkKHJlZClcblxuICBzaWcgPSBzaWcucmVkUG93KG5ldyBCTihwdWIucHVibGljRXhwb25lbnQpKVxuICBzaWcgPSBuZXcgQnVmZmVyKHNpZy5mcm9tUmVkKCkudG9BcnJheSgpKVxuICB2YXIgb3V0ID0gcGFkTnVtIDwgOCA/IDEgOiAwXG4gIGxlbiA9IE1hdGgubWluKHNpZy5sZW5ndGgsIHBhZC5sZW5ndGgpXG4gIGlmIChzaWcubGVuZ3RoICE9PSBwYWQubGVuZ3RoKSBvdXQgPSAxXG5cbiAgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIG91dCB8PSBzaWdbaV0gXiBwYWRbaV1cbiAgcmV0dXJuIG91dCA9PT0gMFxufVxuXG5mdW5jdGlvbiBlY1ZlcmlmeSAoc2lnLCBoYXNoLCBwdWIpIHtcbiAgdmFyIGN1cnZlSWQgPSBjdXJ2ZXNbcHViLmRhdGEuYWxnb3JpdGhtLmN1cnZlLmpvaW4oJy4nKV1cbiAgaWYgKCFjdXJ2ZUlkKSB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY3VydmUgJyArIHB1Yi5kYXRhLmFsZ29yaXRobS5jdXJ2ZS5qb2luKCcuJykpXG5cbiAgdmFyIGN1cnZlID0gbmV3IEVDKGN1cnZlSWQpXG4gIHZhciBwdWJrZXkgPSBwdWIuZGF0YS5zdWJqZWN0UHJpdmF0ZUtleS5kYXRhXG5cbiAgcmV0dXJuIGN1cnZlLnZlcmlmeShoYXNoLCBzaWcsIHB1YmtleSlcbn1cblxuZnVuY3Rpb24gZHNhVmVyaWZ5IChzaWcsIGhhc2gsIHB1Yikge1xuICB2YXIgcCA9IHB1Yi5kYXRhLnBcbiAgdmFyIHEgPSBwdWIuZGF0YS5xXG4gIHZhciBnID0gcHViLmRhdGEuZ1xuICB2YXIgeSA9IHB1Yi5kYXRhLnB1Yl9rZXlcbiAgdmFyIHVucGFja2VkID0gcGFyc2VLZXlzLnNpZ25hdHVyZS5kZWNvZGUoc2lnLCAnZGVyJylcbiAgdmFyIHMgPSB1bnBhY2tlZC5zXG4gIHZhciByID0gdW5wYWNrZWQuclxuICBjaGVja1ZhbHVlKHMsIHEpXG4gIGNoZWNrVmFsdWUociwgcSlcbiAgdmFyIG1vbnRwID0gQk4ubW9udChwKVxuICB2YXIgdyA9IHMuaW52bShxKVxuICB2YXIgdiA9IGcudG9SZWQobW9udHApXG4gICAgLnJlZFBvdyhuZXcgQk4oaGFzaCkubXVsKHcpLm1vZChxKSlcbiAgICAuZnJvbVJlZCgpXG4gICAgLm11bCh5LnRvUmVkKG1vbnRwKS5yZWRQb3coci5tdWwodykubW9kKHEpKS5mcm9tUmVkKCkpXG4gICAgLm1vZChwKVxuICAgIC5tb2QocSlcbiAgcmV0dXJuIHYuY21wKHIpID09PSAwXG59XG5cbmZ1bmN0aW9uIGNoZWNrVmFsdWUgKGIsIHEpIHtcbiAgaWYgKGIuY21wbigwKSA8PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnJylcbiAgaWYgKGIuY21wKHEpID49IHEpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaWcnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZlcmlmeVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4b3IgKGEsIGIpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aClcbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBidWZmZXJbaV0gPSBhW2ldIF4gYltpXVxuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlclxufVxuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtXG52YXIgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlclxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5mdW5jdGlvbiBDaXBoZXJCYXNlIChoYXNoTW9kZSkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLmhhc2hNb2RlID0gdHlwZW9mIGhhc2hNb2RlID09PSAnc3RyaW5nJ1xuICBpZiAodGhpcy5oYXNoTW9kZSkge1xuICAgIHRoaXNbaGFzaE1vZGVdID0gdGhpcy5fZmluYWxPckRpZ2VzdFxuICB9IGVsc2Uge1xuICAgIHRoaXMuZmluYWwgPSB0aGlzLl9maW5hbE9yRGlnZXN0XG4gIH1cbiAgaWYgKHRoaXMuX2ZpbmFsKSB7XG4gICAgdGhpcy5fX2ZpbmFsID0gdGhpcy5fZmluYWxcbiAgICB0aGlzLl9maW5hbCA9IG51bGxcbiAgfVxuICB0aGlzLl9kZWNvZGVyID0gbnVsbFxuICB0aGlzLl9lbmNvZGluZyA9IG51bGxcbn1cbmluaGVyaXRzKENpcGhlckJhc2UsIFRyYW5zZm9ybSlcblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGlucHV0RW5jLCBvdXRwdXRFbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCBpbnB1dEVuYylcbiAgfVxuXG4gIHZhciBvdXREYXRhID0gdGhpcy5fdXBkYXRlKGRhdGEpXG4gIGlmICh0aGlzLmhhc2hNb2RlKSByZXR1cm4gdGhpc1xuXG4gIGlmIChvdXRwdXRFbmMpIHtcbiAgICBvdXREYXRhID0gdGhpcy5fdG9TdHJpbmcob3V0RGF0YSwgb3V0cHV0RW5jKVxuICB9XG5cbiAgcmV0dXJuIG91dERhdGFcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QXV0b1BhZGRpbmcgPSBmdW5jdGlvbiAoKSB7fVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuZ2V0QXV0aFRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gZ2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QXV0aFRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gc2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QUFEID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBzZXQgYWFkIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChkYXRhLCBfLCBuZXh0KSB7XG4gIHZhciBlcnJcbiAgdHJ5IHtcbiAgICBpZiAodGhpcy5oYXNoTW9kZSkge1xuICAgICAgdGhpcy5fdXBkYXRlKGRhdGEpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaCh0aGlzLl91cGRhdGUoZGF0YSkpXG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyID0gZVxuICB9IGZpbmFsbHkge1xuICAgIG5leHQoZXJyKVxuICB9XG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAoZG9uZSkge1xuICB2YXIgZXJyXG4gIHRyeSB7XG4gICAgdGhpcy5wdXNoKHRoaXMuX19maW5hbCgpKVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyID0gZVxuICB9XG5cbiAgZG9uZShlcnIpXG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fZmluYWxPckRpZ2VzdCA9IGZ1bmN0aW9uIChvdXRwdXRFbmMpIHtcbiAgdmFyIG91dERhdGEgPSB0aGlzLl9fZmluYWwoKSB8fCBCdWZmZXIuYWxsb2MoMClcbiAgaWYgKG91dHB1dEVuYykge1xuICAgIG91dERhdGEgPSB0aGlzLl90b1N0cmluZyhvdXREYXRhLCBvdXRwdXRFbmMsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG91dERhdGFcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX3RvU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlLCBlbmMsIGZpbikge1xuICBpZiAoIXRoaXMuX2RlY29kZXIpIHtcbiAgICB0aGlzLl9kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKVxuICAgIHRoaXMuX2VuY29kaW5nID0gZW5jXG4gIH1cblxuICBpZiAodGhpcy5fZW5jb2RpbmcgIT09IGVuYykgdGhyb3cgbmV3IEVycm9yKCdjYW5cXCd0IHN3aXRjaCBlbmNvZGluZ3MnKVxuXG4gIHZhciBvdXQgPSB0aGlzLl9kZWNvZGVyLndyaXRlKHZhbHVlKVxuICBpZiAoZmluKSB7XG4gICAgb3V0ICs9IHRoaXMuX2RlY29kZXIuZW5kKClcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDaXBoZXJCYXNlXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCJ2YXIgZWxsaXB0aWMgPSByZXF1aXJlKCdlbGxpcHRpYycpXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRUNESCAoY3VydmUpIHtcbiAgcmV0dXJuIG5ldyBFQ0RIKGN1cnZlKVxufVxuXG52YXIgYWxpYXNlcyA9IHtcbiAgc2VjcDI1NmsxOiB7XG4gICAgbmFtZTogJ3NlY3AyNTZrMScsXG4gICAgYnl0ZUxlbmd0aDogMzJcbiAgfSxcbiAgc2VjcDIyNHIxOiB7XG4gICAgbmFtZTogJ3AyMjQnLFxuICAgIGJ5dGVMZW5ndGg6IDI4XG4gIH0sXG4gIHByaW1lMjU2djE6IHtcbiAgICBuYW1lOiAncDI1NicsXG4gICAgYnl0ZUxlbmd0aDogMzJcbiAgfSxcbiAgcHJpbWUxOTJ2MToge1xuICAgIG5hbWU6ICdwMTkyJyxcbiAgICBieXRlTGVuZ3RoOiAyNFxuICB9LFxuICBlZDI1NTE5OiB7XG4gICAgbmFtZTogJ2VkMjU1MTknLFxuICAgIGJ5dGVMZW5ndGg6IDMyXG4gIH0sXG4gIHNlY3AzODRyMToge1xuICAgIG5hbWU6ICdwMzg0JyxcbiAgICBieXRlTGVuZ3RoOiA0OFxuICB9LFxuICBzZWNwNTIxcjE6IHtcbiAgICBuYW1lOiAncDUyMScsXG4gICAgYnl0ZUxlbmd0aDogNjZcbiAgfVxufVxuXG5hbGlhc2VzLnAyMjQgPSBhbGlhc2VzLnNlY3AyMjRyMVxuYWxpYXNlcy5wMjU2ID0gYWxpYXNlcy5zZWNwMjU2cjEgPSBhbGlhc2VzLnByaW1lMjU2djFcbmFsaWFzZXMucDE5MiA9IGFsaWFzZXMuc2VjcDE5MnIxID0gYWxpYXNlcy5wcmltZTE5MnYxXG5hbGlhc2VzLnAzODQgPSBhbGlhc2VzLnNlY3AzODRyMVxuYWxpYXNlcy5wNTIxID0gYWxpYXNlcy5zZWNwNTIxcjFcblxuZnVuY3Rpb24gRUNESCAoY3VydmUpIHtcbiAgdGhpcy5jdXJ2ZVR5cGUgPSBhbGlhc2VzW2N1cnZlXVxuICBpZiAoIXRoaXMuY3VydmVUeXBlKSB7XG4gICAgdGhpcy5jdXJ2ZVR5cGUgPSB7XG4gICAgICBuYW1lOiBjdXJ2ZVxuICAgIH1cbiAgfVxuICB0aGlzLmN1cnZlID0gbmV3IGVsbGlwdGljLmVjKHRoaXMuY3VydmVUeXBlLm5hbWUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuICB0aGlzLmtleXMgPSB2b2lkIDBcbn1cblxuRUNESC5wcm90b3R5cGUuZ2VuZXJhdGVLZXlzID0gZnVuY3Rpb24gKGVuYywgZm9ybWF0KSB7XG4gIHRoaXMua2V5cyA9IHRoaXMuY3VydmUuZ2VuS2V5UGFpcigpXG4gIHJldHVybiB0aGlzLmdldFB1YmxpY0tleShlbmMsIGZvcm1hdClcbn1cblxuRUNESC5wcm90b3R5cGUuY29tcHV0ZVNlY3JldCA9IGZ1bmN0aW9uIChvdGhlciwgaW5lbmMsIGVuYykge1xuICBpbmVuYyA9IGluZW5jIHx8ICd1dGY4J1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihvdGhlcikpIHtcbiAgICBvdGhlciA9IG5ldyBCdWZmZXIob3RoZXIsIGluZW5jKVxuICB9XG4gIHZhciBvdGhlclB1YiA9IHRoaXMuY3VydmUua2V5RnJvbVB1YmxpYyhvdGhlcikuZ2V0UHVibGljKClcbiAgdmFyIG91dCA9IG90aGVyUHViLm11bCh0aGlzLmtleXMuZ2V0UHJpdmF0ZSgpKS5nZXRYKClcbiAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKG91dCwgZW5jLCB0aGlzLmN1cnZlVHlwZS5ieXRlTGVuZ3RoKVxufVxuXG5FQ0RILnByb3RvdHlwZS5nZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiAoZW5jLCBmb3JtYXQpIHtcbiAgdmFyIGtleSA9IHRoaXMua2V5cy5nZXRQdWJsaWMoZm9ybWF0ID09PSAnY29tcHJlc3NlZCcsIHRydWUpXG4gIGlmIChmb3JtYXQgPT09ICdoeWJyaWQnKSB7XG4gICAgaWYgKGtleVtrZXkubGVuZ3RoIC0gMV0gJSAyKSB7XG4gICAgICBrZXlbMF0gPSA3XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleVswXSA9IDZcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKGtleSwgZW5jKVxufVxuXG5FQ0RILnByb3RvdHlwZS5nZXRQcml2YXRlS2V5ID0gZnVuY3Rpb24gKGVuYykge1xuICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUodGhpcy5rZXlzLmdldFByaXZhdGUoKSwgZW5jKVxufVxuXG5FQ0RILnByb3RvdHlwZS5zZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiAocHViLCBlbmMpIHtcbiAgZW5jID0gZW5jIHx8ICd1dGY4J1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwdWIpKSB7XG4gICAgcHViID0gbmV3IEJ1ZmZlcihwdWIsIGVuYylcbiAgfVxuICB0aGlzLmtleXMuX2ltcG9ydFB1YmxpYyhwdWIpXG4gIHJldHVybiB0aGlzXG59XG5cbkVDREgucHJvdG90eXBlLnNldFByaXZhdGVLZXkgPSBmdW5jdGlvbiAocHJpdiwgZW5jKSB7XG4gIGVuYyA9IGVuYyB8fCAndXRmOCdcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocHJpdikpIHtcbiAgICBwcml2ID0gbmV3IEJ1ZmZlcihwcml2LCBlbmMpXG4gIH1cblxuICB2YXIgX3ByaXYgPSBuZXcgQk4ocHJpdilcbiAgX3ByaXYgPSBfcHJpdi50b1N0cmluZygxNilcbiAgdGhpcy5rZXlzID0gdGhpcy5jdXJ2ZS5nZW5LZXlQYWlyKClcbiAgdGhpcy5rZXlzLl9pbXBvcnRQcml2YXRlKF9wcml2KVxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBmb3JtYXRSZXR1cm5WYWx1ZSAoYm4sIGVuYywgbGVuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShibikpIHtcbiAgICBibiA9IGJuLnRvQXJyYXkoKVxuICB9XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKGJuKVxuICBpZiAobGVuICYmIGJ1Zi5sZW5ndGggPCBsZW4pIHtcbiAgICB2YXIgemVyb3MgPSBuZXcgQnVmZmVyKGxlbiAtIGJ1Zi5sZW5ndGgpXG4gICAgemVyb3MuZmlsbCgwKVxuICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW3plcm9zLCBidWZdKVxuICB9XG4gIGlmICghZW5jKSB7XG4gICAgcmV0dXJuIGJ1ZlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWYudG9TdHJpbmcoZW5jKVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBNRDUgPSByZXF1aXJlKCdtZDUuanMnKVxudmFyIFJJUEVNRDE2MCA9IHJlcXVpcmUoJ3JpcGVtZDE2MCcpXG52YXIgc2hhID0gcmVxdWlyZSgnc2hhLmpzJylcbnZhciBCYXNlID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxuXG5mdW5jdGlvbiBIYXNoIChoYXNoKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCAnZGlnZXN0JylcblxuICB0aGlzLl9oYXNoID0gaGFzaFxufVxuXG5pbmhlcml0cyhIYXNoLCBCYXNlKVxuXG5IYXNoLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcbn1cblxuSGFzaC5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faGFzaC5kaWdlc3QoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUhhc2ggKGFsZykge1xuICBhbGcgPSBhbGcudG9Mb3dlckNhc2UoKVxuICBpZiAoYWxnID09PSAnbWQ1JykgcmV0dXJuIG5ldyBNRDUoKVxuICBpZiAoYWxnID09PSAncm1kMTYwJyB8fCBhbGcgPT09ICdyaXBlbWQxNjAnKSByZXR1cm4gbmV3IFJJUEVNRDE2MCgpXG5cbiAgcmV0dXJuIG5ldyBIYXNoKHNoYShhbGcpKVxufVxuIiwidmFyIE1ENSA9IHJlcXVpcmUoJ21kNS5qcycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICByZXR1cm4gbmV3IE1ENSgpLnVwZGF0ZShidWZmZXIpLmRpZ2VzdCgpXG59XG4iLCIndXNlIHN0cmljdCdcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBMZWdhY3kgPSByZXF1aXJlKCcuL2xlZ2FjeScpXG52YXIgQmFzZSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIG1kNSA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoL21kNScpXG52YXIgUklQRU1EMTYwID0gcmVxdWlyZSgncmlwZW1kMTYwJylcblxudmFyIHNoYSA9IHJlcXVpcmUoJ3NoYS5qcycpXG5cbnZhciBaRVJPUyA9IEJ1ZmZlci5hbGxvYygxMjgpXG5cbmZ1bmN0aW9uIEhtYWMgKGFsZywga2V5KSB7XG4gIEJhc2UuY2FsbCh0aGlzLCAnZGlnZXN0JylcbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAga2V5ID0gQnVmZmVyLmZyb20oa2V5KVxuICB9XG5cbiAgdmFyIGJsb2Nrc2l6ZSA9IChhbGcgPT09ICdzaGE1MTInIHx8IGFsZyA9PT0gJ3NoYTM4NCcpID8gMTI4IDogNjRcblxuICB0aGlzLl9hbGcgPSBhbGdcbiAgdGhpcy5fa2V5ID0ga2V5XG4gIGlmIChrZXkubGVuZ3RoID4gYmxvY2tzaXplKSB7XG4gICAgdmFyIGhhc2ggPSBhbGcgPT09ICdybWQxNjAnID8gbmV3IFJJUEVNRDE2MCgpIDogc2hhKGFsZylcbiAgICBrZXkgPSBoYXNoLnVwZGF0ZShrZXkpLmRpZ2VzdCgpXG4gIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA8IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwgWkVST1NdLCBibG9ja3NpemUpXG4gIH1cblxuICB2YXIgaXBhZCA9IHRoaXMuX2lwYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYmxvY2tzaXplKVxuICB2YXIgb3BhZCA9IHRoaXMuX29wYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYmxvY2tzaXplKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzaXplOyBpKyspIHtcbiAgICBpcGFkW2ldID0ga2V5W2ldIF4gMHgzNlxuICAgIG9wYWRbaV0gPSBrZXlbaV0gXiAweDVDXG4gIH1cbiAgdGhpcy5faGFzaCA9IGFsZyA9PT0gJ3JtZDE2MCcgPyBuZXcgUklQRU1EMTYwKCkgOiBzaGEoYWxnKVxuICB0aGlzLl9oYXNoLnVwZGF0ZShpcGFkKVxufVxuXG5pbmhlcml0cyhIbWFjLCBCYXNlKVxuXG5IbWFjLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcbn1cblxuSG1hYy5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaCA9IHRoaXMuX2hhc2guZGlnZXN0KClcbiAgdmFyIGhhc2ggPSB0aGlzLl9hbGcgPT09ICdybWQxNjAnID8gbmV3IFJJUEVNRDE2MCgpIDogc2hhKHRoaXMuX2FsZylcbiAgcmV0dXJuIGhhc2gudXBkYXRlKHRoaXMuX29wYWQpLnVwZGF0ZShoKS5kaWdlc3QoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUhtYWMgKGFsZywga2V5KSB7XG4gIGFsZyA9IGFsZy50b0xvd2VyQ2FzZSgpXG4gIGlmIChhbGcgPT09ICdybWQxNjAnIHx8IGFsZyA9PT0gJ3JpcGVtZDE2MCcpIHtcbiAgICByZXR1cm4gbmV3IEhtYWMoJ3JtZDE2MCcsIGtleSlcbiAgfVxuICBpZiAoYWxnID09PSAnbWQ1Jykge1xuICAgIHJldHVybiBuZXcgTGVnYWN5KG1kNSwga2V5KVxuICB9XG4gIHJldHVybiBuZXcgSG1hYyhhbGcsIGtleSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBCYXNlID0gcmVxdWlyZSgnY2lwaGVyLWJhc2UnKVxuXG52YXIgWkVST1MgPSBCdWZmZXIuYWxsb2MoMTI4KVxudmFyIGJsb2Nrc2l6ZSA9IDY0XG5cbmZ1bmN0aW9uIEhtYWMgKGFsZywga2V5KSB7XG4gIEJhc2UuY2FsbCh0aGlzLCAnZGlnZXN0JylcbiAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAga2V5ID0gQnVmZmVyLmZyb20oa2V5KVxuICB9XG5cbiAgdGhpcy5fYWxnID0gYWxnXG4gIHRoaXMuX2tleSA9IGtleVxuXG4gIGlmIChrZXkubGVuZ3RoID4gYmxvY2tzaXplKSB7XG4gICAga2V5ID0gYWxnKGtleSlcbiAgfSBlbHNlIGlmIChrZXkubGVuZ3RoIDwgYmxvY2tzaXplKSB7XG4gICAga2V5ID0gQnVmZmVyLmNvbmNhdChba2V5LCBaRVJPU10sIGJsb2Nrc2l6ZSlcbiAgfVxuXG4gIHZhciBpcGFkID0gdGhpcy5faXBhZCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShibG9ja3NpemUpXG4gIHZhciBvcGFkID0gdGhpcy5fb3BhZCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShibG9ja3NpemUpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja3NpemU7IGkrKykge1xuICAgIGlwYWRbaV0gPSBrZXlbaV0gXiAweDM2XG4gICAgb3BhZFtpXSA9IGtleVtpXSBeIDB4NUNcbiAgfVxuXG4gIHRoaXMuX2hhc2ggPSBbaXBhZF1cbn1cblxuaW5oZXJpdHMoSG1hYywgQmFzZSlcblxuSG1hYy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2hhc2gucHVzaChkYXRhKVxufVxuXG5IbWFjLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoID0gdGhpcy5fYWxnKEJ1ZmZlci5jb25jYXQodGhpcy5faGFzaCkpXG4gIHJldHVybiB0aGlzLl9hbGcoQnVmZmVyLmNvbmNhdChbdGhpcy5fb3BhZCwgaF0pKVxufVxubW9kdWxlLmV4cG9ydHMgPSBIbWFjXG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGV4cG9ydHMucm5nID0gZXhwb3J0cy5wc2V1ZG9SYW5kb21CeXRlcyA9IGV4cG9ydHMucHJuZyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJylcbmV4cG9ydHMuY3JlYXRlSGFzaCA9IGV4cG9ydHMuSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJylcbmV4cG9ydHMuY3JlYXRlSG1hYyA9IGV4cG9ydHMuSG1hYyA9IHJlcXVpcmUoJ2NyZWF0ZS1obWFjJylcblxudmFyIGFsZ29zID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1zaWduL2FsZ29zJylcbnZhciBhbGdvS2V5cyA9IE9iamVjdC5rZXlzKGFsZ29zKVxudmFyIGhhc2hlcyA9IFsnc2hhMScsICdzaGEyMjQnLCAnc2hhMjU2JywgJ3NoYTM4NCcsICdzaGE1MTInLCAnbWQ1JywgJ3JtZDE2MCddLmNvbmNhdChhbGdvS2V5cylcbmV4cG9ydHMuZ2V0SGFzaGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaGFzaGVzXG59XG5cbnZhciBwID0gcmVxdWlyZSgncGJrZGYyJylcbmV4cG9ydHMucGJrZGYyID0gcC5wYmtkZjJcbmV4cG9ydHMucGJrZGYyU3luYyA9IHAucGJrZGYyU3luY1xuXG52YXIgYWVzID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1jaXBoZXInKVxuXG5leHBvcnRzLkNpcGhlciA9IGFlcy5DaXBoZXJcbmV4cG9ydHMuY3JlYXRlQ2lwaGVyID0gYWVzLmNyZWF0ZUNpcGhlclxuZXhwb3J0cy5DaXBoZXJpdiA9IGFlcy5DaXBoZXJpdlxuZXhwb3J0cy5jcmVhdGVDaXBoZXJpdiA9IGFlcy5jcmVhdGVDaXBoZXJpdlxuZXhwb3J0cy5EZWNpcGhlciA9IGFlcy5EZWNpcGhlclxuZXhwb3J0cy5jcmVhdGVEZWNpcGhlciA9IGFlcy5jcmVhdGVEZWNpcGhlclxuZXhwb3J0cy5EZWNpcGhlcml2ID0gYWVzLkRlY2lwaGVyaXZcbmV4cG9ydHMuY3JlYXRlRGVjaXBoZXJpdiA9IGFlcy5jcmVhdGVEZWNpcGhlcml2XG5leHBvcnRzLmdldENpcGhlcnMgPSBhZXMuZ2V0Q2lwaGVyc1xuZXhwb3J0cy5saXN0Q2lwaGVycyA9IGFlcy5saXN0Q2lwaGVyc1xuXG52YXIgZGggPSByZXF1aXJlKCdkaWZmaWUtaGVsbG1hbicpXG5cbmV4cG9ydHMuRGlmZmllSGVsbG1hbkdyb3VwID0gZGguRGlmZmllSGVsbG1hbkdyb3VwXG5leHBvcnRzLmNyZWF0ZURpZmZpZUhlbGxtYW5Hcm91cCA9IGRoLmNyZWF0ZURpZmZpZUhlbGxtYW5Hcm91cFxuZXhwb3J0cy5nZXREaWZmaWVIZWxsbWFuID0gZGguZ2V0RGlmZmllSGVsbG1hblxuZXhwb3J0cy5jcmVhdGVEaWZmaWVIZWxsbWFuID0gZGguY3JlYXRlRGlmZmllSGVsbG1hblxuZXhwb3J0cy5EaWZmaWVIZWxsbWFuID0gZGguRGlmZmllSGVsbG1hblxuXG52YXIgc2lnbiA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktc2lnbicpXG5cbmV4cG9ydHMuY3JlYXRlU2lnbiA9IHNpZ24uY3JlYXRlU2lnblxuZXhwb3J0cy5TaWduID0gc2lnbi5TaWduXG5leHBvcnRzLmNyZWF0ZVZlcmlmeSA9IHNpZ24uY3JlYXRlVmVyaWZ5XG5leHBvcnRzLlZlcmlmeSA9IHNpZ24uVmVyaWZ5XG5cbmV4cG9ydHMuY3JlYXRlRUNESCA9IHJlcXVpcmUoJ2NyZWF0ZS1lY2RoJylcblxudmFyIHB1YmxpY0VuY3J5cHQgPSByZXF1aXJlKCdwdWJsaWMtZW5jcnlwdCcpXG5cbmV4cG9ydHMucHVibGljRW5jcnlwdCA9IHB1YmxpY0VuY3J5cHQucHVibGljRW5jcnlwdFxuZXhwb3J0cy5wcml2YXRlRW5jcnlwdCA9IHB1YmxpY0VuY3J5cHQucHJpdmF0ZUVuY3J5cHRcbmV4cG9ydHMucHVibGljRGVjcnlwdCA9IHB1YmxpY0VuY3J5cHQucHVibGljRGVjcnlwdFxuZXhwb3J0cy5wcml2YXRlRGVjcnlwdCA9IHB1YmxpY0VuY3J5cHQucHJpdmF0ZURlY3J5cHRcblxuLy8gdGhlIGxlYXN0IEkgY2FuIGRvIGlzIG1ha2UgZXJyb3IgbWVzc2FnZXMgZm9yIHRoZSByZXN0IG9mIHRoZSBub2RlLmpzL2NyeXB0byBhcGkuXG4vLyA7W1xuLy8gICAnY3JlYXRlQ3JlZGVudGlhbHMnXG4vLyBdLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbi8vICAgZXhwb3J0c1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbi8vICAgICB0aHJvdyBuZXcgRXJyb3IoW1xuLy8gICAgICAgJ3NvcnJ5LCAnICsgbmFtZSArICcgaXMgbm90IGltcGxlbWVudGVkIHlldCcsXG4vLyAgICAgICAnd2UgYWNjZXB0IHB1bGwgcmVxdWVzdHMnLFxuLy8gICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG8tYnJvd3NlcmlmeS9jcnlwdG8tYnJvd3NlcmlmeSdcbi8vICAgICBdLmpvaW4oJ1xcbicpKVxuLy8gICB9XG4vLyB9KVxuXG52YXIgcmYgPSByZXF1aXJlKCdyYW5kb21maWxsJylcblxuZXhwb3J0cy5yYW5kb21GaWxsID0gcmYucmFuZG9tRmlsbFxuZXhwb3J0cy5yYW5kb21GaWxsU3luYyA9IHJmLnJhbmRvbUZpbGxTeW5jXG5cbmV4cG9ydHMuY3JlYXRlQ3JlZGVudGlhbHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcihbXG4gICAgJ3NvcnJ5LCBjcmVhdGVDcmVkZW50aWFscyBpcyBub3QgaW1wbGVtZW50ZWQgeWV0JyxcbiAgICAnd2UgYWNjZXB0IHB1bGwgcmVxdWVzdHMnLFxuICAgICdodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvLWJyb3dzZXJpZnkvY3J5cHRvLWJyb3dzZXJpZnknXG4gIF0uam9pbignXFxuJykpXG59XG5cbmV4cG9ydHMuY29uc3RhbnRzID0ge1xuICAnREhfQ0hFQ0tfUF9OT1RfU0FGRV9QUklNRSc6IDIsXG4gICdESF9DSEVDS19QX05PVF9QUklNRSc6IDEsXG4gICdESF9VTkFCTEVfVE9fQ0hFQ0tfR0VORVJBVE9SJzogNCxcbiAgJ0RIX05PVF9TVUlUQUJMRV9HRU5FUkFUT1InOiA4LFxuICAnTlBOX0VOQUJMRUQnOiAxLFxuICAnQUxQTl9FTkFCTEVEJzogMSxcbiAgJ1JTQV9QS0NTMV9QQURESU5HJzogMSxcbiAgJ1JTQV9TU0xWMjNfUEFERElORyc6IDIsXG4gICdSU0FfTk9fUEFERElORyc6IDMsXG4gICdSU0FfUEtDUzFfT0FFUF9QQURESU5HJzogNCxcbiAgJ1JTQV9YOTMxX1BBRERJTkcnOiA1LFxuICAnUlNBX1BLQ1MxX1BTU19QQURESU5HJzogNixcbiAgJ1BPSU5UX0NPTlZFUlNJT05fQ09NUFJFU1NFRCc6IDIsXG4gICdQT0lOVF9DT05WRVJTSU9OX1VOQ09NUFJFU1NFRCc6IDQsXG4gICdQT0lOVF9DT05WRVJTSU9OX0hZQlJJRCc6IDZcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy51dGlscyA9IHJlcXVpcmUoJy4vZGVzL3V0aWxzJyk7XG5leHBvcnRzLkNpcGhlciA9IHJlcXVpcmUoJy4vZGVzL2NpcGhlcicpO1xuZXhwb3J0cy5ERVMgPSByZXF1aXJlKCcuL2Rlcy9kZXMnKTtcbmV4cG9ydHMuQ0JDID0gcmVxdWlyZSgnLi9kZXMvY2JjJyk7XG5leHBvcnRzLkVERSA9IHJlcXVpcmUoJy4vZGVzL2VkZScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxudmFyIHByb3RvID0ge307XG5cbmZ1bmN0aW9uIENCQ1N0YXRlKGl2KSB7XG4gIGFzc2VydC5lcXVhbChpdi5sZW5ndGgsIDgsICdJbnZhbGlkIElWIGxlbmd0aCcpO1xuXG4gIHRoaXMuaXYgPSBuZXcgQXJyYXkoOCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pdi5sZW5ndGg7IGkrKylcbiAgICB0aGlzLml2W2ldID0gaXZbaV07XG59XG5cbmZ1bmN0aW9uIGluc3RhbnRpYXRlKEJhc2UpIHtcbiAgZnVuY3Rpb24gQ0JDKG9wdGlvbnMpIHtcbiAgICBCYXNlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5fY2JjSW5pdCgpO1xuICB9XG4gIGluaGVyaXRzKENCQywgQmFzZSk7XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm90byk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIENCQy5wcm90b3R5cGVba2V5XSA9IHByb3RvW2tleV07XG4gIH1cblxuICBDQkMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IENCQyhvcHRpb25zKTtcbiAgfTtcblxuICByZXR1cm4gQ0JDO1xufVxuXG5leHBvcnRzLmluc3RhbnRpYXRlID0gaW5zdGFudGlhdGU7XG5cbnByb3RvLl9jYmNJbml0ID0gZnVuY3Rpb24gX2NiY0luaXQoKSB7XG4gIHZhciBzdGF0ZSA9IG5ldyBDQkNTdGF0ZSh0aGlzLm9wdGlvbnMuaXYpO1xuICB0aGlzLl9jYmNTdGF0ZSA9IHN0YXRlO1xufTtcblxucHJvdG8uX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUoaW5wLCBpbk9mZiwgb3V0LCBvdXRPZmYpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fY2JjU3RhdGU7XG4gIHZhciBzdXBlclByb3RvID0gdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcl8ucHJvdG90eXBlO1xuXG4gIHZhciBpdiA9IHN0YXRlLml2O1xuICBpZiAodGhpcy50eXBlID09PSAnZW5jcnlwdCcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYmxvY2tTaXplOyBpKyspXG4gICAgICBpdltpXSBePSBpbnBbaW5PZmYgKyBpXTtcblxuICAgIHN1cGVyUHJvdG8uX3VwZGF0ZS5jYWxsKHRoaXMsIGl2LCAwLCBvdXQsIG91dE9mZik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYmxvY2tTaXplOyBpKyspXG4gICAgICBpdltpXSA9IG91dFtvdXRPZmYgKyBpXTtcbiAgfSBlbHNlIHtcbiAgICBzdXBlclByb3RvLl91cGRhdGUuY2FsbCh0aGlzLCBpbnAsIGluT2ZmLCBvdXQsIG91dE9mZik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYmxvY2tTaXplOyBpKyspXG4gICAgICBvdXRbb3V0T2ZmICsgaV0gXj0gaXZbaV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYmxvY2tTaXplOyBpKyspXG4gICAgICBpdltpXSA9IGlucFtpbk9mZiArIGldO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG5mdW5jdGlvbiBDaXBoZXIob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gIHRoaXMudHlwZSA9IHRoaXMub3B0aW9ucy50eXBlO1xuICB0aGlzLmJsb2NrU2l6ZSA9IDg7XG4gIHRoaXMuX2luaXQoKTtcblxuICB0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheSh0aGlzLmJsb2NrU2l6ZSk7XG4gIHRoaXMuYnVmZmVyT2ZmID0gMDtcbn1cbm1vZHVsZS5leHBvcnRzID0gQ2lwaGVyO1xuXG5DaXBoZXIucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gX2luaXQoKSB7XG4gIC8vIE1pZ2h0IGJlIG92ZXJyaWRlZFxufTtcblxuQ2lwaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZGF0YSkge1xuICBpZiAoZGF0YS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0aGlzLnR5cGUgPT09ICdkZWNyeXB0JylcbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlRGVjcnlwdChkYXRhKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLl91cGRhdGVFbmNyeXB0KGRhdGEpO1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fYnVmZmVyID0gZnVuY3Rpb24gX2J1ZmZlcihkYXRhLCBvZmYpIHtcbiAgLy8gQXBwZW5kIGRhdGEgdG8gYnVmZmVyXG4gIHZhciBtaW4gPSBNYXRoLm1pbih0aGlzLmJ1ZmZlci5sZW5ndGggLSB0aGlzLmJ1ZmZlck9mZiwgZGF0YS5sZW5ndGggLSBvZmYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbjsgaSsrKVxuICAgIHRoaXMuYnVmZmVyW3RoaXMuYnVmZmVyT2ZmICsgaV0gPSBkYXRhW29mZiArIGldO1xuICB0aGlzLmJ1ZmZlck9mZiArPSBtaW47XG5cbiAgLy8gU2hpZnQgbmV4dFxuICByZXR1cm4gbWluO1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fZmx1c2hCdWZmZXIgPSBmdW5jdGlvbiBfZmx1c2hCdWZmZXIob3V0LCBvZmYpIHtcbiAgdGhpcy5fdXBkYXRlKHRoaXMuYnVmZmVyLCAwLCBvdXQsIG9mZik7XG4gIHRoaXMuYnVmZmVyT2ZmID0gMDtcbiAgcmV0dXJuIHRoaXMuYmxvY2tTaXplO1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlRW5jcnlwdCA9IGZ1bmN0aW9uIF91cGRhdGVFbmNyeXB0KGRhdGEpIHtcbiAgdmFyIGlucHV0T2ZmID0gMDtcbiAgdmFyIG91dHB1dE9mZiA9IDA7XG5cbiAgdmFyIGNvdW50ID0gKCh0aGlzLmJ1ZmZlck9mZiArIGRhdGEubGVuZ3RoKSAvIHRoaXMuYmxvY2tTaXplKSB8IDA7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXkoY291bnQgKiB0aGlzLmJsb2NrU2l6ZSk7XG5cbiAgaWYgKHRoaXMuYnVmZmVyT2ZmICE9PSAwKSB7XG4gICAgaW5wdXRPZmYgKz0gdGhpcy5fYnVmZmVyKGRhdGEsIGlucHV0T2ZmKTtcblxuICAgIGlmICh0aGlzLmJ1ZmZlck9mZiA9PT0gdGhpcy5idWZmZXIubGVuZ3RoKVxuICAgICAgb3V0cHV0T2ZmICs9IHRoaXMuX2ZsdXNoQnVmZmVyKG91dCwgb3V0cHV0T2ZmKTtcbiAgfVxuXG4gIC8vIFdyaXRlIGJsb2Nrc1xuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGggLSAoKGRhdGEubGVuZ3RoIC0gaW5wdXRPZmYpICUgdGhpcy5ibG9ja1NpemUpO1xuICBmb3IgKDsgaW5wdXRPZmYgPCBtYXg7IGlucHV0T2ZmICs9IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgdGhpcy5fdXBkYXRlKGRhdGEsIGlucHV0T2ZmLCBvdXQsIG91dHB1dE9mZik7XG4gICAgb3V0cHV0T2ZmICs9IHRoaXMuYmxvY2tTaXplO1xuICB9XG5cbiAgLy8gUXVldWUgcmVzdFxuICBmb3IgKDsgaW5wdXRPZmYgPCBkYXRhLmxlbmd0aDsgaW5wdXRPZmYrKywgdGhpcy5idWZmZXJPZmYrKylcbiAgICB0aGlzLmJ1ZmZlclt0aGlzLmJ1ZmZlck9mZl0gPSBkYXRhW2lucHV0T2ZmXTtcblxuICByZXR1cm4gb3V0O1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fdXBkYXRlRGVjcnlwdCA9IGZ1bmN0aW9uIF91cGRhdGVEZWNyeXB0KGRhdGEpIHtcbiAgdmFyIGlucHV0T2ZmID0gMDtcbiAgdmFyIG91dHB1dE9mZiA9IDA7XG5cbiAgdmFyIGNvdW50ID0gTWF0aC5jZWlsKCh0aGlzLmJ1ZmZlck9mZiArIGRhdGEubGVuZ3RoKSAvIHRoaXMuYmxvY2tTaXplKSAtIDE7XG4gIHZhciBvdXQgPSBuZXcgQXJyYXkoY291bnQgKiB0aGlzLmJsb2NrU2l6ZSk7XG5cbiAgLy8gVE9ETyhpbmR1dG55KTogb3B0aW1pemUgaXQsIHRoaXMgaXMgZmFyIGZyb20gb3B0aW1hbFxuICBmb3IgKDsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgaW5wdXRPZmYgKz0gdGhpcy5fYnVmZmVyKGRhdGEsIGlucHV0T2ZmKTtcbiAgICBvdXRwdXRPZmYgKz0gdGhpcy5fZmx1c2hCdWZmZXIob3V0LCBvdXRwdXRPZmYpO1xuICB9XG5cbiAgLy8gQnVmZmVyIHJlc3Qgb2YgdGhlIGlucHV0XG4gIGlucHV0T2ZmICs9IHRoaXMuX2J1ZmZlcihkYXRhLCBpbnB1dE9mZik7XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuZmluYWwgPSBmdW5jdGlvbiBmaW5hbChidWZmZXIpIHtcbiAgdmFyIGZpcnN0O1xuICBpZiAoYnVmZmVyKVxuICAgIGZpcnN0ID0gdGhpcy51cGRhdGUoYnVmZmVyKTtcblxuICB2YXIgbGFzdDtcbiAgaWYgKHRoaXMudHlwZSA9PT0gJ2VuY3J5cHQnKVxuICAgIGxhc3QgPSB0aGlzLl9maW5hbEVuY3J5cHQoKTtcbiAgZWxzZVxuICAgIGxhc3QgPSB0aGlzLl9maW5hbERlY3J5cHQoKTtcblxuICBpZiAoZmlyc3QpXG4gICAgcmV0dXJuIGZpcnN0LmNvbmNhdChsYXN0KTtcbiAgZWxzZVxuICAgIHJldHVybiBsYXN0O1xufTtcblxuQ2lwaGVyLnByb3RvdHlwZS5fcGFkID0gZnVuY3Rpb24gX3BhZChidWZmZXIsIG9mZikge1xuICBpZiAob2ZmID09PSAwKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB3aGlsZSAob2ZmIDwgYnVmZmVyLmxlbmd0aClcbiAgICBidWZmZXJbb2ZmKytdID0gMDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX2ZpbmFsRW5jcnlwdCA9IGZ1bmN0aW9uIF9maW5hbEVuY3J5cHQoKSB7XG4gIGlmICghdGhpcy5fcGFkKHRoaXMuYnVmZmVyLCB0aGlzLmJ1ZmZlck9mZikpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBvdXQgPSBuZXcgQXJyYXkodGhpcy5ibG9ja1NpemUpO1xuICB0aGlzLl91cGRhdGUodGhpcy5idWZmZXIsIDAsIG91dCwgMCk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG5DaXBoZXIucHJvdG90eXBlLl91bnBhZCA9IGZ1bmN0aW9uIF91bnBhZChidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbkNpcGhlci5wcm90b3R5cGUuX2ZpbmFsRGVjcnlwdCA9IGZ1bmN0aW9uIF9maW5hbERlY3J5cHQoKSB7XG4gIGFzc2VydC5lcXVhbCh0aGlzLmJ1ZmZlck9mZiwgdGhpcy5ibG9ja1NpemUsICdOb3QgZW5vdWdoIGRhdGEgdG8gZGVjcnlwdCcpO1xuICB2YXIgb3V0ID0gbmV3IEFycmF5KHRoaXMuYmxvY2tTaXplKTtcbiAgdGhpcy5fZmx1c2hCdWZmZXIob3V0LCAwKTtcblxuICByZXR1cm4gdGhpcy5fdW5wYWQob3V0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG52YXIgZGVzID0gcmVxdWlyZSgnLi4vZGVzJyk7XG52YXIgdXRpbHMgPSBkZXMudXRpbHM7XG52YXIgQ2lwaGVyID0gZGVzLkNpcGhlcjtcblxuZnVuY3Rpb24gREVTU3RhdGUoKSB7XG4gIHRoaXMudG1wID0gbmV3IEFycmF5KDIpO1xuICB0aGlzLmtleXMgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBERVMob3B0aW9ucykge1xuICBDaXBoZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB2YXIgc3RhdGUgPSBuZXcgREVTU3RhdGUoKTtcbiAgdGhpcy5fZGVzU3RhdGUgPSBzdGF0ZTtcblxuICB0aGlzLmRlcml2ZUtleXMoc3RhdGUsIG9wdGlvbnMua2V5KTtcbn1cbmluaGVyaXRzKERFUywgQ2lwaGVyKTtcbm1vZHVsZS5leHBvcnRzID0gREVTO1xuXG5ERVMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBERVMob3B0aW9ucyk7XG59O1xuXG52YXIgc2hpZnRUYWJsZSA9IFtcbiAgMSwgMSwgMiwgMiwgMiwgMiwgMiwgMixcbiAgMSwgMiwgMiwgMiwgMiwgMiwgMiwgMVxuXTtcblxuREVTLnByb3RvdHlwZS5kZXJpdmVLZXlzID0gZnVuY3Rpb24gZGVyaXZlS2V5cyhzdGF0ZSwga2V5KSB7XG4gIHN0YXRlLmtleXMgPSBuZXcgQXJyYXkoMTYgKiAyKTtcblxuICBhc3NlcnQuZXF1YWwoa2V5Lmxlbmd0aCwgdGhpcy5ibG9ja1NpemUsICdJbnZhbGlkIGtleSBsZW5ndGgnKTtcblxuICB2YXIga0wgPSB1dGlscy5yZWFkVUludDMyQkUoa2V5LCAwKTtcbiAgdmFyIGtSID0gdXRpbHMucmVhZFVJbnQzMkJFKGtleSwgNCk7XG5cbiAgdXRpbHMucGMxKGtMLCBrUiwgc3RhdGUudG1wLCAwKTtcbiAga0wgPSBzdGF0ZS50bXBbMF07XG4gIGtSID0gc3RhdGUudG1wWzFdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmtleXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgc2hpZnQgPSBzaGlmdFRhYmxlW2kgPj4+IDFdO1xuICAgIGtMID0gdXRpbHMucjI4c2hsKGtMLCBzaGlmdCk7XG4gICAga1IgPSB1dGlscy5yMjhzaGwoa1IsIHNoaWZ0KTtcbiAgICB1dGlscy5wYzIoa0wsIGtSLCBzdGF0ZS5rZXlzLCBpKTtcbiAgfVxufTtcblxuREVTLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShpbnAsIGluT2ZmLCBvdXQsIG91dE9mZikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9kZXNTdGF0ZTtcblxuICB2YXIgbCA9IHV0aWxzLnJlYWRVSW50MzJCRShpbnAsIGluT2ZmKTtcbiAgdmFyIHIgPSB1dGlscy5yZWFkVUludDMyQkUoaW5wLCBpbk9mZiArIDQpO1xuXG4gIC8vIEluaXRpYWwgUGVybXV0YXRpb25cbiAgdXRpbHMuaXAobCwgciwgc3RhdGUudG1wLCAwKTtcbiAgbCA9IHN0YXRlLnRtcFswXTtcbiAgciA9IHN0YXRlLnRtcFsxXTtcblxuICBpZiAodGhpcy50eXBlID09PSAnZW5jcnlwdCcpXG4gICAgdGhpcy5fZW5jcnlwdChzdGF0ZSwgbCwgciwgc3RhdGUudG1wLCAwKTtcbiAgZWxzZVxuICAgIHRoaXMuX2RlY3J5cHQoc3RhdGUsIGwsIHIsIHN0YXRlLnRtcCwgMCk7XG5cbiAgbCA9IHN0YXRlLnRtcFswXTtcbiAgciA9IHN0YXRlLnRtcFsxXTtcblxuICB1dGlscy53cml0ZVVJbnQzMkJFKG91dCwgbCwgb3V0T2ZmKTtcbiAgdXRpbHMud3JpdGVVSW50MzJCRShvdXQsIHIsIG91dE9mZiArIDQpO1xufTtcblxuREVTLnByb3RvdHlwZS5fcGFkID0gZnVuY3Rpb24gX3BhZChidWZmZXIsIG9mZikge1xuICB2YXIgdmFsdWUgPSBidWZmZXIubGVuZ3RoIC0gb2ZmO1xuICBmb3IgKHZhciBpID0gb2ZmOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKVxuICAgIGJ1ZmZlcltpXSA9IHZhbHVlO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuREVTLnByb3RvdHlwZS5fdW5wYWQgPSBmdW5jdGlvbiBfdW5wYWQoYnVmZmVyKSB7XG4gIHZhciBwYWQgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIDFdO1xuICBmb3IgKHZhciBpID0gYnVmZmVyLmxlbmd0aCAtIHBhZDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKylcbiAgICBhc3NlcnQuZXF1YWwoYnVmZmVyW2ldLCBwYWQpO1xuXG4gIHJldHVybiBidWZmZXIuc2xpY2UoMCwgYnVmZmVyLmxlbmd0aCAtIHBhZCk7XG59O1xuXG5ERVMucHJvdG90eXBlLl9lbmNyeXB0ID0gZnVuY3Rpb24gX2VuY3J5cHQoc3RhdGUsIGxTdGFydCwgclN0YXJ0LCBvdXQsIG9mZikge1xuICB2YXIgbCA9IGxTdGFydDtcbiAgdmFyIHIgPSByU3RhcnQ7XG5cbiAgLy8gQXBwbHkgZigpIHgxNiB0aW1lc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmtleXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIga2V5TCA9IHN0YXRlLmtleXNbaV07XG4gICAgdmFyIGtleVIgPSBzdGF0ZS5rZXlzW2kgKyAxXTtcblxuICAgIC8vIGYociwgaylcbiAgICB1dGlscy5leHBhbmQociwgc3RhdGUudG1wLCAwKTtcblxuICAgIGtleUwgXj0gc3RhdGUudG1wWzBdO1xuICAgIGtleVIgXj0gc3RhdGUudG1wWzFdO1xuICAgIHZhciBzID0gdXRpbHMuc3Vic3RpdHV0ZShrZXlMLCBrZXlSKTtcbiAgICB2YXIgZiA9IHV0aWxzLnBlcm11dGUocyk7XG5cbiAgICB2YXIgdCA9IHI7XG4gICAgciA9IChsIF4gZikgPj4+IDA7XG4gICAgbCA9IHQ7XG4gIH1cblxuICAvLyBSZXZlcnNlIEluaXRpYWwgUGVybXV0YXRpb25cbiAgdXRpbHMucmlwKHIsIGwsIG91dCwgb2ZmKTtcbn07XG5cbkRFUy5wcm90b3R5cGUuX2RlY3J5cHQgPSBmdW5jdGlvbiBfZGVjcnlwdChzdGF0ZSwgbFN0YXJ0LCByU3RhcnQsIG91dCwgb2ZmKSB7XG4gIHZhciBsID0gclN0YXJ0O1xuICB2YXIgciA9IGxTdGFydDtcblxuICAvLyBBcHBseSBmKCkgeDE2IHRpbWVzXG4gIGZvciAodmFyIGkgPSBzdGF0ZS5rZXlzLmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgdmFyIGtleUwgPSBzdGF0ZS5rZXlzW2ldO1xuICAgIHZhciBrZXlSID0gc3RhdGUua2V5c1tpICsgMV07XG5cbiAgICAvLyBmKHIsIGspXG4gICAgdXRpbHMuZXhwYW5kKGwsIHN0YXRlLnRtcCwgMCk7XG5cbiAgICBrZXlMIF49IHN0YXRlLnRtcFswXTtcbiAgICBrZXlSIF49IHN0YXRlLnRtcFsxXTtcbiAgICB2YXIgcyA9IHV0aWxzLnN1YnN0aXR1dGUoa2V5TCwga2V5Uik7XG4gICAgdmFyIGYgPSB1dGlscy5wZXJtdXRlKHMpO1xuXG4gICAgdmFyIHQgPSBsO1xuICAgIGwgPSAociBeIGYpID4+PiAwO1xuICAgIHIgPSB0O1xuICB9XG5cbiAgLy8gUmV2ZXJzZSBJbml0aWFsIFBlcm11dGF0aW9uXG4gIHV0aWxzLnJpcChsLCByLCBvdXQsIG9mZik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxudmFyIGRlcyA9IHJlcXVpcmUoJy4uL2RlcycpO1xudmFyIENpcGhlciA9IGRlcy5DaXBoZXI7XG52YXIgREVTID0gZGVzLkRFUztcblxuZnVuY3Rpb24gRURFU3RhdGUodHlwZSwga2V5KSB7XG4gIGFzc2VydC5lcXVhbChrZXkubGVuZ3RoLCAyNCwgJ0ludmFsaWQga2V5IGxlbmd0aCcpO1xuXG4gIHZhciBrMSA9IGtleS5zbGljZSgwLCA4KTtcbiAgdmFyIGsyID0ga2V5LnNsaWNlKDgsIDE2KTtcbiAgdmFyIGszID0ga2V5LnNsaWNlKDE2LCAyNCk7XG5cbiAgaWYgKHR5cGUgPT09ICdlbmNyeXB0Jykge1xuICAgIHRoaXMuY2lwaGVycyA9IFtcbiAgICAgIERFUy5jcmVhdGUoeyB0eXBlOiAnZW5jcnlwdCcsIGtleTogazEgfSksXG4gICAgICBERVMuY3JlYXRlKHsgdHlwZTogJ2RlY3J5cHQnLCBrZXk6IGsyIH0pLFxuICAgICAgREVTLmNyZWF0ZSh7IHR5cGU6ICdlbmNyeXB0Jywga2V5OiBrMyB9KVxuICAgIF07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5jaXBoZXJzID0gW1xuICAgICAgREVTLmNyZWF0ZSh7IHR5cGU6ICdkZWNyeXB0Jywga2V5OiBrMyB9KSxcbiAgICAgIERFUy5jcmVhdGUoeyB0eXBlOiAnZW5jcnlwdCcsIGtleTogazIgfSksXG4gICAgICBERVMuY3JlYXRlKHsgdHlwZTogJ2RlY3J5cHQnLCBrZXk6IGsxIH0pXG4gICAgXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBFREUob3B0aW9ucykge1xuICBDaXBoZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB2YXIgc3RhdGUgPSBuZXcgRURFU3RhdGUodGhpcy50eXBlLCB0aGlzLm9wdGlvbnMua2V5KTtcbiAgdGhpcy5fZWRlU3RhdGUgPSBzdGF0ZTtcbn1cbmluaGVyaXRzKEVERSwgQ2lwaGVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBFREU7XG5cbkVERS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUob3B0aW9ucykge1xuICByZXR1cm4gbmV3IEVERShvcHRpb25zKTtcbn07XG5cbkVERS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUoaW5wLCBpbk9mZiwgb3V0LCBvdXRPZmYpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fZWRlU3RhdGU7XG5cbiAgc3RhdGUuY2lwaGVyc1swXS5fdXBkYXRlKGlucCwgaW5PZmYsIG91dCwgb3V0T2ZmKTtcbiAgc3RhdGUuY2lwaGVyc1sxXS5fdXBkYXRlKG91dCwgb3V0T2ZmLCBvdXQsIG91dE9mZik7XG4gIHN0YXRlLmNpcGhlcnNbMl0uX3VwZGF0ZShvdXQsIG91dE9mZiwgb3V0LCBvdXRPZmYpO1xufTtcblxuRURFLnByb3RvdHlwZS5fcGFkID0gREVTLnByb3RvdHlwZS5fcGFkO1xuRURFLnByb3RvdHlwZS5fdW5wYWQgPSBERVMucHJvdG90eXBlLl91bnBhZDtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUoYnl0ZXMsIG9mZikge1xuICB2YXIgcmVzID0gIChieXRlc1swICsgb2ZmXSA8PCAyNCkgfFxuICAgICAgICAgICAgIChieXRlc1sxICsgb2ZmXSA8PCAxNikgfFxuICAgICAgICAgICAgIChieXRlc1syICsgb2ZmXSA8PCA4KSB8XG4gICAgICAgICAgICAgYnl0ZXNbMyArIG9mZl07XG4gIHJldHVybiByZXMgPj4+IDA7XG59O1xuXG5leHBvcnRzLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFKGJ5dGVzLCB2YWx1ZSwgb2ZmKSB7XG4gIGJ5dGVzWzAgKyBvZmZdID0gdmFsdWUgPj4+IDI0O1xuICBieXRlc1sxICsgb2ZmXSA9ICh2YWx1ZSA+Pj4gMTYpICYgMHhmZjtcbiAgYnl0ZXNbMiArIG9mZl0gPSAodmFsdWUgPj4+IDgpICYgMHhmZjtcbiAgYnl0ZXNbMyArIG9mZl0gPSB2YWx1ZSAmIDB4ZmY7XG59O1xuXG5leHBvcnRzLmlwID0gZnVuY3Rpb24gaXAoaW5MLCBpblIsIG91dCwgb2ZmKSB7XG4gIHZhciBvdXRMID0gMDtcbiAgdmFyIG91dFIgPSAwO1xuXG4gIGZvciAodmFyIGkgPSA2OyBpID49IDA7IGkgLT0gMikge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICAgIG91dEwgPDw9IDE7XG4gICAgICBvdXRMIHw9IChpblIgPj4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgICAgb3V0TCA8PD0gMTtcbiAgICAgIG91dEwgfD0gKGluTCA+Pj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSA2OyBpID49IDA7IGkgLT0gMikge1xuICAgIGZvciAodmFyIGogPSAxOyBqIDw9IDI1OyBqICs9IDgpIHtcbiAgICAgIG91dFIgPDw9IDE7XG4gICAgICBvdXRSIHw9IChpblIgPj4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gMjU7IGogKz0gOCkge1xuICAgICAgb3V0UiA8PD0gMTtcbiAgICAgIG91dFIgfD0gKGluTCA+Pj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgfVxuXG4gIG91dFtvZmYgKyAwXSA9IG91dEwgPj4+IDA7XG4gIG91dFtvZmYgKyAxXSA9IG91dFIgPj4+IDA7XG59O1xuXG5leHBvcnRzLnJpcCA9IGZ1bmN0aW9uIHJpcChpbkwsIGluUiwgb3V0LCBvZmYpIHtcbiAgdmFyIG91dEwgPSAwO1xuICB2YXIgb3V0UiA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMjQ7IGogPj0gMDsgaiAtPSA4KSB7XG4gICAgICBvdXRMIDw8PSAxO1xuICAgICAgb3V0TCB8PSAoaW5SID4+PiAoaiArIGkpKSAmIDE7XG4gICAgICBvdXRMIDw8PSAxO1xuICAgICAgb3V0TCB8PSAoaW5MID4+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGkgPSA0OyBpIDwgODsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDI0OyBqID49IDA7IGogLT0gOCkge1xuICAgICAgb3V0UiA8PD0gMTtcbiAgICAgIG91dFIgfD0gKGluUiA+Pj4gKGogKyBpKSkgJiAxO1xuICAgICAgb3V0UiA8PD0gMTtcbiAgICAgIG91dFIgfD0gKGluTCA+Pj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgfVxuXG4gIG91dFtvZmYgKyAwXSA9IG91dEwgPj4+IDA7XG4gIG91dFtvZmYgKyAxXSA9IG91dFIgPj4+IDA7XG59O1xuXG5leHBvcnRzLnBjMSA9IGZ1bmN0aW9uIHBjMShpbkwsIGluUiwgb3V0LCBvZmYpIHtcbiAgdmFyIG91dEwgPSAwO1xuICB2YXIgb3V0UiA9IDA7XG5cbiAgLy8gNywgMTUsIDIzLCAzMSwgMzksIDQ3LCA1NSwgNjNcbiAgLy8gNiwgMTQsIDIyLCAzMCwgMzksIDQ3LCA1NSwgNjNcbiAgLy8gNSwgMTMsIDIxLCAyOSwgMzksIDQ3LCA1NSwgNjNcbiAgLy8gNCwgMTIsIDIwLCAyOFxuICBmb3IgKHZhciBpID0gNzsgaSA+PSA1OyBpLS0pIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgICBvdXRMIDw8PSAxO1xuICAgICAgb3V0TCB8PSAoaW5SID4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgICAgb3V0TCA8PD0gMTtcbiAgICAgIG91dEwgfD0gKGluTCA+PiAoaiArIGkpKSAmIDE7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICBvdXRMIDw8PSAxO1xuICAgIG91dEwgfD0gKGluUiA+PiAoaiArIGkpKSAmIDE7XG4gIH1cblxuICAvLyAxLCA5LCAxNywgMjUsIDMzLCA0MSwgNDksIDU3XG4gIC8vIDIsIDEwLCAxOCwgMjYsIDM0LCA0MiwgNTAsIDU4XG4gIC8vIDMsIDExLCAxOSwgMjcsIDM1LCA0MywgNTEsIDU5XG4gIC8vIDM2LCA0NCwgNTIsIDYwXG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IDM7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IDI0OyBqICs9IDgpIHtcbiAgICAgIG91dFIgPDw9IDE7XG4gICAgICBvdXRSIHw9IChpblIgPj4gKGogKyBpKSkgJiAxO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSAyNDsgaiArPSA4KSB7XG4gICAgICBvdXRSIDw8PSAxO1xuICAgICAgb3V0UiB8PSAoaW5MID4+IChqICsgaSkpICYgMTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaiA9IDA7IGogPD0gMjQ7IGogKz0gOCkge1xuICAgIG91dFIgPDw9IDE7XG4gICAgb3V0UiB8PSAoaW5MID4+IChqICsgaSkpICYgMTtcbiAgfVxuXG4gIG91dFtvZmYgKyAwXSA9IG91dEwgPj4+IDA7XG4gIG91dFtvZmYgKyAxXSA9IG91dFIgPj4+IDA7XG59O1xuXG5leHBvcnRzLnIyOHNobCA9IGZ1bmN0aW9uIHIyOHNobChudW0sIHNoaWZ0KSB7XG4gIHJldHVybiAoKG51bSA8PCBzaGlmdCkgJiAweGZmZmZmZmYpIHwgKG51bSA+Pj4gKDI4IC0gc2hpZnQpKTtcbn07XG5cbnZhciBwYzJ0YWJsZSA9IFtcbiAgLy8gaW5MID0+IG91dExcbiAgMTQsIDExLCAxNywgNCwgMjcsIDIzLCAyNSwgMCxcbiAgMTMsIDIyLCA3LCAxOCwgNSwgOSwgMTYsIDI0LFxuICAyLCAyMCwgMTIsIDIxLCAxLCA4LCAxNSwgMjYsXG5cbiAgLy8gaW5SID0+IG91dFJcbiAgMTUsIDQsIDI1LCAxOSwgOSwgMSwgMjYsIDE2LFxuICA1LCAxMSwgMjMsIDgsIDEyLCA3LCAxNywgMCxcbiAgMjIsIDMsIDEwLCAxNCwgNiwgMjAsIDI3LCAyNFxuXTtcblxuZXhwb3J0cy5wYzIgPSBmdW5jdGlvbiBwYzIoaW5MLCBpblIsIG91dCwgb2ZmKSB7XG4gIHZhciBvdXRMID0gMDtcbiAgdmFyIG91dFIgPSAwO1xuXG4gIHZhciBsZW4gPSBwYzJ0YWJsZS5sZW5ndGggPj4+IDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRMIDw8PSAxO1xuICAgIG91dEwgfD0gKGluTCA+Pj4gcGMydGFibGVbaV0pICYgMHgxO1xuICB9XG4gIGZvciAodmFyIGkgPSBsZW47IGkgPCBwYzJ0YWJsZS5sZW5ndGg7IGkrKykge1xuICAgIG91dFIgPDw9IDE7XG4gICAgb3V0UiB8PSAoaW5SID4+PiBwYzJ0YWJsZVtpXSkgJiAweDE7XG4gIH1cblxuICBvdXRbb2ZmICsgMF0gPSBvdXRMID4+PiAwO1xuICBvdXRbb2ZmICsgMV0gPSBvdXRSID4+PiAwO1xufTtcblxuZXhwb3J0cy5leHBhbmQgPSBmdW5jdGlvbiBleHBhbmQociwgb3V0LCBvZmYpIHtcbiAgdmFyIG91dEwgPSAwO1xuICB2YXIgb3V0UiA9IDA7XG5cbiAgb3V0TCA9ICgociAmIDEpIDw8IDUpIHwgKHIgPj4+IDI3KTtcbiAgZm9yICh2YXIgaSA9IDIzOyBpID49IDE1OyBpIC09IDQpIHtcbiAgICBvdXRMIDw8PSA2O1xuICAgIG91dEwgfD0gKHIgPj4+IGkpICYgMHgzZjtcbiAgfVxuICBmb3IgKHZhciBpID0gMTE7IGkgPj0gMzsgaSAtPSA0KSB7XG4gICAgb3V0UiB8PSAociA+Pj4gaSkgJiAweDNmO1xuICAgIG91dFIgPDw9IDY7XG4gIH1cbiAgb3V0UiB8PSAoKHIgJiAweDFmKSA8PCAxKSB8IChyID4+PiAzMSk7XG5cbiAgb3V0W29mZiArIDBdID0gb3V0TCA+Pj4gMDtcbiAgb3V0W29mZiArIDFdID0gb3V0UiA+Pj4gMDtcbn07XG5cbnZhciBzVGFibGUgPSBbXG4gIDE0LCAwLCA0LCAxNSwgMTMsIDcsIDEsIDQsIDIsIDE0LCAxNSwgMiwgMTEsIDEzLCA4LCAxLFxuICAzLCAxMCwgMTAsIDYsIDYsIDEyLCAxMiwgMTEsIDUsIDksIDksIDUsIDAsIDMsIDcsIDgsXG4gIDQsIDE1LCAxLCAxMiwgMTQsIDgsIDgsIDIsIDEzLCA0LCA2LCA5LCAyLCAxLCAxMSwgNyxcbiAgMTUsIDUsIDEyLCAxMSwgOSwgMywgNywgMTQsIDMsIDEwLCAxMCwgMCwgNSwgNiwgMCwgMTMsXG5cbiAgMTUsIDMsIDEsIDEzLCA4LCA0LCAxNCwgNywgNiwgMTUsIDExLCAyLCAzLCA4LCA0LCAxNCxcbiAgOSwgMTIsIDcsIDAsIDIsIDEsIDEzLCAxMCwgMTIsIDYsIDAsIDksIDUsIDExLCAxMCwgNSxcbiAgMCwgMTMsIDE0LCA4LCA3LCAxMCwgMTEsIDEsIDEwLCAzLCA0LCAxNSwgMTMsIDQsIDEsIDIsXG4gIDUsIDExLCA4LCA2LCAxMiwgNywgNiwgMTIsIDksIDAsIDMsIDUsIDIsIDE0LCAxNSwgOSxcblxuICAxMCwgMTMsIDAsIDcsIDksIDAsIDE0LCA5LCA2LCAzLCAzLCA0LCAxNSwgNiwgNSwgMTAsXG4gIDEsIDIsIDEzLCA4LCAxMiwgNSwgNywgMTQsIDExLCAxMiwgNCwgMTEsIDIsIDE1LCA4LCAxLFxuICAxMywgMSwgNiwgMTAsIDQsIDEzLCA5LCAwLCA4LCA2LCAxNSwgOSwgMywgOCwgMCwgNyxcbiAgMTEsIDQsIDEsIDE1LCAyLCAxNCwgMTIsIDMsIDUsIDExLCAxMCwgNSwgMTQsIDIsIDcsIDEyLFxuXG4gIDcsIDEzLCAxMywgOCwgMTQsIDExLCAzLCA1LCAwLCA2LCA2LCAxNSwgOSwgMCwgMTAsIDMsXG4gIDEsIDQsIDIsIDcsIDgsIDIsIDUsIDEyLCAxMSwgMSwgMTIsIDEwLCA0LCAxNCwgMTUsIDksXG4gIDEwLCAzLCA2LCAxNSwgOSwgMCwgMCwgNiwgMTIsIDEwLCAxMSwgMSwgNywgMTMsIDEzLCA4LFxuICAxNSwgOSwgMSwgNCwgMywgNSwgMTQsIDExLCA1LCAxMiwgMiwgNywgOCwgMiwgNCwgMTQsXG5cbiAgMiwgMTQsIDEyLCAxMSwgNCwgMiwgMSwgMTIsIDcsIDQsIDEwLCA3LCAxMSwgMTMsIDYsIDEsXG4gIDgsIDUsIDUsIDAsIDMsIDE1LCAxNSwgMTAsIDEzLCAzLCAwLCA5LCAxNCwgOCwgOSwgNixcbiAgNCwgMTEsIDIsIDgsIDEsIDEyLCAxMSwgNywgMTAsIDEsIDEzLCAxNCwgNywgMiwgOCwgMTMsXG4gIDE1LCA2LCA5LCAxNSwgMTIsIDAsIDUsIDksIDYsIDEwLCAzLCA0LCAwLCA1LCAxNCwgMyxcblxuICAxMiwgMTAsIDEsIDE1LCAxMCwgNCwgMTUsIDIsIDksIDcsIDIsIDEyLCA2LCA5LCA4LCA1LFxuICAwLCA2LCAxMywgMSwgMywgMTMsIDQsIDE0LCAxNCwgMCwgNywgMTEsIDUsIDMsIDExLCA4LFxuICA5LCA0LCAxNCwgMywgMTUsIDIsIDUsIDEyLCAyLCA5LCA4LCA1LCAxMiwgMTUsIDMsIDEwLFxuICA3LCAxMSwgMCwgMTQsIDQsIDEsIDEwLCA3LCAxLCA2LCAxMywgMCwgMTEsIDgsIDYsIDEzLFxuXG4gIDQsIDEzLCAxMSwgMCwgMiwgMTEsIDE0LCA3LCAxNSwgNCwgMCwgOSwgOCwgMSwgMTMsIDEwLFxuICAzLCAxNCwgMTIsIDMsIDksIDUsIDcsIDEyLCA1LCAyLCAxMCwgMTUsIDYsIDgsIDEsIDYsXG4gIDEsIDYsIDQsIDExLCAxMSwgMTMsIDEzLCA4LCAxMiwgMSwgMywgNCwgNywgMTAsIDE0LCA3LFxuICAxMCwgOSwgMTUsIDUsIDYsIDAsIDgsIDE1LCAwLCAxNCwgNSwgMiwgOSwgMywgMiwgMTIsXG5cbiAgMTMsIDEsIDIsIDE1LCA4LCAxMywgNCwgOCwgNiwgMTAsIDE1LCAzLCAxMSwgNywgMSwgNCxcbiAgMTAsIDEyLCA5LCA1LCAzLCA2LCAxNCwgMTEsIDUsIDAsIDAsIDE0LCAxMiwgOSwgNywgMixcbiAgNywgMiwgMTEsIDEsIDQsIDE0LCAxLCA3LCA5LCA0LCAxMiwgMTAsIDE0LCA4LCAyLCAxMyxcbiAgMCwgMTUsIDYsIDEyLCAxMCwgOSwgMTMsIDAsIDE1LCAzLCAzLCA1LCA1LCA2LCA4LCAxMVxuXTtcblxuZXhwb3J0cy5zdWJzdGl0dXRlID0gZnVuY3Rpb24gc3Vic3RpdHV0ZShpbkwsIGluUikge1xuICB2YXIgb3V0ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICB2YXIgYiA9IChpbkwgPj4+ICgxOCAtIGkgKiA2KSkgJiAweDNmO1xuICAgIHZhciBzYiA9IHNUYWJsZVtpICogMHg0MCArIGJdO1xuXG4gICAgb3V0IDw8PSA0O1xuICAgIG91dCB8PSBzYjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBiID0gKGluUiA+Pj4gKDE4IC0gaSAqIDYpKSAmIDB4M2Y7XG4gICAgdmFyIHNiID0gc1RhYmxlWzQgKiAweDQwICsgaSAqIDB4NDAgKyBiXTtcblxuICAgIG91dCA8PD0gNDtcbiAgICBvdXQgfD0gc2I7XG4gIH1cbiAgcmV0dXJuIG91dCA+Pj4gMDtcbn07XG5cbnZhciBwZXJtdXRlVGFibGUgPSBbXG4gIDE2LCAyNSwgMTIsIDExLCAzLCAyMCwgNCwgMTUsIDMxLCAxNywgOSwgNiwgMjcsIDE0LCAxLCAyMixcbiAgMzAsIDI0LCA4LCAxOCwgMCwgNSwgMjksIDIzLCAxMywgMTksIDIsIDI2LCAxMCwgMjEsIDI4LCA3XG5dO1xuXG5leHBvcnRzLnBlcm11dGUgPSBmdW5jdGlvbiBwZXJtdXRlKG51bSkge1xuICB2YXIgb3V0ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwZXJtdXRlVGFibGUubGVuZ3RoOyBpKyspIHtcbiAgICBvdXQgPDw9IDE7XG4gICAgb3V0IHw9IChudW0gPj4+IHBlcm11dGVUYWJsZVtpXSkgJiAweDE7XG4gIH1cbiAgcmV0dXJuIG91dCA+Pj4gMDtcbn07XG5cbmV4cG9ydHMucGFkU3BsaXQgPSBmdW5jdGlvbiBwYWRTcGxpdChudW0sIHNpemUsIGdyb3VwKSB7XG4gIHZhciBzdHIgPSBudW0udG9TdHJpbmcoMik7XG4gIHdoaWxlIChzdHIubGVuZ3RoIDwgc2l6ZSlcbiAgICBzdHIgPSAnMCcgKyBzdHI7XG5cbiAgdmFyIG91dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkgKz0gZ3JvdXApXG4gICAgb3V0LnB1c2goc3RyLnNsaWNlKGksIGkgKyBncm91cCkpO1xuICByZXR1cm4gb3V0LmpvaW4oJyAnKTtcbn07XG4iLCJ2YXIgZ2VuZXJhdGVQcmltZSA9IHJlcXVpcmUoJy4vbGliL2dlbmVyYXRlUHJpbWUnKVxudmFyIHByaW1lcyA9IHJlcXVpcmUoJy4vbGliL3ByaW1lcy5qc29uJylcblxudmFyIERIID0gcmVxdWlyZSgnLi9saWIvZGgnKVxuXG5mdW5jdGlvbiBnZXREaWZmaWVIZWxsbWFuIChtb2QpIHtcbiAgdmFyIHByaW1lID0gbmV3IEJ1ZmZlcihwcmltZXNbbW9kXS5wcmltZSwgJ2hleCcpXG4gIHZhciBnZW4gPSBuZXcgQnVmZmVyKHByaW1lc1ttb2RdLmdlbiwgJ2hleCcpXG5cbiAgcmV0dXJuIG5ldyBESChwcmltZSwgZ2VuKVxufVxuXG52YXIgRU5DT0RJTkdTID0ge1xuICAnYmluYXJ5JzogdHJ1ZSwgJ2hleCc6IHRydWUsICdiYXNlNjQnOiB0cnVlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURpZmZpZUhlbGxtYW4gKHByaW1lLCBlbmMsIGdlbmVyYXRvciwgZ2VuYykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGVuYykgfHwgRU5DT0RJTkdTW2VuY10gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjcmVhdGVEaWZmaWVIZWxsbWFuKHByaW1lLCAnYmluYXJ5JywgZW5jLCBnZW5lcmF0b3IpXG4gIH1cblxuICBlbmMgPSBlbmMgfHwgJ2JpbmFyeSdcbiAgZ2VuYyA9IGdlbmMgfHwgJ2JpbmFyeSdcbiAgZ2VuZXJhdG9yID0gZ2VuZXJhdG9yIHx8IG5ldyBCdWZmZXIoWzJdKVxuXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGdlbmVyYXRvcikpIHtcbiAgICBnZW5lcmF0b3IgPSBuZXcgQnVmZmVyKGdlbmVyYXRvciwgZ2VuYylcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJpbWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIG5ldyBESChnZW5lcmF0ZVByaW1lKHByaW1lLCBnZW5lcmF0b3IpLCBnZW5lcmF0b3IsIHRydWUpXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwcmltZSkpIHtcbiAgICBwcmltZSA9IG5ldyBCdWZmZXIocHJpbWUsIGVuYylcbiAgfVxuXG4gIHJldHVybiBuZXcgREgocHJpbWUsIGdlbmVyYXRvciwgdHJ1ZSlcbn1cblxuZXhwb3J0cy5EaWZmaWVIZWxsbWFuR3JvdXAgPSBleHBvcnRzLmNyZWF0ZURpZmZpZUhlbGxtYW5Hcm91cCA9IGV4cG9ydHMuZ2V0RGlmZmllSGVsbG1hbiA9IGdldERpZmZpZUhlbGxtYW5cbmV4cG9ydHMuY3JlYXRlRGlmZmllSGVsbG1hbiA9IGV4cG9ydHMuRGlmZmllSGVsbG1hbiA9IGNyZWF0ZURpZmZpZUhlbGxtYW5cbiIsInZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgTWlsbGVyUmFiaW4gPSByZXF1aXJlKCdtaWxsZXItcmFiaW4nKTtcbnZhciBtaWxsZXJSYWJpbiA9IG5ldyBNaWxsZXJSYWJpbigpO1xudmFyIFRXRU5UWUZPVVIgPSBuZXcgQk4oMjQpO1xudmFyIEVMRVZFTiA9IG5ldyBCTigxMSk7XG52YXIgVEVOID0gbmV3IEJOKDEwKTtcbnZhciBUSFJFRSA9IG5ldyBCTigzKTtcbnZhciBTRVZFTiA9IG5ldyBCTig3KTtcbnZhciBwcmltZXMgPSByZXF1aXJlKCcuL2dlbmVyYXRlUHJpbWUnKTtcbnZhciByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IERIO1xuXG5mdW5jdGlvbiBzZXRQdWJsaWNLZXkocHViLCBlbmMpIHtcbiAgZW5jID0gZW5jIHx8ICd1dGY4JztcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocHViKSkge1xuICAgIHB1YiA9IG5ldyBCdWZmZXIocHViLCBlbmMpO1xuICB9XG4gIHRoaXMuX3B1YiA9IG5ldyBCTihwdWIpO1xuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gc2V0UHJpdmF0ZUtleShwcml2LCBlbmMpIHtcbiAgZW5jID0gZW5jIHx8ICd1dGY4JztcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocHJpdikpIHtcbiAgICBwcml2ID0gbmV3IEJ1ZmZlcihwcml2LCBlbmMpO1xuICB9XG4gIHRoaXMuX3ByaXYgPSBuZXcgQk4ocHJpdik7XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJpbWVDYWNoZSA9IHt9O1xuZnVuY3Rpb24gY2hlY2tQcmltZShwcmltZSwgZ2VuZXJhdG9yKSB7XG4gIHZhciBnZW4gPSBnZW5lcmF0b3IudG9TdHJpbmcoJ2hleCcpO1xuICB2YXIgaGV4ID0gW2dlbiwgcHJpbWUudG9TdHJpbmcoMTYpXS5qb2luKCdfJyk7XG4gIGlmIChoZXggaW4gcHJpbWVDYWNoZSkge1xuICAgIHJldHVybiBwcmltZUNhY2hlW2hleF07XG4gIH1cbiAgdmFyIGVycm9yID0gMDtcblxuICBpZiAocHJpbWUuaXNFdmVuKCkgfHxcbiAgICAhcHJpbWVzLnNpbXBsZVNpZXZlIHx8XG4gICAgIXByaW1lcy5mZXJtYXRUZXN0KHByaW1lKSB8fFxuICAgICFtaWxsZXJSYWJpbi50ZXN0KHByaW1lKSkge1xuICAgIC8vbm90IGEgcHJpbWUgc28gKzFcbiAgICBlcnJvciArPSAxO1xuXG4gICAgaWYgKGdlbiA9PT0gJzAyJyB8fCBnZW4gPT09ICcwNScpIHtcbiAgICAgIC8vIHdlJ2QgYmUgYWJsZSB0byBjaGVjayB0aGUgZ2VuZXJhdG9yXG4gICAgICAvLyBpdCB3b3VsZCBmYWlsIHNvICs4XG4gICAgICBlcnJvciArPSA4O1xuICAgIH0gZWxzZSB7XG4gICAgICAvL3dlIHdvdWxkbid0IGJlIGFibGUgdG8gdGVzdCB0aGUgZ2VuZXJhdG9yXG4gICAgICAvLyBzbyArNFxuICAgICAgZXJyb3IgKz0gNDtcbiAgICB9XG4gICAgcHJpbWVDYWNoZVtoZXhdID0gZXJyb3I7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGlmICghbWlsbGVyUmFiaW4udGVzdChwcmltZS5zaHJuKDEpKSkge1xuICAgIC8vbm90IGEgc2FmZSBwcmltZVxuICAgIGVycm9yICs9IDI7XG4gIH1cbiAgdmFyIHJlbTtcbiAgc3dpdGNoIChnZW4pIHtcbiAgICBjYXNlICcwMic6XG4gICAgICBpZiAocHJpbWUubW9kKFRXRU5UWUZPVVIpLmNtcChFTEVWRU4pKSB7XG4gICAgICAgIC8vIHVuc3VpZGFibGUgZ2VuZXJhdG9yXG4gICAgICAgIGVycm9yICs9IDg7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICcwNSc6XG4gICAgICByZW0gPSBwcmltZS5tb2QoVEVOKTtcbiAgICAgIGlmIChyZW0uY21wKFRIUkVFKSAmJiByZW0uY21wKFNFVkVOKSkge1xuICAgICAgICAvLyBwcmltZSBtb2QgMTAgbmVlZHMgdG8gZXF1YWwgMyBvciA3XG4gICAgICAgIGVycm9yICs9IDg7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZXJyb3IgKz0gNDtcbiAgfVxuICBwcmltZUNhY2hlW2hleF0gPSBlcnJvcjtcbiAgcmV0dXJuIGVycm9yO1xufVxuXG5mdW5jdGlvbiBESChwcmltZSwgZ2VuZXJhdG9yLCBtYWxsZWFibGUpIHtcbiAgdGhpcy5zZXRHZW5lcmF0b3IoZ2VuZXJhdG9yKTtcbiAgdGhpcy5fX3ByaW1lID0gbmV3IEJOKHByaW1lKTtcbiAgdGhpcy5fcHJpbWUgPSBCTi5tb250KHRoaXMuX19wcmltZSk7XG4gIHRoaXMuX3ByaW1lTGVuID0gcHJpbWUubGVuZ3RoO1xuICB0aGlzLl9wdWIgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3ByaXYgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3ByaW1lQ29kZSA9IHVuZGVmaW5lZDtcbiAgaWYgKG1hbGxlYWJsZSkge1xuICAgIHRoaXMuc2V0UHVibGljS2V5ID0gc2V0UHVibGljS2V5O1xuICAgIHRoaXMuc2V0UHJpdmF0ZUtleSA9IHNldFByaXZhdGVLZXk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fcHJpbWVDb2RlID0gODtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERILnByb3RvdHlwZSwgJ3ZlcmlmeUVycm9yJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX3ByaW1lQ29kZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuX3ByaW1lQ29kZSA9IGNoZWNrUHJpbWUodGhpcy5fX3ByaW1lLCB0aGlzLl9fZ2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ByaW1lQ29kZTtcbiAgfVxufSk7XG5ESC5wcm90b3R5cGUuZ2VuZXJhdGVLZXlzID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuX3ByaXYpIHtcbiAgICB0aGlzLl9wcml2ID0gbmV3IEJOKHJhbmRvbUJ5dGVzKHRoaXMuX3ByaW1lTGVuKSk7XG4gIH1cbiAgdGhpcy5fcHViID0gdGhpcy5fZ2VuLnRvUmVkKHRoaXMuX3ByaW1lKS5yZWRQb3codGhpcy5fcHJpdikuZnJvbVJlZCgpO1xuICByZXR1cm4gdGhpcy5nZXRQdWJsaWNLZXkoKTtcbn07XG5cbkRILnByb3RvdHlwZS5jb21wdXRlU2VjcmV0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIG90aGVyID0gbmV3IEJOKG90aGVyKTtcbiAgb3RoZXIgPSBvdGhlci50b1JlZCh0aGlzLl9wcmltZSk7XG4gIHZhciBzZWNyZXQgPSBvdGhlci5yZWRQb3codGhpcy5fcHJpdikuZnJvbVJlZCgpO1xuICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcihzZWNyZXQudG9BcnJheSgpKTtcbiAgdmFyIHByaW1lID0gdGhpcy5nZXRQcmltZSgpO1xuICBpZiAob3V0Lmxlbmd0aCA8IHByaW1lLmxlbmd0aCkge1xuICAgIHZhciBmcm9udCA9IG5ldyBCdWZmZXIocHJpbWUubGVuZ3RoIC0gb3V0Lmxlbmd0aCk7XG4gICAgZnJvbnQuZmlsbCgwKTtcbiAgICBvdXQgPSBCdWZmZXIuY29uY2F0KFtmcm9udCwgb3V0XSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbkRILnByb3RvdHlwZS5nZXRQdWJsaWNLZXkgPSBmdW5jdGlvbiBnZXRQdWJsaWNLZXkoZW5jKSB7XG4gIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZSh0aGlzLl9wdWIsIGVuYyk7XG59O1xuXG5ESC5wcm90b3R5cGUuZ2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uIGdldFByaXZhdGVLZXkoZW5jKSB7XG4gIHJldHVybiBmb3JtYXRSZXR1cm5WYWx1ZSh0aGlzLl9wcml2LCBlbmMpO1xufTtcblxuREgucHJvdG90eXBlLmdldFByaW1lID0gZnVuY3Rpb24gKGVuYykge1xuICByZXR1cm4gZm9ybWF0UmV0dXJuVmFsdWUodGhpcy5fX3ByaW1lLCBlbmMpO1xufTtcblxuREgucHJvdG90eXBlLmdldEdlbmVyYXRvciA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgcmV0dXJuIGZvcm1hdFJldHVyblZhbHVlKHRoaXMuX2dlbiwgZW5jKTtcbn07XG5cbkRILnByb3RvdHlwZS5zZXRHZW5lcmF0b3IgPSBmdW5jdGlvbiAoZ2VuLCBlbmMpIHtcbiAgZW5jID0gZW5jIHx8ICd1dGY4JztcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZ2VuKSkge1xuICAgIGdlbiA9IG5ldyBCdWZmZXIoZ2VuLCBlbmMpO1xuICB9XG4gIHRoaXMuX19nZW4gPSBnZW47XG4gIHRoaXMuX2dlbiA9IG5ldyBCTihnZW4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZvcm1hdFJldHVyblZhbHVlKGJuLCBlbmMpIHtcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoYm4udG9BcnJheSgpKTtcbiAgaWYgKCFlbmMpIHtcbiAgICByZXR1cm4gYnVmO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWYudG9TdHJpbmcoZW5jKTtcbiAgfVxufVxuIiwidmFyIHJhbmRvbUJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZmluZFByaW1lO1xuZmluZFByaW1lLnNpbXBsZVNpZXZlID0gc2ltcGxlU2lldmU7XG5maW5kUHJpbWUuZmVybWF0VGVzdCA9IGZlcm1hdFRlc3Q7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIFRXRU5UWUZPVVIgPSBuZXcgQk4oMjQpO1xudmFyIE1pbGxlclJhYmluID0gcmVxdWlyZSgnbWlsbGVyLXJhYmluJyk7XG52YXIgbWlsbGVyUmFiaW4gPSBuZXcgTWlsbGVyUmFiaW4oKTtcbnZhciBPTkUgPSBuZXcgQk4oMSk7XG52YXIgVFdPID0gbmV3IEJOKDIpO1xudmFyIEZJVkUgPSBuZXcgQk4oNSk7XG52YXIgU0lYVEVFTiA9IG5ldyBCTigxNik7XG52YXIgRUlHSFQgPSBuZXcgQk4oOCk7XG52YXIgVEVOID0gbmV3IEJOKDEwKTtcbnZhciBUSFJFRSA9IG5ldyBCTigzKTtcbnZhciBTRVZFTiA9IG5ldyBCTig3KTtcbnZhciBFTEVWRU4gPSBuZXcgQk4oMTEpO1xudmFyIEZPVVIgPSBuZXcgQk4oNCk7XG52YXIgVFdFTFZFID0gbmV3IEJOKDEyKTtcbnZhciBwcmltZXMgPSBudWxsO1xuXG5mdW5jdGlvbiBfZ2V0UHJpbWVzKCkge1xuICBpZiAocHJpbWVzICE9PSBudWxsKVxuICAgIHJldHVybiBwcmltZXM7XG5cbiAgdmFyIGxpbWl0ID0gMHgxMDAwMDA7XG4gIHZhciByZXMgPSBbXTtcbiAgcmVzWzBdID0gMjtcbiAgZm9yICh2YXIgaSA9IDEsIGsgPSAzOyBrIDwgbGltaXQ7IGsgKz0gMikge1xuICAgIHZhciBzcXJ0ID0gTWF0aC5jZWlsKE1hdGguc3FydChrKSk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBpICYmIHJlc1tqXSA8PSBzcXJ0OyBqKyspXG4gICAgICBpZiAoayAlIHJlc1tqXSA9PT0gMClcbiAgICAgICAgYnJlYWs7XG5cbiAgICBpZiAoaSAhPT0gaiAmJiByZXNbal0gPD0gc3FydClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgcmVzW2krK10gPSBrO1xuICB9XG4gIHByaW1lcyA9IHJlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gc2ltcGxlU2lldmUocCkge1xuICB2YXIgcHJpbWVzID0gX2dldFByaW1lcygpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpbWVzLmxlbmd0aDsgaSsrKVxuICAgIGlmIChwLm1vZG4ocHJpbWVzW2ldKSA9PT0gMCkge1xuICAgICAgaWYgKHAuY21wbihwcmltZXNbaV0pID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZmVybWF0VGVzdChwKSB7XG4gIHZhciByZWQgPSBCTi5tb250KHApO1xuICByZXR1cm4gVFdPLnRvUmVkKHJlZCkucmVkUG93KHAuc3VibigxKSkuZnJvbVJlZCgpLmNtcG4oMSkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmltZShiaXRzLCBnZW4pIHtcbiAgaWYgKGJpdHMgPCAxNikge1xuICAgIC8vIHRoaXMgaXMgd2hhdCBvcGVuc3NsIGRvZXNcbiAgICBpZiAoZ2VuID09PSAyIHx8IGdlbiA9PT0gNSkge1xuICAgICAgcmV0dXJuIG5ldyBCTihbMHg4YywgMHg3Yl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IEJOKFsweDhjLCAweDI3XSk7XG4gICAgfVxuICB9XG4gIGdlbiA9IG5ldyBCTihnZW4pO1xuXG4gIHZhciBudW0sIG4yO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgbnVtID0gbmV3IEJOKHJhbmRvbUJ5dGVzKE1hdGguY2VpbChiaXRzIC8gOCkpKTtcbiAgICB3aGlsZSAobnVtLmJpdExlbmd0aCgpID4gYml0cykge1xuICAgICAgbnVtLmlzaHJuKDEpO1xuICAgIH1cbiAgICBpZiAobnVtLmlzRXZlbigpKSB7XG4gICAgICBudW0uaWFkZChPTkUpO1xuICAgIH1cbiAgICBpZiAoIW51bS50ZXN0bigxKSkge1xuICAgICAgbnVtLmlhZGQoVFdPKTtcbiAgICB9XG4gICAgaWYgKCFnZW4uY21wKFRXTykpIHtcbiAgICAgIHdoaWxlIChudW0ubW9kKFRXRU5UWUZPVVIpLmNtcChFTEVWRU4pKSB7XG4gICAgICAgIG51bS5pYWRkKEZPVVIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWdlbi5jbXAoRklWRSkpIHtcbiAgICAgIHdoaWxlIChudW0ubW9kKFRFTikuY21wKFRIUkVFKSkge1xuICAgICAgICBudW0uaWFkZChGT1VSKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbjIgPSBudW0uc2hybigxKTtcbiAgICBpZiAoc2ltcGxlU2lldmUobjIpICYmIHNpbXBsZVNpZXZlKG51bSkgJiZcbiAgICAgIGZlcm1hdFRlc3QobjIpICYmIGZlcm1hdFRlc3QobnVtKSAmJlxuICAgICAgbWlsbGVyUmFiaW4udGVzdChuMikgJiYgbWlsbGVyUmFiaW4udGVzdChudW0pKSB7XG4gICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgfVxuXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbGxpcHRpYyA9IGV4cG9ydHM7XG5cbmVsbGlwdGljLnZlcnNpb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuZWxsaXB0aWMudXRpbHMgPSByZXF1aXJlKCcuL2VsbGlwdGljL3V0aWxzJyk7XG5lbGxpcHRpYy5yYW5kID0gcmVxdWlyZSgnYnJvcmFuZCcpO1xuZWxsaXB0aWMuY3VydmUgPSByZXF1aXJlKCcuL2VsbGlwdGljL2N1cnZlJyk7XG5lbGxpcHRpYy5jdXJ2ZXMgPSByZXF1aXJlKCcuL2VsbGlwdGljL2N1cnZlcycpO1xuXG4vLyBQcm90b2NvbHNcbmVsbGlwdGljLmVjID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9lYycpO1xuZWxsaXB0aWMuZWRkc2EgPSByZXF1aXJlKCcuL2VsbGlwdGljL2VkZHNhJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG52YXIgZ2V0TkFGID0gdXRpbHMuZ2V0TkFGO1xudmFyIGdldEpTRiA9IHV0aWxzLmdldEpTRjtcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIEJhc2VDdXJ2ZSh0eXBlLCBjb25mKSB7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMucCA9IG5ldyBCTihjb25mLnAsIDE2KTtcblxuICAvLyBVc2UgTW9udGdvbWVyeSwgd2hlbiB0aGVyZSBpcyBubyBmYXN0IHJlZHVjdGlvbiBmb3IgdGhlIHByaW1lXG4gIHRoaXMucmVkID0gY29uZi5wcmltZSA/IEJOLnJlZChjb25mLnByaW1lKSA6IEJOLm1vbnQodGhpcy5wKTtcblxuICAvLyBVc2VmdWwgZm9yIG1hbnkgY3VydmVzXG4gIHRoaXMuemVybyA9IG5ldyBCTigwKS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMub25lID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy50d28gPSBuZXcgQk4oMikudG9SZWQodGhpcy5yZWQpO1xuXG4gIC8vIEN1cnZlIGNvbmZpZ3VyYXRpb24sIG9wdGlvbmFsXG4gIHRoaXMubiA9IGNvbmYubiAmJiBuZXcgQk4oY29uZi5uLCAxNik7XG4gIHRoaXMuZyA9IGNvbmYuZyAmJiB0aGlzLnBvaW50RnJvbUpTT04oY29uZi5nLCBjb25mLmdSZWQpO1xuXG4gIC8vIFRlbXBvcmFyeSBhcnJheXNcbiAgdGhpcy5fd25hZlQxID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl93bmFmVDIgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX3duYWZUMyA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fd25hZlQ0ID0gbmV3IEFycmF5KDQpO1xuXG4gIC8vIEdlbmVyYWxpemVkIEdyZWcgTWF4d2VsbCdzIHRyaWNrXG4gIHZhciBhZGp1c3RDb3VudCA9IHRoaXMubiAmJiB0aGlzLnAuZGl2KHRoaXMubik7XG4gIGlmICghYWRqdXN0Q291bnQgfHwgYWRqdXN0Q291bnQuY21wbigxMDApID4gMCkge1xuICAgIHRoaXMucmVkTiA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fbWF4d2VsbFRyaWNrID0gdHJ1ZTtcbiAgICB0aGlzLnJlZE4gPSB0aGlzLm4udG9SZWQodGhpcy5yZWQpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VDdXJ2ZTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5fZml4ZWROYWZNdWwgPSBmdW5jdGlvbiBfZml4ZWROYWZNdWwocCwgaykge1xuICBhc3NlcnQocC5wcmVjb21wdXRlZCk7XG4gIHZhciBkb3VibGVzID0gcC5fZ2V0RG91YmxlcygpO1xuXG4gIHZhciBuYWYgPSBnZXROQUYoaywgMSk7XG4gIHZhciBJID0gKDEgPDwgKGRvdWJsZXMuc3RlcCArIDEpKSAtIChkb3VibGVzLnN0ZXAgJSAyID09PSAwID8gMiA6IDEpO1xuICBJIC89IDM7XG5cbiAgLy8gVHJhbnNsYXRlIGludG8gbW9yZSB3aW5kb3dlZCBmb3JtXG4gIHZhciByZXByID0gW107XG4gIGZvciAodmFyIGogPSAwOyBqIDwgbmFmLmxlbmd0aDsgaiArPSBkb3VibGVzLnN0ZXApIHtcbiAgICB2YXIgbmFmVyA9IDA7XG4gICAgZm9yICh2YXIgayA9IGogKyBkb3VibGVzLnN0ZXAgLSAxOyBrID49IGo7IGstLSlcbiAgICAgIG5hZlcgPSAobmFmVyA8PCAxKSArIG5hZltrXTtcbiAgICByZXByLnB1c2gobmFmVyk7XG4gIH1cblxuICB2YXIgYSA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICB2YXIgYiA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICBmb3IgKHZhciBpID0gSTsgaSA+IDA7IGktLSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVwci5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIG5hZlcgPSByZXByW2pdO1xuICAgICAgaWYgKG5hZlcgPT09IGkpXG4gICAgICAgIGIgPSBiLm1peGVkQWRkKGRvdWJsZXMucG9pbnRzW2pdKTtcbiAgICAgIGVsc2UgaWYgKG5hZlcgPT09IC1pKVxuICAgICAgICBiID0gYi5taXhlZEFkZChkb3VibGVzLnBvaW50c1tqXS5uZWcoKSk7XG4gICAgfVxuICAgIGEgPSBhLmFkZChiKTtcbiAgfVxuICByZXR1cm4gYS50b1AoKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX3duYWZNdWwgPSBmdW5jdGlvbiBfd25hZk11bChwLCBrKSB7XG4gIHZhciB3ID0gNDtcblxuICAvLyBQcmVjb21wdXRlIHdpbmRvd1xuICB2YXIgbmFmUG9pbnRzID0gcC5fZ2V0TkFGUG9pbnRzKHcpO1xuICB3ID0gbmFmUG9pbnRzLnduZDtcbiAgdmFyIHduZCA9IG5hZlBvaW50cy5wb2ludHM7XG5cbiAgLy8gR2V0IE5BRiBmb3JtXG4gIHZhciBuYWYgPSBnZXROQUYoaywgdyk7XG5cbiAgLy8gQWRkIGB0aGlzYCooTisxKSBmb3IgZXZlcnkgdy1OQUYgaW5kZXhcbiAgdmFyIGFjYyA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICBmb3IgKHZhciBpID0gbmFmLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgLy8gQ291bnQgemVyb2VzXG4gICAgZm9yICh2YXIgayA9IDA7IGkgPj0gMCAmJiBuYWZbaV0gPT09IDA7IGktLSlcbiAgICAgIGsrKztcbiAgICBpZiAoaSA+PSAwKVxuICAgICAgaysrO1xuICAgIGFjYyA9IGFjYy5kYmxwKGspO1xuXG4gICAgaWYgKGkgPCAwKVxuICAgICAgYnJlYWs7XG4gICAgdmFyIHogPSBuYWZbaV07XG4gICAgYXNzZXJ0KHogIT09IDApO1xuICAgIGlmIChwLnR5cGUgPT09ICdhZmZpbmUnKSB7XG4gICAgICAvLyBKICstIFBcbiAgICAgIGlmICh6ID4gMClcbiAgICAgICAgYWNjID0gYWNjLm1peGVkQWRkKHduZFsoeiAtIDEpID4+IDFdKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYWNjID0gYWNjLm1peGVkQWRkKHduZFsoLXogLSAxKSA+PiAxXS5uZWcoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEogKy0gSlxuICAgICAgaWYgKHogPiAwKVxuICAgICAgICBhY2MgPSBhY2MuYWRkKHduZFsoeiAtIDEpID4+IDFdKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYWNjID0gYWNjLmFkZCh3bmRbKC16IC0gMSkgPj4gMV0ubmVnKCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcC50eXBlID09PSAnYWZmaW5lJyA/IGFjYy50b1AoKSA6IGFjYztcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX3duYWZNdWxBZGQgPSBmdW5jdGlvbiBfd25hZk11bEFkZChkZWZXLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2VmZnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGphY29iaWFuUmVzdWx0KSB7XG4gIHZhciB3bmRXaWR0aCA9IHRoaXMuX3duYWZUMTtcbiAgdmFyIHduZCA9IHRoaXMuX3duYWZUMjtcbiAgdmFyIG5hZiA9IHRoaXMuX3duYWZUMztcblxuICAvLyBGaWxsIGFsbCBhcnJheXNcbiAgdmFyIG1heCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgcCA9IHBvaW50c1tpXTtcbiAgICB2YXIgbmFmUG9pbnRzID0gcC5fZ2V0TkFGUG9pbnRzKGRlZlcpO1xuICAgIHduZFdpZHRoW2ldID0gbmFmUG9pbnRzLnduZDtcbiAgICB3bmRbaV0gPSBuYWZQb2ludHMucG9pbnRzO1xuICB9XG5cbiAgLy8gQ29tYiBzbWFsbCB3aW5kb3cgTkFGc1xuICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAxOyBpIC09IDIpIHtcbiAgICB2YXIgYSA9IGkgLSAxO1xuICAgIHZhciBiID0gaTtcbiAgICBpZiAod25kV2lkdGhbYV0gIT09IDEgfHwgd25kV2lkdGhbYl0gIT09IDEpIHtcbiAgICAgIG5hZlthXSA9IGdldE5BRihjb2VmZnNbYV0sIHduZFdpZHRoW2FdKTtcbiAgICAgIG5hZltiXSA9IGdldE5BRihjb2VmZnNbYl0sIHduZFdpZHRoW2JdKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG5hZlthXS5sZW5ndGgsIG1heCk7XG4gICAgICBtYXggPSBNYXRoLm1heChuYWZbYl0ubGVuZ3RoLCBtYXgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGNvbWIgPSBbXG4gICAgICBwb2ludHNbYV0sIC8qIDEgKi9cbiAgICAgIG51bGwsIC8qIDMgKi9cbiAgICAgIG51bGwsIC8qIDUgKi9cbiAgICAgIHBvaW50c1tiXSAvKiA3ICovXG4gICAgXTtcblxuICAgIC8vIFRyeSB0byBhdm9pZCBQcm9qZWN0aXZlIHBvaW50cywgaWYgcG9zc2libGVcbiAgICBpZiAocG9pbnRzW2FdLnkuY21wKHBvaW50c1tiXS55KSA9PT0gMCkge1xuICAgICAgY29tYlsxXSA9IHBvaW50c1thXS5hZGQocG9pbnRzW2JdKTtcbiAgICAgIGNvbWJbMl0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdLm5lZygpKTtcbiAgICB9IGVsc2UgaWYgKHBvaW50c1thXS55LmNtcChwb2ludHNbYl0ueS5yZWROZWcoKSkgPT09IDApIHtcbiAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdKTtcbiAgICAgIGNvbWJbMl0gPSBwb2ludHNbYV0uYWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdKTtcbiAgICAgIGNvbWJbMl0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdLm5lZygpKTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBbXG4gICAgICAtMywgLyogLTEgLTEgKi9cbiAgICAgIC0xLCAvKiAtMSAwICovXG4gICAgICAtNSwgLyogLTEgMSAqL1xuICAgICAgLTcsIC8qIDAgLTEgKi9cbiAgICAgIDAsIC8qIDAgMCAqL1xuICAgICAgNywgLyogMCAxICovXG4gICAgICA1LCAvKiAxIC0xICovXG4gICAgICAxLCAvKiAxIDAgKi9cbiAgICAgIDMgIC8qIDEgMSAqL1xuICAgIF07XG5cbiAgICB2YXIganNmID0gZ2V0SlNGKGNvZWZmc1thXSwgY29lZmZzW2JdKTtcbiAgICBtYXggPSBNYXRoLm1heChqc2ZbMF0ubGVuZ3RoLCBtYXgpO1xuICAgIG5hZlthXSA9IG5ldyBBcnJheShtYXgpO1xuICAgIG5hZltiXSA9IG5ldyBBcnJheShtYXgpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWF4OyBqKyspIHtcbiAgICAgIHZhciBqYSA9IGpzZlswXVtqXSB8IDA7XG4gICAgICB2YXIgamIgPSBqc2ZbMV1bal0gfCAwO1xuXG4gICAgICBuYWZbYV1bal0gPSBpbmRleFsoamEgKyAxKSAqIDMgKyAoamIgKyAxKV07XG4gICAgICBuYWZbYl1bal0gPSAwO1xuICAgICAgd25kW2FdID0gY29tYjtcbiAgICB9XG4gIH1cblxuICB2YXIgYWNjID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIHZhciB0bXAgPSB0aGlzLl93bmFmVDQ7XG4gIGZvciAodmFyIGkgPSBtYXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGsgPSAwO1xuXG4gICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgdmFyIHplcm8gPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgICB0bXBbal0gPSBuYWZbal1baV0gfCAwO1xuICAgICAgICBpZiAodG1wW2pdICE9PSAwKVxuICAgICAgICAgIHplcm8gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghemVybylcbiAgICAgICAgYnJlYWs7XG4gICAgICBrKys7XG4gICAgICBpLS07XG4gICAgfVxuICAgIGlmIChpID49IDApXG4gICAgICBrKys7XG4gICAgYWNjID0gYWNjLmRibHAoayk7XG4gICAgaWYgKGkgPCAwKVxuICAgICAgYnJlYWs7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICB2YXIgeiA9IHRtcFtqXTtcbiAgICAgIHZhciBwO1xuICAgICAgaWYgKHogPT09IDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgZWxzZSBpZiAoeiA+IDApXG4gICAgICAgIHAgPSB3bmRbal1bKHogLSAxKSA+PiAxXTtcbiAgICAgIGVsc2UgaWYgKHogPCAwKVxuICAgICAgICBwID0gd25kW2pdWygteiAtIDEpID4+IDFdLm5lZygpO1xuXG4gICAgICBpZiAocC50eXBlID09PSAnYWZmaW5lJylcbiAgICAgICAgYWNjID0gYWNjLm1peGVkQWRkKHApO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MuYWRkKHApO1xuICAgIH1cbiAgfVxuICAvLyBaZXJvaWZ5IHJlZmVyZW5jZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICB3bmRbaV0gPSBudWxsO1xuXG4gIGlmIChqYWNvYmlhblJlc3VsdClcbiAgICByZXR1cm4gYWNjO1xuICBlbHNlXG4gICAgcmV0dXJuIGFjYy50b1AoKTtcbn07XG5cbmZ1bmN0aW9uIEJhc2VQb2ludChjdXJ2ZSwgdHlwZSkge1xuICB0aGlzLmN1cnZlID0gY3VydmU7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMucHJlY29tcHV0ZWQgPSBudWxsO1xufVxuQmFzZUN1cnZlLkJhc2VQb2ludCA9IEJhc2VQb2ludDtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKC8qb3RoZXIqLykge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS52YWxpZGF0ZSh0aGlzKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuZGVjb2RlUG9pbnQgPSBmdW5jdGlvbiBkZWNvZGVQb2ludChieXRlcywgZW5jKSB7XG4gIGJ5dGVzID0gdXRpbHMudG9BcnJheShieXRlcywgZW5jKTtcblxuICB2YXIgbGVuID0gdGhpcy5wLmJ5dGVMZW5ndGgoKTtcblxuICAvLyB1bmNvbXByZXNzZWQsIGh5YnJpZC1vZGQsIGh5YnJpZC1ldmVuXG4gIGlmICgoYnl0ZXNbMF0gPT09IDB4MDQgfHwgYnl0ZXNbMF0gPT09IDB4MDYgfHwgYnl0ZXNbMF0gPT09IDB4MDcpICYmXG4gICAgICBieXRlcy5sZW5ndGggLSAxID09PSAyICogbGVuKSB7XG4gICAgaWYgKGJ5dGVzWzBdID09PSAweDA2KVxuICAgICAgYXNzZXJ0KGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdICUgMiA9PT0gMCk7XG4gICAgZWxzZSBpZiAoYnl0ZXNbMF0gPT09IDB4MDcpXG4gICAgICBhc3NlcnQoYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gJSAyID09PSAxKTtcblxuICAgIHZhciByZXMgPSAgdGhpcy5wb2ludChieXRlcy5zbGljZSgxLCAxICsgbGVuKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXMuc2xpY2UoMSArIGxlbiwgMSArIDIgKiBsZW4pKTtcblxuICAgIHJldHVybiByZXM7XG4gIH0gZWxzZSBpZiAoKGJ5dGVzWzBdID09PSAweDAyIHx8IGJ5dGVzWzBdID09PSAweDAzKSAmJlxuICAgICAgICAgICAgICBieXRlcy5sZW5ndGggLSAxID09PSBsZW4pIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludEZyb21YKGJ5dGVzLnNsaWNlKDEsIDEgKyBsZW4pLCBieXRlc1swXSA9PT0gMHgwMyk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHBvaW50IGZvcm1hdCcpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5lbmNvZGVDb21wcmVzc2VkID0gZnVuY3Rpb24gZW5jb2RlQ29tcHJlc3NlZChlbmMpIHtcbiAgcmV0dXJuIHRoaXMuZW5jb2RlKGVuYywgdHJ1ZSk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9lbmNvZGUgPSBmdW5jdGlvbiBfZW5jb2RlKGNvbXBhY3QpIHtcbiAgdmFyIGxlbiA9IHRoaXMuY3VydmUucC5ieXRlTGVuZ3RoKCk7XG4gIHZhciB4ID0gdGhpcy5nZXRYKCkudG9BcnJheSgnYmUnLCBsZW4pO1xuXG4gIGlmIChjb21wYWN0KVxuICAgIHJldHVybiBbIHRoaXMuZ2V0WSgpLmlzRXZlbigpID8gMHgwMiA6IDB4MDMgXS5jb25jYXQoeCk7XG5cbiAgcmV0dXJuIFsgMHgwNCBdLmNvbmNhdCh4LCB0aGlzLmdldFkoKS50b0FycmF5KCdiZScsIGxlbikpIDtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGVuYywgY29tcGFjdCkge1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHRoaXMuX2VuY29kZShjb21wYWN0KSwgZW5jKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUucHJlY29tcHV0ZSA9IGZ1bmN0aW9uIHByZWNvbXB1dGUocG93ZXIpIHtcbiAgaWYgKHRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIHByZWNvbXB1dGVkID0ge1xuICAgIGRvdWJsZXM6IG51bGwsXG4gICAgbmFmOiBudWxsLFxuICAgIGJldGE6IG51bGxcbiAgfTtcbiAgcHJlY29tcHV0ZWQubmFmID0gdGhpcy5fZ2V0TkFGUG9pbnRzKDgpO1xuICBwcmVjb21wdXRlZC5kb3VibGVzID0gdGhpcy5fZ2V0RG91Ymxlcyg0LCBwb3dlcik7XG4gIHByZWNvbXB1dGVkLmJldGEgPSB0aGlzLl9nZXRCZXRhKCk7XG4gIHRoaXMucHJlY29tcHV0ZWQgPSBwcmVjb21wdXRlZDtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2hhc0RvdWJsZXMgPSBmdW5jdGlvbiBfaGFzRG91YmxlcyhrKSB7XG4gIGlmICghdGhpcy5wcmVjb21wdXRlZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGRvdWJsZXMgPSB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXM7XG4gIGlmICghZG91YmxlcylcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIGRvdWJsZXMucG9pbnRzLmxlbmd0aCA+PSBNYXRoLmNlaWwoKGsuYml0TGVuZ3RoKCkgKyAxKSAvIGRvdWJsZXMuc3RlcCk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXREb3VibGVzID0gZnVuY3Rpb24gX2dldERvdWJsZXMoc3RlcCwgcG93ZXIpIHtcbiAgaWYgKHRoaXMucHJlY29tcHV0ZWQgJiYgdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzKVxuICAgIHJldHVybiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXM7XG5cbiAgdmFyIGRvdWJsZXMgPSBbIHRoaXMgXTtcbiAgdmFyIGFjYyA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG93ZXI7IGkgKz0gc3RlcCkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RlcDsgaisrKVxuICAgICAgYWNjID0gYWNjLmRibCgpO1xuICAgIGRvdWJsZXMucHVzaChhY2MpO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RlcDogc3RlcCxcbiAgICBwb2ludHM6IGRvdWJsZXNcbiAgfTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2dldE5BRlBvaW50cyA9IGZ1bmN0aW9uIF9nZXROQUZQb2ludHMod25kKSB7XG4gIGlmICh0aGlzLnByZWNvbXB1dGVkICYmIHRoaXMucHJlY29tcHV0ZWQubmFmKVxuICAgIHJldHVybiB0aGlzLnByZWNvbXB1dGVkLm5hZjtcblxuICB2YXIgcmVzID0gWyB0aGlzIF07XG4gIHZhciBtYXggPSAoMSA8PCB3bmQpIC0gMTtcbiAgdmFyIGRibCA9IG1heCA9PT0gMSA/IG51bGwgOiB0aGlzLmRibCgpO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IG1heDsgaSsrKVxuICAgIHJlc1tpXSA9IHJlc1tpIC0gMV0uYWRkKGRibCk7XG4gIHJldHVybiB7XG4gICAgd25kOiB3bmQsXG4gICAgcG9pbnRzOiByZXNcbiAgfTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2dldEJldGEgPSBmdW5jdGlvbiBfZ2V0QmV0YSgpIHtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmRibHAgPSBmdW5jdGlvbiBkYmxwKGspIHtcbiAgdmFyIHIgPSB0aGlzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGs7IGkrKylcbiAgICByID0gci5kYmwoKTtcbiAgcmV0dXJuIHI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VydmUgPSByZXF1aXJlKCcuLi9jdXJ2ZScpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIEJhc2UgPSBjdXJ2ZS5iYXNlO1xuXG52YXIgYXNzZXJ0ID0gZWxsaXB0aWMudXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBFZHdhcmRzQ3VydmUoY29uZikge1xuICAvLyBOT1RFOiBJbXBvcnRhbnQgYXMgd2UgYXJlIGNyZWF0aW5nIHBvaW50IGluIEJhc2UuY2FsbCgpXG4gIHRoaXMudHdpc3RlZCA9IChjb25mLmEgfCAwKSAhPT0gMTtcbiAgdGhpcy5tT25lQSA9IHRoaXMudHdpc3RlZCAmJiAoY29uZi5hIHwgMCkgPT09IC0xO1xuICB0aGlzLmV4dGVuZGVkID0gdGhpcy5tT25lQTtcblxuICBCYXNlLmNhbGwodGhpcywgJ2Vkd2FyZHMnLCBjb25mKTtcblxuICB0aGlzLmEgPSBuZXcgQk4oY29uZi5hLCAxNikudW1vZCh0aGlzLnJlZC5tKTtcbiAgdGhpcy5hID0gdGhpcy5hLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5jID0gbmV3IEJOKGNvbmYuYywgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5jMiA9IHRoaXMuYy5yZWRTcXIoKTtcbiAgdGhpcy5kID0gbmV3IEJOKGNvbmYuZCwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5kZCA9IHRoaXMuZC5yZWRBZGQodGhpcy5kKTtcblxuICBhc3NlcnQoIXRoaXMudHdpc3RlZCB8fCB0aGlzLmMuZnJvbVJlZCgpLmNtcG4oMSkgPT09IDApO1xuICB0aGlzLm9uZUMgPSAoY29uZi5jIHwgMCkgPT09IDE7XG59XG5pbmhlcml0cyhFZHdhcmRzQ3VydmUsIEJhc2UpO1xubW9kdWxlLmV4cG9ydHMgPSBFZHdhcmRzQ3VydmU7XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUuX211bEEgPSBmdW5jdGlvbiBfbXVsQShudW0pIHtcbiAgaWYgKHRoaXMubU9uZUEpXG4gICAgcmV0dXJuIG51bS5yZWROZWcoKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmEucmVkTXVsKG51bSk7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLl9tdWxDID0gZnVuY3Rpb24gX211bEMobnVtKSB7XG4gIGlmICh0aGlzLm9uZUMpXG4gICAgcmV0dXJuIG51bTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmMucmVkTXVsKG51bSk7XG59O1xuXG4vLyBKdXN0IGZvciBjb21wYXRpYmlsaXR5IHdpdGggU2hvcnQgY3VydmVcbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUuanBvaW50ID0gZnVuY3Rpb24ganBvaW50KHgsIHksIHosIHQpIHtcbiAgcmV0dXJuIHRoaXMucG9pbnQoeCwgeSwgeiwgdCk7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnBvaW50RnJvbVggPSBmdW5jdGlvbiBwb2ludEZyb21YKHgsIG9kZCkge1xuICB4ID0gbmV3IEJOKHgsIDE2KTtcbiAgaWYgKCF4LnJlZClcbiAgICB4ID0geC50b1JlZCh0aGlzLnJlZCk7XG5cbiAgdmFyIHgyID0geC5yZWRTcXIoKTtcbiAgdmFyIHJocyA9IHRoaXMuYzIucmVkU3ViKHRoaXMuYS5yZWRNdWwoeDIpKTtcbiAgdmFyIGxocyA9IHRoaXMub25lLnJlZFN1Yih0aGlzLmMyLnJlZE11bCh0aGlzLmQpLnJlZE11bCh4MikpO1xuXG4gIHZhciB5MiA9IHJocy5yZWRNdWwobGhzLnJlZEludm0oKSk7XG4gIHZhciB5ID0geTIucmVkU3FydCgpO1xuICBpZiAoeS5yZWRTcXIoKS5yZWRTdWIoeTIpLmNtcCh0aGlzLnplcm8pICE9PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCcpO1xuXG4gIHZhciBpc09kZCA9IHkuZnJvbVJlZCgpLmlzT2RkKCk7XG4gIGlmIChvZGQgJiYgIWlzT2RkIHx8ICFvZGQgJiYgaXNPZGQpXG4gICAgeSA9IHkucmVkTmVnKCk7XG5cbiAgcmV0dXJuIHRoaXMucG9pbnQoeCwgeSk7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnBvaW50RnJvbVkgPSBmdW5jdGlvbiBwb2ludEZyb21ZKHksIG9kZCkge1xuICB5ID0gbmV3IEJOKHksIDE2KTtcbiAgaWYgKCF5LnJlZClcbiAgICB5ID0geS50b1JlZCh0aGlzLnJlZCk7XG5cbiAgLy8geF4yID0gKHleMiAtIGNeMikgLyAoY14yIGQgeV4yIC0gYSlcbiAgdmFyIHkyID0geS5yZWRTcXIoKTtcbiAgdmFyIGxocyA9IHkyLnJlZFN1Yih0aGlzLmMyKTtcbiAgdmFyIHJocyA9IHkyLnJlZE11bCh0aGlzLmQpLnJlZE11bCh0aGlzLmMyKS5yZWRTdWIodGhpcy5hKTtcbiAgdmFyIHgyID0gbGhzLnJlZE11bChyaHMucmVkSW52bSgpKTtcblxuICBpZiAoeDIuY21wKHRoaXMuemVybykgPT09IDApIHtcbiAgICBpZiAob2RkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMucG9pbnQodGhpcy56ZXJvLCB5KTtcbiAgfVxuXG4gIHZhciB4ID0geDIucmVkU3FydCgpO1xuICBpZiAoeC5yZWRTcXIoKS5yZWRTdWIoeDIpLmNtcCh0aGlzLnplcm8pICE9PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCcpO1xuXG4gIGlmICh4LmZyb21SZWQoKS5pc09kZCgpICE9PSBvZGQpXG4gICAgeCA9IHgucmVkTmVnKCk7XG5cbiAgcmV0dXJuIHRoaXMucG9pbnQoeCwgeSk7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUocG9pbnQpIHtcbiAgaWYgKHBvaW50LmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyBDdXJ2ZTogQSAqIFheMiArIFleMiA9IENeMiAqICgxICsgRCAqIFheMiAqIFleMilcbiAgcG9pbnQubm9ybWFsaXplKCk7XG5cbiAgdmFyIHgyID0gcG9pbnQueC5yZWRTcXIoKTtcbiAgdmFyIHkyID0gcG9pbnQueS5yZWRTcXIoKTtcbiAgdmFyIGxocyA9IHgyLnJlZE11bCh0aGlzLmEpLnJlZEFkZCh5Mik7XG4gIHZhciByaHMgPSB0aGlzLmMyLnJlZE11bCh0aGlzLm9uZS5yZWRBZGQodGhpcy5kLnJlZE11bCh4MikucmVkTXVsKHkyKSkpO1xuXG4gIHJldHVybiBsaHMuY21wKHJocykgPT09IDA7XG59O1xuXG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeSwgeiwgdCkge1xuICBCYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAncHJvamVjdGl2ZScpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsICYmIHogPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSB0aGlzLmN1cnZlLnplcm87XG4gICAgdGhpcy55ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy56ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy50ID0gdGhpcy5jdXJ2ZS56ZXJvO1xuICAgIHRoaXMuek9uZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IEJOKHgsIDE2KTtcbiAgICB0aGlzLnkgPSBuZXcgQk4oeSwgMTYpO1xuICAgIHRoaXMueiA9IHogPyBuZXcgQk4oeiwgMTYpIDogdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy50ID0gdCAmJiBuZXcgQk4odCwgMTYpO1xuICAgIGlmICghdGhpcy54LnJlZClcbiAgICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnkucmVkKVxuICAgICAgdGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICBpZiAoIXRoaXMuei5yZWQpXG4gICAgICB0aGlzLnogPSB0aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICh0aGlzLnQgJiYgIXRoaXMudC5yZWQpXG4gICAgICB0aGlzLnQgPSB0aGlzLnQudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIHRoaXMuek9uZSA9IHRoaXMueiA9PT0gdGhpcy5jdXJ2ZS5vbmU7XG5cbiAgICAvLyBVc2UgZXh0ZW5kZWQgY29vcmRpbmF0ZXNcbiAgICBpZiAodGhpcy5jdXJ2ZS5leHRlbmRlZCAmJiAhdGhpcy50KSB7XG4gICAgICB0aGlzLnQgPSB0aGlzLngucmVkTXVsKHRoaXMueSk7XG4gICAgICBpZiAoIXRoaXMuek9uZSlcbiAgICAgICAgdGhpcy50ID0gdGhpcy50LnJlZE11bCh0aGlzLnoucmVkSW52bSgpKTtcbiAgICB9XG4gIH1cbn1cbmluaGVyaXRzKFBvaW50LCBCYXNlLkJhc2VQb2ludCk7XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTiA9IGZ1bmN0aW9uIHBvaW50RnJvbUpTT04ob2JqKSB7XG4gIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmopO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KHgsIHksIHosIHQpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLCB4LCB5LCB6LCB0KTtcbn07XG5cblBvaW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsIG9iaikge1xuICByZXR1cm4gbmV3IFBvaW50KGN1cnZlLCBvYmpbMF0sIG9ialsxXSwgb2JqWzJdKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIFBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIFBvaW50IHg6ICcgKyB0aGlzLnguZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkuZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHo6ICcgKyB0aGlzLnouZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgLy8gWFhYIFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgemVybyBpcyBhbHdheXMgemVybyBpbiByZWRcbiAgcmV0dXJuIHRoaXMueC5jbXBuKDApID09PSAwICYmXG4gICAgKHRoaXMueS5jbXAodGhpcy56KSA9PT0gMCB8fFxuICAgICh0aGlzLnpPbmUgJiYgdGhpcy55LmNtcCh0aGlzLmN1cnZlLmMpID09PSAwKSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2V4dERibCA9IGZ1bmN0aW9uIF9leHREYmwoKSB7XG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLTEuaHRtbFxuICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA4LWh3Y2RcbiAgLy8gNE0gKyA0U1xuXG4gIC8vIEEgPSBYMV4yXG4gIHZhciBhID0gdGhpcy54LnJlZFNxcigpO1xuICAvLyBCID0gWTFeMlxuICB2YXIgYiA9IHRoaXMueS5yZWRTcXIoKTtcbiAgLy8gQyA9IDIgKiBaMV4yXG4gIHZhciBjID0gdGhpcy56LnJlZFNxcigpO1xuICBjID0gYy5yZWRJQWRkKGMpO1xuICAvLyBEID0gYSAqIEFcbiAgdmFyIGQgPSB0aGlzLmN1cnZlLl9tdWxBKGEpO1xuICAvLyBFID0gKFgxICsgWTEpXjIgLSBBIC0gQlxuICB2YXIgZSA9IHRoaXMueC5yZWRBZGQodGhpcy55KS5yZWRTcXIoKS5yZWRJU3ViKGEpLnJlZElTdWIoYik7XG4gIC8vIEcgPSBEICsgQlxuICB2YXIgZyA9IGQucmVkQWRkKGIpO1xuICAvLyBGID0gRyAtIENcbiAgdmFyIGYgPSBnLnJlZFN1YihjKTtcbiAgLy8gSCA9IEQgLSBCXG4gIHZhciBoID0gZC5yZWRTdWIoYik7XG4gIC8vIFgzID0gRSAqIEZcbiAgdmFyIG54ID0gZS5yZWRNdWwoZik7XG4gIC8vIFkzID0gRyAqIEhcbiAgdmFyIG55ID0gZy5yZWRNdWwoaCk7XG4gIC8vIFQzID0gRSAqIEhcbiAgdmFyIG50ID0gZS5yZWRNdWwoaCk7XG4gIC8vIFozID0gRiAqIEdcbiAgdmFyIG56ID0gZi5yZWRNdWwoZyk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnosIG50KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fcHJvakRibCA9IGZ1bmN0aW9uIF9wcm9qRGJsKCkge1xuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1wcm9qZWN0aXZlLmh0bWxcbiAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwOC1iYmpscFxuICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA3LWJsXG4gIC8vIGFuZCBvdGhlcnNcbiAgLy8gR2VuZXJhbGx5IDNNICsgNFMgb3IgMk0gKyA0U1xuXG4gIC8vIEIgPSAoWDEgKyBZMSleMlxuICB2YXIgYiA9IHRoaXMueC5yZWRBZGQodGhpcy55KS5yZWRTcXIoKTtcbiAgLy8gQyA9IFgxXjJcbiAgdmFyIGMgPSB0aGlzLngucmVkU3FyKCk7XG4gIC8vIEQgPSBZMV4yXG4gIHZhciBkID0gdGhpcy55LnJlZFNxcigpO1xuXG4gIHZhciBueDtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIGlmICh0aGlzLmN1cnZlLnR3aXN0ZWQpIHtcbiAgICAvLyBFID0gYSAqIENcbiAgICB2YXIgZSA9IHRoaXMuY3VydmUuX211bEEoYyk7XG4gICAgLy8gRiA9IEUgKyBEXG4gICAgdmFyIGYgPSBlLnJlZEFkZChkKTtcbiAgICBpZiAodGhpcy56T25lKSB7XG4gICAgICAvLyBYMyA9IChCIC0gQyAtIEQpICogKEYgLSAyKVxuICAgICAgbnggPSBiLnJlZFN1YihjKS5yZWRTdWIoZCkucmVkTXVsKGYucmVkU3ViKHRoaXMuY3VydmUudHdvKSk7XG4gICAgICAvLyBZMyA9IEYgKiAoRSAtIEQpXG4gICAgICBueSA9IGYucmVkTXVsKGUucmVkU3ViKGQpKTtcbiAgICAgIC8vIFozID0gRl4yIC0gMiAqIEZcbiAgICAgIG56ID0gZi5yZWRTcXIoKS5yZWRTdWIoZikucmVkU3ViKGYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBIID0gWjFeMlxuICAgICAgdmFyIGggPSB0aGlzLnoucmVkU3FyKCk7XG4gICAgICAvLyBKID0gRiAtIDIgKiBIXG4gICAgICB2YXIgaiA9IGYucmVkU3ViKGgpLnJlZElTdWIoaCk7XG4gICAgICAvLyBYMyA9IChCLUMtRCkqSlxuICAgICAgbnggPSBiLnJlZFN1YihjKS5yZWRJU3ViKGQpLnJlZE11bChqKTtcbiAgICAgIC8vIFkzID0gRiAqIChFIC0gRClcbiAgICAgIG55ID0gZi5yZWRNdWwoZS5yZWRTdWIoZCkpO1xuICAgICAgLy8gWjMgPSBGICogSlxuICAgICAgbnogPSBmLnJlZE11bChqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRSA9IEMgKyBEXG4gICAgdmFyIGUgPSBjLnJlZEFkZChkKTtcbiAgICAvLyBIID0gKGMgKiBaMSleMlxuICAgIHZhciBoID0gdGhpcy5jdXJ2ZS5fbXVsQyh0aGlzLnopLnJlZFNxcigpO1xuICAgIC8vIEogPSBFIC0gMiAqIEhcbiAgICB2YXIgaiA9IGUucmVkU3ViKGgpLnJlZFN1YihoKTtcbiAgICAvLyBYMyA9IGMgKiAoQiAtIEUpICogSlxuICAgIG54ID0gdGhpcy5jdXJ2ZS5fbXVsQyhiLnJlZElTdWIoZSkpLnJlZE11bChqKTtcbiAgICAvLyBZMyA9IGMgKiBFICogKEMgLSBEKVxuICAgIG55ID0gdGhpcy5jdXJ2ZS5fbXVsQyhlKS5yZWRNdWwoYy5yZWRJU3ViKGQpKTtcbiAgICAvLyBaMyA9IEUgKiBKXG4gICAgbnogPSBlLnJlZE11bChqKTtcbiAgfVxuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnksIG56KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBEb3VibGUgaW4gZXh0ZW5kZWQgY29vcmRpbmF0ZXNcbiAgaWYgKHRoaXMuY3VydmUuZXh0ZW5kZWQpXG4gICAgcmV0dXJuIHRoaXMuX2V4dERibCgpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX3Byb2pEYmwoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZXh0QWRkID0gZnVuY3Rpb24gX2V4dEFkZChwKSB7XG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLTEuaHRtbFxuICAvLyAgICAgI2FkZGl0aW9uLWFkZC0yMDA4LWh3Y2QtM1xuICAvLyA4TVxuXG4gIC8vIEEgPSAoWTEgLSBYMSkgKiAoWTIgLSBYMilcbiAgdmFyIGEgPSB0aGlzLnkucmVkU3ViKHRoaXMueCkucmVkTXVsKHAueS5yZWRTdWIocC54KSk7XG4gIC8vIEIgPSAoWTEgKyBYMSkgKiAoWTIgKyBYMilcbiAgdmFyIGIgPSB0aGlzLnkucmVkQWRkKHRoaXMueCkucmVkTXVsKHAueS5yZWRBZGQocC54KSk7XG4gIC8vIEMgPSBUMSAqIGsgKiBUMlxuICB2YXIgYyA9IHRoaXMudC5yZWRNdWwodGhpcy5jdXJ2ZS5kZCkucmVkTXVsKHAudCk7XG4gIC8vIEQgPSBaMSAqIDIgKiBaMlxuICB2YXIgZCA9IHRoaXMuei5yZWRNdWwocC56LnJlZEFkZChwLnopKTtcbiAgLy8gRSA9IEIgLSBBXG4gIHZhciBlID0gYi5yZWRTdWIoYSk7XG4gIC8vIEYgPSBEIC0gQ1xuICB2YXIgZiA9IGQucmVkU3ViKGMpO1xuICAvLyBHID0gRCArIENcbiAgdmFyIGcgPSBkLnJlZEFkZChjKTtcbiAgLy8gSCA9IEIgKyBBXG4gIHZhciBoID0gYi5yZWRBZGQoYSk7XG4gIC8vIFgzID0gRSAqIEZcbiAgdmFyIG54ID0gZS5yZWRNdWwoZik7XG4gIC8vIFkzID0gRyAqIEhcbiAgdmFyIG55ID0gZy5yZWRNdWwoaCk7XG4gIC8vIFQzID0gRSAqIEhcbiAgdmFyIG50ID0gZS5yZWRNdWwoaCk7XG4gIC8vIFozID0gRiAqIEdcbiAgdmFyIG56ID0gZi5yZWRNdWwoZyk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnosIG50KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fcHJvakFkZCA9IGZ1bmN0aW9uIF9wcm9qQWRkKHApIHtcbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtcHJvamVjdGl2ZS5odG1sXG4gIC8vICAgICAjYWRkaXRpb24tYWRkLTIwMDgtYmJqbHBcbiAgLy8gICAgICNhZGRpdGlvbi1hZGQtMjAwNy1ibFxuICAvLyAxME0gKyAxU1xuXG4gIC8vIEEgPSBaMSAqIFoyXG4gIHZhciBhID0gdGhpcy56LnJlZE11bChwLnopO1xuICAvLyBCID0gQV4yXG4gIHZhciBiID0gYS5yZWRTcXIoKTtcbiAgLy8gQyA9IFgxICogWDJcbiAgdmFyIGMgPSB0aGlzLngucmVkTXVsKHAueCk7XG4gIC8vIEQgPSBZMSAqIFkyXG4gIHZhciBkID0gdGhpcy55LnJlZE11bChwLnkpO1xuICAvLyBFID0gZCAqIEMgKiBEXG4gIHZhciBlID0gdGhpcy5jdXJ2ZS5kLnJlZE11bChjKS5yZWRNdWwoZCk7XG4gIC8vIEYgPSBCIC0gRVxuICB2YXIgZiA9IGIucmVkU3ViKGUpO1xuICAvLyBHID0gQiArIEVcbiAgdmFyIGcgPSBiLnJlZEFkZChlKTtcbiAgLy8gWDMgPSBBICogRiAqICgoWDEgKyBZMSkgKiAoWDIgKyBZMikgLSBDIC0gRClcbiAgdmFyIHRtcCA9IHRoaXMueC5yZWRBZGQodGhpcy55KS5yZWRNdWwocC54LnJlZEFkZChwLnkpKS5yZWRJU3ViKGMpLnJlZElTdWIoZCk7XG4gIHZhciBueCA9IGEucmVkTXVsKGYpLnJlZE11bCh0bXApO1xuICB2YXIgbnk7XG4gIHZhciBuejtcbiAgaWYgKHRoaXMuY3VydmUudHdpc3RlZCkge1xuICAgIC8vIFkzID0gQSAqIEcgKiAoRCAtIGEgKiBDKVxuICAgIG55ID0gYS5yZWRNdWwoZykucmVkTXVsKGQucmVkU3ViKHRoaXMuY3VydmUuX211bEEoYykpKTtcbiAgICAvLyBaMyA9IEYgKiBHXG4gICAgbnogPSBmLnJlZE11bChnKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBZMyA9IEEgKiBHICogKEQgLSBDKVxuICAgIG55ID0gYS5yZWRNdWwoZykucmVkTXVsKGQucmVkU3ViKGMpKTtcbiAgICAvLyBaMyA9IGMgKiBGICogR1xuICAgIG56ID0gdGhpcy5jdXJ2ZS5fbXVsQyhmKS5yZWRNdWwoZyk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55LCBueik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHApIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwO1xuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKHRoaXMuY3VydmUuZXh0ZW5kZWQpXG4gICAgcmV0dXJuIHRoaXMuX2V4dEFkZChwKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLl9wcm9qQWRkKHApO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrKSB7XG4gIGlmICh0aGlzLl9oYXNEb3VibGVzKGspKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9maXhlZE5hZk11bCh0aGlzLCBrKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIG11bEFkZChrMSwgcCwgazIpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgWyB0aGlzLCBwIF0sIFsgazEsIGsyIF0sIDIsIGZhbHNlKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5qbXVsQWRkID0gZnVuY3Rpb24gam11bEFkZChrMSwgcCwgazIpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgWyB0aGlzLCBwIF0sIFsgazEsIGsyIF0sIDIsIHRydWUpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgaWYgKHRoaXMuek9uZSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBOb3JtYWxpemUgY29vcmRpbmF0ZXNcbiAgdmFyIHppID0gdGhpcy56LnJlZEludm0oKTtcbiAgdGhpcy54ID0gdGhpcy54LnJlZE11bCh6aSk7XG4gIHRoaXMueSA9IHRoaXMueS5yZWRNdWwoemkpO1xuICBpZiAodGhpcy50KVxuICAgIHRoaXMudCA9IHRoaXMudC5yZWRNdWwoemkpO1xuICB0aGlzLnogPSB0aGlzLmN1cnZlLm9uZTtcbiAgdGhpcy56T25lID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngucmVkTmVnKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnQgJiYgdGhpcy50LnJlZE5lZygpKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCgpIHtcbiAgdGhpcy5ub3JtYWxpemUoKTtcbiAgcmV0dXJuIHRoaXMueC5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkoKSB7XG4gIHRoaXMubm9ybWFsaXplKCk7XG4gIHJldHVybiB0aGlzLnkuZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMgPT09IG90aGVyIHx8XG4gICAgICAgICB0aGlzLmdldFgoKS5jbXAob3RoZXIuZ2V0WCgpKSA9PT0gMCAmJlxuICAgICAgICAgdGhpcy5nZXRZKCkuY21wKG90aGVyLmdldFkoKSkgPT09IDA7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXFYVG9QID0gZnVuY3Rpb24gZXFYVG9QKHgpIHtcbiAgdmFyIHJ4ID0geC50b1JlZCh0aGlzLmN1cnZlLnJlZCkucmVkTXVsKHRoaXMueik7XG4gIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB2YXIgeGMgPSB4LmNsb25lKCk7XG4gIHZhciB0ID0gdGhpcy5jdXJ2ZS5yZWROLnJlZE11bCh0aGlzLnopO1xuICBmb3IgKDs7KSB7XG4gICAgeGMuaWFkZCh0aGlzLmN1cnZlLm4pO1xuICAgIGlmICh4Yy5jbXAodGhpcy5jdXJ2ZS5wKSA+PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgcngucmVkSUFkZCh0KTtcbiAgICBpZiAodGhpcy54LmNtcChyeCkgPT09IDApXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLy8gQ29tcGF0aWJpbGl0eSB3aXRoIEJhc2VDdXJ2ZVxuUG9pbnQucHJvdG90eXBlLnRvUCA9IFBvaW50LnByb3RvdHlwZS5ub3JtYWxpemU7XG5Qb2ludC5wcm90b3R5cGUubWl4ZWRBZGQgPSBQb2ludC5wcm90b3R5cGUuYWRkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VydmUgPSBleHBvcnRzO1xuXG5jdXJ2ZS5iYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5jdXJ2ZS5zaG9ydCA9IHJlcXVpcmUoJy4vc2hvcnQnKTtcbmN1cnZlLm1vbnQgPSByZXF1aXJlKCcuL21vbnQnKTtcbmN1cnZlLmVkd2FyZHMgPSByZXF1aXJlKCcuL2Vkd2FyZHMnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY3VydmUnKTtcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIEJhc2UgPSBjdXJ2ZS5iYXNlO1xuXG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG5cbmZ1bmN0aW9uIE1vbnRDdXJ2ZShjb25mKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCAnbW9udCcsIGNvbmYpO1xuXG4gIHRoaXMuYSA9IG5ldyBCTihjb25mLmEsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYiA9IG5ldyBCTihjb25mLmIsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuaTQgPSBuZXcgQk4oNCkudG9SZWQodGhpcy5yZWQpLnJlZEludm0oKTtcbiAgdGhpcy50d28gPSBuZXcgQk4oMikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmEyNCA9IHRoaXMuaTQucmVkTXVsKHRoaXMuYS5yZWRBZGQodGhpcy50d28pKTtcbn1cbmluaGVyaXRzKE1vbnRDdXJ2ZSwgQmFzZSk7XG5tb2R1bGUuZXhwb3J0cyA9IE1vbnRDdXJ2ZTtcblxuTW9udEN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHBvaW50KSB7XG4gIHZhciB4ID0gcG9pbnQubm9ybWFsaXplKCkueDtcbiAgdmFyIHgyID0geC5yZWRTcXIoKTtcbiAgdmFyIHJocyA9IHgyLnJlZE11bCh4KS5yZWRBZGQoeDIucmVkTXVsKHRoaXMuYSkpLnJlZEFkZCh4KTtcbiAgdmFyIHkgPSByaHMucmVkU3FydCgpO1xuXG4gIHJldHVybiB5LnJlZFNxcigpLmNtcChyaHMpID09PSAwO1xufTtcblxuZnVuY3Rpb24gUG9pbnQoY3VydmUsIHgsIHopIHtcbiAgQmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ3Byb2plY3RpdmUnKTtcbiAgaWYgKHggPT09IG51bGwgJiYgeiA9PT0gbnVsbCkge1xuICAgIHRoaXMueCA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMueiA9IHRoaXMuY3VydmUuemVybztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgIHRoaXMueiA9IG5ldyBCTih6LCAxNik7XG4gICAgaWYgKCF0aGlzLngucmVkKVxuICAgICAgdGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICBpZiAoIXRoaXMuei5yZWQpXG4gICAgICB0aGlzLnogPSB0aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICB9XG59XG5pbmhlcml0cyhQb2ludCwgQmFzZS5CYXNlUG9pbnQpO1xuXG5Nb250Q3VydmUucHJvdG90eXBlLmRlY29kZVBvaW50ID0gZnVuY3Rpb24gZGVjb2RlUG9pbnQoYnl0ZXMsIGVuYykge1xuICByZXR1cm4gdGhpcy5wb2ludCh1dGlscy50b0FycmF5KGJ5dGVzLCBlbmMpLCAxKTtcbn07XG5cbk1vbnRDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCh4LCB6KSB7XG4gIHJldHVybiBuZXcgUG9pbnQodGhpcywgeCwgeik7XG59O1xuXG5Nb250Q3VydmUucHJvdG90eXBlLnBvaW50RnJvbUpTT04gPSBmdW5jdGlvbiBwb2ludEZyb21KU09OKG9iaikge1xuICByZXR1cm4gUG9pbnQuZnJvbUpTT04odGhpcywgb2JqKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5wcmVjb21wdXRlID0gZnVuY3Rpb24gcHJlY29tcHV0ZSgpIHtcbiAgLy8gTm8tb3Bcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZW5jb2RlID0gZnVuY3Rpb24gX2VuY29kZSgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WCgpLnRvQXJyYXkoJ2JlJywgdGhpcy5jdXJ2ZS5wLmJ5dGVMZW5ndGgoKSk7XG59O1xuXG5Qb2ludC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKGN1cnZlLCBvYmopIHtcbiAgcmV0dXJuIG5ldyBQb2ludChjdXJ2ZSwgb2JqWzBdLCBvYmpbMV0gfHwgY3VydmUub25lKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIFBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIFBvaW50IHg6ICcgKyB0aGlzLnguZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHo6ICcgKyB0aGlzLnouZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgLy8gWFhYIFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgemVybyBpcyBhbHdheXMgemVybyBpbiByZWRcbiAgcmV0dXJuIHRoaXMuei5jbXBuKDApID09PSAwO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uIGRibCgpIHtcbiAgLy8gaHR0cDovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1tb250Z29tLXh6Lmh0bWwjZG91YmxpbmctZGJsLTE5ODctbS0zXG4gIC8vIDJNICsgMlMgKyA0QVxuXG4gIC8vIEEgPSBYMSArIFoxXG4gIHZhciBhID0gdGhpcy54LnJlZEFkZCh0aGlzLnopO1xuICAvLyBBQSA9IEFeMlxuICB2YXIgYWEgPSBhLnJlZFNxcigpO1xuICAvLyBCID0gWDEgLSBaMVxuICB2YXIgYiA9IHRoaXMueC5yZWRTdWIodGhpcy56KTtcbiAgLy8gQkIgPSBCXjJcbiAgdmFyIGJiID0gYi5yZWRTcXIoKTtcbiAgLy8gQyA9IEFBIC0gQkJcbiAgdmFyIGMgPSBhYS5yZWRTdWIoYmIpO1xuICAvLyBYMyA9IEFBICogQkJcbiAgdmFyIG54ID0gYWEucmVkTXVsKGJiKTtcbiAgLy8gWjMgPSBDICogKEJCICsgQTI0ICogQylcbiAgdmFyIG56ID0gYy5yZWRNdWwoYmIucmVkQWRkKHRoaXMuY3VydmUuYTI0LnJlZE11bChjKSkpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnopO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkIG9uIE1vbnRnb21lcnkgY3VydmUnKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kaWZmQWRkID0gZnVuY3Rpb24gZGlmZkFkZChwLCBkaWZmKSB7XG4gIC8vIGh0dHA6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tbW9udGdvbS14ei5odG1sI2RpZmZhZGQtZGFkZC0xOTg3LW0tM1xuICAvLyA0TSArIDJTICsgNkFcblxuICAvLyBBID0gWDIgKyBaMlxuICB2YXIgYSA9IHRoaXMueC5yZWRBZGQodGhpcy56KTtcbiAgLy8gQiA9IFgyIC0gWjJcbiAgdmFyIGIgPSB0aGlzLngucmVkU3ViKHRoaXMueik7XG4gIC8vIEMgPSBYMyArIFozXG4gIHZhciBjID0gcC54LnJlZEFkZChwLnopO1xuICAvLyBEID0gWDMgLSBaM1xuICB2YXIgZCA9IHAueC5yZWRTdWIocC56KTtcbiAgLy8gREEgPSBEICogQVxuICB2YXIgZGEgPSBkLnJlZE11bChhKTtcbiAgLy8gQ0IgPSBDICogQlxuICB2YXIgY2IgPSBjLnJlZE11bChiKTtcbiAgLy8gWDUgPSBaMSAqIChEQSArIENCKV4yXG4gIHZhciBueCA9IGRpZmYuei5yZWRNdWwoZGEucmVkQWRkKGNiKS5yZWRTcXIoKSk7XG4gIC8vIFo1ID0gWDEgKiAoREEgLSBDQileMlxuICB2YXIgbnogPSBkaWZmLngucmVkTXVsKGRhLnJlZElTdWIoY2IpLnJlZFNxcigpKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG56KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaykge1xuICB2YXIgdCA9IGsuY2xvbmUoKTtcbiAgdmFyIGEgPSB0aGlzOyAvLyAoTiAvIDIpICogUSArIFFcbiAgdmFyIGIgPSB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpOyAvLyAoTiAvIDIpICogUVxuICB2YXIgYyA9IHRoaXM7IC8vIFFcblxuICBmb3IgKHZhciBiaXRzID0gW107IHQuY21wbigwKSAhPT0gMDsgdC5pdXNocm4oMSkpXG4gICAgYml0cy5wdXNoKHQuYW5kbG4oMSkpO1xuXG4gIGZvciAodmFyIGkgPSBiaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGJpdHNbaV0gPT09IDApIHtcbiAgICAgIC8vIE4gKiBRICsgUSA9ICgoTiAvIDIpICogUSArIFEpKSArIChOIC8gMikgKiBRXG4gICAgICBhID0gYS5kaWZmQWRkKGIsIGMpO1xuICAgICAgLy8gTiAqIFEgPSAyICogKChOIC8gMikgKiBRICsgUSkpXG4gICAgICBiID0gYi5kYmwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTiAqIFEgPSAoKE4gLyAyKSAqIFEgKyBRKSArICgoTiAvIDIpICogUSlcbiAgICAgIGIgPSBhLmRpZmZBZGQoYiwgYyk7XG4gICAgICAvLyBOICogUSArIFEgPSAyICogKChOIC8gMikgKiBRICsgUSlcbiAgICAgIGEgPSBhLmRibCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYjtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWxBZGQgPSBmdW5jdGlvbiBtdWxBZGQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBvbiBNb250Z29tZXJ5IGN1cnZlJyk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuanVtbEFkZCA9IGZ1bmN0aW9uIGp1bWxBZGQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBvbiBNb250Z29tZXJ5IGN1cnZlJyk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShvdGhlcikge1xuICByZXR1cm4gdGhpcy5nZXRYKCkuY21wKG90aGVyLmdldFgoKSkgPT09IDA7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKCkge1xuICB0aGlzLnggPSB0aGlzLngucmVkTXVsKHRoaXMuei5yZWRJbnZtKCkpO1xuICB0aGlzLnogPSB0aGlzLmN1cnZlLm9uZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFgoKSB7XG4gIC8vIE5vcm1hbGl6ZSBjb29yZGluYXRlc1xuICB0aGlzLm5vcm1hbGl6ZSgpO1xuXG4gIHJldHVybiB0aGlzLnguZnJvbVJlZCgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY3VydmUnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCYXNlID0gY3VydmUuYmFzZTtcblxudmFyIGFzc2VydCA9IGVsbGlwdGljLnV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gU2hvcnRDdXJ2ZShjb25mKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCAnc2hvcnQnLCBjb25mKTtcblxuICB0aGlzLmEgPSBuZXcgQk4oY29uZi5hLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmIgPSBuZXcgQk4oY29uZi5iLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLnRpbnYgPSB0aGlzLnR3by5yZWRJbnZtKCk7XG5cbiAgdGhpcy56ZXJvQSA9IHRoaXMuYS5mcm9tUmVkKCkuY21wbigwKSA9PT0gMDtcbiAgdGhpcy50aHJlZUEgPSB0aGlzLmEuZnJvbVJlZCgpLnN1Yih0aGlzLnApLmNtcG4oLTMpID09PSAwO1xuXG4gIC8vIElmIHRoZSBjdXJ2ZSBpcyBlbmRvbW9ycGhpYywgcHJlY2FsY3VsYXRlIGJldGEgYW5kIGxhbWJkYVxuICB0aGlzLmVuZG8gPSB0aGlzLl9nZXRFbmRvbW9ycGhpc20oY29uZik7XG4gIHRoaXMuX2VuZG9XbmFmVDEgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX2VuZG9XbmFmVDIgPSBuZXcgQXJyYXkoNCk7XG59XG5pbmhlcml0cyhTaG9ydEN1cnZlLCBCYXNlKTtcbm1vZHVsZS5leHBvcnRzID0gU2hvcnRDdXJ2ZTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9tb3JwaGlzbSA9IGZ1bmN0aW9uIF9nZXRFbmRvbW9ycGhpc20oY29uZikge1xuICAvLyBObyBlZmZpY2llbnQgZW5kb21vcnBoaXNtXG4gIGlmICghdGhpcy56ZXJvQSB8fCAhdGhpcy5nIHx8ICF0aGlzLm4gfHwgdGhpcy5wLm1vZG4oMykgIT09IDEpXG4gICAgcmV0dXJuO1xuXG4gIC8vIENvbXB1dGUgYmV0YSBhbmQgbGFtYmRhLCB0aGF0IGxhbWJkYSAqIFAgPSAoYmV0YSAqIFB4OyBQeSlcbiAgdmFyIGJldGE7XG4gIHZhciBsYW1iZGE7XG4gIGlmIChjb25mLmJldGEpIHtcbiAgICBiZXRhID0gbmV3IEJOKGNvbmYuYmV0YSwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYmV0YXMgPSB0aGlzLl9nZXRFbmRvUm9vdHModGhpcy5wKTtcbiAgICAvLyBDaG9vc2UgdGhlIHNtYWxsZXN0IGJldGFcbiAgICBiZXRhID0gYmV0YXNbMF0uY21wKGJldGFzWzFdKSA8IDAgPyBiZXRhc1swXSA6IGJldGFzWzFdO1xuICAgIGJldGEgPSBiZXRhLnRvUmVkKHRoaXMucmVkKTtcbiAgfVxuICBpZiAoY29uZi5sYW1iZGEpIHtcbiAgICBsYW1iZGEgPSBuZXcgQk4oY29uZi5sYW1iZGEsIDE2KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDaG9vc2UgdGhlIGxhbWJkYSB0aGF0IGlzIG1hdGNoaW5nIHNlbGVjdGVkIGJldGFcbiAgICB2YXIgbGFtYmRhcyA9IHRoaXMuX2dldEVuZG9Sb290cyh0aGlzLm4pO1xuICAgIGlmICh0aGlzLmcubXVsKGxhbWJkYXNbMF0pLnguY21wKHRoaXMuZy54LnJlZE11bChiZXRhKSkgPT09IDApIHtcbiAgICAgIGxhbWJkYSA9IGxhbWJkYXNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhbWJkYSA9IGxhbWJkYXNbMV07XG4gICAgICBhc3NlcnQodGhpcy5nLm11bChsYW1iZGEpLnguY21wKHRoaXMuZy54LnJlZE11bChiZXRhKSkgPT09IDApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBiYXNpcyB2ZWN0b3JzLCB1c2VkIGZvciBiYWxhbmNlZCBsZW5ndGgtdHdvIHJlcHJlc2VudGF0aW9uXG4gIHZhciBiYXNpcztcbiAgaWYgKGNvbmYuYmFzaXMpIHtcbiAgICBiYXNpcyA9IGNvbmYuYmFzaXMubWFwKGZ1bmN0aW9uKHZlYykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYTogbmV3IEJOKHZlYy5hLCAxNiksXG4gICAgICAgIGI6IG5ldyBCTih2ZWMuYiwgMTYpXG4gICAgICB9O1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGJhc2lzID0gdGhpcy5fZ2V0RW5kb0Jhc2lzKGxhbWJkYSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJldGE6IGJldGEsXG4gICAgbGFtYmRhOiBsYW1iZGEsXG4gICAgYmFzaXM6IGJhc2lzXG4gIH07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb1Jvb3RzID0gZnVuY3Rpb24gX2dldEVuZG9Sb290cyhudW0pIHtcbiAgLy8gRmluZCByb290cyBvZiBmb3IgeF4yICsgeCArIDEgaW4gRlxuICAvLyBSb290ID0gKC0xICstIFNxcnQoLTMpKSAvIDJcbiAgLy9cbiAgdmFyIHJlZCA9IG51bSA9PT0gdGhpcy5wID8gdGhpcy5yZWQgOiBCTi5tb250KG51bSk7XG4gIHZhciB0aW52ID0gbmV3IEJOKDIpLnRvUmVkKHJlZCkucmVkSW52bSgpO1xuICB2YXIgbnRpbnYgPSB0aW52LnJlZE5lZygpO1xuXG4gIHZhciBzID0gbmV3IEJOKDMpLnRvUmVkKHJlZCkucmVkTmVnKCkucmVkU3FydCgpLnJlZE11bCh0aW52KTtcblxuICB2YXIgbDEgPSBudGludi5yZWRBZGQocykuZnJvbVJlZCgpO1xuICB2YXIgbDIgPSBudGludi5yZWRTdWIocykuZnJvbVJlZCgpO1xuICByZXR1cm4gWyBsMSwgbDIgXTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvQmFzaXMgPSBmdW5jdGlvbiBfZ2V0RW5kb0Jhc2lzKGxhbWJkYSkge1xuICAvLyBhcHJ4U3FydCA+PSBzcXJ0KHRoaXMubilcbiAgdmFyIGFwcnhTcXJ0ID0gdGhpcy5uLnVzaHJuKE1hdGguZmxvb3IodGhpcy5uLmJpdExlbmd0aCgpIC8gMikpO1xuXG4gIC8vIDMuNzRcbiAgLy8gUnVuIEVHQ0QsIHVudGlsIHIoTCArIDEpIDwgYXByeFNxcnRcbiAgdmFyIHUgPSBsYW1iZGE7XG4gIHZhciB2ID0gdGhpcy5uLmNsb25lKCk7XG4gIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgdmFyIHkxID0gbmV3IEJOKDApO1xuICB2YXIgeDIgPSBuZXcgQk4oMCk7XG4gIHZhciB5MiA9IG5ldyBCTigxKTtcblxuICAvLyBOT1RFOiBhbGwgdmVjdG9ycyBhcmUgcm9vdHMgb2Y6IGEgKyBiICogbGFtYmRhID0gMCAobW9kIG4pXG4gIHZhciBhMDtcbiAgdmFyIGIwO1xuICAvLyBGaXJzdCB2ZWN0b3JcbiAgdmFyIGExO1xuICB2YXIgYjE7XG4gIC8vIFNlY29uZCB2ZWN0b3JcbiAgdmFyIGEyO1xuICB2YXIgYjI7XG5cbiAgdmFyIHByZXZSO1xuICB2YXIgaSA9IDA7XG4gIHZhciByO1xuICB2YXIgeDtcbiAgd2hpbGUgKHUuY21wbigwKSAhPT0gMCkge1xuICAgIHZhciBxID0gdi5kaXYodSk7XG4gICAgciA9IHYuc3ViKHEubXVsKHUpKTtcbiAgICB4ID0geDIuc3ViKHEubXVsKHgxKSk7XG4gICAgdmFyIHkgPSB5Mi5zdWIocS5tdWwoeTEpKTtcblxuICAgIGlmICghYTEgJiYgci5jbXAoYXByeFNxcnQpIDwgMCkge1xuICAgICAgYTAgPSBwcmV2Ui5uZWcoKTtcbiAgICAgIGIwID0geDE7XG4gICAgICBhMSA9IHIubmVnKCk7XG4gICAgICBiMSA9IHg7XG4gICAgfSBlbHNlIGlmIChhMSAmJiArK2kgPT09IDIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwcmV2UiA9IHI7XG5cbiAgICB2ID0gdTtcbiAgICB1ID0gcjtcbiAgICB4MiA9IHgxO1xuICAgIHgxID0geDtcbiAgICB5MiA9IHkxO1xuICAgIHkxID0geTtcbiAgfVxuICBhMiA9IHIubmVnKCk7XG4gIGIyID0geDtcblxuICB2YXIgbGVuMSA9IGExLnNxcigpLmFkZChiMS5zcXIoKSk7XG4gIHZhciBsZW4yID0gYTIuc3FyKCkuYWRkKGIyLnNxcigpKTtcbiAgaWYgKGxlbjIuY21wKGxlbjEpID49IDApIHtcbiAgICBhMiA9IGEwO1xuICAgIGIyID0gYjA7XG4gIH1cblxuICAvLyBOb3JtYWxpemUgc2lnbnNcbiAgaWYgKGExLm5lZ2F0aXZlKSB7XG4gICAgYTEgPSBhMS5uZWcoKTtcbiAgICBiMSA9IGIxLm5lZygpO1xuICB9XG4gIGlmIChhMi5uZWdhdGl2ZSkge1xuICAgIGEyID0gYTIubmVnKCk7XG4gICAgYjIgPSBiMi5uZWcoKTtcbiAgfVxuXG4gIHJldHVybiBbXG4gICAgeyBhOiBhMSwgYjogYjEgfSxcbiAgICB7IGE6IGEyLCBiOiBiMiB9XG4gIF07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZW5kb1NwbGl0ID0gZnVuY3Rpb24gX2VuZG9TcGxpdChrKSB7XG4gIHZhciBiYXNpcyA9IHRoaXMuZW5kby5iYXNpcztcbiAgdmFyIHYxID0gYmFzaXNbMF07XG4gIHZhciB2MiA9IGJhc2lzWzFdO1xuXG4gIHZhciBjMSA9IHYyLmIubXVsKGspLmRpdlJvdW5kKHRoaXMubik7XG4gIHZhciBjMiA9IHYxLmIubmVnKCkubXVsKGspLmRpdlJvdW5kKHRoaXMubik7XG5cbiAgdmFyIHAxID0gYzEubXVsKHYxLmEpO1xuICB2YXIgcDIgPSBjMi5tdWwodjIuYSk7XG4gIHZhciBxMSA9IGMxLm11bCh2MS5iKTtcbiAgdmFyIHEyID0gYzIubXVsKHYyLmIpO1xuXG4gIC8vIENhbGN1bGF0ZSBhbnN3ZXJcbiAgdmFyIGsxID0gay5zdWIocDEpLnN1YihwMik7XG4gIHZhciBrMiA9IHExLmFkZChxMikubmVnKCk7XG4gIHJldHVybiB7IGsxOiBrMSwgazI6IGsyIH07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21YID0gZnVuY3Rpb24gcG9pbnRGcm9tWCh4LCBvZGQpIHtcbiAgeCA9IG5ldyBCTih4LCAxNik7XG4gIGlmICgheC5yZWQpXG4gICAgeCA9IHgudG9SZWQodGhpcy5yZWQpO1xuXG4gIHZhciB5MiA9IHgucmVkU3FyKCkucmVkTXVsKHgpLnJlZElBZGQoeC5yZWRNdWwodGhpcy5hKSkucmVkSUFkZCh0aGlzLmIpO1xuICB2YXIgeSA9IHkyLnJlZFNxcnQoKTtcbiAgaWYgKHkucmVkU3FyKCkucmVkU3ViKHkyKS5jbXAodGhpcy56ZXJvKSAhPT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9pbnQnKTtcblxuICAvLyBYWFggSXMgdGhlcmUgYW55IHdheSB0byB0ZWxsIGlmIHRoZSBudW1iZXIgaXMgb2RkIHdpdGhvdXQgY29udmVydGluZyBpdFxuICAvLyB0byBub24tcmVkIGZvcm0/XG4gIHZhciBpc09kZCA9IHkuZnJvbVJlZCgpLmlzT2RkKCk7XG4gIGlmIChvZGQgJiYgIWlzT2RkIHx8ICFvZGQgJiYgaXNPZGQpXG4gICAgeSA9IHkucmVkTmVnKCk7XG5cbiAgcmV0dXJuIHRoaXMucG9pbnQoeCwgeSk7XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHBvaW50KSB7XG4gIGlmIChwb2ludC5pbmYpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgdmFyIHggPSBwb2ludC54O1xuICB2YXIgeSA9IHBvaW50Lnk7XG5cbiAgdmFyIGF4ID0gdGhpcy5hLnJlZE11bCh4KTtcbiAgdmFyIHJocyA9IHgucmVkU3FyKCkucmVkTXVsKHgpLnJlZElBZGQoYXgpLnJlZElBZGQodGhpcy5iKTtcbiAgcmV0dXJuIHkucmVkU3FyKCkucmVkSVN1YihyaHMpLmNtcG4oMCkgPT09IDA7XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZW5kb1duYWZNdWxBZGQgPVxuICAgIGZ1bmN0aW9uIF9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcywgamFjb2JpYW5SZXN1bHQpIHtcbiAgdmFyIG5wb2ludHMgPSB0aGlzLl9lbmRvV25hZlQxO1xuICB2YXIgbmNvZWZmcyA9IHRoaXMuX2VuZG9XbmFmVDI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNwbGl0ID0gdGhpcy5fZW5kb1NwbGl0KGNvZWZmc1tpXSk7XG4gICAgdmFyIHAgPSBwb2ludHNbaV07XG4gICAgdmFyIGJldGEgPSBwLl9nZXRCZXRhKCk7XG5cbiAgICBpZiAoc3BsaXQuazEubmVnYXRpdmUpIHtcbiAgICAgIHNwbGl0LmsxLmluZWcoKTtcbiAgICAgIHAgPSBwLm5lZyh0cnVlKTtcbiAgICB9XG4gICAgaWYgKHNwbGl0LmsyLm5lZ2F0aXZlKSB7XG4gICAgICBzcGxpdC5rMi5pbmVnKCk7XG4gICAgICBiZXRhID0gYmV0YS5uZWcodHJ1ZSk7XG4gICAgfVxuXG4gICAgbnBvaW50c1tpICogMl0gPSBwO1xuICAgIG5wb2ludHNbaSAqIDIgKyAxXSA9IGJldGE7XG4gICAgbmNvZWZmc1tpICogMl0gPSBzcGxpdC5rMTtcbiAgICBuY29lZmZzW2kgKiAyICsgMV0gPSBzcGxpdC5rMjtcbiAgfVxuICB2YXIgcmVzID0gdGhpcy5fd25hZk11bEFkZCgxLCBucG9pbnRzLCBuY29lZmZzLCBpICogMiwgamFjb2JpYW5SZXN1bHQpO1xuXG4gIC8vIENsZWFuLXVwIHJlZmVyZW5jZXMgdG8gcG9pbnRzIGFuZCBjb2VmZmljaWVudHNcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBpICogMjsgaisrKSB7XG4gICAgbnBvaW50c1tqXSA9IG51bGw7XG4gICAgbmNvZWZmc1tqXSA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIFBvaW50KGN1cnZlLCB4LCB5LCBpc1JlZCkge1xuICBCYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAnYWZmaW5lJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHkgPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSBudWxsO1xuICAgIHRoaXMueSA9IG51bGw7XG4gICAgdGhpcy5pbmYgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IG5ldyBCTih4LCAxNik7XG4gICAgdGhpcy55ID0gbmV3IEJOKHksIDE2KTtcbiAgICAvLyBGb3JjZSByZWRnb21lcnkgcmVwcmVzZW50YXRpb24gd2hlbiBsb2FkaW5nIGZyb20gSlNPTlxuICAgIGlmIChpc1JlZCkge1xuICAgICAgdGhpcy54LmZvcmNlUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICAgIHRoaXMueS5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgfVxuICAgIGlmICghdGhpcy54LnJlZClcbiAgICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnkucmVkKVxuICAgICAgdGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICB0aGlzLmluZiA9IGZhbHNlO1xuICB9XG59XG5pbmhlcml0cyhQb2ludCwgQmFzZS5CYXNlUG9pbnQpO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KHgsIHksIGlzUmVkKSB7XG4gIHJldHVybiBuZXcgUG9pbnQodGhpcywgeCwgeSwgaXNSZWQpO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTiA9IGZ1bmN0aW9uIHBvaW50RnJvbUpTT04ob2JqLCByZWQpIHtcbiAgcmV0dXJuIFBvaW50LmZyb21KU09OKHRoaXMsIG9iaiwgcmVkKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZ2V0QmV0YSA9IGZ1bmN0aW9uIF9nZXRCZXRhKCkge1xuICBpZiAoIXRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm47XG5cbiAgdmFyIHByZSA9IHRoaXMucHJlY29tcHV0ZWQ7XG4gIGlmIChwcmUgJiYgcHJlLmJldGEpXG4gICAgcmV0dXJuIHByZS5iZXRhO1xuXG4gIHZhciBiZXRhID0gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngucmVkTXVsKHRoaXMuY3VydmUuZW5kby5iZXRhKSwgdGhpcy55KTtcbiAgaWYgKHByZSkge1xuICAgIHZhciBjdXJ2ZSA9IHRoaXMuY3VydmU7XG4gICAgdmFyIGVuZG9NdWwgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gY3VydmUucG9pbnQocC54LnJlZE11bChjdXJ2ZS5lbmRvLmJldGEpLCBwLnkpO1xuICAgIH07XG4gICAgcHJlLmJldGEgPSBiZXRhO1xuICAgIGJldGEucHJlY29tcHV0ZWQgPSB7XG4gICAgICBiZXRhOiBudWxsLFxuICAgICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgICAgd25kOiBwcmUubmFmLnduZCxcbiAgICAgICAgcG9pbnRzOiBwcmUubmFmLnBvaW50cy5tYXAoZW5kb011bClcbiAgICAgIH0sXG4gICAgICBkb3VibGVzOiBwcmUuZG91YmxlcyAmJiB7XG4gICAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG4gICAgICAgIHBvaW50czogcHJlLmRvdWJsZXMucG9pbnRzLm1hcChlbmRvTXVsKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGJldGE7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICBpZiAoIXRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuIFsgdGhpcy54LCB0aGlzLnkgXTtcblxuICByZXR1cm4gWyB0aGlzLngsIHRoaXMueSwgdGhpcy5wcmVjb21wdXRlZCAmJiB7XG4gICAgZG91YmxlczogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzICYmIHtcbiAgICAgIHN0ZXA6IHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5zdGVwLFxuICAgICAgcG9pbnRzOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMucG9pbnRzLnNsaWNlKDEpXG4gICAgfSxcbiAgICBuYWY6IHRoaXMucHJlY29tcHV0ZWQubmFmICYmIHtcbiAgICAgIHduZDogdGhpcy5wcmVjb21wdXRlZC5uYWYud25kLFxuICAgICAgcG9pbnRzOiB0aGlzLnByZWNvbXB1dGVkLm5hZi5wb2ludHMuc2xpY2UoMSlcbiAgICB9XG4gIH0gXTtcbn07XG5cblBvaW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsIG9iaiwgcmVkKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJylcbiAgICBvYmogPSBKU09OLnBhcnNlKG9iaik7XG4gIHZhciByZXMgPSBjdXJ2ZS5wb2ludChvYmpbMF0sIG9ialsxXSwgcmVkKTtcbiAgaWYgKCFvYmpbMl0pXG4gICAgcmV0dXJuIHJlcztcblxuICBmdW5jdGlvbiBvYmoycG9pbnQob2JqKSB7XG4gICAgcmV0dXJuIGN1cnZlLnBvaW50KG9ialswXSwgb2JqWzFdLCByZWQpO1xuICB9XG5cbiAgdmFyIHByZSA9IG9ialsyXTtcbiAgcmVzLnByZWNvbXB1dGVkID0ge1xuICAgIGJldGE6IG51bGwsXG4gICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgIHBvaW50czogWyByZXMgXS5jb25jYXQocHJlLmRvdWJsZXMucG9pbnRzLm1hcChvYmoycG9pbnQpKVxuICAgIH0sXG4gICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgIHduZDogcHJlLm5hZi53bmQsXG4gICAgICBwb2ludHM6IFsgcmVzIF0uY29uY2F0KHByZS5uYWYucG9pbnRzLm1hcChvYmoycG9pbnQpKVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHJlcztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIFBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIFBvaW50IHg6ICcgKyB0aGlzLnguZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkuZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgcmV0dXJuIHRoaXMuaW5mO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHA7XG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBQICsgUCA9IDJQXG4gIGlmICh0aGlzLmVxKHApKVxuICAgIHJldHVybiB0aGlzLmRibCgpO1xuXG4gIC8vIFAgKyAoLVApID0gT1xuICBpZiAodGhpcy5uZWcoKS5lcShwKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICAvLyBQICsgUSA9IE9cbiAgaWYgKHRoaXMueC5jbXAocC54KSA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgYyA9IHRoaXMueS5yZWRTdWIocC55KTtcbiAgaWYgKGMuY21wbigwKSAhPT0gMClcbiAgICBjID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihwLngpLnJlZEludm0oKSk7XG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngpLnJlZElTdWIocC54KTtcbiAgdmFyIG55ID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihueCkpLnJlZElTdWIodGhpcy55KTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyAyUCA9IE9cbiAgdmFyIHlzMSA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcbiAgaWYgKHlzMS5jbXBuKDApID09PSAwKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuXG4gIHZhciB4MiA9IHRoaXMueC5yZWRTcXIoKTtcbiAgdmFyIGR5aW52ID0geXMxLnJlZEludm0oKTtcbiAgdmFyIGMgPSB4Mi5yZWRBZGQoeDIpLnJlZElBZGQoeDIpLnJlZElBZGQoYSkucmVkTXVsKGR5aW52KTtcblxuICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodGhpcy54LnJlZEFkZCh0aGlzLngpKTtcbiAgdmFyIG55ID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihueCkpLnJlZElTdWIodGhpcy55KTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCgpIHtcbiAgcmV0dXJuIHRoaXMueC5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkoKSB7XG4gIHJldHVybiB0aGlzLnkuZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrKSB7XG4gIGsgPSBuZXcgQk4oaywgMTYpO1xuXG4gIGlmICh0aGlzLl9oYXNEb3VibGVzKGspKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9maXhlZE5hZk11bCh0aGlzLCBrKTtcbiAgZWxzZSBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChbIHRoaXMgXSwgWyBrIF0pO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgayk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24gbXVsQWRkKGsxLCBwMiwgazIpIHtcbiAgdmFyIHBvaW50cyA9IFsgdGhpcywgcDIgXTtcbiAgdmFyIGNvZWZmcyA9IFsgazEsIGsyIF07XG4gIGlmICh0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsIHBvaW50cywgY29lZmZzLCAyKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5qbXVsQWRkID0gZnVuY3Rpb24gam11bEFkZChrMSwgcDIsIGsyKSB7XG4gIHZhciBwb2ludHMgPSBbIHRoaXMsIHAyIF07XG4gIHZhciBjb2VmZnMgPSBbIGsxLCBrMiBdO1xuICBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcywgdHJ1ZSk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBwb2ludHMsIGNvZWZmcywgMiwgdHJ1ZSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShwKSB7XG4gIHJldHVybiB0aGlzID09PSBwIHx8XG4gICAgICAgICB0aGlzLmluZiA9PT0gcC5pbmYgJiZcbiAgICAgICAgICAgICAodGhpcy5pbmYgfHwgdGhpcy54LmNtcChwLngpID09PSAwICYmIHRoaXMueS5jbXAocC55KSA9PT0gMCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKF9wcmVjb21wdXRlKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICB2YXIgcmVzID0gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngsIHRoaXMueS5yZWROZWcoKSk7XG4gIGlmIChfcHJlY29tcHV0ZSAmJiB0aGlzLnByZWNvbXB1dGVkKSB7XG4gICAgdmFyIHByZSA9IHRoaXMucHJlY29tcHV0ZWQ7XG4gICAgdmFyIG5lZ2F0ZSA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBwLm5lZygpO1xuICAgIH07XG4gICAgcmVzLnByZWNvbXB1dGVkID0ge1xuICAgICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgICAgd25kOiBwcmUubmFmLnduZCxcbiAgICAgICAgcG9pbnRzOiBwcmUubmFmLnBvaW50cy5tYXAobmVnYXRlKVxuICAgICAgfSxcbiAgICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgICAgcG9pbnRzOiBwcmUuZG91Ymxlcy5wb2ludHMubWFwKG5lZ2F0ZSlcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudG9KID0gZnVuY3Rpb24gdG9KKCkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuXG4gIHZhciByZXMgPSB0aGlzLmN1cnZlLmpwb2ludCh0aGlzLngsIHRoaXMueSwgdGhpcy5jdXJ2ZS5vbmUpO1xuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gSlBvaW50KGN1cnZlLCB4LCB5LCB6KSB7XG4gIEJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdqYWNvYmlhbicpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsICYmIHogPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnkgPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnogPSBuZXcgQk4oMCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IEJOKHgsIDE2KTtcbiAgICB0aGlzLnkgPSBuZXcgQk4oeSwgMTYpO1xuICAgIHRoaXMueiA9IG5ldyBCTih6LCAxNik7XG4gIH1cbiAgaWYgKCF0aGlzLngucmVkKVxuICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gIGlmICghdGhpcy55LnJlZClcbiAgICB0aGlzLnkgPSB0aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICBpZiAoIXRoaXMuei5yZWQpXG4gICAgdGhpcy56ID0gdGhpcy56LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcblxuICB0aGlzLnpPbmUgPSB0aGlzLnogPT09IHRoaXMuY3VydmUub25lO1xufVxuaW5oZXJpdHMoSlBvaW50LCBCYXNlLkJhc2VQb2ludCk7XG5cblNob3J0Q3VydmUucHJvdG90eXBlLmpwb2ludCA9IGZ1bmN0aW9uIGpwb2ludCh4LCB5LCB6KSB7XG4gIHJldHVybiBuZXcgSlBvaW50KHRoaXMsIHgsIHksIHopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS50b1AgPSBmdW5jdGlvbiB0b1AoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgemludiA9IHRoaXMuei5yZWRJbnZtKCk7XG4gIHZhciB6aW52MiA9IHppbnYucmVkU3FyKCk7XG4gIHZhciBheCA9IHRoaXMueC5yZWRNdWwoemludjIpO1xuICB2YXIgYXkgPSB0aGlzLnkucmVkTXVsKHppbnYyKS5yZWRNdWwoemludik7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQoYXgsIGF5KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCksIHRoaXMueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHA7XG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyAxMk0gKyA0UyArIDdBXG4gIHZhciBwejIgPSBwLnoucmVkU3FyKCk7XG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHUxID0gdGhpcy54LnJlZE11bChwejIpO1xuICB2YXIgdTIgPSBwLngucmVkTXVsKHoyKTtcbiAgdmFyIHMxID0gdGhpcy55LnJlZE11bChwejIucmVkTXVsKHAueikpO1xuICB2YXIgczIgPSBwLnkucmVkTXVsKHoyLnJlZE11bCh0aGlzLnopKTtcblxuICB2YXIgaCA9IHUxLnJlZFN1Yih1Mik7XG4gIHZhciByID0gczEucmVkU3ViKHMyKTtcbiAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuICAgIGlmIChyLmNtcG4oMCkgIT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG4gIH1cblxuICB2YXIgaDIgPSBoLnJlZFNxcigpO1xuICB2YXIgaDMgPSBoMi5yZWRNdWwoaCk7XG4gIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcblxuICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcbiAgdmFyIG55ID0gci5yZWRNdWwodi5yZWRJU3ViKG54KSkucmVkSVN1YihzMS5yZWRNdWwoaDMpKTtcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChwLnopLnJlZE11bChoKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm1peGVkQWRkID0gZnVuY3Rpb24gbWl4ZWRBZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwLnRvSigpO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gOE0gKyAzUyArIDdBXG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHUxID0gdGhpcy54O1xuICB2YXIgdTIgPSBwLngucmVkTXVsKHoyKTtcbiAgdmFyIHMxID0gdGhpcy55O1xuICB2YXIgczIgPSBwLnkucmVkTXVsKHoyKS5yZWRNdWwodGhpcy56KTtcblxuICB2YXIgaCA9IHUxLnJlZFN1Yih1Mik7XG4gIHZhciByID0gczEucmVkU3ViKHMyKTtcbiAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuICAgIGlmIChyLmNtcG4oMCkgIT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG4gIH1cblxuICB2YXIgaDIgPSBoLnJlZFNxcigpO1xuICB2YXIgaDMgPSBoMi5yZWRNdWwoaCk7XG4gIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcblxuICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcbiAgdmFyIG55ID0gci5yZWRNdWwodi5yZWRJU3ViKG54KSkucmVkSVN1YihzMS5yZWRNdWwoaDMpKTtcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChoKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmRibHAgPSBmdW5jdGlvbiBkYmxwKHBvdykge1xuICBpZiAocG93ID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG4gIGlmICghcG93KVxuICAgIHJldHVybiB0aGlzLmRibCgpO1xuXG4gIGlmICh0aGlzLmN1cnZlLnplcm9BIHx8IHRoaXMuY3VydmUudGhyZWVBKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG93OyBpKyspXG4gICAgICByID0gci5kYmwoKTtcbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIC8vIDFNICsgMlMgKyAxQSArIE4gKiAoNFMgKyA1TSArIDhBKVxuICAvLyBOID0gMSA9PiA2TSArIDZTICsgOUFcbiAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG4gIHZhciB0aW52ID0gdGhpcy5jdXJ2ZS50aW52O1xuXG4gIHZhciBqeCA9IHRoaXMueDtcbiAgdmFyIGp5ID0gdGhpcy55O1xuICB2YXIganogPSB0aGlzLno7XG4gIHZhciBqejQgPSBqei5yZWRTcXIoKS5yZWRTcXIoKTtcblxuICAvLyBSZXVzZSByZXN1bHRzXG4gIHZhciBqeWQgPSBqeS5yZWRBZGQoankpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvdzsgaSsrKSB7XG4gICAgdmFyIGp4MiA9IGp4LnJlZFNxcigpO1xuICAgIHZhciBqeWQyID0ganlkLnJlZFNxcigpO1xuICAgIHZhciBqeWQ0ID0ganlkMi5yZWRTcXIoKTtcbiAgICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuICAgIHZhciB0MSA9IGp4LnJlZE11bChqeWQyKTtcbiAgICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodDEucmVkQWRkKHQxKSk7XG4gICAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG4gICAgdmFyIGRueSA9IGMucmVkTXVsKHQyKTtcbiAgICBkbnkgPSBkbnkucmVkSUFkZChkbnkpLnJlZElTdWIoanlkNCk7XG4gICAgdmFyIG56ID0ganlkLnJlZE11bChqeik7XG4gICAgaWYgKGkgKyAxIDwgcG93KVxuICAgICAgano0ID0gano0LnJlZE11bChqeWQ0KTtcblxuICAgIGp4ID0gbng7XG4gICAganogPSBuejtcbiAgICBqeWQgPSBkbnk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQoangsIGp5ZC5yZWRNdWwodGludiksIGp6KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKHRoaXMuY3VydmUuemVyb0EpXG4gICAgcmV0dXJuIHRoaXMuX3plcm9EYmwoKTtcbiAgZWxzZSBpZiAodGhpcy5jdXJ2ZS50aHJlZUEpXG4gICAgcmV0dXJuIHRoaXMuX3RocmVlRGJsKCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5fZGJsKCk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl96ZXJvRGJsID0gZnVuY3Rpb24gX3plcm9EYmwoKSB7XG4gIHZhciBueDtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIC8vIFogPSAxXG4gIGlmICh0aGlzLnpPbmUpIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbFxuICAgIC8vICAgICAjZG91YmxpbmctbWRibC0yMDA3LWJsXG4gICAgLy8gMU0gKyA1UyArIDE0QVxuXG4gICAgLy8gWFggPSBYMV4yXG4gICAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAgIC8vIFlZID0gWTFeMlxuICAgIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBZWVlZID0gWVleMlxuICAgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gICAgLy8gUyA9IDIgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpXG4gICAgdmFyIHMgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuICAgIHMgPSBzLnJlZElBZGQocyk7XG4gICAgLy8gTSA9IDMgKiBYWCArIGE7IGEgPSAwXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO1xuICAgIC8vIFQgPSBNIF4gMiAtIDIqU1xuICAgIHZhciB0ID0gbS5yZWRTcXIoKS5yZWRJU3ViKHMpLnJlZElTdWIocyk7XG5cbiAgICAvLyA4ICogWVlZWVxuICAgIHZhciB5eXl5OCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG5cbiAgICAvLyBYMyA9IFRcbiAgICBueCA9IHQ7XG4gICAgLy8gWTMgPSBNICogKFMgLSBUKSAtIDggKiBZWVlZXG4gICAgbnkgPSBtLnJlZE11bChzLnJlZElTdWIodCkpLnJlZElTdWIoeXl5eTgpO1xuICAgIC8vIFozID0gMipZMVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sXG4gICAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwOS1sXG4gICAgLy8gMk0gKyA1UyArIDEzQVxuXG4gICAgLy8gQSA9IFgxXjJcbiAgICB2YXIgYSA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBCID0gWTFeMlxuICAgIHZhciBiID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIEMgPSBCXjJcbiAgICB2YXIgYyA9IGIucmVkU3FyKCk7XG4gICAgLy8gRCA9IDIgKiAoKFgxICsgQileMiAtIEEgLSBDKVxuICAgIHZhciBkID0gdGhpcy54LnJlZEFkZChiKS5yZWRTcXIoKS5yZWRJU3ViKGEpLnJlZElTdWIoYyk7XG4gICAgZCA9IGQucmVkSUFkZChkKTtcbiAgICAvLyBFID0gMyAqIEFcbiAgICB2YXIgZSA9IGEucmVkQWRkKGEpLnJlZElBZGQoYSk7XG4gICAgLy8gRiA9IEVeMlxuICAgIHZhciBmID0gZS5yZWRTcXIoKTtcblxuICAgIC8vIDggKiBDXG4gICAgdmFyIGM4ID0gYy5yZWRJQWRkKGMpO1xuICAgIGM4ID0gYzgucmVkSUFkZChjOCk7XG4gICAgYzggPSBjOC5yZWRJQWRkKGM4KTtcblxuICAgIC8vIFgzID0gRiAtIDIgKiBEXG4gICAgbnggPSBmLnJlZElTdWIoZCkucmVkSVN1YihkKTtcbiAgICAvLyBZMyA9IEUgKiAoRCAtIFgzKSAtIDggKiBDXG4gICAgbnkgPSBlLnJlZE11bChkLnJlZElTdWIobngpKS5yZWRJU3ViKGM4KTtcbiAgICAvLyBaMyA9IDIgKiBZMSAqIFoxXG4gICAgbnogPSB0aGlzLnkucmVkTXVsKHRoaXMueik7XG4gICAgbnogPSBuei5yZWRJQWRkKG56KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuX3RocmVlRGJsID0gZnVuY3Rpb24gX3RocmVlRGJsKCkge1xuICB2YXIgbng7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICAvLyBaID0gMVxuICBpZiAodGhpcy56T25lKSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0zLmh0bWxcbiAgICAvLyAgICAgI2RvdWJsaW5nLW1kYmwtMjAwNy1ibFxuICAgIC8vIDFNICsgNVMgKyAxNUFcblxuICAgIC8vIFhYID0gWDFeMlxuICAgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBZWSA9IFkxXjJcbiAgICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gWVlZWSA9IFlZXjJcbiAgICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuICAgIC8vIFMgPSAyICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKVxuICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgICBzID0gcy5yZWRJQWRkKHMpO1xuICAgIC8vIE0gPSAzICogWFggKyBhXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpLnJlZElBZGQodGhpcy5jdXJ2ZS5hKTtcbiAgICAvLyBUID0gTV4yIC0gMiAqIFNcbiAgICB2YXIgdCA9IG0ucmVkU3FyKCkucmVkSVN1YihzKS5yZWRJU3ViKHMpO1xuICAgIC8vIFgzID0gVFxuICAgIG54ID0gdDtcbiAgICAvLyBZMyA9IE0gKiAoUyAtIFQpIC0gOCAqIFlZWVlcbiAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIG55ID0gbS5yZWRNdWwocy5yZWRJU3ViKHQpKS5yZWRJU3ViKHl5eXk4KTtcbiAgICAvLyBaMyA9IDIgKiBZMVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMy5odG1sI2RvdWJsaW5nLWRibC0yMDAxLWJcbiAgICAvLyAzTSArIDVTXG5cbiAgICAvLyBkZWx0YSA9IFoxXjJcbiAgICB2YXIgZGVsdGEgPSB0aGlzLnoucmVkU3FyKCk7XG4gICAgLy8gZ2FtbWEgPSBZMV4yXG4gICAgdmFyIGdhbW1hID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIGJldGEgPSBYMSAqIGdhbW1hXG4gICAgdmFyIGJldGEgPSB0aGlzLngucmVkTXVsKGdhbW1hKTtcbiAgICAvLyBhbHBoYSA9IDMgKiAoWDEgLSBkZWx0YSkgKiAoWDEgKyBkZWx0YSlcbiAgICB2YXIgYWxwaGEgPSB0aGlzLngucmVkU3ViKGRlbHRhKS5yZWRNdWwodGhpcy54LnJlZEFkZChkZWx0YSkpO1xuICAgIGFscGhhID0gYWxwaGEucmVkQWRkKGFscGhhKS5yZWRJQWRkKGFscGhhKTtcbiAgICAvLyBYMyA9IGFscGhhXjIgLSA4ICogYmV0YVxuICAgIHZhciBiZXRhNCA9IGJldGEucmVkSUFkZChiZXRhKTtcbiAgICBiZXRhNCA9IGJldGE0LnJlZElBZGQoYmV0YTQpO1xuICAgIHZhciBiZXRhOCA9IGJldGE0LnJlZEFkZChiZXRhNCk7XG4gICAgbnggPSBhbHBoYS5yZWRTcXIoKS5yZWRJU3ViKGJldGE4KTtcbiAgICAvLyBaMyA9IChZMSArIFoxKV4yIC0gZ2FtbWEgLSBkZWx0YVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnopLnJlZFNxcigpLnJlZElTdWIoZ2FtbWEpLnJlZElTdWIoZGVsdGEpO1xuICAgIC8vIFkzID0gYWxwaGEgKiAoNCAqIGJldGEgLSBYMykgLSA4ICogZ2FtbWFeMlxuICAgIHZhciBnZ2FtbWE4ID0gZ2FtbWEucmVkU3FyKCk7XG4gICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcbiAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG4gICAgbnkgPSBhbHBoYS5yZWRNdWwoYmV0YTQucmVkSVN1YihueCkpLnJlZElTdWIoZ2dhbW1hOCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl9kYmwgPSBmdW5jdGlvbiBfZGJsKCkge1xuICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblxuICAvLyA0TSArIDZTICsgMTBBXG4gIHZhciBqeCA9IHRoaXMueDtcbiAgdmFyIGp5ID0gdGhpcy55O1xuICB2YXIganogPSB0aGlzLno7XG4gIHZhciBqejQgPSBqei5yZWRTcXIoKS5yZWRTcXIoKTtcblxuICB2YXIgangyID0gangucmVkU3FyKCk7XG4gIHZhciBqeTIgPSBqeS5yZWRTcXIoKTtcblxuICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuICB2YXIganhkNCA9IGp4LnJlZEFkZChqeCk7XG4gIGp4ZDQgPSBqeGQ0LnJlZElBZGQoanhkNCk7XG4gIHZhciB0MSA9IGp4ZDQucmVkTXVsKGp5Mik7XG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0MS5yZWRBZGQodDEpKTtcbiAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG5cbiAgdmFyIGp5ZDggPSBqeTIucmVkU3FyKCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIHZhciBueSA9IGMucmVkTXVsKHQyKS5yZWRJU3ViKGp5ZDgpO1xuICB2YXIgbnogPSBqeS5yZWRBZGQoankpLnJlZE11bChqeik7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS50cnBsID0gZnVuY3Rpb24gdHJwbCgpIHtcbiAgaWYgKCF0aGlzLmN1cnZlLnplcm9BKVxuICAgIHJldHVybiB0aGlzLmRibCgpLmFkZCh0aGlzKTtcblxuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbCN0cmlwbGluZy10cGwtMjAwNy1ibFxuICAvLyA1TSArIDEwUyArIC4uLlxuXG4gIC8vIFhYID0gWDFeMlxuICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG4gIC8vIFlZID0gWTFeMlxuICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gIC8vIFpaID0gWjFeMlxuICB2YXIgenogPSB0aGlzLnoucmVkU3FyKCk7XG4gIC8vIFlZWVkgPSBZWV4yXG4gIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gIC8vIE0gPSAzICogWFggKyBhICogWloyOyBhID0gMFxuICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCk7XG4gIC8vIE1NID0gTV4yXG4gIHZhciBtbSA9IG0ucmVkU3FyKCk7XG4gIC8vIEUgPSA2ICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKSAtIE1NXG4gIHZhciBlID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgZSA9IGUucmVkSUFkZChlKTtcbiAgZSA9IGUucmVkQWRkKGUpLnJlZElBZGQoZSk7XG4gIGUgPSBlLnJlZElTdWIobW0pO1xuICAvLyBFRSA9IEVeMlxuICB2YXIgZWUgPSBlLnJlZFNxcigpO1xuICAvLyBUID0gMTYqWVlZWVxuICB2YXIgdCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgLy8gVSA9IChNICsgRSleMiAtIE1NIC0gRUUgLSBUXG4gIHZhciB1ID0gbS5yZWRJQWRkKGUpLnJlZFNxcigpLnJlZElTdWIobW0pLnJlZElTdWIoZWUpLnJlZElTdWIodCk7XG4gIC8vIFgzID0gNCAqIChYMSAqIEVFIC0gNCAqIFlZICogVSlcbiAgdmFyIHl5dTQgPSB5eS5yZWRNdWwodSk7XG4gIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG4gIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG4gIHZhciBueCA9IHRoaXMueC5yZWRNdWwoZWUpLnJlZElTdWIoeXl1NCk7XG4gIG54ID0gbngucmVkSUFkZChueCk7XG4gIG54ID0gbngucmVkSUFkZChueCk7XG4gIC8vIFkzID0gOCAqIFkxICogKFUgKiAoVCAtIFUpIC0gRSAqIEVFKVxuICB2YXIgbnkgPSB0aGlzLnkucmVkTXVsKHUucmVkTXVsKHQucmVkSVN1Yih1KSkucmVkSVN1YihlLnJlZE11bChlZSkpKTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgLy8gWjMgPSAoWjEgKyBFKV4yIC0gWlogLSBFRVxuICB2YXIgbnogPSB0aGlzLnoucmVkQWRkKGUpLnJlZFNxcigpLnJlZElTdWIoenopLnJlZElTdWIoZWUpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGssIGtiYXNlKSB7XG4gIGsgPSBuZXcgQk4oaywga2Jhc2UpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKHApIHtcbiAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpXG4gICAgcmV0dXJuIHRoaXMuZXEocC50b0ooKSk7XG5cbiAgaWYgKHRoaXMgPT09IHApXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgLy8geDEgKiB6Ml4yID09IHgyICogejFeMlxuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciBwejIgPSBwLnoucmVkU3FyKCk7XG4gIGlmICh0aGlzLngucmVkTXVsKHB6MikucmVkSVN1YihwLngucmVkTXVsKHoyKSkuY21wbigwKSAhPT0gMClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8geTEgKiB6Ml4zID09IHkyICogejFeM1xuICB2YXIgejMgPSB6Mi5yZWRNdWwodGhpcy56KTtcbiAgdmFyIHB6MyA9IHB6Mi5yZWRNdWwocC56KTtcbiAgcmV0dXJuIHRoaXMueS5yZWRNdWwocHozKS5yZWRJU3ViKHAueS5yZWRNdWwoejMpKS5jbXBuKDApID09PSAwO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5lcVhUb1AgPSBmdW5jdGlvbiBlcVhUb1AoeCkge1xuICB2YXIgenMgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciByeCA9IHgudG9SZWQodGhpcy5jdXJ2ZS5yZWQpLnJlZE11bCh6cyk7XG4gIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB2YXIgeGMgPSB4LmNsb25lKCk7XG4gIHZhciB0ID0gdGhpcy5jdXJ2ZS5yZWROLnJlZE11bCh6cyk7XG4gIGZvciAoOzspIHtcbiAgICB4Yy5pYWRkKHRoaXMuY3VydmUubik7XG4gICAgaWYgKHhjLmNtcCh0aGlzLmN1cnZlLnApID49IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByeC5yZWRJQWRkKHQpO1xuICAgIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuICc8RUMgSlBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIEpQb2ludCB4OiAnICsgdGhpcy54LnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgejogJyArIHRoaXMuei50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICAvLyBYWFggVGhpcyBjb2RlIGFzc3VtZXMgdGhhdCB6ZXJvIGlzIGFsd2F5cyB6ZXJvIGluIHJlZFxuICByZXR1cm4gdGhpcy56LmNtcG4oMCkgPT09IDA7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VydmVzID0gZXhwb3J0cztcblxudmFyIGhhc2ggPSByZXF1aXJlKCdoYXNoLmpzJyk7XG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi9lbGxpcHRpYycpO1xuXG52YXIgYXNzZXJ0ID0gZWxsaXB0aWMudXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBQcmVzZXRDdXJ2ZShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnR5cGUgPT09ICdzaG9ydCcpXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBlbGxpcHRpYy5jdXJ2ZS5zaG9ydChvcHRpb25zKTtcbiAgZWxzZSBpZiAob3B0aW9ucy50eXBlID09PSAnZWR3YXJkcycpXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBlbGxpcHRpYy5jdXJ2ZS5lZHdhcmRzKG9wdGlvbnMpO1xuICBlbHNlXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBlbGxpcHRpYy5jdXJ2ZS5tb250KG9wdGlvbnMpO1xuICB0aGlzLmcgPSB0aGlzLmN1cnZlLmc7XG4gIHRoaXMubiA9IHRoaXMuY3VydmUubjtcbiAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoO1xuXG4gIGFzc2VydCh0aGlzLmcudmFsaWRhdGUoKSwgJ0ludmFsaWQgY3VydmUnKTtcbiAgYXNzZXJ0KHRoaXMuZy5tdWwodGhpcy5uKS5pc0luZmluaXR5KCksICdJbnZhbGlkIGN1cnZlLCBHKk4gIT0gTycpO1xufVxuY3VydmVzLlByZXNldEN1cnZlID0gUHJlc2V0Q3VydmU7XG5cbmZ1bmN0aW9uIGRlZmluZUN1cnZlKG5hbWUsIG9wdGlvbnMpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcywgbmFtZSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3VydmUgPSBuZXcgUHJlc2V0Q3VydmUob3B0aW9ucyk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VydmVzLCBuYW1lLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGN1cnZlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjdXJ2ZTtcbiAgICB9XG4gIH0pO1xufVxuXG5kZWZpbmVDdXJ2ZSgncDE5MicsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6ICdwMTkyJyxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyxcbiAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZjJyxcbiAgYjogJzY0MjEwNTE5IGU1OWM4MGU3IDBmYTdlOWFiIDcyMjQzMDQ5IGZlYjhkZWVjIGMxNDZiOWIxJyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDk5ZGVmODM2IDE0NmJjOWIxIGI0ZDIyODMxJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzE4OGRhODBlIGIwMzA5MGY2IDdjYmYyMGViIDQzYTE4ODAwIGY0ZmYwYWZkIDgyZmYxMDEyJyxcbiAgICAnMDcxOTJiOTUgZmZjOGRhNzggNjMxMDExZWQgNmIyNGNkZDUgNzNmOTc3YTEgMWU3OTQ4MTEnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDIyNCcsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6ICdwMjI0JyxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyxcbiAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlJyxcbiAgYjogJ2I0MDUwYTg1IDBjMDRiM2FiIGY1NDEzMjU2IDUwNDRiMGI3IGQ3YmZkOGJhIDI3MGIzOTQzIDIzNTVmZmI0JyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmYxNmEyIGUwYjhmMDNlIDEzZGQyOTQ1IDVjNWMyYTNkJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJ2I3MGUwY2JkIDZiYjRiZjdmIDMyMTM5MGI5IDRhMDNjMWQzIDU2YzIxMTIyIDM0MzI4MGQ2IDExNWMxZDIxJyxcbiAgICAnYmQzNzYzODggYjVmNzIzZmIgNGMyMmRmZTYgY2Q0Mzc1YTAgNWEwNzQ3NjQgNDRkNTgxOTkgODUwMDdlMzQnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDI1NicsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICc1YWM2MzVkOCBhYTNhOTNlNyBiM2ViYmQ1NSA3Njk4ODZiYyA2NTFkMDZiMCBjYzUzYjBmNiAzYmNlM2MzZSAyN2QyNjA0YicsXG4gIG46ICdmZmZmZmZmZiAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBiY2U2ZmFhZCBhNzE3OWU4NCBmM2I5Y2FjMiBmYzYzMjU1MScsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc2YjE3ZDFmMiBlMTJjNDI0NyBmOGJjZTZlNSA2M2E0NDBmMiA3NzAzN2Q4MSAyZGViMzNhMCBmNGExMzk0NSBkODk4YzI5NicsXG4gICAgJzRmZTM0MmUyIGZlMWE3ZjliIDhlZTdlYjRhIDdjMGY5ZTE2IDJiY2UzMzU3IDZiMzE1ZWNlIGNiYjY0MDY4IDM3YmY1MWY1J1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ3AzODQnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiBudWxsLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZSBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZjJyxcbiAgYjogJ2IzMzEyZmE3IGUyM2VlN2U0IDk4OGUwNTZiIGUzZjgyZDE5IDE4MWQ5YzZlIGZlODE0MTEyIDAzMTQwODhmICcgK1xuICAgICAnNTAxMzg3NWEgYzY1NjM5OGQgOGEyZWQxOWQgMmE4NWM4ZWQgZDNlYzJhZWYnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgYzc2MzRkODEgJyArXG4gICAgICdmNDM3MmRkZiA1ODFhMGRiMiA0OGIwYTc3YSBlY2VjMTk2YSBjY2M1Mjk3MycsXG4gIGhhc2g6IGhhc2guc2hhMzg0LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICdhYTg3Y2EyMiBiZThiMDUzNyA4ZWIxYzcxZSBmMzIwYWQ3NCA2ZTFkM2I2MiA4YmE3OWI5OCA1OWY3NDFlMCA4MjU0MmEzOCAnICtcbiAgICAnNTUwMmYyNWQgYmY1NTI5NmMgM2E1NDVlMzggNzI3NjBhYjcnLFxuICAgICczNjE3ZGU0YSA5NjI2MmM2ZiA1ZDllOThiZiA5MjkyZGMyOSBmOGY0MWRiZCAyODlhMTQ3YyBlOWRhMzExMyBiNWYwYjhjMCAnICtcbiAgICAnMGE2MGIxY2UgMWQ3ZTgxOWQgN2E0MzFkN2MgOTBlYTBlNWYnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDUyMScsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnLFxuICBhOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZjJyxcbiAgYjogJzAwMDAwMDUxIDk1M2ViOTYxIDhlMWM5YTFmIDkyOWEyMWEwIGI2ODU0MGVlIGEyZGE3MjViICcgK1xuICAgICAnOTliMzE1ZjMgYjhiNDg5OTEgOGVmMTA5ZTEgNTYxOTM5NTEgZWM3ZTkzN2IgMTY1MmMwYmQgJyArXG4gICAgICczYmIxYmYwNyAzNTczZGY4OCAzZDJjMzRmMSBlZjQ1MWZkNCA2YjUwM2YwMCcsXG4gIG46ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZhIDUxODY4NzgzIGJmMmY5NjZiIDdmY2MwMTQ4ICcgK1xuICAgICAnZjcwOWE1ZDAgM2JiNWM5YjggODk5YzQ3YWUgYmI2ZmI3MWUgOTEzODY0MDknLFxuICBoYXNoOiBoYXNoLnNoYTUxMixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMDAwMDAwYzYgODU4ZTA2YjcgMDQwNGU5Y2QgOWUzZWNiNjYgMjM5NWI0NDIgOWM2NDgxMzkgJyArXG4gICAgJzA1M2ZiNTIxIGY4MjhhZjYwIDZiNGQzZGJhIGExNGI1ZTc3IGVmZTc1OTI4IGZlMWRjMTI3ICcgK1xuICAgICdhMmZmYThkZSAzMzQ4YjNjMSA4NTZhNDI5YiBmOTdlN2UzMSBjMmU1YmQ2NicsXG4gICAgJzAwMDAwMTE4IDM5Mjk2YTc4IDlhM2JjMDA0IDVjOGE1ZmI0IDJjN2QxYmQ5IDk4ZjU0NDQ5ICcgK1xuICAgICc1NzliNDQ2OCAxN2FmYmQxNyAyNzNlNjYyYyA5N2VlNzI5OSA1ZWY0MjY0MCBjNTUwYjkwMSAnICtcbiAgICAnM2ZhZDA3NjEgMzUzYzcwODYgYTI3MmMyNDAgODhiZTk0NzYgOWZkMTY2NTAnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgnY3VydmUyNTUxOScsIHtcbiAgdHlwZTogJ21vbnQnLFxuICBwcmltZTogJ3AyNTUxOScsXG4gIHA6ICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyxcbiAgYTogJzc2ZDA2JyxcbiAgYjogJzEnLFxuICBuOiAnMTAwMDAwMDAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwIDE0ZGVmOWRlYTJmNzljZDYgNTgxMjYzMWE1Y2Y1ZDNlZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc5J1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ2VkMjU1MTknLCB7XG4gIHR5cGU6ICdlZHdhcmRzJyxcbiAgcHJpbWU6ICdwMjU1MTknLFxuICBwOiAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcsXG4gIGE6ICctMScsXG4gIGM6ICcxJyxcbiAgLy8gLTEyMTY2NSAqICgxMjE2NjZeKC0xKSkgKG1vZCBQKVxuICBkOiAnNTIwMzZjZWUyYjZmZmU3MyA4Y2M3NDA3OTc3NzllODk4IDAwNzAwYTRkNDE0MWQ4YWIgNzVlYjRkY2ExMzU5NzhhMycsXG4gIG46ICcxMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAgMTRkZWY5ZGVhMmY3OWNkNiA1ODEyNjMxYTVjZjVkM2VkJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzIxNjkzNmQzY2Q2ZTUzZmVjMGE0ZTIzMWZkZDZkYzVjNjkyY2M3NjA5NTI1YTdiMmM5NTYyZDYwOGYyNWQ1MWEnLFxuXG4gICAgLy8gNC81XG4gICAgJzY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NTgnXG4gIF1cbn0pO1xuXG52YXIgcHJlO1xudHJ5IHtcbiAgcHJlID0gcmVxdWlyZSgnLi9wcmVjb21wdXRlZC9zZWNwMjU2azEnKTtcbn0gY2F0Y2ggKGUpIHtcbiAgcHJlID0gdW5kZWZpbmVkO1xufVxuXG5kZWZpbmVDdXJ2ZSgnc2VjcDI1NmsxJywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogJ2syNTYnLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnLFxuICBhOiAnMCcsXG4gIGI6ICc3JyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGJhYWVkY2U2IGFmNDhhMDNiIGJmZDI1ZThjIGQwMzY0MTQxJyxcbiAgaDogJzEnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcblxuICAvLyBQcmVjb21wdXRlZCBlbmRvbW9ycGhpc21cbiAgYmV0YTogJzdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnLFxuICBsYW1iZGE6ICc1MzYzYWQ0Y2MwNWMzMGUwYTUyNjFjMDI4ODEyNjQ1YTEyMmUyMmVhMjA4MTY2NzhkZjAyOTY3YzFiMjNiZDcyJyxcbiAgYmFzaXM6IFtcbiAgICB7XG4gICAgICBhOiAnMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnLFxuICAgICAgYjogJy1lNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMydcbiAgICB9LFxuICAgIHtcbiAgICAgIGE6ICcxMTRjYTUwZjdhOGUyZjNmNjU3YzExMDhkOWQ0NGNmZDgnLFxuICAgICAgYjogJzMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1J1xuICAgIH1cbiAgXSxcblxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc3OWJlNjY3ZWY5ZGNiYmFjNTVhMDYyOTVjZTg3MGIwNzAyOWJmY2RiMmRjZTI4ZDk1OWYyODE1YjE2ZjgxNzk4JyxcbiAgICAnNDgzYWRhNzcyNmEzYzQ2NTVkYTRmYmZjMGUxMTA4YThmZDE3YjQ0OGE2ODU1NDE5OWM0N2QwOGZmYjEwZDRiOCcsXG4gICAgcHJlXG4gIF1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIEhtYWNEUkJHID0gcmVxdWlyZSgnaG1hYy1kcmJnJyk7XG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG52YXIgS2V5UGFpciA9IHJlcXVpcmUoJy4va2V5Jyk7XG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9zaWduYXR1cmUnKTtcblxuZnVuY3Rpb24gRUMob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRUMpKVxuICAgIHJldHVybiBuZXcgRUMob3B0aW9ucyk7XG5cbiAgLy8gU2hvcnRjdXQgYGVsbGlwdGljLmVjKGN1cnZlLW5hbWUpYFxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgYXNzZXJ0KGVsbGlwdGljLmN1cnZlcy5oYXNPd25Qcm9wZXJ0eShvcHRpb25zKSwgJ1Vua25vd24gY3VydmUgJyArIG9wdGlvbnMpO1xuXG4gICAgb3B0aW9ucyA9IGVsbGlwdGljLmN1cnZlc1tvcHRpb25zXTtcbiAgfVxuXG4gIC8vIFNob3J0Y3V0IGZvciBgZWxsaXB0aWMuZWMoZWxsaXB0aWMuY3VydmVzLmN1cnZlTmFtZSlgXG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgZWxsaXB0aWMuY3VydmVzLlByZXNldEN1cnZlKVxuICAgIG9wdGlvbnMgPSB7IGN1cnZlOiBvcHRpb25zIH07XG5cbiAgdGhpcy5jdXJ2ZSA9IG9wdGlvbnMuY3VydmUuY3VydmU7XG4gIHRoaXMubiA9IHRoaXMuY3VydmUubjtcbiAgdGhpcy5uaCA9IHRoaXMubi51c2hybigxKTtcbiAgdGhpcy5nID0gdGhpcy5jdXJ2ZS5nO1xuXG4gIC8vIFBvaW50IG9uIGN1cnZlXG4gIHRoaXMuZyA9IG9wdGlvbnMuY3VydmUuZztcbiAgdGhpcy5nLnByZWNvbXB1dGUob3B0aW9ucy5jdXJ2ZS5uLmJpdExlbmd0aCgpICsgMSk7XG5cbiAgLy8gSGFzaCBmb3IgZnVuY3Rpb24gZm9yIERSQkdcbiAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoIHx8IG9wdGlvbnMuY3VydmUuaGFzaDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRUM7XG5cbkVDLnByb3RvdHlwZS5rZXlQYWlyID0gZnVuY3Rpb24ga2V5UGFpcihvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgS2V5UGFpcih0aGlzLCBvcHRpb25zKTtcbn07XG5cbkVDLnByb3RvdHlwZS5rZXlGcm9tUHJpdmF0ZSA9IGZ1bmN0aW9uIGtleUZyb21Qcml2YXRlKHByaXYsIGVuYykge1xuICByZXR1cm4gS2V5UGFpci5mcm9tUHJpdmF0ZSh0aGlzLCBwcml2LCBlbmMpO1xufTtcblxuRUMucHJvdG90eXBlLmtleUZyb21QdWJsaWMgPSBmdW5jdGlvbiBrZXlGcm9tUHVibGljKHB1YiwgZW5jKSB7XG4gIHJldHVybiBLZXlQYWlyLmZyb21QdWJsaWModGhpcywgcHViLCBlbmMpO1xufTtcblxuRUMucHJvdG90eXBlLmdlbktleVBhaXIgPSBmdW5jdGlvbiBnZW5LZXlQYWlyKG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fTtcblxuICAvLyBJbnN0YW50aWF0ZSBIbWFjX0RSQkdcbiAgdmFyIGRyYmcgPSBuZXcgSG1hY0RSQkcoe1xuICAgIGhhc2g6IHRoaXMuaGFzaCxcbiAgICBwZXJzOiBvcHRpb25zLnBlcnMsXG4gICAgcGVyc0VuYzogb3B0aW9ucy5wZXJzRW5jIHx8ICd1dGY4JyxcbiAgICBlbnRyb3B5OiBvcHRpb25zLmVudHJvcHkgfHwgZWxsaXB0aWMucmFuZCh0aGlzLmhhc2guaG1hY1N0cmVuZ3RoKSxcbiAgICBlbnRyb3B5RW5jOiBvcHRpb25zLmVudHJvcHkgJiYgb3B0aW9ucy5lbnRyb3B5RW5jIHx8ICd1dGY4JyxcbiAgICBub25jZTogdGhpcy5uLnRvQXJyYXkoKVxuICB9KTtcblxuICB2YXIgYnl0ZXMgPSB0aGlzLm4uYnl0ZUxlbmd0aCgpO1xuICB2YXIgbnMyID0gdGhpcy5uLnN1YihuZXcgQk4oMikpO1xuICBkbyB7XG4gICAgdmFyIHByaXYgPSBuZXcgQk4oZHJiZy5nZW5lcmF0ZShieXRlcykpO1xuICAgIGlmIChwcml2LmNtcChuczIpID4gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgcHJpdi5pYWRkbigxKTtcbiAgICByZXR1cm4gdGhpcy5rZXlGcm9tUHJpdmF0ZShwcml2KTtcbiAgfSB3aGlsZSAodHJ1ZSk7XG59O1xuXG5FQy5wcm90b3R5cGUuX3RydW5jYXRlVG9OID0gZnVuY3Rpb24gdHJ1bmNhdGVUb04obXNnLCB0cnVuY09ubHkpIHtcbiAgdmFyIGRlbHRhID0gbXNnLmJ5dGVMZW5ndGgoKSAqIDggLSB0aGlzLm4uYml0TGVuZ3RoKCk7XG4gIGlmIChkZWx0YSA+IDApXG4gICAgbXNnID0gbXNnLnVzaHJuKGRlbHRhKTtcbiAgaWYgKCF0cnVuY09ubHkgJiYgbXNnLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIG1zZy5zdWIodGhpcy5uKTtcbiAgZWxzZVxuICAgIHJldHVybiBtc2c7XG59O1xuXG5FQy5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obXNnLCBrZXksIGVuYywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGVuYyA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0gZW5jO1xuICAgIGVuYyA9IG51bGw7XG4gIH1cbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fTtcblxuICBrZXkgPSB0aGlzLmtleUZyb21Qcml2YXRlKGtleSwgZW5jKTtcbiAgbXNnID0gdGhpcy5fdHJ1bmNhdGVUb04obmV3IEJOKG1zZywgMTYpKTtcblxuICAvLyBaZXJvLWV4dGVuZCBrZXkgdG8gcHJvdmlkZSBlbm91Z2ggZW50cm9weVxuICB2YXIgYnl0ZXMgPSB0aGlzLm4uYnl0ZUxlbmd0aCgpO1xuICB2YXIgYmtleSA9IGtleS5nZXRQcml2YXRlKCkudG9BcnJheSgnYmUnLCBieXRlcyk7XG5cbiAgLy8gWmVyby1leHRlbmQgbm9uY2UgdG8gaGF2ZSB0aGUgc2FtZSBieXRlIHNpemUgYXMgTlxuICB2YXIgbm9uY2UgPSBtc2cudG9BcnJheSgnYmUnLCBieXRlcyk7XG5cbiAgLy8gSW5zdGFudGlhdGUgSG1hY19EUkJHXG4gIHZhciBkcmJnID0gbmV3IEhtYWNEUkJHKHtcbiAgICBoYXNoOiB0aGlzLmhhc2gsXG4gICAgZW50cm9weTogYmtleSxcbiAgICBub25jZTogbm9uY2UsXG4gICAgcGVyczogb3B0aW9ucy5wZXJzLFxuICAgIHBlcnNFbmM6IG9wdGlvbnMucGVyc0VuYyB8fCAndXRmOCdcbiAgfSk7XG5cbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlXG4gIHZhciBuczEgPSB0aGlzLm4uc3ViKG5ldyBCTigxKSk7XG5cbiAgZm9yICh2YXIgaXRlciA9IDA7IHRydWU7IGl0ZXIrKykge1xuICAgIHZhciBrID0gb3B0aW9ucy5rID9cbiAgICAgICAgb3B0aW9ucy5rKGl0ZXIpIDpcbiAgICAgICAgbmV3IEJOKGRyYmcuZ2VuZXJhdGUodGhpcy5uLmJ5dGVMZW5ndGgoKSkpO1xuICAgIGsgPSB0aGlzLl90cnVuY2F0ZVRvTihrLCB0cnVlKTtcbiAgICBpZiAoay5jbXBuKDEpIDw9IDAgfHwgay5jbXAobnMxKSA+PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIga3AgPSB0aGlzLmcubXVsKGspO1xuICAgIGlmIChrcC5pc0luZmluaXR5KCkpXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciBrcFggPSBrcC5nZXRYKCk7XG4gICAgdmFyIHIgPSBrcFgudW1vZCh0aGlzLm4pO1xuICAgIGlmIChyLmNtcG4oMCkgPT09IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciBzID0gay5pbnZtKHRoaXMubikubXVsKHIubXVsKGtleS5nZXRQcml2YXRlKCkpLmlhZGQobXNnKSk7XG4gICAgcyA9IHMudW1vZCh0aGlzLm4pO1xuICAgIGlmIChzLmNtcG4oMCkgPT09IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciByZWNvdmVyeVBhcmFtID0gKGtwLmdldFkoKS5pc09kZCgpID8gMSA6IDApIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChrcFguY21wKHIpICE9PSAwID8gMiA6IDApO1xuXG4gICAgLy8gVXNlIGNvbXBsZW1lbnQgb2YgYHNgLCBpZiBpdCBpcyA+IGBuIC8gMmBcbiAgICBpZiAob3B0aW9ucy5jYW5vbmljYWwgJiYgcy5jbXAodGhpcy5uaCkgPiAwKSB7XG4gICAgICBzID0gdGhpcy5uLnN1YihzKTtcbiAgICAgIHJlY292ZXJ5UGFyYW0gXj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh7IHI6IHIsIHM6IHMsIHJlY292ZXJ5UGFyYW06IHJlY292ZXJ5UGFyYW0gfSk7XG4gIH1cbn07XG5cbkVDLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobXNnLCBzaWduYXR1cmUsIGtleSwgZW5jKSB7XG4gIG1zZyA9IHRoaXMuX3RydW5jYXRlVG9OKG5ldyBCTihtc2csIDE2KSk7XG4gIGtleSA9IHRoaXMua2V5RnJvbVB1YmxpYyhrZXksIGVuYyk7XG4gIHNpZ25hdHVyZSA9IG5ldyBTaWduYXR1cmUoc2lnbmF0dXJlLCAnaGV4Jyk7XG5cbiAgLy8gUGVyZm9ybSBwcmltaXRpdmUgdmFsdWVzIHZhbGlkYXRpb25cbiAgdmFyIHIgPSBzaWduYXR1cmUucjtcbiAgdmFyIHMgPSBzaWduYXR1cmUucztcbiAgaWYgKHIuY21wbigxKSA8IDAgfHwgci5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHMuY21wbigxKSA8IDAgfHwgcy5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBWYWxpZGF0ZSBzaWduYXR1cmVcbiAgdmFyIHNpbnYgPSBzLmludm0odGhpcy5uKTtcbiAgdmFyIHUxID0gc2ludi5tdWwobXNnKS51bW9kKHRoaXMubik7XG4gIHZhciB1MiA9IHNpbnYubXVsKHIpLnVtb2QodGhpcy5uKTtcblxuICBpZiAoIXRoaXMuY3VydmUuX21heHdlbGxUcmljaykge1xuICAgIHZhciBwID0gdGhpcy5nLm11bEFkZCh1MSwga2V5LmdldFB1YmxpYygpLCB1Mik7XG4gICAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHAuZ2V0WCgpLnVtb2QodGhpcy5uKS5jbXAocikgPT09IDA7XG4gIH1cblxuICAvLyBOT1RFOiBHcmVnIE1heHdlbGwncyB0cmljaywgaW5zcGlyZWQgYnk6XG4gIC8vIGh0dHBzOi8vZ2l0LmlvL3ZhZDNLXG5cbiAgdmFyIHAgPSB0aGlzLmcuam11bEFkZCh1MSwga2V5LmdldFB1YmxpYygpLCB1Mik7XG4gIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gQ29tcGFyZSBgcC54YCBvZiBKYWNvYmlhbiBwb2ludCB3aXRoIGByYCxcbiAgLy8gdGhpcyB3aWxsIGRvIGBwLnggPT0gciAqIHAuel4yYCBpbnN0ZWFkIG9mIG11bHRpcGx5aW5nIGBwLnhgIGJ5IHRoZVxuICAvLyBpbnZlcnNlIG9mIGBwLnpeMmBcbiAgcmV0dXJuIHAuZXFYVG9QKHIpO1xufTtcblxuRUMucHJvdG90eXBlLnJlY292ZXJQdWJLZXkgPSBmdW5jdGlvbihtc2csIHNpZ25hdHVyZSwgaiwgZW5jKSB7XG4gIGFzc2VydCgoMyAmIGopID09PSBqLCAnVGhlIHJlY292ZXJ5IHBhcmFtIGlzIG1vcmUgdGhhbiB0d28gYml0cycpO1xuICBzaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKHNpZ25hdHVyZSwgZW5jKTtcblxuICB2YXIgbiA9IHRoaXMubjtcbiAgdmFyIGUgPSBuZXcgQk4obXNnKTtcbiAgdmFyIHIgPSBzaWduYXR1cmUucjtcbiAgdmFyIHMgPSBzaWduYXR1cmUucztcblxuICAvLyBBIHNldCBMU0Igc2lnbmlmaWVzIHRoYXQgdGhlIHktY29vcmRpbmF0ZSBpcyBvZGRcbiAgdmFyIGlzWU9kZCA9IGogJiAxO1xuICB2YXIgaXNTZWNvbmRLZXkgPSBqID4+IDE7XG4gIGlmIChyLmNtcCh0aGlzLmN1cnZlLnAudW1vZCh0aGlzLmN1cnZlLm4pKSA+PSAwICYmIGlzU2Vjb25kS2V5KVxuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgc2VuY29uZCBrZXkgY2FuZGluYXRlJyk7XG5cbiAgLy8gMS4xLiBMZXQgeCA9IHIgKyBqbi5cbiAgaWYgKGlzU2Vjb25kS2V5KVxuICAgIHIgPSB0aGlzLmN1cnZlLnBvaW50RnJvbVgoci5hZGQodGhpcy5jdXJ2ZS5uKSwgaXNZT2RkKTtcbiAgZWxzZVxuICAgIHIgPSB0aGlzLmN1cnZlLnBvaW50RnJvbVgociwgaXNZT2RkKTtcblxuICB2YXIgckludiA9IHNpZ25hdHVyZS5yLmludm0obik7XG4gIHZhciBzMSA9IG4uc3ViKGUpLm11bChySW52KS51bW9kKG4pO1xuICB2YXIgczIgPSBzLm11bChySW52KS51bW9kKG4pO1xuXG4gIC8vIDEuNi4xIENvbXB1dGUgUSA9IHJeLTEgKHNSIC0gIGVHKVxuICAvLyAgICAgICAgICAgICAgIFEgPSByXi0xIChzUiArIC1lRylcbiAgcmV0dXJuIHRoaXMuZy5tdWxBZGQoczEsIHIsIHMyKTtcbn07XG5cbkVDLnByb3RvdHlwZS5nZXRLZXlSZWNvdmVyeVBhcmFtID0gZnVuY3Rpb24oZSwgc2lnbmF0dXJlLCBRLCBlbmMpIHtcbiAgc2lnbmF0dXJlID0gbmV3IFNpZ25hdHVyZShzaWduYXR1cmUsIGVuYyk7XG4gIGlmIChzaWduYXR1cmUucmVjb3ZlcnlQYXJhbSAhPT0gbnVsbClcbiAgICByZXR1cm4gc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICB2YXIgUXByaW1lO1xuICAgIHRyeSB7XG4gICAgICBRcHJpbWUgPSB0aGlzLnJlY292ZXJQdWJLZXkoZSwgc2lnbmF0dXJlLCBpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoUXByaW1lLmVxKFEpKVxuICAgICAgcmV0dXJuIGk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCB2YWxpZCByZWNvdmVyeSBmYWN0b3InKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBLZXlQYWlyKGVjLCBvcHRpb25zKSB7XG4gIHRoaXMuZWMgPSBlYztcbiAgdGhpcy5wcml2ID0gbnVsbDtcbiAgdGhpcy5wdWIgPSBudWxsO1xuXG4gIC8vIEtleVBhaXIoZWMsIHsgcHJpdjogLi4uLCBwdWI6IC4uLiB9KVxuICBpZiAob3B0aW9ucy5wcml2KVxuICAgIHRoaXMuX2ltcG9ydFByaXZhdGUob3B0aW9ucy5wcml2LCBvcHRpb25zLnByaXZFbmMpO1xuICBpZiAob3B0aW9ucy5wdWIpXG4gICAgdGhpcy5faW1wb3J0UHVibGljKG9wdGlvbnMucHViLCBvcHRpb25zLnB1YkVuYyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEtleVBhaXI7XG5cbktleVBhaXIuZnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGZyb21QdWJsaWMoZWMsIHB1YiwgZW5jKSB7XG4gIGlmIChwdWIgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBwdWI7XG5cbiAgcmV0dXJuIG5ldyBLZXlQYWlyKGVjLCB7XG4gICAgcHViOiBwdWIsXG4gICAgcHViRW5jOiBlbmNcbiAgfSk7XG59O1xuXG5LZXlQYWlyLmZyb21Qcml2YXRlID0gZnVuY3Rpb24gZnJvbVByaXZhdGUoZWMsIHByaXYsIGVuYykge1xuICBpZiAocHJpdiBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgcmV0dXJuIHByaXY7XG5cbiAgcmV0dXJuIG5ldyBLZXlQYWlyKGVjLCB7XG4gICAgcHJpdjogcHJpdixcbiAgICBwcml2RW5jOiBlbmNcbiAgfSk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICB2YXIgcHViID0gdGhpcy5nZXRQdWJsaWMoKTtcblxuICBpZiAocHViLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdJbnZhbGlkIHB1YmxpYyBrZXknIH07XG4gIGlmICghcHViLnZhbGlkYXRlKCkpXG4gICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnUHVibGljIGtleSBpcyBub3QgYSBwb2ludCcgfTtcbiAgaWYgKCFwdWIubXVsKHRoaXMuZWMuY3VydmUubikuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ1B1YmxpYyBrZXkgKiBOICE9IE8nIH07XG5cbiAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCByZWFzb246IG51bGwgfTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmdldFB1YmxpYyA9IGZ1bmN0aW9uIGdldFB1YmxpYyhjb21wYWN0LCBlbmMpIHtcbiAgLy8gY29tcGFjdCBpcyBvcHRpb25hbCBhcmd1bWVudFxuICBpZiAodHlwZW9mIGNvbXBhY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jID0gY29tcGFjdDtcbiAgICBjb21wYWN0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICghdGhpcy5wdWIpXG4gICAgdGhpcy5wdWIgPSB0aGlzLmVjLmcubXVsKHRoaXMucHJpdik7XG5cbiAgaWYgKCFlbmMpXG4gICAgcmV0dXJuIHRoaXMucHViO1xuXG4gIHJldHVybiB0aGlzLnB1Yi5lbmNvZGUoZW5jLCBjb21wYWN0KTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmdldFByaXZhdGUgPSBmdW5jdGlvbiBnZXRQcml2YXRlKGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdGhpcy5wcml2LnRvU3RyaW5nKDE2LCAyKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLnByaXY7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5faW1wb3J0UHJpdmF0ZSA9IGZ1bmN0aW9uIF9pbXBvcnRQcml2YXRlKGtleSwgZW5jKSB7XG4gIHRoaXMucHJpdiA9IG5ldyBCTihrZXksIGVuYyB8fCAxNik7XG5cbiAgLy8gRW5zdXJlIHRoYXQgdGhlIHByaXYgd29uJ3QgYmUgYmlnZ2VyIHRoYW4gbiwgb3RoZXJ3aXNlIHdlIG1heSBmYWlsXG4gIC8vIGluIGZpeGVkIG11bHRpcGxpY2F0aW9uIG1ldGhvZFxuICB0aGlzLnByaXYgPSB0aGlzLnByaXYudW1vZCh0aGlzLmVjLmN1cnZlLm4pO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFB1YmxpYyA9IGZ1bmN0aW9uIF9pbXBvcnRQdWJsaWMoa2V5LCBlbmMpIHtcbiAgaWYgKGtleS54IHx8IGtleS55KSB7XG4gICAgLy8gTW9udGdvbWVyeSBwb2ludHMgb25seSBoYXZlIGFuIGB4YCBjb29yZGluYXRlLlxuICAgIC8vIFdlaWVyc3RyYXNzL0Vkd2FyZHMgcG9pbnRzIG9uIHRoZSBvdGhlciBoYW5kIGhhdmUgYm90aCBgeGAgYW5kXG4gICAgLy8gYHlgIGNvb3JkaW5hdGVzLlxuICAgIGlmICh0aGlzLmVjLmN1cnZlLnR5cGUgPT09ICdtb250Jykge1xuICAgICAgYXNzZXJ0KGtleS54LCAnTmVlZCB4IGNvb3JkaW5hdGUnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWMuY3VydmUudHlwZSA9PT0gJ3Nob3J0JyB8fFxuICAgICAgICAgICAgICAgdGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnZWR3YXJkcycpIHtcbiAgICAgIGFzc2VydChrZXkueCAmJiBrZXkueSwgJ05lZWQgYm90aCB4IGFuZCB5IGNvb3JkaW5hdGUnKTtcbiAgICB9XG4gICAgdGhpcy5wdWIgPSB0aGlzLmVjLmN1cnZlLnBvaW50KGtleS54LCBrZXkueSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucHViID0gdGhpcy5lYy5jdXJ2ZS5kZWNvZGVQb2ludChrZXksIGVuYyk7XG59O1xuXG4vLyBFQ0RIXG5LZXlQYWlyLnByb3RvdHlwZS5kZXJpdmUgPSBmdW5jdGlvbiBkZXJpdmUocHViKSB7XG4gIHJldHVybiBwdWIubXVsKHRoaXMucHJpdikuZ2V0WCgpO1xufTtcblxuLy8gRUNEU0FcbktleVBhaXIucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1zZywgZW5jLCBvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmVjLnNpZ24obXNnLCB0aGlzLCBlbmMsIG9wdGlvbnMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1zZywgc2lnbmF0dXJlKSB7XG4gIHJldHVybiB0aGlzLmVjLnZlcmlmeShtc2csIHNpZ25hdHVyZSwgdGhpcyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgcmV0dXJuICc8S2V5IHByaXY6ICcgKyAodGhpcy5wcml2ICYmIHRoaXMucHJpdi50b1N0cmluZygxNiwgMikpICtcbiAgICAgICAgICcgcHViOiAnICsgKHRoaXMucHViICYmIHRoaXMucHViLmluc3BlY3QoKSkgKyAnID4nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcblxudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gU2lnbmF0dXJlKG9wdGlvbnMsIGVuYykge1xuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIFNpZ25hdHVyZSlcbiAgICByZXR1cm4gb3B0aW9ucztcblxuICBpZiAodGhpcy5faW1wb3J0REVSKG9wdGlvbnMsIGVuYykpXG4gICAgcmV0dXJuO1xuXG4gIGFzc2VydChvcHRpb25zLnIgJiYgb3B0aW9ucy5zLCAnU2lnbmF0dXJlIHdpdGhvdXQgciBvciBzJyk7XG4gIHRoaXMuciA9IG5ldyBCTihvcHRpb25zLnIsIDE2KTtcbiAgdGhpcy5zID0gbmV3IEJOKG9wdGlvbnMucywgMTYpO1xuICBpZiAob3B0aW9ucy5yZWNvdmVyeVBhcmFtID09PSB1bmRlZmluZWQpXG4gICAgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbDtcbiAgZWxzZVxuICAgIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG9wdGlvbnMucmVjb3ZlcnlQYXJhbTtcbn1cbm1vZHVsZS5leHBvcnRzID0gU2lnbmF0dXJlO1xuXG5mdW5jdGlvbiBQb3NpdGlvbigpIHtcbiAgdGhpcy5wbGFjZSA9IDA7XG59XG5cbmZ1bmN0aW9uIGdldExlbmd0aChidWYsIHApIHtcbiAgdmFyIGluaXRpYWwgPSBidWZbcC5wbGFjZSsrXTtcbiAgaWYgKCEoaW5pdGlhbCAmIDB4ODApKSB7XG4gICAgcmV0dXJuIGluaXRpYWw7XG4gIH1cbiAgdmFyIG9jdGV0TGVuID0gaW5pdGlhbCAmIDB4ZjtcbiAgdmFyIHZhbCA9IDA7XG4gIGZvciAodmFyIGkgPSAwLCBvZmYgPSBwLnBsYWNlOyBpIDwgb2N0ZXRMZW47IGkrKywgb2ZmKyspIHtcbiAgICB2YWwgPDw9IDg7XG4gICAgdmFsIHw9IGJ1ZltvZmZdO1xuICB9XG4gIHAucGxhY2UgPSBvZmY7XG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIHJtUGFkZGluZyhidWYpIHtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aCAtIDE7XG4gIHdoaWxlICghYnVmW2ldICYmICEoYnVmW2kgKyAxXSAmIDB4ODApICYmIGkgPCBsZW4pIHtcbiAgICBpKys7XG4gIH1cbiAgaWYgKGkgPT09IDApIHtcbiAgICByZXR1cm4gYnVmO1xuICB9XG4gIHJldHVybiBidWYuc2xpY2UoaSk7XG59XG5cblNpZ25hdHVyZS5wcm90b3R5cGUuX2ltcG9ydERFUiA9IGZ1bmN0aW9uIF9pbXBvcnRERVIoZGF0YSwgZW5jKSB7XG4gIGRhdGEgPSB1dGlscy50b0FycmF5KGRhdGEsIGVuYyk7XG4gIHZhciBwID0gbmV3IFBvc2l0aW9uKCk7XG4gIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MzApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcbiAgaWYgKChsZW4gKyBwLnBsYWNlKSAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgwMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcmxlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcbiAgdmFyIHIgPSBkYXRhLnNsaWNlKHAucGxhY2UsIHJsZW4gKyBwLnBsYWNlKTtcbiAgcC5wbGFjZSArPSBybGVuO1xuICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBzbGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuICBpZiAoZGF0YS5sZW5ndGggIT09IHNsZW4gKyBwLnBsYWNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBzID0gZGF0YS5zbGljZShwLnBsYWNlLCBzbGVuICsgcC5wbGFjZSk7XG4gIGlmIChyWzBdID09PSAwICYmIChyWzFdICYgMHg4MCkpIHtcbiAgICByID0gci5zbGljZSgxKTtcbiAgfVxuICBpZiAoc1swXSA9PT0gMCAmJiAoc1sxXSAmIDB4ODApKSB7XG4gICAgcyA9IHMuc2xpY2UoMSk7XG4gIH1cblxuICB0aGlzLnIgPSBuZXcgQk4ocik7XG4gIHRoaXMucyA9IG5ldyBCTihzKTtcbiAgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdExlbmd0aChhcnIsIGxlbikge1xuICBpZiAobGVuIDwgMHg4MCkge1xuICAgIGFyci5wdXNoKGxlbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvY3RldHMgPSAxICsgKE1hdGgubG9nKGxlbikgLyBNYXRoLkxOMiA+Pj4gMyk7XG4gIGFyci5wdXNoKG9jdGV0cyB8IDB4ODApO1xuICB3aGlsZSAoLS1vY3RldHMpIHtcbiAgICBhcnIucHVzaCgobGVuID4+PiAob2N0ZXRzIDw8IDMpKSAmIDB4ZmYpO1xuICB9XG4gIGFyci5wdXNoKGxlbik7XG59XG5cblNpZ25hdHVyZS5wcm90b3R5cGUudG9ERVIgPSBmdW5jdGlvbiB0b0RFUihlbmMpIHtcbiAgdmFyIHIgPSB0aGlzLnIudG9BcnJheSgpO1xuICB2YXIgcyA9IHRoaXMucy50b0FycmF5KCk7XG5cbiAgLy8gUGFkIHZhbHVlc1xuICBpZiAoclswXSAmIDB4ODApXG4gICAgciA9IFsgMCBdLmNvbmNhdChyKTtcbiAgLy8gUGFkIHZhbHVlc1xuICBpZiAoc1swXSAmIDB4ODApXG4gICAgcyA9IFsgMCBdLmNvbmNhdChzKTtcblxuICByID0gcm1QYWRkaW5nKHIpO1xuICBzID0gcm1QYWRkaW5nKHMpO1xuXG4gIHdoaWxlICghc1swXSAmJiAhKHNbMV0gJiAweDgwKSkge1xuICAgIHMgPSBzLnNsaWNlKDEpO1xuICB9XG4gIHZhciBhcnIgPSBbIDB4MDIgXTtcbiAgY29uc3RydWN0TGVuZ3RoKGFyciwgci5sZW5ndGgpO1xuICBhcnIgPSBhcnIuY29uY2F0KHIpO1xuICBhcnIucHVzaCgweDAyKTtcbiAgY29uc3RydWN0TGVuZ3RoKGFyciwgcy5sZW5ndGgpO1xuICB2YXIgYmFja0hhbGYgPSBhcnIuY29uY2F0KHMpO1xuICB2YXIgcmVzID0gWyAweDMwIF07XG4gIGNvbnN0cnVjdExlbmd0aChyZXMsIGJhY2tIYWxmLmxlbmd0aCk7XG4gIHJlcyA9IHJlcy5jb25jYXQoYmFja0hhbGYpO1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHJlcywgZW5jKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNoID0gcmVxdWlyZSgnaGFzaC5qcycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcbnZhciBwYXJzZUJ5dGVzID0gdXRpbHMucGFyc2VCeXRlcztcbnZhciBLZXlQYWlyID0gcmVxdWlyZSgnLi9rZXknKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuL3NpZ25hdHVyZScpO1xuXG5mdW5jdGlvbiBFRERTQShjdXJ2ZSkge1xuICBhc3NlcnQoY3VydmUgPT09ICdlZDI1NTE5JywgJ29ubHkgdGVzdGVkIHdpdGggZWQyNTUxOSBzbyBmYXInKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRUREU0EpKVxuICAgIHJldHVybiBuZXcgRUREU0EoY3VydmUpO1xuXG4gIHZhciBjdXJ2ZSA9IGVsbGlwdGljLmN1cnZlc1tjdXJ2ZV0uY3VydmU7XG4gIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgdGhpcy5nID0gY3VydmUuZztcbiAgdGhpcy5nLnByZWNvbXB1dGUoY3VydmUubi5iaXRMZW5ndGgoKSArIDEpO1xuXG4gIHRoaXMucG9pbnRDbGFzcyA9IGN1cnZlLnBvaW50KCkuY29uc3RydWN0b3I7XG4gIHRoaXMuZW5jb2RpbmdMZW5ndGggPSBNYXRoLmNlaWwoY3VydmUubi5iaXRMZW5ndGgoKSAvIDgpO1xuICB0aGlzLmhhc2ggPSBoYXNoLnNoYTUxMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFRERTQTtcblxuLyoqXG4qIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBtZXNzYWdlIC0gbWVzc2FnZSBieXRlc1xuKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xLZXlQYWlyfSBzZWNyZXQgLSBzZWNyZXQgYnl0ZXMgb3IgYSBrZXlwYWlyXG4qIEByZXR1cm5zIHtTaWduYXR1cmV9IC0gc2lnbmF0dXJlXG4qL1xuRUREU0EucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1lc3NhZ2UsIHNlY3JldCkge1xuICBtZXNzYWdlID0gcGFyc2VCeXRlcyhtZXNzYWdlKTtcbiAgdmFyIGtleSA9IHRoaXMua2V5RnJvbVNlY3JldChzZWNyZXQpO1xuICB2YXIgciA9IHRoaXMuaGFzaEludChrZXkubWVzc2FnZVByZWZpeCgpLCBtZXNzYWdlKTtcbiAgdmFyIFIgPSB0aGlzLmcubXVsKHIpO1xuICB2YXIgUmVuY29kZWQgPSB0aGlzLmVuY29kZVBvaW50KFIpO1xuICB2YXIgc18gPSB0aGlzLmhhc2hJbnQoUmVuY29kZWQsIGtleS5wdWJCeXRlcygpLCBtZXNzYWdlKVxuICAgICAgICAgICAgICAgLm11bChrZXkucHJpdigpKTtcbiAgdmFyIFMgPSByLmFkZChzXykudW1vZCh0aGlzLmN1cnZlLm4pO1xuICByZXR1cm4gdGhpcy5tYWtlU2lnbmF0dXJlKHsgUjogUiwgUzogUywgUmVuY29kZWQ6IFJlbmNvZGVkIH0pO1xufTtcblxuLyoqXG4qIEBwYXJhbSB7QXJyYXl9IG1lc3NhZ2UgLSBtZXNzYWdlIGJ5dGVzXG4qIEBwYXJhbSB7QXJyYXl8U3RyaW5nfFNpZ25hdHVyZX0gc2lnIC0gc2lnIGJ5dGVzXG4qIEBwYXJhbSB7QXJyYXl8U3RyaW5nfFBvaW50fEtleVBhaXJ9IHB1YiAtIHB1YmxpYyBrZXlcbiogQHJldHVybnMge0Jvb2xlYW59IC0gdHJ1ZSBpZiBwdWJsaWMga2V5IG1hdGNoZXMgc2lnIG9mIG1lc3NhZ2VcbiovXG5FRERTQS5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UsIHNpZywgcHViKSB7XG4gIG1lc3NhZ2UgPSBwYXJzZUJ5dGVzKG1lc3NhZ2UpO1xuICBzaWcgPSB0aGlzLm1ha2VTaWduYXR1cmUoc2lnKTtcbiAgdmFyIGtleSA9IHRoaXMua2V5RnJvbVB1YmxpYyhwdWIpO1xuICB2YXIgaCA9IHRoaXMuaGFzaEludChzaWcuUmVuY29kZWQoKSwga2V5LnB1YkJ5dGVzKCksIG1lc3NhZ2UpO1xuICB2YXIgU0cgPSB0aGlzLmcubXVsKHNpZy5TKCkpO1xuICB2YXIgUnBsdXNBaCA9IHNpZy5SKCkuYWRkKGtleS5wdWIoKS5tdWwoaCkpO1xuICByZXR1cm4gUnBsdXNBaC5lcShTRyk7XG59O1xuXG5FRERTQS5wcm90b3R5cGUuaGFzaEludCA9IGZ1bmN0aW9uIGhhc2hJbnQoKSB7XG4gIHZhciBoYXNoID0gdGhpcy5oYXNoKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgIGhhc2gudXBkYXRlKGFyZ3VtZW50c1tpXSk7XG4gIHJldHVybiB1dGlscy5pbnRGcm9tTEUoaGFzaC5kaWdlc3QoKSkudW1vZCh0aGlzLmN1cnZlLm4pO1xufTtcblxuRUREU0EucHJvdG90eXBlLmtleUZyb21QdWJsaWMgPSBmdW5jdGlvbiBrZXlGcm9tUHVibGljKHB1Yikge1xuICByZXR1cm4gS2V5UGFpci5mcm9tUHVibGljKHRoaXMsIHB1Yik7XG59O1xuXG5FRERTQS5wcm90b3R5cGUua2V5RnJvbVNlY3JldCA9IGZ1bmN0aW9uIGtleUZyb21TZWNyZXQoc2VjcmV0KSB7XG4gIHJldHVybiBLZXlQYWlyLmZyb21TZWNyZXQodGhpcywgc2VjcmV0KTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5tYWtlU2lnbmF0dXJlID0gZnVuY3Rpb24gbWFrZVNpZ25hdHVyZShzaWcpIHtcbiAgaWYgKHNpZyBpbnN0YW5jZW9mIFNpZ25hdHVyZSlcbiAgICByZXR1cm4gc2lnO1xuICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLCBzaWcpO1xufTtcblxuLyoqXG4qICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWpvc2Vmc3Nvbi1lZGRzYS1lZDI1NTE5LTAzI3NlY3Rpb24tNS4yXG4qXG4qIEVERFNBIGRlZmluZXMgbWV0aG9kcyBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIHBvaW50cyBhbmQgaW50ZWdlcnMuIFRoZXNlIGFyZVxuKiBoZWxwZXIgY29udmVuaWVuY2UgbWV0aG9kcywgdGhhdCBwYXNzIGFsb25nIHRvIHV0aWxpdHkgZnVuY3Rpb25zIGltcGxpZWRcbiogcGFyYW1ldGVycy5cbipcbiovXG5FRERTQS5wcm90b3R5cGUuZW5jb2RlUG9pbnQgPSBmdW5jdGlvbiBlbmNvZGVQb2ludChwb2ludCkge1xuICB2YXIgZW5jID0gcG9pbnQuZ2V0WSgpLnRvQXJyYXkoJ2xlJywgdGhpcy5lbmNvZGluZ0xlbmd0aCk7XG4gIGVuY1t0aGlzLmVuY29kaW5nTGVuZ3RoIC0gMV0gfD0gcG9pbnQuZ2V0WCgpLmlzT2RkKCkgPyAweDgwIDogMDtcbiAgcmV0dXJuIGVuYztcbn07XG5cbkVERFNBLnByb3RvdHlwZS5kZWNvZGVQb2ludCA9IGZ1bmN0aW9uIGRlY29kZVBvaW50KGJ5dGVzKSB7XG4gIGJ5dGVzID0gdXRpbHMucGFyc2VCeXRlcyhieXRlcyk7XG5cbiAgdmFyIGxhc3RJeCA9IGJ5dGVzLmxlbmd0aCAtIDE7XG4gIHZhciBub3JtZWQgPSBieXRlcy5zbGljZSgwLCBsYXN0SXgpLmNvbmNhdChieXRlc1tsYXN0SXhdICYgfjB4ODApO1xuICB2YXIgeElzT2RkID0gKGJ5dGVzW2xhc3RJeF0gJiAweDgwKSAhPT0gMDtcblxuICB2YXIgeSA9IHV0aWxzLmludEZyb21MRShub3JtZWQpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludEZyb21ZKHksIHhJc09kZCk7XG59O1xuXG5FRERTQS5wcm90b3R5cGUuZW5jb2RlSW50ID0gZnVuY3Rpb24gZW5jb2RlSW50KG51bSkge1xuICByZXR1cm4gbnVtLnRvQXJyYXkoJ2xlJywgdGhpcy5lbmNvZGluZ0xlbmd0aCk7XG59O1xuXG5FRERTQS5wcm90b3R5cGUuZGVjb2RlSW50ID0gZnVuY3Rpb24gZGVjb2RlSW50KGJ5dGVzKSB7XG4gIHJldHVybiB1dGlscy5pbnRGcm9tTEUoYnl0ZXMpO1xufTtcblxuRUREU0EucHJvdG90eXBlLmlzUG9pbnQgPSBmdW5jdGlvbiBpc1BvaW50KHZhbCkge1xuICByZXR1cm4gdmFsIGluc3RhbmNlb2YgdGhpcy5wb2ludENsYXNzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcbnZhciBwYXJzZUJ5dGVzID0gdXRpbHMucGFyc2VCeXRlcztcbnZhciBjYWNoZWRQcm9wZXJ0eSA9IHV0aWxzLmNhY2hlZFByb3BlcnR5O1xuXG4vKipcbiogQHBhcmFtIHtFRERTQX0gZWRkc2EgLSBpbnN0YW5jZVxuKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gcHVibGljL3ByaXZhdGUga2V5IHBhcmFtZXRlcnNcbipcbiogQHBhcmFtIHtBcnJheTxCeXRlPn0gW3BhcmFtcy5zZWNyZXRdIC0gc2VjcmV0IHNlZWQgYnl0ZXNcbiogQHBhcmFtIHtQb2ludH0gW3BhcmFtcy5wdWJdIC0gcHVibGljIGtleSBwb2ludCAoYWthIGBBYCBpbiBlZGRzYSB0ZXJtcylcbiogQHBhcmFtIHtBcnJheTxCeXRlPn0gW3BhcmFtcy5wdWJdIC0gcHVibGljIGtleSBwb2ludCBlbmNvZGVkIGFzIGJ5dGVzXG4qXG4qL1xuZnVuY3Rpb24gS2V5UGFpcihlZGRzYSwgcGFyYW1zKSB7XG4gIHRoaXMuZWRkc2EgPSBlZGRzYTtcbiAgdGhpcy5fc2VjcmV0ID0gcGFyc2VCeXRlcyhwYXJhbXMuc2VjcmV0KTtcbiAgaWYgKGVkZHNhLmlzUG9pbnQocGFyYW1zLnB1YikpXG4gICAgdGhpcy5fcHViID0gcGFyYW1zLnB1YjtcbiAgZWxzZVxuICAgIHRoaXMuX3B1YkJ5dGVzID0gcGFyc2VCeXRlcyhwYXJhbXMucHViKTtcbn1cblxuS2V5UGFpci5mcm9tUHVibGljID0gZnVuY3Rpb24gZnJvbVB1YmxpYyhlZGRzYSwgcHViKSB7XG4gIGlmIChwdWIgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBwdWI7XG4gIHJldHVybiBuZXcgS2V5UGFpcihlZGRzYSwgeyBwdWI6IHB1YiB9KTtcbn07XG5cbktleVBhaXIuZnJvbVNlY3JldCA9IGZ1bmN0aW9uIGZyb21TZWNyZXQoZWRkc2EsIHNlY3JldCkge1xuICBpZiAoc2VjcmV0IGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICByZXR1cm4gc2VjcmV0O1xuICByZXR1cm4gbmV3IEtleVBhaXIoZWRkc2EsIHsgc2VjcmV0OiBzZWNyZXQgfSk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5zZWNyZXQgPSBmdW5jdGlvbiBzZWNyZXQoKSB7XG4gIHJldHVybiB0aGlzLl9zZWNyZXQ7XG59O1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAncHViQnl0ZXMnLCBmdW5jdGlvbiBwdWJCeXRlcygpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZW5jb2RlUG9pbnQodGhpcy5wdWIoKSk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ3B1YicsIGZ1bmN0aW9uIHB1YigpIHtcbiAgaWYgKHRoaXMuX3B1YkJ5dGVzKVxuICAgIHJldHVybiB0aGlzLmVkZHNhLmRlY29kZVBvaW50KHRoaXMuX3B1YkJ5dGVzKTtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZy5tdWwodGhpcy5wcml2KCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KEtleVBhaXIsICdwcml2Qnl0ZXMnLCBmdW5jdGlvbiBwcml2Qnl0ZXMoKSB7XG4gIHZhciBlZGRzYSA9IHRoaXMuZWRkc2E7XG4gIHZhciBoYXNoID0gdGhpcy5oYXNoKCk7XG4gIHZhciBsYXN0SXggPSBlZGRzYS5lbmNvZGluZ0xlbmd0aCAtIDE7XG5cbiAgdmFyIGEgPSBoYXNoLnNsaWNlKDAsIGVkZHNhLmVuY29kaW5nTGVuZ3RoKTtcbiAgYVswXSAmPSAyNDg7XG4gIGFbbGFzdEl4XSAmPSAxMjc7XG4gIGFbbGFzdEl4XSB8PSA2NDtcblxuICByZXR1cm4gYTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAncHJpdicsIGZ1bmN0aW9uIHByaXYoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmRlY29kZUludCh0aGlzLnByaXZCeXRlcygpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAnaGFzaCcsIGZ1bmN0aW9uIGhhc2goKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmhhc2goKS51cGRhdGUodGhpcy5zZWNyZXQoKSkuZGlnZXN0KCk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ21lc3NhZ2VQcmVmaXgnLCBmdW5jdGlvbiBtZXNzYWdlUHJlZml4KCkge1xuICByZXR1cm4gdGhpcy5oYXNoKCkuc2xpY2UodGhpcy5lZGRzYS5lbmNvZGluZ0xlbmd0aCk7XG59KTtcblxuS2V5UGFpci5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obWVzc2FnZSkge1xuICBhc3NlcnQodGhpcy5fc2VjcmV0LCAnS2V5UGFpciBjYW4gb25seSB2ZXJpZnknKTtcbiAgcmV0dXJuIHRoaXMuZWRkc2Euc2lnbihtZXNzYWdlLCB0aGlzKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlLCBzaWcpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EudmVyaWZ5KG1lc3NhZ2UsIHNpZywgdGhpcyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRTZWNyZXQgPSBmdW5jdGlvbiBnZXRTZWNyZXQoZW5jKSB7XG4gIGFzc2VydCh0aGlzLl9zZWNyZXQsICdLZXlQYWlyIGlzIHB1YmxpYyBvbmx5Jyk7XG4gIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy5zZWNyZXQoKSwgZW5jKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmdldFB1YmxpYyA9IGZ1bmN0aW9uIGdldFB1YmxpYyhlbmMpIHtcbiAgcmV0dXJuIHV0aWxzLmVuY29kZSh0aGlzLnB1YkJ5dGVzKCksIGVuYyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleVBhaXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIHV0aWxzID0gZWxsaXB0aWMudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xudmFyIGNhY2hlZFByb3BlcnR5ID0gdXRpbHMuY2FjaGVkUHJvcGVydHk7XG52YXIgcGFyc2VCeXRlcyA9IHV0aWxzLnBhcnNlQnl0ZXM7XG5cbi8qKlxuKiBAcGFyYW0ge0VERFNBfSBlZGRzYSAtIGVkZHNhIGluc3RhbmNlXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZXM+fE9iamVjdH0gc2lnIC1cbiogQHBhcmFtIHtBcnJheTxCeXRlcz58UG9pbnR9IFtzaWcuUl0gLSBSIHBvaW50IGFzIFBvaW50IG9yIGJ5dGVzXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZXM+fGJufSBbc2lnLlNdIC0gUyBzY2FsYXIgYXMgYm4gb3IgYnl0ZXNcbiogQHBhcmFtIHtBcnJheTxCeXRlcz59IFtzaWcuUmVuY29kZWRdIC0gUiBwb2ludCBlbmNvZGVkXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZXM+fSBbc2lnLlNlbmNvZGVkXSAtIFMgc2NhbGFyIGVuY29kZWRcbiovXG5mdW5jdGlvbiBTaWduYXR1cmUoZWRkc2EsIHNpZykge1xuICB0aGlzLmVkZHNhID0gZWRkc2E7XG5cbiAgaWYgKHR5cGVvZiBzaWcgIT09ICdvYmplY3QnKVxuICAgIHNpZyA9IHBhcnNlQnl0ZXMoc2lnKTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShzaWcpKSB7XG4gICAgc2lnID0ge1xuICAgICAgUjogc2lnLnNsaWNlKDAsIGVkZHNhLmVuY29kaW5nTGVuZ3RoKSxcbiAgICAgIFM6IHNpZy5zbGljZShlZGRzYS5lbmNvZGluZ0xlbmd0aClcbiAgICB9O1xuICB9XG5cbiAgYXNzZXJ0KHNpZy5SICYmIHNpZy5TLCAnU2lnbmF0dXJlIHdpdGhvdXQgUiBvciBTJyk7XG5cbiAgaWYgKGVkZHNhLmlzUG9pbnQoc2lnLlIpKVxuICAgIHRoaXMuX1IgPSBzaWcuUjtcbiAgaWYgKHNpZy5TIGluc3RhbmNlb2YgQk4pXG4gICAgdGhpcy5fUyA9IHNpZy5TO1xuXG4gIHRoaXMuX1JlbmNvZGVkID0gQXJyYXkuaXNBcnJheShzaWcuUikgPyBzaWcuUiA6IHNpZy5SZW5jb2RlZDtcbiAgdGhpcy5fU2VuY29kZWQgPSBBcnJheS5pc0FycmF5KHNpZy5TKSA/IHNpZy5TIDogc2lnLlNlbmNvZGVkO1xufVxuXG5jYWNoZWRQcm9wZXJ0eShTaWduYXR1cmUsICdTJywgZnVuY3Rpb24gUygpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZGVjb2RlSW50KHRoaXMuU2VuY29kZWQoKSk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoU2lnbmF0dXJlLCAnUicsIGZ1bmN0aW9uIFIoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmRlY29kZVBvaW50KHRoaXMuUmVuY29kZWQoKSk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoU2lnbmF0dXJlLCAnUmVuY29kZWQnLCBmdW5jdGlvbiBSZW5jb2RlZCgpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZW5jb2RlUG9pbnQodGhpcy5SKCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KFNpZ25hdHVyZSwgJ1NlbmNvZGVkJywgZnVuY3Rpb24gU2VuY29kZWQoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmVuY29kZUludCh0aGlzLlMoKSk7XG59KTtcblxuU2lnbmF0dXJlLnByb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcygpIHtcbiAgcmV0dXJuIHRoaXMuUmVuY29kZWQoKS5jb25jYXQodGhpcy5TZW5jb2RlZCgpKTtcbn07XG5cblNpZ25hdHVyZS5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbiB0b0hleCgpIHtcbiAgcmV0dXJuIHV0aWxzLmVuY29kZSh0aGlzLnRvQnl0ZXMoKSwgJ2hleCcpLnRvVXBwZXJDYXNlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpZ25hdHVyZTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBkb3VibGVzOiB7XG4gICAgc3RlcDogNCxcbiAgICBwb2ludHM6IFtcbiAgICAgIFtcbiAgICAgICAgJ2U2MGZjZTkzYjU5ZTllYzUzMDExYWFiYzIxYzIzZTk3YjJhMzEzNjliODdhNWFlOWM0NGVlODllMmE2ZGVjMGEnLFxuICAgICAgICAnZjdlMzUwNzM5OWU1OTU5MjlkYjk5ZjM0ZjU3OTM3MTAxMjk2ODkxZTQ0ZDIzZjBiZTFmMzJjY2U2OTYxNjgyMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4MjgyMjYzMjEyYzYwOWQ5ZWEyYTZlM2UxNzJkZTIzOGQ4YzM5Y2FiZDVhYzFjYTEwNjQ2ZTIzZmQ1ZjUxNTA4JyxcbiAgICAgICAgJzExZjhhODA5ODU1N2RmZTQ1ZTgyNTZlODMwYjYwYWNlNjJkNjEzYWMyZjdiMTdiZWQzMWI2ZWFmZjZlMjZjYWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTc1ZTE1OWY3MjhiODY1YTcyZjk5Y2M2YzZmYzg0NmRlMGI5MzgzM2ZkMjIyMmVkNzNmY2U1YjU1MWU1YjczOScsXG4gICAgICAgICdkMzUwNmUwZDllM2M3OWViYTRlZjk3YTUxZmY3MWY1ZWFjYjU5NTVhZGQyNDM0NWM2ZWZhNmZmZWU5ZmVkNjk1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM2M2Q5MGQ0NDdiMDBjOWM5OWNlYWMwNWI2MjYyZWUwNTM0NDFjN2U1NTU1MmZmZTUyNmJhZDhmODNmZjQ2NDAnLFxuICAgICAgICAnNGUyNzNhZGZjNzMyMjIxOTUzYjQ0NTM5N2YzMzYzMTQ1YjlhODkwMDgxOTllY2I2MjAwM2M3ZjNiZWU5ZGU5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhiNGI1ZjE2NWRmM2MyYmU4YzYyNDRiNWI3NDU2Mzg4NDNlNGE3ODFhMTViY2QxYjY5Zjc5YTU1ZGZmZGY4MGMnLFxuICAgICAgICAnNGFhZDBhNmY2OGQzMDhiNGIzZmJkNzgxM2FiMGRhMDRmOWUzMzY1NDYxNjJlZTU2YjNlZmYwYzY1ZmQ0ZmQzNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3MjNjYmFhNmU1ZGI5OTZkNmJmNzcxYzAwYmQ1NDhjN2I3MDBkYmZmYTZjMGU3N2JjYjYxMTU5MjUyMzJmY2RhJyxcbiAgICAgICAgJzk2ZTg2N2I1NTk1Y2M0OThhOTIxMTM3NDg4ODI0ZDZlMjY2MGEwNjUzNzc5NDk0ODAxZGMwNjlkOWViMzlmNWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWViZmE0ZDQ5M2JlYmY5OGJhNWZlZWM4MTJjMmQzYjUwOTQ3OTYxMjM3YTkxOTgzOWE1MzNlY2EwZTdkZDdmYScsXG4gICAgICAgICc1ZDlhOGNhMzk3MGVmMGYyNjllZTdlZGFmMTc4MDg5ZDlhZTRjZGMzYTcxMWY3MTJkZGZkNGZkYWUxZGU4OTk5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzEwMGY0NGRhNjk2ZTcxNjcyNzkxZDBhMDliN2JkZTQ1OWYxMjE1YTI5YjNjMDNiZmVmZDc4MzViMzlhNDhkYjAnLFxuICAgICAgICAnY2RkOWUxMzE5MmEwMGI3NzJlYzhmMzMwMGMwOTA2NjZiN2ZmNGExOGZmNTE5NWFjMGZiZDVjZDYyYmM2NWEwOSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlMTAzMWJlMjYyYzdlZDFiMWRjOTIyN2E0YTA0YzAxN2E3N2Y4ZDQ0NjRmM2IzODUyYzhhY2RlNmU1MzRmZDJkJyxcbiAgICAgICAgJzlkNzA2MTkyODk0MDQwNWU2YmI2YTQxNzY1OTc1MzVhZjI5MmRkNDE5ZTFjZWQ3OWE0NGYxOGYyOTQ1NmEwMGQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmVlYTZjYWU0NmQ1NWI1MzBhYzI4MzlmMTQzYmQ3ZWM1Y2Y4YjI2NmE0MWQ2YWY1MmQ1ZTY4OGQ5MDk0Njk2ZCcsXG4gICAgICAgICdlNTdjNmI2Yzk3ZGNlMWJhYjA2ZTRlMTJiZjNlY2Q1Yzk4MWM4OTU3Y2M0MTQ0MmQzMTU1ZGViZjE4MDkwMDg4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RhNjdhOTFkOTEwNDljZGNiMzY3YmU0YmU2ZmZjYTNjZmVlZDY1N2Q4MDg1ODNkZTMzZmE5NzhiYzFlYzZjYjEnLFxuICAgICAgICAnOWJhY2FhMzU0ODE2NDJiYzQxZjQ2M2Y3ZWM5NzgwZTVkZWM3YWRjNTA4Zjc0MGExN2U5ZWE4ZTI3YTY4YmUxZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1MzkwNGZhYTBiMzM0Y2RkYTZlMDAwOTM1ZWYyMjE1MWVjMDhkMGY3YmIxMTA2OWY1NzU0NWNjYzFhMzdiN2MwJyxcbiAgICAgICAgJzViYzA4N2QwYmM4MDEwNmQ4OGM5ZWNjYWMyMGQzYzFjMTM5OTk5ODFlMTQ0MzQ2OTlkY2IwOTZiMDIyNzcxYzgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGU3YmNkMGJkMzU5ODNhNzcxOWNjYTc3NjRjYTkwNjc3OWI1M2EwNDNhOWI4YmNhZWZmOTU5ZjQzYWQ4NjA0NycsXG4gICAgICAgICcxMGI3NzcwYjJhM2RhNGIzOTQwMzEwNDIwY2E5NTE0NTc5ZTg4ZTJlNDdmZDY4YjNlYTEwMDQ3ZTg0NjAzNzJhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM4NWVlZDM0YzFjZGZmMjFlNmQwODE4Njg5YjgxYmRlNzFhN2Y0ZjE4Mzk3ZTY2OTBhODQxZTE1OTljNDM4NjInLFxuICAgICAgICAnMjgzYmViYzNlOGVhMjNmNTY3MDFkZTE5ZTllYmY0NTc2YjMwNGVlYzIwODZkYzhjYzA0NThmZTU1NDJlNTQ1MydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2ZjlkOWI4MDNlY2YxOTE2MzdjNzNhNDQxM2RmYTE4MGZkZGY4NGE1OTQ3ZmJjOWM2MDZlZDg2YzNmYWMzYTcnLFxuICAgICAgICAnN2M4MGM2OGU2MDMwNTliYTY5YjhlMmEzMGU0NWM0ZDQ3ZWE0ZGQyZjVjMjgxMDAyZDg2ODkwNjAzYTg0MjE2MCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMzIyZDQwMTI0M2M0ZTI1ODJhMjE0N2MxMDRkNmVjYmY3NzRkMTYzZGIwZjVlNTMxM2I3ZTBlNzQyZDBlNmJkJyxcbiAgICAgICAgJzU2ZTcwNzk3ZTk2NjRlZjViZmIwMTliYzRkZGFmOWI3MjgwNWY2M2VhMjg3M2FmNjI0ZjNhMmU5NmMyOGIyYTAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODU2NzJjN2QyZGUwYjdkYTJiZDE3NzBkODk2NjU4Njg3NDFiM2Y5YWY3NjQzMzk3NzIxZDc0ZDI4MTM0YWI4MycsXG4gICAgICAgICc3YzQ4MWI5YjViNDNiMmViNjM3NDA0OWJmYTYyYzJlNWU3N2YxN2ZjYzUyOThmNDRjOGUzMDk0Zjc5MDMxM2E2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzk0OGJmODA5YjE5ODhhNDZiMDZjOWYxOTE5NDEzYjEwZjkyMjZjNjBmNjY4ODMyZmZkOTU5YWY2MGM4MmEwYScsXG4gICAgICAgICc1M2E1NjI4NTZkY2I2NjQ2ZGM2Yjc0YzVkMWMzNDE4YzZkNGRmZjA4Yzk3Y2QyYmVkNGNiN2Y4OGQ4YzhlNTg5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzYyNjBjZTdmNDYxODAxYzM0ZjA2N2NlMGYwMjg3M2E4ZjFiMGU0NGRmYzY5NzUyYWNjZWNkODE5ZjM4ZmQ4ZTgnLFxuICAgICAgICAnYmMyZGE4MmI2ZmE1YjU3MWE3ZjA5MDQ5Nzc2YTFlZjdlY2QyOTIyMzgwNTFjMTk4YzFhODRlOTViMmI0YWUxNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlNTAzN2RlMGFmYzFkOGQ0M2Q4MzQ4NDE0YmJmNDEwMzA0M2VjOGY1NzViZmRjNDMyOTUzY2M4ZDIwMzdmYTJkJyxcbiAgICAgICAgJzQ1NzE1MzRiYWE5NGQzYjVmOWY5OGQwOWZiOTkwYmRkYmQ1ZjViMDNlYzQ4MWYxMGUwZTVkYzg0MWQ3NTViZGEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTA2MzcyYjBmNGEyMDdhZGY1ZWE5MDVlOGYxNzcxYjRlN2U4ZGJkMWM2YTZjNWI3MjU4NjZhMGFlNGZjZTcyNScsXG4gICAgICAgICc3YTkwODk3NGJjZTE4Y2ZlMTJhMjdiYjJhZDVhNDg4Y2Q3NDg0YTc3ODcxMDQ4NzBiMjcwMzRmOTRlZWUzMWRkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzIxM2M3YTcxNWNkNWQ0NTM1OGQwYmJmOWRjMGNlMDIyMDRiMTBiZGRlMmEzZjU4NTQwYWQ2OTA4ZDA1NTk3NTQnLFxuICAgICAgICAnNGI2ZGFkMGI1YWU0NjI1MDcwMTNhZDA2MjQ1YmExOTBiYjQ4NTBmNWYzNmE3ZWVkZGZmMmMyNzUzNGI0NThmMidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ZTdjMjcyYTdhZjRiMzRlOGRiYjkzNTJhNTQxOWE4N2UyODM4YzcwYWRjNjJjZGRmMGNjM2EzYjA4ZmJkNTNjJyxcbiAgICAgICAgJzE3NzQ5Yzc2NmM5ZDBiMThlMTZmZDA5ZjZkZWY2ODFiNTMwYjk2MTRiZmY3ZGQzM2UwYjM5NDE4MTdkY2FhZTYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmVhNzRlM2RiZTc3OGIxYjEwZjIzOGFkNjE2ODZhYTVjNzZlM2RiMmJlNDMwNTc2MzI0MjdlMjg0MGZiMjdiNicsXG4gICAgICAgICc2ZTA1NjhkYjliMGIxMzI5N2NmNjc0ZGVjY2I2YWY5MzEyNmI1OTZiOTczZjdiNzc3MDFkM2RiN2YyM2NiOTZmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc2ZTY0MTEzZjY3N2NmMGUxMGEyNTcwZDU5OTk2OGQzMTU0NGUxNzliNzYwNDMyOTUyYzAyYTQ0MTdiZGRlMzknLFxuICAgICAgICAnYzkwZGRmOGRlZTRlOTVjZjU3NzA2NmQ3MDY4MWYwZDM1ZTJhMzNkMmI1NmQyMDMyYjRiMTc1MmQxOTAxYWMwMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjNzM4YzU2YjAzYjJhYmUxZTgyODFiYWE3NDNmOGY5YThmN2NjNjQzZGYyNmNiZWUzYWIxNTAyNDJiY2JiODkxJyxcbiAgICAgICAgJzg5M2ZiNTc4OTUxYWQyNTM3ZjcxOGYyZWFjYmZiYmJiODIzMTRlZWY3ODgwY2ZlOTE3ZTczNWQ5Njk5YTg0YzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDg5NTYyNjU0OGI2NWI4MWUyNjRjNzYzN2M5NzI4NzdkMWQ3MmU1ZjNhOTI1MDE0MzcyZTlmNjU4OGY2YzE0YicsXG4gICAgICAgICdmZWJmYWEzOGYyYmM3ZWFlNzI4ZWM2MDgxOGMzNDBlYjAzNDI4ZDYzMmJiMDY3ZTE3OTM2M2VkNzVkN2Q5OTFmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2I4ZGE5NDAzMmE5NTc1MThlYjBmNjQzMzU3MWU4NzYxY2VmZmM3MzY5M2U4NGVkZDQ5MTUwYTU2NGY2NzZlMDMnLFxuICAgICAgICAnMjgwNGRmYTQ0ODA1YTFlNGQ3Yzk5Y2M5NzYyODA4YjA5MmNjNTg0ZDk1ZmYzYjUxMTQ4OGU0ZTc0ZWZkZjZlNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlODBmZWExNDQ0MWZiMzNhN2Q4YWRhYjk0NzVkN2ZhYjIwMTllZmZiNTE1NmE3OTJmMWExMTc3OGUzYzBkZjVkJyxcbiAgICAgICAgJ2VlZDFkZTdmNjM4ZTAwNzcxZTg5NzY4Y2EzY2E5NDQ3MmQxNTVlODBhZjMyMmVhOWZjYjQyOTFiNmFjOWVjNzgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTMwMTY5N2JkZmNkNzA0MzEzYmE0OGU1MWQ1Njc1NDNmMmExODIwMzFlZmQ2OTE1ZGRjMDdiYmNjNGUxNjA3MCcsXG4gICAgICAgICc3MzcwZjkxY2ZiNjdlNGY1MDgxODA5ZmEyNWQ0MGY5YjE3MzVkYmY3YzBhMTFhMTMwYzBkMWEwNDFlMTc3ZWExJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzkwYWQ4NWIzODlkNmI5MzY0NjNmOWQwNTEyNjc4ZGUyMDhjYzMzMGIxMTMwN2ZmZmFiN2FjNjNlM2ZiMDRlZDQnLFxuICAgICAgICAnZTUwN2EzNjIwYTM4MjYxYWZmZGNiZDk0MjcyMjJiODM5YWVmYWJlMTU4Mjg5NGQ5OTFkNGQ0OGNiNmVmMTUwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhmNjhiOWQyZjYzYjVmMzM5MjM5YzFhZDk4MWYxNjJlZTg4YzU2Nzg3MjNlYTMzNTFiN2I0NDRjOWVjNGMwZGEnLFxuICAgICAgICAnNjYyYTlmMmRiYTA2Mzk4NmRlMWQ5MGMyYjZiZTIxNWRiYmVhMmNmZTk1NTEwYmZkZjIzY2JmNzk1MDFmZmY4MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlNGYzZmIwMTc2YWY4NWQ2NWZmOTlmZjkxOThjMzYwOTFmNDhlODY1MDM2ODFlM2U2Njg2ZmQ1MDUzMjMxZTExJyxcbiAgICAgICAgJzFlNjM2MzNhZDBlZjRmMWMxNjYxYTZkMGVhMDJiNzI4NmNjN2U3NGVjOTUxZDFjOTgyMmMzODU3NmZlYjczYmMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGMwMGZhOWIxOGViZjMzMWViOTYxNTM3YTQ1YTQyNjZjNzAzNGYyZjBkNGUxZDA3MTZmYjZlYWUyMGVhZTI5ZScsXG4gICAgICAgICdlZmE0NzI2N2ZlYTUyMWExYTlkYzM0M2EzNzM2Yzk3NGMyZmFkYWZhODFlMzZjNTRlN2QyYTRjNjY3MDI0MTRiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U3YTI2Y2U2OWRkNDgyOWYzZTEwY2VjMGE5ZTk4ZWQzMTQzZDA4NGYzMDhiOTJjMDk5N2ZkZGZjNjBjYjNlNDEnLFxuICAgICAgICAnMmE3NThlMzAwZmE3OTg0YjQ3MWIwMDZhMWFhZmJiMThkMGE2YjJjMDQyMGU4M2UyMGU4YTk0MjFjZjJjZmQ1MSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiNjQ1OWUwZWUzNjYyZWM4ZDIzNTQwYzIyM2JjYmRjNTcxY2JjYjk2N2Q3OTQyNGYzY2YyOWViM2RlNmI4MGVmJyxcbiAgICAgICAgJzY3Yzg3NmQwNmYzZTA2ZGUxZGFkZjE2ZTU2NjFkYjNjNGIzYWU2ZDQ4ZTM1YjJmZjMwYmYwYjYxYTcxYmE0NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkNjhhODBjODI4MGJiODQwNzkzMjM0YWExMThmMDYyMzFkNmYxZmM2N2U3M2M1YTVkZWRhMGY1YjQ5Njk0M2U4JyxcbiAgICAgICAgJ2RiOGJhOWZmZjRiNTg2ZDAwYzRiMWY5MTc3YjBlMjhiNWIwZTdiOGY3ODQ1Mjk1YTI5NGM4NDI2NmIxMzMxMjAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzI0YWVkN2RmNjVjODA0MjUyZGMwMjcwOTA3YTMwYjA5NjEyYWViOTczNDQ5Y2VhNDA5NTk4MGZjMjhkM2Q1ZCcsXG4gICAgICAgICc2NDhhMzY1Nzc0YjYxZjJmZjEzMGMwYzM1YWVjMWY0ZjE5MjEzYjBjN2UzMzI4NDM5NjcyMjRhZjk2YWI3Yzg0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzRkZjljMTQ5MTljZGU2MWY2ZDUxZGZkYmU1ZmVlNWRjZWVjNDE0M2JhOGQxY2E4ODhlOGJkMzczZmQwNTRjOTYnLFxuICAgICAgICAnMzVlYzUxMDkyZDg3MjgwNTA5NzRjMjNhMWQ4NWQ0YjVkNTA2Y2RjMjg4NDkwMTkyZWJhYzA2Y2FkMTBkNWQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOWMzOTE5YTg0YTQ3NDg3MGZhZWQ4YTljMWNjNjYwMjE1MjM0ODkwNTRkN2YwMzA4Y2JmYzk5YzhhYzFmOThjZCcsXG4gICAgICAgICdkZGI4NGYwZjRhNGRkZDU3NTg0ZjA0NGJmMjYwZTY0MTkwNTMyNmY3NmM2NGM4ZTZiZTdlNWUwM2Q0ZmM1OTlkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzYwNTcxNzBiMWRkMTJmZGY4ZGUwNWYyODFkOGUwNmJiOTFlMTQ5M2E4YjkxZDRjYzVhMjEzODIxMjBhOTU5ZTUnLFxuICAgICAgICAnOWExYWYwYjI2YTZhNDgwN2FkZDlhMmRhZjcxZGYyNjI0NjUxNTJiYzNlZTI0YzY1ZTg5OWJlOTMyMzg1YTJhOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhNTc2ZGY4ZTIzYTA4NDExNDIxNDM5YTQ1MThkYTMxODgwY2VmMGZiYTdkNGRmMTJiMWE2OTczZWVjYjk0MjY2JyxcbiAgICAgICAgJzQwYTZiZjIwZTc2NjQwYjJjOTJiOTdhZmU1OGNkODJjNDMyZTEwYTdmNTE0ZDlmM2VlOGJlMTFhZTFiMjhlYzgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzc3OGE3OGMyOGRlYzNlMzBhMDVmZTk2MjlkZThjMzhiYjMwZDFmNWNmOWEzYTIwOGY3NjM4ODliZTU4YWQ3MScsXG4gICAgICAgICczNDYyNmQ5YWI1YTViMjJmZjcwOThlMTJmMmZmNTgwMDg3YjM4NDExZmYyNGFjNTYzYjUxM2ZjMWZkOWY0M2FjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzkyODk1NWVlNjM3YTg0NDYzNzI5ZmQzMGU3YWZkMmVkNWY5NjI3NGU1YWQ3ZTVjYjA5ZWRhOWMwNmQ5MDNhYycsXG4gICAgICAgICdjMjU2MjEwMDNkM2Y0MmE4MjdiNzhhMTMwOTNhOTVlZWFjM2QyNmVmYThhOGQ4M2ZjNTE4MGU5MzViY2QwOTFmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg1ZDBmZWYzZWM2ZGIxMDkzOTkwNjRmM2EwZTNiMjg1NTY0NWI0YTkwN2FkMzU0NTI3YWFlNzUxNjNkODI3NTEnLFxuICAgICAgICAnMWYwMzY0ODQxM2EzOGMwYmUyOWQ0OTZlNTgyY2Y1NjYzZTg3NTFlOTY4NzczMzE1ODJjMjM3YTI0ZWIxZjk2MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmZjJiMGRjZTk3ZWVjZTk3YzFjOWI2MDQxNzk4Yjg1ZGZkZmI2ZDg4ODJkYTIwMzA4ZjU0MDQ4MjQ1MjYwODdlJyxcbiAgICAgICAgJzQ5M2QxM2ZlZjUyNGJhMTg4YWY0YzRkYzU0ZDA3OTM2YzdiN2VkNmZiOTBlMmNlYjJjOTUxZTAxZjBjMjk5MDcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODI3ZmJiZTRiMWU4ODBlYTllZDJiMmU2MzAxYjIxMmI1N2YxZWUxNDhjZDZkZDI4NzgwZTVlMmNmODU2ZTI0MScsXG4gICAgICAgICdjNjBmOWM5MjNjNzI3YjBiNzFiZWYyYzY3ZDFkMTI2ODdmZjdhNjMxODY5MDMxNjZkNjA1YjY4YmFlYzI5M2VjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VhYTY0OWYyMWY1MWJkYmFlN2JlNGFlMzRjZTZlNTIxN2E1OGZkY2U3ZjQ3ZjlhYTdmM2I1OGZhMjEyMGUyYjMnLFxuICAgICAgICAnYmUzMjc5ZWQ1YmJiYjAzYWM2OWE4MGY4OTg3OWFhNWEwMWE2Yjk2NWYxM2Y3ZTU5ZDQ3YTUzMDViYTVhZDkzZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlNGE0MmQ0M2M1Y2YxNjlkOTM5MWRmNmRlY2Y0MmVlNTQxYjZkOGYwYzlhMTM3NDAxZTIzNjMyZGRhMzRkMjRmJyxcbiAgICAgICAgJzRkOWY5MmU3MTZkMWM3MzUyNmZjOTljY2ZiOGFkMzRjZTg4NmVlZGZhOGQ4ZTRmMTNhN2Y3MTMxZGViYTk0MTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMWVjODBmZWYzNjBjYmRkOTU0MTYwZmFkYWIzNTJiNmI5MmI1MzU3NmE4OGZlYTQ5NDcxNzNiOWQ0MzAwYmYxOScsXG4gICAgICAgICdhZWVmZTkzNzU2YjUzNDBkMmYzYTQ5NThhN2FiYmY1ZTAxNDZlNzdmNjI5NWEwN2I2NzFjZGMxY2MxMDdjZWZkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE0NmE3NzhjMDQ2NzBjMmY5MWIwMGFmNDY4MGRmYThiY2UzNDkwNzE3ZDU4YmE4ODlkZGI1OTI4MzY2NjQyYmUnLFxuICAgICAgICAnYjMxOGUwZWMzMzU0MDI4YWRkNjY5ODI3ZjlkNGIyODcwYWFhOTcxZDJmN2U1ZWQxZDBiMjk3NDgzZDgzZWZkMCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmYTUwYzBmNjFkMjJlNWYwN2UzYWNlYmIxYWEwN2IxMjhkMDAxMjIwOWEyOGI5Nzc2ZDc2YTg3OTMxODBlZWY5JyxcbiAgICAgICAgJzZiODRjNjkyMjM5N2ViYTliNzJjZDI4NzIyODFhNjhhNWU2ODMyOTNhNTdhMjEzYjM4Y2Q4ZDdkM2Y0ZjI4MTEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGExZDYxZDBjYTcyMWExMWIxYTViZjZiN2Q4OGU4NDIxYTI4OGFiNWQ1YmJhNTIyMGU1M2QzMmI1ZjA2N2VjMicsXG4gICAgICAgICc4MTU3ZjU1YTdjOTkzMDZjNzljMDc2NjE2MWM5MWUyOTY2YTczODk5ZDI3OWI0OGE2NTVmYmEwZjFhZDgzNmYxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2E4ZTI4MmZmMGM5NzA2OTA3MjE1ZmY5OGU4ZmQ0MTY2MTUzMTFkZTA0NDZmMWUwNjJhNzNiMDYxMGQwNjRlMTMnLFxuICAgICAgICAnN2Y5NzM1NWI4ZGI4MWMwOWFiZmI3ZjNjNWIyNTE1ODg4YjY3OWEzZTUwZGQ2YmQ2Y2VmN2M3MzExMWY0Y2MwYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNzRhNTNiOWM5YTI4NTg3MmQzOWU1NmU2OTEzY2FiMTVkNTliMWZhNTEyNTA4YzAyMmYzODJkZTgzMTk0OTdjJyxcbiAgICAgICAgJ2NjYzlkYzM3YWJmYzljMTY1N2I0MTU1ZjJjNDdmOWU2NjQ2YjNhMWQ4Y2I5ODU0MzgzZGExM2FjMDc5YWZhNzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTU5Mzk2OTgxOTQzNzg1YzNkM2U1N2VkZjUwMThjZGJlMDM5ZTczMGU0OTE4YjNkODg0ZmRmZjA5NDc1YjdiYScsXG4gICAgICAgICcyZTdlNTUyODg4YzMzMWRkOGJhMDM4NmE0YjljZDY4NDljNjUzZjY0Yzg3MDkzODVlOWI4YWJmODc1MjRmMmZkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2QyYTYzYTUwYWU0MDFlNTZkNjQ1YTExNTNiMTA5YThmY2NhMGE0M2Q1NjFmYmEyZGJiNTEzNDBjOWQ4MmIxNTEnLFxuICAgICAgICAnZTgyZDg2ZmI2NDQzZmNiNzU2NWFlZTU4YjI5NDgyMjBhNzBmNzUwYWY0ODRjYTUyZDQxNDIxNzRkY2Y4OTQwNSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2NDU4N2UyMzM1NDcxZWI4OTBlZTc4OTZkN2NmZGM4NjZiYWNiZGJkMzgzOTMxN2IzNDM2ZjliNDU2MTdlMDczJyxcbiAgICAgICAgJ2Q5OWZjZGQ1YmY2OTAyZTJhZTk2ZGQ2NDQ3YzI5OWExODViOTBhMzkxMzNhZWFiMzU4Mjk5ZTVlOWZhZjY1ODknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODQ4MWJkZTBlNGU0ZDg4NWIzYTU0NmQzZTU0OWRlMDQyZjBhYTZjZWEyNTBlN2ZkMzU4ZDZjODZkZDQ1ZTQ1OCcsXG4gICAgICAgICczOGVlN2I4Y2JhNTQwNGRkODRhMjViZjM5Y2VjYjJjYTkwMGE3OWM0MmIyNjJlNTU2ZDY0YjFiNTk3NzkwNTdlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzEzNDY0YTU3YTc4MTAyYWE2MmI2OTc5YWU4MTdmNDYzN2ZmY2ZlZDNjNGIxY2UzMGJjZDYzMDNmNmNhZjY2NmInLFxuICAgICAgICAnNjliZTE1OTAwNDYxNDU4MGVmN2U0MzM0NTNjY2IwY2E0OGYzMDBhODFkMDk0MmUxM2Y0OTVhOTA3ZjZlY2MyNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiYzRhOWRmNWI3MTNmZTJlOWFlZjQzMGJjYzFkYzk3YTBjZDljY2VkZTJmMjg1ODhjYWRhM2EwZDJkODNmMzY2JyxcbiAgICAgICAgJ2QzYTgxY2E2ZTc4NWMwNjM4MzkzN2FkZjRiNzk4Y2FhNmU4YTlmYmZhNTQ3YjE2ZDc1OGQ2NjY1ODFmMzNjMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4YzI4YTk3YmY4Mjk4YmMwZDIzZDhjNzQ5NDUyYTMyZTY5NGI2NWUzMGE5NDcyYTM5NTRhYjMwZmU1MzI0Y2FhJyxcbiAgICAgICAgJzQwYTMwNDYzYTMzMDUxOTMzNzhmZWRmMzFmN2NjMGViN2FlNzg0ZjA0NTFjYjk0NTllNzFkYzczY2JlZjk0ODInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGVhOTY2NjEzOTUyN2E4YzFkZDk0Y2U0ZjA3MWZkMjNjOGIzNTBjNWE0YmIzMzc0OGM0YmExMTFmYWNjYWUwJyxcbiAgICAgICAgJzYyMGVmYWJiYzhlZTI3ODJlMjRlN2MwY2ZiOTVjNWQ3MzViNzgzYmU5Y2YwZjhlOTU1YWYzNGEzMGU2MmI5NDUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGQzNjI1ZmFlZjViYTA2MDc0NjY5NzE2YmJkMzc4OGQ4OWJkZGU4MTU5NTk5NjgwOTJmNzZjYzRlYjlhOTc4NycsXG4gICAgICAgICc3YTE4OGZhMzUyMGUzMGQ0NjFkYTI1MDEwNDU3MzFjYTk0MTQ2MTk4Mjg4MzM5NTkzN2Y2OGQwMGM2NDRhNTczJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Y3MTBkNzlkOWViOTYyMjk3ZTRmNjIzMmI0MGU4ZjdmZWIyYmM2MzgxNDYxNGQ2OTJjMTJkZTc1MjQwODIyMWUnLFxuICAgICAgICAnZWE5OGU2NzIzMmQzYjMyOTVkM2I1MzU1MzIxMTVjY2FjODYxMmM3MjE4NTE2MTc1MjZhZTQ3YTljNzdiZmM4MidcbiAgICAgIF1cbiAgICBdXG4gIH0sXG4gIG5hZjoge1xuICAgIHduZDogNyxcbiAgICBwb2ludHM6IFtcbiAgICAgIFtcbiAgICAgICAgJ2Y5MzA4YTAxOTI1OGMzMTA0OTM0NGY4NWY4OWQ1MjI5YjUzMWM4NDU4MzZmOTliMDg2MDFmMTEzYmNlMDM2ZjknLFxuICAgICAgICAnMzg4ZjdiMGY2MzJkZTgxNDBmZTMzN2U2MmEzN2YzNTY2NTAwYTk5OTM0YzIyMzFiNmNiOWZkNzU4NGI4ZTY3MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyZjhiZGU0ZDFhMDcyMDkzNTViNGE3MjUwYTVjNTEyOGU4OGI4NGJkZGM2MTlhYjdjYmE4ZDU2OWIyNDBlZmU0JyxcbiAgICAgICAgJ2Q4YWMyMjI2MzZlNWUzZDZkNGRiYTlkZGE2YzljNDI2Zjc4ODI3MWJhYjBkNjg0MGRjYTg3ZDNhYTZhYzYyZDYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNWNiZGYwNjQ2ZTVkYjRlYWEzOThmMzY1ZjJlYTdhMGUzZDQxOWI3ZTAzMzBlMzljZTkyYmRkZWRjYWM0ZjliYycsXG4gICAgICAgICc2YWViY2E0MGJhMjU1OTYwYTMxNzhkNmQ4NjFhNTRkYmE4MTNkMGI4MTNmZGU3YjVhNTA4MjYyODA4NzI2NGRhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2FjZDQ4NGUyZjBjN2Y2NTMwOWFkMTc4YTlmNTU5YWJkZTA5Nzk2OTc0YzU3ZTcxNGMzNWYxMTBkZmMyN2NjYmUnLFxuICAgICAgICAnY2MzMzg5MjFiMGE3ZDlmZDY0MzgwOTcxNzYzYjYxZTlhZGQ4ODhhNDM3NWY4ZTBmMDVjYzI2MmFjNjRmOWMzNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NzRhZTdmODU4YTk0MTFlNWVmNDI0NmI3MGM2NWFhYzU2NDk5ODBiZTVjMTc4OTFiYmVjMTc4OTVkYTAwOGNiJyxcbiAgICAgICAgJ2Q5ODRhMDMyZWI2YjVlMTkwMjQzZGQ1NmQ3YjdiMzY1MzcyZGIxZTJkZmY5ZDZhODMwMWQ3NGM5Yzk1M2M2MWInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjI4NzczYzJkOTc1Mjg4YmM3ZDFkMjA1YzM3NDg2NTFiMDc1ZmJjNjYxMGU1OGNkZGVlZGRmOGYxOTQwNWFhOCcsXG4gICAgICAgICdhYjA5MDJlOGQ4ODBhODk3NTgyMTJlYjY1Y2RhZjQ3M2ExYTA2ZGE1MjFmYTkxZjI5YjVjYjUyZGIwM2VkODEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDc5MjRkNGY3ZDQzZWE5NjVhNDY1YWUzMDk1ZmY0MTEzMWU1OTQ2ZjNjODVmNzllNDRhZGJjZjhlMjdlMDgwZScsXG4gICAgICAgICc1ODFlMjg3MmE4NmM3MmE2ODM4NDJlYzIyOGNjNmRlZmVhNDBhZjJiZDg5NmQzYTVjNTA0ZGM5ZmY2YTI2YjU4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RlZmRlYTRjZGI2Nzc3NTBhNDIwZmVlODA3ZWFjZjIxZWI5ODk4YWU3OWI5NzY4NzY2ZTRmYWEwNGEyZDRhMzQnLFxuICAgICAgICAnNDIxMWFiMDY5NDYzNTE2OGU5OTdiMGVhZDJhOTNkYWVjZWQxZjRhMDRhOTVjMGY2Y2ZiMTk5ZjY5ZTU2ZWI3NydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyYjRlYTBhNzk3YTQ0M2QyOTNlZjVjZmY0NDRmNDk3OWYwNmFjZmViZDdlODZkMjc3NDc1NjU2MTM4Mzg1YjZjJyxcbiAgICAgICAgJzg1ZTg5YmMwMzc5NDVkOTNiMzQzMDgzYjVhMWM4NjEzMWEwMWY2MGM1MDI2OTc2M2I1NzBjODU0ZTVjMDliN2EnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzUyYmJmNGE0Y2RkMTI1NjRmOTNmYTMzMmNlMzMzMzAxZDlhZDQwMjcxZjgxMDcxODEzNDBhZWYyNWJlNTlkNScsXG4gICAgICAgICczMjFlYjQwNzUzNDhmNTM0ZDU5YzE4MjU5ZGRhM2UxZjRhMWIzYjJlNzFiMTAzOWM2N2JkM2Q4YmNmODE5OThjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzJmYTIxMDRkNmIzOGQxMWIwMjMwMDEwNTU5ODc5MTI0ZTQyYWI4ZGZlZmY1ZmYyOWRjOWNkYWRkNGVjYWNjM2YnLFxuICAgICAgICAnMmRlMTA2ODI5NWRkODY1YjY0NTY5MzM1YmQ1ZGQ4MDE4MWQ3MGVjZmM4ODI2NDg0MjNiYTc2YjUzMmI3ZDY3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzkyNDgyNzliMDliNGQ2OGRhYjIxYTliMDY2ZWRkYTgzMjYzYzNkODRlMDk1NzJlMjY5Y2EwY2Q3ZjU0NTM3MTQnLFxuICAgICAgICAnNzMwMTZmN2JmMjM0YWFkZTVkMWFhNzFiZGVhMmIxZmYzZmMwZGUyYTg4NzkxMmZmZTU0YTMyY2U5N2NiMzQwMidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkYWVkNGYyYmUzYThiZjI3OGU3MDEzMmZiMGJlYjc1MjJmNTcwZTE0NGJmNjE1YzA3ZTk5NmQ0NDNkZWU4NzI5JyxcbiAgICAgICAgJ2E2OWRjZTRhN2Q2Yzk4ZThkNGExYWNhODdlZjhkNzAwM2Y4M2MyMzBmM2FmYTcyNmFiNDBlNTIyOTBiZTFjNTUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzQ0ZDEyYzcwNjVkODEyZThhY2YyOGQ3Y2JiMTlmOTAxMWVjZDllOWZkZjI4MWIwZTZhM2I1ZTg3ZDIyZTdkYicsXG4gICAgICAgICcyMTE5YTQ2MGNlMzI2Y2RjNzZjNDU5MjZjOTgyZmRhYzBlMTA2ZTg2MWVkZjYxYzVhMDM5MDYzZjBlMGU2NDgyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzZhMjQ1YmY2ZGM2OTg1MDRjODlhMjBjZmRlZDYwODUzMTUyYjY5NTMzNmMyODA2M2I2MWM2NWNiZDI2OWU2YjQnLFxuICAgICAgICAnZTAyMmNmNDJjMmJkNGE3MDhiM2Y1MTI2ZjE2YTI0YWQ4YjMzYmE0OGQwNDIzYjZlZmQ1ZTYzNDgxMDBkOGE4MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNjk3ZmZhNmZkOWRlNjI3YzA3N2UzZDJmZTU0MTA4NGNlMTMzMDBiMGJlYzExNDZmOTVhZTU3ZjBkMGJkNmE1JyxcbiAgICAgICAgJ2I5YzM5OGYxODY4MDZmNWQyNzU2MTUwNmU0NTU3NDMzYTJjZjE1MDA5ZTQ5OGFlN2FkZWU5ZDYzZDAxYjIzOTYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjA1YmRiMDE5OTgxNzE4Yjk4NmQwZjA3ZTgzNGNiMGQ5ZGViODM2MGZmYjdmNjFkZjk4MjM0NWVmMjdhNzQ3OScsXG4gICAgICAgICcyOTcyZDJkZTRmOGQyMDY4MWE3OGQ5M2VjOTZmZTIzYzI2YmZhZTg0ZmIxNGRiNDNiMDFlMWU5MDU2YjhjNDknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjJkMTRkYWI0MTUwYmY0OTc0MDJmZGM0NWEyMTVlMTBkY2IwMWMzNTQ5NTliMTBjZmUzMWM3ZTlkODdmZjMzZCcsXG4gICAgICAgICc4MGZjMDZiZDhjYzViMDEwOTgwODhhMTk1MGVlZDBkYjAxYWExMzI5NjdhYjQ3MjIzNWY1NjQyNDgzYjI1ZWFmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzgwYzYwYWQwMDQwZjI3ZGFkZTViNGIwNmM0MDhlNTZiMmM1MGU5ZjU2YjliOGI0MjVlNTU1YzJmODYzMDhiNmYnLFxuICAgICAgICAnMWMzODMwM2YxY2M1YzMwZjI2ZTY2YmFkN2ZlNzJmNzBhNjVlZWQ0Y2JlNzAyNGViMWFhMDFmNTY0MzBiZDU3YSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3YTkzNzVhZDYxNjdhZDU0YWE3NGM2MzQ4Y2M1NGQzNDRjYzVkYzk0ODdkODQ3MDQ5ZDVlYWJiMGZhMDNjOGZiJyxcbiAgICAgICAgJ2QwZTNmYTllY2E4NzI2OTA5NTU5ZTBkNzkyNjkwNDZiZGM1OWVhMTBjNzBjZTJiMDJkNDk5ZWMyMjRkYzdmNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkNTI4ZWNkOWI2OTZiNTRjOTA3YTllZDA0NTQ0N2E3OWJiNDA4ZWMzOWI2OGRmNTA0YmI1MWY0NTliYzNmZmM5JyxcbiAgICAgICAgJ2VlY2Y0MTI1MzEzNmU1Zjk5OTY2ZjIxODgxZmQ2NTZlYmM0MzQ1NDA1YzUyMGRiYzA2MzQ2NWI1MjE0MDk5MzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDkzNzBhNGI1ZjQzNDEyZWEyNWY1MTRlOGVjZGFkMDUyNjYxMTVlNGE3ZWNiMTM4NzIzMTgwOGY4YjQ1OTYzJyxcbiAgICAgICAgJzc1OGYzZjQxYWZkNmVkNDI4YjMwODFiMDUxMmZkNjJhNTRjM2YzYWZiYjViNjc2NGI2NTMwNTJhMTI5NDljOWEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzdmMjMwOTM2ZWU4OGNiYmQ3M2RmOTMwZDY0NzAyZWY4ODFkODExZTBlMTQ5OGUyZjFjMTNlYjFmYzM0NWQ3NCcsXG4gICAgICAgICc5NThlZjQyYTc4ODZiNjQwMGEwODI2NmU5YmExYjM3ODk2Yzk1MzMwZDk3MDc3Y2JiZThlYjNjNzY3MWM2MGQ2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YyZGFjOTkxY2M0Y2U0YjllYTQ0ODg3ZTVjN2MwYmNlNThjODAwNzRhYjlkNGRiYWViMjg1MzFiNzczOWY1MzAnLFxuICAgICAgICAnZTBkZWRjOWIzYjJmOGRhZDRkYTFmMzJkZWMyNTMxZGY5ZWI1ZmJlYjA1OThlNGZkMWExMTdkYmE3MDNhM2MzNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0NjNiM2Q5ZjY2MjYyMWZiMWI0YmU4ZmJiZTI1MjAxMjVhMjE2Y2RmYzlkYWUzZGViY2JhNDg1MGM2OTBkNDViJyxcbiAgICAgICAgJzVlZDQzMGQ3OGMyOTZjMzU0MzExNDMwNmRkODYyMmQ3YzYyMmUyN2M5NzBhMWRlMzFjYjM3N2IwMWFmNzMwN2UnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjE2ZjgwNDI0NGU0NmUyYTA5MjMyZDRhZmYzYjU5OTc2Yjk4ZmFjMTQzMjhhMmQxYTMyNDk2YjQ5OTk4ZjI0NycsXG4gICAgICAgICdjZWRhYmQ5YjgyMjAzZjdlMTNkMjA2ZmNkZjRlMzNkOTJhNmM1M2MyNmU1Y2NlMjZkNjU3OTk2MmM0ZTMxZGY2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2NhZjc1NDI3MmRjODQ1NjNiMDM1MmI3YTE0MzExYWY1NWQyNDUzMTVhY2UyN2M2NTM2OWUxNWY3MTUxZDQxZDEnLFxuICAgICAgICAnY2I0NzQ2NjBlZjM1ZjVmMmE0MWI2NDNmYTVlNDYwNTc1ZjRmYTliNzk2MjIzMmE1YzMyZjkwODMxOGEwNDQ3NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyNjAwY2E0YjI4MmNiOTg2Zjg1ZDBmMTcwOTk3OWQ4YjQ0YTA5YzA3Y2I4NmQ3YzEyNDQ5N2JjODZmMDgyMTIwJyxcbiAgICAgICAgJzQxMTliODg3NTNjMTViZDZhNjkzYjAzZmNkZGJiNDVkNWFjNmJlNzRhYjVmMGVmNDRiMGJlOTQ3NWE3ZTRiNDAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzYzNWNhNzJkN2U4NDMyYzMzOGVjNTNjZDEyMjIwYmMwMWM0ODY4NWUyNGY3ZGM4YzYwMmE3NzQ2OTk4ZTQzNScsXG4gICAgICAgICc5MWI2NDk2MDk0ODlkNjEzZDFkNWU1OTBmNzhlNmQ3NGVjZmMwNjFkNTcwNDhiYWQ5ZTc2ZjMwMmM1YjljNjEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzU0ZTMyMzlmMzI1NTcwY2RiYmY0YTg3ZGVlZThhNjZiN2YyYjMzNDc5ZDQ2OGZiYzFhNTA3NDNiZjU2Y2MxOCcsXG4gICAgICAgICc2NzNmYjg2ZTViZGEzMGZiM2NkMGVkMzA0ZWE0OWEwMjNlZTMzZDAxOTdhNjk1ZDBjNWQ5ODA5M2M1MzY2ODMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTNlNmJkMTA3MWExZTk2YWZmNTc4NTljODJkNTcwZjAzMzA4MDA2NjFkMWM5NTJmOWZlMjY5NDY5MWQ5YjllOCcsXG4gICAgICAgICc1OWM5ZTBiYmEzOTRlNzZmNDBjMGFhNTgzNzlhM2NiNmE1YTIyODM5OTNlOTBjNDE2NzAwMmFmNDkyMGUzN2Y1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE4NmI0ODNkMDU2YTAzMzgyNmFlNzNkODhmNzMyOTg1YzRjY2IxZjMyYmEzNWY0YjRjYzQ3ZmRjZjA0YWE2ZWInLFxuICAgICAgICAnM2I5NTJkMzJjNjdjZjc3ZTJlMTc0NDZlMjA0MTgwYWIyMWZiODA5MDg5NTEzOGI0YTRhNzk3Zjg2ZTgwODg4YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkZjlkNzBhNmI5ODc2Y2U1NDRjOTg1NjFmNGJlNGY3MjU0NDJlNmQyYjczN2Q5YzkxYTgzMjE3MjRjZTA5NjNmJyxcbiAgICAgICAgJzU1ZWIyZGFmZDg0ZDZjY2Q1Zjg2MmI3ODVkYzM5ZDRhYjE1NzIyMjcyMGVmOWRhMjE3YjhjNDVjZjJiYTI0MTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNWVkZDVjYzIzYzUxZTg3YTQ5N2NhODE1ZDVkY2UwZjhhYjUyNTU0Zjg0OWVkODk5NWRlNjRjNWYzNGNlNzE0MycsXG4gICAgICAgICdlZmFlOWM4ZGJjMTQxMzA2NjFlOGNlYzAzMGM4OWFkMGMxM2M2NmMwZDE3YTI5MDVjZGM3MDZhYjczOTlhODY4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzI5MDc5OGMyYjY0NzY4MzBkYTEyZmUwMjI4N2U5ZTc3N2FhM2ZiYTFjMzU1YjE3YTcyMmQzNjJmODQ2MTRmYmEnLFxuICAgICAgICAnZTM4ZGE3NmRjZDQ0MDYyMTk4OGQwMGJjZjc5YWYyNWQ1YjI5YzA5NGRiMmEyMzE0NmQwMDNhZmQ0MTk0M2U3YSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhZjNjNDIzYTk1ZDlmNWIzMDU0NzU0ZWZhMTUwYWMzOWNkMjk1NTJmZTM2MDI1NzM2MmRmZGVjZWY0MDUzYjQ1JyxcbiAgICAgICAgJ2Y5OGEzZmQ4MzFlYjJiNzQ5YTkzYjBlNmYzNWNmYjQwYzhjZDVhYTY2N2ExNTU4MWJjMmZlZGVkNDk4ZmQ5YzYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzY2ZGJiMjRkMTM0ZTc0NWNjY2FhMjhjOTliZjI3NDkwNmJiNjZiMjZkY2Y5OGRmOGQyZmVkNTBkODg0MjQ5YScsXG4gICAgICAgICc3NDRiMTE1MmVhY2JlNWUzOGRjYzg4Nzk4MGRhMzhiODk3NTg0YTY1ZmEwNmNlZGQyYzkyNGY5N2NiYWM1OTk2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzU5ZGJmNDZmOGM5NDc1OWJhMjEyNzdjMzM3ODRmNDE2NDVmN2I0NGY2YzU5NmE1OGNlOTJlNjY2MTkxYWJlM2UnLFxuICAgICAgICAnYzUzNGFkNDQxNzVmYmMzMDBmNGVhNmNlNjQ4MzA5YTA0MmNlNzM5YTc5MTk3OThjZDg1ZTIxNmM0YTMwN2Y2ZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmMTNhZGE5NTEwM2M0NTM3MzA1ZTY5MWU3NGU5YTRhOGRkNjQ3ZTcxMWE5NWU3M2NiNjJkYzYwMThjZmQ4N2I4JyxcbiAgICAgICAgJ2UxMzgxN2I0NGVlMTRkZTY2M2JmNGJjODA4MzQxZjMyNjk0OWUyMWE2YTc1YzI1NzA3Nzg0MTliZGFmNTczM2QnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzc1NGI0ZmEwZThhY2VkMDZkNDE2N2EyYzU5Y2NhNGNkYTE4NjljMDZlYmFkZmI2NDg4NTUwMDE1YTg4NTIyYycsXG4gICAgICAgICczMGU5M2U4NjRlNjY5ZDgyMjI0Yjk2N2MzMDIwYjhmYThkMWU0ZTM1MGI2Y2JjYzUzN2E0OGI1Nzg0MTE2M2EyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzk0OGRjYWRmNTk5MGUwNDhhYTM4NzRkNDZhYmVmOWQ3MDE4NThmOTVkZTgwNDFkMmE2ODI4Yzk5ZTIyNjI1MTknLFxuICAgICAgICAnZTQ5MWE0MjUzN2Y2ZTU5N2Q1ZDI4YTMyMjRiMWJjMjVkZjkxNTRlZmJkMmVmMWQyY2JiYTJjYWU1MzQ3ZDU3ZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3OTYyNDE0NDUwYzc2YzE2ODljN2I0OGY4MjAyZWMzN2ZiMjI0Y2Y1YWMwYmZhMTU3MDMyOGE4YTNkN2M3N2FiJyxcbiAgICAgICAgJzEwMGI2MTBlYzRmZmI0NzYwZDVjMWZjMTMzZWY2ZjZiMTI1MDdhMDUxZjA0YWM1NzYwYWZhNWIyOWRiODM0MzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzUxNDA4NzgzNDk2NGI1NGIxNWIxNjA2NDRkOTE1NDg1YTE2OTc3MjI1Yjg4NDdiYjBkZDA4NTEzN2VjNDdjYScsXG4gICAgICAgICdlZjBhZmJiMjA1NjIwNTQ0OGUxNjUyYzQ4ZTgxMjdmYzYwMzllNzdjMTVjMjM3OGI3ZTdkMTVhMGRlMjkzMzExJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2QzY2MzMGFkNmI0ODNlNGJjNzljZTJjOWRkOGJjNTQ5OTNlOTQ3ZWI4ZGY3ODdiNDQyOTQzZDNmN2I1MjdlYWYnLFxuICAgICAgICAnOGIzNzhhMjJkODI3Mjc4ZDg5YzVlOWJlOGY5NTA4YWUzYzJhZDQ2MjkwMzU4NjMwYWZiMzRkYjA0ZWVkZTBhNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNjI0ZDg0NzgwNzMyODYwY2UxYzc4ZmNiZmVmZTA4YjJiMjk4MjNkYjkxM2Y2NDkzOTc1YmEwZmY0ODQ3NjEwJyxcbiAgICAgICAgJzY4NjUxY2Y5YjZkYTkwM2UwOTE0NDQ4YzZjZDlkNGNhODk2ODc4ZjUyODJiZTRjOGNjMDZlMmE0MDQwNzg1NzUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzMzY2U4MGRhOTU1YThhMjY5MDJjOTU2MzNlNjJhOTg1MTkyNDc0YjVhZjIwN2RhNmRmN2I0ZmQ1ZmM2MWNkNCcsXG4gICAgICAgICdmNTQzNWEyYmQyYmFkZjdkNDg1YTRkOGI4ZGI5ZmNjZTNlMWVmOGUwMjAxZTQ1NzhjNTQ2NzNiYzFkYzVlYTFkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE1ZDk0NDEyNTQ5NDUwNjRjZjFhMWMzM2JiZDNiNDlmODk2NmM1MDkyMTcxZTY5OWVmMjU4ZGZhYjgxYzA0NWMnLFxuICAgICAgICAnZDU2ZWIzMGI2OTQ2M2U3MjM0ZjUxMzdiNzNiODQxNzc0MzQ4MDBiYWNlYmZjNjg1ZmMzN2JiZTllZmU0MDcwZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhMWQwZmNmMmVjOWRlNjc1YjYxMjEzNmU1Y2U3MGQyNzFjMjE0MTdjOWQyYjhhYWFhYzEzODU5OWQwNzE3OTQwJyxcbiAgICAgICAgJ2VkZDc3ZjUwYmNiNWEzY2FiMmU5MDczNzMwOTY2N2YyNjQxNDYyYTU0MDcwZjNkNTE5MjEyZDM5YzE5N2E2MjknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTIyZmJlMTVjMGFmOGNjYzU3ODBjMDczNWY4NGRiZTlhNzkwYmFkZWU4MjQ1YzA2YzdjYTM3MzMxY2IzNjk4MCcsXG4gICAgICAgICdhODU1YmFiYWQ1Y2Q2MGM4OGI0MzBhNjlmNTNhMWE3YTM4Mjg5MTU0OTY0Nzk5YmU0M2QwNmQ3N2QzMWRhMDYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzExMDkxZGQ5ODYwZThlMjBlZTEzNDczYzExNTVmNWY2OTYzNWUzOTQ3MDRlYWE3NDAwOTQ1MjI0NmNmYTliMycsXG4gICAgICAgICc2NmRiNjU2Zjg3ZDFmMDRmZmZkMWYwNDc4OGMwNjgzMDg3MWVjNWE2NGZlZWU2ODViZDgwZjBiMTI4NmQ4Mzc0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM0YzFmZDA0ZDMwMWJlODliMzFjMDQ0MmQzZTZhYzI0ODgzOTI4YjQ1YTkzNDA3ODE4NjdkNDIzMmVjMmRiZGYnLFxuICAgICAgICAnOTQxNDY4NWU5N2IxYjU5NTRiZDQ2ZjczMDE3NDEzNmQ1N2YxY2VlYjQ4NzQ0M2RjNTMyMTg1N2JhNzNhYmVlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YyMTllYTVkNmI1NDcwMWMxYzE0ZGU1YjU1N2ViNDJhOGQxM2YzYWJiY2QwOGFmZmNjMmE1ZTZiMDQ5YjhkNjMnLFxuICAgICAgICAnNGNiOTU5NTdlODNkNDBiMGY3M2FmNDU0NGNjY2Y2YjFmNGIwOGQzYzA3YjI3ZmI4ZDhjMjk2MmE0MDA3NjZkMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkN2I4NzQwZjc0YThmYmFhYjFmNjgzZGI4ZjQ1ZGUyNjU0M2E1NDkwYmNhNjI3MDg3MjM2OTEyNDY5YTBiNDQ4JyxcbiAgICAgICAgJ2ZhNzc5NjgxMjhkOWM5MmVlMTAxMGYzMzdhZDQ3MTdlZmYxNWRiNWVkM2MwNDliMzQxMWUwMzE1ZWFhNDU5M2InXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzJkMzFjMjIyZjhmNmYwZWY4NmY3Yzk4ZDNhMzMzNWVhZDViY2QzMmFiZGQ5NDI4OWZlNGQzMDkxYWE4MjRiZicsXG4gICAgICAgICc1ZjMwMzJmNTg5MjE1NmUzOWNjZDNkNzkxNWI5ZTFkYTJlNmRhYzllNmYyNmU5NjExMThkMTRiODQ2MmUxNjYxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc0NjFmMzcxOTE0YWIzMjY3MTA0NWExNTVkOTgzMWVhODc5M2Q3N2NkNTk1OTJjNDM0MGY4NmNiYzE4MzQ3YjUnLFxuICAgICAgICAnOGVjMGJhMjM4Yjk2YmVjMGNiZGRkY2FlMGFhNDQyNTQyZWVlMWZmNTBjOTg2ZWE2YjM5ODQ3YjNjYzA5MmZmNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlZTA3OWFkYjFkZjE4NjAwNzQzNTZhMjVhYTM4MjA2YTZkNzE2YjJjM2U2NzQ1M2QyODc2OThiYWQ3YjJiMmQ2JyxcbiAgICAgICAgJzhkYzI0MTJhYWZlM2JlNWM0YzVmMzdlMGVjYzVmOWY2YTQ0Njk4OWFmMDRjNGUyNWViYWFjNDc5ZWMxYzhjMWUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTZlYzkzZTQ0N2VjODNmMDQ2N2IxODMwMmVlNjIwZjdlNjVkZTMzMTg3NGM5ZGM3MmJmZDg2MTZiYTlkYTZiNScsXG4gICAgICAgICc1ZTQ2MzExNTBlNjJmYjQwZDBlOGMyYTdjYTU4MDRhMzlkNTgxODZhNTBlNDk3MTM5NjI2Nzc4ZTI1YjA2NzRkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VhYTVmOTgwYzI0NWY2ZjAzODk3ODI5MGFmYTcwYjZiZDg4NTU4OTdmOThiNmFhNDg1Yjk2MDY1ZDUzN2JkOTknLFxuICAgICAgICAnZjY1ZjVkM2UyOTJjMmUwODE5YTUyODM5MWM5OTQ2MjRkNzg0ODY5ZDdlNmVhNjdmYjE4MDQxMDI0ZWRjMDdkYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3OGM5NDA3NTQ0YWMxMzI2OTJlZTE5MTBhMDI0Mzk5NThhZTA0ODc3MTUxMzQyZWE5NmM0YjZiMzVhNDlmNTEnLFxuICAgICAgICAnZjNlMDMxOTE2OWViOWI4NWQ1NDA0Nzk1NTM5YTVlNjhmYTFmYmQ1ODNjMDY0ZDI0NjJiNjc1ZjE5NGEzZGRiNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0OTRmNGJlMjE5YTFhNzcwMTZkY2Q4Mzg0MzFhZWEwMDAxY2RjOGFlN2E2ZmM2ODg3MjY1NzhkOTcwMjg1N2E1JyxcbiAgICAgICAgJzQyMjQyYTk2OTI4M2E1ZjMzOWJhN2YwNzVlMzZiYTJhZjkyNWNlMzBkNzY3ZWQ2ZTU1ZjRiMDMxODgwZDU2MmMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTU5OGE4MDMwZGE2ZDg2YzZiYzdmMmY1MTQ0ZWE1NDlkMjgyMTFlYTU4ZmFhNzBlYmY0YzFlNjY1YzFmZTliNScsXG4gICAgICAgICcyMDRiNWQ2Zjg0ODIyYzMwN2U0YjRhNzE0MDczN2FlYzIzZmM2M2I2NWIzNWY4NmExMDAyNmRiZDJkODY0ZTZiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M0MTkxNjM2NWFiYjJiNWQwOTE5MmY1ZjJkYmVhZmVjMjA4ZjAyMGYxMjU3MGExODRkYmFkYzNlNTg1OTU5OTcnLFxuICAgICAgICAnNGYxNDM1MWQwMDg3ZWZhNDlkMjQ1YjMyODk4NDk4OWQ1Y2FmOTQ1MGYzNGJmYzBlZDE2ZTk2YjU4ZmE5OTEzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg0MWQ2MDYzYTU4NmZhNDc1YTcyNDYwNGRhMDNiYzViOTJhMmUwZDJlMGEzNmFjZmU0YzczYTU1MTQ3NDI4ODEnLFxuICAgICAgICAnNzM4NjdmNTljMDY1OWU4MTkwNGY5YTFjNzU0MzY5OGU2MjU2MmQ2NzQ0YzE2OWNlN2EzNmRlMDFhOGQ2MTU0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzVlOTViYjM5OWE2OTcxZDM3NjAyNjk0N2Y4OWJkZTJmMjgyYjMzODEwOTI4YmU0ZGVkMTEyYWM0ZDcwZTIwZDUnLFxuICAgICAgICAnMzlmMjNmMzY2ODA5MDg1YmVlYmZjNzExODEzMTM3NzVhOTljOWFlZDdkOGJhMzhiMTYxMzg0Yzc0NjAxMjg2NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNmU0NjQxYTUzOTQ4ZmQ0NzZjMzlmOGE5OWZkOTc0ZTVlYzA3NTY0YjUzMTVkOGJmOTk0NzFiY2EwZWYyZjY2JyxcbiAgICAgICAgJ2QyNDI0YjFiMWFiZTRlYjgxNjQyMjdiMDg1YzlhYTk0NTZlYTEzNDkzZmQ1NjNlMDZmZDUxY2Y1Njk0Yzc4ZmMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzM2NTgxZWE3YmZiYmIyOTBjMTkxYTJmNTA3YTQxY2Y1NjQzODQyMTcwZTkxNGZhZWFiMjdjMmM1NzlmNzI2JyxcbiAgICAgICAgJ2VhZDEyMTY4NTk1ZmUxYmU5OTI1MjEyOWI2ZTU2YjMzOTFmN2FiMTQxMGNkMWUwZWYzZGNkY2FiZDJmZGEyMjQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGFiODk4MTZkYWRmZDZiNmExZjI2MzRmY2YwMGVjODQwMzc4MTAyNWVkNjg5MGM0ODQ5NzQyNzA2YmQ0M2VkZScsXG4gICAgICAgICc2ZmRjZWYwOWYyZjZkMGEwNDRlNjU0YWVmNjI0MTM2ZjUwM2Q0NTljM2U4OTg0NTg1OGE0N2E5MTI5Y2RkMjRlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzFlMzNmMWE3NDZjOWM1Nzc4MTMzMzQ0ZDkyOTlmY2FhMjBiMDkzOGU4YWNmZjI1NDRiYjQwMjg0YjhjNWZiOTQnLFxuICAgICAgICAnNjA2NjAyNTdkZDExYjNhYTljOGVkNjE4ZDI0ZWRmZjIzMDZkMzIwZjFkMDMwMTBlMzNhN2QyMDU3ZjNiM2I2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg1YjdjMWRjYjNjZWMxYjdlZTdmMzBkZWQ3OWRkMjBhMGVkMWY0Y2MxOGNiY2ZjZmE0MTAzNjFmZDhmMDhmMzEnLFxuICAgICAgICAnM2Q5OGE5Y2RkMDI2ZGQ0M2YzOTA0OGYyNWE4ODQ3ZjRmY2FmYWQxODk1ZDdhNjMzYzZmZWQzYzM1ZTk5OTUxMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyOWRmOWZiZDhkOWU0NjUwOTI3NWY0YjEyNWQ2ZDQ1ZDdmYmU5YTNiODc4YTdhZjg3MmEyODAwNjYxYWM1ZjUxJyxcbiAgICAgICAgJ2I0YzRmZTk5Yzc3NWE2MDZlMmQ4ODYyMTc5MTM5ZmZkYTYxZGM4NjFjMDE5ZTU1Y2QyODc2ZWIyYTI3ZDg0YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhMGIxY2FlMDZiMGE4NDdhM2ZlYTZlNjcxYWFmOGFkZmRmZTU4Y2EyZjc2ODEwNWM4MDgyYjJlNDQ5ZmNlMjUyJyxcbiAgICAgICAgJ2FlNDM0MTAyZWRkZTA5NThlYzRiMTlkOTE3YTZhMjhlNmI3MmRhMTgzNGFmZjBlNjUwZjA0OTUwM2EyOTZjZjInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNGU4Y2VhZmI5YjNlOWExMzZkYzdmZjY3ZTg0MDI5NWI0OTlkZmIzYjIxMzNlNGJhMTEzZjJlNGMwZTEyMWU1JyxcbiAgICAgICAgJ2NmMjE3NDExOGM4YjZkN2E0YjQ4ZjZkNTM0Y2U1Yzc5NDIyYzA4NmE2MzQ2MDUwMmI4MjdjZTYyYTMyNjY4M2MnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDI0YTQ0ZTA0N2UxOWI2ZjVhZmI4MWM3Y2EyZjY5MDgwYTUwNzY2ODlhMDEwOTE5ZjQyNzI1YzJiNzg5YTMzYicsXG4gICAgICAgICc2ZmI4ZDU1OTFiNDY2ZjhmYzYzZGI1MGYxYzBmMWM2OTAxM2Y5OTY4ODdiODI0NGQyY2RlYzQxN2FmZWE4ZmEzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VhMDE2MDZhN2E2YzljZGQyNDlmZGZjZmFjYjk5NTg0MDAxZWRkMjhhYmJhYjc3YjUxMDRlOThlOGUzYjM1ZDQnLFxuICAgICAgICAnMzIyYWY0OTA4YzczMTJiMGNmYmZlMzY5ZjdhN2IzY2RiN2Q0NDk0YmMyODIzNzAwY2ZkNjUyMTg4YTNlYTk4ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhZjhhZGRiZjJiNjYxYzhhNmM2MzI4NjU1ZWI5NjY1MTI1MjAwN2Q4YzVlYTMxYmU0YWQxOTZkZThjZTIxMzFmJyxcbiAgICAgICAgJzY3NDllNjdjMDI5Yjg1ZjUyYTAzNGVhZmQwOTY4MzZiMjUyMDgxODY4MGUyNmFjOGYzZGZiY2RiNzE3NDk3MDAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTNhZTE5NzQ1NjZjYTA2Y2M1MTZkNDdlMGZiMTY1YTY3NGEzZGFiY2ZjYTE1ZTcyMmYwZTM0NTBmNDU4ODknLFxuICAgICAgICAnMmFlYWJlN2U0NTMxNTEwMTE2MjE3ZjA3YmY0ZDA3MzAwZGU5N2U0ODc0ZjgxZjUzMzQyMGE3MmVlYjBiZDZhNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1OTFlZTM1NTMxM2Q5OTcyMWNmNjk5M2ZmZWQxZTNlMzAxOTkzZmYzZWQyNTg4MDIwNzVlYThjZWQzOTdlMjQ2JyxcbiAgICAgICAgJ2IwZWE1NThhMTEzYzMwYmVhNjBmYzQ3NzU0NjBjNzkwMWZmMGIwNTNkMjVjYTJiZGVlZTk4ZjFhNGJlNWQxOTYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTEzOTZkNTVmZGE1NGM0OWYxOWFhOTczMThkOGRhNjFmYTg1ODRlNDdiMDg0OTQ1MDc3Y2YwMzI1NWI1Mjk4NCcsXG4gICAgICAgICc5OThjNzRhOGNkNDVhYzAxMjg5ZDU4MzNhN2JlYjQ3NDRmZjUzNmIwMWIyNTdiZTRjNTc2N2JlYTkzZWE1N2E0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzNjNWQyYTFiYTM5YzVhMTc5MDAwMDczOGM5ZTBjNDBiOGRjZGZkNTQ2ODc1NGI2NDA1NTQwMTU3ZTAxN2FhN2EnLFxuICAgICAgICAnYjIyODQyNzk5OTVhMzRlMmY5ZDRkZTczOTZmYzE4YjgwZjliOGI5ZmRkMjcwZjY2NjFmNzljYTRjODFiZDI1NydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjYzg3MDRiOGE2MGEwZGVmYTNhOTlhNzI5OWYyZTljM2ZiYzM5NWFmYjA0YWMwNzg0MjVlZjhhMTc5M2NjMDMwJyxcbiAgICAgICAgJ2JkZDQ2MDM5ZmVlZDE3ODgxZDFlMDg2MmRiMzQ3ZjhjZjM5NWI3NGZjNGJjZGM0ZTk0MGI3NGUzYWMxZjFiMTMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzUzM2U0ZjdlYTg1NTVhYWNkOTc3N2FjNWNhZDI5Yjk3ZGQ0ZGVmY2NjNTNlZTdlYTIwNDExOWIyODg5YjE5NycsXG4gICAgICAgICc2ZjBhMjU2YmM1ZWZkZjQyOWEyZmI2MjQyZjFhNDNhMmQ5YjkyNWJiNGE0YjNhMjZiYjhlMGY0NWViNTk2MDk2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2MxNGY4ZjJjY2IyN2Q2ZjEwOWY2ZDA4ZDAzY2M5NmE2OWJhOGMzNGVlYzA3YmJjZjU2NmQ0OGUzM2RhNjU5MycsXG4gICAgICAgICdjMzU5ZDY5MjNiYjM5OGY3ZmQ0NDczZTE2ZmUxYzI4NDc1Yjc0MGRkMDk4MDc1ZTZjMGU4NjQ5MTEzZGMzYTM4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2E2Y2JjMzA0NmJjNmE0NTBiYWMyNDc4OWZhMTcxMTVhNGM5NzM5ZWQ3NWY4ZjIxY2U0NDFmNzJlMGI5MGU2ZWYnLFxuICAgICAgICAnMjFhZTdmNDY4MGU4ODliYjEzMDYxOWUyYzBmOTVhMzYwY2ViNTczYzcwNjAzMTM5ODYyYWZkNjE3ZmE5YjlmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM0N2Q2ZDlhMDJjNDg5MjdlYmZiODZjMTM1OWIxY2FmMTMwYTNjMDI2N2QxMWNlNjM0NGIzOWY5OWQ0M2NjMzgnLFxuICAgICAgICAnNjBlYTdmNjFhMzUzNTI0ZDFjOTg3ZjZlY2VjOTJmMDg2ZDU2NWFiNjg3ODcwY2IxMjY4OWZmMWUzMWM3NDQ0OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkYTY1NDVkMjE4MWRiOGQ5ODNmN2RjYjM3NWVmNTg2NmQ0N2M2N2IxYmYzMWM4Y2Y4NTVlZjc0MzdiNzI2NTZhJyxcbiAgICAgICAgJzQ5Yjk2NzE1YWI2ODc4YTc5ZTc4ZjA3Y2U1NjgwYzVkNjY3MzA1MWI0OTM1YmQ4OTdmZWE4MjRiNzdkYzIwOGEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzQwNzQ3Y2M5ZDAxMmNiMWExM2I4MTQ4MzA5YzZkZTdlYzI1ZDY5NDVkNjU3MTQ2YjlkNTk5NGI4ZmViMTExMScsXG4gICAgICAgICc1Y2E1NjA3NTNiZTJhMTJmYzZkZTZjYWYyY2I0ODk1NjVkYjkzNjE1NmI5NTE0ZTFiYjVlODMwMzdlMGZhMmQ0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzRlNDJjOGVjODJjOTk3OThjY2YzYTYxMGJlODcwZTc4MzM4YzdmNzEzMzQ4YmQzNGM4MjAzZWY0MDM3ZjM1MDInLFxuICAgICAgICAnNzU3MWQ3NGVlNWUwZmI5MmE3YThiMzNhMDc3ODMzNDFhNTQ5MjE0NGNjNTRiY2M0MGE5NDQ3MzY5MzYwNjQzNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNzc1YWI3MDg5YmM2YWY4MjNhYmEyZTFhZjcwYjIzNmQyNTFjYWRiMGM4Njc0MzI4NzUyMmExYjNiMGRlZGVhJyxcbiAgICAgICAgJ2JlNTJkMTA3YmNmYTA5ZDhiY2I5NzM2YTgyOGNmYTdmYWM4ZGIxN2JmN2E3NmEyYzQyYWQ5NjE0MDkwMThjZjcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnY2VlMzFjYmY3ZTM0ZWMzNzlkOTRmYjgxNGQzZDc3NWFkOTU0NTk1ZDEzMTRiYTg4NDY5NTllM2U4MmY3NGUyNicsXG4gICAgICAgICc4ZmQ2NGExNGMwNmI1ODljMjZiOTQ3YWUyYmNmNmJmYTAxNDllZjBiZTE0ZWQ0ZDgwZjQ0OGEwMWM0M2IxYzZkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2I0ZjllYWVhMDliNjkxNzYxOWY2ZWE2YTRlYjU0NjRlZmRkYjU4ZmQ0NWIxZWJlZmNkYzFhMDFkMDhiNDc5ODYnLFxuICAgICAgICAnMzllNWM5OTI1YjVhNTRiMDc0MzNhNGYxOGM2MTcyNmY4YmIxMzFjMDEyY2E1NDJlYjI0YThhYzA3MjAwNjgyYSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkNDI2M2RmYzNkMmRmOTIzYTAxNzlhNDg5NjZkMzBjZTg0ZTI1MTVhZmMzZGNjYzFiNzc5MDc3OTJlYmNjNjBlJyxcbiAgICAgICAgJzYyZGZhZjA3YTBmNzhmZWIzMGUzMGQ2Mjk1ODUzY2UxODllMTI3NzYwYWQ2Y2Y3ZmFlMTY0ZTEyMmEyMDhkNTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDg0NTc1MjQ4MjBmYTY1YTRmOGQzNWViNjkzMDg1N2MwMDMyYWNjMGE0YTJkZTQyMjIzM2VlZGE4OTc2MTJjNCcsXG4gICAgICAgICcyNWE3NDhhYjM2Nzk3OWQ5ODczM2MzOGExZmExYzJlN2RjNmNjMDdkYjJkNjBhOWFlN2E3NmFhYTQ5YmQwZjc3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RmZWVlZjE4ODExMDFmMmNiMTE2NDRmM2EyYWZkZmMyMDQ1ZTE5OTE5MTUyOTIzZjM2N2ExNzY3YzExY2NlZGEnLFxuICAgICAgICAnZWNmYjcwNTZjZjFkZTA0MmY5NDIwYmFiMzk2NzkzYzBjMzkwYmRlNzRiNGJiZGZmMTZhODNhZTA5YTlhNzUxNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2ZDdlZjZiMTc1NDNmODM3M2M1NzNmNDRlMWYzODk4MzVkODliY2JjNjA2MmNlZDM2YzgyZGY4M2I4ZmFlODU5JyxcbiAgICAgICAgJ2NkNDUwZWMzMzU0Mzg5ODZkZmVmYTEwYzU3ZmVhOWJjYzUyMWEwOTU5YjJkODBiYmY3NGIxOTBkY2E3MTJkMTAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTc1NjA1ZDU5MTAyYTVhMjY4NDUwMGQzYjk5MWYyZTNmM2M4OGI5MzIyNTU0NzAzNWFmMjVhZjY2ZTA0NTQxZicsXG4gICAgICAgICdmNWM1NDc1NGE4ZjcxZWU1NDBiOWI0ODcyODQ3M2UzMTRmNzI5YWM1MzA4YjA2OTM4MzYwOTkwZTJiZmFkMTI1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ViOTg2NjBmNGM0ZGZhYTA2YTJiZTQ1M2Q1MDIwYmM5OWEwYzJlNjBhYmUzODg0NTdkZDQzZmVmYjFlZDYyMGMnLFxuICAgICAgICAnNmNiOWE4ODc2ZDljYjg1MjA2MDlhZjNhZGQyNmNkMjBhMGE3Y2Q4YTk0MTExMzFjZTg1ZjQ0MTAwMDk5MjIzZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxM2U4N2IwMjdkODUxNGQzNTkzOWYyZTY4OTJiMTk5MjIxNTQ1OTY5NDE4ODgzMzZkYzM1NjNlM2I4ZGJhOTQyJyxcbiAgICAgICAgJ2ZlZjVhM2M2ODA1OWE2ZGVjNWQ2MjQxMTRiZjFlOTFhYWMyYjlkYTU2OGQ2YWJlYjI1NzBkNTU2NDZiOGFkZjEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWUxNjMwMjZlOWZkNmZlMDE3YzM4ZjA2YTViZTZmYzEyNTQyNGIzNzFjZTI3MDhlN2JmNDQ5MTY5MWU1NzY0YScsXG4gICAgICAgICcxYWNiMjUwZjI1NWRkNjFjNDNkOTRjY2M2NzBkMGY1OGY0OWFlM2ZhMTViOTY2MjNlNTQzMGRhMGFkNmM2MmIyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2IyNjhmNWVmOWFkNTFlNGQ3OGRlM2E3NTBjMmRjODliMWU2MjZkNDM1MDU4Njc5OTk5MzJlNWRiMzNhZjNkODAnLFxuICAgICAgICAnNWYzMTBkNGIzYzk5YjllYmIxOWY3N2Q0MWMxZGVlMDE4Y2YwZDM0ZmQ0MTkxNjE0MDAzZTk0NWExMjE2ZTQyMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmZjA3ZjMxMThhOWRmMDM1ZTlmYWQ4NWViNmM3YmZlNDJiMDJmMDFjYTk5Y2VlYTNiZjdmZmRiYTkzYzQ3NTBkJyxcbiAgICAgICAgJzQzODEzNmQ2MDNlODU4YTNhNWM0NDBjMzhlY2NiYWRkYzFkMjk0MjExNGUyZWRkZDQ3NDBkMDk4Y2VkMWYwZDgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGQ4Yjk4NTVjN2MwNTJhMzQxNDZmZDIwZmZiNjU4YmVhNGI5ZjY5ZTBkODI1ZWJlYzE2ZThjM2NlMmI1MjZhMScsXG4gICAgICAgICdjZGI1NTllZWRjMmQ3OWY5MjZiYWY0NGZiODRlYTRkNDRiY2Y1MGZlZTUxZDdjZWIzMGUyZTdmNDYzMDM2NzU4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzUyZGIwYjUzODRkZmJmMDViZmE5ZDQ3MmQ3YWUyNmRmZTRiODUxY2VjYTkxYjFlYmE1NDI2MzE4MGRhMzJiNjMnLFxuICAgICAgICAnYzNiOTk3ZDA1MGVlNWQ0MjNlYmFmNjZhNmRiOWY1N2IzMTgwYzkwMjg3NTY3OWRlOTI0YjY5ZDg0YTdiMzc1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U2MmY5NDkwZDNkNTFkYTYzOTVlZmQyNGU4MDkxOWNjN2QwZjI5YzNmM2ZhNDhjNmZmZjU0M2JlY2JkNDMzNTInLFxuICAgICAgICAnNmQ4OWFkN2JhNDg3NmIwYjIyYzJjYTI4MGM2ODI4NjJmMzQyYzg1OTFmMWRhZjUxNzBlMDdiZmQ5Y2NhZmE3ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3ZjMwZWEyNDc2YjM5OWI0OTU3NTA5Yzg4Zjc3ZDAxOTFhZmEyZmY1Y2I3YjE0ZmQ2ZDhlN2Q2NWFhYWIxMTkzJyxcbiAgICAgICAgJ2NhNWVmN2Q0YjIzMWM5NGMzYjE1Mzg5YTVmNjMxMWU5ZGFmZjdiYjY3YjEwM2U5ODgwZWY0YmZmNjM3YWNhZWMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTA5OGZmMWUxZDlmMTRmYjQ2YTIxMGZhZGE2YzkwM2ZlZjBmYjdiNGExZGQxZDlhYzYwYTAzNjE4MDBiN2EwMCcsXG4gICAgICAgICc5NzMxMTQxZDgxZmM4ZjgwODRkMzdjNmU3NTQyMDA2YjNlZTFiNDBkNjBkZmU1MzYyYTViMTMyZmQxN2RkYzAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzJiNzhjN2RlOWVlNTEyYTcyODk1YmU2YjljYmVmYTZlMmYzYzRjY2NlNDQ1Yzk2YjlmMmM4MWUyNzc4YWQ1OCcsXG4gICAgICAgICdlZTE4NDlmNTEzZGY3MWUzMmVmYzM4OTZlZTI4MjYwYzczYmI4MDU0N2FlMjI3NWJhNDk3MjM3Nzk0Yzg3NTNjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UyY2I3NGZkZGM4ZTlmYmNkMDc2ZWVmMmE3YzcyYjBjZTM3ZDUwZjA4MjY5ZGZjMDc0YjU4MTU1MDU0N2E0ZjcnLFxuICAgICAgICAnZDNhYTJlZDcxYzlkZDIyNDdhNjJkZjA2MjczNmViMGJhZGRlYTllMzYxMjJkMmJlODY0MWFiY2IwMDVjYzRhNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NDM4NDQ3NTY2ZDRkN2JlZGFkYzI5OTQ5NmFiMzU3NDI2MDA5YTM1ZjIzNWNiMTQxYmUwZDk5Y2QxMGFlM2E4JyxcbiAgICAgICAgJ2M0ZTEwMjA5MTY5ODBhNGRhNWQwMWFjNWU2YWQzMzA3MzRlZjBkNzkwNjYzMWM0ZjIzOTA0MjZiMmVkZDc5MWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDE2MmQ0ODhiODk0MDIwMzliNTg0YzZmYzZjMzA4ODcwNTg3ZDljNDZmNjYwYjg3OGFiNjVjODJjNzExZDY3ZScsXG4gICAgICAgICc2NzE2M2U5MDMyMzYyODlmNzc2ZjIyYzI1ZmI4YTNhZmMxNzMyZjJiODRiNGU5NWRiZGE0N2FlNWEwODUyNjQ5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzNmYWQzZmE4NGNhZjBmMzRmMGY4OWJmZDJkY2Y1NGZjMTc1ZDc2N2FlYzNlNTA2ODRmM2JhNGE0YmY1ZjY4M2QnLFxuICAgICAgICAnY2QxYmM3Y2I2Y2M0MDdiYjJmMGNhNjQ3YzcxOGE3MzBjZjcxODcyZTdkMGQyYTUzZmEyMGVmY2RmZTYxODI2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzY3NGYyNjAwYTMwMDdhMDA1NjhjMWE3Y2UwNWQwODE2YzFmYjg0YmYxMzcwNzk4ZjFjNjk1MzJmYWViMWE4NmInLFxuICAgICAgICAnMjk5ZDIxZjk0MTNmMzNiM2VkZjQzYjI1NzAwNDU4MGI3MGRiNTdkYTBiMTgyMjU5ZTA5ZWVjYzY5ZTBkMzhhNSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkMzJmNGRhNTRhZGU3NGFiYjgxYjgxNWFkMWZiM2IyNjNkODJkNmM2OTI3MTRiY2ZmODdkMjliZDVlZTlmMDhmJyxcbiAgICAgICAgJ2Y5NDI5ZTczOGI4ZTUzYjk2OGU5OTAxNmMwNTk3MDc3ODJlMTRmNDUzNTM1OWQ1ODJmYzQxNjkxMGIzZWVhODcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzBlNGU2NzA0MzUzODU1NTZlNTkzNjU3MTM1ODQ1ZDM2ZmJiNjkzMWY3MmIwOGNiMWVkOTU0ZjFlM2NlM2ZmNicsXG4gICAgICAgICc0NjJmOWJjZTYxOTg5ODYzODQ5OTM1MDExM2JiYzliMTBhODc4ZDM1ZGE3MDc0MGRjNjk1YTU1OWViODhkYjdiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2JlMjA2MjAwM2M1MWNjMzAwNDY4MjkwNDMzMGU0ZGVlN2YzZGNkMTBiMDFlNTgwYmYxOTcxYjA0ZDRjYWQyOTcnLFxuICAgICAgICAnNjIxODhiYzQ5ZDYxZTU0Mjg1NzNkNDhhNzRlMWM2NTViMWM2MTA5MDkwNTY4MmEwZDU1NThlZDcyZGNjYjliYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5MzE0NDQyM2FjZTM0NTFlZDI5ZTBmYjlhYzJhZjIxMWNiNmU4NGE2MDFkZjU5OTNjNDE5ODU5ZmZmNWRmMDRhJyxcbiAgICAgICAgJzdjMTBkZmIxNjRjMzQyNWY1YzcxYTNmOWQ3OTkyMDM4ZjEwNjUyMjRmNzJiYjlkMWQ5MDJhNmQxMzAzN2I0N2MnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjAxNWY4MDQ0ZjVmY2JkY2YyMWNhMjZkNmMzNGZiODE5NzgyOTIwNWM3YjdkMmE3Y2I2NjQxOGMxNTdiMTEyYycsXG4gICAgICAgICdhYjhjMWUwODZkMDRlODEzNzQ0YTY1NWIyZGY4ZDVmODNiM2NkYzZmYWEzMDg4YzFkM2FlYTE0NTRlM2ExZDVmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q1ZTllMWRhNjQ5ZDk3ZDg5ZTQ4NjgxMTdhNDY1YTNhNGY4YTE4ZGU1N2ExNDBkMzZiM2YyYWYzNDFhMjFiNTInLFxuICAgICAgICAnNGNiMDQ0MzdmMzkxZWQ3MzExMWExM2NjMWQ0ZGQwZGIxNjkzNDY1YzIyNDA0ODBkODk1NWU4NTkyZjI3NDQ3YSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkM2FlNDEwNDdkZDdjYTA2NWRiZjhlZDc3Yjk5MjQzOTk4MzAwNWNkNzJlMTZkNmY5OTZhNTMxNmQzNjk2NmJiJyxcbiAgICAgICAgJ2JkMWFlYjIxYWQyMmViYjIyYTEwZjAzMDM0MTdjNmQ5NjRmOGNkZDdkZjBhY2E2MTRiMTBkYzE0ZDEyNWFjNDYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDYzZTI3NjNkODg1Zjk1OGZjNjZjZGQyMjgwMGYwYTQ4NzE5N2QwYTgyZTM3N2I0OWY4MGFmODdjODk3YjA2NScsXG4gICAgICAgICdiZmVmYWNkYjBlNWQwZmQ3ZGYzYTMxMWE5NGRlMDYyYjI2YjgwYzYxZmJjOTc1MDhiNzk5OTI2NzFlZjdjYTdmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc5ODVmZGZkMTI3YzA1NjdjNmY1M2VjMWJiNjNlYzMxNThlNTk3YzQwYmZlNzQ3YzgzY2RkZmM5MTA2NDE5MTcnLFxuICAgICAgICAnNjAzYzEyZGFmM2Q5ODYyZWYyYjI1ZmUxZGUyODlhZWQyNGVkMjkxZTBlYzY3MDg3MDNhNWJkNTY3ZjMyZWQwMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NGExYWQ2YjVmNzZlMzlkYjJkZDI0OTQxMGVhYzdmOTllNzRjNTljYjgzZDJkMGVkNWZmMTU0M2RhNzcwM2U5JyxcbiAgICAgICAgJ2NjNjE1N2VmMThjOWM2M2NkNjE5M2Q4MzYzMWJiZWEwMDkzZTA5Njg5NDJlOGMzM2Q1NzM3ZmQ3OTBlMGRiMDgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzA2ODJhNTA3MDMzNzVmNjAyZDQxNjY2NGJhMTliN2ZjOWJhYjQyYzcyNzQ3NDYzYTcxZDA4OTZiMjJmNmRhMycsXG4gICAgICAgICc1NTNlMDRmNmIwMThiNGZhNmM4ZjM5ZTdmMzExZDMxNzYyOTBkMGUwZjE5Y2E3M2YxNzcxNGQ5OTc3YTIyZmY4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzllMjE1OGYwZDdjMGQ1ZjI2YzM3OTFlZmVmYTc5NTk3NjU0ZTdhMmIyNDY0ZjUyYjFlZTZjMTM0Nzc2OWVmNTcnLFxuICAgICAgICAnNzEyZmNkZDFiOTA1M2YwOTAwM2EzNDgxZmE3NzYyZTlmZmQ3YzhlZjM1YTM4NTA5ZTJmYmYyNjI5MDA4MzczJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE3NmUyNjk4OWE0M2M5Y2ZlYmE0MDI5YzIwMjUzOGMyODE3MmU1NjZlM2M0ZmNlNzMyMjg1N2YzYmUzMjdkNjYnLFxuICAgICAgICAnZWQ4Y2M5ZDA0YjI5ZWI4NzdkMjcwYjQ4NzhkYzQzYzE5YWVmZDMxZjRlZWUwOWVlN2I0NzgzNGMxZmE0YjFjMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NWQ0NmVmZWEzNzcxZTZlNjhhYmI4OWExM2FkNzQ3ZWNmMTg5MjM5M2RmYzRmMWI3MDA0Nzg4YzUwMzc0ZGE4JyxcbiAgICAgICAgJzk4NTIzOTBhOTk1MDc2NzlmZDBiODZmZDJiMzlhODY4ZDdlZmMyMjE1MTM0NmUxYTNjYTQ3MjY1ODZhNmJlZDgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODA5YTIwYzY3ZDY0OTAwZmZiNjk4YzRjODI1ZjZkNWYyMzEwZmIwNDUxYzg2OTM0NWI3MzE5ZjY0NTYwNTcyMScsXG4gICAgICAgICc5ZTk5NDk4MGQ5OTE3ZTIyYjc2YjA2MTkyN2ZhMDQxNDNkMDk2Y2NjNTQ5NjNlNmE1ZWJmYTVmM2Y4ZTI4NmMxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzFiMzg5MDNhNDNmN2YxMTRlZDQ1MDBiNGVhYzcwODNmZGVmZWNlMWNmMjljNjM1MjhkNTYzNDQ2Zjk3MmMxODAnLFxuICAgICAgICAnNDAzNmVkYzkzMWE2MGFlODg5MzUzZjc3ZmQ1M2RlNGEyNzA4YjI2YjZmNWRhNzJhZDMzOTQxMTlkYWY0MDhmOSdcbiAgICAgIF1cbiAgICBdXG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IGV4cG9ydHM7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIG1pbkFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcbnZhciBtaW5VdGlscyA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1jcnlwdG8tdXRpbHMnKTtcblxudXRpbHMuYXNzZXJ0ID0gbWluQXNzZXJ0O1xudXRpbHMudG9BcnJheSA9IG1pblV0aWxzLnRvQXJyYXk7XG51dGlscy56ZXJvMiA9IG1pblV0aWxzLnplcm8yO1xudXRpbHMudG9IZXggPSBtaW5VdGlscy50b0hleDtcbnV0aWxzLmVuY29kZSA9IG1pblV0aWxzLmVuY29kZTtcblxuLy8gUmVwcmVzZW50IG51bSBpbiBhIHctTkFGIGZvcm1cbmZ1bmN0aW9uIGdldE5BRihudW0sIHcpIHtcbiAgdmFyIG5hZiA9IFtdO1xuICB2YXIgd3MgPSAxIDw8ICh3ICsgMSk7XG4gIHZhciBrID0gbnVtLmNsb25lKCk7XG4gIHdoaWxlIChrLmNtcG4oMSkgPj0gMCkge1xuICAgIHZhciB6O1xuICAgIGlmIChrLmlzT2RkKCkpIHtcbiAgICAgIHZhciBtb2QgPSBrLmFuZGxuKHdzIC0gMSk7XG4gICAgICBpZiAobW9kID4gKHdzID4+IDEpIC0gMSlcbiAgICAgICAgeiA9ICh3cyA+PiAxKSAtIG1vZDtcbiAgICAgIGVsc2VcbiAgICAgICAgeiA9IG1vZDtcbiAgICAgIGsuaXN1Ym4oeik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHogPSAwO1xuICAgIH1cbiAgICBuYWYucHVzaCh6KTtcblxuICAgIC8vIE9wdGltaXphdGlvbiwgc2hpZnQgYnkgd29yZCBpZiBwb3NzaWJsZVxuICAgIHZhciBzaGlmdCA9IChrLmNtcG4oMCkgIT09IDAgJiYgay5hbmRsbih3cyAtIDEpID09PSAwKSA/ICh3ICsgMSkgOiAxO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2hpZnQ7IGkrKylcbiAgICAgIG5hZi5wdXNoKDApO1xuICAgIGsuaXVzaHJuKHNoaWZ0KTtcbiAgfVxuXG4gIHJldHVybiBuYWY7XG59XG51dGlscy5nZXROQUYgPSBnZXROQUY7XG5cbi8vIFJlcHJlc2VudCBrMSwgazIgaW4gYSBKb2ludCBTcGFyc2UgRm9ybVxuZnVuY3Rpb24gZ2V0SlNGKGsxLCBrMikge1xuICB2YXIganNmID0gW1xuICAgIFtdLFxuICAgIFtdXG4gIF07XG5cbiAgazEgPSBrMS5jbG9uZSgpO1xuICBrMiA9IGsyLmNsb25lKCk7XG4gIHZhciBkMSA9IDA7XG4gIHZhciBkMiA9IDA7XG4gIHdoaWxlIChrMS5jbXBuKC1kMSkgPiAwIHx8IGsyLmNtcG4oLWQyKSA+IDApIHtcblxuICAgIC8vIEZpcnN0IHBoYXNlXG4gICAgdmFyIG0xNCA9IChrMS5hbmRsbigzKSArIGQxKSAmIDM7XG4gICAgdmFyIG0yNCA9IChrMi5hbmRsbigzKSArIGQyKSAmIDM7XG4gICAgaWYgKG0xNCA9PT0gMylcbiAgICAgIG0xNCA9IC0xO1xuICAgIGlmIChtMjQgPT09IDMpXG4gICAgICBtMjQgPSAtMTtcbiAgICB2YXIgdTE7XG4gICAgaWYgKChtMTQgJiAxKSA9PT0gMCkge1xuICAgICAgdTEgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbTggPSAoazEuYW5kbG4oNykgKyBkMSkgJiA3O1xuICAgICAgaWYgKChtOCA9PT0gMyB8fCBtOCA9PT0gNSkgJiYgbTI0ID09PSAyKVxuICAgICAgICB1MSA9IC1tMTQ7XG4gICAgICBlbHNlXG4gICAgICAgIHUxID0gbTE0O1xuICAgIH1cbiAgICBqc2ZbMF0ucHVzaCh1MSk7XG5cbiAgICB2YXIgdTI7XG4gICAgaWYgKChtMjQgJiAxKSA9PT0gMCkge1xuICAgICAgdTIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbTggPSAoazIuYW5kbG4oNykgKyBkMikgJiA3O1xuICAgICAgaWYgKChtOCA9PT0gMyB8fCBtOCA9PT0gNSkgJiYgbTE0ID09PSAyKVxuICAgICAgICB1MiA9IC1tMjQ7XG4gICAgICBlbHNlXG4gICAgICAgIHUyID0gbTI0O1xuICAgIH1cbiAgICBqc2ZbMV0ucHVzaCh1Mik7XG5cbiAgICAvLyBTZWNvbmQgcGhhc2VcbiAgICBpZiAoMiAqIGQxID09PSB1MSArIDEpXG4gICAgICBkMSA9IDEgLSBkMTtcbiAgICBpZiAoMiAqIGQyID09PSB1MiArIDEpXG4gICAgICBkMiA9IDEgLSBkMjtcbiAgICBrMS5pdXNocm4oMSk7XG4gICAgazIuaXVzaHJuKDEpO1xuICB9XG5cbiAgcmV0dXJuIGpzZjtcbn1cbnV0aWxzLmdldEpTRiA9IGdldEpTRjtcblxuZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkob2JqLCBuYW1lLCBjb21wdXRlcikge1xuICB2YXIga2V5ID0gJ18nICsgbmFtZTtcbiAgb2JqLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIGNhY2hlZFByb3BlcnR5KCkge1xuICAgIHJldHVybiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCA/IHRoaXNba2V5XSA6XG4gICAgICAgICAgIHRoaXNba2V5XSA9IGNvbXB1dGVyLmNhbGwodGhpcyk7XG4gIH07XG59XG51dGlscy5jYWNoZWRQcm9wZXJ0eSA9IGNhY2hlZFByb3BlcnR5O1xuXG5mdW5jdGlvbiBwYXJzZUJ5dGVzKGJ5dGVzKSB7XG4gIHJldHVybiB0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnID8gdXRpbHMudG9BcnJheShieXRlcywgJ2hleCcpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlcztcbn1cbnV0aWxzLnBhcnNlQnl0ZXMgPSBwYXJzZUJ5dGVzO1xuXG5mdW5jdGlvbiBpbnRGcm9tTEUoYnl0ZXMpIHtcbiAgcmV0dXJuIG5ldyBCTihieXRlcywgJ2hleCcsICdsZScpO1xufVxudXRpbHMuaW50RnJvbUxFID0gaW50RnJvbUxFO1xuXG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBNRDUgPSByZXF1aXJlKCdtZDUuanMnKVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbmZ1bmN0aW9uIEVWUF9CeXRlc1RvS2V5IChwYXNzd29yZCwgc2FsdCwga2V5Qml0cywgaXZMZW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFzc3dvcmQpKSBwYXNzd29yZCA9IEJ1ZmZlci5mcm9tKHBhc3N3b3JkLCAnYmluYXJ5JylcbiAgaWYgKHNhbHQpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihzYWx0KSkgc2FsdCA9IEJ1ZmZlci5mcm9tKHNhbHQsICdiaW5hcnknKVxuICAgIGlmIChzYWx0Lmxlbmd0aCAhPT0gOCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NhbHQgc2hvdWxkIGJlIEJ1ZmZlciB3aXRoIDggYnl0ZSBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGtleUxlbiA9IGtleUJpdHMgLyA4XG4gIHZhciBrZXkgPSBCdWZmZXIuYWxsb2Moa2V5TGVuKVxuICB2YXIgaXYgPSBCdWZmZXIuYWxsb2MoaXZMZW4gfHwgMClcbiAgdmFyIHRtcCA9IEJ1ZmZlci5hbGxvYygwKVxuXG4gIHdoaWxlIChrZXlMZW4gPiAwIHx8IGl2TGVuID4gMCkge1xuICAgIHZhciBoYXNoID0gbmV3IE1ENSgpXG4gICAgaGFzaC51cGRhdGUodG1wKVxuICAgIGhhc2gudXBkYXRlKHBhc3N3b3JkKVxuICAgIGlmIChzYWx0KSBoYXNoLnVwZGF0ZShzYWx0KVxuICAgIHRtcCA9IGhhc2guZGlnZXN0KClcblxuICAgIHZhciB1c2VkID0gMFxuXG4gICAgaWYgKGtleUxlbiA+IDApIHtcbiAgICAgIHZhciBrZXlTdGFydCA9IGtleS5sZW5ndGggLSBrZXlMZW5cbiAgICAgIHVzZWQgPSBNYXRoLm1pbihrZXlMZW4sIHRtcC5sZW5ndGgpXG4gICAgICB0bXAuY29weShrZXksIGtleVN0YXJ0LCAwLCB1c2VkKVxuICAgICAga2V5TGVuIC09IHVzZWRcbiAgICB9XG5cbiAgICBpZiAodXNlZCA8IHRtcC5sZW5ndGggJiYgaXZMZW4gPiAwKSB7XG4gICAgICB2YXIgaXZTdGFydCA9IGl2Lmxlbmd0aCAtIGl2TGVuXG4gICAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oaXZMZW4sIHRtcC5sZW5ndGggLSB1c2VkKVxuICAgICAgdG1wLmNvcHkoaXYsIGl2U3RhcnQsIHVzZWQsIHVzZWQgKyBsZW5ndGgpXG4gICAgICBpdkxlbiAtPSBsZW5ndGhcbiAgICB9XG4gIH1cblxuICB0bXAuZmlsbCgwKVxuICByZXR1cm4geyBrZXk6IGtleSwgaXY6IGl2IH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFVlBfQnl0ZXNUb0tleVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm1cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuZnVuY3Rpb24gdGhyb3dJZk5vdFN0cmluZ09yQnVmZmVyICh2YWwsIHByZWZpeCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWwpICYmIHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihwcmVmaXggKyAnIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBidWZmZXInKVxuICB9XG59XG5cbmZ1bmN0aW9uIEhhc2hCYXNlIChibG9ja1NpemUpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcylcblxuICB0aGlzLl9ibG9jayA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShibG9ja1NpemUpXG4gIHRoaXMuX2Jsb2NrU2l6ZSA9IGJsb2NrU2l6ZVxuICB0aGlzLl9ibG9ja09mZnNldCA9IDBcbiAgdGhpcy5fbGVuZ3RoID0gWzAsIDAsIDAsIDBdXG5cbiAgdGhpcy5fZmluYWxpemVkID0gZmFsc2Vcbn1cblxuaW5oZXJpdHMoSGFzaEJhc2UsIFRyYW5zZm9ybSlcblxuSGFzaEJhc2UucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICB2YXIgZXJyb3IgPSBudWxsXG4gIHRyeSB7XG4gICAgdGhpcy51cGRhdGUoY2h1bmssIGVuY29kaW5nKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvciA9IGVyclxuICB9XG5cbiAgY2FsbGJhY2soZXJyb3IpXG59XG5cbkhhc2hCYXNlLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdmFyIGVycm9yID0gbnVsbFxuICB0cnkge1xuICAgIHRoaXMucHVzaCh0aGlzLmRpZ2VzdCgpKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvciA9IGVyclxuICB9XG5cbiAgY2FsbGJhY2soZXJyb3IpXG59XG5cbkhhc2hCYXNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jb2RpbmcpIHtcbiAgdGhyb3dJZk5vdFN0cmluZ09yQnVmZmVyKGRhdGEsICdEYXRhJylcbiAgaWYgKHRoaXMuX2ZpbmFsaXplZCkgdGhyb3cgbmV3IEVycm9yKCdEaWdlc3QgYWxyZWFkeSBjYWxsZWQnKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nKVxuXG4gIC8vIGNvbnN1bWUgZGF0YVxuICB2YXIgYmxvY2sgPSB0aGlzLl9ibG9ja1xuICB2YXIgb2Zmc2V0ID0gMFxuICB3aGlsZSAodGhpcy5fYmxvY2tPZmZzZXQgKyBkYXRhLmxlbmd0aCAtIG9mZnNldCA+PSB0aGlzLl9ibG9ja1NpemUpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5fYmxvY2tPZmZzZXQ7IGkgPCB0aGlzLl9ibG9ja1NpemU7KSBibG9ja1tpKytdID0gZGF0YVtvZmZzZXQrK11cbiAgICB0aGlzLl91cGRhdGUoKVxuICAgIHRoaXMuX2Jsb2NrT2Zmc2V0ID0gMFxuICB9XG4gIHdoaWxlIChvZmZzZXQgPCBkYXRhLmxlbmd0aCkgYmxvY2tbdGhpcy5fYmxvY2tPZmZzZXQrK10gPSBkYXRhW29mZnNldCsrXVxuXG4gIC8vIHVwZGF0ZSBsZW5ndGhcbiAgZm9yICh2YXIgaiA9IDAsIGNhcnJ5ID0gZGF0YS5sZW5ndGggKiA4OyBjYXJyeSA+IDA7ICsraikge1xuICAgIHRoaXMuX2xlbmd0aFtqXSArPSBjYXJyeVxuICAgIGNhcnJ5ID0gKHRoaXMuX2xlbmd0aFtqXSAvIDB4MDEwMDAwMDAwMCkgfCAwXG4gICAgaWYgKGNhcnJ5ID4gMCkgdGhpcy5fbGVuZ3RoW2pdIC09IDB4MDEwMDAwMDAwMCAqIGNhcnJ5XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG5IYXNoQmFzZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdXBkYXRlIGlzIG5vdCBpbXBsZW1lbnRlZCcpXG59XG5cbkhhc2hCYXNlLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgaWYgKHRoaXMuX2ZpbmFsaXplZCkgdGhyb3cgbmV3IEVycm9yKCdEaWdlc3QgYWxyZWFkeSBjYWxsZWQnKVxuICB0aGlzLl9maW5hbGl6ZWQgPSB0cnVlXG5cbiAgdmFyIGRpZ2VzdCA9IHRoaXMuX2RpZ2VzdCgpXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSBkaWdlc3QgPSBkaWdlc3QudG9TdHJpbmcoZW5jb2RpbmcpXG5cbiAgLy8gcmVzZXQgc3RhdGVcbiAgdGhpcy5fYmxvY2suZmlsbCgwKVxuICB0aGlzLl9ibG9ja09mZnNldCA9IDBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHRoaXMuX2xlbmd0aFtpXSA9IDBcblxuICByZXR1cm4gZGlnZXN0XG59XG5cbkhhc2hCYXNlLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ19kaWdlc3QgaXMgbm90IGltcGxlbWVudGVkJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoQmFzZVxuIiwidmFyIGhhc2ggPSBleHBvcnRzO1xuXG5oYXNoLnV0aWxzID0gcmVxdWlyZSgnLi9oYXNoL3V0aWxzJyk7XG5oYXNoLmNvbW1vbiA9IHJlcXVpcmUoJy4vaGFzaC9jb21tb24nKTtcbmhhc2guc2hhID0gcmVxdWlyZSgnLi9oYXNoL3NoYScpO1xuaGFzaC5yaXBlbWQgPSByZXF1aXJlKCcuL2hhc2gvcmlwZW1kJyk7XG5oYXNoLmhtYWMgPSByZXF1aXJlKCcuL2hhc2gvaG1hYycpO1xuXG4vLyBQcm94eSBoYXNoIGZ1bmN0aW9ucyB0byB0aGUgbWFpbiBvYmplY3Rcbmhhc2guc2hhMSA9IGhhc2guc2hhLnNoYTE7XG5oYXNoLnNoYTI1NiA9IGhhc2guc2hhLnNoYTI1Njtcbmhhc2guc2hhMjI0ID0gaGFzaC5zaGEuc2hhMjI0O1xuaGFzaC5zaGEzODQgPSBoYXNoLnNoYS5zaGEzODQ7XG5oYXNoLnNoYTUxMiA9IGhhc2guc2hhLnNoYTUxMjtcbmhhc2gucmlwZW1kMTYwID0gaGFzaC5yaXBlbWQucmlwZW1kMTYwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG5mdW5jdGlvbiBCbG9ja0hhc2goKSB7XG4gIHRoaXMucGVuZGluZyA9IG51bGw7XG4gIHRoaXMucGVuZGluZ1RvdGFsID0gMDtcbiAgdGhpcy5ibG9ja1NpemUgPSB0aGlzLmNvbnN0cnVjdG9yLmJsb2NrU2l6ZTtcbiAgdGhpcy5vdXRTaXplID0gdGhpcy5jb25zdHJ1Y3Rvci5vdXRTaXplO1xuICB0aGlzLmhtYWNTdHJlbmd0aCA9IHRoaXMuY29uc3RydWN0b3IuaG1hY1N0cmVuZ3RoO1xuICB0aGlzLnBhZExlbmd0aCA9IHRoaXMuY29uc3RydWN0b3IucGFkTGVuZ3RoIC8gODtcbiAgdGhpcy5lbmRpYW4gPSAnYmlnJztcblxuICB0aGlzLl9kZWx0YTggPSB0aGlzLmJsb2NrU2l6ZSAvIDg7XG4gIHRoaXMuX2RlbHRhMzIgPSB0aGlzLmJsb2NrU2l6ZSAvIDMyO1xufVxuZXhwb3J0cy5CbG9ja0hhc2ggPSBCbG9ja0hhc2g7XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKG1zZywgZW5jKSB7XG4gIC8vIENvbnZlcnQgbWVzc2FnZSB0byBhcnJheSwgcGFkIGl0LCBhbmQgam9pbiBpbnRvIDMyYml0IGJsb2Nrc1xuICBtc2cgPSB1dGlscy50b0FycmF5KG1zZywgZW5jKTtcbiAgaWYgKCF0aGlzLnBlbmRpbmcpXG4gICAgdGhpcy5wZW5kaW5nID0gbXNnO1xuICBlbHNlXG4gICAgdGhpcy5wZW5kaW5nID0gdGhpcy5wZW5kaW5nLmNvbmNhdChtc2cpO1xuICB0aGlzLnBlbmRpbmdUb3RhbCArPSBtc2cubGVuZ3RoO1xuXG4gIC8vIEVub3VnaCBkYXRhLCB0cnkgdXBkYXRpbmdcbiAgaWYgKHRoaXMucGVuZGluZy5sZW5ndGggPj0gdGhpcy5fZGVsdGE4KSB7XG4gICAgbXNnID0gdGhpcy5wZW5kaW5nO1xuXG4gICAgLy8gUHJvY2VzcyBwZW5kaW5nIGRhdGEgaW4gYmxvY2tzXG4gICAgdmFyIHIgPSBtc2cubGVuZ3RoICUgdGhpcy5fZGVsdGE4O1xuICAgIHRoaXMucGVuZGluZyA9IG1zZy5zbGljZShtc2cubGVuZ3RoIC0gciwgbXNnLmxlbmd0aCk7XG4gICAgaWYgKHRoaXMucGVuZGluZy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuXG4gICAgbXNnID0gdXRpbHMuam9pbjMyKG1zZywgMCwgbXNnLmxlbmd0aCAtIHIsIHRoaXMuZW5kaWFuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gdGhpcy5fZGVsdGEzMilcbiAgICAgIHRoaXMuX3VwZGF0ZShtc2csIGksIGkgKyB0aGlzLl9kZWx0YTMyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuQmxvY2tIYXNoLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIHRoaXMudXBkYXRlKHRoaXMuX3BhZCgpKTtcbiAgYXNzZXJ0KHRoaXMucGVuZGluZyA9PT0gbnVsbCk7XG5cbiAgcmV0dXJuIHRoaXMuX2RpZ2VzdChlbmMpO1xufTtcblxuQmxvY2tIYXNoLnByb3RvdHlwZS5fcGFkID0gZnVuY3Rpb24gcGFkKCkge1xuICB2YXIgbGVuID0gdGhpcy5wZW5kaW5nVG90YWw7XG4gIHZhciBieXRlcyA9IHRoaXMuX2RlbHRhODtcbiAgdmFyIGsgPSBieXRlcyAtICgobGVuICsgdGhpcy5wYWRMZW5ndGgpICUgYnl0ZXMpO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGsgKyB0aGlzLnBhZExlbmd0aCk7XG4gIHJlc1swXSA9IDB4ODA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgazsgaSsrKVxuICAgIHJlc1tpXSA9IDA7XG5cbiAgLy8gQXBwZW5kIGxlbmd0aFxuICBsZW4gPDw9IDM7XG4gIGlmICh0aGlzLmVuZGlhbiA9PT0gJ2JpZycpIHtcbiAgICBmb3IgKHZhciB0ID0gODsgdCA8IHRoaXMucGFkTGVuZ3RoOyB0KyspXG4gICAgICByZXNbaSsrXSA9IDA7XG5cbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAyNCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMTYpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDgpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IGxlbiAmIDB4ZmY7XG4gIH0gZWxzZSB7XG4gICAgcmVzW2krK10gPSBsZW4gJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gOCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMTYpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDI0KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuXG4gICAgZm9yICh0ID0gODsgdCA8IHRoaXMucGFkTGVuZ3RoOyB0KyspXG4gICAgICByZXNbaSsrXSA9IDA7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxuZnVuY3Rpb24gSG1hYyhoYXNoLCBrZXksIGVuYykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSG1hYykpXG4gICAgcmV0dXJuIG5ldyBIbWFjKGhhc2gsIGtleSwgZW5jKTtcbiAgdGhpcy5IYXNoID0gaGFzaDtcbiAgdGhpcy5ibG9ja1NpemUgPSBoYXNoLmJsb2NrU2l6ZSAvIDg7XG4gIHRoaXMub3V0U2l6ZSA9IGhhc2gub3V0U2l6ZSAvIDg7XG4gIHRoaXMuaW5uZXIgPSBudWxsO1xuICB0aGlzLm91dGVyID0gbnVsbDtcblxuICB0aGlzLl9pbml0KHV0aWxzLnRvQXJyYXkoa2V5LCBlbmMpKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gSG1hYztcblxuSG1hYy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGtleSkge1xuICAvLyBTaG9ydGVuIGtleSwgaWYgbmVlZGVkXG4gIGlmIChrZXkubGVuZ3RoID4gdGhpcy5ibG9ja1NpemUpXG4gICAga2V5ID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpO1xuICBhc3NlcnQoa2V5Lmxlbmd0aCA8PSB0aGlzLmJsb2NrU2l6ZSk7XG5cbiAgLy8gQWRkIHBhZGRpbmcgdG8ga2V5XG4gIGZvciAodmFyIGkgPSBrZXkubGVuZ3RoOyBpIDwgdGhpcy5ibG9ja1NpemU7IGkrKylcbiAgICBrZXkucHVzaCgwKTtcblxuICBmb3IgKGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKVxuICAgIGtleVtpXSBePSAweDM2O1xuICB0aGlzLmlubmVyID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpO1xuXG4gIC8vIDB4MzYgXiAweDVjID0gMHg2YVxuICBmb3IgKGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKVxuICAgIGtleVtpXSBePSAweDZhO1xuICB0aGlzLm91dGVyID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpO1xufTtcblxuSG1hYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKG1zZywgZW5jKSB7XG4gIHRoaXMuaW5uZXIudXBkYXRlKG1zZywgZW5jKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5IbWFjLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIHRoaXMub3V0ZXIudXBkYXRlKHRoaXMuaW5uZXIuZGlnZXN0KCkpO1xuICByZXR1cm4gdGhpcy5vdXRlci5kaWdlc3QoZW5jKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG52YXIgcm90bDMyID0gdXRpbHMucm90bDMyO1xudmFyIHN1bTMyID0gdXRpbHMuc3VtMzI7XG52YXIgc3VtMzJfMyA9IHV0aWxzLnN1bTMyXzM7XG52YXIgc3VtMzJfNCA9IHV0aWxzLnN1bTMyXzQ7XG52YXIgQmxvY2tIYXNoID0gY29tbW9uLkJsb2NrSGFzaDtcblxuZnVuY3Rpb24gUklQRU1EMTYwKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUklQRU1EMTYwKSlcbiAgICByZXR1cm4gbmV3IFJJUEVNRDE2MCgpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuaCA9IFsgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMCBdO1xuICB0aGlzLmVuZGlhbiA9ICdsaXR0bGUnO1xufVxudXRpbHMuaW5oZXJpdHMoUklQRU1EMTYwLCBCbG9ja0hhc2gpO1xuZXhwb3J0cy5yaXBlbWQxNjAgPSBSSVBFTUQxNjA7XG5cblJJUEVNRDE2MC5ibG9ja1NpemUgPSA1MTI7XG5SSVBFTUQxNjAub3V0U2l6ZSA9IDE2MDtcblJJUEVNRDE2MC5obWFjU3RyZW5ndGggPSAxOTI7XG5SSVBFTUQxNjAucGFkTGVuZ3RoID0gNjQ7XG5cblJJUEVNRDE2MC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHZhciBBID0gdGhpcy5oWzBdO1xuICB2YXIgQiA9IHRoaXMuaFsxXTtcbiAgdmFyIEMgPSB0aGlzLmhbMl07XG4gIHZhciBEID0gdGhpcy5oWzNdO1xuICB2YXIgRSA9IHRoaXMuaFs0XTtcbiAgdmFyIEFoID0gQTtcbiAgdmFyIEJoID0gQjtcbiAgdmFyIENoID0gQztcbiAgdmFyIERoID0gRDtcbiAgdmFyIEVoID0gRTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgaisrKSB7XG4gICAgdmFyIFQgPSBzdW0zMihcbiAgICAgIHJvdGwzMihcbiAgICAgICAgc3VtMzJfNChBLCBmKGosIEIsIEMsIEQpLCBtc2dbcltqXSArIHN0YXJ0XSwgSyhqKSksXG4gICAgICAgIHNbal0pLFxuICAgICAgRSk7XG4gICAgQSA9IEU7XG4gICAgRSA9IEQ7XG4gICAgRCA9IHJvdGwzMihDLCAxMCk7XG4gICAgQyA9IEI7XG4gICAgQiA9IFQ7XG4gICAgVCA9IHN1bTMyKFxuICAgICAgcm90bDMyKFxuICAgICAgICBzdW0zMl80KEFoLCBmKDc5IC0gaiwgQmgsIENoLCBEaCksIG1zZ1tyaFtqXSArIHN0YXJ0XSwgS2goaikpLFxuICAgICAgICBzaFtqXSksXG4gICAgICBFaCk7XG4gICAgQWggPSBFaDtcbiAgICBFaCA9IERoO1xuICAgIERoID0gcm90bDMyKENoLCAxMCk7XG4gICAgQ2ggPSBCaDtcbiAgICBCaCA9IFQ7XG4gIH1cbiAgVCA9IHN1bTMyXzModGhpcy5oWzFdLCBDLCBEaCk7XG4gIHRoaXMuaFsxXSA9IHN1bTMyXzModGhpcy5oWzJdLCBELCBFaCk7XG4gIHRoaXMuaFsyXSA9IHN1bTMyXzModGhpcy5oWzNdLCBFLCBBaCk7XG4gIHRoaXMuaFszXSA9IHN1bTMyXzModGhpcy5oWzRdLCBBLCBCaCk7XG4gIHRoaXMuaFs0XSA9IHN1bTMyXzModGhpcy5oWzBdLCBCLCBDaCk7XG4gIHRoaXMuaFswXSA9IFQ7XG59O1xuXG5SSVBFTUQxNjAucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2xpdHRsZScpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnbGl0dGxlJyk7XG59O1xuXG5mdW5jdGlvbiBmKGosIHgsIHksIHopIHtcbiAgaWYgKGogPD0gMTUpXG4gICAgcmV0dXJuIHggXiB5IF4gejtcbiAgZWxzZSBpZiAoaiA8PSAzMSlcbiAgICByZXR1cm4gKHggJiB5KSB8ICgofngpICYgeik7XG4gIGVsc2UgaWYgKGogPD0gNDcpXG4gICAgcmV0dXJuICh4IHwgKH55KSkgXiB6O1xuICBlbHNlIGlmIChqIDw9IDYzKVxuICAgIHJldHVybiAoeCAmIHopIHwgKHkgJiAofnopKTtcbiAgZWxzZVxuICAgIHJldHVybiB4IF4gKHkgfCAofnopKTtcbn1cblxuZnVuY3Rpb24gSyhqKSB7XG4gIGlmIChqIDw9IDE1KVxuICAgIHJldHVybiAweDAwMDAwMDAwO1xuICBlbHNlIGlmIChqIDw9IDMxKVxuICAgIHJldHVybiAweDVhODI3OTk5O1xuICBlbHNlIGlmIChqIDw9IDQ3KVxuICAgIHJldHVybiAweDZlZDllYmExO1xuICBlbHNlIGlmIChqIDw9IDYzKVxuICAgIHJldHVybiAweDhmMWJiY2RjO1xuICBlbHNlXG4gICAgcmV0dXJuIDB4YTk1M2ZkNGU7XG59XG5cbmZ1bmN0aW9uIEtoKGopIHtcbiAgaWYgKGogPD0gMTUpXG4gICAgcmV0dXJuIDB4NTBhMjhiZTY7XG4gIGVsc2UgaWYgKGogPD0gMzEpXG4gICAgcmV0dXJuIDB4NWM0ZGQxMjQ7XG4gIGVsc2UgaWYgKGogPD0gNDcpXG4gICAgcmV0dXJuIDB4NmQ3MDNlZjM7XG4gIGVsc2UgaWYgKGogPD0gNjMpXG4gICAgcmV0dXJuIDB4N2E2ZDc2ZTk7XG4gIGVsc2VcbiAgICByZXR1cm4gMHgwMDAwMDAwMDtcbn1cblxudmFyIHIgPSBbXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gIDcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDgsXG4gIDMsIDEwLCAxNCwgNCwgOSwgMTUsIDgsIDEsIDIsIDcsIDAsIDYsIDEzLCAxMSwgNSwgMTIsXG4gIDEsIDksIDExLCAxMCwgMCwgOCwgMTIsIDQsIDEzLCAzLCA3LCAxNSwgMTQsIDUsIDYsIDIsXG4gIDQsIDAsIDUsIDksIDcsIDEyLCAyLCAxMCwgMTQsIDEsIDMsIDgsIDExLCA2LCAxNSwgMTNcbl07XG5cbnZhciByaCA9IFtcbiAgNSwgMTQsIDcsIDAsIDksIDIsIDExLCA0LCAxMywgNiwgMTUsIDgsIDEsIDEwLCAzLCAxMixcbiAgNiwgMTEsIDMsIDcsIDAsIDEzLCA1LCAxMCwgMTQsIDE1LCA4LCAxMiwgNCwgOSwgMSwgMixcbiAgMTUsIDUsIDEsIDMsIDcsIDE0LCA2LCA5LCAxMSwgOCwgMTIsIDIsIDEwLCAwLCA0LCAxMyxcbiAgOCwgNiwgNCwgMSwgMywgMTEsIDE1LCAwLCA1LCAxMiwgMiwgMTMsIDksIDcsIDEwLCAxNCxcbiAgMTIsIDE1LCAxMCwgNCwgMSwgNSwgOCwgNywgNiwgMiwgMTMsIDE0LCAwLCAzLCA5LCAxMVxuXTtcblxudmFyIHMgPSBbXG4gIDExLCAxNCwgMTUsIDEyLCA1LCA4LCA3LCA5LCAxMSwgMTMsIDE0LCAxNSwgNiwgNywgOSwgOCxcbiAgNywgNiwgOCwgMTMsIDExLCA5LCA3LCAxNSwgNywgMTIsIDE1LCA5LCAxMSwgNywgMTMsIDEyLFxuICAxMSwgMTMsIDYsIDcsIDE0LCA5LCAxMywgMTUsIDE0LCA4LCAxMywgNiwgNSwgMTIsIDcsIDUsXG4gIDExLCAxMiwgMTQsIDE1LCAxNCwgMTUsIDksIDgsIDksIDE0LCA1LCA2LCA4LCA2LCA1LCAxMixcbiAgOSwgMTUsIDUsIDExLCA2LCA4LCAxMywgMTIsIDUsIDEyLCAxMywgMTQsIDExLCA4LCA1LCA2XG5dO1xuXG52YXIgc2ggPSBbXG4gIDgsIDksIDksIDExLCAxMywgMTUsIDE1LCA1LCA3LCA3LCA4LCAxMSwgMTQsIDE0LCAxMiwgNixcbiAgOSwgMTMsIDE1LCA3LCAxMiwgOCwgOSwgMTEsIDcsIDcsIDEyLCA3LCA2LCAxNSwgMTMsIDExLFxuICA5LCA3LCAxNSwgMTEsIDgsIDYsIDYsIDE0LCAxMiwgMTMsIDUsIDE0LCAxMywgMTMsIDcsIDUsXG4gIDE1LCA1LCA4LCAxMSwgMTQsIDE0LCA2LCAxNCwgNiwgOSwgMTIsIDksIDEyLCA1LCAxNSwgOCxcbiAgOCwgNSwgMTIsIDksIDEyLCA1LCAxNCwgNiwgOCwgMTMsIDYsIDUsIDE1LCAxMywgMTEsIDExXG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLnNoYTEgPSByZXF1aXJlKCcuL3NoYS8xJyk7XG5leHBvcnRzLnNoYTIyNCA9IHJlcXVpcmUoJy4vc2hhLzIyNCcpO1xuZXhwb3J0cy5zaGEyNTYgPSByZXF1aXJlKCcuL3NoYS8yNTYnKTtcbmV4cG9ydHMuc2hhMzg0ID0gcmVxdWlyZSgnLi9zaGEvMzg0Jyk7XG5leHBvcnRzLnNoYTUxMiA9IHJlcXVpcmUoJy4vc2hhLzUxMicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIHNoYUNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cbnZhciByb3RsMzIgPSB1dGlscy5yb3RsMzI7XG52YXIgc3VtMzIgPSB1dGlscy5zdW0zMjtcbnZhciBzdW0zMl81ID0gdXRpbHMuc3VtMzJfNTtcbnZhciBmdF8xID0gc2hhQ29tbW9uLmZ0XzE7XG52YXIgQmxvY2tIYXNoID0gY29tbW9uLkJsb2NrSGFzaDtcblxudmFyIHNoYTFfSyA9IFtcbiAgMHg1QTgyNzk5OSwgMHg2RUQ5RUJBMSxcbiAgMHg4RjFCQkNEQywgMHhDQTYyQzFENlxuXTtcblxuZnVuY3Rpb24gU0hBMSgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTEpKVxuICAgIHJldHVybiBuZXcgU0hBMSgpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSxcbiAgICAweDEwMzI1NDc2LCAweGMzZDJlMWYwIF07XG4gIHRoaXMuVyA9IG5ldyBBcnJheSg4MCk7XG59XG5cbnV0aWxzLmluaGVyaXRzKFNIQTEsIEJsb2NrSGFzaCk7XG5tb2R1bGUuZXhwb3J0cyA9IFNIQTE7XG5cblNIQTEuYmxvY2tTaXplID0gNTEyO1xuU0hBMS5vdXRTaXplID0gMTYwO1xuU0hBMS5obWFjU3RyZW5ndGggPSA4MDtcblNIQTEucGFkTGVuZ3RoID0gNjQ7XG5cblNIQTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcblxuICBmb3IoOyBpIDwgVy5sZW5ndGg7IGkrKylcbiAgICBXW2ldID0gcm90bDMyKFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl0sIDEpO1xuXG4gIHZhciBhID0gdGhpcy5oWzBdO1xuICB2YXIgYiA9IHRoaXMuaFsxXTtcbiAgdmFyIGMgPSB0aGlzLmhbMl07XG4gIHZhciBkID0gdGhpcy5oWzNdO1xuICB2YXIgZSA9IHRoaXMuaFs0XTtcblxuICBmb3IgKGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzID0gfn4oaSAvIDIwKTtcbiAgICB2YXIgdCA9IHN1bTMyXzUocm90bDMyKGEsIDUpLCBmdF8xKHMsIGIsIGMsIGQpLCBlLCBXW2ldLCBzaGExX0tbc10pO1xuICAgIGUgPSBkO1xuICAgIGQgPSBjO1xuICAgIGMgPSByb3RsMzIoYiwgMzApO1xuICAgIGIgPSBhO1xuICAgIGEgPSB0O1xuICB9XG5cbiAgdGhpcy5oWzBdID0gc3VtMzIodGhpcy5oWzBdLCBhKTtcbiAgdGhpcy5oWzFdID0gc3VtMzIodGhpcy5oWzFdLCBiKTtcbiAgdGhpcy5oWzJdID0gc3VtMzIodGhpcy5oWzJdLCBjKTtcbiAgdGhpcy5oWzNdID0gc3VtMzIodGhpcy5oWzNdLCBkKTtcbiAgdGhpcy5oWzRdID0gc3VtMzIodGhpcy5oWzRdLCBlKTtcbn07XG5cblNIQTEucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIFNIQTI1NiA9IHJlcXVpcmUoJy4vMjU2Jyk7XG5cbmZ1bmN0aW9uIFNIQTIyNCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTIyNCkpXG4gICAgcmV0dXJuIG5ldyBTSEEyMjQoKTtcblxuICBTSEEyNTYuY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gW1xuICAgIDB4YzEwNTllZDgsIDB4MzY3Y2Q1MDcsIDB4MzA3MGRkMTcsIDB4ZjcwZTU5MzksXG4gICAgMHhmZmMwMGIzMSwgMHg2ODU4MTUxMSwgMHg2NGY5OGZhNywgMHhiZWZhNGZhNCBdO1xufVxudXRpbHMuaW5oZXJpdHMoU0hBMjI0LCBTSEEyNTYpO1xubW9kdWxlLmV4cG9ydHMgPSBTSEEyMjQ7XG5cblNIQTIyNC5ibG9ja1NpemUgPSA1MTI7XG5TSEEyMjQub3V0U2l6ZSA9IDIyNDtcblNIQTIyNC5obWFjU3RyZW5ndGggPSAxOTI7XG5TSEEyMjQucGFkTGVuZ3RoID0gNjQ7XG5cblNIQTIyNC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgLy8gSnVzdCB0cnVuY2F0ZSBvdXRwdXRcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLnNsaWNlKDAsIDcpLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmguc2xpY2UoMCwgNyksICdiaWcnKTtcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBzaGFDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxudmFyIHN1bTMyID0gdXRpbHMuc3VtMzI7XG52YXIgc3VtMzJfNCA9IHV0aWxzLnN1bTMyXzQ7XG52YXIgc3VtMzJfNSA9IHV0aWxzLnN1bTMyXzU7XG52YXIgY2gzMiA9IHNoYUNvbW1vbi5jaDMyO1xudmFyIG1hajMyID0gc2hhQ29tbW9uLm1hajMyO1xudmFyIHMwXzI1NiA9IHNoYUNvbW1vbi5zMF8yNTY7XG52YXIgczFfMjU2ID0gc2hhQ29tbW9uLnMxXzI1NjtcbnZhciBnMF8yNTYgPSBzaGFDb21tb24uZzBfMjU2O1xudmFyIGcxXzI1NiA9IHNoYUNvbW1vbi5nMV8yNTY7XG5cbnZhciBCbG9ja0hhc2ggPSBjb21tb24uQmxvY2tIYXNoO1xuXG52YXIgc2hhMjU2X0sgPSBbXG4gIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsXG4gIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsXG4gIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsXG4gIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsXG4gIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsXG4gIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsXG4gIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsXG4gIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsXG4gIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl07XG5cbmZ1bmN0aW9uIFNIQTI1NigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTI1NikpXG4gICAgcmV0dXJuIG5ldyBTSEEyNTYoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsXG4gICAgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuICBdO1xuICB0aGlzLmsgPSBzaGEyNTZfSztcbiAgdGhpcy5XID0gbmV3IEFycmF5KDY0KTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTI1NiwgQmxvY2tIYXNoKTtcbm1vZHVsZS5leHBvcnRzID0gU0hBMjU2O1xuXG5TSEEyNTYuYmxvY2tTaXplID0gNTEyO1xuU0hBMjU2Lm91dFNpemUgPSAyNTY7XG5TSEEyNTYuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBMjU2LnBhZExlbmd0aCA9IDY0O1xuXG5TSEEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcbiAgZm9yICg7IGkgPCBXLmxlbmd0aDsgaSsrKVxuICAgIFdbaV0gPSBzdW0zMl80KGcxXzI1NihXW2kgLSAyXSksIFdbaSAtIDddLCBnMF8yNTYoV1tpIC0gMTVdKSwgV1tpIC0gMTZdKTtcblxuICB2YXIgYSA9IHRoaXMuaFswXTtcbiAgdmFyIGIgPSB0aGlzLmhbMV07XG4gIHZhciBjID0gdGhpcy5oWzJdO1xuICB2YXIgZCA9IHRoaXMuaFszXTtcbiAgdmFyIGUgPSB0aGlzLmhbNF07XG4gIHZhciBmID0gdGhpcy5oWzVdO1xuICB2YXIgZyA9IHRoaXMuaFs2XTtcbiAgdmFyIGggPSB0aGlzLmhbN107XG5cbiAgYXNzZXJ0KHRoaXMuay5sZW5ndGggPT09IFcubGVuZ3RoKTtcbiAgZm9yIChpID0gMDsgaSA8IFcubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgVDEgPSBzdW0zMl81KGgsIHMxXzI1NihlKSwgY2gzMihlLCBmLCBnKSwgdGhpcy5rW2ldLCBXW2ldKTtcbiAgICB2YXIgVDIgPSBzdW0zMihzMF8yNTYoYSksIG1hajMyKGEsIGIsIGMpKTtcbiAgICBoID0gZztcbiAgICBnID0gZjtcbiAgICBmID0gZTtcbiAgICBlID0gc3VtMzIoZCwgVDEpO1xuICAgIGQgPSBjO1xuICAgIGMgPSBiO1xuICAgIGIgPSBhO1xuICAgIGEgPSBzdW0zMihUMSwgVDIpO1xuICB9XG5cbiAgdGhpcy5oWzBdID0gc3VtMzIodGhpcy5oWzBdLCBhKTtcbiAgdGhpcy5oWzFdID0gc3VtMzIodGhpcy5oWzFdLCBiKTtcbiAgdGhpcy5oWzJdID0gc3VtMzIodGhpcy5oWzJdLCBjKTtcbiAgdGhpcy5oWzNdID0gc3VtMzIodGhpcy5oWzNdLCBkKTtcbiAgdGhpcy5oWzRdID0gc3VtMzIodGhpcy5oWzRdLCBlKTtcbiAgdGhpcy5oWzVdID0gc3VtMzIodGhpcy5oWzVdLCBmKTtcbiAgdGhpcy5oWzZdID0gc3VtMzIodGhpcy5oWzZdLCBnKTtcbiAgdGhpcy5oWzddID0gc3VtMzIodGhpcy5oWzddLCBoKTtcbn07XG5cblNIQTI1Ni5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdiaWcnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnZhciBTSEE1MTIgPSByZXF1aXJlKCcuLzUxMicpO1xuXG5mdW5jdGlvbiBTSEEzODQoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEEzODQpKVxuICAgIHJldHVybiBuZXcgU0hBMzg0KCk7XG5cbiAgU0hBNTEyLmNhbGwodGhpcyk7XG4gIHRoaXMuaCA9IFtcbiAgICAweGNiYmI5ZDVkLCAweGMxMDU5ZWQ4LFxuICAgIDB4NjI5YTI5MmEsIDB4MzY3Y2Q1MDcsXG4gICAgMHg5MTU5MDE1YSwgMHgzMDcwZGQxNyxcbiAgICAweDE1MmZlY2Q4LCAweGY3MGU1OTM5LFxuICAgIDB4NjczMzI2NjcsIDB4ZmZjMDBiMzEsXG4gICAgMHg4ZWI0NGE4NywgMHg2ODU4MTUxMSxcbiAgICAweGRiMGMyZTBkLCAweDY0Zjk4ZmE3LFxuICAgIDB4NDdiNTQ4MWQsIDB4YmVmYTRmYTQgXTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTM4NCwgU0hBNTEyKTtcbm1vZHVsZS5leHBvcnRzID0gU0hBMzg0O1xuXG5TSEEzODQuYmxvY2tTaXplID0gMTAyNDtcblNIQTM4NC5vdXRTaXplID0gMzg0O1xuU0hBMzg0LmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTM4NC5wYWRMZW5ndGggPSAxMjg7XG5cblNIQTM4NC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLnNsaWNlKDAsIDEyKSwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLnNsaWNlKDAsIDEyKSwgJ2JpZycpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG5cbnZhciByb3RyNjRfaGkgPSB1dGlscy5yb3RyNjRfaGk7XG52YXIgcm90cjY0X2xvID0gdXRpbHMucm90cjY0X2xvO1xudmFyIHNocjY0X2hpID0gdXRpbHMuc2hyNjRfaGk7XG52YXIgc2hyNjRfbG8gPSB1dGlscy5zaHI2NF9sbztcbnZhciBzdW02NCA9IHV0aWxzLnN1bTY0O1xudmFyIHN1bTY0X2hpID0gdXRpbHMuc3VtNjRfaGk7XG52YXIgc3VtNjRfbG8gPSB1dGlscy5zdW02NF9sbztcbnZhciBzdW02NF80X2hpID0gdXRpbHMuc3VtNjRfNF9oaTtcbnZhciBzdW02NF80X2xvID0gdXRpbHMuc3VtNjRfNF9sbztcbnZhciBzdW02NF81X2hpID0gdXRpbHMuc3VtNjRfNV9oaTtcbnZhciBzdW02NF81X2xvID0gdXRpbHMuc3VtNjRfNV9sbztcblxudmFyIEJsb2NrSGFzaCA9IGNvbW1vbi5CbG9ja0hhc2g7XG5cbnZhciBzaGE1MTJfSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXTtcblxuZnVuY3Rpb24gU0hBNTEyKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBNTEyKSlcbiAgICByZXR1cm4gbmV3IFNIQTUxMigpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHg2YTA5ZTY2NywgMHhmM2JjYzkwOCxcbiAgICAweGJiNjdhZTg1LCAweDg0Y2FhNzNiLFxuICAgIDB4M2M2ZWYzNzIsIDB4ZmU5NGY4MmIsXG4gICAgMHhhNTRmZjUzYSwgMHg1ZjFkMzZmMSxcbiAgICAweDUxMGU1MjdmLCAweGFkZTY4MmQxLFxuICAgIDB4OWIwNTY4OGMsIDB4MmIzZTZjMWYsXG4gICAgMHgxZjgzZDlhYiwgMHhmYjQxYmQ2YixcbiAgICAweDViZTBjZDE5LCAweDEzN2UyMTc5IF07XG4gIHRoaXMuayA9IHNoYTUxMl9LO1xuICB0aGlzLlcgPSBuZXcgQXJyYXkoMTYwKTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTUxMiwgQmxvY2tIYXNoKTtcbm1vZHVsZS5leHBvcnRzID0gU0hBNTEyO1xuXG5TSEE1MTIuYmxvY2tTaXplID0gMTAyNDtcblNIQTUxMi5vdXRTaXplID0gNTEyO1xuU0hBNTEyLmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTUxMi5wYWRMZW5ndGggPSAxMjg7XG5cblNIQTUxMi5wcm90b3R5cGUuX3ByZXBhcmVCbG9jayA9IGZ1bmN0aW9uIF9wcmVwYXJlQmxvY2sobXNnLCBzdGFydCkge1xuICB2YXIgVyA9IHRoaXMuVztcblxuICAvLyAzMiB4IDMyYml0IHdvcmRzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKylcbiAgICBXW2ldID0gbXNnW3N0YXJ0ICsgaV07XG4gIGZvciAoOyBpIDwgVy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBjMF9oaSA9IGcxXzUxMl9oaShXW2kgLSA0XSwgV1tpIC0gM10pOyAgLy8gaSAtIDJcbiAgICB2YXIgYzBfbG8gPSBnMV81MTJfbG8oV1tpIC0gNF0sIFdbaSAtIDNdKTtcbiAgICB2YXIgYzFfaGkgPSBXW2kgLSAxNF07ICAvLyBpIC0gN1xuICAgIHZhciBjMV9sbyA9IFdbaSAtIDEzXTtcbiAgICB2YXIgYzJfaGkgPSBnMF81MTJfaGkoV1tpIC0gMzBdLCBXW2kgLSAyOV0pOyAgLy8gaSAtIDE1XG4gICAgdmFyIGMyX2xvID0gZzBfNTEyX2xvKFdbaSAtIDMwXSwgV1tpIC0gMjldKTtcbiAgICB2YXIgYzNfaGkgPSBXW2kgLSAzMl07ICAvLyBpIC0gMTZcbiAgICB2YXIgYzNfbG8gPSBXW2kgLSAzMV07XG5cbiAgICBXW2ldID0gc3VtNjRfNF9oaShcbiAgICAgIGMwX2hpLCBjMF9sbyxcbiAgICAgIGMxX2hpLCBjMV9sbyxcbiAgICAgIGMyX2hpLCBjMl9sbyxcbiAgICAgIGMzX2hpLCBjM19sbyk7XG4gICAgV1tpICsgMV0gPSBzdW02NF80X2xvKFxuICAgICAgYzBfaGksIGMwX2xvLFxuICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgYzNfaGksIGMzX2xvKTtcbiAgfVxufTtcblxuU0hBNTEyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHRoaXMuX3ByZXBhcmVCbG9jayhtc2csIHN0YXJ0KTtcblxuICB2YXIgVyA9IHRoaXMuVztcblxuICB2YXIgYWggPSB0aGlzLmhbMF07XG4gIHZhciBhbCA9IHRoaXMuaFsxXTtcbiAgdmFyIGJoID0gdGhpcy5oWzJdO1xuICB2YXIgYmwgPSB0aGlzLmhbM107XG4gIHZhciBjaCA9IHRoaXMuaFs0XTtcbiAgdmFyIGNsID0gdGhpcy5oWzVdO1xuICB2YXIgZGggPSB0aGlzLmhbNl07XG4gIHZhciBkbCA9IHRoaXMuaFs3XTtcbiAgdmFyIGVoID0gdGhpcy5oWzhdO1xuICB2YXIgZWwgPSB0aGlzLmhbOV07XG4gIHZhciBmaCA9IHRoaXMuaFsxMF07XG4gIHZhciBmbCA9IHRoaXMuaFsxMV07XG4gIHZhciBnaCA9IHRoaXMuaFsxMl07XG4gIHZhciBnbCA9IHRoaXMuaFsxM107XG4gIHZhciBoaCA9IHRoaXMuaFsxNF07XG4gIHZhciBobCA9IHRoaXMuaFsxNV07XG5cbiAgYXNzZXJ0KHRoaXMuay5sZW5ndGggPT09IFcubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBXLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGMwX2hpID0gaGg7XG4gICAgdmFyIGMwX2xvID0gaGw7XG4gICAgdmFyIGMxX2hpID0gczFfNTEyX2hpKGVoLCBlbCk7XG4gICAgdmFyIGMxX2xvID0gczFfNTEyX2xvKGVoLCBlbCk7XG4gICAgdmFyIGMyX2hpID0gY2g2NF9oaShlaCwgZWwsIGZoLCBmbCwgZ2gsIGdsKTtcbiAgICB2YXIgYzJfbG8gPSBjaDY0X2xvKGVoLCBlbCwgZmgsIGZsLCBnaCwgZ2wpO1xuICAgIHZhciBjM19oaSA9IHRoaXMua1tpXTtcbiAgICB2YXIgYzNfbG8gPSB0aGlzLmtbaSArIDFdO1xuICAgIHZhciBjNF9oaSA9IFdbaV07XG4gICAgdmFyIGM0X2xvID0gV1tpICsgMV07XG5cbiAgICB2YXIgVDFfaGkgPSBzdW02NF81X2hpKFxuICAgICAgYzBfaGksIGMwX2xvLFxuICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgYzNfaGksIGMzX2xvLFxuICAgICAgYzRfaGksIGM0X2xvKTtcbiAgICB2YXIgVDFfbG8gPSBzdW02NF81X2xvKFxuICAgICAgYzBfaGksIGMwX2xvLFxuICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgYzNfaGksIGMzX2xvLFxuICAgICAgYzRfaGksIGM0X2xvKTtcblxuICAgIGMwX2hpID0gczBfNTEyX2hpKGFoLCBhbCk7XG4gICAgYzBfbG8gPSBzMF81MTJfbG8oYWgsIGFsKTtcbiAgICBjMV9oaSA9IG1hajY0X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wpO1xuICAgIGMxX2xvID0gbWFqNjRfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCk7XG5cbiAgICB2YXIgVDJfaGkgPSBzdW02NF9oaShjMF9oaSwgYzBfbG8sIGMxX2hpLCBjMV9sbyk7XG4gICAgdmFyIFQyX2xvID0gc3VtNjRfbG8oYzBfaGksIGMwX2xvLCBjMV9oaSwgYzFfbG8pO1xuXG4gICAgaGggPSBnaDtcbiAgICBobCA9IGdsO1xuXG4gICAgZ2ggPSBmaDtcbiAgICBnbCA9IGZsO1xuXG4gICAgZmggPSBlaDtcbiAgICBmbCA9IGVsO1xuXG4gICAgZWggPSBzdW02NF9oaShkaCwgZGwsIFQxX2hpLCBUMV9sbyk7XG4gICAgZWwgPSBzdW02NF9sbyhkbCwgZGwsIFQxX2hpLCBUMV9sbyk7XG5cbiAgICBkaCA9IGNoO1xuICAgIGRsID0gY2w7XG5cbiAgICBjaCA9IGJoO1xuICAgIGNsID0gYmw7XG5cbiAgICBiaCA9IGFoO1xuICAgIGJsID0gYWw7XG5cbiAgICBhaCA9IHN1bTY0X2hpKFQxX2hpLCBUMV9sbywgVDJfaGksIFQyX2xvKTtcbiAgICBhbCA9IHN1bTY0X2xvKFQxX2hpLCBUMV9sbywgVDJfaGksIFQyX2xvKTtcbiAgfVxuXG4gIHN1bTY0KHRoaXMuaCwgMCwgYWgsIGFsKTtcbiAgc3VtNjQodGhpcy5oLCAyLCBiaCwgYmwpO1xuICBzdW02NCh0aGlzLmgsIDQsIGNoLCBjbCk7XG4gIHN1bTY0KHRoaXMuaCwgNiwgZGgsIGRsKTtcbiAgc3VtNjQodGhpcy5oLCA4LCBlaCwgZWwpO1xuICBzdW02NCh0aGlzLmgsIDEwLCBmaCwgZmwpO1xuICBzdW02NCh0aGlzLmgsIDEyLCBnaCwgZ2wpO1xuICBzdW02NCh0aGlzLmgsIDE0LCBoaCwgaGwpO1xufTtcblxuU0hBNTEyLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2JpZycpO1xufTtcblxuZnVuY3Rpb24gY2g2NF9oaSh4aCwgeGwsIHloLCB5bCwgemgpIHtcbiAgdmFyIHIgPSAoeGggJiB5aCkgXiAoKH54aCkgJiB6aCk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gY2g2NF9sbyh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG4gIHZhciByID0gKHhsICYgeWwpIF4gKCh+eGwpICYgemwpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIG1hajY0X2hpKHhoLCB4bCwgeWgsIHlsLCB6aCkge1xuICB2YXIgciA9ICh4aCAmIHloKSBeICh4aCAmIHpoKSBeICh5aCAmIHpoKTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBtYWo2NF9sbyh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG4gIHZhciByID0gKHhsICYgeWwpIF4gKHhsICYgemwpIF4gKHlsICYgemwpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMwXzUxMl9oaSh4aCwgeGwpIHtcbiAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMjgpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCAyKTsgIC8vIDM0XG4gIHZhciBjMl9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDcpOyAgLy8gMzlcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBzMF81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDI4KTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgMik7ICAvLyAzNFxuICB2YXIgYzJfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCA3KTsgIC8vIDM5XG5cbiAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gczFfNTEyX2hpKHhoLCB4bCkge1xuICB2YXIgYzBfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAxNCk7XG4gIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDE4KTtcbiAgdmFyIGMyX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgOSk7ICAvLyA0MVxuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMxXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMTQpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAxOCk7XG4gIHZhciBjMl9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDkpOyAgLy8gNDFcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMF81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDEpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCA4KTtcbiAgdmFyIGMyX2hpID0gc2hyNjRfaGkoeGgsIHhsLCA3KTtcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMF81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDEpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCA4KTtcbiAgdmFyIGMyX2xvID0gc2hyNjRfbG8oeGgsIHhsLCA3KTtcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMV81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDE5KTtcbiAgdmFyIGMxX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgMjkpOyAgLy8gNjFcbiAgdmFyIGMyX2hpID0gc2hyNjRfaGkoeGgsIHhsLCA2KTtcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMV81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDE5KTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgMjkpOyAgLy8gNjFcbiAgdmFyIGMyX2xvID0gc2hyNjRfbG8oeGgsIHhsLCA2KTtcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIHJvdHIzMiA9IHV0aWxzLnJvdHIzMjtcblxuZnVuY3Rpb24gZnRfMShzLCB4LCB5LCB6KSB7XG4gIGlmIChzID09PSAwKVxuICAgIHJldHVybiBjaDMyKHgsIHksIHopO1xuICBpZiAocyA9PT0gMSB8fCBzID09PSAzKVxuICAgIHJldHVybiBwMzIoeCwgeSwgeik7XG4gIGlmIChzID09PSAyKVxuICAgIHJldHVybiBtYWozMih4LCB5LCB6KTtcbn1cbmV4cG9ydHMuZnRfMSA9IGZ0XzE7XG5cbmZ1bmN0aW9uIGNoMzIoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSBeICgofngpICYgeik7XG59XG5leHBvcnRzLmNoMzIgPSBjaDMyO1xuXG5mdW5jdGlvbiBtYWozMih4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIF4gKHggJiB6KSBeICh5ICYgeik7XG59XG5leHBvcnRzLm1hajMyID0gbWFqMzI7XG5cbmZ1bmN0aW9uIHAzMih4LCB5LCB6KSB7XG4gIHJldHVybiB4IF4geSBeIHo7XG59XG5leHBvcnRzLnAzMiA9IHAzMjtcblxuZnVuY3Rpb24gczBfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCAyKSBeIHJvdHIzMih4LCAxMykgXiByb3RyMzIoeCwgMjIpO1xufVxuZXhwb3J0cy5zMF8yNTYgPSBzMF8yNTY7XG5cbmZ1bmN0aW9uIHMxXzI1Nih4KSB7XG4gIHJldHVybiByb3RyMzIoeCwgNikgXiByb3RyMzIoeCwgMTEpIF4gcm90cjMyKHgsIDI1KTtcbn1cbmV4cG9ydHMuczFfMjU2ID0gczFfMjU2O1xuXG5mdW5jdGlvbiBnMF8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDcpIF4gcm90cjMyKHgsIDE4KSBeICh4ID4+PiAzKTtcbn1cbmV4cG9ydHMuZzBfMjU2ID0gZzBfMjU2O1xuXG5mdW5jdGlvbiBnMV8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDE3KSBeIHJvdHIzMih4LCAxOSkgXiAoeCA+Pj4gMTApO1xufVxuZXhwb3J0cy5nMV8yNTYgPSBnMV8yNTY7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLmluaGVyaXRzID0gaW5oZXJpdHM7XG5cbmZ1bmN0aW9uIGlzU3Vycm9nYXRlUGFpcihtc2csIGkpIHtcbiAgaWYgKChtc2cuY2hhckNvZGVBdChpKSAmIDB4RkMwMCkgIT09IDB4RDgwMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaSA8IDAgfHwgaSArIDEgPj0gbXNnLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKG1zZy5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4RkMwMCkgPT09IDB4REMwMDtcbn1cblxuZnVuY3Rpb24gdG9BcnJheShtc2csIGVuYykge1xuICBpZiAoQXJyYXkuaXNBcnJheShtc2cpKVxuICAgIHJldHVybiBtc2cuc2xpY2UoKTtcbiAgaWYgKCFtc2cpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgcmVzID0gW107XG4gIGlmICh0eXBlb2YgbXNnID09PSAnc3RyaW5nJykge1xuICAgIGlmICghZW5jKSB7XG4gICAgICAvLyBJbnNwaXJlZCBieSBzdHJpbmdUb1V0ZjhCeXRlQXJyYXkoKSBpbiBjbG9zdXJlLWxpYnJhcnkgYnkgR29vZ2xlXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtbGlicmFyeS9ibG9iLzg1OThkODcyNDJhZjU5YWFjMjMzMjcwNzQyYzg5ODRlMmIyYmRiZTAvY2xvc3VyZS9nb29nL2NyeXB0L2NyeXB0LmpzI0wxMTctTDE0M1xuICAgICAgLy8gQXBhY2hlIExpY2Vuc2UgMi4wXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtbGlicmFyeS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gICAgICB2YXIgcCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgIHJlc1twKytdID0gYztcbiAgICAgICAgfSBlbHNlIGlmIChjIDwgMjA0OCkge1xuICAgICAgICAgIHJlc1twKytdID0gKGMgPj4gNikgfCAxOTI7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfSBlbHNlIGlmIChpc1N1cnJvZ2F0ZVBhaXIobXNnLCBpKSkge1xuICAgICAgICAgIGMgPSAweDEwMDAwICsgKChjICYgMHgwM0ZGKSA8PCAxMCkgKyAobXNnLmNoYXJDb2RlQXQoKytpKSAmIDB4MDNGRik7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyA+PiAxOCkgfCAyNDA7XG4gICAgICAgICAgcmVzW3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xuICAgICAgICAgIHJlc1twKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgICAgIHJlc1twKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XG4gICAgICAgICAgcmVzW3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW5jID09PSAnaGV4Jykge1xuICAgICAgbXNnID0gbXNnLnJlcGxhY2UoL1teYS16MC05XSsvaWcsICcnKTtcbiAgICAgIGlmIChtc2cubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgICAgbXNnID0gJzAnICsgbXNnO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgcmVzLnB1c2gocGFyc2VJbnQobXNnW2ldICsgbXNnW2kgKyAxXSwgMTYpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICAgIHJlc1tpXSA9IG1zZ1tpXSB8IDA7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMudG9BcnJheSA9IHRvQXJyYXk7XG5cbmZ1bmN0aW9uIHRvSGV4KG1zZykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgIHJlcyArPSB6ZXJvMihtc2dbaV0udG9TdHJpbmcoMTYpKTtcbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMudG9IZXggPSB0b0hleDtcblxuZnVuY3Rpb24gaHRvbmwodykge1xuICB2YXIgcmVzID0gKHcgPj4+IDI0KSB8XG4gICAgICAgICAgICAoKHcgPj4+IDgpICYgMHhmZjAwKSB8XG4gICAgICAgICAgICAoKHcgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICAgICAgICAgKCh3ICYgMHhmZikgPDwgMjQpO1xuICByZXR1cm4gcmVzID4+PiAwO1xufVxuZXhwb3J0cy5odG9ubCA9IGh0b25sO1xuXG5mdW5jdGlvbiB0b0hleDMyKG1zZywgZW5kaWFuKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdyA9IG1zZ1tpXTtcbiAgICBpZiAoZW5kaWFuID09PSAnbGl0dGxlJylcbiAgICAgIHcgPSBodG9ubCh3KTtcbiAgICByZXMgKz0gemVybzgody50b1N0cmluZygxNikpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5leHBvcnRzLnRvSGV4MzIgPSB0b0hleDMyO1xuXG5mdW5jdGlvbiB6ZXJvMih3b3JkKSB7XG4gIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gJzAnICsgd29yZDtcbiAgZWxzZVxuICAgIHJldHVybiB3b3JkO1xufVxuZXhwb3J0cy56ZXJvMiA9IHplcm8yO1xuXG5mdW5jdGlvbiB6ZXJvOCh3b3JkKSB7XG4gIGlmICh3b3JkLmxlbmd0aCA9PT0gNylcbiAgICByZXR1cm4gJzAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDYpXG4gICAgcmV0dXJuICcwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNSlcbiAgICByZXR1cm4gJzAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNClcbiAgICByZXR1cm4gJzAwMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDMpXG4gICAgcmV0dXJuICcwMDAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMilcbiAgICByZXR1cm4gJzAwMDAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gJzAwMDAwMDAnICsgd29yZDtcbiAgZWxzZVxuICAgIHJldHVybiB3b3JkO1xufVxuZXhwb3J0cy56ZXJvOCA9IHplcm84O1xuXG5mdW5jdGlvbiBqb2luMzIobXNnLCBzdGFydCwgZW5kLCBlbmRpYW4pIHtcbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xuICBhc3NlcnQobGVuICUgNCA9PT0gMCk7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuIC8gNCk7XG4gIGZvciAodmFyIGkgPSAwLCBrID0gc3RhcnQ7IGkgPCByZXMubGVuZ3RoOyBpKyssIGsgKz0gNCkge1xuICAgIHZhciB3O1xuICAgIGlmIChlbmRpYW4gPT09ICdiaWcnKVxuICAgICAgdyA9IChtc2dba10gPDwgMjQpIHwgKG1zZ1trICsgMV0gPDwgMTYpIHwgKG1zZ1trICsgMl0gPDwgOCkgfCBtc2dbayArIDNdO1xuICAgIGVsc2VcbiAgICAgIHcgPSAobXNnW2sgKyAzXSA8PCAyNCkgfCAobXNnW2sgKyAyXSA8PCAxNikgfCAobXNnW2sgKyAxXSA8PCA4KSB8IG1zZ1trXTtcbiAgICByZXNbaV0gPSB3ID4+PiAwO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5leHBvcnRzLmpvaW4zMiA9IGpvaW4zMjtcblxuZnVuY3Rpb24gc3BsaXQzMihtc2csIGVuZGlhbikge1xuICB2YXIgcmVzID0gbmV3IEFycmF5KG1zZy5sZW5ndGggKiA0KTtcbiAgZm9yICh2YXIgaSA9IDAsIGsgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrLCBrICs9IDQpIHtcbiAgICB2YXIgbSA9IG1zZ1tpXTtcbiAgICBpZiAoZW5kaWFuID09PSAnYmlnJykge1xuICAgICAgcmVzW2tdID0gbSA+Pj4gMjQ7XG4gICAgICByZXNbayArIDFdID0gKG0gPj4+IDE2KSAmIDB4ZmY7XG4gICAgICByZXNbayArIDJdID0gKG0gPj4+IDgpICYgMHhmZjtcbiAgICAgIHJlc1trICsgM10gPSBtICYgMHhmZjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2sgKyAzXSA9IG0gPj4+IDI0O1xuICAgICAgcmVzW2sgKyAyXSA9IChtID4+PiAxNikgJiAweGZmO1xuICAgICAgcmVzW2sgKyAxXSA9IChtID4+PiA4KSAmIDB4ZmY7XG4gICAgICByZXNba10gPSBtICYgMHhmZjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuc3BsaXQzMiA9IHNwbGl0MzI7XG5cbmZ1bmN0aW9uIHJvdHIzMih3LCBiKSB7XG4gIHJldHVybiAodyA+Pj4gYikgfCAodyA8PCAoMzIgLSBiKSk7XG59XG5leHBvcnRzLnJvdHIzMiA9IHJvdHIzMjtcblxuZnVuY3Rpb24gcm90bDMyKHcsIGIpIHtcbiAgcmV0dXJuICh3IDw8IGIpIHwgKHcgPj4+ICgzMiAtIGIpKTtcbn1cbmV4cG9ydHMucm90bDMyID0gcm90bDMyO1xuXG5mdW5jdGlvbiBzdW0zMihhLCBiKSB7XG4gIHJldHVybiAoYSArIGIpID4+PiAwO1xufVxuZXhwb3J0cy5zdW0zMiA9IHN1bTMyO1xuXG5mdW5jdGlvbiBzdW0zMl8zKGEsIGIsIGMpIHtcbiAgcmV0dXJuIChhICsgYiArIGMpID4+PiAwO1xufVxuZXhwb3J0cy5zdW0zMl8zID0gc3VtMzJfMztcblxuZnVuY3Rpb24gc3VtMzJfNChhLCBiLCBjLCBkKSB7XG4gIHJldHVybiAoYSArIGIgKyBjICsgZCkgPj4+IDA7XG59XG5leHBvcnRzLnN1bTMyXzQgPSBzdW0zMl80O1xuXG5mdW5jdGlvbiBzdW0zMl81KGEsIGIsIGMsIGQsIGUpIHtcbiAgcmV0dXJuIChhICsgYiArIGMgKyBkICsgZSkgPj4+IDA7XG59XG5leHBvcnRzLnN1bTMyXzUgPSBzdW0zMl81O1xuXG5mdW5jdGlvbiBzdW02NChidWYsIHBvcywgYWgsIGFsKSB7XG4gIHZhciBiaCA9IGJ1Zltwb3NdO1xuICB2YXIgYmwgPSBidWZbcG9zICsgMV07XG5cbiAgdmFyIGxvID0gKGFsICsgYmwpID4+PiAwO1xuICB2YXIgaGkgPSAobG8gPCBhbCA/IDEgOiAwKSArIGFoICsgYmg7XG4gIGJ1Zltwb3NdID0gaGkgPj4+IDA7XG4gIGJ1Zltwb3MgKyAxXSA9IGxvO1xufVxuZXhwb3J0cy5zdW02NCA9IHN1bTY0O1xuXG5mdW5jdGlvbiBzdW02NF9oaShhaCwgYWwsIGJoLCBibCkge1xuICB2YXIgbG8gPSAoYWwgKyBibCkgPj4+IDA7XG4gIHZhciBoaSA9IChsbyA8IGFsID8gMSA6IDApICsgYWggKyBiaDtcbiAgcmV0dXJuIGhpID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF9oaSA9IHN1bTY0X2hpO1xuXG5mdW5jdGlvbiBzdW02NF9sbyhhaCwgYWwsIGJoLCBibCkge1xuICB2YXIgbG8gPSBhbCArIGJsO1xuICByZXR1cm4gbG8gPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0X2xvID0gc3VtNjRfbG87XG5cbmZ1bmN0aW9uIHN1bTY0XzRfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIHZhciBsbyA9IGFsO1xuICBsbyA9IChsbyArIGJsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBhbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGNsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBjbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGRsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBkbCA/IDEgOiAwO1xuXG4gIHZhciBoaSA9IGFoICsgYmggKyBjaCArIGRoICsgY2Fycnk7XG4gIHJldHVybiBoaSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfNF9oaSA9IHN1bTY0XzRfaGk7XG5cbmZ1bmN0aW9uIHN1bTY0XzRfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsKSB7XG4gIHZhciBsbyA9IGFsICsgYmwgKyBjbCArIGRsO1xuICByZXR1cm4gbG8gPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0XzRfbG8gPSBzdW02NF80X2xvO1xuXG5mdW5jdGlvbiBzdW02NF81X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCwgZWgsIGVsKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIHZhciBsbyA9IGFsO1xuICBsbyA9IChsbyArIGJsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBhbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGNsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBjbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGRsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBkbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGVsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBlbCA/IDEgOiAwO1xuXG4gIHZhciBoaSA9IGFoICsgYmggKyBjaCArIGRoICsgZWggKyBjYXJyeTtcbiAgcmV0dXJuIGhpID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF81X2hpID0gc3VtNjRfNV9oaTtcblxuZnVuY3Rpb24gc3VtNjRfNV9sbyhhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwsIGVoLCBlbCkge1xuICB2YXIgbG8gPSBhbCArIGJsICsgY2wgKyBkbCArIGVsO1xuXG4gIHJldHVybiBsbyA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfNV9sbyA9IHN1bTY0XzVfbG87XG5cbmZ1bmN0aW9uIHJvdHI2NF9oaShhaCwgYWwsIG51bSkge1xuICB2YXIgciA9IChhbCA8PCAoMzIgLSBudW0pKSB8IChhaCA+Pj4gbnVtKTtcbiAgcmV0dXJuIHIgPj4+IDA7XG59XG5leHBvcnRzLnJvdHI2NF9oaSA9IHJvdHI2NF9oaTtcblxuZnVuY3Rpb24gcm90cjY0X2xvKGFoLCBhbCwgbnVtKSB7XG4gIHZhciByID0gKGFoIDw8ICgzMiAtIG51bSkpIHwgKGFsID4+PiBudW0pO1xuICByZXR1cm4gciA+Pj4gMDtcbn1cbmV4cG9ydHMucm90cjY0X2xvID0gcm90cjY0X2xvO1xuXG5mdW5jdGlvbiBzaHI2NF9oaShhaCwgYWwsIG51bSkge1xuICByZXR1cm4gYWggPj4+IG51bTtcbn1cbmV4cG9ydHMuc2hyNjRfaGkgPSBzaHI2NF9oaTtcblxuZnVuY3Rpb24gc2hyNjRfbG8oYWgsIGFsLCBudW0pIHtcbiAgdmFyIHIgPSAoYWggPDwgKDMyIC0gbnVtKSkgfCAoYWwgPj4+IG51bSk7XG4gIHJldHVybiByID4+PiAwO1xufVxuZXhwb3J0cy5zaHI2NF9sbyA9IHNocjY0X2xvO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJ2hhc2guanMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1jcnlwdG8tdXRpbHMnKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG5cbmZ1bmN0aW9uIEhtYWNEUkJHKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhtYWNEUkJHKSlcbiAgICByZXR1cm4gbmV3IEhtYWNEUkJHKG9wdGlvbnMpO1xuICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2g7XG4gIHRoaXMucHJlZFJlc2lzdCA9ICEhb3B0aW9ucy5wcmVkUmVzaXN0O1xuXG4gIHRoaXMub3V0TGVuID0gdGhpcy5oYXNoLm91dFNpemU7XG4gIHRoaXMubWluRW50cm9weSA9IG9wdGlvbnMubWluRW50cm9weSB8fCB0aGlzLmhhc2guaG1hY1N0cmVuZ3RoO1xuXG4gIHRoaXMuX3Jlc2VlZCA9IG51bGw7XG4gIHRoaXMucmVzZWVkSW50ZXJ2YWwgPSBudWxsO1xuICB0aGlzLksgPSBudWxsO1xuICB0aGlzLlYgPSBudWxsO1xuXG4gIHZhciBlbnRyb3B5ID0gdXRpbHMudG9BcnJheShvcHRpb25zLmVudHJvcHksIG9wdGlvbnMuZW50cm9weUVuYyB8fCAnaGV4Jyk7XG4gIHZhciBub25jZSA9IHV0aWxzLnRvQXJyYXkob3B0aW9ucy5ub25jZSwgb3B0aW9ucy5ub25jZUVuYyB8fCAnaGV4Jyk7XG4gIHZhciBwZXJzID0gdXRpbHMudG9BcnJheShvcHRpb25zLnBlcnMsIG9wdGlvbnMucGVyc0VuYyB8fCAnaGV4Jyk7XG4gIGFzc2VydChlbnRyb3B5Lmxlbmd0aCA+PSAodGhpcy5taW5FbnRyb3B5IC8gOCksXG4gICAgICAgICAnTm90IGVub3VnaCBlbnRyb3B5LiBNaW5pbXVtIGlzOiAnICsgdGhpcy5taW5FbnRyb3B5ICsgJyBiaXRzJyk7XG4gIHRoaXMuX2luaXQoZW50cm9weSwgbm9uY2UsIHBlcnMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBIbWFjRFJCRztcblxuSG1hY0RSQkcucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdChlbnRyb3B5LCBub25jZSwgcGVycykge1xuICB2YXIgc2VlZCA9IGVudHJvcHkuY29uY2F0KG5vbmNlKS5jb25jYXQocGVycyk7XG5cbiAgdGhpcy5LID0gbmV3IEFycmF5KHRoaXMub3V0TGVuIC8gOCk7XG4gIHRoaXMuViA9IG5ldyBBcnJheSh0aGlzLm91dExlbiAvIDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuVi5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuS1tpXSA9IDB4MDA7XG4gICAgdGhpcy5WW2ldID0gMHgwMTtcbiAgfVxuXG4gIHRoaXMuX3VwZGF0ZShzZWVkKTtcbiAgdGhpcy5fcmVzZWVkID0gMTtcbiAgdGhpcy5yZXNlZWRJbnRlcnZhbCA9IDB4MTAwMDAwMDAwMDAwMDsgIC8vIDJeNDhcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5faG1hYyA9IGZ1bmN0aW9uIGhtYWMoKSB7XG4gIHJldHVybiBuZXcgaGFzaC5obWFjKHRoaXMuaGFzaCwgdGhpcy5LKTtcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNlZWQpIHtcbiAgdmFyIGttYWMgPSB0aGlzLl9obWFjKClcbiAgICAgICAgICAgICAgICAgLnVwZGF0ZSh0aGlzLlYpXG4gICAgICAgICAgICAgICAgIC51cGRhdGUoWyAweDAwIF0pO1xuICBpZiAoc2VlZClcbiAgICBrbWFjID0ga21hYy51cGRhdGUoc2VlZCk7XG4gIHRoaXMuSyA9IGttYWMuZGlnZXN0KCk7XG4gIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcbiAgaWYgKCFzZWVkKVxuICAgIHJldHVybjtcblxuICB0aGlzLksgPSB0aGlzLl9obWFjKClcbiAgICAgICAgICAgICAgIC51cGRhdGUodGhpcy5WKVxuICAgICAgICAgICAgICAgLnVwZGF0ZShbIDB4MDEgXSlcbiAgICAgICAgICAgICAgIC51cGRhdGUoc2VlZClcbiAgICAgICAgICAgICAgIC5kaWdlc3QoKTtcbiAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLnJlc2VlZCA9IGZ1bmN0aW9uIHJlc2VlZChlbnRyb3B5LCBlbnRyb3B5RW5jLCBhZGQsIGFkZEVuYykge1xuICAvLyBPcHRpb25hbCBlbnRyb3B5IGVuY1xuICBpZiAodHlwZW9mIGVudHJvcHlFbmMgIT09ICdzdHJpbmcnKSB7XG4gICAgYWRkRW5jID0gYWRkO1xuICAgIGFkZCA9IGVudHJvcHlFbmM7XG4gICAgZW50cm9weUVuYyA9IG51bGw7XG4gIH1cblxuICBlbnRyb3B5ID0gdXRpbHMudG9BcnJheShlbnRyb3B5LCBlbnRyb3B5RW5jKTtcbiAgYWRkID0gdXRpbHMudG9BcnJheShhZGQsIGFkZEVuYyk7XG5cbiAgYXNzZXJ0KGVudHJvcHkubGVuZ3RoID49ICh0aGlzLm1pbkVudHJvcHkgLyA4KSxcbiAgICAgICAgICdOb3QgZW5vdWdoIGVudHJvcHkuIE1pbmltdW0gaXM6ICcgKyB0aGlzLm1pbkVudHJvcHkgKyAnIGJpdHMnKTtcblxuICB0aGlzLl91cGRhdGUoZW50cm9weS5jb25jYXQoYWRkIHx8IFtdKSk7XG4gIHRoaXMuX3Jlc2VlZCA9IDE7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZShsZW4sIGVuYywgYWRkLCBhZGRFbmMpIHtcbiAgaWYgKHRoaXMuX3Jlc2VlZCA+IHRoaXMucmVzZWVkSW50ZXJ2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXNlZWQgaXMgcmVxdWlyZWQnKTtcblxuICAvLyBPcHRpb25hbCBlbmNvZGluZ1xuICBpZiAodHlwZW9mIGVuYyAhPT0gJ3N0cmluZycpIHtcbiAgICBhZGRFbmMgPSBhZGQ7XG4gICAgYWRkID0gZW5jO1xuICAgIGVuYyA9IG51bGw7XG4gIH1cblxuICAvLyBPcHRpb25hbCBhZGRpdGlvbmFsIGRhdGFcbiAgaWYgKGFkZCkge1xuICAgIGFkZCA9IHV0aWxzLnRvQXJyYXkoYWRkLCBhZGRFbmMgfHwgJ2hleCcpO1xuICAgIHRoaXMuX3VwZGF0ZShhZGQpO1xuICB9XG5cbiAgdmFyIHRlbXAgPSBbXTtcbiAgd2hpbGUgKHRlbXAubGVuZ3RoIDwgbGVuKSB7XG4gICAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xuICAgIHRlbXAgPSB0ZW1wLmNvbmNhdCh0aGlzLlYpO1xuICB9XG5cbiAgdmFyIHJlcyA9IHRlbXAuc2xpY2UoMCwgbGVuKTtcbiAgdGhpcy5fdXBkYXRlKGFkZCk7XG4gIHRoaXMuX3Jlc2VlZCsrO1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHJlcywgZW5jKTtcbn07XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJcbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07IiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2hCYXNlID0gcmVxdWlyZSgnaGFzaC1iYXNlJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgQVJSQVkxNiA9IG5ldyBBcnJheSgxNilcblxuZnVuY3Rpb24gTUQ1ICgpIHtcbiAgSGFzaEJhc2UuY2FsbCh0aGlzLCA2NClcblxuICAvLyBzdGF0ZVxuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxufVxuXG5pbmhlcml0cyhNRDUsIEhhc2hCYXNlKVxuXG5NRDUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBNID0gQVJSQVkxNlxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIE1baV0gPSB0aGlzLl9ibG9jay5yZWFkSW50MzJMRShpICogNClcblxuICB2YXIgYSA9IHRoaXMuX2FcbiAgdmFyIGIgPSB0aGlzLl9iXG4gIHZhciBjID0gdGhpcy5fY1xuICB2YXIgZCA9IHRoaXMuX2RcblxuICBhID0gZm5GKGEsIGIsIGMsIGQsIE1bMF0sIDB4ZDc2YWE0NzgsIDcpXG4gIGQgPSBmbkYoZCwgYSwgYiwgYywgTVsxXSwgMHhlOGM3Yjc1NiwgMTIpXG4gIGMgPSBmbkYoYywgZCwgYSwgYiwgTVsyXSwgMHgyNDIwNzBkYiwgMTcpXG4gIGIgPSBmbkYoYiwgYywgZCwgYSwgTVszXSwgMHhjMWJkY2VlZSwgMjIpXG4gIGEgPSBmbkYoYSwgYiwgYywgZCwgTVs0XSwgMHhmNTdjMGZhZiwgNylcbiAgZCA9IGZuRihkLCBhLCBiLCBjLCBNWzVdLCAweDQ3ODdjNjJhLCAxMilcbiAgYyA9IGZuRihjLCBkLCBhLCBiLCBNWzZdLCAweGE4MzA0NjEzLCAxNylcbiAgYiA9IGZuRihiLCBjLCBkLCBhLCBNWzddLCAweGZkNDY5NTAxLCAyMilcbiAgYSA9IGZuRihhLCBiLCBjLCBkLCBNWzhdLCAweDY5ODA5OGQ4LCA3KVxuICBkID0gZm5GKGQsIGEsIGIsIGMsIE1bOV0sIDB4OGI0NGY3YWYsIDEyKVxuICBjID0gZm5GKGMsIGQsIGEsIGIsIE1bMTBdLCAweGZmZmY1YmIxLCAxNylcbiAgYiA9IGZuRihiLCBjLCBkLCBhLCBNWzExXSwgMHg4OTVjZDdiZSwgMjIpXG4gIGEgPSBmbkYoYSwgYiwgYywgZCwgTVsxMl0sIDB4NmI5MDExMjIsIDcpXG4gIGQgPSBmbkYoZCwgYSwgYiwgYywgTVsxM10sIDB4ZmQ5ODcxOTMsIDEyKVxuICBjID0gZm5GKGMsIGQsIGEsIGIsIE1bMTRdLCAweGE2Nzk0MzhlLCAxNylcbiAgYiA9IGZuRihiLCBjLCBkLCBhLCBNWzE1XSwgMHg0OWI0MDgyMSwgMjIpXG5cbiAgYSA9IGZuRyhhLCBiLCBjLCBkLCBNWzFdLCAweGY2MWUyNTYyLCA1KVxuICBkID0gZm5HKGQsIGEsIGIsIGMsIE1bNl0sIDB4YzA0MGIzNDAsIDkpXG4gIGMgPSBmbkcoYywgZCwgYSwgYiwgTVsxMV0sIDB4MjY1ZTVhNTEsIDE0KVxuICBiID0gZm5HKGIsIGMsIGQsIGEsIE1bMF0sIDB4ZTliNmM3YWEsIDIwKVxuICBhID0gZm5HKGEsIGIsIGMsIGQsIE1bNV0sIDB4ZDYyZjEwNWQsIDUpXG4gIGQgPSBmbkcoZCwgYSwgYiwgYywgTVsxMF0sIDB4MDI0NDE0NTMsIDkpXG4gIGMgPSBmbkcoYywgZCwgYSwgYiwgTVsxNV0sIDB4ZDhhMWU2ODEsIDE0KVxuICBiID0gZm5HKGIsIGMsIGQsIGEsIE1bNF0sIDB4ZTdkM2ZiYzgsIDIwKVxuICBhID0gZm5HKGEsIGIsIGMsIGQsIE1bOV0sIDB4MjFlMWNkZTYsIDUpXG4gIGQgPSBmbkcoZCwgYSwgYiwgYywgTVsxNF0sIDB4YzMzNzA3ZDYsIDkpXG4gIGMgPSBmbkcoYywgZCwgYSwgYiwgTVszXSwgMHhmNGQ1MGQ4NywgMTQpXG4gIGIgPSBmbkcoYiwgYywgZCwgYSwgTVs4XSwgMHg0NTVhMTRlZCwgMjApXG4gIGEgPSBmbkcoYSwgYiwgYywgZCwgTVsxM10sIDB4YTllM2U5MDUsIDUpXG4gIGQgPSBmbkcoZCwgYSwgYiwgYywgTVsyXSwgMHhmY2VmYTNmOCwgOSlcbiAgYyA9IGZuRyhjLCBkLCBhLCBiLCBNWzddLCAweDY3NmYwMmQ5LCAxNClcbiAgYiA9IGZuRyhiLCBjLCBkLCBhLCBNWzEyXSwgMHg4ZDJhNGM4YSwgMjApXG5cbiAgYSA9IGZuSChhLCBiLCBjLCBkLCBNWzVdLCAweGZmZmEzOTQyLCA0KVxuICBkID0gZm5IKGQsIGEsIGIsIGMsIE1bOF0sIDB4ODc3MWY2ODEsIDExKVxuICBjID0gZm5IKGMsIGQsIGEsIGIsIE1bMTFdLCAweDZkOWQ2MTIyLCAxNilcbiAgYiA9IGZuSChiLCBjLCBkLCBhLCBNWzE0XSwgMHhmZGU1MzgwYywgMjMpXG4gIGEgPSBmbkgoYSwgYiwgYywgZCwgTVsxXSwgMHhhNGJlZWE0NCwgNClcbiAgZCA9IGZuSChkLCBhLCBiLCBjLCBNWzRdLCAweDRiZGVjZmE5LCAxMSlcbiAgYyA9IGZuSChjLCBkLCBhLCBiLCBNWzddLCAweGY2YmI0YjYwLCAxNilcbiAgYiA9IGZuSChiLCBjLCBkLCBhLCBNWzEwXSwgMHhiZWJmYmM3MCwgMjMpXG4gIGEgPSBmbkgoYSwgYiwgYywgZCwgTVsxM10sIDB4Mjg5YjdlYzYsIDQpXG4gIGQgPSBmbkgoZCwgYSwgYiwgYywgTVswXSwgMHhlYWExMjdmYSwgMTEpXG4gIGMgPSBmbkgoYywgZCwgYSwgYiwgTVszXSwgMHhkNGVmMzA4NSwgMTYpXG4gIGIgPSBmbkgoYiwgYywgZCwgYSwgTVs2XSwgMHgwNDg4MWQwNSwgMjMpXG4gIGEgPSBmbkgoYSwgYiwgYywgZCwgTVs5XSwgMHhkOWQ0ZDAzOSwgNClcbiAgZCA9IGZuSChkLCBhLCBiLCBjLCBNWzEyXSwgMHhlNmRiOTllNSwgMTEpXG4gIGMgPSBmbkgoYywgZCwgYSwgYiwgTVsxNV0sIDB4MWZhMjdjZjgsIDE2KVxuICBiID0gZm5IKGIsIGMsIGQsIGEsIE1bMl0sIDB4YzRhYzU2NjUsIDIzKVxuXG4gIGEgPSBmbkkoYSwgYiwgYywgZCwgTVswXSwgMHhmNDI5MjI0NCwgNilcbiAgZCA9IGZuSShkLCBhLCBiLCBjLCBNWzddLCAweDQzMmFmZjk3LCAxMClcbiAgYyA9IGZuSShjLCBkLCBhLCBiLCBNWzE0XSwgMHhhYjk0MjNhNywgMTUpXG4gIGIgPSBmbkkoYiwgYywgZCwgYSwgTVs1XSwgMHhmYzkzYTAzOSwgMjEpXG4gIGEgPSBmbkkoYSwgYiwgYywgZCwgTVsxMl0sIDB4NjU1YjU5YzMsIDYpXG4gIGQgPSBmbkkoZCwgYSwgYiwgYywgTVszXSwgMHg4ZjBjY2M5MiwgMTApXG4gIGMgPSBmbkkoYywgZCwgYSwgYiwgTVsxMF0sIDB4ZmZlZmY0N2QsIDE1KVxuICBiID0gZm5JKGIsIGMsIGQsIGEsIE1bMV0sIDB4ODU4NDVkZDEsIDIxKVxuICBhID0gZm5JKGEsIGIsIGMsIGQsIE1bOF0sIDB4NmZhODdlNGYsIDYpXG4gIGQgPSBmbkkoZCwgYSwgYiwgYywgTVsxNV0sIDB4ZmUyY2U2ZTAsIDEwKVxuICBjID0gZm5JKGMsIGQsIGEsIGIsIE1bNl0sIDB4YTMwMTQzMTQsIDE1KVxuICBiID0gZm5JKGIsIGMsIGQsIGEsIE1bMTNdLCAweDRlMDgxMWExLCAyMSlcbiAgYSA9IGZuSShhLCBiLCBjLCBkLCBNWzRdLCAweGY3NTM3ZTgyLCA2KVxuICBkID0gZm5JKGQsIGEsIGIsIGMsIE1bMTFdLCAweGJkM2FmMjM1LCAxMClcbiAgYyA9IGZuSShjLCBkLCBhLCBiLCBNWzJdLCAweDJhZDdkMmJiLCAxNSlcbiAgYiA9IGZuSShiLCBjLCBkLCBhLCBNWzldLCAweGViODZkMzkxLCAyMSlcblxuICB0aGlzLl9hID0gKHRoaXMuX2EgKyBhKSB8IDBcbiAgdGhpcy5fYiA9ICh0aGlzLl9iICsgYikgfCAwXG4gIHRoaXMuX2MgPSAodGhpcy5fYyArIGMpIHwgMFxuICB0aGlzLl9kID0gKHRoaXMuX2QgKyBkKSB8IDBcbn1cblxuTUQ1LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBjcmVhdGUgcGFkZGluZyBhbmQgaGFuZGxlIGJsb2Nrc1xuICB0aGlzLl9ibG9ja1t0aGlzLl9ibG9ja09mZnNldCsrXSA9IDB4ODBcbiAgaWYgKHRoaXMuX2Jsb2NrT2Zmc2V0ID4gNTYpIHtcbiAgICB0aGlzLl9ibG9jay5maWxsKDAsIHRoaXMuX2Jsb2NrT2Zmc2V0LCA2NClcbiAgICB0aGlzLl91cGRhdGUoKVxuICAgIHRoaXMuX2Jsb2NrT2Zmc2V0ID0gMFxuICB9XG5cbiAgdGhpcy5fYmxvY2suZmlsbCgwLCB0aGlzLl9ibG9ja09mZnNldCwgNTYpXG4gIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyTEUodGhpcy5fbGVuZ3RoWzBdLCA1NilcbiAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJMRSh0aGlzLl9sZW5ndGhbMV0sIDYwKVxuICB0aGlzLl91cGRhdGUoKVxuXG4gIC8vIHByb2R1Y2UgcmVzdWx0XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTYpXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fYSwgMClcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9iLCA0KVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2MsIDgpXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fZCwgMTIpXG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gcm90bCAoeCwgbikge1xuICByZXR1cm4gKHggPDwgbikgfCAoeCA+Pj4gKDMyIC0gbikpXG59XG5cbmZ1bmN0aW9uIGZuRiAoYSwgYiwgYywgZCwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoKGIgJiBjKSB8ICgofmIpICYgZCkpICsgbSArIGspIHwgMCwgcykgKyBiKSB8IDBcbn1cblxuZnVuY3Rpb24gZm5HIChhLCBiLCBjLCBkLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArICgoYiAmIGQpIHwgKGMgJiAofmQpKSkgKyBtICsgaykgfCAwLCBzKSArIGIpIHwgMFxufVxuXG5mdW5jdGlvbiBmbkggKGEsIGIsIGMsIGQsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKGIgXiBjIF4gZCkgKyBtICsgaykgfCAwLCBzKSArIGIpIHwgMFxufVxuXG5mdW5jdGlvbiBmbkkgKGEsIGIsIGMsIGQsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKChjIF4gKGIgfCAofmQpKSkpICsgbSArIGspIHwgMCwgcykgKyBiKSB8IDBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNRDVcbiIsInZhciBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgYnJvcmFuZCA9IHJlcXVpcmUoJ2Jyb3JhbmQnKTtcblxuZnVuY3Rpb24gTWlsbGVyUmFiaW4ocmFuZCkge1xuICB0aGlzLnJhbmQgPSByYW5kIHx8IG5ldyBicm9yYW5kLlJhbmQoKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gTWlsbGVyUmFiaW47XG5cbk1pbGxlclJhYmluLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShyYW5kKSB7XG4gIHJldHVybiBuZXcgTWlsbGVyUmFiaW4ocmFuZCk7XG59O1xuXG5NaWxsZXJSYWJpbi5wcm90b3R5cGUuX3JhbmRiZWxvdyA9IGZ1bmN0aW9uIF9yYW5kYmVsb3cobikge1xuICB2YXIgbGVuID0gbi5iaXRMZW5ndGgoKTtcbiAgdmFyIG1pbl9ieXRlcyA9IE1hdGguY2VpbChsZW4gLyA4KTtcblxuICAvLyBHZW5lcmFnZSByYW5kb20gYnl0ZXMgdW50aWwgYSBudW1iZXIgbGVzcyB0aGFuIG4gaXMgZm91bmQuXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0IDAuLm4tMSBoYXZlIGFuIGVxdWFsIHByb2JhYmlsaXR5IG9mIGJlaW5nIHNlbGVjdGVkLlxuICBkb1xuICAgIHZhciBhID0gbmV3IGJuKHRoaXMucmFuZC5nZW5lcmF0ZShtaW5fYnl0ZXMpKTtcbiAgd2hpbGUgKGEuY21wKG4pID49IDApO1xuXG4gIHJldHVybiBhO1xufTtcblxuTWlsbGVyUmFiaW4ucHJvdG90eXBlLl9yYW5kcmFuZ2UgPSBmdW5jdGlvbiBfcmFuZHJhbmdlKHN0YXJ0LCBzdG9wKSB7XG4gIC8vIEdlbmVyYXRlIGEgcmFuZG9tIG51bWJlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gc3RhcnQgYW5kIGxlc3MgdGhhbiBzdG9wLlxuICB2YXIgc2l6ZSA9IHN0b3Auc3ViKHN0YXJ0KTtcbiAgcmV0dXJuIHN0YXJ0LmFkZCh0aGlzLl9yYW5kYmVsb3coc2l6ZSkpO1xufTtcblxuTWlsbGVyUmFiaW4ucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiB0ZXN0KG4sIGssIGNiKSB7XG4gIHZhciBsZW4gPSBuLmJpdExlbmd0aCgpO1xuICB2YXIgcmVkID0gYm4ubW9udChuKTtcbiAgdmFyIHJvbmUgPSBuZXcgYm4oMSkudG9SZWQocmVkKTtcblxuICBpZiAoIWspXG4gICAgayA9IE1hdGgubWF4KDEsIChsZW4gLyA0OCkgfCAwKTtcblxuICAvLyBGaW5kIGQgYW5kIHMsIChuIC0gMSkgPSAoMiBeIHMpICogZDtcbiAgdmFyIG4xID0gbi5zdWJuKDEpO1xuICBmb3IgKHZhciBzID0gMDsgIW4xLnRlc3RuKHMpOyBzKyspIHt9XG4gIHZhciBkID0gbi5zaHJuKHMpO1xuXG4gIHZhciBybjEgPSBuMS50b1JlZChyZWQpO1xuXG4gIHZhciBwcmltZSA9IHRydWU7XG4gIGZvciAoOyBrID4gMDsgay0tKSB7XG4gICAgdmFyIGEgPSB0aGlzLl9yYW5kcmFuZ2UobmV3IGJuKDIpLCBuMSk7XG4gICAgaWYgKGNiKVxuICAgICAgY2IoYSk7XG5cbiAgICB2YXIgeCA9IGEudG9SZWQocmVkKS5yZWRQb3coZCk7XG4gICAgaWYgKHguY21wKHJvbmUpID09PSAwIHx8IHguY21wKHJuMSkgPT09IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgczsgaSsrKSB7XG4gICAgICB4ID0geC5yZWRTcXIoKTtcblxuICAgICAgaWYgKHguY21wKHJvbmUpID09PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoeC5jbXAocm4xKSA9PT0gMClcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGkgPT09IHMpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcHJpbWU7XG59O1xuXG5NaWxsZXJSYWJpbi5wcm90b3R5cGUuZ2V0RGl2aXNvciA9IGZ1bmN0aW9uIGdldERpdmlzb3Iobiwgaykge1xuICB2YXIgbGVuID0gbi5iaXRMZW5ndGgoKTtcbiAgdmFyIHJlZCA9IGJuLm1vbnQobik7XG4gIHZhciByb25lID0gbmV3IGJuKDEpLnRvUmVkKHJlZCk7XG5cbiAgaWYgKCFrKVxuICAgIGsgPSBNYXRoLm1heCgxLCAobGVuIC8gNDgpIHwgMCk7XG5cbiAgLy8gRmluZCBkIGFuZCBzLCAobiAtIDEpID0gKDIgXiBzKSAqIGQ7XG4gIHZhciBuMSA9IG4uc3VibigxKTtcbiAgZm9yICh2YXIgcyA9IDA7ICFuMS50ZXN0bihzKTsgcysrKSB7fVxuICB2YXIgZCA9IG4uc2hybihzKTtcblxuICB2YXIgcm4xID0gbjEudG9SZWQocmVkKTtcblxuICBmb3IgKDsgayA+IDA7IGstLSkge1xuICAgIHZhciBhID0gdGhpcy5fcmFuZHJhbmdlKG5ldyBibigyKSwgbjEpO1xuXG4gICAgdmFyIGcgPSBuLmdjZChhKTtcbiAgICBpZiAoZy5jbXBuKDEpICE9PSAwKVxuICAgICAgcmV0dXJuIGc7XG5cbiAgICB2YXIgeCA9IGEudG9SZWQocmVkKS5yZWRQb3coZCk7XG4gICAgaWYgKHguY21wKHJvbmUpID09PSAwIHx8IHguY21wKHJuMSkgPT09IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgczsgaSsrKSB7XG4gICAgICB4ID0geC5yZWRTcXIoKTtcblxuICAgICAgaWYgKHguY21wKHJvbmUpID09PSAwKVxuICAgICAgICByZXR1cm4geC5mcm9tUmVkKCkuc3VibigxKS5nY2Qobik7XG4gICAgICBpZiAoeC5jbXAocm4xKSA9PT0gMClcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGkgPT09IHMpIHtcbiAgICAgIHggPSB4LnJlZFNxcigpO1xuICAgICAgcmV0dXJuIHguZnJvbVJlZCgpLnN1Ym4oMSkuZ2NkKG4pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFzc2VydDtcblxuZnVuY3Rpb24gYXNzZXJ0KHZhbCwgbXNnKSB7XG4gIGlmICghdmFsKVxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbn1cblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gYXNzZXJ0RXF1YWwobCwgciwgbXNnKSB7XG4gIGlmIChsICE9IHIpXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAoJ0Fzc2VydGlvbiBmYWlsZWQ6ICcgKyBsICsgJyAhPSAnICsgcikpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gZXhwb3J0cztcblxuZnVuY3Rpb24gdG9BcnJheShtc2csIGVuYykge1xuICBpZiAoQXJyYXkuaXNBcnJheShtc2cpKVxuICAgIHJldHVybiBtc2cuc2xpY2UoKTtcbiAgaWYgKCFtc2cpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgcmVzID0gW107XG4gIGlmICh0eXBlb2YgbXNnICE9PSAnc3RyaW5nJykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgICAgcmVzW2ldID0gbXNnW2ldIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmIChlbmMgPT09ICdoZXgnKSB7XG4gICAgbXNnID0gbXNnLnJlcGxhY2UoL1teYS16MC05XSsvaWcsICcnKTtcbiAgICBpZiAobXNnLmxlbmd0aCAlIDIgIT09IDApXG4gICAgICBtc2cgPSAnMCcgKyBtc2c7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IDIpXG4gICAgICByZXMucHVzaChwYXJzZUludChtc2dbaV0gKyBtc2dbaSArIDFdLCAxNikpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgdmFyIGhpID0gYyA+PiA4O1xuICAgICAgdmFyIGxvID0gYyAmIDB4ZmY7XG4gICAgICBpZiAoaGkpXG4gICAgICAgIHJlcy5wdXNoKGhpLCBsbyk7XG4gICAgICBlbHNlXG4gICAgICAgIHJlcy5wdXNoKGxvKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnRvQXJyYXkgPSB0b0FycmF5O1xuXG5mdW5jdGlvbiB6ZXJvMih3b3JkKSB7XG4gIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gJzAnICsgd29yZDtcbiAgZWxzZVxuICAgIHJldHVybiB3b3JkO1xufVxudXRpbHMuemVybzIgPSB6ZXJvMjtcblxuZnVuY3Rpb24gdG9IZXgobXNnKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgcmVzICs9IHplcm8yKG1zZ1tpXS50b1N0cmluZygxNikpO1xuICByZXR1cm4gcmVzO1xufVxudXRpbHMudG9IZXggPSB0b0hleDtcblxudXRpbHMuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGFyciwgZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB0b0hleChhcnIpO1xuICBlbHNlXG4gICAgcmV0dXJuIGFycjtcbn07XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBSZWZsZWN0QXBwbHkodGhpcy5saXN0ZW5lciwgdGhpcy50YXJnZXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiIsInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuIiwiLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9zZWxmLXNpZ25lZC9ibG9iL2doLXBhZ2VzL2xpYi9hc24xLmpzXG4vLyBGZWRvciwgeW91IGFyZSBhbWF6aW5nLlxuJ3VzZSBzdHJpY3QnXG5cbnZhciBhc24xID0gcmVxdWlyZSgnYXNuMS5qcycpXG5cbmV4cG9ydHMuY2VydGlmaWNhdGUgPSByZXF1aXJlKCcuL2NlcnRpZmljYXRlJylcblxudmFyIFJTQVByaXZhdGVLZXkgPSBhc24xLmRlZmluZSgnUlNBUHJpdmF0ZUtleScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ3ZlcnNpb24nKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnbW9kdWx1cycpLmludCgpLFxuICAgIHRoaXMua2V5KCdwdWJsaWNFeHBvbmVudCcpLmludCgpLFxuICAgIHRoaXMua2V5KCdwcml2YXRlRXhwb25lbnQnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgncHJpbWUxJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3ByaW1lMicpLmludCgpLFxuICAgIHRoaXMua2V5KCdleHBvbmVudDEnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnZXhwb25lbnQyJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ2NvZWZmaWNpZW50JykuaW50KClcbiAgKVxufSlcbmV4cG9ydHMuUlNBUHJpdmF0ZUtleSA9IFJTQVByaXZhdGVLZXlcblxudmFyIFJTQVB1YmxpY0tleSA9IGFzbjEuZGVmaW5lKCdSU0FQdWJsaWNLZXknLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdtb2R1bHVzJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3B1YmxpY0V4cG9uZW50JykuaW50KClcbiAgKVxufSlcbmV4cG9ydHMuUlNBUHVibGljS2V5ID0gUlNBUHVibGljS2V5XG5cbnZhciBQdWJsaWNLZXkgPSBhc24xLmRlZmluZSgnU3ViamVjdFB1YmxpY0tleUluZm8nLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdhbGdvcml0aG0nKS51c2UoQWxnb3JpdGhtSWRlbnRpZmllciksXG4gICAgdGhpcy5rZXkoJ3N1YmplY3RQdWJsaWNLZXknKS5iaXRzdHIoKVxuICApXG59KVxuZXhwb3J0cy5QdWJsaWNLZXkgPSBQdWJsaWNLZXlcblxudmFyIEFsZ29yaXRobUlkZW50aWZpZXIgPSBhc24xLmRlZmluZSgnQWxnb3JpdGhtSWRlbnRpZmllcicsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXEoKS5vYmooXG4gICAgdGhpcy5rZXkoJ2FsZ29yaXRobScpLm9iamlkKCksXG4gICAgdGhpcy5rZXkoJ25vbmUnKS5udWxsXygpLm9wdGlvbmFsKCksXG4gICAgdGhpcy5rZXkoJ2N1cnZlJykub2JqaWQoKS5vcHRpb25hbCgpLFxuICAgIHRoaXMua2V5KCdwYXJhbXMnKS5zZXEoKS5vYmooXG4gICAgICB0aGlzLmtleSgncCcpLmludCgpLFxuICAgICAgdGhpcy5rZXkoJ3EnKS5pbnQoKSxcbiAgICAgIHRoaXMua2V5KCdnJykuaW50KClcbiAgICApLm9wdGlvbmFsKClcbiAgKVxufSlcblxudmFyIFByaXZhdGVLZXlJbmZvID0gYXNuMS5kZWZpbmUoJ1ByaXZhdGVLZXlJbmZvJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgndmVyc2lvbicpLmludCgpLFxuICAgIHRoaXMua2V5KCdhbGdvcml0aG0nKS51c2UoQWxnb3JpdGhtSWRlbnRpZmllciksXG4gICAgdGhpcy5rZXkoJ3N1YmplY3RQcml2YXRlS2V5Jykub2N0c3RyKClcbiAgKVxufSlcbmV4cG9ydHMuUHJpdmF0ZUtleSA9IFByaXZhdGVLZXlJbmZvXG52YXIgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8gPSBhc24xLmRlZmluZSgnRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8nLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdhbGdvcml0aG0nKS5zZXEoKS5vYmooXG4gICAgICB0aGlzLmtleSgnaWQnKS5vYmppZCgpLFxuICAgICAgdGhpcy5rZXkoJ2RlY3J5cHQnKS5zZXEoKS5vYmooXG4gICAgICAgIHRoaXMua2V5KCdrZGUnKS5zZXEoKS5vYmooXG4gICAgICAgICAgdGhpcy5rZXkoJ2lkJykub2JqaWQoKSxcbiAgICAgICAgICB0aGlzLmtleSgna2RlcGFyYW1zJykuc2VxKCkub2JqKFxuICAgICAgICAgICAgdGhpcy5rZXkoJ3NhbHQnKS5vY3RzdHIoKSxcbiAgICAgICAgICAgIHRoaXMua2V5KCdpdGVycycpLmludCgpXG4gICAgICAgICAgKVxuICAgICAgICApLFxuICAgICAgICB0aGlzLmtleSgnY2lwaGVyJykuc2VxKCkub2JqKFxuICAgICAgICAgIHRoaXMua2V5KCdhbGdvJykub2JqaWQoKSxcbiAgICAgICAgICB0aGlzLmtleSgnaXYnKS5vY3RzdHIoKVxuICAgICAgICApXG4gICAgICApXG4gICAgKSxcbiAgICB0aGlzLmtleSgnc3ViamVjdFByaXZhdGVLZXknKS5vY3RzdHIoKVxuICApXG59KVxuXG5leHBvcnRzLkVuY3J5cHRlZFByaXZhdGVLZXkgPSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mb1xuXG52YXIgRFNBUHJpdmF0ZUtleSA9IGFzbjEuZGVmaW5lKCdEU0FQcml2YXRlS2V5JywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgndmVyc2lvbicpLmludCgpLFxuICAgIHRoaXMua2V5KCdwJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3EnKS5pbnQoKSxcbiAgICB0aGlzLmtleSgnZycpLmludCgpLFxuICAgIHRoaXMua2V5KCdwdWJfa2V5JykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3ByaXZfa2V5JykuaW50KClcbiAgKVxufSlcbmV4cG9ydHMuRFNBUHJpdmF0ZUtleSA9IERTQVByaXZhdGVLZXlcblxuZXhwb3J0cy5EU0FwYXJhbSA9IGFzbjEuZGVmaW5lKCdEU0FwYXJhbScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5pbnQoKVxufSlcblxudmFyIEVDUHJpdmF0ZUtleSA9IGFzbjEuZGVmaW5lKCdFQ1ByaXZhdGVLZXknLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd2ZXJzaW9uJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3ByaXZhdGVLZXknKS5vY3RzdHIoKSxcbiAgICB0aGlzLmtleSgncGFyYW1ldGVycycpLm9wdGlvbmFsKCkuZXhwbGljaXQoMCkudXNlKEVDUGFyYW1ldGVycyksXG4gICAgdGhpcy5rZXkoJ3B1YmxpY0tleScpLm9wdGlvbmFsKCkuZXhwbGljaXQoMSkuYml0c3RyKClcbiAgKVxufSlcbmV4cG9ydHMuRUNQcml2YXRlS2V5ID0gRUNQcml2YXRlS2V5XG5cbnZhciBFQ1BhcmFtZXRlcnMgPSBhc24xLmRlZmluZSgnRUNQYXJhbWV0ZXJzJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLmNob2ljZSh7XG4gICAgbmFtZWRDdXJ2ZTogdGhpcy5vYmppZCgpXG4gIH0pXG59KVxuXG5leHBvcnRzLnNpZ25hdHVyZSA9IGFzbjEuZGVmaW5lKCdzaWduYXR1cmUnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdyJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3MnKS5pbnQoKVxuICApXG59KVxuIiwiLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vUmFudGFuZW4vbm9kZS1kdGxzL2Jsb2IvMjVhN2RjODYxYmRhMzhjZmVhYzkzYTcyMzUwMGVlYTRmMGFjMmU4Ni9DZXJ0aWZpY2F0ZS5qc1xuLy8gdGhhbmtzIHRvIEBSYW50YW5lblxuXG4ndXNlIHN0cmljdCdcblxudmFyIGFzbiA9IHJlcXVpcmUoJ2FzbjEuanMnKVxuXG52YXIgVGltZSA9IGFzbi5kZWZpbmUoJ1RpbWUnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2hvaWNlKHtcbiAgICB1dGNUaW1lOiB0aGlzLnV0Y3RpbWUoKSxcbiAgICBnZW5lcmFsVGltZTogdGhpcy5nZW50aW1lKClcbiAgfSlcbn0pXG5cbnZhciBBdHRyaWJ1dGVUeXBlVmFsdWUgPSBhc24uZGVmaW5lKCdBdHRyaWJ1dGVUeXBlVmFsdWUnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd0eXBlJykub2JqaWQoKSxcbiAgICB0aGlzLmtleSgndmFsdWUnKS5hbnkoKVxuICApXG59KVxuXG52YXIgQWxnb3JpdGhtSWRlbnRpZmllciA9IGFzbi5kZWZpbmUoJ0FsZ29yaXRobUlkZW50aWZpZXInLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdhbGdvcml0aG0nKS5vYmppZCgpLFxuICAgIHRoaXMua2V5KCdwYXJhbWV0ZXJzJykub3B0aW9uYWwoKSxcbiAgICB0aGlzLmtleSgnY3VydmUnKS5vYmppZCgpLm9wdGlvbmFsKClcbiAgKVxufSlcblxudmFyIFN1YmplY3RQdWJsaWNLZXlJbmZvID0gYXNuLmRlZmluZSgnU3ViamVjdFB1YmxpY0tleUluZm8nLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCdhbGdvcml0aG0nKS51c2UoQWxnb3JpdGhtSWRlbnRpZmllciksXG4gICAgdGhpcy5rZXkoJ3N1YmplY3RQdWJsaWNLZXknKS5iaXRzdHIoKVxuICApXG59KVxuXG52YXIgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZSA9IGFzbi5kZWZpbmUoJ1JlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWUnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2V0b2YoQXR0cmlidXRlVHlwZVZhbHVlKVxufSlcblxudmFyIFJETlNlcXVlbmNlID0gYXNuLmRlZmluZSgnUkROU2VxdWVuY2UnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2Vxb2YoUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZSlcbn0pXG5cbnZhciBOYW1lID0gYXNuLmRlZmluZSgnTmFtZScsIGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jaG9pY2Uoe1xuICAgIHJkblNlcXVlbmNlOiB0aGlzLnVzZShSRE5TZXF1ZW5jZSlcbiAgfSlcbn0pXG5cbnZhciBWYWxpZGl0eSA9IGFzbi5kZWZpbmUoJ1ZhbGlkaXR5JywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgnbm90QmVmb3JlJykudXNlKFRpbWUpLFxuICAgIHRoaXMua2V5KCdub3RBZnRlcicpLnVzZShUaW1lKVxuICApXG59KVxuXG52YXIgRXh0ZW5zaW9uID0gYXNuLmRlZmluZSgnRXh0ZW5zaW9uJywgZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlcSgpLm9iaihcbiAgICB0aGlzLmtleSgnZXh0bklEJykub2JqaWQoKSxcbiAgICB0aGlzLmtleSgnY3JpdGljYWwnKS5ib29sKCkuZGVmKGZhbHNlKSxcbiAgICB0aGlzLmtleSgnZXh0blZhbHVlJykub2N0c3RyKClcbiAgKVxufSlcblxudmFyIFRCU0NlcnRpZmljYXRlID0gYXNuLmRlZmluZSgnVEJTQ2VydGlmaWNhdGUnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd2ZXJzaW9uJykuZXhwbGljaXQoMCkuaW50KCkub3B0aW9uYWwoKSxcbiAgICB0aGlzLmtleSgnc2VyaWFsTnVtYmVyJykuaW50KCksXG4gICAgdGhpcy5rZXkoJ3NpZ25hdHVyZScpLnVzZShBbGdvcml0aG1JZGVudGlmaWVyKSxcbiAgICB0aGlzLmtleSgnaXNzdWVyJykudXNlKE5hbWUpLFxuICAgIHRoaXMua2V5KCd2YWxpZGl0eScpLnVzZShWYWxpZGl0eSksXG4gICAgdGhpcy5rZXkoJ3N1YmplY3QnKS51c2UoTmFtZSksXG4gICAgdGhpcy5rZXkoJ3N1YmplY3RQdWJsaWNLZXlJbmZvJykudXNlKFN1YmplY3RQdWJsaWNLZXlJbmZvKSxcbiAgICB0aGlzLmtleSgnaXNzdWVyVW5pcXVlSUQnKS5pbXBsaWNpdCgxKS5iaXRzdHIoKS5vcHRpb25hbCgpLFxuICAgIHRoaXMua2V5KCdzdWJqZWN0VW5pcXVlSUQnKS5pbXBsaWNpdCgyKS5iaXRzdHIoKS5vcHRpb25hbCgpLFxuICAgIHRoaXMua2V5KCdleHRlbnNpb25zJykuZXhwbGljaXQoMykuc2Vxb2YoRXh0ZW5zaW9uKS5vcHRpb25hbCgpXG4gIClcbn0pXG5cbnZhciBYNTA5Q2VydGlmaWNhdGUgPSBhc24uZGVmaW5lKCdYNTA5Q2VydGlmaWNhdGUnLCBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VxKCkub2JqKFxuICAgIHRoaXMua2V5KCd0YnNDZXJ0aWZpY2F0ZScpLnVzZShUQlNDZXJ0aWZpY2F0ZSksXG4gICAgdGhpcy5rZXkoJ3NpZ25hdHVyZUFsZ29yaXRobScpLnVzZShBbGdvcml0aG1JZGVudGlmaWVyKSxcbiAgICB0aGlzLmtleSgnc2lnbmF0dXJlVmFsdWUnKS5iaXRzdHIoKVxuICApXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IFg1MDlDZXJ0aWZpY2F0ZVxuIiwiLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hcGF0aWwvcGVtc3RyaXBcbnZhciBmaW5kUHJvYyA9IC9Qcm9jLVR5cGU6IDQsRU5DUllQVEVEW1xcblxccl0rREVLLUluZm86IEFFUy0oKD86MTI4KXwoPzoxOTIpfCg/OjI1NikpLUNCQywoWzAtOUEtSF0rKVtcXG5cXHJdKyhbMC05QS16XFxuXFxyXFwrXFwvXFw9XSspW1xcblxccl0rL21cbnZhciBzdGFydFJlZ2V4ID0gL14tLS0tLUJFR0lOICgoPzouKj8gS0VZKXxDRVJUSUZJQ0FURSktLS0tLS9tXG52YXIgZnVsbFJlZ2V4ID0gL14tLS0tLUJFR0lOICgoPzouKj8gS0VZKXxDRVJUSUZJQ0FURSktLS0tLShbMC05QS16XFxuXFxyXFwrXFwvXFw9XSspLS0tLS1FTkQgXFwxLS0tLS0kL21cbnZhciBldnAgPSByZXF1aXJlKCdldnBfYnl0ZXN0b2tleScpXG52YXIgY2lwaGVycyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktYWVzJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2tleSwgcGFzc3dvcmQpIHtcbiAgdmFyIGtleSA9IG9rZXkudG9TdHJpbmcoKVxuICB2YXIgbWF0Y2ggPSBrZXkubWF0Y2goZmluZFByb2MpXG4gIHZhciBkZWNyeXB0ZWRcbiAgaWYgKCFtYXRjaCkge1xuICAgIHZhciBtYXRjaDIgPSBrZXkubWF0Y2goZnVsbFJlZ2V4KVxuICAgIGRlY3J5cHRlZCA9IG5ldyBCdWZmZXIobWF0Y2gyWzJdLnJlcGxhY2UoL1tcXHJcXG5dL2csICcnKSwgJ2Jhc2U2NCcpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHN1aXRlID0gJ2FlcycgKyBtYXRjaFsxXVxuICAgIHZhciBpdiA9IEJ1ZmZlci5mcm9tKG1hdGNoWzJdLCAnaGV4JylcbiAgICB2YXIgY2lwaGVyVGV4dCA9IEJ1ZmZlci5mcm9tKG1hdGNoWzNdLnJlcGxhY2UoL1tcXHJcXG5dL2csICcnKSwgJ2Jhc2U2NCcpXG4gICAgdmFyIGNpcGhlcktleSA9IGV2cChwYXNzd29yZCwgaXYuc2xpY2UoMCwgOCksIHBhcnNlSW50KG1hdGNoWzFdLCAxMCkpLmtleVxuICAgIHZhciBvdXQgPSBbXVxuICAgIHZhciBjaXBoZXIgPSBjaXBoZXJzLmNyZWF0ZURlY2lwaGVyaXYoc3VpdGUsIGNpcGhlcktleSwgaXYpXG4gICAgb3V0LnB1c2goY2lwaGVyLnVwZGF0ZShjaXBoZXJUZXh0KSlcbiAgICBvdXQucHVzaChjaXBoZXIuZmluYWwoKSlcbiAgICBkZWNyeXB0ZWQgPSBCdWZmZXIuY29uY2F0KG91dClcbiAgfVxuICB2YXIgdGFnID0ga2V5Lm1hdGNoKHN0YXJ0UmVnZXgpWzFdXG4gIHJldHVybiB7XG4gICAgdGFnOiB0YWcsXG4gICAgZGF0YTogZGVjcnlwdGVkXG4gIH1cbn1cbiIsInZhciBhc24xID0gcmVxdWlyZSgnLi9hc24xJylcbnZhciBhZXNpZCA9IHJlcXVpcmUoJy4vYWVzaWQuanNvbicpXG52YXIgZml4UHJvYyA9IHJlcXVpcmUoJy4vZml4UHJvYycpXG52YXIgY2lwaGVycyA9IHJlcXVpcmUoJ2Jyb3dzZXJpZnktYWVzJylcbnZhciBjb21wYXQgPSByZXF1aXJlKCdwYmtkZjInKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlS2V5c1xuXG5mdW5jdGlvbiBwYXJzZUtleXMgKGJ1ZmZlcikge1xuICB2YXIgcGFzc3dvcmRcbiAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdvYmplY3QnICYmICFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgIHBhc3N3b3JkID0gYnVmZmVyLnBhc3NwaHJhc2VcbiAgICBidWZmZXIgPSBidWZmZXIua2V5XG4gIH1cbiAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmZmVyID0gQnVmZmVyLmZyb20oYnVmZmVyKVxuICB9XG5cbiAgdmFyIHN0cmlwcGVkID0gZml4UHJvYyhidWZmZXIsIHBhc3N3b3JkKVxuXG4gIHZhciB0eXBlID0gc3RyaXBwZWQudGFnXG4gIHZhciBkYXRhID0gc3RyaXBwZWQuZGF0YVxuICB2YXIgc3VidHlwZSwgbmRhdGFcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnQ0VSVElGSUNBVEUnOlxuICAgICAgbmRhdGEgPSBhc24xLmNlcnRpZmljYXRlLmRlY29kZShkYXRhLCAnZGVyJykudGJzQ2VydGlmaWNhdGUuc3ViamVjdFB1YmxpY0tleUluZm9cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICBjYXNlICdQVUJMSUMgS0VZJzpcbiAgICAgIGlmICghbmRhdGEpIHtcbiAgICAgICAgbmRhdGEgPSBhc24xLlB1YmxpY0tleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgICB9XG4gICAgICBzdWJ0eXBlID0gbmRhdGEuYWxnb3JpdGhtLmFsZ29yaXRobS5qb2luKCcuJylcbiAgICAgIHN3aXRjaCAoc3VidHlwZSkge1xuICAgICAgICBjYXNlICcxLjIuODQwLjExMzU0OS4xLjEuMSc6XG4gICAgICAgICAgcmV0dXJuIGFzbjEuUlNBUHVibGljS2V5LmRlY29kZShuZGF0YS5zdWJqZWN0UHVibGljS2V5LmRhdGEsICdkZXInKVxuICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQ1LjIuMSc6XG4gICAgICAgICAgbmRhdGEuc3ViamVjdFByaXZhdGVLZXkgPSBuZGF0YS5zdWJqZWN0UHVibGljS2V5XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdlYycsXG4gICAgICAgICAgICBkYXRhOiBuZGF0YVxuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnMS4yLjg0MC4xMDA0MC40LjEnOlxuICAgICAgICAgIG5kYXRhLmFsZ29yaXRobS5wYXJhbXMucHViX2tleSA9IGFzbjEuRFNBcGFyYW0uZGVjb2RlKG5kYXRhLnN1YmplY3RQdWJsaWNLZXkuZGF0YSwgJ2RlcicpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdkc2EnLFxuICAgICAgICAgICAgZGF0YTogbmRhdGEuYWxnb3JpdGhtLnBhcmFtc1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleSBpZCAnICsgc3VidHlwZSlcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgdHlwZSAnICsgdHlwZSlcbiAgICBjYXNlICdFTkNSWVBURUQgUFJJVkFURSBLRVknOlxuICAgICAgZGF0YSA9IGFzbjEuRW5jcnlwdGVkUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgICBkYXRhID0gZGVjcnlwdChkYXRhLCBwYXNzd29yZClcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICBjYXNlICdQUklWQVRFIEtFWSc6XG4gICAgICBuZGF0YSA9IGFzbjEuUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgICBzdWJ0eXBlID0gbmRhdGEuYWxnb3JpdGhtLmFsZ29yaXRobS5qb2luKCcuJylcbiAgICAgIHN3aXRjaCAoc3VidHlwZSkge1xuICAgICAgICBjYXNlICcxLjIuODQwLjExMzU0OS4xLjEuMSc6XG4gICAgICAgICAgcmV0dXJuIGFzbjEuUlNBUHJpdmF0ZUtleS5kZWNvZGUobmRhdGEuc3ViamVjdFByaXZhdGVLZXksICdkZXInKVxuICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQ1LjIuMSc6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnZlOiBuZGF0YS5hbGdvcml0aG0uY3VydmUsXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBhc24xLkVDUHJpdmF0ZUtleS5kZWNvZGUobmRhdGEuc3ViamVjdFByaXZhdGVLZXksICdkZXInKS5wcml2YXRlS2V5XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICcxLjIuODQwLjEwMDQwLjQuMSc6XG4gICAgICAgICAgbmRhdGEuYWxnb3JpdGhtLnBhcmFtcy5wcml2X2tleSA9IGFzbjEuRFNBcGFyYW0uZGVjb2RlKG5kYXRhLnN1YmplY3RQcml2YXRlS2V5LCAnZGVyJylcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2RzYScsXG4gICAgICAgICAgICBwYXJhbXM6IG5kYXRhLmFsZ29yaXRobS5wYXJhbXNcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgaWQgJyArIHN1YnR5cGUpXG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IHR5cGUgJyArIHR5cGUpXG4gICAgY2FzZSAnUlNBIFBVQkxJQyBLRVknOlxuICAgICAgcmV0dXJuIGFzbjEuUlNBUHVibGljS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICBjYXNlICdSU0EgUFJJVkFURSBLRVknOlxuICAgICAgcmV0dXJuIGFzbjEuUlNBUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgY2FzZSAnRFNBIFBSSVZBVEUgS0VZJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdkc2EnLFxuICAgICAgICBwYXJhbXM6IGFzbjEuRFNBUHJpdmF0ZUtleS5kZWNvZGUoZGF0YSwgJ2RlcicpXG4gICAgICB9XG4gICAgY2FzZSAnRUMgUFJJVkFURSBLRVknOlxuICAgICAgZGF0YSA9IGFzbjEuRUNQcml2YXRlS2V5LmRlY29kZShkYXRhLCAnZGVyJylcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGN1cnZlOiBkYXRhLnBhcmFtZXRlcnMudmFsdWUsXG4gICAgICAgIHByaXZhdGVLZXk6IGRhdGEucHJpdmF0ZUtleVxuICAgICAgfVxuICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgdHlwZSAnICsgdHlwZSlcbiAgfVxufVxucGFyc2VLZXlzLnNpZ25hdHVyZSA9IGFzbjEuc2lnbmF0dXJlXG5mdW5jdGlvbiBkZWNyeXB0IChkYXRhLCBwYXNzd29yZCkge1xuICB2YXIgc2FsdCA9IGRhdGEuYWxnb3JpdGhtLmRlY3J5cHQua2RlLmtkZXBhcmFtcy5zYWx0XG4gIHZhciBpdGVycyA9IHBhcnNlSW50KGRhdGEuYWxnb3JpdGhtLmRlY3J5cHQua2RlLmtkZXBhcmFtcy5pdGVycy50b1N0cmluZygpLCAxMClcbiAgdmFyIGFsZ28gPSBhZXNpZFtkYXRhLmFsZ29yaXRobS5kZWNyeXB0LmNpcGhlci5hbGdvLmpvaW4oJy4nKV1cbiAgdmFyIGl2ID0gZGF0YS5hbGdvcml0aG0uZGVjcnlwdC5jaXBoZXIuaXZcbiAgdmFyIGNpcGhlclRleHQgPSBkYXRhLnN1YmplY3RQcml2YXRlS2V5XG4gIHZhciBrZXlsZW4gPSBwYXJzZUludChhbGdvLnNwbGl0KCctJylbMV0sIDEwKSAvIDhcbiAgdmFyIGtleSA9IGNvbXBhdC5wYmtkZjJTeW5jKHBhc3N3b3JkLCBzYWx0LCBpdGVycywga2V5bGVuLCAnc2hhMScpXG4gIHZhciBjaXBoZXIgPSBjaXBoZXJzLmNyZWF0ZURlY2lwaGVyaXYoYWxnbywga2V5LCBpdilcbiAgdmFyIG91dCA9IFtdXG4gIG91dC5wdXNoKGNpcGhlci51cGRhdGUoY2lwaGVyVGV4dCkpXG4gIG91dC5wdXNoKGNpcGhlci5maW5hbCgpKVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChvdXQpXG59XG4iLCJleHBvcnRzLnBia2RmMiA9IHJlcXVpcmUoJy4vbGliL2FzeW5jJylcbmV4cG9ydHMucGJrZGYyU3luYyA9IHJlcXVpcmUoJy4vbGliL3N5bmMnKVxuIiwidmFyIGNoZWNrUGFyYW1ldGVycyA9IHJlcXVpcmUoJy4vcHJlY29uZGl0aW9uJylcbnZhciBkZWZhdWx0RW5jb2RpbmcgPSByZXF1aXJlKCcuL2RlZmF1bHQtZW5jb2RpbmcnKVxudmFyIHN5bmMgPSByZXF1aXJlKCcuL3N5bmMnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBaRVJPX0JVRlxudmFyIHN1YnRsZSA9IGdsb2JhbC5jcnlwdG8gJiYgZ2xvYmFsLmNyeXB0by5zdWJ0bGVcbnZhciB0b0Jyb3dzZXIgPSB7XG4gICdzaGEnOiAnU0hBLTEnLFxuICAnc2hhLTEnOiAnU0hBLTEnLFxuICAnc2hhMSc6ICdTSEEtMScsXG4gICdzaGEyNTYnOiAnU0hBLTI1NicsXG4gICdzaGEtMjU2JzogJ1NIQS0yNTYnLFxuICAnc2hhMzg0JzogJ1NIQS0zODQnLFxuICAnc2hhLTM4NCc6ICdTSEEtMzg0JyxcbiAgJ3NoYS01MTInOiAnU0hBLTUxMicsXG4gICdzaGE1MTInOiAnU0hBLTUxMidcbn1cbnZhciBjaGVja3MgPSBbXVxuZnVuY3Rpb24gY2hlY2tOYXRpdmUgKGFsZ28pIHtcbiAgaWYgKGdsb2JhbC5wcm9jZXNzICYmICFnbG9iYWwucHJvY2Vzcy5icm93c2VyKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSlcbiAgfVxuICBpZiAoIXN1YnRsZSB8fCAhc3VidGxlLmltcG9ydEtleSB8fCAhc3VidGxlLmRlcml2ZUJpdHMpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKVxuICB9XG4gIGlmIChjaGVja3NbYWxnb10gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjaGVja3NbYWxnb11cbiAgfVxuICBaRVJPX0JVRiA9IFpFUk9fQlVGIHx8IEJ1ZmZlci5hbGxvYyg4KVxuICB2YXIgcHJvbSA9IGJyb3dzZXJQYmtkZjIoWkVST19CVUYsIFpFUk9fQlVGLCAxMCwgMTI4LCBhbGdvKVxuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSlcbiAgY2hlY2tzW2FsZ29dID0gcHJvbVxuICByZXR1cm4gcHJvbVxufVxuXG5mdW5jdGlvbiBicm93c2VyUGJrZGYyIChwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywgbGVuZ3RoLCBhbGdvKSB7XG4gIHJldHVybiBzdWJ0bGUuaW1wb3J0S2V5KFxuICAgICdyYXcnLCBwYXNzd29yZCwge25hbWU6ICdQQktERjInfSwgZmFsc2UsIFsnZGVyaXZlQml0cyddXG4gICkudGhlbihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHN1YnRsZS5kZXJpdmVCaXRzKHtcbiAgICAgIG5hbWU6ICdQQktERjInLFxuICAgICAgc2FsdDogc2FsdCxcbiAgICAgIGl0ZXJhdGlvbnM6IGl0ZXJhdGlvbnMsXG4gICAgICBoYXNoOiB7XG4gICAgICAgIG5hbWU6IGFsZ29cbiAgICAgIH1cbiAgICB9LCBrZXksIGxlbmd0aCA8PCAzKVxuICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20ocmVzKVxuICB9KVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUHJvbWlzZSAocHJvbWlzZSwgY2FsbGJhY2spIHtcbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChvdXQpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIG91dClcbiAgICB9KVxuICB9LCBmdW5jdGlvbiAoZSkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2soZSlcbiAgICB9KVxuICB9KVxufVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRpZ2VzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gZGlnZXN0XG4gICAgZGlnZXN0ID0gdW5kZWZpbmVkXG4gIH1cblxuICBkaWdlc3QgPSBkaWdlc3QgfHwgJ3NoYTEnXG4gIHZhciBhbGdvID0gdG9Ccm93c2VyW2RpZ2VzdC50b0xvd2VyQ2FzZSgpXVxuXG4gIGlmICghYWxnbyB8fCB0eXBlb2YgZ2xvYmFsLlByb21pc2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb3V0XG4gICAgICB0cnkge1xuICAgICAgICBvdXQgPSBzeW5jKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGRpZ2VzdClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpXG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBvdXQpXG4gICAgfSlcbiAgfVxuXG4gIGNoZWNrUGFyYW1ldGVycyhwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuKVxuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGNhbGxiYWNrIHByb3ZpZGVkIHRvIHBia2RmMicpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHBhc3N3b3JkKSkgcGFzc3dvcmQgPSBCdWZmZXIuZnJvbShwYXNzd29yZCwgZGVmYXVsdEVuY29kaW5nKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihzYWx0KSkgc2FsdCA9IEJ1ZmZlci5mcm9tKHNhbHQsIGRlZmF1bHRFbmNvZGluZylcblxuICByZXNvbHZlUHJvbWlzZShjaGVja05hdGl2ZShhbGdvKS50aGVuKGZ1bmN0aW9uIChyZXNwKSB7XG4gICAgaWYgKHJlc3ApIHJldHVybiBicm93c2VyUGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGFsZ28pXG5cbiAgICByZXR1cm4gc3luYyhwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBkaWdlc3QpXG4gIH0pLCBjYWxsYmFjaylcbn1cbiIsInZhciBkZWZhdWx0RW5jb2Rpbmdcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAocHJvY2Vzcy5icm93c2VyKSB7XG4gIGRlZmF1bHRFbmNvZGluZyA9ICd1dGYtOCdcbn0gZWxzZSB7XG4gIHZhciBwVmVyc2lvbk1ham9yID0gcGFyc2VJbnQocHJvY2Vzcy52ZXJzaW9uLnNwbGl0KCcuJylbMF0uc2xpY2UoMSksIDEwKVxuXG4gIGRlZmF1bHRFbmNvZGluZyA9IHBWZXJzaW9uTWFqb3IgPj0gNiA/ICd1dGYtOCcgOiAnYmluYXJ5J1xufVxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0RW5jb2RpbmdcbiIsInZhciBNQVhfQUxMT0MgPSBNYXRoLnBvdygyLCAzMCkgLSAxIC8vIGRlZmF1bHQgaW4gaW9qc1xuXG5mdW5jdGlvbiBjaGVja0J1ZmZlciAoYnVmLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgYnVmICE9PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG5hbWUgKyAnIG11c3QgYmUgYSBidWZmZXIgb3Igc3RyaW5nJylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuKSB7XG4gIGNoZWNrQnVmZmVyKHBhc3N3b3JkLCAnUGFzc3dvcmQnKVxuICBjaGVja0J1ZmZlcihzYWx0LCAnU2FsdCcpXG5cbiAgaWYgKHR5cGVvZiBpdGVyYXRpb25zICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0l0ZXJhdGlvbnMgbm90IGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChpdGVyYXRpb25zIDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JhZCBpdGVyYXRpb25zJylcbiAgfVxuXG4gIGlmICh0eXBlb2Yga2V5bGVuICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0tleSBsZW5ndGggbm90IGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmIChrZXlsZW4gPCAwIHx8IGtleWxlbiA+IE1BWF9BTExPQyB8fCBrZXlsZW4gIT09IGtleWxlbikgeyAvKiBlc2xpbnQgbm8tc2VsZi1jb21wYXJlOiAwICovXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQmFkIGtleSBsZW5ndGgnKVxuICB9XG59XG4iLCJ2YXIgbWQ1ID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gvbWQ1JylcbnZhciBSSVBFTUQxNjAgPSByZXF1aXJlKCdyaXBlbWQxNjAnKVxudmFyIHNoYSA9IHJlcXVpcmUoJ3NoYS5qcycpXG5cbnZhciBjaGVja1BhcmFtZXRlcnMgPSByZXF1aXJlKCcuL3ByZWNvbmRpdGlvbicpXG52YXIgZGVmYXVsdEVuY29kaW5nID0gcmVxdWlyZSgnLi9kZWZhdWx0LWVuY29kaW5nJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIFpFUk9TID0gQnVmZmVyLmFsbG9jKDEyOClcbnZhciBzaXplcyA9IHtcbiAgbWQ1OiAxNixcbiAgc2hhMTogMjAsXG4gIHNoYTIyNDogMjgsXG4gIHNoYTI1NjogMzIsXG4gIHNoYTM4NDogNDgsXG4gIHNoYTUxMjogNjQsXG4gIHJtZDE2MDogMjAsXG4gIHJpcGVtZDE2MDogMjBcbn1cblxuZnVuY3Rpb24gSG1hYyAoYWxnLCBrZXksIHNhbHRMZW4pIHtcbiAgdmFyIGhhc2ggPSBnZXREaWdlc3QoYWxnKVxuICB2YXIgYmxvY2tzaXplID0gKGFsZyA9PT0gJ3NoYTUxMicgfHwgYWxnID09PSAnc2hhMzg0JykgPyAxMjggOiA2NFxuXG4gIGlmIChrZXkubGVuZ3RoID4gYmxvY2tzaXplKSB7XG4gICAga2V5ID0gaGFzaChrZXkpXG4gIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA8IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwgWkVST1NdLCBibG9ja3NpemUpXG4gIH1cblxuICB2YXIgaXBhZCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShibG9ja3NpemUgKyBzaXplc1thbGddKVxuICB2YXIgb3BhZCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShibG9ja3NpemUgKyBzaXplc1thbGddKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2Nrc2l6ZTsgaSsrKSB7XG4gICAgaXBhZFtpXSA9IGtleVtpXSBeIDB4MzZcbiAgICBvcGFkW2ldID0ga2V5W2ldIF4gMHg1Q1xuICB9XG5cbiAgdmFyIGlwYWQxID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJsb2Nrc2l6ZSArIHNhbHRMZW4gKyA0KVxuICBpcGFkLmNvcHkoaXBhZDEsIDAsIDAsIGJsb2Nrc2l6ZSlcbiAgdGhpcy5pcGFkMSA9IGlwYWQxXG4gIHRoaXMuaXBhZDIgPSBpcGFkXG4gIHRoaXMub3BhZCA9IG9wYWRcbiAgdGhpcy5hbGcgPSBhbGdcbiAgdGhpcy5ibG9ja3NpemUgPSBibG9ja3NpemVcbiAgdGhpcy5oYXNoID0gaGFzaFxuICB0aGlzLnNpemUgPSBzaXplc1thbGddXG59XG5cbkhtYWMucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChkYXRhLCBpcGFkKSB7XG4gIGRhdGEuY29weShpcGFkLCB0aGlzLmJsb2Nrc2l6ZSlcbiAgdmFyIGggPSB0aGlzLmhhc2goaXBhZClcbiAgaC5jb3B5KHRoaXMub3BhZCwgdGhpcy5ibG9ja3NpemUpXG4gIHJldHVybiB0aGlzLmhhc2godGhpcy5vcGFkKVxufVxuXG5mdW5jdGlvbiBnZXREaWdlc3QgKGFsZykge1xuICBmdW5jdGlvbiBzaGFGdW5jIChkYXRhKSB7XG4gICAgcmV0dXJuIHNoYShhbGcpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKVxuICB9XG4gIGZ1bmN0aW9uIHJtZDE2MEZ1bmMgKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFJJUEVNRDE2MCgpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKVxuICB9XG5cbiAgaWYgKGFsZyA9PT0gJ3JtZDE2MCcgfHwgYWxnID09PSAncmlwZW1kMTYwJykgcmV0dXJuIHJtZDE2MEZ1bmNcbiAgaWYgKGFsZyA9PT0gJ21kNScpIHJldHVybiBtZDVcbiAgcmV0dXJuIHNoYUZ1bmNcbn1cblxuZnVuY3Rpb24gcGJrZGYyIChwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBkaWdlc3QpIHtcbiAgY2hlY2tQYXJhbWV0ZXJzKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4pXG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFzc3dvcmQpKSBwYXNzd29yZCA9IEJ1ZmZlci5mcm9tKHBhc3N3b3JkLCBkZWZhdWx0RW5jb2RpbmcpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHNhbHQpKSBzYWx0ID0gQnVmZmVyLmZyb20oc2FsdCwgZGVmYXVsdEVuY29kaW5nKVxuXG4gIGRpZ2VzdCA9IGRpZ2VzdCB8fCAnc2hhMSdcblxuICB2YXIgaG1hYyA9IG5ldyBIbWFjKGRpZ2VzdCwgcGFzc3dvcmQsIHNhbHQubGVuZ3RoKVxuXG4gIHZhciBESyA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShrZXlsZW4pXG4gIHZhciBibG9jazEgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc2FsdC5sZW5ndGggKyA0KVxuICBzYWx0LmNvcHkoYmxvY2sxLCAwLCAwLCBzYWx0Lmxlbmd0aClcblxuICB2YXIgZGVzdFBvcyA9IDBcbiAgdmFyIGhMZW4gPSBzaXplc1tkaWdlc3RdXG4gIHZhciBsID0gTWF0aC5jZWlsKGtleWxlbiAvIGhMZW4pXG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbDsgaSsrKSB7XG4gICAgYmxvY2sxLndyaXRlVUludDMyQkUoaSwgc2FsdC5sZW5ndGgpXG5cbiAgICB2YXIgVCA9IGhtYWMucnVuKGJsb2NrMSwgaG1hYy5pcGFkMSlcbiAgICB2YXIgVSA9IFRcblxuICAgIGZvciAodmFyIGogPSAxOyBqIDwgaXRlcmF0aW9uczsgaisrKSB7XG4gICAgICBVID0gaG1hYy5ydW4oVSwgaG1hYy5pcGFkMilcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaExlbjsgaysrKSBUW2tdIF49IFVba11cbiAgICB9XG5cbiAgICBULmNvcHkoREssIGRlc3RQb3MpXG4gICAgZGVzdFBvcyArPSBoTGVuXG4gIH1cblxuICByZXR1cm4gREtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYmtkZjJcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKCFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IG5leHRUaWNrOiBuZXh0VGljayB9O1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cblxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsImV4cG9ydHMucHVibGljRW5jcnlwdCA9IHJlcXVpcmUoJy4vcHVibGljRW5jcnlwdCcpXG5leHBvcnRzLnByaXZhdGVEZWNyeXB0ID0gcmVxdWlyZSgnLi9wcml2YXRlRGVjcnlwdCcpXG5cbmV4cG9ydHMucHJpdmF0ZUVuY3J5cHQgPSBmdW5jdGlvbiBwcml2YXRlRW5jcnlwdCAoa2V5LCBidWYpIHtcbiAgcmV0dXJuIGV4cG9ydHMucHVibGljRW5jcnlwdChrZXksIGJ1ZiwgdHJ1ZSlcbn1cblxuZXhwb3J0cy5wdWJsaWNEZWNyeXB0ID0gZnVuY3Rpb24gcHVibGljRGVjcnlwdCAoa2V5LCBidWYpIHtcbiAgcmV0dXJuIGV4cG9ydHMucHJpdmF0ZURlY3J5cHQoa2V5LCBidWYsIHRydWUpXG59XG4iLCJ2YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWVkLCBsZW4pIHtcbiAgdmFyIHQgPSBCdWZmZXIuYWxsb2MoMClcbiAgdmFyIGkgPSAwXG4gIHZhciBjXG4gIHdoaWxlICh0Lmxlbmd0aCA8IGxlbikge1xuICAgIGMgPSBpMm9wcyhpKyspXG4gICAgdCA9IEJ1ZmZlci5jb25jYXQoW3QsIGNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoc2VlZCkudXBkYXRlKGMpLmRpZ2VzdCgpXSlcbiAgfVxuICByZXR1cm4gdC5zbGljZSgwLCBsZW4pXG59XG5cbmZ1bmN0aW9uIGkyb3BzIChjKSB7XG4gIHZhciBvdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNClcbiAgb3V0LndyaXRlVUludDMyQkUoYywgMClcbiAgcmV0dXJuIG91dFxufVxuIiwidmFyIHBhcnNlS2V5cyA9IHJlcXVpcmUoJ3BhcnNlLWFzbjEnKVxudmFyIG1nZiA9IHJlcXVpcmUoJy4vbWdmJylcbnZhciB4b3IgPSByZXF1aXJlKCcuL3hvcicpXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG52YXIgY3J0ID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1yc2EnKVxudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpXG52YXIgd2l0aFB1YmxpYyA9IHJlcXVpcmUoJy4vd2l0aFB1YmxpYycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwcml2YXRlRGVjcnlwdCAocHJpdmF0ZUtleSwgZW5jLCByZXZlcnNlKSB7XG4gIHZhciBwYWRkaW5nXG4gIGlmIChwcml2YXRlS2V5LnBhZGRpbmcpIHtcbiAgICBwYWRkaW5nID0gcHJpdmF0ZUtleS5wYWRkaW5nXG4gIH0gZWxzZSBpZiAocmV2ZXJzZSkge1xuICAgIHBhZGRpbmcgPSAxXG4gIH0gZWxzZSB7XG4gICAgcGFkZGluZyA9IDRcbiAgfVxuXG4gIHZhciBrZXkgPSBwYXJzZUtleXMocHJpdmF0ZUtleSlcbiAgdmFyIGsgPSBrZXkubW9kdWx1cy5ieXRlTGVuZ3RoKClcbiAgaWYgKGVuYy5sZW5ndGggPiBrIHx8IG5ldyBCTihlbmMpLmNtcChrZXkubW9kdWx1cykgPj0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVjcnlwdGlvbiBlcnJvcicpXG4gIH1cbiAgdmFyIG1zZ1xuICBpZiAocmV2ZXJzZSkge1xuICAgIG1zZyA9IHdpdGhQdWJsaWMobmV3IEJOKGVuYyksIGtleSlcbiAgfSBlbHNlIHtcbiAgICBtc2cgPSBjcnQoZW5jLCBrZXkpXG4gIH1cbiAgdmFyIHpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoayAtIG1zZy5sZW5ndGgpXG4gIG1zZyA9IEJ1ZmZlci5jb25jYXQoW3pCdWZmZXIsIG1zZ10sIGspXG4gIGlmIChwYWRkaW5nID09PSA0KSB7XG4gICAgcmV0dXJuIG9hZXAoa2V5LCBtc2cpXG4gIH0gZWxzZSBpZiAocGFkZGluZyA9PT0gMSkge1xuICAgIHJldHVybiBwa2NzMShrZXksIG1zZywgcmV2ZXJzZSlcbiAgfSBlbHNlIGlmIChwYWRkaW5nID09PSAzKSB7XG4gICAgcmV0dXJuIG1zZ1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBwYWRkaW5nJylcbiAgfVxufVxuXG5mdW5jdGlvbiBvYWVwIChrZXksIG1zZykge1xuICB2YXIgayA9IGtleS5tb2R1bHVzLmJ5dGVMZW5ndGgoKVxuICB2YXIgaUhhc2ggPSBjcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKEJ1ZmZlci5hbGxvYygwKSkuZGlnZXN0KClcbiAgdmFyIGhMZW4gPSBpSGFzaC5sZW5ndGhcbiAgaWYgKG1zZ1swXSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVjcnlwdGlvbiBlcnJvcicpXG4gIH1cbiAgdmFyIG1hc2tlZFNlZWQgPSBtc2cuc2xpY2UoMSwgaExlbiArIDEpXG4gIHZhciBtYXNrZWREYiA9IG1zZy5zbGljZShoTGVuICsgMSlcbiAgdmFyIHNlZWQgPSB4b3IobWFza2VkU2VlZCwgbWdmKG1hc2tlZERiLCBoTGVuKSlcbiAgdmFyIGRiID0geG9yKG1hc2tlZERiLCBtZ2Yoc2VlZCwgayAtIGhMZW4gLSAxKSlcbiAgaWYgKGNvbXBhcmUoaUhhc2gsIGRiLnNsaWNlKDAsIGhMZW4pKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVjcnlwdGlvbiBlcnJvcicpXG4gIH1cbiAgdmFyIGkgPSBoTGVuXG4gIHdoaWxlIChkYltpXSA9PT0gMCkge1xuICAgIGkrK1xuICB9XG4gIGlmIChkYltpKytdICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZWNyeXB0aW9uIGVycm9yJylcbiAgfVxuICByZXR1cm4gZGIuc2xpY2UoaSlcbn1cblxuZnVuY3Rpb24gcGtjczEgKGtleSwgbXNnLCByZXZlcnNlKSB7XG4gIHZhciBwMSA9IG1zZy5zbGljZSgwLCAyKVxuICB2YXIgaSA9IDJcbiAgdmFyIHN0YXR1cyA9IDBcbiAgd2hpbGUgKG1zZ1tpKytdICE9PSAwKSB7XG4gICAgaWYgKGkgPj0gbXNnLmxlbmd0aCkge1xuICAgICAgc3RhdHVzKytcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHZhciBwcyA9IG1zZy5zbGljZSgyLCBpIC0gMSlcblxuICBpZiAoKHAxLnRvU3RyaW5nKCdoZXgnKSAhPT0gJzAwMDInICYmICFyZXZlcnNlKSB8fCAocDEudG9TdHJpbmcoJ2hleCcpICE9PSAnMDAwMScgJiYgcmV2ZXJzZSkpIHtcbiAgICBzdGF0dXMrK1xuICB9XG4gIGlmIChwcy5sZW5ndGggPCA4KSB7XG4gICAgc3RhdHVzKytcbiAgfVxuICBpZiAoc3RhdHVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZWNyeXB0aW9uIGVycm9yJylcbiAgfVxuICByZXR1cm4gbXNnLnNsaWNlKGkpXG59XG5mdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGEgPSBCdWZmZXIuZnJvbShhKVxuICBiID0gQnVmZmVyLmZyb20oYilcbiAgdmFyIGRpZiA9IDBcbiAgdmFyIGxlbiA9IGEubGVuZ3RoXG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICBkaWYrK1xuICAgIGxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aClcbiAgfVxuICB2YXIgaSA9IC0xXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBkaWYgKz0gKGFbaV0gXiBiW2ldKVxuICB9XG4gIHJldHVybiBkaWZcbn1cbiIsInZhciBwYXJzZUtleXMgPSByZXF1aXJlKCdwYXJzZS1hc24xJylcbnZhciByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJylcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKVxudmFyIG1nZiA9IHJlcXVpcmUoJy4vbWdmJylcbnZhciB4b3IgPSByZXF1aXJlKCcuL3hvcicpXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG52YXIgd2l0aFB1YmxpYyA9IHJlcXVpcmUoJy4vd2l0aFB1YmxpYycpXG52YXIgY3J0ID0gcmVxdWlyZSgnYnJvd3NlcmlmeS1yc2EnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHVibGljRW5jcnlwdCAocHVibGljS2V5LCBtc2csIHJldmVyc2UpIHtcbiAgdmFyIHBhZGRpbmdcbiAgaWYgKHB1YmxpY0tleS5wYWRkaW5nKSB7XG4gICAgcGFkZGluZyA9IHB1YmxpY0tleS5wYWRkaW5nXG4gIH0gZWxzZSBpZiAocmV2ZXJzZSkge1xuICAgIHBhZGRpbmcgPSAxXG4gIH0gZWxzZSB7XG4gICAgcGFkZGluZyA9IDRcbiAgfVxuICB2YXIga2V5ID0gcGFyc2VLZXlzKHB1YmxpY0tleSlcbiAgdmFyIHBhZGRlZE1zZ1xuICBpZiAocGFkZGluZyA9PT0gNCkge1xuICAgIHBhZGRlZE1zZyA9IG9hZXAoa2V5LCBtc2cpXG4gIH0gZWxzZSBpZiAocGFkZGluZyA9PT0gMSkge1xuICAgIHBhZGRlZE1zZyA9IHBrY3MxKGtleSwgbXNnLCByZXZlcnNlKVxuICB9IGVsc2UgaWYgKHBhZGRpbmcgPT09IDMpIHtcbiAgICBwYWRkZWRNc2cgPSBuZXcgQk4obXNnKVxuICAgIGlmIChwYWRkZWRNc2cuY21wKGtleS5tb2R1bHVzKSA+PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgdG9vIGxvbmcgZm9yIG1vZHVsdXMnKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gcGFkZGluZycpXG4gIH1cbiAgaWYgKHJldmVyc2UpIHtcbiAgICByZXR1cm4gY3J0KHBhZGRlZE1zZywga2V5KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB3aXRoUHVibGljKHBhZGRlZE1zZywga2V5KVxuICB9XG59XG5cbmZ1bmN0aW9uIG9hZXAgKGtleSwgbXNnKSB7XG4gIHZhciBrID0ga2V5Lm1vZHVsdXMuYnl0ZUxlbmd0aCgpXG4gIHZhciBtTGVuID0gbXNnLmxlbmd0aFxuICB2YXIgaUhhc2ggPSBjcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKEJ1ZmZlci5hbGxvYygwKSkuZGlnZXN0KClcbiAgdmFyIGhMZW4gPSBpSGFzaC5sZW5ndGhcbiAgdmFyIGhMZW4yID0gMiAqIGhMZW5cbiAgaWYgKG1MZW4gPiBrIC0gaExlbjIgLSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtZXNzYWdlIHRvbyBsb25nJylcbiAgfVxuICB2YXIgcHMgPSBCdWZmZXIuYWxsb2MoayAtIG1MZW4gLSBoTGVuMiAtIDIpXG4gIHZhciBkYmxlbiA9IGsgLSBoTGVuIC0gMVxuICB2YXIgc2VlZCA9IHJhbmRvbUJ5dGVzKGhMZW4pXG4gIHZhciBtYXNrZWREYiA9IHhvcihCdWZmZXIuY29uY2F0KFtpSGFzaCwgcHMsIEJ1ZmZlci5hbGxvYygxLCAxKSwgbXNnXSwgZGJsZW4pLCBtZ2Yoc2VlZCwgZGJsZW4pKVxuICB2YXIgbWFza2VkU2VlZCA9IHhvcihzZWVkLCBtZ2YobWFza2VkRGIsIGhMZW4pKVxuICByZXR1cm4gbmV3IEJOKEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5hbGxvYygxKSwgbWFza2VkU2VlZCwgbWFza2VkRGJdLCBrKSlcbn1cbmZ1bmN0aW9uIHBrY3MxIChrZXksIG1zZywgcmV2ZXJzZSkge1xuICB2YXIgbUxlbiA9IG1zZy5sZW5ndGhcbiAgdmFyIGsgPSBrZXkubW9kdWx1cy5ieXRlTGVuZ3RoKClcbiAgaWYgKG1MZW4gPiBrIC0gMTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21lc3NhZ2UgdG9vIGxvbmcnKVxuICB9XG4gIHZhciBwc1xuICBpZiAocmV2ZXJzZSkge1xuICAgIHBzID0gQnVmZmVyLmFsbG9jKGsgLSBtTGVuIC0gMywgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBwcyA9IG5vblplcm8oayAtIG1MZW4gLSAzKVxuICB9XG4gIHJldHVybiBuZXcgQk4oQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzAsIHJldmVyc2UgPyAxIDogMl0pLCBwcywgQnVmZmVyLmFsbG9jKDEpLCBtc2ddLCBrKSlcbn1cbmZ1bmN0aW9uIG5vblplcm8gKGxlbikge1xuICB2YXIgb3V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbilcbiAgdmFyIGkgPSAwXG4gIHZhciBjYWNoZSA9IHJhbmRvbUJ5dGVzKGxlbiAqIDIpXG4gIHZhciBjdXIgPSAwXG4gIHZhciBudW1cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBpZiAoY3VyID09PSBjYWNoZS5sZW5ndGgpIHtcbiAgICAgIGNhY2hlID0gcmFuZG9tQnl0ZXMobGVuICogMilcbiAgICAgIGN1ciA9IDBcbiAgICB9XG4gICAgbnVtID0gY2FjaGVbY3VyKytdXG4gICAgaWYgKG51bSkge1xuICAgICAgb3V0W2krK10gPSBudW1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dFxufVxuIiwidmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbmZ1bmN0aW9uIHdpdGhQdWJsaWMgKHBhZGRlZE1zZywga2V5KSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShwYWRkZWRNc2dcbiAgICAudG9SZWQoQk4ubW9udChrZXkubW9kdWx1cykpXG4gICAgLnJlZFBvdyhuZXcgQk4oa2V5LnB1YmxpY0V4cG9uZW50KSlcbiAgICAuZnJvbVJlZCgpXG4gICAgLnRvQXJyYXkoKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3aXRoUHVibGljXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhvciAoYSwgYikge1xuICB2YXIgbGVuID0gYS5sZW5ndGhcbiAgdmFyIGkgPSAtMVxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgYVtpXSBePSBiW2ldXG4gIH1cbiAgcmV0dXJuIGFcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBsaW1pdCBvZiBDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKClcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DcnlwdG8vZ2V0UmFuZG9tVmFsdWVzXG52YXIgTUFYX0JZVEVTID0gNjU1MzZcblxuLy8gTm9kZSBzdXBwb3J0cyByZXF1ZXN0aW5nIHVwIHRvIHRoaXMgbnVtYmVyIG9mIGJ5dGVzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9tYXN0ZXIvbGliL2ludGVybmFsL2NyeXB0by9yYW5kb20uanMjTDQ4XG52YXIgTUFYX1VJTlQzMiA9IDQyOTQ5NjcyOTVcblxuZnVuY3Rpb24gb2xkQnJvd3NlciAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignU2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci5cXG5Vc2UgQ2hyb21lLCBGaXJlZm94IG9yIEludGVybmV0IEV4cGxvcmVyIDExJylcbn1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgY3J5cHRvID0gZ2xvYmFsLmNyeXB0byB8fCBnbG9iYWwubXNDcnlwdG9cblxuaWYgKGNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmFuZG9tQnl0ZXNcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gb2xkQnJvd3NlclxufVxuXG5mdW5jdGlvbiByYW5kb21CeXRlcyAoc2l6ZSwgY2IpIHtcbiAgLy8gcGhhbnRvbWpzIG5lZWRzIHRvIHRocm93XG4gIGlmIChzaXplID4gTUFYX1VJTlQzMikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3JlcXVlc3RlZCB0b28gbWFueSByYW5kb20gYnl0ZXMnKVxuXG4gIHZhciBieXRlcyA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKVxuXG4gIGlmIChzaXplID4gMCkgeyAgLy8gZ2V0UmFuZG9tVmFsdWVzIGZhaWxzIG9uIElFIGlmIHNpemUgPT0gMFxuICAgIGlmIChzaXplID4gTUFYX0JZVEVTKSB7IC8vIHRoaXMgaXMgdGhlIG1heCBieXRlcyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzXG4gICAgICAvLyBjYW4gZG8gYXQgb25jZSBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL3dpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzXG4gICAgICBmb3IgKHZhciBnZW5lcmF0ZWQgPSAwOyBnZW5lcmF0ZWQgPCBzaXplOyBnZW5lcmF0ZWQgKz0gTUFYX0JZVEVTKSB7XG4gICAgICAgIC8vIGJ1ZmZlci5zbGljZSBhdXRvbWF0aWNhbGx5IGNoZWNrcyBpZiB0aGUgZW5kIGlzIHBhc3QgdGhlIGVuZCBvZlxuICAgICAgICAvLyB0aGUgYnVmZmVyIHNvIHdlIGRvbid0IGhhdmUgdG8gaGVyZVxuICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzLnNsaWNlKGdlbmVyYXRlZCwgZ2VuZXJhdGVkICsgTUFYX0JZVEVTKSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcylcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgY2IobnVsbCwgYnl0ZXMpXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmZ1bmN0aW9uIG9sZEJyb3dzZXIgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3NlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24gbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXJcXG51c2UgY2hyb21lLCBGaXJlRm94IG9yIEludGVybmV0IEV4cGxvcmVyIDExJylcbn1cbnZhciBzYWZlQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKVxudmFyIHJhbmRvbWJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKVxudmFyIEJ1ZmZlciA9IHNhZmVCdWZmZXIuQnVmZmVyXG52YXIga0J1ZmZlck1heExlbmd0aCA9IHNhZmVCdWZmZXIua01heExlbmd0aFxudmFyIGNyeXB0byA9IGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvXG52YXIga01heFVpbnQzMiA9IE1hdGgucG93KDIsIDMyKSAtIDFcbmZ1bmN0aW9uIGFzc2VydE9mZnNldCAob2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAhPT0gb2Zmc2V0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb2Zmc2V0IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+IGtNYXhVaW50MzIgfHwgb2Zmc2V0IDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29mZnNldCBtdXN0IGJlIGEgdWludDMyJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPiBrQnVmZmVyTWF4TGVuZ3RoIHx8IG9mZnNldCA+IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgb3V0IG9mIHJhbmdlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplLCBvZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInIHx8IHNpemUgIT09IHNpemUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHNpemUgPiBrTWF4VWludDMyIHx8IHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgdWludDMyJylcbiAgfVxuXG4gIGlmIChzaXplICsgb2Zmc2V0ID4gbGVuZ3RoIHx8IHNpemUgPiBrQnVmZmVyTWF4TGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2J1ZmZlciB0b28gc21hbGwnKVxuICB9XG59XG5pZiAoKGNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB8fCAhcHJvY2Vzcy5icm93c2VyKSB7XG4gIGV4cG9ydHMucmFuZG9tRmlsbCA9IHJhbmRvbUZpbGxcbiAgZXhwb3J0cy5yYW5kb21GaWxsU3luYyA9IHJhbmRvbUZpbGxTeW5jXG59IGVsc2Uge1xuICBleHBvcnRzLnJhbmRvbUZpbGwgPSBvbGRCcm93c2VyXG4gIGV4cG9ydHMucmFuZG9tRmlsbFN5bmMgPSBvbGRCcm93c2VyXG59XG5mdW5jdGlvbiByYW5kb21GaWxsIChidWYsIG9mZnNldCwgc2l6ZSwgY2IpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSAmJiAhKGJ1ZiBpbnN0YW5jZW9mIGdsb2JhbC5VaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBvciBVaW50OEFycmF5JylcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSAwXG4gICAgc2l6ZSA9IGJ1Zi5sZW5ndGhcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gc2l6ZVxuICAgIHNpemUgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYlwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpXG4gIH1cbiAgYXNzZXJ0T2Zmc2V0KG9mZnNldCwgYnVmLmxlbmd0aClcbiAgYXNzZXJ0U2l6ZShzaXplLCBvZmZzZXQsIGJ1Zi5sZW5ndGgpXG4gIHJldHVybiBhY3R1YWxGaWxsKGJ1Ziwgb2Zmc2V0LCBzaXplLCBjYilcbn1cblxuZnVuY3Rpb24gYWN0dWFsRmlsbCAoYnVmLCBvZmZzZXQsIHNpemUsIGNiKSB7XG4gIGlmIChwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICB2YXIgb3VyQnVmID0gYnVmLmJ1ZmZlclxuICAgIHZhciB1aW50ID0gbmV3IFVpbnQ4QXJyYXkob3VyQnVmLCBvZmZzZXQsIHNpemUpXG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh1aW50KVxuICAgIGlmIChjYikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNiKG51bGwsIGJ1ZilcbiAgICAgIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG4gIGlmIChjYikge1xuICAgIHJhbmRvbWJ5dGVzKHNpemUsIGZ1bmN0aW9uIChlcnIsIGJ5dGVzKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICB9XG4gICAgICBieXRlcy5jb3B5KGJ1Ziwgb2Zmc2V0KVxuICAgICAgY2IobnVsbCwgYnVmKVxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGJ5dGVzID0gcmFuZG9tYnl0ZXMoc2l6ZSlcbiAgYnl0ZXMuY29weShidWYsIG9mZnNldClcbiAgcmV0dXJuIGJ1ZlxufVxuZnVuY3Rpb24gcmFuZG9tRmlsbFN5bmMgKGJ1Ziwgb2Zmc2V0LCBzaXplKSB7XG4gIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIG9mZnNldCA9IDBcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpICYmICEoYnVmIGluc3RhbmNlb2YgZ2xvYmFsLlVpbnQ4QXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIG9yIFVpbnQ4QXJyYXknKVxuICB9XG5cbiAgYXNzZXJ0T2Zmc2V0KG9mZnNldCwgYnVmLmxlbmd0aClcblxuICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKSBzaXplID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuXG4gIGFzc2VydFNpemUoc2l6ZSwgb2Zmc2V0LCBidWYubGVuZ3RoKVxuXG4gIHJldHVybiBhY3R1YWxGaWxsKGJ1Ziwgb2Zmc2V0LCBzaXplKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBhdm9pZCBzY29wZSBjcmVlcCwgdGhlIGtleXMgYXJyYXkgY2FuIHRoZW4gYmUgY29sbGVjdGVkXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwbmEubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5EdXBsZXgucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICB0aGlzLmVuZCgpO1xuXG4gIHBuYS5uZXh0VGljayhjYiwgZXJyKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciByZWFkYWJsZUh3bSA9IG9wdGlvbnMucmVhZGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHJlYWRhYmxlSHdtIHx8IHJlYWRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gcmVhZGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gICAgaWYgKGVyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHBuYS5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcG5hLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcG5hLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICB2YXIgcmV0O1xuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuLy8gY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHZhciByZXQgPSBwLmRhdGE7XG4gIG4gLT0gcmV0Lmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3dyaXRlIGNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9O1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgICBfdGhpczIuZW1pdCgnY2xvc2UnKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyogPHJlcGxhY2VtZW50PiAqL1xuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwbmEubmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciB3cml0YWJsZUh3bSA9IG9wdGlvbnMud3JpdGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHdyaXRhYmxlSHdtIHx8IHdyaXRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gd3JpdGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpO1xuXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcbiAgICBwbmEubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ193cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgaWYgKGVycikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwbmEubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHBuYS5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9XG4gIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gY29ya1JlcTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMuZW5kKCk7XG4gIGNiKGVycik7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBzcmMuY29weSh0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgIH1yZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChwKSB7XG4gICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7XG5cbmlmICh1dGlsICYmIHV0aWwuaW5zcGVjdCAmJiB1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIG1vZHVsZS5leHBvcnRzLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdXRpbC5pbnNwZWN0KHsgbGVuZ3RoOiB0aGlzLmxlbmd0aCB9KTtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyAnICsgb2JqO1xuICB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIgJiYgKCF0aGlzLl93cml0YWJsZVN0YXRlIHx8ICF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIF90aGlzLCBlcnIpO1xuICAgICAgaWYgKF90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3lcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5QYXNzVGhyb3VnaFxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlRyYW5zZm9ybVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG4iLCIndXNlIHN0cmljdCdcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXJcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoQmFzZSA9IHJlcXVpcmUoJ2hhc2gtYmFzZScpXG5cbnZhciBBUlJBWTE2ID0gbmV3IEFycmF5KDE2KVxuXG52YXIgemwgPSBbXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gIDcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDgsXG4gIDMsIDEwLCAxNCwgNCwgOSwgMTUsIDgsIDEsIDIsIDcsIDAsIDYsIDEzLCAxMSwgNSwgMTIsXG4gIDEsIDksIDExLCAxMCwgMCwgOCwgMTIsIDQsIDEzLCAzLCA3LCAxNSwgMTQsIDUsIDYsIDIsXG4gIDQsIDAsIDUsIDksIDcsIDEyLCAyLCAxMCwgMTQsIDEsIDMsIDgsIDExLCA2LCAxNSwgMTNcbl1cblxudmFyIHpyID0gW1xuICA1LCAxNCwgNywgMCwgOSwgMiwgMTEsIDQsIDEzLCA2LCAxNSwgOCwgMSwgMTAsIDMsIDEyLFxuICA2LCAxMSwgMywgNywgMCwgMTMsIDUsIDEwLCAxNCwgMTUsIDgsIDEyLCA0LCA5LCAxLCAyLFxuICAxNSwgNSwgMSwgMywgNywgMTQsIDYsIDksIDExLCA4LCAxMiwgMiwgMTAsIDAsIDQsIDEzLFxuICA4LCA2LCA0LCAxLCAzLCAxMSwgMTUsIDAsIDUsIDEyLCAyLCAxMywgOSwgNywgMTAsIDE0LFxuICAxMiwgMTUsIDEwLCA0LCAxLCA1LCA4LCA3LCA2LCAyLCAxMywgMTQsIDAsIDMsIDksIDExXG5dXG5cbnZhciBzbCA9IFtcbiAgMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4LFxuICA3LCA2LCA4LCAxMywgMTEsIDksIDcsIDE1LCA3LCAxMiwgMTUsIDksIDExLCA3LCAxMywgMTIsXG4gIDExLCAxMywgNiwgNywgMTQsIDksIDEzLCAxNSwgMTQsIDgsIDEzLCA2LCA1LCAxMiwgNywgNSxcbiAgMTEsIDEyLCAxNCwgMTUsIDE0LCAxNSwgOSwgOCwgOSwgMTQsIDUsIDYsIDgsIDYsIDUsIDEyLFxuICA5LCAxNSwgNSwgMTEsIDYsIDgsIDEzLCAxMiwgNSwgMTIsIDEzLCAxNCwgMTEsIDgsIDUsIDZcbl1cblxudmFyIHNyID0gW1xuICA4LCA5LCA5LCAxMSwgMTMsIDE1LCAxNSwgNSwgNywgNywgOCwgMTEsIDE0LCAxNCwgMTIsIDYsXG4gIDksIDEzLCAxNSwgNywgMTIsIDgsIDksIDExLCA3LCA3LCAxMiwgNywgNiwgMTUsIDEzLCAxMSxcbiAgOSwgNywgMTUsIDExLCA4LCA2LCA2LCAxNCwgMTIsIDEzLCA1LCAxNCwgMTMsIDEzLCA3LCA1LFxuICAxNSwgNSwgOCwgMTEsIDE0LCAxNCwgNiwgMTQsIDYsIDksIDEyLCA5LCAxMiwgNSwgMTUsIDgsXG4gIDgsIDUsIDEyLCA5LCAxMiwgNSwgMTQsIDYsIDgsIDEzLCA2LCA1LCAxNSwgMTMsIDExLCAxMVxuXVxuXG52YXIgaGwgPSBbMHgwMDAwMDAwMCwgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhhOTUzZmQ0ZV1cbnZhciBociA9IFsweDUwYTI4YmU2LCAweDVjNGRkMTI0LCAweDZkNzAzZWYzLCAweDdhNmQ3NmU5LCAweDAwMDAwMDAwXVxuXG5mdW5jdGlvbiBSSVBFTUQxNjAgKCkge1xuICBIYXNoQmFzZS5jYWxsKHRoaXMsIDY0KVxuXG4gIC8vIHN0YXRlXG4gIHRoaXMuX2EgPSAweDY3NDUyMzAxXG4gIHRoaXMuX2IgPSAweGVmY2RhYjg5XG4gIHRoaXMuX2MgPSAweDk4YmFkY2ZlXG4gIHRoaXMuX2QgPSAweDEwMzI1NDc2XG4gIHRoaXMuX2UgPSAweGMzZDJlMWYwXG59XG5cbmluaGVyaXRzKFJJUEVNRDE2MCwgSGFzaEJhc2UpXG5cblJJUEVNRDE2MC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHdvcmRzID0gQVJSQVkxNlxuICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHdvcmRzW2pdID0gdGhpcy5fYmxvY2sucmVhZEludDMyTEUoaiAqIDQpXG5cbiAgdmFyIGFsID0gdGhpcy5fYSB8IDBcbiAgdmFyIGJsID0gdGhpcy5fYiB8IDBcbiAgdmFyIGNsID0gdGhpcy5fYyB8IDBcbiAgdmFyIGRsID0gdGhpcy5fZCB8IDBcbiAgdmFyIGVsID0gdGhpcy5fZSB8IDBcblxuICB2YXIgYXIgPSB0aGlzLl9hIHwgMFxuICB2YXIgYnIgPSB0aGlzLl9iIHwgMFxuICB2YXIgY3IgPSB0aGlzLl9jIHwgMFxuICB2YXIgZHIgPSB0aGlzLl9kIHwgMFxuICB2YXIgZXIgPSB0aGlzLl9lIHwgMFxuXG4gIC8vIGNvbXB1dGF0aW9uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkgKz0gMSkge1xuICAgIHZhciB0bFxuICAgIHZhciB0clxuICAgIGlmIChpIDwgMTYpIHtcbiAgICAgIHRsID0gZm4xKGFsLCBibCwgY2wsIGRsLCBlbCwgd29yZHNbemxbaV1dLCBobFswXSwgc2xbaV0pXG4gICAgICB0ciA9IGZuNShhciwgYnIsIGNyLCBkciwgZXIsIHdvcmRzW3pyW2ldXSwgaHJbMF0sIHNyW2ldKVxuICAgIH0gZWxzZSBpZiAoaSA8IDMyKSB7XG4gICAgICB0bCA9IGZuMihhbCwgYmwsIGNsLCBkbCwgZWwsIHdvcmRzW3psW2ldXSwgaGxbMV0sIHNsW2ldKVxuICAgICAgdHIgPSBmbjQoYXIsIGJyLCBjciwgZHIsIGVyLCB3b3Jkc1t6cltpXV0sIGhyWzFdLCBzcltpXSlcbiAgICB9IGVsc2UgaWYgKGkgPCA0OCkge1xuICAgICAgdGwgPSBmbjMoYWwsIGJsLCBjbCwgZGwsIGVsLCB3b3Jkc1t6bFtpXV0sIGhsWzJdLCBzbFtpXSlcbiAgICAgIHRyID0gZm4zKGFyLCBiciwgY3IsIGRyLCBlciwgd29yZHNbenJbaV1dLCBoclsyXSwgc3JbaV0pXG4gICAgfSBlbHNlIGlmIChpIDwgNjQpIHtcbiAgICAgIHRsID0gZm40KGFsLCBibCwgY2wsIGRsLCBlbCwgd29yZHNbemxbaV1dLCBobFszXSwgc2xbaV0pXG4gICAgICB0ciA9IGZuMihhciwgYnIsIGNyLCBkciwgZXIsIHdvcmRzW3pyW2ldXSwgaHJbM10sIHNyW2ldKVxuICAgIH0gZWxzZSB7IC8vIGlmIChpPDgwKSB7XG4gICAgICB0bCA9IGZuNShhbCwgYmwsIGNsLCBkbCwgZWwsIHdvcmRzW3psW2ldXSwgaGxbNF0sIHNsW2ldKVxuICAgICAgdHIgPSBmbjEoYXIsIGJyLCBjciwgZHIsIGVyLCB3b3Jkc1t6cltpXV0sIGhyWzRdLCBzcltpXSlcbiAgICB9XG5cbiAgICBhbCA9IGVsXG4gICAgZWwgPSBkbFxuICAgIGRsID0gcm90bChjbCwgMTApXG4gICAgY2wgPSBibFxuICAgIGJsID0gdGxcblxuICAgIGFyID0gZXJcbiAgICBlciA9IGRyXG4gICAgZHIgPSByb3RsKGNyLCAxMClcbiAgICBjciA9IGJyXG4gICAgYnIgPSB0clxuICB9XG5cbiAgLy8gdXBkYXRlIHN0YXRlXG4gIHZhciB0ID0gKHRoaXMuX2IgKyBjbCArIGRyKSB8IDBcbiAgdGhpcy5fYiA9ICh0aGlzLl9jICsgZGwgKyBlcikgfCAwXG4gIHRoaXMuX2MgPSAodGhpcy5fZCArIGVsICsgYXIpIHwgMFxuICB0aGlzLl9kID0gKHRoaXMuX2UgKyBhbCArIGJyKSB8IDBcbiAgdGhpcy5fZSA9ICh0aGlzLl9hICsgYmwgKyBjcikgfCAwXG4gIHRoaXMuX2EgPSB0XG59XG5cblJJUEVNRDE2MC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gY3JlYXRlIHBhZGRpbmcgYW5kIGhhbmRsZSBibG9ja3NcbiAgdGhpcy5fYmxvY2tbdGhpcy5fYmxvY2tPZmZzZXQrK10gPSAweDgwXG4gIGlmICh0aGlzLl9ibG9ja09mZnNldCA+IDU2KSB7XG4gICAgdGhpcy5fYmxvY2suZmlsbCgwLCB0aGlzLl9ibG9ja09mZnNldCwgNjQpXG4gICAgdGhpcy5fdXBkYXRlKClcbiAgICB0aGlzLl9ibG9ja09mZnNldCA9IDBcbiAgfVxuXG4gIHRoaXMuX2Jsb2NrLmZpbGwoMCwgdGhpcy5fYmxvY2tPZmZzZXQsIDU2KVxuICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkxFKHRoaXMuX2xlbmd0aFswXSwgNTYpXG4gIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyTEUodGhpcy5fbGVuZ3RoWzFdLCA2MClcbiAgdGhpcy5fdXBkYXRlKClcblxuICAvLyBwcm9kdWNlIHJlc3VsdFxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jID8gQnVmZmVyLmFsbG9jKDIwKSA6IG5ldyBCdWZmZXIoMjApXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fYSwgMClcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9iLCA0KVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2MsIDgpXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fZCwgMTIpXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fZSwgMTYpXG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gcm90bCAoeCwgbikge1xuICByZXR1cm4gKHggPDwgbikgfCAoeCA+Pj4gKDMyIC0gbikpXG59XG5cbmZ1bmN0aW9uIGZuMSAoYSwgYiwgYywgZCwgZSwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoYiBeIGMgXiBkKSArIG0gKyBrKSB8IDAsIHMpICsgZSkgfCAwXG59XG5cbmZ1bmN0aW9uIGZuMiAoYSwgYiwgYywgZCwgZSwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoKGIgJiBjKSB8ICgofmIpICYgZCkpICsgbSArIGspIHwgMCwgcykgKyBlKSB8IDBcbn1cblxuZnVuY3Rpb24gZm4zIChhLCBiLCBjLCBkLCBlLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArICgoYiB8ICh+YykpIF4gZCkgKyBtICsgaykgfCAwLCBzKSArIGUpIHwgMFxufVxuXG5mdW5jdGlvbiBmbjQgKGEsIGIsIGMsIGQsIGUsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKChiICYgZCkgfCAoYyAmICh+ZCkpKSArIG0gKyBrKSB8IDAsIHMpICsgZSkgfCAwXG59XG5cbmZ1bmN0aW9uIGZuNSAoYSwgYiwgYywgZCwgZSwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoYiBeIChjIHwgKH5kKSkpICsgbSArIGspIHwgMCwgcykgKyBlKSB8IDBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSSVBFTUQxNjBcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuLy8gcHJvdG90eXBlIGNsYXNzIGZvciBoYXNoIGZ1bmN0aW9uc1xuZnVuY3Rpb24gSGFzaCAoYmxvY2tTaXplLCBmaW5hbFNpemUpIHtcbiAgdGhpcy5fYmxvY2sgPSBCdWZmZXIuYWxsb2MoYmxvY2tTaXplKVxuICB0aGlzLl9maW5hbFNpemUgPSBmaW5hbFNpemVcbiAgdGhpcy5fYmxvY2tTaXplID0gYmxvY2tTaXplXG4gIHRoaXMuX2xlbiA9IDBcbn1cblxuSGFzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jID0gZW5jIHx8ICd1dGY4J1xuICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCBlbmMpXG4gIH1cblxuICB2YXIgYmxvY2sgPSB0aGlzLl9ibG9ja1xuICB2YXIgYmxvY2tTaXplID0gdGhpcy5fYmxvY2tTaXplXG4gIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aFxuICB2YXIgYWNjdW0gPSB0aGlzLl9sZW5cblxuICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBsZW5ndGg7KSB7XG4gICAgdmFyIGFzc2lnbmVkID0gYWNjdW0gJSBibG9ja1NpemVcbiAgICB2YXIgcmVtYWluZGVyID0gTWF0aC5taW4obGVuZ3RoIC0gb2Zmc2V0LCBibG9ja1NpemUgLSBhc3NpZ25lZClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVtYWluZGVyOyBpKyspIHtcbiAgICAgIGJsb2NrW2Fzc2lnbmVkICsgaV0gPSBkYXRhW29mZnNldCArIGldXG4gICAgfVxuXG4gICAgYWNjdW0gKz0gcmVtYWluZGVyXG4gICAgb2Zmc2V0ICs9IHJlbWFpbmRlclxuXG4gICAgaWYgKChhY2N1bSAlIGJsb2NrU2l6ZSkgPT09IDApIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShibG9jaylcbiAgICB9XG4gIH1cblxuICB0aGlzLl9sZW4gKz0gbGVuZ3RoXG4gIHJldHVybiB0aGlzXG59XG5cbkhhc2gucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgdmFyIHJlbSA9IHRoaXMuX2xlbiAlIHRoaXMuX2Jsb2NrU2l6ZVxuXG4gIHRoaXMuX2Jsb2NrW3JlbV0gPSAweDgwXG5cbiAgLy8gemVybyAocmVtICsgMSkgdHJhaWxpbmcgYml0cywgd2hlcmUgKHJlbSArIDEpIGlzIHRoZSBzbWFsbGVzdFxuICAvLyBub24tbmVnYXRpdmUgc29sdXRpb24gdG8gdGhlIGVxdWF0aW9uIChsZW5ndGggKyAxICsgKHJlbSArIDEpKSA9PT0gZmluYWxTaXplIG1vZCBibG9ja1NpemVcbiAgdGhpcy5fYmxvY2suZmlsbCgwLCByZW0gKyAxKVxuXG4gIGlmIChyZW0gPj0gdGhpcy5fZmluYWxTaXplKSB7XG4gICAgdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKVxuICAgIHRoaXMuX2Jsb2NrLmZpbGwoMClcbiAgfVxuXG4gIHZhciBiaXRzID0gdGhpcy5fbGVuICogOFxuXG4gIC8vIHVpbnQzMlxuICBpZiAoYml0cyA8PSAweGZmZmZmZmZmKSB7XG4gICAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJCRShiaXRzLCB0aGlzLl9ibG9ja1NpemUgLSA0KVxuXG4gIC8vIHVpbnQ2NFxuICB9IGVsc2Uge1xuICAgIHZhciBsb3dCaXRzID0gKGJpdHMgJiAweGZmZmZmZmZmKSA+Pj4gMFxuICAgIHZhciBoaWdoQml0cyA9IChiaXRzIC0gbG93Qml0cykgLyAweDEwMDAwMDAwMFxuXG4gICAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJCRShoaWdoQml0cywgdGhpcy5fYmxvY2tTaXplIC0gOClcbiAgICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkJFKGxvd0JpdHMsIHRoaXMuX2Jsb2NrU2l6ZSAtIDQpXG4gIH1cblxuICB0aGlzLl91cGRhdGUodGhpcy5fYmxvY2spXG4gIHZhciBoYXNoID0gdGhpcy5faGFzaCgpXG5cbiAgcmV0dXJuIGVuYyA/IGhhc2gudG9TdHJpbmcoZW5jKSA6IGhhc2hcbn1cblxuSGFzaC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdXBkYXRlIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3MnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2hcbiIsInZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBTSEEgKGFsZ29yaXRobSkge1xuICBhbGdvcml0aG0gPSBhbGdvcml0aG0udG9Mb3dlckNhc2UoKVxuXG4gIHZhciBBbGdvcml0aG0gPSBleHBvcnRzW2FsZ29yaXRobV1cbiAgaWYgKCFBbGdvcml0aG0pIHRocm93IG5ldyBFcnJvcihhbGdvcml0aG0gKyAnIGlzIG5vdCBzdXBwb3J0ZWQgKHdlIGFjY2VwdCBwdWxsIHJlcXVlc3RzKScpXG5cbiAgcmV0dXJuIG5ldyBBbGdvcml0aG0oKVxufVxuXG5leHBvcnRzLnNoYSA9IHJlcXVpcmUoJy4vc2hhJylcbmV4cG9ydHMuc2hhMSA9IHJlcXVpcmUoJy4vc2hhMScpXG5leHBvcnRzLnNoYTIyNCA9IHJlcXVpcmUoJy4vc2hhMjI0JylcbmV4cG9ydHMuc2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxuZXhwb3J0cy5zaGEzODQgPSByZXF1aXJlKCcuL3NoYTM4NCcpXG5leHBvcnRzLnNoYTUxMiA9IHJlcXVpcmUoJy4vc2hhNTEyJylcbiIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTAsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGRlcml2ZWQgZnJvbSBzaGExLmpzIG9mIHRoZSBzYW1lIHJlcG9zaXRvcnkuXG4gKiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIFNIQS0wIGFuZCBTSEEtMSBpcyBqdXN0IGEgYml0d2lzZSByb3RhdGUgbGVmdFxuICogb3BlcmF0aW9uIHdhcyBhZGRlZC5cbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEsgPSBbXG4gIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMgfCAwLCAweGNhNjJjMWQ2IHwgMFxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg4MClcblxuZnVuY3Rpb24gU2hhICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEsIEhhc2gpXG5cblNoYS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjBcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiByb3RsNSAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDUpIHwgKG51bSA+Pj4gMjcpXG59XG5cbmZ1bmN0aW9uIHJvdGwzMCAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDMwKSB8IChudW0gPj4+IDIpXG59XG5cbmZ1bmN0aW9uIGZ0IChzLCBiLCBjLCBkKSB7XG4gIGlmIChzID09PSAwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZClcbiAgaWYgKHMgPT09IDIpIHJldHVybiAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZClcbiAgcmV0dXJuIGIgXiBjIF4gZFxufVxuXG5TaGEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDgwOyArK2kpIFdbaV0gPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgKytqKSB7XG4gICAgdmFyIHMgPSB+fihqIC8gMjApXG4gICAgdmFyIHQgPSAocm90bDUoYSkgKyBmdChzLCBiLCBjLCBkKSArIGUgKyBXW2pdICsgS1tzXSkgfCAwXG5cbiAgICBlID0gZFxuICAgIGQgPSBjXG4gICAgYyA9IHJvdGwzMChiKVxuICAgIGIgPSBhXG4gICAgYSA9IHRcbiAgfVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbn1cblxuU2hhLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjApXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSB8IDAsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IgfCAwLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jIHwgMCwgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCB8IDAsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lIHwgMCwgMTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGFcbiIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTEsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBWZXJzaW9uIDIuMWEgQ29weXJpZ2h0IFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBkZXRhaWxzLlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgSyA9IFtcbiAgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYyB8IDAsIDB4Y2E2MmMxZDYgfCAwXG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDgwKVxuXG5mdW5jdGlvbiBTaGExICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGExLCBIYXNoKVxuXG5TaGExLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxuICB0aGlzLl9lID0gMHhjM2QyZTFmMFxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIHJvdGwxIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMSkgfCAobnVtID4+PiAzMSlcbn1cblxuZnVuY3Rpb24gcm90bDUgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCA1KSB8IChudW0gPj4+IDI3KVxufVxuXG5mdW5jdGlvbiByb3RsMzAgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCAzMCkgfCAobnVtID4+PiAyKVxufVxuXG5mdW5jdGlvbiBmdCAocywgYiwgYywgZCkge1xuICBpZiAocyA9PT0gMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpXG4gIGlmIChzID09PSAyKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpXG4gIHJldHVybiBiIF4gYyBeIGRcbn1cblxuU2hhMS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gIGZvciAoOyBpIDwgODA7ICsraSkgV1tpXSA9IHJvdGwxKFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl0pXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgKytqKSB7XG4gICAgdmFyIHMgPSB+fihqIC8gMjApXG4gICAgdmFyIHQgPSAocm90bDUoYSkgKyBmdChzLCBiLCBjLCBkKSArIGUgKyBXW2pdICsgS1tzXSkgfCAwXG5cbiAgICBlID0gZFxuICAgIGQgPSBjXG4gICAgYyA9IHJvdGwzMChiKVxuICAgIGIgPSBhXG4gICAgYSA9IHRcbiAgfVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbn1cblxuU2hhMS5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIwKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EgfCAwLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iIHwgMCwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYyB8IDAsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QgfCAwLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSB8IDAsIDE2KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMVxuIiwiLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMlxuICogVmVyc2lvbiAyLjItYmV0YSBDb3B5cmlnaHQgQW5nZWwgTWFyaW4sIFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBTaGEyNTYgPSByZXF1aXJlKCcuL3NoYTI1NicpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbmZ1bmN0aW9uIFNoYTIyNCAoKSB7XG4gIHRoaXMuaW5pdCgpXG5cbiAgdGhpcy5fdyA9IFcgLy8gbmV3IEFycmF5KDY0KVxuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTIyNCwgU2hhMjU2KVxuXG5TaGEyMjQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweGMxMDU5ZWQ4XG4gIHRoaXMuX2IgPSAweDM2N2NkNTA3XG4gIHRoaXMuX2MgPSAweDMwNzBkZDE3XG4gIHRoaXMuX2QgPSAweGY3MGU1OTM5XG4gIHRoaXMuX2UgPSAweGZmYzAwYjMxXG4gIHRoaXMuX2YgPSAweDY4NTgxNTExXG4gIHRoaXMuX2cgPSAweDY0Zjk4ZmE3XG4gIHRoaXMuX2ggPSAweGJlZmE0ZmE0XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuU2hhMjI0LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjgpXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYywgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UsIDE2KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9mLCAyMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZywgMjQpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEyMjRcbiIsIi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEsgPSBbXG4gIDB4NDI4QTJGOTgsIDB4NzEzNzQ0OTEsIDB4QjVDMEZCQ0YsIDB4RTlCNURCQTUsXG4gIDB4Mzk1NkMyNUIsIDB4NTlGMTExRjEsIDB4OTIzRjgyQTQsIDB4QUIxQzVFRDUsXG4gIDB4RDgwN0FBOTgsIDB4MTI4MzVCMDEsIDB4MjQzMTg1QkUsIDB4NTUwQzdEQzMsXG4gIDB4NzJCRTVENzQsIDB4ODBERUIxRkUsIDB4OUJEQzA2QTcsIDB4QzE5QkYxNzQsXG4gIDB4RTQ5QjY5QzEsIDB4RUZCRTQ3ODYsIDB4MEZDMTlEQzYsIDB4MjQwQ0ExQ0MsXG4gIDB4MkRFOTJDNkYsIDB4NEE3NDg0QUEsIDB4NUNCMEE5REMsIDB4NzZGOTg4REEsXG4gIDB4OTgzRTUxNTIsIDB4QTgzMUM2NkQsIDB4QjAwMzI3QzgsIDB4QkY1OTdGQzcsXG4gIDB4QzZFMDBCRjMsIDB4RDVBNzkxNDcsIDB4MDZDQTYzNTEsIDB4MTQyOTI5NjcsXG4gIDB4MjdCNzBBODUsIDB4MkUxQjIxMzgsIDB4NEQyQzZERkMsIDB4NTMzODBEMTMsXG4gIDB4NjUwQTczNTQsIDB4NzY2QTBBQkIsIDB4ODFDMkM5MkUsIDB4OTI3MjJDODUsXG4gIDB4QTJCRkU4QTEsIDB4QTgxQTY2NEIsIDB4QzI0QjhCNzAsIDB4Qzc2QzUxQTMsXG4gIDB4RDE5MkU4MTksIDB4RDY5OTA2MjQsIDB4RjQwRTM1ODUsIDB4MTA2QUEwNzAsXG4gIDB4MTlBNEMxMTYsIDB4MUUzNzZDMDgsIDB4Mjc0ODc3NEMsIDB4MzRCMEJDQjUsXG4gIDB4MzkxQzBDQjMsIDB4NEVEOEFBNEEsIDB4NUI5Q0NBNEYsIDB4NjgyRTZGRjMsXG4gIDB4NzQ4RjgyRUUsIDB4NzhBNTYzNkYsIDB4ODRDODc4MTQsIDB4OENDNzAyMDgsXG4gIDB4OTBCRUZGRkEsIDB4QTQ1MDZDRUIsIDB4QkVGOUEzRjcsIDB4QzY3MTc4RjJcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbmZ1bmN0aW9uIFNoYTI1NiAoKSB7XG4gIHRoaXMuaW5pdCgpXG5cbiAgdGhpcy5fdyA9IFcgLy8gbmV3IEFycmF5KDY0KVxuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTI1NiwgSGFzaClcblxuU2hhMjU2LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2YTA5ZTY2N1xuICB0aGlzLl9iID0gMHhiYjY3YWU4NVxuICB0aGlzLl9jID0gMHgzYzZlZjM3MlxuICB0aGlzLl9kID0gMHhhNTRmZjUzYVxuICB0aGlzLl9lID0gMHg1MTBlNTI3ZlxuICB0aGlzLl9mID0gMHg5YjA1Njg4Y1xuICB0aGlzLl9nID0gMHgxZjgzZDlhYlxuICB0aGlzLl9oID0gMHg1YmUwY2QxOVxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIGNoICh4LCB5LCB6KSB7XG4gIHJldHVybiB6IF4gKHggJiAoeSBeIHopKVxufVxuXG5mdW5jdGlvbiBtYWogKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgfCAoeiAmICh4IHwgeSkpXG59XG5cbmZ1bmN0aW9uIHNpZ21hMCAoeCkge1xuICByZXR1cm4gKHggPj4+IDIgfCB4IDw8IDMwKSBeICh4ID4+PiAxMyB8IHggPDwgMTkpIF4gKHggPj4+IDIyIHwgeCA8PCAxMClcbn1cblxuZnVuY3Rpb24gc2lnbWExICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gNiB8IHggPDwgMjYpIF4gKHggPj4+IDExIHwgeCA8PCAyMSkgXiAoeCA+Pj4gMjUgfCB4IDw8IDcpXG59XG5cbmZ1bmN0aW9uIGdhbW1hMCAoeCkge1xuICByZXR1cm4gKHggPj4+IDcgfCB4IDw8IDI1KSBeICh4ID4+PiAxOCB8IHggPDwgMTQpIF4gKHggPj4+IDMpXG59XG5cbmZ1bmN0aW9uIGdhbW1hMSAoeCkge1xuICByZXR1cm4gKHggPj4+IDE3IHwgeCA8PCAxNSkgXiAoeCA+Pj4gMTkgfCB4IDw8IDEzKSBeICh4ID4+PiAxMClcbn1cblxuU2hhMjU2LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG4gIHZhciBmID0gdGhpcy5fZiB8IDBcbiAgdmFyIGcgPSB0aGlzLl9nIHwgMFxuICB2YXIgaCA9IHRoaXMuX2ggfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgZm9yICg7IGkgPCA2NDsgKytpKSBXW2ldID0gKGdhbW1hMShXW2kgLSAyXSkgKyBXW2kgLSA3XSArIGdhbW1hMChXW2kgLSAxNV0pICsgV1tpIC0gMTZdKSB8IDBcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDY0OyArK2opIHtcbiAgICB2YXIgVDEgPSAoaCArIHNpZ21hMShlKSArIGNoKGUsIGYsIGcpICsgS1tqXSArIFdbal0pIHwgMFxuICAgIHZhciBUMiA9IChzaWdtYTAoYSkgKyBtYWooYSwgYiwgYykpIHwgMFxuXG4gICAgaCA9IGdcbiAgICBnID0gZlxuICAgIGYgPSBlXG4gICAgZSA9IChkICsgVDEpIHwgMFxuICAgIGQgPSBjXG4gICAgYyA9IGJcbiAgICBiID0gYVxuICAgIGEgPSAoVDEgKyBUMikgfCAwXG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG4gIHRoaXMuX2YgPSAoZiArIHRoaXMuX2YpIHwgMFxuICB0aGlzLl9nID0gKGcgKyB0aGlzLl9nKSB8IDBcbiAgdGhpcy5faCA9IChoICsgdGhpcy5faCkgfCAwXG59XG5cblNoYTI1Ni5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDMyKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lLCAxNilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZiwgMjApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2csIDI0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9oLCAyOClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTI1NlxuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFNIQTUxMiA9IHJlcXVpcmUoJy4vc2hhNTEyJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgVyA9IG5ldyBBcnJheSgxNjApXG5cbmZ1bmN0aW9uIFNoYTM4NCAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDEyOCwgMTEyKVxufVxuXG5pbmhlcml0cyhTaGEzODQsIFNIQTUxMilcblxuU2hhMzg0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9haCA9IDB4Y2JiYjlkNWRcbiAgdGhpcy5fYmggPSAweDYyOWEyOTJhXG4gIHRoaXMuX2NoID0gMHg5MTU5MDE1YVxuICB0aGlzLl9kaCA9IDB4MTUyZmVjZDhcbiAgdGhpcy5fZWggPSAweDY3MzMyNjY3XG4gIHRoaXMuX2ZoID0gMHg4ZWI0NGE4N1xuICB0aGlzLl9naCA9IDB4ZGIwYzJlMGRcbiAgdGhpcy5faGggPSAweDQ3YjU0ODFkXG5cbiAgdGhpcy5fYWwgPSAweGMxMDU5ZWQ4XG4gIHRoaXMuX2JsID0gMHgzNjdjZDUwN1xuICB0aGlzLl9jbCA9IDB4MzA3MGRkMTdcbiAgdGhpcy5fZGwgPSAweGY3MGU1OTM5XG4gIHRoaXMuX2VsID0gMHhmZmMwMGIzMVxuICB0aGlzLl9mbCA9IDB4Njg1ODE1MTFcbiAgdGhpcy5fZ2wgPSAweDY0Zjk4ZmE3XG4gIHRoaXMuX2hsID0gMHhiZWZhNGZhNFxuXG4gIHJldHVybiB0aGlzXG59XG5cblNoYTM4NC5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQ4KVxuXG4gIGZ1bmN0aW9uIHdyaXRlSW50NjRCRSAoaCwgbCwgb2Zmc2V0KSB7XG4gICAgSC53cml0ZUludDMyQkUoaCwgb2Zmc2V0KVxuICAgIEgud3JpdGVJbnQzMkJFKGwsIG9mZnNldCArIDQpXG4gIH1cblxuICB3cml0ZUludDY0QkUodGhpcy5fYWgsIHRoaXMuX2FsLCAwKVxuICB3cml0ZUludDY0QkUodGhpcy5fYmgsIHRoaXMuX2JsLCA4KVxuICB3cml0ZUludDY0QkUodGhpcy5fY2gsIHRoaXMuX2NsLCAxNilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2RoLCB0aGlzLl9kbCwgMjQpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9laCwgdGhpcy5fZWwsIDMyKVxuICB3cml0ZUludDY0QkUodGhpcy5fZmgsIHRoaXMuX2ZsLCA0MClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTM4NFxuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBLID0gW1xuICAweDQyOGEyZjk4LCAweGQ3MjhhZTIyLCAweDcxMzc0NDkxLCAweDIzZWY2NWNkLFxuICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxuICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuICAweDkyM2Y4MmE0LCAweGFmMTk0ZjliLCAweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4LFxuICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxuICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuICAweDcyYmU1ZDc0LCAweGYyN2I4OTZmLCAweDgwZGViMWZlLCAweDNiMTY5NmIxLFxuICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxuICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuICAweDBmYzE5ZGM2LCAweDhiOGNkNWI1LCAweDI0MGNhMWNjLCAweDc3YWM5YzY1LFxuICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxuICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuICAweDk4M2U1MTUyLCAweGVlNjZkZmFiLCAweGE4MzFjNjZkLCAweDJkYjQzMjEwLFxuICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxuICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuICAweDA2Y2E2MzUxLCAweGUwMDM4MjZmLCAweDE0MjkyOTY3LCAweDBhMGU2ZTcwLFxuICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxuICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuICAweDY1MGE3MzU0LCAweDhiYWY2M2RlLCAweDc2NmEwYWJiLCAweDNjNzdiMmE4LFxuICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxuICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuICAweGMyNGI4YjcwLCAweGQwZjg5NzkxLCAweGM3NmM1MWEzLCAweDA2NTRiZTMwLFxuICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxuICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuICAweDE5YTRjMTE2LCAweGI4ZDJkMGM4LCAweDFlMzc2YzA4LCAweDUxNDFhYjUzLFxuICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxuICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuICAweDViOWNjYTRmLCAweDc3NjNlMzczLCAweDY4MmU2ZmYzLCAweGQ2YjJiOGEzLFxuICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxuICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuICAweDkwYmVmZmZhLCAweDIzNjMxZTI4LCAweGE0NTA2Y2ViLCAweGRlODJiZGU5LFxuICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxuICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuICAweGVhZGE3ZGQ2LCAweGNkZTBlYjFlLCAweGY1N2Q0ZjdmLCAweGVlNmVkMTc4LFxuICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxuICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuICAweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0LCAweDMyY2FhYjdiLCAweDQwYzcyNDkzLFxuICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxuICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuICAweDVmY2I2ZmFiLCAweDNhZDZmYWVjLCAweDZjNDQxOThjLCAweDRhNDc1ODE3XG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDE2MClcblxuZnVuY3Rpb24gU2hhNTEyICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgMTI4LCAxMTIpXG59XG5cbmluaGVyaXRzKFNoYTUxMiwgSGFzaClcblxuU2hhNTEyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9haCA9IDB4NmEwOWU2NjdcbiAgdGhpcy5fYmggPSAweGJiNjdhZTg1XG4gIHRoaXMuX2NoID0gMHgzYzZlZjM3MlxuICB0aGlzLl9kaCA9IDB4YTU0ZmY1M2FcbiAgdGhpcy5fZWggPSAweDUxMGU1MjdmXG4gIHRoaXMuX2ZoID0gMHg5YjA1Njg4Y1xuICB0aGlzLl9naCA9IDB4MWY4M2Q5YWJcbiAgdGhpcy5faGggPSAweDViZTBjZDE5XG5cbiAgdGhpcy5fYWwgPSAweGYzYmNjOTA4XG4gIHRoaXMuX2JsID0gMHg4NGNhYTczYlxuICB0aGlzLl9jbCA9IDB4ZmU5NGY4MmJcbiAgdGhpcy5fZGwgPSAweDVmMWQzNmYxXG4gIHRoaXMuX2VsID0gMHhhZGU2ODJkMVxuICB0aGlzLl9mbCA9IDB4MmIzZTZjMWZcbiAgdGhpcy5fZ2wgPSAweGZiNDFiZDZiXG4gIHRoaXMuX2hsID0gMHgxMzdlMjE3OVxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIENoICh4LCB5LCB6KSB7XG4gIHJldHVybiB6IF4gKHggJiAoeSBeIHopKVxufVxuXG5mdW5jdGlvbiBtYWogKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgfCAoeiAmICh4IHwgeSkpXG59XG5cbmZ1bmN0aW9uIHNpZ21hMCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAyOCB8IHhsIDw8IDQpIF4gKHhsID4+PiAyIHwgeCA8PCAzMCkgXiAoeGwgPj4+IDcgfCB4IDw8IDI1KVxufVxuXG5mdW5jdGlvbiBzaWdtYTEgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMTQgfCB4bCA8PCAxOCkgXiAoeCA+Pj4gMTggfCB4bCA8PCAxNCkgXiAoeGwgPj4+IDkgfCB4IDw8IDIzKVxufVxuXG5mdW5jdGlvbiBHYW1tYTAgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMSB8IHhsIDw8IDMxKSBeICh4ID4+PiA4IHwgeGwgPDwgMjQpIF4gKHggPj4+IDcpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMGwgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMSB8IHhsIDw8IDMxKSBeICh4ID4+PiA4IHwgeGwgPDwgMjQpIF4gKHggPj4+IDcgfCB4bCA8PCAyNSlcbn1cblxuZnVuY3Rpb24gR2FtbWExICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDE5IHwgeGwgPDwgMTMpIF4gKHhsID4+PiAyOSB8IHggPDwgMykgXiAoeCA+Pj4gNilcbn1cblxuZnVuY3Rpb24gR2FtbWExbCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxOSB8IHhsIDw8IDEzKSBeICh4bCA+Pj4gMjkgfCB4IDw8IDMpIF4gKHggPj4+IDYgfCB4bCA8PCAyNilcbn1cblxuZnVuY3Rpb24gZ2V0Q2FycnkgKGEsIGIpIHtcbiAgcmV0dXJuIChhID4+PiAwKSA8IChiID4+PiAwKSA/IDEgOiAwXG59XG5cblNoYTUxMi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhaCA9IHRoaXMuX2FoIHwgMFxuICB2YXIgYmggPSB0aGlzLl9iaCB8IDBcbiAgdmFyIGNoID0gdGhpcy5fY2ggfCAwXG4gIHZhciBkaCA9IHRoaXMuX2RoIHwgMFxuICB2YXIgZWggPSB0aGlzLl9laCB8IDBcbiAgdmFyIGZoID0gdGhpcy5fZmggfCAwXG4gIHZhciBnaCA9IHRoaXMuX2doIHwgMFxuICB2YXIgaGggPSB0aGlzLl9oaCB8IDBcblxuICB2YXIgYWwgPSB0aGlzLl9hbCB8IDBcbiAgdmFyIGJsID0gdGhpcy5fYmwgfCAwXG4gIHZhciBjbCA9IHRoaXMuX2NsIHwgMFxuICB2YXIgZGwgPSB0aGlzLl9kbCB8IDBcbiAgdmFyIGVsID0gdGhpcy5fZWwgfCAwXG4gIHZhciBmbCA9IHRoaXMuX2ZsIHwgMFxuICB2YXIgZ2wgPSB0aGlzLl9nbCB8IDBcbiAgdmFyIGhsID0gdGhpcy5faGwgfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSArPSAyKSB7XG4gICAgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gICAgV1tpICsgMV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0ICsgNClcbiAgfVxuICBmb3IgKDsgaSA8IDE2MDsgaSArPSAyKSB7XG4gICAgdmFyIHhoID0gV1tpIC0gMTUgKiAyXVxuICAgIHZhciB4bCA9IFdbaSAtIDE1ICogMiArIDFdXG4gICAgdmFyIGdhbW1hMCA9IEdhbW1hMCh4aCwgeGwpXG4gICAgdmFyIGdhbW1hMGwgPSBHYW1tYTBsKHhsLCB4aClcblxuICAgIHhoID0gV1tpIC0gMiAqIDJdXG4gICAgeGwgPSBXW2kgLSAyICogMiArIDFdXG4gICAgdmFyIGdhbW1hMSA9IEdhbW1hMSh4aCwgeGwpXG4gICAgdmFyIGdhbW1hMWwgPSBHYW1tYTFsKHhsLCB4aClcblxuICAgIC8vIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XVxuICAgIHZhciBXaTdoID0gV1tpIC0gNyAqIDJdXG4gICAgdmFyIFdpN2wgPSBXW2kgLSA3ICogMiArIDFdXG5cbiAgICB2YXIgV2kxNmggPSBXW2kgLSAxNiAqIDJdXG4gICAgdmFyIFdpMTZsID0gV1tpIC0gMTYgKiAyICsgMV1cblxuICAgIHZhciBXaWwgPSAoZ2FtbWEwbCArIFdpN2wpIHwgMFxuICAgIHZhciBXaWggPSAoZ2FtbWEwICsgV2k3aCArIGdldENhcnJ5KFdpbCwgZ2FtbWEwbCkpIHwgMFxuICAgIFdpbCA9IChXaWwgKyBnYW1tYTFsKSB8IDBcbiAgICBXaWggPSAoV2loICsgZ2FtbWExICsgZ2V0Q2FycnkoV2lsLCBnYW1tYTFsKSkgfCAwXG4gICAgV2lsID0gKFdpbCArIFdpMTZsKSB8IDBcbiAgICBXaWggPSAoV2loICsgV2kxNmggKyBnZXRDYXJyeShXaWwsIFdpMTZsKSkgfCAwXG5cbiAgICBXW2ldID0gV2loXG4gICAgV1tpICsgMV0gPSBXaWxcbiAgfVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgMTYwOyBqICs9IDIpIHtcbiAgICBXaWggPSBXW2pdXG4gICAgV2lsID0gV1tqICsgMV1cblxuICAgIHZhciBtYWpoID0gbWFqKGFoLCBiaCwgY2gpXG4gICAgdmFyIG1hamwgPSBtYWooYWwsIGJsLCBjbClcblxuICAgIHZhciBzaWdtYTBoID0gc2lnbWEwKGFoLCBhbClcbiAgICB2YXIgc2lnbWEwbCA9IHNpZ21hMChhbCwgYWgpXG4gICAgdmFyIHNpZ21hMWggPSBzaWdtYTEoZWgsIGVsKVxuICAgIHZhciBzaWdtYTFsID0gc2lnbWExKGVsLCBlaClcblxuICAgIC8vIHQxID0gaCArIHNpZ21hMSArIGNoICsgS1tqXSArIFdbal1cbiAgICB2YXIgS2loID0gS1tqXVxuICAgIHZhciBLaWwgPSBLW2ogKyAxXVxuXG4gICAgdmFyIGNoaCA9IENoKGVoLCBmaCwgZ2gpXG4gICAgdmFyIGNobCA9IENoKGVsLCBmbCwgZ2wpXG5cbiAgICB2YXIgdDFsID0gKGhsICsgc2lnbWExbCkgfCAwXG4gICAgdmFyIHQxaCA9IChoaCArIHNpZ21hMWggKyBnZXRDYXJyeSh0MWwsIGhsKSkgfCAwXG4gICAgdDFsID0gKHQxbCArIGNobCkgfCAwXG4gICAgdDFoID0gKHQxaCArIGNoaCArIGdldENhcnJ5KHQxbCwgY2hsKSkgfCAwXG4gICAgdDFsID0gKHQxbCArIEtpbCkgfCAwXG4gICAgdDFoID0gKHQxaCArIEtpaCArIGdldENhcnJ5KHQxbCwgS2lsKSkgfCAwXG4gICAgdDFsID0gKHQxbCArIFdpbCkgfCAwXG4gICAgdDFoID0gKHQxaCArIFdpaCArIGdldENhcnJ5KHQxbCwgV2lsKSkgfCAwXG5cbiAgICAvLyB0MiA9IHNpZ21hMCArIG1halxuICAgIHZhciB0MmwgPSAoc2lnbWEwbCArIG1hamwpIHwgMFxuICAgIHZhciB0MmggPSAoc2lnbWEwaCArIG1hamggKyBnZXRDYXJyeSh0MmwsIHNpZ21hMGwpKSB8IDBcblxuICAgIGhoID0gZ2hcbiAgICBobCA9IGdsXG4gICAgZ2ggPSBmaFxuICAgIGdsID0gZmxcbiAgICBmaCA9IGVoXG4gICAgZmwgPSBlbFxuICAgIGVsID0gKGRsICsgdDFsKSB8IDBcbiAgICBlaCA9IChkaCArIHQxaCArIGdldENhcnJ5KGVsLCBkbCkpIHwgMFxuICAgIGRoID0gY2hcbiAgICBkbCA9IGNsXG4gICAgY2ggPSBiaFxuICAgIGNsID0gYmxcbiAgICBiaCA9IGFoXG4gICAgYmwgPSBhbFxuICAgIGFsID0gKHQxbCArIHQybCkgfCAwXG4gICAgYWggPSAodDFoICsgdDJoICsgZ2V0Q2FycnkoYWwsIHQxbCkpIHwgMFxuICB9XG5cbiAgdGhpcy5fYWwgPSAodGhpcy5fYWwgKyBhbCkgfCAwXG4gIHRoaXMuX2JsID0gKHRoaXMuX2JsICsgYmwpIHwgMFxuICB0aGlzLl9jbCA9ICh0aGlzLl9jbCArIGNsKSB8IDBcbiAgdGhpcy5fZGwgPSAodGhpcy5fZGwgKyBkbCkgfCAwXG4gIHRoaXMuX2VsID0gKHRoaXMuX2VsICsgZWwpIHwgMFxuICB0aGlzLl9mbCA9ICh0aGlzLl9mbCArIGZsKSB8IDBcbiAgdGhpcy5fZ2wgPSAodGhpcy5fZ2wgKyBnbCkgfCAwXG4gIHRoaXMuX2hsID0gKHRoaXMuX2hsICsgaGwpIHwgMFxuXG4gIHRoaXMuX2FoID0gKHRoaXMuX2FoICsgYWggKyBnZXRDYXJyeSh0aGlzLl9hbCwgYWwpKSB8IDBcbiAgdGhpcy5fYmggPSAodGhpcy5fYmggKyBiaCArIGdldENhcnJ5KHRoaXMuX2JsLCBibCkpIHwgMFxuICB0aGlzLl9jaCA9ICh0aGlzLl9jaCArIGNoICsgZ2V0Q2FycnkodGhpcy5fY2wsIGNsKSkgfCAwXG4gIHRoaXMuX2RoID0gKHRoaXMuX2RoICsgZGggKyBnZXRDYXJyeSh0aGlzLl9kbCwgZGwpKSB8IDBcbiAgdGhpcy5fZWggPSAodGhpcy5fZWggKyBlaCArIGdldENhcnJ5KHRoaXMuX2VsLCBlbCkpIHwgMFxuICB0aGlzLl9maCA9ICh0aGlzLl9maCArIGZoICsgZ2V0Q2FycnkodGhpcy5fZmwsIGZsKSkgfCAwXG4gIHRoaXMuX2doID0gKHRoaXMuX2doICsgZ2ggKyBnZXRDYXJyeSh0aGlzLl9nbCwgZ2wpKSB8IDBcbiAgdGhpcy5faGggPSAodGhpcy5faGggKyBoaCArIGdldENhcnJ5KHRoaXMuX2hsLCBobCkpIHwgMFxufVxuXG5TaGE1MTIucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg2NClcblxuICBmdW5jdGlvbiB3cml0ZUludDY0QkUgKGgsIGwsIG9mZnNldCkge1xuICAgIEgud3JpdGVJbnQzMkJFKGgsIG9mZnNldClcbiAgICBILndyaXRlSW50MzJCRShsLCBvZmZzZXQgKyA0KVxuICB9XG5cbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2FoLCB0aGlzLl9hbCwgMClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2JoLCB0aGlzLl9ibCwgOClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2NoLCB0aGlzLl9jbCwgMTYpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9kaCwgdGhpcy5fZGwsIDI0KVxuICB3cml0ZUludDY0QkUodGhpcy5fZWgsIHRoaXMuX2VsLCAzMilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2ZoLCB0aGlzLl9mbCwgNDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9naCwgdGhpcy5fZ2wsIDQ4KVxuICB3cml0ZUludDY0QkUodGhpcy5faGgsIHRoaXMuX2hsLCA1NilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTUxMlxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJ2YXIgaW5kZXhPZiA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcblxudmFyIE9iamVjdF9rZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChPYmplY3Qua2V5cykgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSByZXMucHVzaChrZXkpXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufTtcblxudmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoeHMsIGZuKSB7XG4gICAgaWYgKHhzLmZvckVhY2gpIHJldHVybiB4cy5mb3JFYWNoKGZuKVxuICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbih4c1tpXSwgaSwgeHMpO1xuICAgIH1cbn07XG5cbnZhciBkZWZpbmVQcm9wID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ18nLCB7fSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIG9ialtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cbn0oKSk7XG5cbnZhciBnbG9iYWxzID0gWydBcnJheScsICdCb29sZWFuJywgJ0RhdGUnLCAnRXJyb3InLCAnRXZhbEVycm9yJywgJ0Z1bmN0aW9uJyxcbidJbmZpbml0eScsICdKU09OJywgJ01hdGgnLCAnTmFOJywgJ051bWJlcicsICdPYmplY3QnLCAnUmFuZ2VFcnJvcicsXG4nUmVmZXJlbmNlRXJyb3InLCAnUmVnRXhwJywgJ1N0cmluZycsICdTeW50YXhFcnJvcicsICdUeXBlRXJyb3InLCAnVVJJRXJyb3InLFxuJ2RlY29kZVVSSScsICdkZWNvZGVVUklDb21wb25lbnQnLCAnZW5jb2RlVVJJJywgJ2VuY29kZVVSSUNvbXBvbmVudCcsICdlc2NhcGUnLFxuJ2V2YWwnLCAnaXNGaW5pdGUnLCAnaXNOYU4nLCAncGFyc2VGbG9hdCcsICdwYXJzZUludCcsICd1bmRlZmluZWQnLCAndW5lc2NhcGUnXTtcblxuZnVuY3Rpb24gQ29udGV4dCgpIHt9XG5Db250ZXh0LnByb3RvdHlwZSA9IHt9O1xuXG52YXIgU2NyaXB0ID0gZXhwb3J0cy5TY3JpcHQgPSBmdW5jdGlvbiBOb2RlU2NyaXB0IChjb2RlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNjcmlwdCkpIHJldHVybiBuZXcgU2NyaXB0KGNvZGUpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG59O1xuXG5TY3JpcHQucHJvdG90eXBlLnJ1bkluQ29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgaWYgKCEoY29udGV4dCBpbnN0YW5jZW9mIENvbnRleHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJuZWVkcyBhICdjb250ZXh0JyBhcmd1bWVudC5cIik7XG4gICAgfVxuICAgIFxuICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZiAoIWlmcmFtZS5zdHlsZSkgaWZyYW1lLnN0eWxlID0ge307XG4gICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIFxuICAgIHZhciB3aW4gPSBpZnJhbWUuY29udGVudFdpbmRvdztcbiAgICB2YXIgd0V2YWwgPSB3aW4uZXZhbCwgd0V4ZWNTY3JpcHQgPSB3aW4uZXhlY1NjcmlwdDtcblxuICAgIGlmICghd0V2YWwgJiYgd0V4ZWNTY3JpcHQpIHtcbiAgICAgICAgLy8gd2luLmV2YWwoKSBtYWdpY2FsbHkgYXBwZWFycyB3aGVuIHRoaXMgaXMgY2FsbGVkIGluIElFOlxuICAgICAgICB3RXhlY1NjcmlwdC5jYWxsKHdpbiwgJ251bGwnKTtcbiAgICAgICAgd0V2YWwgPSB3aW4uZXZhbDtcbiAgICB9XG4gICAgXG4gICAgZm9yRWFjaChPYmplY3Rfa2V5cyhjb250ZXh0KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB3aW5ba2V5XSA9IGNvbnRleHRba2V5XTtcbiAgICB9KTtcbiAgICBmb3JFYWNoKGdsb2JhbHMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGNvbnRleHRba2V5XSkge1xuICAgICAgICAgICAgd2luW2tleV0gPSBjb250ZXh0W2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICB2YXIgd2luS2V5cyA9IE9iamVjdF9rZXlzKHdpbik7XG5cbiAgICB2YXIgcmVzID0gd0V2YWwuY2FsbCh3aW4sIHRoaXMuY29kZSk7XG4gICAgXG4gICAgZm9yRWFjaChPYmplY3Rfa2V5cyh3aW4pLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8vIEF2b2lkIGNvcHlpbmcgY2lyY3VsYXIgb2JqZWN0cyBsaWtlIGB0b3BgIGFuZCBgd2luZG93YCBieSBvbmx5XG4gICAgICAgIC8vIHVwZGF0aW5nIGV4aXN0aW5nIGNvbnRleHQgcHJvcGVydGllcyBvciBuZXcgcHJvcGVydGllcyBpbiB0aGUgYHdpbmBcbiAgICAgICAgLy8gdGhhdCB3YXMgb25seSBpbnRyb2R1Y2VkIGFmdGVyIHRoZSBldmFsLlxuICAgICAgICBpZiAoa2V5IGluIGNvbnRleHQgfHwgaW5kZXhPZih3aW5LZXlzLCBrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgY29udGV4dFtrZXldID0gd2luW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvckVhY2goZ2xvYmFscywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gY29udGV4dCkpIHtcbiAgICAgICAgICAgIGRlZmluZVByb3AoY29udGV4dCwga2V5LCB3aW5ba2V5XSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgXG4gICAgcmV0dXJuIHJlcztcbn07XG5cblNjcmlwdC5wcm90b3R5cGUucnVuSW5UaGlzQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZXZhbCh0aGlzLmNvZGUpOyAvLyBtYXliZS4uLlxufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5Jbk5ld0NvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBjdHggPSBTY3JpcHQuY3JlYXRlQ29udGV4dChjb250ZXh0KTtcbiAgICB2YXIgcmVzID0gdGhpcy5ydW5JbkNvbnRleHQoY3R4KTtcblxuICAgIGZvckVhY2goT2JqZWN0X2tleXMoY3R4KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBjb250ZXh0W2tleV0gPSBjdHhba2V5XTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXM7XG59O1xuXG5mb3JFYWNoKE9iamVjdF9rZXlzKFNjcmlwdC5wcm90b3R5cGUpLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIGV4cG9ydHNbbmFtZV0gPSBTY3JpcHRbbmFtZV0gPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICB2YXIgcyA9IFNjcmlwdChjb2RlKTtcbiAgICAgICAgcmV0dXJuIHNbbmFtZV0uYXBwbHkocywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB9O1xufSk7XG5cbmV4cG9ydHMuY3JlYXRlU2NyaXB0ID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5TY3JpcHQoY29kZSk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBTY3JpcHQuY3JlYXRlQ29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIGNvcHkgPSBuZXcgQ29udGV4dCgpO1xuICAgIGlmKHR5cGVvZiBjb250ZXh0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3JFYWNoKE9iamVjdF9rZXlzKGNvbnRleHQpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBjb3B5W2tleV0gPSBjb250ZXh0W2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn07XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCIvKipcbiAqIFN1cHBvcnQgbW9kdWxlcyB1c2VkIGJ5IFNrZXRjaFJOTlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogRGVhbHMgd2l0aCBkZWNvbXByZXNzaW5nIGI2NCBtb2RlbHMgdG8gdWludDggYXJyYXlzLlxuICpcbiAqIEBwYXJhbSBiNjRlbmNvZGVkIFN0cmluZyBvZiBiNjQgZW5jb2RlZCBkYXRhLlxuICogQHJldHVybnMgdWludDggdmVyc2lvbiBvZiBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nVG9VaW50OGFycmF5KGI2NGVuY29kZWQ6IHN0cmluZykge1xuICBjb25zdCB1ODogVWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGF0b2IoYjY0ZW5jb2RlZClcbiAgICAuc3BsaXQoXCJcIilcbiAgICAubWFwKChjOiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICAgICAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKTtcbiAgICB9KSk7XG4gIHJldHVybiB1ODtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBiNjQgZGF0YSBpbnRvIGludDE2IGFycmF5IHZlcnNpb24uXG4gKlxuICogQHBhcmFtIGI2NGVuY29kZWQgU3RyaW5nIG9mIGI2NCBlbmNvZGVkIGRhdGEuXG4gKiBAcmV0dXJucyBpbnQxNiB2ZXJzaW9uIG9mIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb0FycmF5KGI2NGVuY29kZWQ6IHN0cmluZykge1xuICBjb25zdCB1OiBVaW50OEFycmF5ID0gc3RyaW5nVG9VaW50OGFycmF5KGI2NGVuY29kZWQpO1xuICBjb25zdCByZXN1bHQ6IEludDE2QXJyYXkgPSBuZXcgSW50MTZBcnJheSh1LmJ1ZmZlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIEZ1bmN0aW9ucyBmb3Igc2FtcGxpbmcgbm9ybWFsIG9yIGJpLW5vcm1hbHNcblxuLy8gUmFuZG9tIG51bWJlcnMgdXRpbCAoZnJvbSBodHRwczovL2dpdGh1Yi5jb20va2FycGF0aHkvcmVjdXJyZW50anMpXG5sZXQgcmV0dXJuViA9IGZhbHNlO1xubGV0IHZWYWwgPSAwLjA7XG5leHBvcnQgZnVuY3Rpb24gZ2F1c3NSYW5kb20oKTogbnVtYmVyIHtcbiAgaWYgKHJldHVyblYpIHtcbiAgICByZXR1cm5WID0gZmFsc2U7XG4gICAgcmV0dXJuIHZWYWw7XG4gIH1cbiAgY29uc3QgdSA9IDIgKiBNYXRoLnJhbmRvbSgpIC0gMTtcbiAgY29uc3QgdiA9IDIgKiBNYXRoLnJhbmRvbSgpIC0gMTtcbiAgY29uc3QgciA9IHUgKiB1ICsgdiAqIHY7XG4gIGlmIChyID09PSAwIHx8IHIgPiAxKSB7XG4gICAgcmV0dXJuIGdhdXNzUmFuZG9tKCk7XG4gIH1cbiAgY29uc3QgYyA9IE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHIpIC8gcik7XG4gIHZWYWwgPSB2ICogYzsgLy8gY2FjaGUgdGhpc1xuICByZXR1cm5WID0gdHJ1ZTtcbiAgcmV0dXJuIHUgKiBjO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRmKGE6IG51bWJlciwgYjogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAoYiAtIGEpICsgYTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByYW5kaShhOiBudW1iZXIsIGI6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoYiAtIGEpICsgYSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmFuZG4obXU6IG51bWJlciwgc3RkOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gbXUgKyBnYXVzc1JhbmRvbSgpICogc3RkO1xufVxuLy8gRnJvbSBodHRwOi8vd3d3Lm1hdGguZ3Jpbi5lZHUvfm1vb3JldC9jb3Vyc2VzL21hdGgzMzYvYml2YXJpYXRlLW5vcm1hbC5odG1sXG5leHBvcnQgZnVuY3Rpb24gYmlyYW5kbihcbiAgbXUxOiBudW1iZXIsXG4gIG11MjogbnVtYmVyLFxuICBzdGQxOiBudW1iZXIsXG4gIHN0ZDI6IG51bWJlcixcbiAgcmhvOiBudW1iZXIpOiBudW1iZXJbXSB7XG4gIGNvbnN0IHoxID0gcmFuZG4oMCwgMSk7XG4gIGNvbnN0IHoyID0gcmFuZG4oMCwgMSk7XG4gIGNvbnN0IHggPSBNYXRoLnNxcnQoMSAtIHJobyAqIHJobykgKiBzdGQxICogejEgKyByaG8gKiBzdGQxICogejIgKyBtdTE7XG4gIGNvbnN0IHkgPSBzdGQyICogejIgKyBtdTI7XG4gIHJldHVybiBbeCwgeV07XG59XG5cbi8qKlxuICogU2FtcGxlIGZyb20gYSBjYXRlZ29yaWFsIGRpc3RyaWJ1dGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FtcGxlU29mdG1heCh6U2FtcGxlOiBudW1iZXJbXSB8IEZsb2F0MzJBcnJheSk6IG51bWJlciB7XG4gIGNvbnN0IHggPSByYW5kZigwLCAxKTtcbiAgY29uc3QgTiA9IHpTYW1wbGUubGVuZ3RoO1xuICBsZXQgYWNjdW11bGF0ZSA9IDA7XG4gIGxldCBpOiBudW1iZXI7XG4gIGZvciAoaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICBhY2N1bXVsYXRlICs9IHpTYW1wbGVbaV07XG4gICAgaWYgKGFjY3VtdWxhdGUgPj0geCkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIGNvbnNvbGUubG9nKCdlcnJvciBzYW1wbGluZyBwaSBpbmRleCcpO1xuICByZXR1cm4gLTE7XG59XG5cbi8vIExlZ2FjeSBSRFAgYWxnb3JpdGhtIGltcGxlbWVudGF0aW9uLCBwb3J0ZWQgb3ZlciB0byBUeXBlU2NyaXB0LlxuXG5leHBvcnQgZnVuY3Rpb24gc2ltcGxpZnlMaW5lKFY6IG51bWJlcltdW10sIHRvbGVyYW5jZT0yLjApOiBudW1iZXJbXVtdIHtcbiAgLypcbiAgZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9hZGFtbWlsbGVyLzgyNjE0OFxuICBWIC4uLiBbW3gxLHkxXSxbeDIseTJdLC4uLl0gcG9seWxpbmVcbiAgdG9sICAuLi4gYXBwcm94aW1hdGlvbiB0b2xlcmFuY2VcbiAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBDb3B5cmlnaHQgMjAwMiwgc29mdFN1cmZlciAod3d3LnNvZnRzdXJmZXIuY29tKVxuICBUaGlzIGNvZGUgbWF5IGJlIGZyZWVseSB1c2VkIGFuZCBtb2RpZmllZCBmb3IgYW55IHB1cnBvc2VcbiAgcHJvdmlkaW5nIHRoYXQgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIGluY2x1ZGVkIHdpdGggaXQuXG4gIFNvZnRTdXJmZXIgbWFrZXMgbm8gd2FycmFudHkgZm9yIHRoaXMgY29kZSwgYW5kIGNhbm5vdCBiZSBoZWxkXG4gIGxpYWJsZSBmb3IgYW55IHJlYWwgb3IgaW1hZ2luZWQgZGFtYWdlIHJlc3VsdGluZyBmcm9tIGl0cyB1c2UuXG4gIFVzZXJzIG9mIHRoaXMgY29kZSBtdXN0IHZlcmlmeSBjb3JyZWN0bmVzcyBmb3IgdGhlaXIgYXBwbGljYXRpb24uXG4gIGh0dHA6Ly9zb2Z0c3VyZmVyLmNvbS9BcmNoaXZlL2FsZ29yaXRobV8wMjA1L2FsZ29yaXRobV8wMjA1Lmh0bVxuICAqL1xuXG4gIGNvbnN0IHRvbCA9IHRvbGVyYW5jZTtcblxuICBmdW5jdGlvbiBkaWZmKHU6IG51bWJlcltdLCB2OiBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgICByZXR1cm4gW3VbMF0gLSB2WzBdLCB1WzFdIC0gdlsxXV07XG4gIH1cbiAgZnVuY3Rpb24gZG90KHU6IG51bWJlcltdLCB2OiBudW1iZXJbXSk6IG51bWJlciB7XG4gICAgcmV0dXJuIHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV07XG4gIH1cbiAgZnVuY3Rpb24gbm9ybTIodjogbnVtYmVyW10pOiBudW1iZXIge1xuICAgIHJldHVybiB2WzBdICogdlswXSArIHZbMV0gKiB2WzFdO1xuICB9XG4gIGZ1bmN0aW9uIGQyKHU6IG51bWJlcltdLCB2OiBudW1iZXJbXSk6IG51bWJlciB7cmV0dXJuIG5vcm0yKGRpZmYodSwgdikpO31cblxuICBmdW5jdGlvbiBzaW1wbGlmeURQKHRvbDogbnVtYmVyLCB2OiBudW1iZXJbXVtdLFxuICAgIGo6IG51bWJlciwgazogbnVtYmVyLCBtazogbnVtYmVyW10pIHtcbiAgICAvKlxuICAgIFRoaXMgaXMgdGhlIERvdWdsYXMtUGV1Y2tlciByZWN1cnNpdmUgc2ltcGxpZmljYXRpb24gcm91dGluZVxuICAgIEl0IGp1c3QgbWFya3MgdmVydGljZXMgdGhhdCBhcmUgcGFydCBvZiB0aGUgc2ltcGxpZmllZCBwb2x5bGluZVxuICAgIGZvciBhcHByb3hpbWF0aW5nIHRoZSBwb2x5bGluZSBzdWJjaGFpbiB2W2pdIHRvIHZba10uXG4gICAgbWtbXSAuLi4gYXJyYXkgb2YgbWFya2VycyBtYXRjaGluZyB2ZXJ0ZXggYXJyYXkgdltdXG4gICAgKi9cbiAgICBpZiAoayA8PSBqICsgMSkgeyAvLyB0aGVyZSBpcyBub3RoaW5nIHRvIHNpbXBsaWZ5XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBhZGVxdWF0ZSBhcHByb3hpbWF0aW9uIGJ5IHNlZ21lbnQgUyBmcm9tIHZbal0gdG8gdltrXVxuICAgIGxldCBtYXhpID0gajsgLy8gaW5kZXggb2YgdmVydGV4IGZhcnRoZXN0IGZyb20gU1xuICAgIGxldCBtYXhkMiA9IDA7IC8vIGRpc3RhbmNlIHNxdWFyZWQgb2YgZmFydGhlc3QgdmVydGV4XG4gICAgY29uc3QgdG9sMiA9IHRvbCAqIHRvbDsgLy8gdG9sZXJhbmNlIHNxdWFyZWRcbiAgICBjb25zdCBTOiBudW1iZXJbXVtdID0gW3Zbal0sIHZba11dOyAvLyBzZWdtZW50IGZyb20gdltqXSB0byB2W2tdXG4gICAgY29uc3QgdTogbnVtYmVyW10gPSBkaWZmKFNbMV0sIFNbMF0pOyAvLyBzZWdtZW50IGRpcmVjdGlvbiB2ZWN0b3JcbiAgICBjb25zdCBjdTogbnVtYmVyID0gbm9ybTIodSk7IC8vIHNlZ21lbnQgbGVuZ3RoIHNxdWFyZWRcbiAgICAvKlxuICAgIHRlc3QgZWFjaCB2ZXJ0ZXggdltpXSBmb3IgbWF4IGRpc3RhbmNlIGZyb20gU1xuICAgIGNvbXB1dGUgdXNpbmcgdGhlIEZlYiAyMDAxIEFsZ29yaXRobSdzIGRpc3RfUG9pbnRfdG9fU2VnbWVudCgpXG4gICAgTm90ZTogdGhpcyB3b3JrcyBpbiBhbnkgZGltZW5zaW9uICgyRCwgM0QsIC4uLilcbiAgICAqL1xuICAgIGxldCB3OiBudW1iZXJbXTsgLy8gdmVjdG9yXG4gICAgbGV0IHBiOiBudW1iZXJbXTsgLy8gcG9pbnQsIGJhc2Ugb2YgcGVycGVuZGljdWxhciBmcm9tIHZbaV0gdG8gU1xuICAgIGxldCBiOiBudW1iZXIsIGN3OiBudW1iZXIsIGR2MjogbnVtYmVyOyAvLyBkdjIgPSBkaXN0YW5jZSB2W2ldIHRvIFMgc3F1YXJlZFxuICAgIGZvciAobGV0IGk6IG51bWJlciA9IGogKyAxOyBpIDwgazsgaSsrKSB7XG4gICAgICAvLyBjb21wdXRlIGRpc3RhbmNlIHNxdWFyZWRcbiAgICAgIHcgPSBkaWZmKHZbaV0sIFNbMF0pO1xuICAgICAgY3cgPSBkb3QodywgdSk7XG4gICAgICBpZiAoY3cgPD0gMCkge1xuICAgICAgICBkdjIgPSBkMih2W2ldLCBTWzBdKTtcbiAgICAgIH0gZWxzZSBpZiAoY3UgPD0gY3cpIHtcbiAgICAgICAgZHYyID0gZDIodltpXSwgU1sxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiID0gY3cgLyBjdTtcbiAgICAgICAgcGIgPSBbU1swXVswXSArIGIgKiB1WzBdLCBTWzBdWzFdICsgYiAqIHVbMV1dO1xuICAgICAgICBkdjIgPSBkMih2W2ldLCBwYik7XG4gICAgICB9XG4gICAgICAvLyB0ZXN0IHdpdGggY3VycmVudCBtYXggZGlzdGFuY2Ugc3F1YXJlZFxuICAgICAgaWYgKGR2MiA8PSBtYXhkMikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIHZbaV0gaXMgYSBuZXcgbWF4IHZlcnRleFxuICAgICAgbWF4aSA9IGk7XG4gICAgICBtYXhkMiA9IGR2MjtcbiAgICB9XG4gICAgaWYgKG1heGQyID4gdG9sMikgeyAvLyBlcnJvciBpcyB3b3JzZSB0aGFuIHRoZSB0b2xlcmFuY2VcbiAgICAgIC8vIHNwbGl0IHRoZSBwb2x5bGluZSBhdCB0aGUgZmFydGhlc3QgdmVydGV4IGZyb20gU1xuICAgICAgbWtbbWF4aV0gPSAxOyAvLyBtYXJrIHZbbWF4aV0gZm9yIHRoZSBzaW1wbGlmaWVkIHBvbHlsaW5lXG4gICAgICAvLyByZWN1cnNpdmVseSBzaW1wbGlmeSB0aGUgdHdvIHN1YnBvbHlsaW5lcyBhdCB2W21heGldXG4gICAgICBzaW1wbGlmeURQKHRvbCwgdiwgaiwgbWF4aSwgbWspOyAvLyBwb2x5bGluZSB2W2pdIHRvIHZbbWF4aV1cbiAgICAgIHNpbXBsaWZ5RFAodG9sLCB2LCBtYXhpLCBrLCBtayk7IC8vIHBvbHlsaW5lIHZbbWF4aV0gdG8gdltrXVxuICAgIH1cbiAgICAvLyBlbHNlIHRoZSBhcHByb3hpbWF0aW9uIGlzIE9LLCBzbyBpZ25vcmUgaW50ZXJtZWRpYXRlIHZlcnRpY2VzXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgbiA9IFYubGVuZ3RoO1xuICBjb25zdCBzVjogbnVtYmVyW11bXSA9IFtdO1xuICBsZXQgaTogbnVtYmVyLCBrOiBudW1iZXIsIG06IG51bWJlciwgcHY6IG51bWJlcjsgLy8gbWlzYyBjb3VudGVyc1xuICBjb25zdCB0b2wyOiBudW1iZXIgPSB0b2wgKiB0b2w7IC8vIHRvbGVyYW5jZSBzcXVhcmVkXG4gIGNvbnN0IHZ0OiBudW1iZXJbXVtdID0gW107IC8vIHZlcnRleCBidWZmZXIsIHBvaW50c1xuICBjb25zdCBtazogbnVtYmVyW10gPSBbXTsgLy8gbWFya2VyIGJ1ZmZlciwgaW50c1xuXG4gIC8vIFNUQUdFIDEuIFZlcnRleCBSZWR1Y3Rpb24gd2l0aGluIHRvbGVyYW5jZSBvZiBwcmlvciB2ZXJ0ZXggY2x1c3RlclxuICB2dFswXSA9IFZbMF07IC8vIHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmdcbiAgZm9yIChpID0gayA9IDEsIHB2ID0gMDsgaSA8IG47IGkrKykge1xuICAgIGlmIChkMihWW2ldLCBWW3B2XSkgPCB0b2wyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdnRbaysrXSA9IFZbaV07XG4gICAgcHYgPSBpO1xuICB9XG4gIGlmIChwdiA8IG4gLSAxKSB7XG4gICAgdnRbaysrXSA9IFZbbiAtIDFdOyAvLyBmaW5pc2ggYXQgdGhlIGVuZFxuICB9XG5cbiAgLy8gU1RBR0UgMi4gIERvdWdsYXMtUGV1Y2tlciBwb2x5bGluZSBzaW1wbGlmaWNhdGlvblxuICBta1swXSA9IG1rW2sgLSAxXSA9IDE7IC8vIG1hcmsgdGhlIGZpcnN0IGFuZCBsYXN0IHZlcnRpY2VzXG4gIHNpbXBsaWZ5RFAodG9sLCB2dCwgMCwgayAtIDEsIG1rKTtcblxuICAvLyBjb3B5IG1hcmtlZCB2ZXJ0aWNlcyB0byB0aGUgb3V0cHV0IHNpbXBsaWZpZWQgcG9seWxpbmVcbiAgZm9yIChpID0gbSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICBpZiAobWtbaV0pIHtcbiAgICAgIHNWW20rK10gPSB2dFtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNWO1xufVxuXG4vKipcbiAqIENsZWFuIHdyYXBwZXIgbWV0aG9kIHRvIHVzZSBSRFAgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaW1wbGlmeUxpbmVzKGxpbmVzOiBudW1iZXJbXVtdW10sXG4gIHRvbGVyYW5jZT86IG51bWJlcik6IG51bWJlcltdW11bXSB7XG4gIGNvbnN0IHJlc3VsdDogbnVtYmVyW11bXVtdID0gW107XG4gIGxldCB0b2wgPSAyLjA7XG4gIGlmICh0b2xlcmFuY2UpIHtcbiAgICB0b2wgPSB0b2xlcmFuY2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdC5wdXNoKHNpbXBsaWZ5TGluZShsaW5lc1tpXSwgdG9sKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGZyb20gcG9seWxpbmVzIHRvIHN0cm9rZS01IGZvcm1hdCB0aGF0IHNrZXRjaC1ybm4gdXNlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZXNUb1N0cm9rZXMocmF3RGF0YTogbnVtYmVyW11bXVtdKTogbnVtYmVyW11bXSB7XG4gIGxldCB4OiBudW1iZXIsIHk6IG51bWJlcjtcbiAgbGV0IHB4ID0gMCwgcHkgPSAwO1xuICBsZXQgZHg6IG51bWJlciwgZHk6IG51bWJlcjtcbiAgbGV0IHBvbjogbnVtYmVyLCBwb2ZmOiBudW1iZXI7XG4gIGNvbnN0IHN0cm9rZTogbnVtYmVyW11bXSA9IFtdO1xuICBsZXQgaTogbnVtYmVyLCBqOiBudW1iZXI7XG4gIGxldCBsZW46IG51bWJlcjtcbiAgbGV0IHA6IG51bWJlcltdO1xuICBmb3IgKGkgPSAwOyBpIDwgcmF3RGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGxlbiA9IHJhd0RhdGFbaV0ubGVuZ3RoO1xuICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgcCA9IHJhd0RhdGFbaV1bal07XG4gICAgICAgIHggPSBwWzBdO1xuICAgICAgICB5ID0gcFsxXTtcbiAgICAgICAgaWYgKGogPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICBwb2ZmID0gMTtcbiAgICAgICAgICBwb24gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvZmYgPSAwO1xuICAgICAgICAgIHBvbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZHggPSB4IC0gcHg7XG4gICAgICAgIGR5ID0geSAtIHB5O1xuICAgICAgICBweCA9IHg7XG4gICAgICAgIHB5ID0geTtcbiAgICAgICAgc3Ryb2tlLnB1c2goW2R4LCBkeSwgcG9uLCBwb2ZmLCAwXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0cm9rZS5wdXNoKFswLCAwLCAwLCAwLCAxXSk7XG4gIHJldHVybiBzdHJva2Uuc2xpY2UoMSk7XG59XG5cbi8qKlxuICogQ29udmVydCB0byBzdHJva2UtNSBmb3JtYXQgdG8gcG9seWxpbmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVUb1N0cm9rZShsaW5lOiBudW1iZXJbXVtdLFxuICBsYXN0UG9pbnQ6IG51bWJlcltdKTogbnVtYmVyW11bXSB7XG4gIGxldCBwb246IG51bWJlciwgcG9mZjogbnVtYmVyO1xuICBjb25zdCBzdHJva2U6IG51bWJlcltdW10gPSBbXTtcbiAgbGV0IGxlbjogbnVtYmVyO1xuICBsZXQgcDogbnVtYmVyW107XG4gIGxldCBkeDogbnVtYmVyLCBkeTogbnVtYmVyO1xuICBsZXQgeDogbnVtYmVyLCB5OiBudW1iZXI7XG4gIGxldCBweDogbnVtYmVyLCBweTogbnVtYmVyO1xuICBsZXQgajogbnVtYmVyO1xuICBweCA9IGxhc3RQb2ludFswXTtcbiAgcHkgPSBsYXN0UG9pbnRbMV07XG4gIGxlbiA9IGxpbmUubGVuZ3RoO1xuICBpZiAobGVuID4gMSkge1xuICAgIGZvciAoaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgcCA9IGxpbmVbal07XG4gICAgICB4ID0gcFswXTtcbiAgICAgIHkgPSBwWzFdO1xuICAgICAgaWYgKGogPT09IGxlbiAtIDEpIHtcbiAgICAgICAgcG9mZiA9IDE7XG4gICAgICAgIHBvbiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb2ZmID0gMDtcbiAgICAgICAgcG9uID0gMTtcbiAgICAgIH1cbiAgICAgIGR4ID0geCAtIHB4O1xuICAgICAgZHkgPSB5IC0gcHk7XG4gICAgICBweCA9IHg7XG4gICAgICBweSA9IHk7XG4gICAgICBzdHJva2UucHVzaChbZHgsIGR5LCBwb24sIHBvZmYsIDBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cm9rZTtcbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcyc7XG5leHBvcnQge3RmfTtcblxuZXhwb3J0ICogZnJvbSAnLi9za2V0Y2hfcm5uJztcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuZXhwb3J0IHtTa2V0Y2hSTk59IGZyb20gJy4vbW9kZWwnO1xuIiwiLyoqXG4gKiBDb3JlIGltcGxlbWVudGF0aW9uIGZvciBSTk4tYmFzZWQgTWFnZW50YSBza2V0Y2ggbW9kZWxzIHN1Y2ggYXMgU2tldGNoUk5OLlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBJbXBvcnRzXG4gKi9cbmltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCAqIGFzIHN1cHBvcnQgZnJvbSAnLi4vY29yZS9za2V0Y2hfc3VwcG9ydCc7XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciBKU09OIHNwZWNpZmljYXRpb24gb2YgYSBgTXVzaWNWQUVgIG1vZGVsLlxuICpcbiAqIEBwcm9wZXJ0eSBtYXhfc2VxX2xlbjogTW9kZWwgdHJhaW5lZCBvbiBkYXRhc2V0IHcvIHRoaXMgbWF4IHNlcXVlbmNlIGxlbmd0aC5cbiAqIEBwcm9wZXJ0eSBtb2RlOiBQcmUtdHJhaW5lZCBtb2RlbHMgaGF2ZSB0aGlzIHBhcmFtZXRlciBmb3IgbGVnYWN5IHJlYXNvbnMuXG4gKiAwIGZvciBWQUUsIDEgZm9yIERlY29kZXIgb25seS4gVGhpcyBtb2RlbCBpcyBEZWNvZGVyIG9ubHkgKG5vdCB1c2VkKS5cbiAqIEBwcm9wZXJ0eSBuYW1lOiBRdWlja0RyYXcgbmFtZSwgbGlrZSBjYXQsIGRvZywgZWxlcGhhbnQsIGV0Y1xuICogQHByb3BlcnR5IHNjYWxlX2ZhY3RvcjogdGhlIGZhY3RvciB0byBjb252ZXJ0IGZyb20gbmV1cmFsLW5ldHdvcmsgc3BhY2UgdG9cbiAqIHBpeGVsIHNwYWNlLiBNb3N0IHByZS10cmFpbmVkIG1vZGVscyBoYXZlIHRoaXMgbnVtYmVyIGJldHdlZW4gODAtMTIwXG4gKiBAcHJvcGVydHkgdmVyc2lvbjogUHJlLXRyYWluZWQgbW9kZWxzIGhhdmUgYSB2ZXJzaW9uIGJldHdlZW4gMS02LCBmb3JcbiAqIHRoZSBwdXJwb3NlIG9mIGV4cGVyaW1lbnRhbCByZXNlYXJjaCBsb2cuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2tldGNoUk5OSW5mbyB7XG4gIG1heF9zZXFfbGVuOiBudW1iZXI7XG4gIG1vZGU6IG51bWJlcjtcbiAgbmFtZTogc3RyaW5nO1xuICBzY2FsZV9mYWN0b3I6IG51bWJlcjtcbiAgdmVyc2lvbjogbnVtYmVyO1xufVxuXG4vKipcbiAqIEludGVyZmFjZSBmb3Igc3BlY2lmaWNhdGlvbiBvZiB0aGUgUHJvYmFiaWxpdHkgRGlzdHJpYnV0aW9uIEZ1bmN0aW9uXG4gKiBvZiBhIHBlbiBzdHJva2UuXG4gKiBcbiAqIFBsZWFzZSByZWZlciB0byBcIkEgTmV1cmFsIFJlcHJlc2VudGF0aW9uIG9mIFNrZXRjaCBEcmF3aW5nc1wiXG4gKiBodHRwczovL2FyeGl2Lm9yZy9hYnMvMTcwNC4wMzQ3N1xuICogXG4gKiBJbiBFcS4zIGlzIGFuIGV4cGxhbmF0aW9uIG9mIGFsbCBvZiB0aGVzZSBwYXJhbWV0ZXJzLlxuICogXG4gKiBCZWxvdyBpcyBhIGJyaWVmIGRlc2NyaXB0aW9uOlxuICogXG4gKiBAcHJvcGVydHkgcGk6IGNhdGVnb3JpYWwgZGlzdHJpYnV0aW9uIGZvciBtaXh0dXJlIG9mIEdhdXNzaWFuXG4gKiBAcHJvcGVydHkgbXVYOiBtZWFuIGZvciB4LWF4aXNcbiAqIEBwcm9wZXJ0eSBtdVk6IG1lYW4gZm9yIHktYXhpc1xuICogQHByb3BlcnR5IHNpZ21hWDogc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHgtYXhpc1xuICogQHByb3BlcnR5IHNpZ21hWTogc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHktYXhpc1xuICogQHByb3BlcnR5IGNvcnI6IGNvcnJlbGF0aW9uIHBhcmFtZXRlciBiZXR3ZWVuIHggYW5kIHlcbiAqIEBwcm9wZXJ0eSBwZW46IGNhdGVnb3JpY2FsIGRpc3RyaWJ1dGlvbiBmb3IgdGhlIDMgcGVuIHN0YXRlc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0cm9rZVBERiB7XG4gIHBpOiBGbG9hdDMyQXJyYXk7XG4gIG11WDogRmxvYXQzMkFycmF5O1xuICBtdVk6IEZsb2F0MzJBcnJheTtcbiAgc2lnbWFYOiBGbG9hdDMyQXJyYXk7XG4gIHNpZ21hWTogRmxvYXQzMkFycmF5O1xuICBjb3JyOiBGbG9hdDMyQXJyYXk7XG4gIHBlbjogRmxvYXQzMkFycmF5O1xufVxuXG4vKipcbiAqIFN0YXRlcyBvZiB0aGUgTFNUTSBDZWxsXG4gKiBcbiAqIExvbmctU2hvcnQgVGVybSBNZW1vcnk6IGZ0cDovL2Z0cC5pZHNpYS5jaC9wdWIvanVlcmdlbi9sc3RtLnBkZlxuICogXG4gKiBAcHJvcGVydHkgYzogbWVtb3J5IFwiY2VsbFwiIG9mIHRoZSBMU1RNLlxuICogQHByb3BlcnR5IGg6IGhpZGRlbiBzdGF0ZSAoYWxzbyB0aGUgb3V0cHV0KSBvZiB0aGUgTFNUTS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMU1RNU3RhdGUge1xuICBjOiBGbG9hdDMyQXJyYXk7XG4gIGg6IEZsb2F0MzJBcnJheTtcbn1cblxuLyoqXG4gKiBNYWluIFNrZXRjaFJOTiBtb2RlbCBjbGFzcy5cbiAqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBkZWNvZGVyIG1vZGVsIGluIGh0dHBzOi8vYXJ4aXYub3JnL2Ficy8xNzA0LjAzNDc3XG4gKiBcbiAqIFRPRE8oaGFyZG1hcnUpOiBtYWtlIGEgXCJiYXRjaFwiIGNvbnRpbnVlU2VxdWVuY2UtbGlrZSBtZXRob2RcbiAqIHRoYXQgcnVucyBmdWxseSBvbiBHUFUuXG4gKi9cbmV4cG9ydCBjbGFzcyBTa2V0Y2hSTk4ge1xuICBwcml2YXRlIGNoZWNrcG9pbnRVUkw6IHN0cmluZztcblxuICBwcml2YXRlIGZvcmdldEJpYXM6IHRmLlNjYWxhcjtcblxuICBwcml2YXRlIGluaXRpYWxpemVkOiBib29sZWFuO1xuXG4gIHB1YmxpYyBpbmZvOiBTa2V0Y2hSTk5JbmZvO1xuICBwdWJsaWMgbnVtVW5pdHM6IG51bWJlcjtcblxuICBwdWJsaWMgcGl4ZWxGYWN0b3I6IG51bWJlcjtcbiAgcHVibGljIHNjYWxlRmFjdG9yOiBudW1iZXI7XG5cbiAgLy8gcmF3IHdlaWdodHMgYW5kIGRpbWVuc2lvbnMgZGlyZWN0bHkgZnJvbSBKU09OXG4gIHByaXZhdGUgd2VpZ2h0czogRmxvYXQzMkFycmF5W107XG4gIHByaXZhdGUgd2VpZ2h0RGltczogbnVtYmVyW11bXTtcblxuICAvLyBUZW5zb3JGbG93LmpzIHdlaWdodCBtYXRyaWNlc1xuICBwcml2YXRlIG91dHB1dEtlcm5lbDogdGYuVGVuc29yMkQ7XG4gIHByaXZhdGUgb3V0cHV0QmlhczogdGYuVGVuc29yMUQ7XG4gIHByaXZhdGUgbHN0bUtlcm5lbDogdGYuVGVuc29yMkQ7XG4gIHByaXZhdGUgbHN0bUJpYXM6IHRmLlRlbnNvcjFEO1xuXG4gIHByaXZhdGUgcmF3VmFyczogdGYuVGVuc29yW107XG5cbiAgcHJpdmF0ZSBOTUlYVFVSRSA9IDIwO1xuXG4gIC8qKlxuICAgKiBgU2tldGNoUk5OYCBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIGNoZWNrcG9pbnRVUkwgUGF0aCB0byB0aGUgY2hlY2twb2ludCBkaXJlY3RvcnkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjaGVja3BvaW50VVJMOiBzdHJpbmcpIHtcbiAgICB0aGlzLmNoZWNrcG9pbnRVUkwgPSBjaGVja3BvaW50VVJMO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgbW9kZWwgaXMgaW50aWFsaXplZC5cbiAgICovXG4gIGlzSW5pdGlhbGl6ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZWQ7XG4gIH1cblxuICAvKipcbiAgICogSW5zdGFudGlhdGVzIGNsYXNzIGluZm9ybWF0aW9uIGlucHV0cyBmcm9tIHRoZSBKU09OIG1vZGVsLlxuICAgKiBUT0RPKGhhcmRtYXJ1KTogdG8gYWRkIHN1cHBvcnQgZm9yIG5ldyB0ZmpzIGNoZWNrcG9pbnRzLlxuICAgKi9cbiAgcHJpdmF0ZSBpbnN0YW50aWF0ZUZyb21KU09OKGluZm86IFNrZXRjaFJOTkluZm8sXG4gICAgd2VpZ2h0RGltczogbnVtYmVyW11bXSxcbiAgICB3ZWlnaHRTdHJpbmdzOiBzdHJpbmdbXSkge1xuXG4gICAgdGhpcy5mb3JnZXRCaWFzID0gdGYuc2NhbGFyKDEuMCk7XG4gICAgdGhpcy5pbmZvID0gaW5mbztcbiAgICB0aGlzLnNldFBpeGVsRmFjdG9yKDIuMCk7XG4gICAgdGhpcy53ZWlnaHREaW1zID0gd2VpZ2h0RGltcztcbiAgICB0aGlzLm51bVVuaXRzID0gdGhpcy53ZWlnaHREaW1zWzBdWzBdOyAvLyBzaXplIG9mIExTVE1cbiAgICBsZXQgcmF3V2VpZ2h0czogRmxvYXQzMkFycmF5O1xuICAgIGNvbnN0IG1heFdlaWdodCA9IDEwLjA7XG4gICAgdGhpcy53ZWlnaHRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3ZWlnaHRTdHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByYXdXZWlnaHRzID0gbmV3IEZsb2F0MzJBcnJheShzdXBwb3J0LnN0cmluZ1RvQXJyYXkod2VpZ2h0U3RyaW5nc1tpXSkpO1xuICAgICAgY29uc3QgTjogbnVtYmVyID0gcmF3V2VpZ2h0cy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IE47IGorKykge1xuICAgICAgICByYXdXZWlnaHRzW2pdID0gbWF4V2VpZ2h0ICogcmF3V2VpZ2h0c1tqXSAvIDMyNzY3O1xuICAgICAgfVxuICAgICAgdGhpcy53ZWlnaHRzLnB1c2gocmF3V2VpZ2h0cyk7XG4gICAgfVxuICAgIHRoaXMub3V0cHV0S2VybmVsID0gdGYudGVuc29yMmQodGhpcy53ZWlnaHRzWzBdLFxuICAgICAgW3RoaXMud2VpZ2h0RGltc1swXVswXSwgdGhpcy53ZWlnaHREaW1zWzBdWzFdXSk7XG4gICAgdGhpcy5vdXRwdXRCaWFzID0gdGYudGVuc29yMWQodGhpcy53ZWlnaHRzWzFdKTtcbiAgICBjb25zdCBsc3RtS2VybmVsWEggPSB0Zi50ZW5zb3IyZCh0aGlzLndlaWdodHNbMl0sXG4gICAgICBbdGhpcy53ZWlnaHREaW1zWzJdWzBdLCB0aGlzLndlaWdodERpbXNbMl1bMV1dKTtcbiAgICBjb25zdCBsc3RtS2VybmVsSEggPSB0Zi50ZW5zb3IyZCh0aGlzLndlaWdodHNbM10sXG4gICAgICBbdGhpcy53ZWlnaHREaW1zWzNdWzBdLCB0aGlzLndlaWdodERpbXNbM11bMV1dKTtcbiAgICBjb25zdCBheGlzID0gMDtcbiAgICB0aGlzLmxzdG1LZXJuZWwgPSB0Zi5jb25jYXQyZChbbHN0bUtlcm5lbFhILCBsc3RtS2VybmVsSEhdLCBheGlzKTtcbiAgICB0aGlzLmxzdG1CaWFzID0gdGYudGVuc29yMWQodGhpcy53ZWlnaHRzWzRdKTtcblxuICAgIHRoaXMucmF3VmFycyA9IFtcbiAgICAgIHRoaXMub3V0cHV0S2VybmVsLFxuICAgICAgdGhpcy5vdXRwdXRCaWFzLFxuICAgICAgdGhpcy5sc3RtS2VybmVsLFxuICAgICAgdGhpcy5sc3RtQmlhc1xuICAgIF07XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyB2YXJpYWJsZXMgZnJvbSB0aGUgSlNPTiBtb2RlbFxuICAgKi9cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmRpc3Bvc2UoKTtcblxuICAgIGNvbnN0IHZhcnMgPSBhd2FpdCBmZXRjaCh0aGlzLmNoZWNrcG9pbnRVUkwpXG4gICAgICAudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSk7XG5cbiAgICB0aGlzLmluc3RhbnRpYXRlRnJvbUpTT04odmFyc1swXSwgdmFyc1sxXSwgdmFyc1syXSk7XG5cbiAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBjb25zb2xlLmxvZygnSW5pdGlhbGl6ZWQgU2tldGNoUk5OLicpO1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5yYXdWYXJzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmF3VmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnJhd1ZhcnNbaV0uZGlzcG9zZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5yYXdWYXJzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5mb3JnZXRCaWFzKSB7XG4gICAgICB0aGlzLmZvcmdldEJpYXMuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5mb3JnZXRCaWFzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgaW50ZXJuYWwgRVhUUkEgZmFjdG9yIG9mIHRoaXMgbW9kZWwgKHBpeGVsIHRvIG1vZGVsIHNwYWNlKVxuICAgKlxuICAgKiBAcGFyYW0gc2NhbGUgKHRoZSBleHRyYSBzY2FsZSBmYWN0b3IgZm9yIHBpeGVsIHRvIG1vZGVsIHNwYWNlKVxuICAgKlxuICAgKiBAcmV0dXJucyBub3RoaW5nXG4gICAqL1xuICBzZXRQaXhlbEZhY3RvcihzY2FsZTogbnVtYmVyKSB7XG4gICAgLy8gZm9yIGJlc3QgZWZmZWN0LCBzZXQgdG8gMS4wIGZvciBkMyBvciBwYXBlci5qcywgMi4wIGZvciBwNS5qc1xuICAgIHRoaXMucGl4ZWxGYWN0b3IgPSBzY2FsZTtcbiAgICB0aGlzLnNjYWxlRmFjdG9yID0gdGhpcy5pbmZvLnNjYWxlX2ZhY3RvciAvIHRoaXMucGl4ZWxGYWN0b3I7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgUk5OLCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0gc3Ryb2tlIFtkeCwgZHksIHBlbkRvd24sIHBlblVwLCBwZW5FbmRdLlxuICAgKiBAcGFyYW0gc3RhdGUgcHJldmlvdXMgTFNUTVN0YXRlLlxuICAgKlxuICAgKiBAcmV0dXJucyBuZXh0IExTVE1TdGF0ZS5cbiAgICovXG4gIHVwZGF0ZShzdHJva2U6IG51bWJlcltdLCBzdGF0ZTogTFNUTVN0YXRlKSB7XG4gICAgY29uc3Qgb3V0ID0gdGYudGlkeSgoKSA9PiB7XG4gICAgICBjb25zdCBudW1Vbml0cyA9IHRoaXMubnVtVW5pdHM7XG4gICAgICBjb25zdCBzID0gdGhpcy5zY2FsZUZhY3RvcjtcbiAgICAgIGNvbnN0IG5vcm1TdHJva2UgPVxuICAgICAgICBbc3Ryb2tlWzBdL3MsIHN0cm9rZVsxXS9zLCBzdHJva2VbMl0sIHN0cm9rZVszXSwgc3Ryb2tlWzRdXTtcbiAgICAgIGNvbnN0IHggPSB0Zi50ZW5zb3IyZChub3JtU3Ryb2tlLCBbMSwgNV0pO1xuICAgICAgY29uc3QgYyA9IHRmLnRlbnNvcjJkKHN0YXRlLmMsIFsxLCBudW1Vbml0c10pO1xuICAgICAgY29uc3QgaCA9IHRmLnRlbnNvcjJkKHN0YXRlLmgsIFsxLCBudW1Vbml0c10pO1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0Zi5iYXNpY0xTVE1DZWxsKFxuICAgICAgICB0aGlzLmZvcmdldEJpYXMsXG4gICAgICAgIHRoaXMubHN0bUtlcm5lbCxcbiAgICAgICAgdGhpcy5sc3RtQmlhcyxcbiAgICAgICAgeCxcbiAgICAgICAgYyxcbiAgICAgICAgaCk7XG4gICAgICByZXR1cm4gdGYuY29uY2F0KG5ld1N0YXRlLCAxKTtcbiAgICB9KTtcbiAgICBjb25zdCBuZXdDSCA9IG91dC5kYXRhU3luYygpO1xuICAgIG91dC5kaXNwb3NlKCk7XG4gICAgY29uc3QgbmV3QyA9IG5ld0NILnNsaWNlKDAsIHRoaXMubnVtVW5pdHMpO1xuICAgIGNvbnN0IG5ld0ggPSBuZXdDSC5zbGljZSh0aGlzLm51bVVuaXRzLCB0aGlzLm51bVVuaXRzICogMik7XG4gICAgY29uc3QgZmluYWxTdGF0ZTpMU1RNU3RhdGUgPSB7XG4gICAgICBjOiBuZXcgRmxvYXQzMkFycmF5KG5ld0MpLFxuICAgICAgaDogbmV3IEZsb2F0MzJBcnJheShuZXdIKVxuICAgIH07XG4gICAgcmV0dXJuIGZpbmFsU3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgUk5OIG9uIGEgc2VyaWVzIG9mIFN0cm9rZXMsIHJldHVybnMgdGhlIG5leHQgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJva2VzIGxpc3Qgb2YgW2R4LCBkeSwgcGVuRG93biwgcGVuVXAsIHBlbkVuZF0uXG4gICAqIEBwYXJhbSBzdGF0ZSBwcmV2aW91cyBMU1RNU3RhdGUuXG4gICAqIEBwYXJhbSBzdGVwcyAoT3B0aW9uYWwpIG51bWJlciBvZiBzdGVwcyBvZiB0aGUgc3Ryb2tlIHRvIHVwZGF0ZVxuICAgKiAoZGVmYXVsdCBpcyBsZW5ndGggb2Ygc3Ryb2tlcyBsaXN0KVxuICAgKiBcbiAgICpcbiAgICogQHJldHVybnMgdGhlIGZpbmFsIExTVE1TdGF0ZS5cbiAgICovXG4gIHVwZGF0ZVN0cm9rZXMoc3Ryb2tlczogbnVtYmVyW11bXSwgc3RhdGU6IExTVE1TdGF0ZSwgc3RlcHM/OiBudW1iZXIpIHtcbiAgICBjb25zdCBvdXQgPSB0Zi50aWR5KCgpID0+IHtcbiAgICAgIGNvbnN0IG51bVVuaXRzID0gdGhpcy5udW1Vbml0cztcbiAgICAgIGNvbnN0IHMgPSB0aGlzLnNjYWxlRmFjdG9yO1xuICAgICAgbGV0IG5vcm1TdHJva2U6bnVtYmVyW107XG4gICAgICBsZXQgeDogdGYuVGVuc29yMkQ7XG4gICAgICBsZXQgYzogdGYuVGVuc29yMkQ7XG4gICAgICBsZXQgaDogdGYuVGVuc29yMkQ7XG4gICAgICBsZXQgbmV3U3RhdGU6IHRmLlRlbnNvcjJEW107XG4gICAgICBsZXQgbnVtU3RlcHMgPSBzdHJva2VzLmxlbmd0aDtcbiAgICAgIGlmIChzdGVwcykge1xuICAgICAgICBudW1TdGVwcyA9IHN0ZXBzO1xuICAgICAgfVxuICAgICAgYyA9IHRmLnRlbnNvcjJkKHN0YXRlLmMsIFsxLCBudW1Vbml0c10pO1xuICAgICAgaCA9IHRmLnRlbnNvcjJkKHN0YXRlLmgsIFsxLCBudW1Vbml0c10pO1xuICAgICAgZm9yIChsZXQgaT0wO2k8bnVtU3RlcHM7aSsrKSB7XG4gICAgICAgIG5vcm1TdHJva2UgPSBbc3Ryb2tlc1tpXVswXS9zLFxuICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZXNbaV1bMV0vcyxcbiAgICAgICAgICAgICAgICAgICAgICBzdHJva2VzW2ldWzJdLFxuICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZXNbaV1bM10sXG4gICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlc1tpXVs0XV07XG4gICAgICAgIHggPSB0Zi50ZW5zb3IyZChub3JtU3Ryb2tlLCBbMSwgNV0pO1xuICAgICAgICBuZXdTdGF0ZSA9IHRmLmJhc2ljTFNUTUNlbGwoXG4gICAgICAgICAgdGhpcy5mb3JnZXRCaWFzLFxuICAgICAgICAgIHRoaXMubHN0bUtlcm5lbCxcbiAgICAgICAgICB0aGlzLmxzdG1CaWFzLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBoKTtcbiAgICAgICAgYyA9IG5ld1N0YXRlWzBdO1xuICAgICAgICBoID0gbmV3U3RhdGVbMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGYuY29uY2F0KG5ld1N0YXRlLCAxKTtcbiAgICB9KTtcbiAgICBjb25zdCBuZXdDSCA9IG91dC5kYXRhU3luYygpO1xuICAgIG91dC5kaXNwb3NlKCk7XG4gICAgY29uc3QgbmV3QyA9IG5ld0NILnNsaWNlKDAsIHRoaXMubnVtVW5pdHMpO1xuICAgIGNvbnN0IG5ld0ggPSBuZXdDSC5zbGljZSh0aGlzLm51bVVuaXRzLCB0aGlzLm51bVVuaXRzICogMik7XG4gICAgY29uc3QgZmluYWxTdGF0ZTpMU1RNU3RhdGUgPSB7XG4gICAgICBjOiBuZXcgRmxvYXQzMkFycmF5KG5ld0MpLFxuICAgICAgaDogbmV3IEZsb2F0MzJBcnJheShuZXdIKVxuICAgIH07XG4gICAgcmV0dXJuIGZpbmFsU3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gdGhlIFJOTiBzdGF0ZSwgcmV0dXJucyB0aGUgcHJvYmFiaWx0eSBkaXN0cmlidXRpb24gZnVuY3Rpb24gKHBkZilcbiAgICogb2YgdGhlIG5leHQgc3Ryb2tlLiBPcHRpb25hbGx5IGFkanVzdCB0aGUgdGVtcGVyYXR1cmUgb2YgdGhlIHBkZiBoZXJlLlxuICAgKlxuICAgKiBAcGFyYW0gc3RhdGUgcHJldmlvdXMgTFNUTVN0YXRlLlxuICAgKiBAcGFyYW0gdGVtcGVyYXR1cmUgKE9wdGlvbmFsKSBmb3IgZHggYW5kIGR5IChkZWZhdWx0IDAuNjUpXG4gICAqIEBwYXJhbSBzb2Z0bWF4VGVtcGVyYXR1cmUgKE9wdGlvbmFsKSBmb3IgUGkgYW5kIFBlbiBkaXNjcmV0ZSBzdGF0ZXNcbiAgICogKGRlZmF1bHQgaXMgdGVtcGVyYXR1cmUgKiAwLjUgKyAwLjUsIHdoaWNoIGlzIGEgbmljZSBoZXVyaXN0aWMuKVxuICAgKlxuICAgKiBAcmV0dXJucyBTdHJva2VQREYgKHBpLCBtdVgsIG11WSwgc2lnbWFYLCBzaWdtYVksIGNvcnIsIHBlbilcbiAgICovXG4gIGdldFBERihzdGF0ZTogTFNUTVN0YXRlLFxuICAgIHRlbXBlcmF0dXJlPTAuNjUsXG4gICAgc29mdG1heFRlbXBlcmF0dXJlPzogbnVtYmVyKSB7XG4gICAgY29uc3QgdGVtcCA9IHRlbXBlcmF0dXJlO1xuICAgIGxldCBkaXNjcmV0ZVRlbXA6IG51bWJlciA9IDAuNSArIHRlbXAgKiAwLjU7IC8vIGdvb2QgaGV1cmlzdGljLlxuICAgIGlmIChzb2Z0bWF4VGVtcGVyYXR1cmUpIHtcbiAgICAgIGRpc2NyZXRlVGVtcCA9IHNvZnRtYXhUZW1wZXJhdHVyZTtcbiAgICB9XG4gICAgY29uc3QgTk9VVCA9IHRoaXMuTk1JWFRVUkU7XG4gICAgY29uc3Qgb3V0ID0gdGYudGlkeSgoKSA9PiB7XG4gICAgICBjb25zdCBudW1Vbml0cyA9IHRoaXMubnVtVW5pdHM7XG4gICAgICBjb25zdCBoID0gdGYudGVuc29yMmQoc3RhdGUuaCwgWzEsIG51bVVuaXRzXSk7XG5cbiAgICAgIGNvbnN0IHNxcnR0ZW1wID0gdGYuc2NhbGFyKE1hdGguc3FydCh0ZW1wKSk7XG4gICAgICBjb25zdCBzb2Z0dGVtcCA9IHRmLnNjYWxhcihkaXNjcmV0ZVRlbXApO1xuXG4gICAgICBjb25zdCB6ID0gdGYuYWRkKHRmLm1hdE11bChoLCB0aGlzLm91dHB1dEtlcm5lbCksIHRoaXMub3V0cHV0QmlhcylcbiAgICAgICAgLnNxdWVlemUoKTtcblxuICAgICAgY29uc3QgW3Jhd1BlbiwgcnN0XSA9IHRmLnNwbGl0KHosIFszLCBOT1VUKjZdKTtcbiAgICAgIGNvbnN0IFtyYXdQaSwgbXUxLCBtdTIsIHJhd1NpZ21hMSwgcmF3U2lnbWEyLCByYXdDb3JyXSA9IHRmLnNwbGl0KHJzdCwgNik7XG4gICAgICBjb25zdCBwZW4gPSB0Zi5zb2Z0bWF4KHJhd1Blbi5kaXYoc29mdHRlbXApKTtcbiAgICAgIGNvbnN0IHBpID0gdGYuc29mdG1heChyYXdQaS5kaXYoc29mdHRlbXApKTtcbiAgICAgIGNvbnN0IHNpZ21hMSA9IHRmLmV4cChyYXdTaWdtYTEpLm11bChzcXJ0dGVtcCk7XG4gICAgICBjb25zdCBzaWdtYTIgPSB0Zi5leHAocmF3U2lnbWEyKS5tdWwoc3FydHRlbXApO1xuICAgICAgY29uc3QgY29yciA9IHRmLnRhbmgocmF3Q29ycik7XG4gICAgICBjb25zdCByZXN1bHQgPSBbcGksIG11MSwgbXUyLCBzaWdtYTEsIHNpZ21hMiwgY29yciwgcGVuXTtcbiAgICAgIC8vIGNvbmNhdCwgYW5kIHRoZW4gdW5wYWNrIGFmdGVyIGRhdGFTeW5jXG4gICAgICByZXR1cm4gdGYuY29uY2F0KHJlc3VsdCk7XG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gb3V0LmRhdGFTeW5jKCk7XG4gICAgb3V0LmRpc3Bvc2UoKTtcbiAgICBjb25zdCBwZGY6U3Ryb2tlUERGID0geyAvLyBub3RlOiBKUyBkb2Vzbid0IGhhdmUgYSBuaWNlIFwic3BsaXRcIiBtZXRob2QuXG4gICAgICBwaTogbmV3IEZsb2F0MzJBcnJheShyZXN1bHQuc2xpY2UoMCwgTk9VVCkpLFxuICAgICAgbXVYOiBuZXcgRmxvYXQzMkFycmF5KHJlc3VsdC5zbGljZSgxKk5PVVQsIDIqTk9VVCkpLFxuICAgICAgbXVZOiBuZXcgRmxvYXQzMkFycmF5KHJlc3VsdC5zbGljZSgyKk5PVVQsIDMqTk9VVCkpLFxuICAgICAgc2lnbWFYOiBuZXcgRmxvYXQzMkFycmF5KHJlc3VsdC5zbGljZSgzKk5PVVQsIDQqTk9VVCkpLFxuICAgICAgc2lnbWFZOiBuZXcgRmxvYXQzMkFycmF5KHJlc3VsdC5zbGljZSg0Kk5PVVQsIDE1Kk5PVVQpKSxcbiAgICAgIGNvcnI6IG5ldyBGbG9hdDMyQXJyYXkocmVzdWx0LnNsaWNlKDUqTk9VVCwgNipOT1VUKSksXG4gICAgICBwZW46IG5ldyBGbG9hdDMyQXJyYXkocmVzdWx0LnNsaWNlKDYqTk9VVCwgNipOT1VUKzMpKVxuICAgIH07XG4gICAgcmV0dXJuIHBkZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB6ZXJvL2luaXRpYWwgc3RhdGUgb2YgdGhlIG1vZGVsXG4gICAqXG4gICAqIEByZXR1cm5zIHplcm8gc3RhdGUgb2YgdGhlIGxzdG06IFtjLCBoXSwgd2hlcmUgYyBhbmQgaCBhcmUgemVybyB2ZWN0b3JzLlxuICAgKi9cbiAgemVyb1N0YXRlKCkge1xuICAgIGNvbnN0IHJlc3VsdDpMU1RNU3RhdGUgPSB7XG4gICAgICBjOiBuZXcgRmxvYXQzMkFycmF5KHRoaXMubnVtVW5pdHMpLFxuICAgICAgaDogbmV3IEZsb2F0MzJBcnJheSh0aGlzLm51bVVuaXRzKVxuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IGNvcHkgb2YgdGhlIHJubiBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gcm5uU3RhdGUgb3JpZ2luYWwgTFNUTVN0YXRlXG4gICAqXG4gICAqIEByZXR1cm5zIGNvcHkgb2YgTFNUTVN0YXRlXG4gICAqL1xuICBjb3B5U3RhdGUocm5uU3RhdGU6IExTVE1TdGF0ZSkge1xuICAgIGNvbnN0IHJlc3VsdDpMU1RNU3RhdGUgPSB7XG4gICAgICBjOiBuZXcgRmxvYXQzMkFycmF5KHJublN0YXRlLmMpLFxuICAgICAgaDogbmV3IEZsb2F0MzJBcnJheShybm5TdGF0ZS5oKVxuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB6ZXJvIGlucHV0IHN0YXRlIG9mIHRoZSBtb2RlbFxuICAgKlxuICAgKiBAcmV0dXJucyBbMCwgMCwgMSwgMCwgMF0uXG4gICAqL1xuICB6ZXJvSW5wdXQoKSB7XG4gICAgcmV0dXJuIFswLCAwLCAxLCAwLCAwXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYW1wbGVzIHRoZSBuZXh0IHBvaW50IG9mIHRoZSBza2V0Y2ggZ2l2ZW4gcGRmIHBhcmFtZXRlcnNcbiAgICpcbiAgICogQHBhcmFtIHBkZiByZXN1bHQgZnJvbSBnZXRQREYoKSBjYWxsXG4gICAqXG4gICAqIEByZXR1cm5zIFtkeCwgZHksIHBlbkRvd24sIHBlblVwLCBwZW5FbmRdXG4gICAqL1xuICBzYW1wbGUocGRmOiBTdHJva2VQREYpIHtcbiAgICAvLyBwZGYgaXMgYSBTdHJva2VQREYgSW50ZXJmYWNlXG4gICAgLy8gcmV0dXJucyBbeCwgeSwgZW9zXVxuICAgIGNvbnN0IGlkeCA9IHN1cHBvcnQuc2FtcGxlU29mdG1heChwZGYucGkpO1xuICAgIGNvbnN0IG11MSA9IHBkZi5tdVhbaWR4XTtcbiAgICBjb25zdCBtdTIgPSBwZGYubXVZW2lkeF07XG4gICAgY29uc3Qgc2lnbWExID0gcGRmLnNpZ21hWFtpZHhdO1xuICAgIGNvbnN0IHNpZ21hMiA9IHBkZi5zaWdtYVlbaWR4XTtcbiAgICBjb25zdCBjb3JyID0gcGRmLmNvcnJbaWR4XTtcbiAgICBjb25zdCBwZW5JZHggPSBzdXBwb3J0LnNhbXBsZVNvZnRtYXgocGRmLnBlbik7XG4gICAgY29uc3QgcGVuc3RhdGUgPSBbMCwgMCwgMF07XG4gICAgcGVuc3RhdGVbcGVuSWR4XSA9IDE7XG4gICAgY29uc3QgZGVsdGEgPSBzdXBwb3J0LmJpcmFuZG4obXUxLCBtdTIsIHNpZ21hMSwgc2lnbWEyLCBjb3JyKTtcbiAgICBjb25zdCBzdHJva2UgPSBbXG4gICAgICBkZWx0YVswXSAqIHRoaXMuc2NhbGVGYWN0b3IsXG4gICAgICBkZWx0YVsxXSAqIHRoaXMuc2NhbGVGYWN0b3IsXG4gICAgICBwZW5zdGF0ZVswXSxcbiAgICAgIHBlbnN0YXRlWzFdLFxuICAgICAgcGVuc3RhdGVbMl1cbiAgICBdO1xuICAgIHJldHVybiBzdHJva2U7XG4gIH1cblxuICAvKipcbiAgICogU2ltcGxpZmllcyBsaW5lIHVzaW5nIFJEUCBhbGdvcml0aG1cbiAgICpcbiAgICogQHBhcmFtIGxpbmUgbGlzdCBvZiBwb2ludHMgW1t4MCwgeTBdLCBbeDEsIHkxXSwgLi4uXVxuICAgKiBAcGFyYW0gdG9sZXJhbmNlIChPcHRpb25hbCkgZGVmYXVsdCAyLjBcbiAgICpcbiAgICogQHJldHVybnMgc2ltcGlmaWVkIGxpbmUgW1t4MCcsIHkwJ10sIFt4MScsIHkxJ10sIC4uLl1cbiAgICovXG4gIHNpbXBsaWZ5TGluZShsaW5lOiBudW1iZXJbXVtdLCB0b2xlcmFuY2U/OiBudW1iZXIpIHtcbiAgICByZXR1cm4gc3VwcG9ydC5zaW1wbGlmeUxpbmUobGluZSwgdG9sZXJhbmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW1wbGlmaWVzIGxpbmVzIHVzaW5nIFJEUCBhbGdvcml0aG1cbiAgICpcbiAgICogQHBhcmFtIGxpbmUgbGlzdCBvZiBsaW5lcyAoZWFjaCBlbGVtZW50IGlzIFtbeDAsIHkwXSwgW3gxLCB5MV0sIC4uLl0pXG4gICAqIEBwYXJhbSB0b2xlcmFuY2UgKE9wdGlvbmFsKSBkZWZhdWx0IDIuMFxuICAgKlxuICAgKiBAcmV0dXJucyBzaW1waWZpZWQgbGluZXMgKGVhY2ggZWxlbSBpcyBbW3gwJywgeTAnXSwgW3gxJywgeTEnXSwgLi4uXSlcbiAgICovXG4gIHNpbXBsaWZ5TGluZXMobGluZXM6IG51bWJlcltdW11bXSwgdG9sZXJhbmNlPzogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHN1cHBvcnQuc2ltcGxpZnlMaW5lcyhsaW5lcywgdG9sZXJhbmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGZyb20gcG9seWxpbmVzIHRvIHN0cm9rZS01IGZvcm1hdCB0aGF0IHNrZXRjaC1ybm4gdXNlc1xuICAgKlxuICAgKiBAcGFyYW0gbGluZXMgbGlzdCBvZiBwb2ludHMgZWFjaCBlbGVtIGlzIChbW3gwLCB5MF0sIFt4MSwgeTFdLCAuLi5dKVxuICAgKlxuICAgKiBAcmV0dXJucyBzdHJva2UtNSBmb3JtYXQgb2YgdGhlIGxpbmUsIGxpc3Qgb2YgW2R4LCBkeSwgcDAsIHAxLCBwMl1cbiAgICovXG4gIGxpbmVzVG9TdHJva2UobGluZXM6IG51bWJlcltdW11bXSkge1xuICAgIHJldHVybiBzdXBwb3J0LmxpbmVzVG9TdHJva2VzKGxpbmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGZyb20gYSBsaW5lIGZvcm1hdCB0byBzdHJva2UtNVxuICAgKlxuICAgKiBAcGFyYW0gbGluZSBsaXN0IG9mIHBvaW50cyBbW3gwLCB5MF0sIFt4MSwgeTFdLCAuLi5dXG4gICAqIEBwYXJhbSBsYXN0UG9pbnQgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBsYXN0IHBvaW50XG4gICAqXG4gICAqIEByZXR1cm5zIHN0cm9rZS01IGZvcm1hdCBvZiB0aGUgbGluZSwgbGlzdCBvZiBbZHgsIGR5LCBwMCwgcDEsIHAyXVxuICAgKi9cbiAgbGluZVRvU3Ryb2tlKGxpbmU6IG51bWJlcltdW10sIGxhc3RQb2ludDogbnVtYmVyW10pIHtcbiAgICByZXR1cm4gc3VwcG9ydC5saW5lVG9TdHJva2UobGluZSwgbGFzdFBvaW50KTtcbiAgfVxuXG59XG4iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iXSwic291cmNlUm9vdCI6IiJ9